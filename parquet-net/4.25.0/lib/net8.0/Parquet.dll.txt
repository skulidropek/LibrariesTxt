[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetBox.Ascii85 : object {
    public string PrefixMark;
    public string SuffixMark;
    public int LineLength;
    private static int _asciiOffset;
    private Byte[] _encodedBlock;
    private Byte[] _decodedBlock;
    private UInt32 _tuple;
    private int _linePos;
    private UInt32[] pow85;
    private static Ascii85 _instance;
    public static Ascii85 Instance { get; }
    private static Ascii85();
    public static Ascii85 get_Instance();
    public Byte[] Decode(string s, bool enforceMarks);
    public string Encode(Byte[] ba, bool enforceMarks);
    private void EncodeBlock(StringBuilder sb);
    private void EncodeBlock(int count, StringBuilder sb);
    private void DecodeBlock();
    private void DecodeBlock(int bytes);
    private void AppendString(StringBuilder sb, string s);
    private void AppendChar(StringBuilder sb, char c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NetBox.ByteFormat : object {
    private static long Kb;
    private static long KiB;
    private static long Mb;
    private static long MiB;
    private static long Gb;
    private static long GiB;
    private static long Tb;
    private static long TiB;
    private static long Pb;
    private static long PiB;
    private static string ToString(long bytes, Standard st);
    public static string ToString(long bytes, Standard st, string customFormat);
    private static string BytesToPb(long bytes, string customFormat);
    private static string BytesToPib(long bytes, string customFormat);
    private static string BytesToTb(long bytes, string customFormat);
    private static string BytesToTib(long bytes, string customFormat);
    private static string BytesToGb(long bytes, string customFormat);
    private static string BytesToGib(long bytes, string customFormat);
    private static string BytesToMb(long bytes, string customFormat);
    private static string BytesToMib(long bytes, string customFormat);
    private static string BytesToKb(long bytes, string customFormat);
    private static string BytesToKib(long bytes, string customFormat);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NetBox.FileFormats.Csv.CsvFormat : object {
    public static char ValueSeparator;
    public static char ValueQuote;
    public static string ValueQuoteStr;
    public static string ValueQuoteStrStr;
    private static Char[] QuoteMark;
    public static Char[] NewLine;
    private static string ValueLeftBracket;
    private static string ValueRightBracket;
    private static string ValueEscapeFind;
    private static string ValueEscapeValue;
    private static CsvFormat();
    public static string EscapeValue(string value);
    public static string UnescapeValue(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetBox.FileFormats.Csv.CsvReader : object {
    private StreamReader _reader;
    private Char[] _buffer;
    private static int BufferSize;
    private int _pos;
    private int _size;
    private List`1<char> _chars;
    private List`1<string> _row;
    private ValueState _lastState;
    public CsvReader(Stream stream, Encoding encoding);
    public static Dictionary`2<string, List`1<string>> ReadAllFromContent(string content, bool hasColumns);
    public String[] ReadNextRow();
    private string Str();
    private ValueState ReadNextValue();
    private bool NextChars(Int32& curr, Int32& next);
    private bool NextBlock();
    private static bool IsLineEndChar(int ch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetBox.FileFormats.Csv.CsvWriter : object {
    private Stream _destination;
    private Encoding _encoding;
    private Byte[] _newLine;
    private Byte[] _separator;
    private bool _firstRowWritten;
    public CsvWriter(Stream destination);
    public CsvWriter(string fileName);
    public CsvWriter(Stream destination, Encoding encoding);
    public void Write(String[] values);
    public void Write(IEnumerable`1<string> values);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetBox.FileFormats.Ini.IniComment : IniEntity {
    public static string CommentSeparator;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; public set; }
    public IniComment(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    public virtual string ToString();
}
internal abstract class NetBox.FileFormats.Ini.IniEntity : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetBox.FileFormats.Ini.IniKeyValue : IniEntity {
    public static string KeyValueSeparator;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IniComment <Comment>k__BackingField;
    public string Key { get; }
    public string Value { get; public set; }
    [NullableAttribute("2")]
public IniComment Comment { get; }
    public IniKeyValue(string key, string value, string comment);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IniComment get_Comment();
    public static IniKeyValue FromLine(string line, bool parseInlineComments);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetBox.FileFormats.Ini.IniSection : object {
    public static string SectionKeySeparator;
    private List`1<IniEntity> _entities;
    private Dictionary`2<string, IniKeyValue> _keyToValue;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NullableAttribute("2")]
public string Name { get; public set; }
    public String[] Keys { get; }
    [NullableContextAttribute("2")]
public IniSection(string name);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Name(string value);
    public void Add(IniEntity entity);
    public String[] get_Keys();
    [NullableContextAttribute("2")]
public IniKeyValue Set(string key, string value);
    public static void SplitKey(string fullKey, String& sectionName, String& keyName);
    public void WriteTo(StreamWriter writer);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class NetBox.FileFormats.Ini.StructuredIniFile : object {
    private static string _sectionBegin;
    private static string _sectionEnd;
    private static Char[] _sectionTrims;
    private IniSection _globalSection;
    private List`1<IniSection> _sections;
    private Dictionary`2<string, IniKeyValue> _fullKeyNameToValue;
    public String[] SectionNames { get; }
    [NullableAttribute("2")]
public string Item { get; public set; }
    private static StructuredIniFile();
    public String[] get_SectionNames();
    public String[] GetSectionKeys(string sectionName);
    public string get_Item(string key);
    public void set_Item(string key, string value);
    public static StructuredIniFile FromString(string content, bool parseInlineComments);
    public static StructuredIniFile FromStream(Stream inputStream, bool parseInlineComments);
    public void WriteTo(Stream outputStream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NetBox.Generator.RandomGenerator : object {
    private static RandomNumberGenerator Rnd;
    public static bool RandomBool { get; }
    public static long RandomLong { get; }
    public static int RandomInt { get; }
    public static double RandomDouble { get; }
    public static DateTime RandomDate { get; }
    public static string RandomString { get; }
    [NullableAttribute("2")]
public static Uri RandomUri { get; }
    private static RandomGenerator();
    private static double NextCryptoDouble();
    private static int NextCryptoInt();
    public static bool get_RandomBool();
    public static long get_RandomLong();
    public static int get_RandomInt();
    public static double get_RandomDouble();
    public static int GetRandomInt(int max);
    public static int GetRandomInt(int min, int max);
    public static long GetRandomLong(long min, long max);
    public static Enum RandomEnum(Type t);
    [NullableContextAttribute("0")]
public static Nullable`1<T> GetRandomEnum();
    public static DateTime GetRandomDate(DateTime minValue, DateTime maxValue);
    public static DateTime get_RandomDate();
    public static string get_RandomString();
    [NullableContextAttribute("2")]
public static string GetRandomString(int length, bool allowNulls);
    [NullableContextAttribute("2")]
public static Uri GetRandomUri(bool allowNulls);
    [NullableContextAttribute("2")]
public static Uri get_RandomUri();
    public static Byte[] GetRandomBytes(int minSize, int maxSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetBox.IO.DelegatedStream : Stream {
    private Stream _master;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public DelegatedStream(Stream master);
    public virtual bool get_CanRead();
    protected virtual bool GetCanRead();
    public virtual bool get_CanSeek();
    protected virtual bool GetCanSeek();
    public virtual bool get_CanWrite();
    protected virtual bool GetCanWrite();
    public virtual long get_Length();
    protected virtual long GetLength();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal class NetBox.IO.NonCloseableStream : DelegatedStream {
    [NullableContextAttribute("1")]
public NonCloseableStream(Stream master);
    protected virtual void Dispose(bool disposing);
}
internal class NetBox.Performance.TimeMeasure : object {
    [NullableAttribute("1")]
private Stopwatch _sw;
    public long ElapsedTicks { get; }
    public long ElapsedMilliseconds { get; }
    public TimeSpan Elapsed { get; }
    public long get_ElapsedTicks();
    public long get_ElapsedMilliseconds();
    public TimeSpan get_Elapsed();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetBox.TempFile : object {
    [CompilerGeneratedAttribute]
private string <FullPath>k__BackingField;
    public string FullPath { get; }
    [NullableContextAttribute("2")]
public TempFile(string ext);
    [CompilerGeneratedAttribute]
public string get_FullPath();
    public static string op_Implicit(TempFile tf);
    public virtual string ToString();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class NetBox.WebUtility : object {
    public static string UrlEncode(string value);
    public static string UrlDecode(string encodedValue);
    private static Byte[] UrlEncode(Byte[] bytes, int offset, int count, bool alwaysCreateNewReturnValue);
    private static Byte[] UrlEncode(Byte[] bytes, int offset, int count);
    private static bool ValidateUrlEncodingParameters(Byte[] bytes, int offset, int count);
    private static bool IsUrlSafeChar(char ch);
    private static char IntToHex(int n);
    private static string UrlDecodeInternal(string value, Encoding encoding);
    private static int HexToInt(char h);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Parquet.CollectionExtensions : object {
    [ExtensionAttribute]
public static void TrimTail(IList list, int maxValues);
    [ExtensionAttribute]
public static void TrimHead(IList list, int maxValues);
    [IteratorStateMachineAttribute("Parquet.CollectionExtensions/<Batch>d__2`1")]
[ExtensionAttribute]
public static IEnumerable`1<IEnumerable`1<T>> Batch(IEnumerable`1<T> source, int size);
    [ExtensionAttribute]
public static IEnumerable`1<Tuple`2<TFirst, TSecond>> IterateWith(IEnumerable`1<TFirst> firstSource, IEnumerable`1<TSecond> secondSource);
    [ExtensionAttribute]
public static T[] Append(T[] array, T value);
}
public enum Parquet.CompressionMethod : Enum {
    public int value__;
    public static CompressionMethod None;
    public static CompressionMethod Snappy;
    public static CompressionMethod Gzip;
    public static CompressionMethod Lzo;
    public static CompressionMethod Brotli;
    public static CompressionMethod LZ4;
    public static CompressionMethod Zstd;
    public static CompressionMethod Lz4Raw;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Parquet.Data.Analysis.DataFrameMapper : object {
    public static DataFrameColumn ToDataFrameColumn(DataColumn dc);
    public static void AppendValues(DataFrameColumn dfc, DataColumn dc);
    public static Array GetTypedDataFast(DataFrameColumn col);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Data.DataColumn : object {
    [NullableAttribute("2")]
private Array _data;
    [CompilerGeneratedAttribute]
private DataField <Field>k__BackingField;
    [CompilerGeneratedAttribute]
private Array <DefinedData>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Int32[] <DefinitionLevels>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Int32[] <RepetitionLevels>k__BackingField;
    [CompilerGeneratedAttribute]
private DataColumnStatistics <Statistics>k__BackingField;
    public DataField Field { get; private set; }
    public Array DefinedData { get; private set; }
    public Array Data { get; }
    [NullableAttribute("2")]
public Int32[] DefinitionLevels { get; }
    [NullableAttribute("2")]
public Int32[] RepetitionLevels { get; }
    public bool HasRepetitions { get; }
    public bool HasDefinitions { get; }
    public DataColumnStatistics Statistics { get; internal set; }
    public int NumValues { get; }
    internal bool IsDeltaEncodable { get; }
    private DataColumn(DataField field, Array data, Int32[] definitionLevels, Int32[] repetitionLevels, bool dataMayContainNulls);
    public DataColumn(DataField field, Array definedData, Int32[] definitionLevels, Int32[] repetitionLevels);
    public DataColumn(DataField field, Array data, Int32[] repetitionLevels);
    public DataColumn(DataField field, Array data);
    [CompilerGeneratedAttribute]
public DataField get_Field();
    [CompilerGeneratedAttribute]
private void set_Field(DataField value);
    [CompilerGeneratedAttribute]
public Array get_DefinedData();
    [CompilerGeneratedAttribute]
private void set_DefinedData(Array value);
    public Array get_Data();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Int32[] get_DefinitionLevels();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Int32[] get_RepetitionLevels();
    public bool get_HasRepetitions();
    public bool get_HasDefinitions();
    [CompilerGeneratedAttribute]
public DataColumnStatistics get_Statistics();
    [CompilerGeneratedAttribute]
internal void set_Statistics(DataColumnStatistics value);
    public int get_NumValues();
    [NullableContextAttribute("2")]
public Span`1<T> AsSpan(Nullable`1<int> offset, Nullable`1<int> count);
    public static DataColumn Concat(IEnumerable`1<DataColumn> columns);
    internal bool get_IsDeltaEncodable();
    internal long CalculateRowCount();
    public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Parquet.Data.DataColumnStatistics : object {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <NullCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <DistinctCount>k__BackingField;
    [CompilerGeneratedAttribute]
private object <MinValue>k__BackingField;
    [CompilerGeneratedAttribute]
private object <MaxValue>k__BackingField;
    public Nullable`1<long> NullCount { get; internal set; }
    public Nullable`1<long> DistinctCount { get; internal set; }
    public object MinValue { get; internal set; }
    public object MaxValue { get; internal set; }
    public DataColumnStatistics(Nullable`1<long> nullCount, Nullable`1<long> distinctCount, object minValue, object maxValue);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_NullCount();
    [CompilerGeneratedAttribute]
internal void set_NullCount(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_DistinctCount();
    [CompilerGeneratedAttribute]
internal void set_DistinctCount(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public object get_MinValue();
    [CompilerGeneratedAttribute]
internal void set_MinValue(object value);
    [CompilerGeneratedAttribute]
public object get_MaxValue();
    [CompilerGeneratedAttribute]
internal void set_MaxValue(object value);
    [NullableContextAttribute("1")]
internal Statistics ToThriftStatistics(SchemaElement tse);
}
public static class Parquet.Data.DecimalFormatDefaults : object {
    public static int DefaultPrecision;
    public static int DefaultScale;
}
internal static class Parquet.Encodings.BitPackedEncoder : object {
    public static int Encode8ValuesLE(Span`1<int> src, Span`1<byte> dest, int bitWidth);
    public static void Pack8ValuesLE(Span`1<int> src, Span`1<byte> dest, int bitWidth);
    public static int Decode8ValuesLE(Span`1<byte> src, Span`1<int> dest, int bitWidth);
    public static void Unpack8ValuesLE(Span`1<byte> src, Span`1<int> dest, int bitWidth);
    public static int Encode8ValuesBE(Span`1<int> src, Span`1<byte> dest, int bitWidth);
    public static void Pack8ValuesBE(Span`1<int> src, Span`1<byte> dest, int bitWidth);
    public static int Decode8ValuesBE(Span`1<byte> src, Span`1<int> dest, int bitWidth);
    public static void Unpack8ValuesBE(Span`1<byte> src, Span`1<int> dest, int bitWidth);
    public static int Encode8ValuesLE(Span`1<long> src, Span`1<byte> dest, int bitWidth);
    public static void Pack8ValuesLE(Span`1<long> src, Span`1<byte> dest, int bitWidth);
    public static int Decode8ValuesLE(Span`1<byte> src, Span`1<long> dest, int bitWidth);
    public static void Unpack8ValuesLE(Span`1<byte> src, Span`1<long> dest, int bitWidth);
    public static int Encode8ValuesBE(Span`1<long> src, Span`1<byte> dest, int bitWidth);
    public static void Pack8ValuesBE(Span`1<long> src, Span`1<byte> dest, int bitWidth);
    public static int Decode8ValuesBE(Span`1<byte> src, Span`1<long> dest, int bitWidth);
    public static void Unpack8ValuesBE(Span`1<byte> src, Span`1<long> dest, int bitWidth);
    private static void Unpack8IntValuesLE0(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE0(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE0(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE0(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE1(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE1(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE1(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE1(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE2(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE2(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE2(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE2(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE3(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE3(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE3(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE3(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE4(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE4(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE4(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE4(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE5(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE5(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE5(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE5(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE6(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE6(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE6(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE6(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE7(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE7(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE7(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE7(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE8(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE8(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE8(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE8(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE9(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE9(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE9(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE9(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE10(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE10(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE10(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE10(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE11(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE11(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE11(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE11(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE12(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE12(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE12(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE12(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE13(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE13(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE13(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE13(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE14(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE14(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE14(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE14(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE15(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE15(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE15(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE15(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE16(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE16(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE16(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE16(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE17(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE17(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE17(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE17(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE18(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE18(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE18(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE18(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE19(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE19(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE19(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE19(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE20(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE20(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE20(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE20(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE21(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE21(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE21(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE21(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE22(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE22(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE22(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE22(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE23(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE23(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE23(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE23(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE24(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE24(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE24(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE24(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE25(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE25(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE25(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE25(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE26(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE26(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE26(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE26(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE27(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE27(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE27(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE27(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE28(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE28(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE28(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE28(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE29(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE29(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE29(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE29(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE30(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE30(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE30(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE30(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE31(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE31(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE31(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE31(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesLE32(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesLE32(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8IntValuesBE32(Span`1<byte> src, Span`1<int> dest);
    private static void Pack8IntValuesBE32(Span`1<int> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE0(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE0(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE0(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE0(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE1(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE1(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE1(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE1(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE2(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE2(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE2(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE2(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE3(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE3(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE3(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE3(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE4(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE4(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE4(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE4(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE5(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE5(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE5(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE5(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE6(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE6(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE6(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE6(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE7(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE7(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE7(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE7(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE8(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE8(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE8(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE8(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE9(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE9(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE9(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE9(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE10(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE10(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE10(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE10(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE11(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE11(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE11(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE11(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE12(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE12(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE12(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE12(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE13(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE13(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE13(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE13(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE14(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE14(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE14(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE14(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE15(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE15(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE15(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE15(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE16(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE16(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE16(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE16(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE17(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE17(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE17(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE17(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE18(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE18(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE18(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE18(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE19(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE19(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE19(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE19(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE20(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE20(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE20(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE20(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE21(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE21(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE21(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE21(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE22(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE22(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE22(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE22(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE23(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE23(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE23(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE23(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE24(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE24(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE24(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE24(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE25(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE25(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE25(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE25(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE26(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE26(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE26(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE26(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE27(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE27(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE27(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE27(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE28(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE28(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE28(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE28(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE29(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE29(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE29(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE29(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE30(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE30(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE30(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE30(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE31(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE31(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE31(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE31(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE32(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE32(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE32(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE32(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE33(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE33(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE33(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE33(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE34(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE34(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE34(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE34(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE35(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE35(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE35(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE35(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE36(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE36(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE36(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE36(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE37(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE37(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE37(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE37(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE38(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE38(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE38(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE38(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE39(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE39(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE39(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE39(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE40(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE40(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE40(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE40(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE41(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE41(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE41(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE41(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE42(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE42(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE42(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE42(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE43(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE43(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE43(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE43(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE44(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE44(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE44(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE44(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE45(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE45(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE45(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE45(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE46(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE46(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE46(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE46(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE47(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE47(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE47(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE47(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE48(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE48(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE48(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE48(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE49(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE49(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE49(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE49(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE50(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE50(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE50(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE50(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE51(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE51(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE51(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE51(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE52(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE52(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE52(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE52(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE53(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE53(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE53(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE53(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE54(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE54(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE54(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE54(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE55(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE55(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE55(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE55(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE56(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE56(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE56(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE56(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE57(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE57(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE57(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE57(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE58(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE58(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE58(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE58(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE59(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE59(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE59(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE59(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE60(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE60(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE60(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE60(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE61(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE61(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE61(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE61(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE62(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE62(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE62(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE62(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE63(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE63(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE63(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE63(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesLE64(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesLE64(Span`1<long> src, Span`1<byte> dest);
    private static void Unpack8LongValuesBE64(Span`1<byte> src, Span`1<long> dest);
    private static void Pack8LongValuesBE64(Span`1<long> src, Span`1<byte> dest);
}
[ExtensionAttribute]
internal static class Parquet.Encodings.DeltaBinaryPackedEncoder : object {
    [NullableContextAttribute("1")]
public static bool IsSupported(Type t);
    [NullableContextAttribute("1")]
public static void Encode(Array data, int offset, int count, Stream destination, DataColumnStatistics stats);
    public static int Decode(Span`1<byte> s, Array dest, int destOffset, int valueCount, Int32& consumedBytes);
    [ExtensionAttribute]
private static int CalculateBitWidth(Span`1<int> span);
    [ExtensionAttribute]
private static int CalculateBitWidth(Span`1<long> span);
    private static void FlushIntBlock(Span`1<int> block, int minDelta, Stream destination, int miniblockCount, int miniblockSize);
    private static void EncodeInt(ReadOnlySpan`1<int> data, Stream destination, int blockSize, int miniblockSize);
    private static int DecodeInt(Span`1<byte> s, Span`1<int> dest, Int32& consumedBytes);
    private static void FlushLongBlock(Span`1<long> block, long minDelta, Stream destination, int miniblockCount, int miniblockSize);
    private static void EncodeLong(ReadOnlySpan`1<long> data, Stream destination, int blockSize, int miniblockSize);
    private static int DecodeLong(Span`1<byte> s, Span`1<long> dest, Int32& consumedBytes);
}
internal static class Parquet.Encodings.DeltaByteArrayEncoder : object {
    [NullableContextAttribute("1")]
private static void MakeStrings(Int32[] prefixLenghs, String[] dest, int destOffset, int count);
    public static int Decode(Span`1<byte> s, Array dest, int destOffset, int valueCount);
}
internal static class Parquet.Encodings.DeltaLengthByteArrayEncoder : object {
    [NullableAttribute("1")]
private static Encoding E;
    private static DeltaLengthByteArrayEncoder();
    private static int MakeStrings(Span`1<byte> s, Span`1<int> lengths, String[] dest, int destOffset);
    private static int MakeBytes(Span`1<byte> s, Span`1<int> lengths, Byte[][] dest, int destOffset);
    public static int Decode(Span`1<byte> s, Array dest, int destOffset, int valueCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Parquet.Encodings.ParquetDictionaryEncoder : object {
    public static bool TryExtractDictionary(Type elementType, Array data, int offset, int count, Array& dictionaryArray, Int32[]& rentedIndexes, double threshold);
    [NullableContextAttribute("2")]
private static bool EncodeStrings(Array data, int offset, int count, Array& dictionaryArray, Int32[]& rentedIndexes, double threshold);
    private static HashSet`1<string> Distinct(String[] strings, int offset, int count);
    private static bool Encode(Array data, int offset, int count, Array& dictionaryArray, Int32[]& rentedIndexes, double threshold);
    private static Dictionary`2<T, ValueTuple`3<int, int, int>> Distinct(T[] values, int offset, int count, EqualityComparer`1<T> equalityComparer);
}
internal static class Parquet.Encodings.ParquetPlainEncoder : object {
    [NullableAttribute("1")]
private static Encoding E;
    [NullableAttribute("1")]
private static Byte[] ZeroInt32;
    [NullableAttribute("1")]
private static ArrayPool`1<byte> BytePool;
    private static ParquetPlainEncoder();
    [NullableContextAttribute("1")]
public static void Encode(Array data, int offset, int count, SchemaElement tse, Stream destination, DataColumnStatistics stats);
    [NullableContextAttribute("1")]
public static void Decode(Array data, int offset, int count, SchemaElement tse, Span`1<byte> source, Int32& elementsRead);
    [NullableContextAttribute("2")]
public static bool TryEncode(object value, SchemaElement tse, Byte[]& result);
    [NullableContextAttribute("2")]
public static bool TryDecode(Byte[] value, SchemaElement tse, ParquetOptions options, Object& result);
    [NullableContextAttribute("1")]
private static decimal TryDecodeDecimal(Byte[] value, SchemaElement tse);
    [NullableContextAttribute("1")]
private static bool TryEncode(DateTime value, SchemaElement tse, Byte[]& result);
    [NullableContextAttribute("1")]
private static bool TryEncode(DateOnly value, SchemaElement tse, Byte[]& result);
    [NullableContextAttribute("1")]
private static bool TryEncode(TimeOnly value, SchemaElement tse, Byte[]& result);
    [NullableContextAttribute("1")]
private static bool TryEncode(decimal value, SchemaElement tse, Byte[]& result);
    [NullableContextAttribute("1")]
private static bool TryEncode(TimeSpan value, SchemaElement tse, Byte[]& result);
    public static void Encode(ReadOnlySpan`1<bool> data, Stream destination);
    public static int Decode(Span`1<byte> source, Span`1<bool> data);
    [NullableContextAttribute("1")]
public static void Encode(ReadOnlySpan`1<byte> data, Stream destination, SchemaElement tse);
    public static int Decode(Span`1<byte> source, Span`1<byte> data);
    public static void Encode(ReadOnlySpan`1<sbyte> data, Stream destination);
    public static int Decode(Span`1<byte> source, Span`1<sbyte> data);
    public static void Encode(ReadOnlySpan`1<short> data, Stream destination);
    public static int Decode(Span`1<byte> source, Span`1<short> data);
    public static void Encode(ReadOnlySpan`1<ushort> data, Stream destination);
    public static int Decode(Span`1<byte> source, Span`1<ushort> data);
    public static void Encode(ReadOnlySpan`1<int> data, Stream destination);
    public static void Encode(ReadOnlySpan`1<UInt32> data, Stream destination);
    public static void Encode(ReadOnlySpan`1<long> data, Stream destination);
    public static void Encode(ReadOnlySpan`1<ulong> data, Stream destination);
    public static void Encode(ReadOnlySpan`1<BigInteger> data, Stream destination);
    public static int Decode(Span`1<byte> source, Span`1<T> data);
    [NullableContextAttribute("1")]
public static void Encode(ReadOnlySpan`1<decimal> data, Stream destination, SchemaElement tse);
    public static int Decode(Span`1<byte> source, Span`1<decimal> data, SchemaElement tse);
    public static void Encode(ReadOnlySpan`1<double> data, Stream destination);
    public static void Encode(ReadOnlySpan`1<float> data, Stream destination);
    public static int Decode(Span`1<byte> source, Span`1<float> data);
    [NullableContextAttribute("1")]
public static void Encode(ReadOnlySpan`1<Byte[]> data, Stream destination);
    public static void Encode(ReadOnlySpan`1<Guid> data, Stream destination);
    public static int Decode(Span`1<byte> source, Span`1<Byte[]> data, SchemaElement tse);
    [NullableContextAttribute("1")]
public static void Encode(ReadOnlySpan`1<DateTime> data, Stream destination, SchemaElement tse);
    [NullableContextAttribute("1")]
public static void Encode(ReadOnlySpan`1<DateOnly> data, Stream destination, SchemaElement tse);
    [NullableContextAttribute("1")]
public static void Encode(ReadOnlySpan`1<TimeOnly> data, Stream destination, SchemaElement tse);
    public static int Decode(Span`1<byte> source, Span`1<DateTime> data, SchemaElement tse);
    public static int Decode(Span`1<byte> source, Span`1<DateOnly> data, SchemaElement tse);
    public static int Decode(Span`1<byte> source, Span`1<TimeOnly> data, SchemaElement tse);
    [NullableContextAttribute("1")]
public static void Encode(ReadOnlySpan`1<TimeSpan> data, Stream destination, SchemaElement tse);
    public static int Decode(Span`1<byte> source, Span`1<TimeSpan> data, SchemaElement tse);
    public static void Encode(ReadOnlySpan`1<Interval> data, Stream destination);
    public static int Decode(Span`1<byte> source, Span`1<Interval> data);
    [NullableContextAttribute("1")]
public static void Encode(ReadOnlySpan`1<string> data, Stream destination);
    public static int Decode(Span`1<byte> source, Span`1<string> data, SchemaElement tse);
    public static int Decode(Span`1<byte> source, Span`1<Guid> data, SchemaElement tse);
    private static void Write(Stream destination, ReadOnlySpan`1<byte> bytes);
    private static int Read(Stream source, Span`1<byte> bytes);
    public static void FillStats(ReadOnlySpan`1<byte> data, DataColumnStatistics stats);
    public static void FillStats(ReadOnlySpan`1<sbyte> data, DataColumnStatistics stats);
    public static void FillStats(ReadOnlySpan`1<short> data, DataColumnStatistics stats);
    public static void FillStats(ReadOnlySpan`1<ushort> data, DataColumnStatistics stats);
    public static void FillStats(ReadOnlySpan`1<int> data, DataColumnStatistics stats);
    public static void FillStats(ReadOnlySpan`1<UInt32> data, DataColumnStatistics stats);
    public static void FillStats(ReadOnlySpan`1<long> data, DataColumnStatistics stats);
    public static void FillStats(ReadOnlySpan`1<ulong> data, DataColumnStatistics stats);
    public static void FillStats(ReadOnlySpan`1<BigInteger> data, DataColumnStatistics stats);
    public static void FillStats(ReadOnlySpan`1<decimal> data, DataColumnStatistics stats);
    public static void FillStats(ReadOnlySpan`1<double> data, DataColumnStatistics stats);
    public static void FillStats(ReadOnlySpan`1<float> data, DataColumnStatistics stats);
    public static void FillStats(ReadOnlySpan`1<DateTime> data, DataColumnStatistics stats);
    public static void FillStats(ReadOnlySpan`1<DateOnly> data, DataColumnStatistics stats);
    public static void FillStats(ReadOnlySpan`1<TimeOnly> data, DataColumnStatistics stats);
    public static void FillStats(ReadOnlySpan`1<TimeSpan> data, DataColumnStatistics stats);
    [NullableContextAttribute("1")]
public static void FillStats(ReadOnlySpan`1<string> data, DataColumnStatistics stats);
}
internal static class Parquet.Encodings.RleBitpackedHybridEncoder : object {
    [NullableAttribute("1")]
private static ArrayPool`1<byte> BytePool;
    private static int MaxValueCount;
    private static RleBitpackedHybridEncoder();
    public static void EncodeWithLength(Stream s, int bitWidth, Span`1<int> data);
    public static void Encode(Stream dest, Span`1<int> data, int bitWidth);
    public static int Encode(Span`1<int> data, int bitWidth, Byte[]& rentedBuffer);
    [NullableContextAttribute("1")]
private static void WriteRle0(Byte[] r, Int32& consumed, int chunkCount, int value);
    [NullableContextAttribute("1")]
private static void WriteRle1(Byte[] r, Int32& consumed, int chunkCount, int value);
    [NullableContextAttribute("1")]
private static void WriteRle2(Byte[] r, Int32& consumed, int chunkCount, int value);
    [NullableContextAttribute("1")]
private static void WriteRle3(Byte[] r, Int32& consumed, int chunkCount, int value);
    [NullableContextAttribute("1")]
private static void WriteRle4(Byte[] r, Int32& consumed, int chunkCount, int value);
    public static int Decode(Span`1<byte> s, int bitWidth, Nullable`1<int> spanLength, Int32& usedSpanLength, Span`1<int> dest, int pageSize);
    public static int Decode(Span`1<byte> data, int bitWidth, Span`1<int> dest, int pageSize);
    private static int ReadRle(int header, Span`1<byte> data, Int32& offset, int byteWidth, Span`1<int> dest, int maxItems);
    internal static int DecodeBitpacked(int header, Span`1<byte> data, Int32& dataOffset, int bitWidth, Span`1<int> dest, int maxItems);
    private static int ReadIntOnBytes(Span`1<byte> data);
    private static void Encode0(Byte[] s, Int32& consumed, Span`1<int> data);
    private static void Encode1(Byte[] s, Int32& consumed, Span`1<int> data);
    private static void Encode2(Byte[] s, Int32& consumed, Span`1<int> data);
    private static void Encode3(Byte[] s, Int32& consumed, Span`1<int> data);
    private static void Encode4(Byte[] s, Int32& consumed, Span`1<int> data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Parquet.Encodings.SchemaEncoder : object {
    public static Type[] SupportedTypes;
    private static SchemaEncoder();
    private static bool TryBuildList(List`1<SchemaElement> schema, Int32& index, Int32& ownedChildren, ListField& field);
    private static bool TryBuildMap(List`1<SchemaElement> schema, Int32& index, Int32& ownedChildren, MapField& field);
    private static bool TryBuildStruct(List`1<SchemaElement> schema, Int32& index, Int32& ownedChildren, StructField& field);
    public static bool IsSupported(Type t);
    public static Field Decode(List`1<SchemaElement> schema, ParquetOptions options, Int32& index, Int32& ownedChildCount);
    private static bool TryBuildDataField(SchemaElement se, ParquetOptions options, DataField& df);
    private static DataField GetDecimalDataField(SchemaElement se);
    private static DataField GetDateTimeDataField(SchemaElement se);
    private static void Encode(ListField listField, SchemaElement parent, IList`1<SchemaElement> container);
    private static void Encode(MapField mapField, SchemaElement parent, IList`1<SchemaElement> container);
    private static void Encode(StructField structField, SchemaElement parent, IList`1<SchemaElement> container);
    public static SchemaElement Encode(DataField field);
    public static void Encode(Field field, SchemaElement parent, IList`1<SchemaElement> container);
}
[ExtensionAttribute]
internal static class Parquet.Extensions.ArrayExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Explode(Array dictionary, Span`1<int> indexes, Array result, int resultOffset, int resultCount);
}
[ExtensionAttribute]
internal static class Parquet.Extensions.EncodingExtensions : object {
    [ExtensionAttribute]
public static int GetBitWidth(int value);
    [ExtensionAttribute]
public static int GetBitWidth(long value);
    [ExtensionAttribute]
public static long ZigZagEncode(long num);
    [ExtensionAttribute]
public static long ZigZagDecode(long raw);
    [ExtensionAttribute]
public static long ReadZigZagVarLong(Span`1<byte> data, Int32& offset);
    [ExtensionAttribute]
public static void ULEB128Encode(ulong value, Span`1<byte> dest, Int32& offset);
    [ExtensionAttribute]
public static ulong ULEB128Decode(Span`1<byte> data, Int32& offset);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void WriteULEB128(Stream destination, ulong value);
    [ExtensionAttribute]
public static int NumberOfLeadingZerosInt(int num);
    [ExtensionAttribute]
public static int NumberOfLeadingZerosLong(long num);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Parquet.Extensions.ExpressionExtensions : object {
    [ExtensionAttribute]
public static Expression Loop(Expression iteration, Expression collection, Type elementType, ParameterExpression element, ParameterExpression countVar);
    [ExtensionAttribute]
public static Expression ForLoop(Expression fromVar, Expression toVar, ParameterExpression iVar, Expression body);
    [ExtensionAttribute]
public static Expression ClearArray(ParameterExpression array, Expression fromIndexVar);
    [ExtensionAttribute]
public static Expression CollectionCount(Expression collection, Type collectionType);
    [ExtensionAttribute]
public static Expression CollectionAdd(Expression collection, Type collectionType, Expression element, Type elementType);
    [ExtensionAttribute]
public static Expression IsNull(Expression nullableVar);
    [ExtensionAttribute]
public static string GetPseudoCode(Expression expression);
}
[ExtensionAttribute]
internal static class Parquet.Extensions.GuidExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Byte[] ToBigEndianByteArray(Guid guid);
    [ExtensionAttribute]
public static Guid ToGuidFromBigEndian(ReadOnlySpan`1<byte> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Parquet.Extensions.MeteredWriteStream : Stream {
    private Stream _baseStream;
    private long _written;
    public long TotalBytesWritten { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public long Position { get; public set; }
    public MeteredWriteStream(Stream inner);
    public long get_TotalBytesWritten();
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> buffer);
    [AsyncStateMachineAttribute("Parquet.Extensions.MeteredWriteStream/<WriteAsync>d__16")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Parquet.Extensions.MeteredWriteStream/<WriteAsync>d__17")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual void Close();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("Parquet.Extensions.MeteredWriteStream/<DisposeAsync>d__42")]
public virtual ValueTask DisposeAsync();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Parquet.Extensions.StreamExtensions : object {
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void WriteSpan(Stream s, Span`1<byte> span);
    [ExtensionAttribute]
public static int ReadInt32(Stream s);
    [AsyncStateMachineAttribute("Parquet.Extensions.StreamExtensions/<ReadInt32Async>d__2")]
[ExtensionAttribute]
public static Task`1<int> ReadInt32Async(Stream s);
    [ExtensionAttribute]
public static void WriteInt32(Stream s, int value);
    [ExtensionAttribute]
public static long ReadInt64(Stream s);
    [ExtensionAttribute]
public static Byte[] ReadBytesExactly(Stream s, int count);
    [AsyncStateMachineAttribute("Parquet.Extensions.StreamExtensions/<ReadBytesExactlyAsync>d__6")]
[ExtensionAttribute]
public static Task`1<Byte[]> ReadBytesExactlyAsync(Stream s, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Parquet.Extensions.StringBuilderExtensions : object {
    private static string BraceOpen;
    private static string BraceClose;
    private static string JsonQuote;
    private static string JsonSingleQuote;
    [ExtensionAttribute]
public static void StartArray(StringBuilder sb, StringFormat sf, int level);
    [ExtensionAttribute]
public static void EndArray(StringBuilder sb, StringFormat sf, int level);
    [ExtensionAttribute]
public static void DivideObjects(StringBuilder sb, StringFormat sf, int level);
    [ExtensionAttribute]
public static void StartObject(StringBuilder sb, StringFormat sf);
    [ExtensionAttribute]
public static void EndObject(StringBuilder sb, StringFormat sf);
    [ExtensionAttribute]
public static void AppendPropertyName(StringBuilder sb, StringFormat sf, Field f);
    [ExtensionAttribute]
public static void AppendNull(StringBuilder sb, StringFormat sf);
    [ExtensionAttribute]
public static void Append(StringBuilder sb, StringFormat sf, object value);
    private static void EncodeCsv(StringBuilder sb, StringFormat sf, object value);
    private static void EncodeJson(StringBuilder sb, StringFormat sf, object value);
}
[ExtensionAttribute]
internal static class Parquet.Extensions.TaskExtensions : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Parquet.Extensions.TaskExtensions/<SequentialWhenAll>d__0`1")]
[ExtensionAttribute]
public static Task`1<T[]> SequentialWhenAll(IEnumerable`1<Task`1<T>> collection);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Parquet.Extensions.UntypedArrayExtensions : object {
    [ExtensionAttribute]
public static int CalculateNullCountFast(Array array, int offset, int count);
    private static int CalculateNullCount(Nullable`1[] array, int offset, int count);
    private static int CalculateNullCount(Nullable`1[] array, int offset, int count);
    private static int CalculateNullCount(Nullable`1[] array, int offset, int count);
    private static int CalculateNullCount(Nullable`1[] array, int offset, int count);
    private static int CalculateNullCount(Nullable`1[] array, int offset, int count);
    private static int CalculateNullCount(Nullable`1[] array, int offset, int count);
    private static int CalculateNullCount(Nullable`1[] array, int offset, int count);
    private static int CalculateNullCount(Nullable`1[] array, int offset, int count);
    private static int CalculateNullCount(Nullable`1[] array, int offset, int count);
    private static int CalculateNullCount(Nullable`1[] array, int offset, int count);
    private static int CalculateNullCount(Nullable`1[] array, int offset, int count);
    private static int CalculateNullCount(Nullable`1[] array, int offset, int count);
    private static int CalculateNullCount(Nullable`1[] array, int offset, int count);
    private static int CalculateNullCount(Nullable`1[] array, int offset, int count);
    private static int CalculateNullCount(Nullable`1[] array, int offset, int count);
    private static int CalculateNullCount(Nullable`1[] array, int offset, int count);
    private static int CalculateNullCount(String[] array, int offset, int count);
    private static int CalculateNullCount(Byte[][] array, int offset, int count);
    private static int CalculateNullCount(Nullable`1[] array, int offset, int count);
    private static int CalculateNullCount(Nullable`1[] array, int offset, int count);
    private static int CalculateNullCount(Nullable`1[] array, int offset, int count);
    [ExtensionAttribute]
public static void PackNullsFast(Array array, int offset, int count, Array packedData, Span`1<int> dest, int fillerValue);
    private static void PackNullsTypeFast(Nullable`1[] array, int offset, int count, Boolean[] packedArray, Span`1<int> dest, int fillerValue);
    private static void PackNullsTypeFast(Nullable`1[] array, int offset, int count, Byte[] packedArray, Span`1<int> dest, int fillerValue);
    private static void PackNullsTypeFast(Nullable`1[] array, int offset, int count, SByte[] packedArray, Span`1<int> dest, int fillerValue);
    private static void PackNullsTypeFast(Nullable`1[] array, int offset, int count, Int16[] packedArray, Span`1<int> dest, int fillerValue);
    private static void PackNullsTypeFast(Nullable`1[] array, int offset, int count, UInt16[] packedArray, Span`1<int> dest, int fillerValue);
    private static void PackNullsTypeFast(Nullable`1[] array, int offset, int count, Int32[] packedArray, Span`1<int> dest, int fillerValue);
    private static void PackNullsTypeFast(Nullable`1[] array, int offset, int count, UInt32[] packedArray, Span`1<int> dest, int fillerValue);
    private static void PackNullsTypeFast(Nullable`1[] array, int offset, int count, Int64[] packedArray, Span`1<int> dest, int fillerValue);
    private static void PackNullsTypeFast(Nullable`1[] array, int offset, int count, UInt64[] packedArray, Span`1<int> dest, int fillerValue);
    private static void PackNullsTypeFast(Nullable`1[] array, int offset, int count, BigInteger[] packedArray, Span`1<int> dest, int fillerValue);
    private static void PackNullsTypeFast(Nullable`1[] array, int offset, int count, Single[] packedArray, Span`1<int> dest, int fillerValue);
    private static void PackNullsTypeFast(Nullable`1[] array, int offset, int count, Double[] packedArray, Span`1<int> dest, int fillerValue);
    private static void PackNullsTypeFast(Nullable`1[] array, int offset, int count, Decimal[] packedArray, Span`1<int> dest, int fillerValue);
    private static void PackNullsTypeFast(Nullable`1[] array, int offset, int count, DateTime[] packedArray, Span`1<int> dest, int fillerValue);
    private static void PackNullsTypeFast(Nullable`1[] array, int offset, int count, TimeSpan[] packedArray, Span`1<int> dest, int fillerValue);
    private static void PackNullsTypeFast(Nullable`1[] array, int offset, int count, Interval[] packedArray, Span`1<int> dest, int fillerValue);
    private static void PackNullsTypeFast(String[] array, int offset, int count, String[] packedArray, Span`1<int> dest, int fillerValue);
    private static void PackNullsTypeFast(Byte[][] array, int offset, int count, Byte[][] packedArray, Span`1<int> dest, int fillerValue);
    private static void PackNullsTypeFast(Nullable`1[] array, int offset, int count, Guid[] packedArray, Span`1<int> dest, int fillerValue);
    private static void PackNullsTypeFast(Nullable`1[] array, int offset, int count, DateOnly[] packedArray, Span`1<int> dest, int fillerValue);
    private static void PackNullsTypeFast(Nullable`1[] array, int offset, int count, TimeOnly[] packedArray, Span`1<int> dest, int fillerValue);
    [ExtensionAttribute]
public static void UnpackNullsFast(Array array, Span`1<int> flags, int fillFlag, Array result);
    private static void UnpackNullsTypeFast(Boolean[] array, Span`1<int> flags, int fillFlag, Nullable`1[] result);
    private static void UnpackNullsTypeFast(Byte[] array, Span`1<int> flags, int fillFlag, Nullable`1[] result);
    private static void UnpackNullsTypeFast(SByte[] array, Span`1<int> flags, int fillFlag, Nullable`1[] result);
    private static void UnpackNullsTypeFast(Int16[] array, Span`1<int> flags, int fillFlag, Nullable`1[] result);
    private static void UnpackNullsTypeFast(UInt16[] array, Span`1<int> flags, int fillFlag, Nullable`1[] result);
    private static void UnpackNullsTypeFast(Int32[] array, Span`1<int> flags, int fillFlag, Nullable`1[] result);
    private static void UnpackNullsTypeFast(UInt32[] array, Span`1<int> flags, int fillFlag, Nullable`1[] result);
    private static void UnpackNullsTypeFast(Int64[] array, Span`1<int> flags, int fillFlag, Nullable`1[] result);
    private static void UnpackNullsTypeFast(UInt64[] array, Span`1<int> flags, int fillFlag, Nullable`1[] result);
    private static void UnpackNullsTypeFast(BigInteger[] array, Span`1<int> flags, int fillFlag, Nullable`1[] result);
    private static void UnpackNullsTypeFast(Single[] array, Span`1<int> flags, int fillFlag, Nullable`1[] result);
    private static void UnpackNullsTypeFast(Double[] array, Span`1<int> flags, int fillFlag, Nullable`1[] result);
    private static void UnpackNullsTypeFast(Decimal[] array, Span`1<int> flags, int fillFlag, Nullable`1[] result);
    private static void UnpackNullsTypeFast(DateTime[] array, Span`1<int> flags, int fillFlag, Nullable`1[] result);
    private static void UnpackNullsTypeFast(TimeSpan[] array, Span`1<int> flags, int fillFlag, Nullable`1[] result);
    private static void UnpackNullsTypeFast(Interval[] array, Span`1<int> flags, int fillFlag, Nullable`1[] result);
    private static void UnpackNullsTypeFast(String[] array, Span`1<int> flags, int fillFlag, String[] result);
    private static void UnpackNullsTypeFast(Byte[][] array, Span`1<int> flags, int fillFlag, Byte[][] result);
    private static void UnpackNullsTypeFast(Guid[] array, Span`1<int> flags, int fillFlag, Nullable`1[] result);
    private static void UnpackNullsTypeFast(DateOnly[] array, Span`1<int> flags, int fillFlag, Nullable`1[] result);
    private static void UnpackNullsTypeFast(TimeOnly[] array, Span`1<int> flags, int fillFlag, Nullable`1[] result);
    [ExtensionAttribute]
public static void ExplodeFast(Array dictionary, Span`1<int> indexes, Array result, int resultOffset, int resultCount);
    private static void ExplodeTypeFast(Boolean[] dictionary, Span`1<int> indexes, Boolean[] result, int resultOffset, int resultCount);
    private static void ExplodeTypeFast(Byte[] dictionary, Span`1<int> indexes, Byte[] result, int resultOffset, int resultCount);
    private static void ExplodeTypeFast(SByte[] dictionary, Span`1<int> indexes, SByte[] result, int resultOffset, int resultCount);
    private static void ExplodeTypeFast(Int16[] dictionary, Span`1<int> indexes, Int16[] result, int resultOffset, int resultCount);
    private static void ExplodeTypeFast(UInt16[] dictionary, Span`1<int> indexes, UInt16[] result, int resultOffset, int resultCount);
    private static void ExplodeTypeFast(Int32[] dictionary, Span`1<int> indexes, Int32[] result, int resultOffset, int resultCount);
    private static void ExplodeTypeFast(UInt32[] dictionary, Span`1<int> indexes, UInt32[] result, int resultOffset, int resultCount);
    private static void ExplodeTypeFast(Int64[] dictionary, Span`1<int> indexes, Int64[] result, int resultOffset, int resultCount);
    private static void ExplodeTypeFast(UInt64[] dictionary, Span`1<int> indexes, UInt64[] result, int resultOffset, int resultCount);
    private static void ExplodeTypeFast(BigInteger[] dictionary, Span`1<int> indexes, BigInteger[] result, int resultOffset, int resultCount);
    private static void ExplodeTypeFast(Single[] dictionary, Span`1<int> indexes, Single[] result, int resultOffset, int resultCount);
    private static void ExplodeTypeFast(Double[] dictionary, Span`1<int> indexes, Double[] result, int resultOffset, int resultCount);
    private static void ExplodeTypeFast(Decimal[] dictionary, Span`1<int> indexes, Decimal[] result, int resultOffset, int resultCount);
    private static void ExplodeTypeFast(DateTime[] dictionary, Span`1<int> indexes, DateTime[] result, int resultOffset, int resultCount);
    private static void ExplodeTypeFast(TimeSpan[] dictionary, Span`1<int> indexes, TimeSpan[] result, int resultOffset, int resultCount);
    private static void ExplodeTypeFast(Interval[] dictionary, Span`1<int> indexes, Interval[] result, int resultOffset, int resultCount);
    private static void ExplodeTypeFast(String[] dictionary, Span`1<int> indexes, String[] result, int resultOffset, int resultCount);
    private static void ExplodeTypeFast(Byte[][] dictionary, Span`1<int> indexes, Byte[][] result, int resultOffset, int resultCount);
    private static void ExplodeTypeFast(Guid[] dictionary, Span`1<int> indexes, Guid[] result, int resultOffset, int resultCount);
    private static void ExplodeTypeFast(DateOnly[] dictionary, Span`1<int> indexes, DateOnly[] result, int resultOffset, int resultCount);
    private static void ExplodeTypeFast(TimeOnly[] dictionary, Span`1<int> indexes, TimeOnly[] result, int resultOffset, int resultCount);
}
internal static class Parquet.File.Compressor : object {
    [NullableAttribute("1")]
private static Iron _iron;
    private static Compressor();
    public static IronCompressResult Compress(CompressionMethod method, ReadOnlySpan`1<byte> input, CompressionLevel compressionLevel);
    public static IronCompressResult Decompress(CompressionMethod method, ReadOnlySpan`1<byte> input, int outLength);
    private static Codec ToCodec(CompressionMethod method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Parquet.File.DataColumnReader : object {
    private DataField _dataField;
    private Stream _inputStream;
    private ColumnChunk _thriftColumnChunk;
    [NullableAttribute("2")]
private SchemaElement _schemaElement;
    private ThriftFooter _footer;
    private ParquetOptions _options;
    [NullableAttribute("2")]
private DataColumnStatistics _stats;
    internal DataColumnReader(DataField dataField, Stream inputStream, ColumnChunk thriftColumnChunk, DataColumnStatistics stats, ThriftFooter footer, ParquetOptions parquetOptions);
    [NullableContextAttribute("2")]
public DataColumnStatistics GetColumnStatistics();
    [AsyncStateMachineAttribute("Parquet.File.DataColumnReader/<ReadAsync>d__9")]
public Task`1<DataColumn> ReadAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Parquet.File.DataColumnReader/<ReadPageDataAsync>d__10")]
private Task`1<IronCompressResult> ReadPageDataAsync(PageHeader ph);
    [AsyncStateMachineAttribute("Parquet.File.DataColumnReader/<ReadPageDataV2Async>d__11")]
private Task`1<IronCompressResult> ReadPageDataV2Async(PageHeader ph);
    [AsyncStateMachineAttribute("Parquet.File.DataColumnReader/<ReadDictionaryPage>d__12")]
private ValueTask ReadDictionaryPage(PageHeader ph, PackedColumn pc);
    private long GetFileOffset();
    [AsyncStateMachineAttribute("Parquet.File.DataColumnReader/<ReadDataPageV1Async>d__14")]
private Task ReadDataPageV1Async(PageHeader ph, PackedColumn pc);
    [AsyncStateMachineAttribute("Parquet.File.DataColumnReader/<ReadDataPageV2Async>d__15")]
private Task ReadDataPageV2Async(PageHeader ph, PackedColumn pc, long maxValues);
    [NullableContextAttribute("0")]
private int ReadLevels(Span`1<byte> s, int maxLevel, Span`1<int> dest, int pageSize, Nullable`1<int> length, Int32& usedLength);
    [NullableContextAttribute("0")]
private void ReadColumn(Span`1<byte> src, Encoding encoding, long totalValuesInChunk, int totalValuesInPage, PackedColumn pc);
    [NullableContextAttribute("0")]
private static int ReadRleDictionary(Span`1<byte> s, int maxReadCount, Span`1<int> dest);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Parquet.File.DataColumnWriter : object {
    private Stream _stream;
    private ThriftFooter _footer;
    private SchemaElement _schemaElement;
    private CompressionMethod _compressionMethod;
    private CompressionLevel _compressionLevel;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, string> _keyValueMetadata;
    private ParquetOptions _options;
    private static RecyclableMemoryStreamManager _rmsMgr;
    public DataColumnWriter(Stream stream, ThriftFooter footer, SchemaElement schemaElement, CompressionMethod compressionMethod, ParquetOptions options, CompressionLevel compressionLevel, Dictionary`2<string, string> keyValueMetadata);
    private static DataColumnWriter();
    [AsyncStateMachineAttribute("Parquet.File.DataColumnWriter/<WriteAsync>d__9")]
public Task`1<ColumnChunk> WriteAsync(FieldPath fullPath, DataColumn column, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Parquet.File.DataColumnWriter/<CompressAndWriteAsync>d__11")]
private Task CompressAndWriteAsync(PageHeader ph, MemoryStream data, ColumnSizes cs, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Parquet.File.DataColumnWriter/<WriteColumnAsync>d__12")]
private Task`1<ColumnSizes> WriteColumnAsync(ColumnChunk chunk, DataColumn column, SchemaElement tse, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private static void WriteLevels(Stream s, Span`1<int> levels, int count, int maxValue);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Parquet.File.PackedColumn : object {
    [NullableAttribute("1")]
private static ArrayPool`1<int> IntPool;
    [NullableAttribute("1")]
private DataField _field;
    private int _totalCount;
    private Array _dictionary;
    private Int32[] _dictionaryIndexes;
    private int _dictionaryIndexesOffset;
    private Int32[] _repetitionLevels;
    private bool _repetitionsRented;
    private int _repetitionOffset;
    private Int32[] _definitionLevels;
    private int _definitionOffset;
    private bool _areDefinitionsPooled;
    [NullableAttribute("1")]
private Array _definedData;
    private int _definedDataCount;
    private DataColumn _column;
    public bool HasDictionary { get; }
    public Array Dictionary { get; }
    public bool HasRepetitionLevels { get; }
    public Int32[] RepetitionLevels { get; }
    public bool HasDefinitionLevels { get; }
    public Int32[] DefinitionLevels { get; }
    public int DefinitionsRead { get; }
    public int ValuesRead { get; }
    [NullableContextAttribute("1")]
public PackedColumn(DataColumn column);
    [NullableContextAttribute("1")]
public PackedColumn(DataField df, int totalCount, int approxDefinedCount);
    private static PackedColumn();
    public bool get_HasDictionary();
    public Array get_Dictionary();
    public bool get_HasRepetitionLevels();
    public Int32[] get_RepetitionLevels();
    public bool get_HasDefinitionLevels();
    public Int32[] get_DefinitionLevels();
    public Int32[] GetDictionaryIndexes(Int32& length);
    [NullableContextAttribute("0")]
public Span`1<int> AllocateOrGetDictionaryIndexes(int max);
    public void MarkUsefulDictionaryIndexes(int count);
    [NullableContextAttribute("0")]
public Span`1<int> GetWriteableRepetitionLevelSpan();
    public void MarkRepetitionLevels(int count);
    [NullableContextAttribute("0")]
public Span`1<int> GetWriteableDefinitionLevelSpan();
    public void MarkDefinitionLevels(int count);
    public int MarkDefinitionLevels(int count, int dl);
    public int get_DefinitionsRead();
    [NullableContextAttribute("1")]
public Array GetPlainData(Int32& offset, Int32& count);
    [NullableContextAttribute("1")]
public Array GetPlainDataToReadInto(Int32& offset);
    public void MarkUsefulPlainData(int count);
    [NullableContextAttribute("1")]
public void AssignDictionary(Array dictionary);
    public int get_ValuesRead();
    public void Pack(bool useDictionaryEncoding, double dictionaryThreshold);
    public void Checkpoint();
    [NullableContextAttribute("1")]
public DataColumn Unpack();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Parquet.File.StringListComparer : object {
    private List`1<string> _key;
    public StringListComparer(List`1<string> key);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private bool Equals(StringListComparer other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Parquet.File.ThriftFooter : object {
    private FileMetaData _fileMeta;
    private ThriftSchemaTree _tree;
    internal static ThriftFooter Empty { get; }
    public Dictionary`2<string, string> CustomMetadata { get; public set; }
    public ThriftFooter(FileMetaData fileMeta);
    public ThriftFooter(ParquetSchema schema, long totalRowCount);
    internal static ThriftFooter get_Empty();
    internal static ParquetSchema Parse(SchemaElement[] elements);
    public void set_CustomMetadata(Dictionary`2<string, string> value);
    public Dictionary`2<string, string> get_CustomMetadata();
    public void Add(long totalRowCount);
    [AsyncStateMachineAttribute("Parquet.File.ThriftFooter/<WriteAsync>d__12")]
public Task`1<long> WriteAsync(Stream s, CancellationToken cancellationToken);
    public SchemaElement GetSchemaElement(ColumnChunk columnChunk);
    public FieldPath GetPath(SchemaElement schemaElement);
    public SchemaElement[] GetWriteableSchema();
    public RowGroup AddRowGroup();
    public ColumnChunk CreateColumnChunk(CompressionMethod compression, Stream output, Type columnType, FieldPath path, int valuesCount, Dictionary`2<string, string> keyValueMetadata);
    public PageHeader CreateDataPage(int valueCount, bool isDictionary, bool isDeltaEncodable);
    public PageHeader CreateDictionaryPage(int numValues);
    public ParquetSchema CreateModelSchema(ParquetOptions formatOptions);
    private void CreateModelSchema(FieldPath path, IList`1<Field> container, int childCount, Int32& si, ParquetOptions formatOptions);
    public FileMetaData CreateThriftSchema(ParquetSchema schema);
    private static SchemaElement AddRoot(IList`1<SchemaElement> container);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Parquet.File.Values.Primitives.BigDecimal : ValueType {
    [CompilerGeneratedAttribute]
private decimal <DecimalValue>k__BackingField;
    [CompilerGeneratedAttribute]
private BigInteger <UnscaledValue>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Scale>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Precision>k__BackingField;
    public decimal DecimalValue { get; public set; }
    public BigInteger UnscaledValue { get; public set; }
    public int Scale { get; public set; }
    public int Precision { get; public set; }
    public BigDecimal(Byte[] data, SchemaElement schema, bool isReversed);
    public BigDecimal(decimal d, int precision, int scale);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public decimal get_DecimalValue();
    [CompilerGeneratedAttribute]
public void set_DecimalValue(decimal value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public BigInteger get_UnscaledValue();
    [CompilerGeneratedAttribute]
public void set_UnscaledValue(BigInteger value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Scale();
    [CompilerGeneratedAttribute]
public void set_Scale(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Precision();
    [CompilerGeneratedAttribute]
public void set_Precision(int value);
    public static decimal op_Implicit(BigDecimal bd);
    public static int GetBufferSize(int precision);
    private Byte[] AllocateResult();
    public Byte[] GetBytes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.File.Values.Primitives.Interval : ValueType {
    public static int BinarySize;
    [CompilerGeneratedAttribute]
private int <Millis>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Days>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Months>k__BackingField;
    public int Millis { get; public set; }
    public int Days { get; public set; }
    public int Months { get; public set; }
    public Interval(int months, int days, int millis);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Millis();
    [CompilerGeneratedAttribute]
public void set_Millis(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Days();
    [CompilerGeneratedAttribute]
public void set_Days(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Months();
    [CompilerGeneratedAttribute]
public void set_Months(int value);
    public Byte[] GetBytes();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Parquet.File.Values.Primitives.NanoTime : object {
    private int _julianDay;
    private long _timeOfDayNanos;
    public static int BinarySize;
    public NanoTime(Byte[] data, int offset);
    [NullableContextAttribute("0")]
public NanoTime(Span`1<byte> span);
    public NanoTime(DateTime dt);
    public void Write(BinaryWriter writer);
    public void Write(Stream s);
    public Byte[] GetBytes();
    public static DateTime op_Implicit(NanoTime nanoTime);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Parquet.Globals : object {
    public static string Version;
    public static string GithubSha;
    private static Globals();
}
[NullableContextAttribute("1")]
public interface Parquet.IParquetRowGroupReader {
    public RowGroup RowGroup { get; }
    public long RowCount { get; }
    public abstract virtual RowGroup get_RowGroup();
    public abstract virtual long get_RowCount();
    public abstract virtual bool ColumnExists(DataField field);
    public abstract virtual Task`1<DataColumn> ReadColumnAsync(DataField field, CancellationToken cancellationToken);
    public abstract virtual ColumnChunk GetMetadata(DataField field);
    public abstract virtual Dictionary`2<string, string> GetCustomMetadata(DataField field);
    public abstract virtual DataColumnStatistics GetStatistics(DataField field);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Parquet.Meta.AesGcmCtrV1 : object {
    [CompilerGeneratedAttribute]
private Byte[] <AadPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <AadFileUnique>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <SupplyAadPrefix>k__BackingField;
    public Byte[] AadPrefix { get; public set; }
    public Byte[] AadFileUnique { get; public set; }
    public Nullable`1<bool> SupplyAadPrefix { get; public set; }
    [CompilerGeneratedAttribute]
public Byte[] get_AadPrefix();
    [CompilerGeneratedAttribute]
public void set_AadPrefix(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_AadFileUnique();
    [CompilerGeneratedAttribute]
public void set_AadFileUnique(Byte[] value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_SupplyAadPrefix();
    [CompilerGeneratedAttribute]
public void set_SupplyAadPrefix(Nullable`1<bool> value);
    [NullableContextAttribute("1")]
internal void Write(ThriftCompactProtocolWriter proto);
    [NullableContextAttribute("1")]
internal static AesGcmCtrV1 Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Parquet.Meta.AesGcmV1 : object {
    [CompilerGeneratedAttribute]
private Byte[] <AadPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <AadFileUnique>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <SupplyAadPrefix>k__BackingField;
    public Byte[] AadPrefix { get; public set; }
    public Byte[] AadFileUnique { get; public set; }
    public Nullable`1<bool> SupplyAadPrefix { get; public set; }
    [CompilerGeneratedAttribute]
public Byte[] get_AadPrefix();
    [CompilerGeneratedAttribute]
public void set_AadPrefix(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_AadFileUnique();
    [CompilerGeneratedAttribute]
public void set_AadFileUnique(Byte[] value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_SupplyAadPrefix();
    [CompilerGeneratedAttribute]
public void set_SupplyAadPrefix(Nullable`1<bool> value);
    [NullableContextAttribute("1")]
internal void Write(ThriftCompactProtocolWriter proto);
    [NullableContextAttribute("1")]
internal static AesGcmV1 Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Parquet.Meta.BloomFilterAlgorithm : object {
    [CompilerGeneratedAttribute]
private SplitBlockAlgorithm <BLOCK>k__BackingField;
    public SplitBlockAlgorithm BLOCK { get; public set; }
    [CompilerGeneratedAttribute]
public SplitBlockAlgorithm get_BLOCK();
    [CompilerGeneratedAttribute]
public void set_BLOCK(SplitBlockAlgorithm value);
    [NullableContextAttribute("1")]
internal void Write(ThriftCompactProtocolWriter proto);
    [NullableContextAttribute("1")]
internal static BloomFilterAlgorithm Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Parquet.Meta.BloomFilterCompression : object {
    [CompilerGeneratedAttribute]
private Uncompressed <UNCOMPRESSED>k__BackingField;
    public Uncompressed UNCOMPRESSED { get; public set; }
    [CompilerGeneratedAttribute]
public Uncompressed get_UNCOMPRESSED();
    [CompilerGeneratedAttribute]
public void set_UNCOMPRESSED(Uncompressed value);
    [NullableContextAttribute("1")]
internal void Write(ThriftCompactProtocolWriter proto);
    [NullableContextAttribute("1")]
internal static BloomFilterCompression Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Parquet.Meta.BloomFilterHash : object {
    [CompilerGeneratedAttribute]
private XxHash <XXHASH>k__BackingField;
    public XxHash XXHASH { get; public set; }
    [CompilerGeneratedAttribute]
public XxHash get_XXHASH();
    [CompilerGeneratedAttribute]
public void set_XXHASH(XxHash value);
    [NullableContextAttribute("1")]
internal void Write(ThriftCompactProtocolWriter proto);
    [NullableContextAttribute("1")]
internal static BloomFilterHash Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.BloomFilterHeader : object {
    [CompilerGeneratedAttribute]
private int <NumBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private BloomFilterAlgorithm <Algorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private BloomFilterHash <Hash>k__BackingField;
    [CompilerGeneratedAttribute]
private BloomFilterCompression <Compression>k__BackingField;
    public int NumBytes { get; public set; }
    public BloomFilterAlgorithm Algorithm { get; public set; }
    public BloomFilterHash Hash { get; public set; }
    public BloomFilterCompression Compression { get; public set; }
    [CompilerGeneratedAttribute]
public int get_NumBytes();
    [CompilerGeneratedAttribute]
public void set_NumBytes(int value);
    [CompilerGeneratedAttribute]
public BloomFilterAlgorithm get_Algorithm();
    [CompilerGeneratedAttribute]
public void set_Algorithm(BloomFilterAlgorithm value);
    [CompilerGeneratedAttribute]
public BloomFilterHash get_Hash();
    [CompilerGeneratedAttribute]
public void set_Hash(BloomFilterHash value);
    [CompilerGeneratedAttribute]
public BloomFilterCompression get_Compression();
    [CompilerGeneratedAttribute]
public void set_Compression(BloomFilterCompression value);
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static BloomFilterHeader Read(ThriftCompactProtocolReader proto);
}
public enum Parquet.Meta.BoundaryOrder : Enum {
    public int value__;
    public static BoundaryOrder UNORDERED;
    public static BoundaryOrder ASCENDING;
    public static BoundaryOrder DESCENDING;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.BsonType : object {
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static BsonType Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Parquet.Meta.ColumnChunk : object {
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FileOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private ColumnMetaData <MetaData>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <OffsetIndexOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <OffsetIndexLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ColumnIndexOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ColumnIndexLength>k__BackingField;
    [CompilerGeneratedAttribute]
private ColumnCryptoMetaData <CryptoMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <EncryptedColumnMetadata>k__BackingField;
    public string FilePath { get; public set; }
    public long FileOffset { get; public set; }
    public ColumnMetaData MetaData { get; public set; }
    public Nullable`1<long> OffsetIndexOffset { get; public set; }
    public Nullable`1<int> OffsetIndexLength { get; public set; }
    public Nullable`1<long> ColumnIndexOffset { get; public set; }
    public Nullable`1<int> ColumnIndexLength { get; public set; }
    public ColumnCryptoMetaData CryptoMetadata { get; public set; }
    public Byte[] EncryptedColumnMetadata { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public long get_FileOffset();
    [CompilerGeneratedAttribute]
public void set_FileOffset(long value);
    [CompilerGeneratedAttribute]
public ColumnMetaData get_MetaData();
    [CompilerGeneratedAttribute]
public void set_MetaData(ColumnMetaData value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_OffsetIndexOffset();
    [CompilerGeneratedAttribute]
public void set_OffsetIndexOffset(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_OffsetIndexLength();
    [CompilerGeneratedAttribute]
public void set_OffsetIndexLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ColumnIndexOffset();
    [CompilerGeneratedAttribute]
public void set_ColumnIndexOffset(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ColumnIndexLength();
    [CompilerGeneratedAttribute]
public void set_ColumnIndexLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public ColumnCryptoMetaData get_CryptoMetadata();
    [CompilerGeneratedAttribute]
public void set_CryptoMetadata(ColumnCryptoMetaData value);
    [CompilerGeneratedAttribute]
public Byte[] get_EncryptedColumnMetadata();
    [CompilerGeneratedAttribute]
public void set_EncryptedColumnMetadata(Byte[] value);
    [NullableContextAttribute("1")]
internal void Write(ThriftCompactProtocolWriter proto);
    [NullableContextAttribute("1")]
internal static ColumnChunk Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Parquet.Meta.ColumnCryptoMetaData : object {
    [CompilerGeneratedAttribute]
private EncryptionWithFooterKey <ENCRYPTIONWITHFOOTERKEY>k__BackingField;
    [CompilerGeneratedAttribute]
private EncryptionWithColumnKey <ENCRYPTIONWITHCOLUMNKEY>k__BackingField;
    public EncryptionWithFooterKey ENCRYPTIONWITHFOOTERKEY { get; public set; }
    public EncryptionWithColumnKey ENCRYPTIONWITHCOLUMNKEY { get; public set; }
    [CompilerGeneratedAttribute]
public EncryptionWithFooterKey get_ENCRYPTIONWITHFOOTERKEY();
    [CompilerGeneratedAttribute]
public void set_ENCRYPTIONWITHFOOTERKEY(EncryptionWithFooterKey value);
    [CompilerGeneratedAttribute]
public EncryptionWithColumnKey get_ENCRYPTIONWITHCOLUMNKEY();
    [CompilerGeneratedAttribute]
public void set_ENCRYPTIONWITHCOLUMNKEY(EncryptionWithColumnKey value);
    [NullableContextAttribute("1")]
internal void Write(ThriftCompactProtocolWriter proto);
    [NullableContextAttribute("1")]
internal static ColumnCryptoMetaData Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.ColumnIndex : object {
    [CompilerGeneratedAttribute]
private List`1<bool> <NullPages>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Byte[]> <MinValues>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Byte[]> <MaxValues>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundaryOrder <BoundaryOrder>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private List`1<long> <NullCounts>k__BackingField;
    public List`1<bool> NullPages { get; public set; }
    public List`1<Byte[]> MinValues { get; public set; }
    public List`1<Byte[]> MaxValues { get; public set; }
    public BoundaryOrder BoundaryOrder { get; public set; }
    [NullableAttribute("2")]
public List`1<long> NullCounts { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<bool> get_NullPages();
    [CompilerGeneratedAttribute]
public void set_NullPages(List`1<bool> value);
    [CompilerGeneratedAttribute]
public List`1<Byte[]> get_MinValues();
    [CompilerGeneratedAttribute]
public void set_MinValues(List`1<Byte[]> value);
    [CompilerGeneratedAttribute]
public List`1<Byte[]> get_MaxValues();
    [CompilerGeneratedAttribute]
public void set_MaxValues(List`1<Byte[]> value);
    [CompilerGeneratedAttribute]
public BoundaryOrder get_BoundaryOrder();
    [CompilerGeneratedAttribute]
public void set_BoundaryOrder(BoundaryOrder value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public List`1<long> get_NullCounts();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_NullCounts(List`1<long> value);
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static ColumnIndex Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.ColumnMetaData : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Encoding> <Encodings>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <PathInSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionCodec <Codec>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumValues>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalUncompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalCompressedSize>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<KeyValue> <KeyValueMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DataPageOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <IndexPageOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <DictionaryPageOffset>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Statistics <Statistics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<PageEncodingStats> <EncodingStats>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <BloomFilterOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <BloomFilterLength>k__BackingField;
    public Type Type { get; public set; }
    public List`1<Encoding> Encodings { get; public set; }
    public List`1<string> PathInSchema { get; public set; }
    public CompressionCodec Codec { get; public set; }
    public long NumValues { get; public set; }
    public long TotalUncompressedSize { get; public set; }
    public long TotalCompressedSize { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<KeyValue> KeyValueMetadata { get; public set; }
    public long DataPageOffset { get; public set; }
    public Nullable`1<long> IndexPageOffset { get; public set; }
    public Nullable`1<long> DictionaryPageOffset { get; public set; }
    [NullableAttribute("2")]
public Statistics Statistics { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<PageEncodingStats> EncodingStats { get; public set; }
    public Nullable`1<long> BloomFilterOffset { get; public set; }
    public Nullable`1<int> BloomFilterLength { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
    [CompilerGeneratedAttribute]
public List`1<Encoding> get_Encodings();
    [CompilerGeneratedAttribute]
public void set_Encodings(List`1<Encoding> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_PathInSchema();
    [CompilerGeneratedAttribute]
public void set_PathInSchema(List`1<string> value);
    [CompilerGeneratedAttribute]
public CompressionCodec get_Codec();
    [CompilerGeneratedAttribute]
public void set_Codec(CompressionCodec value);
    [CompilerGeneratedAttribute]
public long get_NumValues();
    [CompilerGeneratedAttribute]
public void set_NumValues(long value);
    [CompilerGeneratedAttribute]
public long get_TotalUncompressedSize();
    [CompilerGeneratedAttribute]
public void set_TotalUncompressedSize(long value);
    [CompilerGeneratedAttribute]
public long get_TotalCompressedSize();
    [CompilerGeneratedAttribute]
public void set_TotalCompressedSize(long value);
    [CompilerGeneratedAttribute]
public List`1<KeyValue> get_KeyValueMetadata();
    [CompilerGeneratedAttribute]
public void set_KeyValueMetadata(List`1<KeyValue> value);
    [CompilerGeneratedAttribute]
public long get_DataPageOffset();
    [CompilerGeneratedAttribute]
public void set_DataPageOffset(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_IndexPageOffset();
    [CompilerGeneratedAttribute]
public void set_IndexPageOffset(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_DictionaryPageOffset();
    [CompilerGeneratedAttribute]
public void set_DictionaryPageOffset(Nullable`1<long> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Statistics get_Statistics();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Statistics(Statistics value);
    [CompilerGeneratedAttribute]
public List`1<PageEncodingStats> get_EncodingStats();
    [CompilerGeneratedAttribute]
public void set_EncodingStats(List`1<PageEncodingStats> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_BloomFilterOffset();
    [CompilerGeneratedAttribute]
public void set_BloomFilterOffset(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_BloomFilterLength();
    [CompilerGeneratedAttribute]
public void set_BloomFilterLength(Nullable`1<int> value);
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static ColumnMetaData Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Parquet.Meta.ColumnOrder : object {
    [CompilerGeneratedAttribute]
private TypeDefinedOrder <TYPEORDER>k__BackingField;
    public TypeDefinedOrder TYPEORDER { get; public set; }
    [CompilerGeneratedAttribute]
public TypeDefinedOrder get_TYPEORDER();
    [CompilerGeneratedAttribute]
public void set_TYPEORDER(TypeDefinedOrder value);
    [NullableContextAttribute("1")]
internal void Write(ThriftCompactProtocolWriter proto);
    [NullableContextAttribute("1")]
internal static ColumnOrder Read(ThriftCompactProtocolReader proto);
}
public enum Parquet.Meta.CompressionCodec : Enum {
    public int value__;
    public static CompressionCodec UNCOMPRESSED;
    public static CompressionCodec SNAPPY;
    public static CompressionCodec GZIP;
    public static CompressionCodec LZO;
    public static CompressionCodec BROTLI;
    public static CompressionCodec LZ4;
    public static CompressionCodec ZSTD;
    public static CompressionCodec LZ4_RAW;
}
public enum Parquet.Meta.ConvertedType : Enum {
    public int value__;
    public static ConvertedType UTF8;
    public static ConvertedType MAP;
    public static ConvertedType MAP_KEY_VALUE;
    public static ConvertedType LIST;
    public static ConvertedType ENUM;
    public static ConvertedType DECIMAL;
    public static ConvertedType DATE;
    public static ConvertedType TIME_MILLIS;
    public static ConvertedType TIME_MICROS;
    public static ConvertedType TIMESTAMP_MILLIS;
    public static ConvertedType TIMESTAMP_MICROS;
    public static ConvertedType UINT_8;
    public static ConvertedType UINT_16;
    public static ConvertedType UINT_32;
    public static ConvertedType UINT_64;
    public static ConvertedType INT_8;
    public static ConvertedType INT_16;
    public static ConvertedType INT_32;
    public static ConvertedType INT_64;
    public static ConvertedType JSON;
    public static ConvertedType BSON;
    public static ConvertedType INTERVAL;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Parquet.Meta.DataPageHeader : object {
    [CompilerGeneratedAttribute]
private int <NumValues>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <DefinitionLevelEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <RepetitionLevelEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private Statistics <Statistics>k__BackingField;
    public int NumValues { get; public set; }
    public Encoding Encoding { get; public set; }
    public Encoding DefinitionLevelEncoding { get; public set; }
    public Encoding RepetitionLevelEncoding { get; public set; }
    public Statistics Statistics { get; public set; }
    [CompilerGeneratedAttribute]
public int get_NumValues();
    [CompilerGeneratedAttribute]
public void set_NumValues(int value);
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public void set_Encoding(Encoding value);
    [CompilerGeneratedAttribute]
public Encoding get_DefinitionLevelEncoding();
    [CompilerGeneratedAttribute]
public void set_DefinitionLevelEncoding(Encoding value);
    [CompilerGeneratedAttribute]
public Encoding get_RepetitionLevelEncoding();
    [CompilerGeneratedAttribute]
public void set_RepetitionLevelEncoding(Encoding value);
    [CompilerGeneratedAttribute]
public Statistics get_Statistics();
    [CompilerGeneratedAttribute]
public void set_Statistics(Statistics value);
    [NullableContextAttribute("1")]
internal void Write(ThriftCompactProtocolWriter proto);
    [NullableContextAttribute("1")]
internal static DataPageHeader Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Parquet.Meta.DataPageHeaderV2 : object {
    [CompilerGeneratedAttribute]
private int <NumValues>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumNulls>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumRows>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DefinitionLevelsByteLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RepetitionLevelsByteLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsCompressed>k__BackingField;
    [CompilerGeneratedAttribute]
private Statistics <Statistics>k__BackingField;
    public int NumValues { get; public set; }
    public int NumNulls { get; public set; }
    public int NumRows { get; public set; }
    public Encoding Encoding { get; public set; }
    public int DefinitionLevelsByteLength { get; public set; }
    public int RepetitionLevelsByteLength { get; public set; }
    public Nullable`1<bool> IsCompressed { get; public set; }
    public Statistics Statistics { get; public set; }
    [CompilerGeneratedAttribute]
public int get_NumValues();
    [CompilerGeneratedAttribute]
public void set_NumValues(int value);
    [CompilerGeneratedAttribute]
public int get_NumNulls();
    [CompilerGeneratedAttribute]
public void set_NumNulls(int value);
    [CompilerGeneratedAttribute]
public int get_NumRows();
    [CompilerGeneratedAttribute]
public void set_NumRows(int value);
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public void set_Encoding(Encoding value);
    [CompilerGeneratedAttribute]
public int get_DefinitionLevelsByteLength();
    [CompilerGeneratedAttribute]
public void set_DefinitionLevelsByteLength(int value);
    [CompilerGeneratedAttribute]
public int get_RepetitionLevelsByteLength();
    [CompilerGeneratedAttribute]
public void set_RepetitionLevelsByteLength(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsCompressed();
    [CompilerGeneratedAttribute]
public void set_IsCompressed(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Statistics get_Statistics();
    [CompilerGeneratedAttribute]
public void set_Statistics(Statistics value);
    [NullableContextAttribute("1")]
internal void Write(ThriftCompactProtocolWriter proto);
    [NullableContextAttribute("1")]
internal static DataPageHeaderV2 Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.DateType : object {
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static DateType Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.DecimalType : object {
    [CompilerGeneratedAttribute]
private int <Scale>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Precision>k__BackingField;
    public int Scale { get; public set; }
    public int Precision { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Scale();
    [CompilerGeneratedAttribute]
public void set_Scale(int value);
    [CompilerGeneratedAttribute]
public int get_Precision();
    [CompilerGeneratedAttribute]
public void set_Precision(int value);
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static DecimalType Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.DictionaryPageHeader : object {
    [CompilerGeneratedAttribute]
private int <NumValues>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsSorted>k__BackingField;
    public int NumValues { get; public set; }
    public Encoding Encoding { get; public set; }
    public Nullable`1<bool> IsSorted { get; public set; }
    [CompilerGeneratedAttribute]
public int get_NumValues();
    [CompilerGeneratedAttribute]
public void set_NumValues(int value);
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public void set_Encoding(Encoding value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsSorted();
    [CompilerGeneratedAttribute]
public void set_IsSorted(Nullable`1<bool> value);
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static DictionaryPageHeader Read(ThriftCompactProtocolReader proto);
}
public enum Parquet.Meta.Encoding : Enum {
    public int value__;
    public static Encoding PLAIN;
    public static Encoding PLAIN_DICTIONARY;
    public static Encoding RLE;
    public static Encoding BIT_PACKED;
    public static Encoding DELTA_BINARY_PACKED;
    public static Encoding DELTA_LENGTH_BYTE_ARRAY;
    public static Encoding DELTA_BYTE_ARRAY;
    public static Encoding RLE_DICTIONARY;
    public static Encoding BYTE_STREAM_SPLIT;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Parquet.Meta.EncryptionAlgorithm : object {
    [CompilerGeneratedAttribute]
private AesGcmV1 <AESGCMV1>k__BackingField;
    [CompilerGeneratedAttribute]
private AesGcmCtrV1 <AESGCMCTRV1>k__BackingField;
    public AesGcmV1 AESGCMV1 { get; public set; }
    public AesGcmCtrV1 AESGCMCTRV1 { get; public set; }
    [CompilerGeneratedAttribute]
public AesGcmV1 get_AESGCMV1();
    [CompilerGeneratedAttribute]
public void set_AESGCMV1(AesGcmV1 value);
    [CompilerGeneratedAttribute]
public AesGcmCtrV1 get_AESGCMCTRV1();
    [CompilerGeneratedAttribute]
public void set_AESGCMCTRV1(AesGcmCtrV1 value);
    [NullableContextAttribute("1")]
internal void Write(ThriftCompactProtocolWriter proto);
    [NullableContextAttribute("1")]
internal static EncryptionAlgorithm Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.EncryptionWithColumnKey : object {
    [CompilerGeneratedAttribute]
private List`1<string> <PathInSchema>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Byte[] <KeyMetadata>k__BackingField;
    public List`1<string> PathInSchema { get; public set; }
    [NullableAttribute("2")]
public Byte[] KeyMetadata { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_PathInSchema();
    [CompilerGeneratedAttribute]
public void set_PathInSchema(List`1<string> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Byte[] get_KeyMetadata();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_KeyMetadata(Byte[] value);
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static EncryptionWithColumnKey Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.EncryptionWithFooterKey : object {
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static EncryptionWithFooterKey Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.EnumType : object {
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static EnumType Read(ThriftCompactProtocolReader proto);
}
public enum Parquet.Meta.FieldRepetitionType : Enum {
    public int value__;
    public static FieldRepetitionType REQUIRED;
    public static FieldRepetitionType OPTIONAL;
    public static FieldRepetitionType REPEATED;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.FileCryptoMetaData : object {
    [CompilerGeneratedAttribute]
private EncryptionAlgorithm <EncryptionAlgorithm>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Byte[] <KeyMetadata>k__BackingField;
    public EncryptionAlgorithm EncryptionAlgorithm { get; public set; }
    [NullableAttribute("2")]
public Byte[] KeyMetadata { get; public set; }
    [CompilerGeneratedAttribute]
public EncryptionAlgorithm get_EncryptionAlgorithm();
    [CompilerGeneratedAttribute]
public void set_EncryptionAlgorithm(EncryptionAlgorithm value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Byte[] get_KeyMetadata();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_KeyMetadata(Byte[] value);
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static FileCryptoMetaData Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Parquet.Meta.FileMetaData : object {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private List`1<SchemaElement> <Schema>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumRows>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private List`1<RowGroup> <RowGroups>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<KeyValue> <KeyValueMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CreatedBy>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<ColumnOrder> <ColumnOrders>k__BackingField;
    [CompilerGeneratedAttribute]
private EncryptionAlgorithm <EncryptionAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <FooterSigningKeyMetadata>k__BackingField;
    public int Version { get; public set; }
    [NullableAttribute("1")]
public List`1<SchemaElement> Schema { get; public set; }
    public long NumRows { get; public set; }
    [NullableAttribute("1")]
public List`1<RowGroup> RowGroups { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<KeyValue> KeyValueMetadata { get; public set; }
    public string CreatedBy { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<ColumnOrder> ColumnOrders { get; public set; }
    public EncryptionAlgorithm EncryptionAlgorithm { get; public set; }
    public Byte[] FooterSigningKeyMetadata { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public List`1<SchemaElement> get_Schema();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_Schema(List`1<SchemaElement> value);
    [CompilerGeneratedAttribute]
public long get_NumRows();
    [CompilerGeneratedAttribute]
public void set_NumRows(long value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public List`1<RowGroup> get_RowGroups();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_RowGroups(List`1<RowGroup> value);
    [CompilerGeneratedAttribute]
public List`1<KeyValue> get_KeyValueMetadata();
    [CompilerGeneratedAttribute]
public void set_KeyValueMetadata(List`1<KeyValue> value);
    [CompilerGeneratedAttribute]
public string get_CreatedBy();
    [CompilerGeneratedAttribute]
public void set_CreatedBy(string value);
    [CompilerGeneratedAttribute]
public List`1<ColumnOrder> get_ColumnOrders();
    [CompilerGeneratedAttribute]
public void set_ColumnOrders(List`1<ColumnOrder> value);
    [CompilerGeneratedAttribute]
public EncryptionAlgorithm get_EncryptionAlgorithm();
    [CompilerGeneratedAttribute]
public void set_EncryptionAlgorithm(EncryptionAlgorithm value);
    [CompilerGeneratedAttribute]
public Byte[] get_FooterSigningKeyMetadata();
    [CompilerGeneratedAttribute]
public void set_FooterSigningKeyMetadata(Byte[] value);
    [NullableContextAttribute("1")]
internal void Write(ThriftCompactProtocolWriter proto);
    [NullableContextAttribute("1")]
internal static FileMetaData Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.IndexPageHeader : object {
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static IndexPageHeader Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.IntType : object {
    [CompilerGeneratedAttribute]
private sbyte <BitWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSigned>k__BackingField;
    public sbyte BitWidth { get; public set; }
    public bool IsSigned { get; public set; }
    [CompilerGeneratedAttribute]
public sbyte get_BitWidth();
    [CompilerGeneratedAttribute]
public void set_BitWidth(sbyte value);
    [CompilerGeneratedAttribute]
public bool get_IsSigned();
    [CompilerGeneratedAttribute]
public void set_IsSigned(bool value);
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static IntType Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.JsonType : object {
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static JsonType Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.KeyValue : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Key { get; public set; }
    [NullableAttribute("2")]
public string Value { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Value();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Value(string value);
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static KeyValue Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.ListType : object {
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static ListType Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Parquet.Meta.LogicalType : object {
    [CompilerGeneratedAttribute]
private StringType <STRING>k__BackingField;
    [CompilerGeneratedAttribute]
private MapType <MAP>k__BackingField;
    [CompilerGeneratedAttribute]
private ListType <LIST>k__BackingField;
    [CompilerGeneratedAttribute]
private EnumType <ENUM>k__BackingField;
    [CompilerGeneratedAttribute]
private DecimalType <DECIMAL>k__BackingField;
    [CompilerGeneratedAttribute]
private DateType <DATE>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeType <TIME>k__BackingField;
    [CompilerGeneratedAttribute]
private TimestampType <TIMESTAMP>k__BackingField;
    [CompilerGeneratedAttribute]
private IntType <INTEGER>k__BackingField;
    [CompilerGeneratedAttribute]
private NullType <UNKNOWN>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonType <JSON>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonType <BSON>k__BackingField;
    [CompilerGeneratedAttribute]
private UUIDType <UUID>k__BackingField;
    public StringType STRING { get; public set; }
    public MapType MAP { get; public set; }
    public ListType LIST { get; public set; }
    public EnumType ENUM { get; public set; }
    public DecimalType DECIMAL { get; public set; }
    public DateType DATE { get; public set; }
    public TimeType TIME { get; public set; }
    public TimestampType TIMESTAMP { get; public set; }
    public IntType INTEGER { get; public set; }
    public NullType UNKNOWN { get; public set; }
    public JsonType JSON { get; public set; }
    public BsonType BSON { get; public set; }
    public UUIDType UUID { get; public set; }
    [CompilerGeneratedAttribute]
public StringType get_STRING();
    [CompilerGeneratedAttribute]
public void set_STRING(StringType value);
    [CompilerGeneratedAttribute]
public MapType get_MAP();
    [CompilerGeneratedAttribute]
public void set_MAP(MapType value);
    [CompilerGeneratedAttribute]
public ListType get_LIST();
    [CompilerGeneratedAttribute]
public void set_LIST(ListType value);
    [CompilerGeneratedAttribute]
public EnumType get_ENUM();
    [CompilerGeneratedAttribute]
public void set_ENUM(EnumType value);
    [CompilerGeneratedAttribute]
public DecimalType get_DECIMAL();
    [CompilerGeneratedAttribute]
public void set_DECIMAL(DecimalType value);
    [CompilerGeneratedAttribute]
public DateType get_DATE();
    [CompilerGeneratedAttribute]
public void set_DATE(DateType value);
    [CompilerGeneratedAttribute]
public TimeType get_TIME();
    [CompilerGeneratedAttribute]
public void set_TIME(TimeType value);
    [CompilerGeneratedAttribute]
public TimestampType get_TIMESTAMP();
    [CompilerGeneratedAttribute]
public void set_TIMESTAMP(TimestampType value);
    [CompilerGeneratedAttribute]
public IntType get_INTEGER();
    [CompilerGeneratedAttribute]
public void set_INTEGER(IntType value);
    [CompilerGeneratedAttribute]
public NullType get_UNKNOWN();
    [CompilerGeneratedAttribute]
public void set_UNKNOWN(NullType value);
    [CompilerGeneratedAttribute]
public JsonType get_JSON();
    [CompilerGeneratedAttribute]
public void set_JSON(JsonType value);
    [CompilerGeneratedAttribute]
public BsonType get_BSON();
    [CompilerGeneratedAttribute]
public void set_BSON(BsonType value);
    [CompilerGeneratedAttribute]
public UUIDType get_UUID();
    [CompilerGeneratedAttribute]
public void set_UUID(UUIDType value);
    [NullableContextAttribute("1")]
internal void Write(ThriftCompactProtocolWriter proto);
    [NullableContextAttribute("1")]
internal static LogicalType Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.MapType : object {
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static MapType Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.MicroSeconds : object {
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static MicroSeconds Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.MilliSeconds : object {
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static MilliSeconds Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.NanoSeconds : object {
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static NanoSeconds Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.NullType : object {
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static NullType Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.OffsetIndex : object {
    [CompilerGeneratedAttribute]
private List`1<PageLocation> <PageLocations>k__BackingField;
    public List`1<PageLocation> PageLocations { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<PageLocation> get_PageLocations();
    [CompilerGeneratedAttribute]
public void set_PageLocations(List`1<PageLocation> value);
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static OffsetIndex Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.PageEncodingStats : object {
    [CompilerGeneratedAttribute]
private PageType <PageType>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public PageType PageType { get; public set; }
    public Encoding Encoding { get; public set; }
    public int Count { get; public set; }
    [CompilerGeneratedAttribute]
public PageType get_PageType();
    [CompilerGeneratedAttribute]
public void set_PageType(PageType value);
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public void set_Encoding(Encoding value);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(int value);
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static PageEncodingStats Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Parquet.Meta.PageHeader : object {
    [CompilerGeneratedAttribute]
private PageType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UncompressedPageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CompressedPageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Crc>k__BackingField;
    [CompilerGeneratedAttribute]
private DataPageHeader <DataPageHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexPageHeader <IndexPageHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private DictionaryPageHeader <DictionaryPageHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private DataPageHeaderV2 <DataPageHeaderV2>k__BackingField;
    public PageType Type { get; public set; }
    public int UncompressedPageSize { get; public set; }
    public int CompressedPageSize { get; public set; }
    public Nullable`1<int> Crc { get; public set; }
    public DataPageHeader DataPageHeader { get; public set; }
    public IndexPageHeader IndexPageHeader { get; public set; }
    public DictionaryPageHeader DictionaryPageHeader { get; public set; }
    public DataPageHeaderV2 DataPageHeaderV2 { get; public set; }
    [CompilerGeneratedAttribute]
public PageType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(PageType value);
    [CompilerGeneratedAttribute]
public int get_UncompressedPageSize();
    [CompilerGeneratedAttribute]
public void set_UncompressedPageSize(int value);
    [CompilerGeneratedAttribute]
public int get_CompressedPageSize();
    [CompilerGeneratedAttribute]
public void set_CompressedPageSize(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Crc();
    [CompilerGeneratedAttribute]
public void set_Crc(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public DataPageHeader get_DataPageHeader();
    [CompilerGeneratedAttribute]
public void set_DataPageHeader(DataPageHeader value);
    [CompilerGeneratedAttribute]
public IndexPageHeader get_IndexPageHeader();
    [CompilerGeneratedAttribute]
public void set_IndexPageHeader(IndexPageHeader value);
    [CompilerGeneratedAttribute]
public DictionaryPageHeader get_DictionaryPageHeader();
    [CompilerGeneratedAttribute]
public void set_DictionaryPageHeader(DictionaryPageHeader value);
    [CompilerGeneratedAttribute]
public DataPageHeaderV2 get_DataPageHeaderV2();
    [CompilerGeneratedAttribute]
public void set_DataPageHeaderV2(DataPageHeaderV2 value);
    [NullableContextAttribute("1")]
internal void Write(ThriftCompactProtocolWriter proto);
    [NullableContextAttribute("1")]
internal static PageHeader Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.PageLocation : object {
    [CompilerGeneratedAttribute]
private long <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CompressedPageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FirstRowIndex>k__BackingField;
    public long Offset { get; public set; }
    public int CompressedPageSize { get; public set; }
    public long FirstRowIndex { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(long value);
    [CompilerGeneratedAttribute]
public int get_CompressedPageSize();
    [CompilerGeneratedAttribute]
public void set_CompressedPageSize(int value);
    [CompilerGeneratedAttribute]
public long get_FirstRowIndex();
    [CompilerGeneratedAttribute]
public void set_FirstRowIndex(long value);
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static PageLocation Read(ThriftCompactProtocolReader proto);
}
public enum Parquet.Meta.PageType : Enum {
    public int value__;
    public static PageType DATA_PAGE;
    public static PageType INDEX_PAGE;
    public static PageType DICTIONARY_PAGE;
    public static PageType DATA_PAGE_V2;
}
internal enum Parquet.Meta.Proto.CompactType : Enum {
    public byte value__;
    public static CompactType Stop;
    public static CompactType BooleanTrue;
    public static CompactType BooleanFalse;
    public static CompactType Byte;
    public static CompactType I16;
    public static CompactType I32;
    public static CompactType I64;
    public static CompactType Double;
    public static CompactType Binary;
    public static CompactType List;
    public static CompactType Set;
    public static CompactType Map;
    public static CompactType Struct;
    public static CompactType Uuid;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Parquet.Meta.Proto.ThriftCompactProtocolReader : object {
    private Stream _inputStream;
    private Stack`1<short> _lastField;
    private short _lastFieldId;
    public ThriftCompactProtocolReader(Stream inputStream);
    public void StructBegin();
    public void StructEnd();
    private static int ZigzagToInt(UInt32 n);
    private static long ZigzagToLong(ulong n);
    private UInt32 ReadVarInt32();
    private ulong ReadVarInt64();
    public bool ReadBool();
    public sbyte ReadByte();
    public short ReadI16();
    public int ReadI32();
    public long ReadI64();
    public Byte[] ReadBinary();
    public string ReadString();
    public bool ReadNextField(Int16& fieldId, CompactType& compactType);
    public int ReadListHeader(CompactType& elementType);
    public void SkipField(CompactType compactType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Parquet.Meta.Proto.ThriftCompactProtocolWriter : object {
    private Stack`1<short> _lastField;
    private Stream _outputStream;
    private short _lastFieldId;
    private VarInt PreAllocatedVarInt;
    public ThriftCompactProtocolWriter(Stream outputStream);
    public void StructBegin();
    public void StructEnd();
    public void WriteEmptyStruct();
    private static void Int32ToVarInt(UInt32 n, VarInt& varint);
    private static void Int64ToVarInt(ulong n, VarInt& varint);
    private static UInt32 IntToZigzag(int n);
    private static ulong LongToZigzag(long n);
    private void WriteI16Async(short i16);
    private void WriteFieldBegin(short fieldId, CompactType fieldType);
    public void BeginInlineStruct(short fieldId);
    public void WriteBoolValue(bool value);
    public void WriteBoolField(short fieldId, bool value);
    public void WriteByteField(short fieldId, sbyte value);
    public void WriteI16Field(short fieldId, short value);
    public void WriteI32Value(int value);
    public void WriteI32Field(short fieldId, int value);
    public void WriteI64Value(long value);
    public void WriteI64Field(short fieldId, long value);
    public void WriteBinaryValue(Byte[] value);
    public void WriteBinaryField(short fieldId, Byte[] value);
    public void WriteStringValue(string value);
    public void WriteStringField(short fieldId, string value);
    public void WriteListBegin(short fieldId, byte elementType, int elementCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.RowGroup : object {
    [CompilerGeneratedAttribute]
private List`1<ColumnChunk> <Columns>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalByteSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumRows>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<SortingColumn> <SortingColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <FileOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <TotalCompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<short> <Ordinal>k__BackingField;
    public List`1<ColumnChunk> Columns { get; public set; }
    public long TotalByteSize { get; public set; }
    public long NumRows { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<SortingColumn> SortingColumns { get; public set; }
    public Nullable`1<long> FileOffset { get; public set; }
    public Nullable`1<long> TotalCompressedSize { get; public set; }
    public Nullable`1<short> Ordinal { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<ColumnChunk> get_Columns();
    [CompilerGeneratedAttribute]
public void set_Columns(List`1<ColumnChunk> value);
    [CompilerGeneratedAttribute]
public long get_TotalByteSize();
    [CompilerGeneratedAttribute]
public void set_TotalByteSize(long value);
    [CompilerGeneratedAttribute]
public long get_NumRows();
    [CompilerGeneratedAttribute]
public void set_NumRows(long value);
    [CompilerGeneratedAttribute]
public List`1<SortingColumn> get_SortingColumns();
    [CompilerGeneratedAttribute]
public void set_SortingColumns(List`1<SortingColumn> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_FileOffset();
    [CompilerGeneratedAttribute]
public void set_FileOffset(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_TotalCompressedSize();
    [CompilerGeneratedAttribute]
public void set_TotalCompressedSize(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<short> get_Ordinal();
    [CompilerGeneratedAttribute]
public void set_Ordinal(Nullable`1<short> value);
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static RowGroup Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.SchemaElement : object {
    [CompilerGeneratedAttribute]
private Nullable`1<Type> <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <TypeLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<FieldRepetitionType> <RepetitionType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <NumChildren>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ConvertedType> <ConvertedType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Scale>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Precision>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <FieldId>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private LogicalType <LogicalType>k__BackingField;
    public Nullable`1<Type> Type { get; public set; }
    public Nullable`1<int> TypeLength { get; public set; }
    public Nullable`1<FieldRepetitionType> RepetitionType { get; public set; }
    public string Name { get; public set; }
    public Nullable`1<int> NumChildren { get; public set; }
    public Nullable`1<ConvertedType> ConvertedType { get; public set; }
    public Nullable`1<int> Scale { get; public set; }
    public Nullable`1<int> Precision { get; public set; }
    public Nullable`1<int> FieldId { get; public set; }
    [NullableAttribute("2")]
public LogicalType LogicalType { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<Type> get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Nullable`1<Type> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_TypeLength();
    [CompilerGeneratedAttribute]
public void set_TypeLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<FieldRepetitionType> get_RepetitionType();
    [CompilerGeneratedAttribute]
public void set_RepetitionType(Nullable`1<FieldRepetitionType> value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_NumChildren();
    [CompilerGeneratedAttribute]
public void set_NumChildren(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ConvertedType> get_ConvertedType();
    [CompilerGeneratedAttribute]
public void set_ConvertedType(Nullable`1<ConvertedType> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Scale();
    [CompilerGeneratedAttribute]
public void set_Scale(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Precision();
    [CompilerGeneratedAttribute]
public void set_Precision(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_FieldId();
    [CompilerGeneratedAttribute]
public void set_FieldId(Nullable`1<int> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public LogicalType get_LogicalType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_LogicalType(LogicalType value);
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static SchemaElement Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.SortingColumn : object {
    [CompilerGeneratedAttribute]
private int <ColumnIdx>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Descending>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NullsFirst>k__BackingField;
    public int ColumnIdx { get; public set; }
    public bool Descending { get; public set; }
    public bool NullsFirst { get; public set; }
    [CompilerGeneratedAttribute]
public int get_ColumnIdx();
    [CompilerGeneratedAttribute]
public void set_ColumnIdx(int value);
    [CompilerGeneratedAttribute]
public bool get_Descending();
    [CompilerGeneratedAttribute]
public void set_Descending(bool value);
    [CompilerGeneratedAttribute]
public bool get_NullsFirst();
    [CompilerGeneratedAttribute]
public void set_NullsFirst(bool value);
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static SortingColumn Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.SplitBlockAlgorithm : object {
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static SplitBlockAlgorithm Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Parquet.Meta.Statistics : object {
    [CompilerGeneratedAttribute]
private Byte[] <Max>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <NullCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <DistinctCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <MaxValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <MinValue>k__BackingField;
    public Byte[] Max { get; public set; }
    public Byte[] Min { get; public set; }
    public Nullable`1<long> NullCount { get; public set; }
    public Nullable`1<long> DistinctCount { get; public set; }
    public Byte[] MaxValue { get; public set; }
    public Byte[] MinValue { get; public set; }
    [CompilerGeneratedAttribute]
public Byte[] get_Max();
    [CompilerGeneratedAttribute]
public void set_Max(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_Min();
    [CompilerGeneratedAttribute]
public void set_Min(Byte[] value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_NullCount();
    [CompilerGeneratedAttribute]
public void set_NullCount(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_DistinctCount();
    [CompilerGeneratedAttribute]
public void set_DistinctCount(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Byte[] get_MaxValue();
    [CompilerGeneratedAttribute]
public void set_MaxValue(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_MinValue();
    [CompilerGeneratedAttribute]
public void set_MinValue(Byte[] value);
    [NullableContextAttribute("1")]
internal void Write(ThriftCompactProtocolWriter proto);
    [NullableContextAttribute("1")]
internal static Statistics Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.StringType : object {
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static StringType Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.TimestampType : object {
    [CompilerGeneratedAttribute]
private bool <IsAdjustedToUTC>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeUnit <Unit>k__BackingField;
    public bool IsAdjustedToUTC { get; public set; }
    public TimeUnit Unit { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsAdjustedToUTC();
    [CompilerGeneratedAttribute]
public void set_IsAdjustedToUTC(bool value);
    [CompilerGeneratedAttribute]
public TimeUnit get_Unit();
    [CompilerGeneratedAttribute]
public void set_Unit(TimeUnit value);
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static TimestampType Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.TimeType : object {
    [CompilerGeneratedAttribute]
private bool <IsAdjustedToUTC>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeUnit <Unit>k__BackingField;
    public bool IsAdjustedToUTC { get; public set; }
    public TimeUnit Unit { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsAdjustedToUTC();
    [CompilerGeneratedAttribute]
public void set_IsAdjustedToUTC(bool value);
    [CompilerGeneratedAttribute]
public TimeUnit get_Unit();
    [CompilerGeneratedAttribute]
public void set_Unit(TimeUnit value);
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static TimeType Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Parquet.Meta.TimeUnit : object {
    [CompilerGeneratedAttribute]
private MilliSeconds <MILLIS>k__BackingField;
    [CompilerGeneratedAttribute]
private MicroSeconds <MICROS>k__BackingField;
    [CompilerGeneratedAttribute]
private NanoSeconds <NANOS>k__BackingField;
    public MilliSeconds MILLIS { get; public set; }
    public MicroSeconds MICROS { get; public set; }
    public NanoSeconds NANOS { get; public set; }
    [CompilerGeneratedAttribute]
public MilliSeconds get_MILLIS();
    [CompilerGeneratedAttribute]
public void set_MILLIS(MilliSeconds value);
    [CompilerGeneratedAttribute]
public MicroSeconds get_MICROS();
    [CompilerGeneratedAttribute]
public void set_MICROS(MicroSeconds value);
    [CompilerGeneratedAttribute]
public NanoSeconds get_NANOS();
    [CompilerGeneratedAttribute]
public void set_NANOS(NanoSeconds value);
    [NullableContextAttribute("1")]
internal void Write(ThriftCompactProtocolWriter proto);
    [NullableContextAttribute("1")]
internal static TimeUnit Read(ThriftCompactProtocolReader proto);
}
public enum Parquet.Meta.Type : Enum {
    public int value__;
    public static Type BOOLEAN;
    public static Type INT32;
    public static Type INT64;
    public static Type INT96;
    public static Type FLOAT;
    public static Type DOUBLE;
    public static Type BYTE_ARRAY;
    public static Type FIXED_LEN_BYTE_ARRAY;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.TypeDefinedOrder : object {
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static TypeDefinedOrder Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.Uncompressed : object {
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static Uncompressed Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.UUIDType : object {
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static UUIDType Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Meta.XxHash : object {
    internal void Write(ThriftCompactProtocolWriter proto);
    internal static XxHash Read(ThriftCompactProtocolReader proto);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Parquet.OtherExtensions : object {
    private static DateTime UnixEpoch;
    private static long UnixEpochMilliseconds;
    private static long UnixEpochMicroseconds;
    private static long UnixEpochNanoseconds;
    private static OtherExtensions();
    [ExtensionAttribute]
public static DateTimeOffset FromUnixMilliseconds(long unixMilliseconds);
    [ExtensionAttribute]
public static DateTime AsUnixMillisecondsInDateTime(long unixMilliseconds);
    [ExtensionAttribute]
public static long ToUnixMilliseconds(DateTime dto);
    [ExtensionAttribute]
public static long ToUnixMicroseconds(DateTime dto);
    [ExtensionAttribute]
public static long ToUnixNanoseconds(DateTime dto);
    [ExtensionAttribute]
public static DateTime AsUnixDaysInDateTime(int unixDays);
    [ExtensionAttribute]
public static int ToUnixDays(DateTime dto);
    [ExtensionAttribute]
public static int ToUnixDays(DateOnly dto);
    [ExtensionAttribute]
public static DateTime ToUtc(DateTime dto);
    [ExtensionAttribute]
public static string AddPath(string s, String[] parts);
    [ExtensionAttribute]
public static bool EqualTo(Array left, Array right);
    public static Exception NotImplemented(string reason);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.ParquetActor : object {
    internal static Byte[] MagicBytes;
    private Stream _fileStream;
    [NullableAttribute("2")]
private BinaryWriter _binaryWriter;
    protected Stream Stream { get; }
    internal BinaryWriter Writer { get; }
    [NullableContextAttribute("2")]
internal ParquetActor(Stream fileStream);
    private static ParquetActor();
    protected Stream get_Stream();
    internal BinaryWriter get_Writer();
    [AsyncStateMachineAttribute("Parquet.ParquetActor/<ValidateFileAsync>d__8")]
protected Task ValidateFileAsync();
    [AsyncStateMachineAttribute("Parquet.ParquetActor/<ReadMetadataAsync>d__9")]
internal ValueTask`1<FileMetaData> ReadMetadataAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Parquet.ParquetActor/<GoBeforeFooterAsync>d__10")]
internal ValueTask`1<int> GoBeforeFooterAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.ParquetException : Exception {
    public ParquetException(string message);
    public ParquetException(string message, Exception inner);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Parquet.ParquetExtensions : object {
    [AsyncStateMachineAttribute("Parquet.ParquetExtensions/<WriteSingleRowGroupParquetFileAsync>d__0")]
[ExtensionAttribute]
public static Task WriteSingleRowGroupParquetFileAsync(Stream stream, ParquetSchema schema, DataColumn[] columns);
    [AsyncStateMachineAttribute("Parquet.ParquetExtensions/<ReadSingleRowGroupParquetFile>d__1")]
[ExtensionAttribute]
public static Task`1<ValueTuple`2<ParquetSchema, DataColumn[]>> ReadSingleRowGroupParquetFile(Stream stream);
    [AsyncStateMachineAttribute("Parquet.ParquetExtensions/<WriteAsync>d__2")]
[ExtensionAttribute]
public static Task WriteAsync(ParquetWriter writer, Table table);
    [AsyncStateMachineAttribute("Parquet.ParquetExtensions/<WriteAsync>d__3")]
[ExtensionAttribute]
public static Task WriteAsync(Table table, Stream output, ParquetOptions formatOptions, bool append, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Parquet.ParquetExtensions/<WriteAsync>d__4")]
[ExtensionAttribute]
public static Task WriteAsync(Table table, string path, ParquetOptions formatOptions, bool append, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Parquet.ParquetExtensions/<ReadAsTableAsync>d__5")]
[ExtensionAttribute]
public static Task`1<Table> ReadAsTableAsync(ParquetReader reader, TableReaderProgressCallback progressCallback, Nullable`1<int> rowGroupIndex);
    [AsyncStateMachineAttribute("Parquet.ParquetExtensions/<WriteAsync>d__6")]
[ExtensionAttribute]
public static Task WriteAsync(ParquetRowGroupWriter writer, Table table);
    [AsyncStateMachineAttribute("Parquet.ParquetExtensions/<ReadParquetAsDataFrameAsync>d__7")]
[ExtensionAttribute]
public static Task`1<DataFrame> ReadParquetAsDataFrameAsync(Stream inputStream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Parquet.ParquetExtensions/<WriteAsync>d__8")]
[ExtensionAttribute]
public static Task WriteAsync(DataFrame df, Stream outputStream, CancellationToken cancellationToken);
}
public class Parquet.ParquetOptions : object {
    [CompilerGeneratedAttribute]
private bool <TreatByteArrayAsString>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TreatBigIntegersAsDates>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseDateOnlyTypeForDates>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseTimeOnlyTypeForTimeMillis>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseTimeOnlyTypeForTimeMicros>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseDictionaryEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DictionaryEncodingThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseDeltaBinaryPackedEncoding>k__BackingField;
    public bool TreatByteArrayAsString { get; public set; }
    public bool TreatBigIntegersAsDates { get; public set; }
    public bool UseDateOnlyTypeForDates { get; public set; }
    public bool UseTimeOnlyTypeForTimeMillis { get; public set; }
    public bool UseTimeOnlyTypeForTimeMicros { get; public set; }
    public bool UseDictionaryEncoding { get; public set; }
    public double DictionaryEncodingThreshold { get; public set; }
    public bool UseDeltaBinaryPackedEncoding { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_TreatByteArrayAsString();
    [CompilerGeneratedAttribute]
public void set_TreatByteArrayAsString(bool value);
    [CompilerGeneratedAttribute]
public bool get_TreatBigIntegersAsDates();
    [CompilerGeneratedAttribute]
public void set_TreatBigIntegersAsDates(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseDateOnlyTypeForDates();
    [CompilerGeneratedAttribute]
public void set_UseDateOnlyTypeForDates(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseTimeOnlyTypeForTimeMillis();
    [CompilerGeneratedAttribute]
public void set_UseTimeOnlyTypeForTimeMillis(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseTimeOnlyTypeForTimeMicros();
    [CompilerGeneratedAttribute]
public void set_UseTimeOnlyTypeForTimeMicros(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseDictionaryEncoding();
    [CompilerGeneratedAttribute]
public void set_UseDictionaryEncoding(bool value);
    [CompilerGeneratedAttribute]
public double get_DictionaryEncodingThreshold();
    [CompilerGeneratedAttribute]
public void set_DictionaryEncodingThreshold(double value);
    [CompilerGeneratedAttribute]
public bool get_UseDeltaBinaryPackedEncoding();
    [CompilerGeneratedAttribute]
public void set_UseDeltaBinaryPackedEncoding(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.ParquetReader : ParquetActor {
    private Stream _input;
    [NullableAttribute("2")]
private FileMetaData _meta;
    private ThriftFooter _thriftFooter;
    private ParquetOptions _parquetOptions;
    private List`1<ParquetRowGroupReader> _groupReaders;
    private bool _leaveStreamOpen;
    public Dictionary`2<string, string> CustomMetadata { get; }
    public int RowGroupCount { get; }
    public ParquetSchema Schema { get; }
    [NullableAttribute("2")]
public FileMetaData Metadata { get; }
    public IReadOnlyList`1<IParquetRowGroupReader> RowGroups { get; }
    private ParquetReader(Stream input, ParquetOptions parquetOptions, bool leaveStreamOpen);
    [AsyncStateMachineAttribute("Parquet.ParquetReader/<InitialiseAsync>d__7")]
private Task InitialiseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Parquet.ParquetReader/<CreateAsync>d__8")]
public static Task`1<ParquetReader> CreateAsync(string filePath, ParquetOptions parquetOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Parquet.ParquetReader/<CreateAsync>d__9")]
public static Task`1<ParquetReader> CreateAsync(Stream input, ParquetOptions parquetOptions, bool leaveStreamOpen, CancellationToken cancellationToken);
    public Dictionary`2<string, string> get_CustomMetadata();
    [AsyncStateMachineAttribute("Parquet.ParquetReader/<ReadTableFromFileAsync>d__12")]
public static Task`1<Table> ReadTableFromFileAsync(string filePath, ParquetOptions parquetOptions);
    [AsyncStateMachineAttribute("Parquet.ParquetReader/<ReadSchemaAsync>d__13")]
public static Task`1<ParquetSchema> ReadSchemaAsync(string filePath);
    [AsyncStateMachineAttribute("Parquet.ParquetReader/<ReadSchemaAsync>d__14")]
public static Task`1<ParquetSchema> ReadSchemaAsync(Stream parquetStream);
    [AsyncStateMachineAttribute("Parquet.ParquetReader/<ReadTableFromStreamAsync>d__15")]
public static Task`1<Table> ReadTableFromStreamAsync(Stream stream, ParquetOptions parquetOptions);
    public int get_RowGroupCount();
    public ParquetSchema get_Schema();
    [NullableContextAttribute("2")]
public FileMetaData get_Metadata();
    public ParquetRowGroupReader OpenRowGroupReader(int index);
    public IReadOnlyList`1<IParquetRowGroupReader> get_RowGroups();
    [AsyncStateMachineAttribute("Parquet.ParquetReader/<ReadEntireRowGroupAsync>d__25")]
public Task`1<DataColumn[]> ReadEntireRowGroupAsync(int rowGroupIndex);
    private void InitRowGroupReaders();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.ParquetRowGroupReader : object {
    private RowGroup _rowGroup;
    private ThriftFooter _footer;
    private Stream _stream;
    [NullableAttribute("2")]
private ParquetOptions _options;
    private Dictionary`2<FieldPath, ColumnChunk> _pathToChunk;
    public RowGroup RowGroup { get; }
    public long RowCount { get; }
    internal ParquetRowGroupReader(RowGroup rowGroup, ThriftFooter footer, Stream stream, ParquetOptions parquetOptions);
    public sealed virtual RowGroup get_RowGroup();
    public sealed virtual long get_RowCount();
    public sealed virtual bool ColumnExists(DataField field);
    public sealed virtual Task`1<DataColumn> ReadColumnAsync(DataField field, CancellationToken cancellationToken);
    public sealed virtual ColumnChunk GetMetadata(DataField field);
    public sealed virtual Dictionary`2<string, string> GetCustomMetadata(DataField field);
    private DataColumnStatistics ReadColumnStatistics(ColumnChunk cc);
    public sealed virtual DataColumnStatistics GetStatistics(DataField field);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.ParquetRowGroupWriter : object {
    private ParquetSchema _schema;
    private Stream _stream;
    private ThriftFooter _footer;
    private CompressionMethod _compressionMethod;
    private CompressionLevel _compressionLevel;
    private ParquetOptions _formatOptions;
    private RowGroup _owGroup;
    private SchemaElement[] _thschema;
    private int _colIdx;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <RowCount>k__BackingField;
    internal Nullable`1<long> RowCount { get; private set; }
    internal ParquetRowGroupWriter(ParquetSchema schema, Stream stream, ThriftFooter footer, CompressionMethod compressionMethod, ParquetOptions formatOptions, CompressionLevel compressionLevel);
    [CompilerGeneratedAttribute]
internal Nullable`1<long> get_RowCount();
    [CompilerGeneratedAttribute]
private void set_RowCount(Nullable`1<long> value);
    public Task WriteColumnAsync(DataColumn column, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Parquet.ParquetRowGroupWriter/<WriteColumnAsync>d__15")]
public Task WriteColumnAsync(DataColumn column, Dictionary`2<string, string> customMetadata, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.ParquetWriter : ParquetActor {
    [NullableAttribute("2")]
private ThriftFooter _footer;
    private ParquetSchema _schema;
    private ParquetOptions _formatOptions;
    private bool _dataWritten;
    private List`1<ParquetRowGroupWriter> _openedWriters;
    [CompilerGeneratedAttribute]
private CompressionMethod <CompressionMethod>k__BackingField;
    public CompressionLevel CompressionLevel;
    public CompressionMethod CompressionMethod { get; public set; }
    public IReadOnlyDictionary`2<string, string> CustomMetadata { get; public set; }
    private ParquetWriter(ParquetSchema schema, Stream output, ParquetOptions formatOptions, bool append);
    [CompilerGeneratedAttribute]
public CompressionMethod get_CompressionMethod();
    [CompilerGeneratedAttribute]
public void set_CompressionMethod(CompressionMethod value);
    [AsyncStateMachineAttribute("Parquet.ParquetWriter/<CreateAsync>d__11")]
public static Task`1<ParquetWriter> CreateAsync(ParquetSchema schema, Stream output, ParquetOptions formatOptions, bool append, CancellationToken cancellationToken);
    public ParquetRowGroupWriter CreateRowGroup();
    public IReadOnlyDictionary`2<string, string> get_CustomMetadata();
    public void set_CustomMetadata(IReadOnlyDictionary`2<string, string> value);
    [AsyncStateMachineAttribute("Parquet.ParquetWriter/<PrepareFileAsync>d__16")]
private Task PrepareFileAsync(bool append, CancellationToken cancellationToken);
    private void ValidateSchemasCompatible(ThriftFooter footer, ParquetSchema schema);
    private void WriteMagic();
    public sealed virtual void Dispose();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private Task`1<long> <Dispose>b__19_1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Parquet.ReferenceEqualityComparer`1 : object {
    [CompilerGeneratedAttribute]
private static IEqualityComparer`1<T> <Default>k__BackingField;
    public static IEqualityComparer`1<T> Default { get; }
    private static ReferenceEqualityComparer`1();
    [CompilerGeneratedAttribute]
public static IEqualityComparer`1<T> get_Default();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Parquet.Rows.DataColumnAppender : object {
    private DataField _dataField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<object> _values;
    private List`1<int> _rls;
    private bool _isRepeated;
    [NullableAttribute("2")]
private LevelIndex[] _lastIndexes;
    public DataColumnAppender(DataField dataField);
    public void Add(object value, LevelIndex[] indexes);
    public DataColumn ToDataColumn();
    public virtual string ToString();
    private static int GetRepetitionLevel(LevelIndex[] currentIndexes, LevelIndex[] lastIndexes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Parquet.Rows.DataColumnEnumerator : object {
    private int _position;
    private bool _isRepeated;
    private Array _data;
    [NullableAttribute("2")]
private Int32[] _rls;
    private DataField _field;
    private DataColumn _dc;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <Current>k__BackingField;
    [NullableAttribute("2")]
public object Current { get; private set; }
    public DataColumn DataColumn { get; }
    public DataColumnEnumerator(DataColumn dataColumn);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual object get_Current();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Current(object value);
    public DataColumn get_DataColumn();
    public sealed virtual bool MoveNext();
    [NullableContextAttribute("2")]
private int Read(int position, Object& cr);
    public sealed virtual void Reset();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Parquet.Rows.DataColumnsToRowsConverter : object {
    private ParquetSchema _schema;
    private DataColumn[] _columns;
    private long _totalRowRount;
    public DataColumnsToRowsConverter(ParquetSchema schema, DataColumn[] columns, long totalRowRount);
    public IReadOnlyCollection`1<Row> Convert();
    private void ColumnsToRows(IReadOnlyCollection`1<Field> fields, Dictionary`2<FieldPath, LazyColumnEnumerator> pathToColumn, List`1<Row> result, long rowCount);
    private IReadOnlyList`1<Row> BuildRows(IReadOnlyCollection`1<Field> fields, Dictionary`2<FieldPath, LazyColumnEnumerator> pathToColumn);
    private bool TryBuildNextRow(IReadOnlyCollection`1<Field> fields, Dictionary`2<FieldPath, LazyColumnEnumerator> pathToColumn, Row& row);
    private bool TryBuildNextCell(Field f, Dictionary`2<FieldPath, LazyColumnEnumerator> pathToColumn, Object& cell);
    private bool TryBuildListCell(ListField lf, Dictionary`2<FieldPath, LazyColumnEnumerator> pathToColumn, Object& cell);
    private bool TryBuildStructCell(StructField sf, Dictionary`2<FieldPath, LazyColumnEnumerator> pathToColumn, Row& cell);
    private bool TryBuildMapCell(MapField mf, Dictionary`2<FieldPath, LazyColumnEnumerator> pathToColumn, IReadOnlyList`1& rows);
    private static void ValidateColumnsAreInSchema(ParquetSchema schema, DataColumn[] columns);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Parquet.Rows.LazyColumnEnumerator : object {
    private DataColumn _dc;
    private int _start;
    private int _offset;
    private int _count;
    private Array _data;
    [NullableAttribute("2")]
private Int32[] _rls;
    private int _rl;
    private int _maxRl;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <Current>k__BackingField;
    [NullableAttribute("2")]
public object Current { get; private set; }
    public LazyColumnEnumerator(DataColumn dc);
    private LazyColumnEnumerator(DataColumn dc, int offset, int count, int rl);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual object get_Current();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Current(object value);
    public List`1<LazyColumnEnumerator> ToEnumeratorList();
    public Array ToDataArray();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private void ReadWindow();
    public sealed virtual IEnumerator GetEnumerator();
}
internal class Parquet.Rows.LevelIndex : ValueType {
    [CompilerGeneratedAttribute]
private int <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public int Level { get; public set; }
    public int Index { get; public set; }
    public LevelIndex(int level, int index);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Parquet.Rows.Row : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Field[] <Schema>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Object[] <Values>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Field[] Schema { get; internal set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] Values { get; internal set; }
    public int Length { get; }
    [NullableAttribute("2")]
public object Item { get; public set; }
    public Row(object value);
    public Row(IEnumerable`1<object> values);
    internal Row(IReadOnlyCollection`1<Field> schema, IEnumerable`1<object> values);
    public Row(Object[] values);
    [CompilerGeneratedAttribute]
internal Field[] get_Schema();
    [CompilerGeneratedAttribute]
internal void set_Schema(Field[] value);
    public static Row SingleCell(object value);
    [CompilerGeneratedAttribute]
public Object[] get_Values();
    [CompilerGeneratedAttribute]
internal void set_Values(Object[] value);
    public int get_Length();
    [NullableContextAttribute("2")]
public object get_Item(int i);
    [NullableContextAttribute("2")]
public void set_Item(int i, object value);
    public bool GetBoolean(int i);
    public int GetInt(int i);
    public float GetFloat(int i);
    public long GetLong(int i);
    public double GetDouble(int i);
    public BigInteger GetBigInt(int i);
    [NullableContextAttribute("2")]
public Byte[] GetByteArray(int i);
    [NullableContextAttribute("2")]
public string GetString(int i);
    public DateTime GetDateTime(int i);
    public bool IsNullAt(int i);
    [NullableContextAttribute("2")]
public T Get(int i);
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(string format, int rowIndex);
    [NullableContextAttribute("2")]
internal static StringFormat GetStringFormat(string format);
    internal void ToString(StringBuilder sb, StringFormat sf, int level, IReadOnlyCollection`1<Field> fields);
    internal void ToString(StringBuilder sb, Object[] values, StringFormat sf, int level, IReadOnlyCollection`1<Field> fields);
    [NullableContextAttribute("2")]
private void FormatValue(object v, StringBuilder sb, StringFormat sf, Field f, int level, bool appendPropertyName);
    private static IReadOnlyCollection`1<Field> GetMoreFields(Field f);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(Row other);
    [NullableContextAttribute("2")]
public bool Equals(Row other, bool throwException);
    [NullableContextAttribute("2")]
private bool Equal(object v, object ov, int position, bool throwException);
    public sealed virtual IEnumerator`1<object> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Parquet.Rows.RowsToDataColumnsConverter : object {
    private ParquetSchema _schema;
    private IReadOnlyCollection`1<Row> _rows;
    private Dictionary`2<FieldPath, DataColumnAppender> _pathToDataColumn;
    public RowsToDataColumnsConverter(ParquetSchema schema, IReadOnlyCollection`1<Row> rows);
    public IReadOnlyCollection`1<DataColumn> Convert();
    private void ProcessRows(IReadOnlyCollection`1<Field> fields, IReadOnlyCollection`1<Row> rows, int level, LevelIndex[] indexes);
    private void ProcessRow(IReadOnlyCollection`1<Field> fields, Row row, int level, LevelIndex[] indexes);
    private void ProcessMap(MapField mapField, IReadOnlyCollection`1<Row> mapRows, int level, LevelIndex[] indexes);
    private void ProcessList(ListField listField, object cellValue, int level, LevelIndex[] indexes);
    private void ProcessDataValue(Field f, object value, LevelIndex[] indexes);
    private DataColumnAppender GetAppender(Field f);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private DataColumn <Convert>b__4_0(DataField df);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Parquet.Rows.RowValidator : object {
    public static void Validate(Row row, IReadOnlyList`1<Field> fields);
    private static void ValidateMap(MapField mf, object value);
    private static void ValidateList(ListField lf, object value);
    private static void ValidatePrimitive(DataField df, object value);
}
internal enum Parquet.Rows.StringFormat : Enum {
    public int value__;
    public static StringFormat JsonSingleQuote;
    public static StringFormat Json;
    public static StringFormat Csv;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Parquet.Rows.Table : object {
    private List`1<Row> _rows;
    private Field[] _dfs;
    [CompilerGeneratedAttribute]
private ParquetSchema <Schema>k__BackingField;
    public ParquetSchema Schema { get; }
    public Row Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public Table(ParquetSchema schema);
    public Table(Field[] schema);
    internal Table(ParquetSchema schema, DataColumn[] tableData, long rowCount);
    [CompilerGeneratedAttribute]
public ParquetSchema get_Schema();
    internal IReadOnlyCollection`1<DataColumn> ExtractDataColumns();
    public sealed virtual Row get_Item(int index);
    public sealed virtual void set_Item(int index, Row value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(Row item);
    public void Add(Object[] rowCells);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Row item);
    public sealed virtual void CopyTo(Row[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<Row> GetEnumerator();
    public sealed virtual int IndexOf(Row item);
    public sealed virtual void Insert(int index, Row item);
    public sealed virtual bool Remove(Row item);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(Table other);
    [NullableContextAttribute("2")]
public bool Equals(Table other, bool throwExceptions);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public string ToString(string format);
    private string ToString(string format, int maxRows);
    [AsyncStateMachineAttribute("Parquet.Rows.Table/<ReadAsync>d__33")]
public static Task`1<Table> ReadAsync(Stream stream, ParquetOptions parquetOptions, TableReaderProgressCallback progressCallback);
    [AsyncStateMachineAttribute("Parquet.Rows.Table/<ReadAsync>d__34")]
public static Task`1<Table> ReadAsync(string fileName, ParquetOptions parquetOptions, TableReaderProgressCallback progressCallback);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Parquet.Rows.TreeList : object {
    private TreeList _parent;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<TreeList> _children;
    private List`1<object> _values;
    public bool HasValues { get; }
    public TreeList FirstChild { get; }
    public TreeList(TreeList parent);
    public bool get_HasValues();
    public TreeList get_FirstChild();
    public TreeList Submerge(int depth);
    public void Add(object value);
    [NullableContextAttribute("1")]
public object Compact(Type clrType);
    [NullableContextAttribute("1")]
public object ValuesAs(Type clrType);
    [NullableContextAttribute("1")]
public object FinalValue(Type clrType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Schema.DataField : Field {
    private bool _isNullable;
    private bool _isArray;
    [CompilerGeneratedAttribute]
private Type <ClrType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ClrNullableIfHasNullsType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAttachedToSchema>k__BackingField;
    public bool IsNullable { get; internal set; }
    [ObsoleteAttribute("Use IsNullable instead.")]
public bool HasNulls { get; }
    public bool IsArray { get; internal set; }
    public Type ClrType { get; private set; }
    public Type ClrNullableIfHasNullsType { get; public set; }
    [NullableAttribute("2")]
unknown FieldPath PathPrefix {internal set; }
    internal bool IsAttachedToSchema { get; internal set; }
    internal bool IsAtomic { get; }
    internal bool IsDeltaEncodable { get; }
    private Type BaseClrType { get; }
    public DataField(string name, Type clrType, Nullable`1<bool> isNullable, Nullable`1<bool> isArray, string propertyName, Nullable`1<bool> isCompiledWithNullable);
    public virtual bool get_IsNullable();
    internal virtual void set_IsNullable(bool value);
    public bool get_HasNulls();
    public bool get_IsArray();
    internal void set_IsArray(bool value);
    [CompilerGeneratedAttribute]
public Type get_ClrType();
    [CompilerGeneratedAttribute]
private void set_ClrType(Type value);
    [CompilerGeneratedAttribute]
public Type get_ClrNullableIfHasNullsType();
    [CompilerGeneratedAttribute]
public void set_ClrNullableIfHasNullsType(Type value);
    [NullableContextAttribute("2")]
internal virtual void set_PathPrefix(FieldPath value);
    [CompilerGeneratedAttribute]
internal bool get_IsAttachedToSchema();
    [CompilerGeneratedAttribute]
internal void set_IsAttachedToSchema(bool value);
    internal void EnsureAttachedToSchema(string argName);
    internal virtual void PropagateLevels(int parentRepetitionLevel, int parentDefinitionLevel);
    internal Array CreateArray(int length);
    internal Array UnpackDefinitions(Array definedData, Span`1<int> definitionLevels);
    internal virtual bool get_IsAtomic();
    internal bool get_IsDeltaEncodable();
    public virtual string ToString();
    private Type get_BaseClrType();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static void Discover(Type t, bool isCompiledWithNullable, Type& baseType, Boolean& isArray, Boolean& isNullable);
}
public class Parquet.Schema.DataField`1 : DataField {
    [NullableContextAttribute("1")]
public DataField`1(string name, Nullable`1<bool> nullable);
}
public class Parquet.Schema.DateTimeDataField : DataField {
    [CompilerGeneratedAttribute]
private DateTimeFormat <DateTimeFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAdjustedToUTC>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeTimeUnit <Unit>k__BackingField;
    public DateTimeFormat DateTimeFormat { get; }
    public bool IsAdjustedToUTC { get; }
    public DateTimeTimeUnit Unit { get; }
    [NullableContextAttribute("1")]
public DateTimeDataField(string name, DateTimeFormat format, bool isAdjustedToUTC, Nullable`1<DateTimeTimeUnit> unit, Nullable`1<bool> isNullable, Nullable`1<bool> isArray, string propertyName);
    [CompilerGeneratedAttribute]
public DateTimeFormat get_DateTimeFormat();
    [CompilerGeneratedAttribute]
public bool get_IsAdjustedToUTC();
    [CompilerGeneratedAttribute]
public DateTimeTimeUnit get_Unit();
}
public enum Parquet.Schema.DateTimeFormat : Enum {
    public int value__;
    public static DateTimeFormat Impala;
    public static DateTimeFormat DateAndTime;
    public static DateTimeFormat DateAndTimeMicros;
    public static DateTimeFormat Date;
    public static DateTimeFormat Timestamp;
}
public enum Parquet.Schema.DateTimeTimeUnit : Enum {
    public int value__;
    public static DateTimeTimeUnit Millis;
    public static DateTimeTimeUnit Micros;
    public static DateTimeTimeUnit Nanos;
}
public class Parquet.Schema.DecimalDataField : DataField {
    [CompilerGeneratedAttribute]
private int <Precision>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Scale>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceByteArrayEncoding>k__BackingField;
    public int Precision { get; }
    public int Scale { get; }
    public bool ForceByteArrayEncoding { get; }
    [NullableContextAttribute("1")]
public DecimalDataField(string name, int precision, int scale, bool forceByteArrayEncoding, Nullable`1<bool> isNullable, Nullable`1<bool> isArray, string propertyName);
    [CompilerGeneratedAttribute]
public int get_Precision();
    [CompilerGeneratedAttribute]
public int get_Scale();
    [CompilerGeneratedAttribute]
public bool get_ForceByteArrayEncoding();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Parquet.Schema.Field : object {
    [CompilerGeneratedAttribute]
private SchemaType <SchemaType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldPath <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNullable>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxRepetitionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDefinitionLevel>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ClrPropName>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SchemaElement <SchemaElement>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private Field[] <Children>k__BackingField;
    public SchemaType SchemaType { get; }
    public string Name { get; private set; }
    public FieldPath Path { get; internal set; }
    public bool IsNullable { get; internal set; }
    public int MaxRepetitionLevel { get; protected set; }
    public int MaxDefinitionLevel { get; protected set; }
    [NullableAttribute("2")]
internal string ClrPropName { get; internal set; }
    [NullableAttribute("2")]
public SchemaElement SchemaElement { get; internal set; }
    [NullableAttribute("2")]
unknown FieldPath PathPrefix {internal set; }
    internal Nullable`1<int> Order { get; internal set; }
    internal Field[] Children { get; }
    internal Field[] NaturalChildren { get; }
    internal bool IsAtomic { get; }
    protected Field(string name, SchemaType schemaType);
    [CompilerGeneratedAttribute]
public SchemaType get_SchemaType();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public FieldPath get_Path();
    [CompilerGeneratedAttribute]
internal void set_Path(FieldPath value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsNullable();
    [CompilerGeneratedAttribute]
internal virtual void set_IsNullable(bool value);
    internal List`1<string> GetNaturalChildPath(List`1<string> path);
    [CompilerGeneratedAttribute]
public int get_MaxRepetitionLevel();
    [CompilerGeneratedAttribute]
protected void set_MaxRepetitionLevel(int value);
    [CompilerGeneratedAttribute]
public int get_MaxDefinitionLevel();
    [CompilerGeneratedAttribute]
protected void set_MaxDefinitionLevel(int value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal string get_ClrPropName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_ClrPropName(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public SchemaElement get_SchemaElement();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_SchemaElement(SchemaElement value);
    [NullableContextAttribute("2")]
internal virtual void set_PathPrefix(FieldPath value);
    [CompilerGeneratedAttribute]
internal Nullable`1<int> get_Order();
    [CompilerGeneratedAttribute]
internal void set_Order(Nullable`1<int> value);
    internal abstract virtual void PropagateLevels(int parentRepetitionLevel, int parentDefinitionLevel);
    internal virtual void Assign(Field field);
    [CompilerGeneratedAttribute]
internal virtual Field[] get_Children();
    internal virtual Field[] get_NaturalChildren();
    internal virtual bool get_IsAtomic();
    internal bool Equals(SchemaElement tse);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Parquet.Schema.FieldPath : object {
    private List`1<string> _parts;
    [NullableAttribute("2")]
public string FirstPart { get; }
    public string Item { get; }
    public int Length { get; }
    public FieldPath(string firstPart);
    public FieldPath(IEnumerable`1<string> parts);
    public FieldPath(String[] parts);
    public void Append(string value);
    public List`1<string> ToList();
    [NullableContextAttribute("2")]
public string get_FirstPart();
    public string get_Item(int i);
    public int get_Length();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(FieldPath other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public static FieldPath op_Addition(FieldPath left, FieldPath right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Schema.ListField : Field {
    private bool _itemAssigned;
    public static string ElementName;
    public static string DefaultContainerName;
    [CompilerGeneratedAttribute]
private string <ContainerName>k__BackingField;
    [CompilerGeneratedAttribute]
private Field <Item>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SchemaElement <GroupSchemaElement>k__BackingField;
    internal string ContainerName { get; internal set; }
    public Field Item { get; internal set; }
    [NullableAttribute("2")]
unknown FieldPath PathPrefix {internal set; }
    internal Field[] Children { get; }
    [NullableAttribute("2")]
internal SchemaElement GroupSchemaElement { get; internal set; }
    internal bool IsAtomic { get; }
    private ListField(string name);
    public ListField(string name, Field item, string containerName);
    public ListField(string name, Type itemDataType, string propertyName, string containerName, string elementName);
    [CompilerGeneratedAttribute]
internal string get_ContainerName();
    [CompilerGeneratedAttribute]
internal void set_ContainerName(string value);
    [CompilerGeneratedAttribute]
public Field get_Item();
    [CompilerGeneratedAttribute]
internal void set_Item(Field value);
    [NullableContextAttribute("2")]
internal virtual void set_PathPrefix(FieldPath value);
    internal virtual Field[] get_Children();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal SchemaElement get_GroupSchemaElement();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_GroupSchemaElement(SchemaElement value);
    internal virtual void PropagateLevels(int parentRepetitionLevel, int parentDefinitionLevel);
    internal static ListField CreateWithNoItem(string name, bool isNullable);
    internal virtual void Assign(Field field);
    internal virtual bool get_IsAtomic();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Schema.MapField : Field {
    internal static string ContainerName;
    private bool _keyAssigned;
    private bool _valueAssigned;
    [CompilerGeneratedAttribute]
private Field <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Field <Value>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SchemaElement <GroupSchemaElement>k__BackingField;
    public Field Key { get; private set; }
    public Field Value { get; private set; }
    [NullableAttribute("2")]
unknown FieldPath PathPrefix {internal set; }
    internal Field[] Children { get; }
    [NullableAttribute("2")]
internal SchemaElement GroupSchemaElement { get; internal set; }
    public MapField(string name, Field keyField, Field valueField);
    internal MapField(string name);
    [CompilerGeneratedAttribute]
public Field get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(Field value);
    [CompilerGeneratedAttribute]
public Field get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(Field value);
    internal virtual void Assign(Field se);
    [NullableContextAttribute("2")]
internal virtual void set_PathPrefix(FieldPath value);
    internal virtual Field[] get_Children();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal SchemaElement get_GroupSchemaElement();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_GroupSchemaElement(SchemaElement value);
    internal virtual void PropagateLevels(int parentRepetitionLevel, int parentDefinitionLevel);
    internal IDictionary CreateSimpleDictionary();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Parquet.Schema.ParquetSchema : object {
    public static string PathSeparator;
    public static char PathSeparatorChar;
    private List`1<Field> _fields;
    public IReadOnlyList`1<Field> Fields { get; }
    public Field Item { get; }
    public DataField[] DataFields { get; }
    public ParquetSchema(IEnumerable`1<Field> fields);
    public ParquetSchema(Field[] fields);
    private ParquetSchema(List`1<Field> fields);
    internal void PropagateLevels();
    public IReadOnlyList`1<Field> get_Fields();
    public Field get_Item(int i);
    public DataField[] GetDataFields();
    public DataField[] get_DataFields();
    public DataField FindDataField(FieldPath path);
    public DataField FindDataField(string path);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ParquetSchema other);
    public string GetNotEqualsMessage(ParquetSchema other, string thisName, string otherName);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal static void <GetDataFields>g__analyse|11_0(Field f, <>c__DisplayClass11_0& );
    [CompilerGeneratedAttribute]
internal static void <GetDataFields>g__traverse|11_1(IEnumerable`1<Field> fields, <>c__DisplayClass11_0& );
}
public enum Parquet.Schema.SchemaType : Enum {
    public int value__;
    public static SchemaType Data;
    public static SchemaType Map;
    public static SchemaType Struct;
    public static SchemaType List;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Schema.StructField : Field {
    private List`1<Field> _fields;
    [NullableAttribute("2")]
unknown FieldPath PathPrefix {internal set; }
    internal Field[] Children { get; }
    public IReadOnlyList`1<Field> Fields { get; }
    private StructField(string name);
    public StructField(string name, Field[] elements);
    [NullableContextAttribute("2")]
internal virtual void set_PathPrefix(FieldPath value);
    internal virtual Field[] get_Children();
    internal virtual void PropagateLevels(int parentRepetitionLevel, int parentDefinitionLevel);
    internal static StructField CreateWithNoElements(string name);
    public IReadOnlyList`1<Field> get_Fields();
    internal virtual void Assign(Field se);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(StructField other);
}
public class Parquet.Schema.TimeOnlyDataField : DataField {
    [CompilerGeneratedAttribute]
private TimeSpanFormat <TimeSpanFormat>k__BackingField;
    public TimeSpanFormat TimeSpanFormat { get; }
    [NullableContextAttribute("1")]
public TimeOnlyDataField(string name, TimeSpanFormat format, Nullable`1<bool> isNullable, Nullable`1<bool> isArray, string propertyName);
    [CompilerGeneratedAttribute]
public TimeSpanFormat get_TimeSpanFormat();
}
public class Parquet.Schema.TimeSpanDataField : DataField {
    [CompilerGeneratedAttribute]
private TimeSpanFormat <TimeSpanFormat>k__BackingField;
    public TimeSpanFormat TimeSpanFormat { get; }
    [NullableContextAttribute("1")]
public TimeSpanDataField(string name, TimeSpanFormat format, Nullable`1<bool> isNullable, Nullable`1<bool> isArray, string propertyName);
    [CompilerGeneratedAttribute]
public TimeSpanFormat get_TimeSpanFormat();
}
public enum Parquet.Schema.TimeSpanFormat : Enum {
    public int value__;
    public static TimeSpanFormat MilliSeconds;
    public static TimeSpanFormat MicroSeconds;
}
[AttributeUsageAttribute("128")]
public class Parquet.Serialization.Attributes.ParquetDecimalAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Precision>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Scale>k__BackingField;
    public int Precision { get; }
    public int Scale { get; }
    public ParquetDecimalAttribute(int precision, int scale);
    [CompilerGeneratedAttribute]
public int get_Precision();
    [CompilerGeneratedAttribute]
public int get_Scale();
}
[AttributeUsageAttribute("384")]
public class Parquet.Serialization.Attributes.ParquetIgnoreAttribute : Attribute {
}
[AttributeUsageAttribute("128")]
public class Parquet.Serialization.Attributes.ParquetMicroSecondsTimeAttribute : Attribute {
}
[AttributeUsageAttribute("128")]
public class Parquet.Serialization.Attributes.ParquetRequiredAttribute : Attribute {
}
[AttributeUsageAttribute("128")]
public class Parquet.Serialization.Attributes.ParquetSimpleRepeatableAttribute : Attribute {
}
[AttributeUsageAttribute("128")]
public class Parquet.Serialization.Attributes.ParquetTimestampAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ParquetTimestampResolution <Resolution>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseLogicalTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAdjustedToUTC>k__BackingField;
    public ParquetTimestampResolution Resolution { get; private set; }
    public bool UseLogicalTimestamp { get; private set; }
    public bool IsAdjustedToUTC { get; private set; }
    public ParquetTimestampAttribute(ParquetTimestampResolution resolution, bool useLogicalTimestamp);
    [CompilerGeneratedAttribute]
public ParquetTimestampResolution get_Resolution();
    [CompilerGeneratedAttribute]
private void set_Resolution(ParquetTimestampResolution value);
    [CompilerGeneratedAttribute]
public bool get_UseLogicalTimestamp();
    [CompilerGeneratedAttribute]
private void set_UseLogicalTimestamp(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAdjustedToUTC();
    [CompilerGeneratedAttribute]
private void set_IsAdjustedToUTC(bool value);
    internal DateTimeFormat GetDateTimeFormat();
}
public enum Parquet.Serialization.Attributes.ParquetTimestampResolution : Enum {
    public int value__;
    public static ParquetTimestampResolution Milliseconds;
    public static ParquetTimestampResolution Microseconds;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Parquet.Serialization.Dremel.Assembler`1 : object {
    [CompilerGeneratedAttribute]
private ParquetSchema <Schema>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<FieldAssembler`1<TClass>> <FieldAssemblers>k__BackingField;
    public ParquetSchema Schema { get; }
    public List`1<FieldAssembler`1<TClass>> FieldAssemblers { get; }
    public Assembler`1(ParquetSchema schema);
    private static FieldAssembler`1<TClass> Compile(ParquetSchema schema, DataField df);
    [CompilerGeneratedAttribute]
public ParquetSchema get_Schema();
    [CompilerGeneratedAttribute]
public List`1<FieldAssembler`1<TClass>> get_FieldAssemblers();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Parquet.Serialization.Dremel.FieldAssembler`1 : FieldWorker`1<TClass> {
    [CompilerGeneratedAttribute]
private Action`2<IEnumerable`1<TClass>, DataColumn> <Assemble>k__BackingField;
    public Action`2<IEnumerable`1<TClass>, DataColumn> Assemble { get; }
    public FieldAssembler`1(ParquetSchema schema, DataField field, Action`2<IEnumerable`1<TClass>, DataColumn> assembler, Expression expression, Expression iterationExpression);
    [CompilerGeneratedAttribute]
public Action`2<IEnumerable`1<TClass>, DataColumn> get_Assemble();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Parquet.Serialization.Dremel.FieldAssemblerCompiler`1 : object {
    private static Expression Zero;
    private static Expression One;
    private ParquetSchema _schema;
    private DataField _df;
    private bool _isUntypedClass;
    private ParameterExpression _dcParam;
    private ParameterExpression _classElementVar;
    private ParameterExpression _dataIdxVar;
    private ParameterExpression _dataVar;
    private ParameterExpression _dataElementVar;
    private ParameterExpression _rlIdxVar;
    private ParameterExpression _rlVar;
    private ParameterExpression _dlIdxVar;
    private ParameterExpression _dlVar;
    private ParameterExpression _hasData;
    private ParameterExpression _rsmVar;
    private bool _hasReps;
    private bool _hasDefs;
    public FieldAssemblerCompiler`1(ParquetSchema schema, DataField df);
    private static FieldAssemblerCompiler`1();
    private Expression GetDataLength();
    private Expression GetRlLength();
    private Expression GetDLLength();
    private Expression GetRLAt(Expression index);
    private Expression GetDLAt(Expression index);
    private Expression GetCurrentRLOr0();
    private Expression TakeCurrentValuesAndAdvance();
    private static void Discover(Field field, Boolean& isRepeated);
    private Expression TransitionRSM();
    private Expression GetCollectionElement(Expression collection, int rlDepth, Type collectionType, Type elementType);
    private static void ReplaceIDictionaryTypes(Type t, Type& dictionaryType, Type& elementType);
    private static void GetReadLevels(Field f, Int32& dlDepth, Int32& rlDepth);
    private static Type GetIdealUntypedType(Field f);
    private static Expression CreateInstance(Type t);
    private static Expression RebuildArray(Expression arrayAccessor, Type arrayType, Expression newElement);
    private ClassMember<TClass> GetClassMember(Type rootType, Expression rootVar, Field parentField, Field field, string name);
    private Expression InjectLevel(Expression rootVar, Type rootType, Field parentField, Field[] levelFields, List`1<string> path);
    private Expression InjectColumn();
    public FieldAssembler`1<TClass> Compile();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Parquet.Serialization.Dremel.FieldStriper`1 : FieldWorker`1<TClass> {
    [CompilerGeneratedAttribute]
private Func`3<DataField, IEnumerable`1<TClass>, ShreddedColumn> <Stripe>k__BackingField;
    public Func`3<DataField, IEnumerable`1<TClass>, ShreddedColumn> Stripe { get; }
    public FieldStriper`1(ParquetSchema schema, DataField field, Func`3<DataField, IEnumerable`1<TClass>, ShreddedColumn> striper, Expression expression, Expression iterationExpression);
    [CompilerGeneratedAttribute]
public Func`3<DataField, IEnumerable`1<TClass>, ShreddedColumn> get_Stripe();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Parquet.Serialization.Dremel.FieldStriperCompiler`1 : object {
    private static MethodInfo LevelsAddMethod;
    private static MethodInfo IDictionaryTryGetValueMethod;
    private MethodInfo _valuesListAddMethod;
    private bool _isUntypedClass;
    private ParquetSchema _schema;
    private DataField _df;
    private bool _hasRls;
    private bool _hasDls;
    private ParameterExpression _dfParam;
    private ParameterExpression _classesParam;
    private static ConstructorInfo ShreddedColumnConstructor;
    private Type _valuesListType;
    private ParameterExpression _valuesVar;
    private ParameterExpression _dlsVar;
    private ParameterExpression _rlsVar;
    private ParameterExpression _classElementVar;
    private static Expression NullListOfInt;
    public FieldStriperCompiler`1(ParquetSchema schema, DataField df);
    private static FieldStriperCompiler`1();
    private static void Discover(Field field, Boolean& isRepeated);
    private Expression WriteValue(ParameterExpression valueVar, int dl, Expression currentRlVar, ParameterExpression isLeaf, bool isAtomic);
    private Expression WriteMissingValue(int dl, Expression currentRlVar);
    private Expression WhileBody(Expression element, bool isAtomic, int dl, ParameterExpression currentRlVar, ParameterExpression seenFieldsVar, Field field, int rlDepth, Type elementType, List`1<string> path);
    private static Type ExtractElementTypeFromEnumerableType(Type t);
    private static int GetWriteableDL(Field f);
    private static Type GetIdealUntypedType(Field f);
    private Expression GetClassMemberAccessorAndType(Type rootType, Expression rootVar, Field parentField, Field field, string name, Type& type);
    private Expression DissectRecord(Expression rootVar, Field parentField, Field[] levelFields, List`1<string> path, Type rootType, int rlDepth, ParameterExpression currentRlVar);
    public FieldStriper`1<TClass> Compile();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Parquet.Serialization.Dremel.FieldWorker`1 : object {
    [CompilerGeneratedAttribute]
private ParquetSchema <Schema>k__BackingField;
    [CompilerGeneratedAttribute]
private DataField <Field>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <IterationExpression>k__BackingField;
    public ParquetSchema Schema { get; }
    public DataField Field { get; }
    public Expression Expression { get; }
    public Expression IterationExpression { get; }
    protected FieldWorker`1(ParquetSchema schema, DataField field, Expression expression, Expression iterationExpression);
    [CompilerGeneratedAttribute]
public ParquetSchema get_Schema();
    [CompilerGeneratedAttribute]
public DataField get_Field();
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    [CompilerGeneratedAttribute]
public Expression get_IterationExpression();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
internal class Parquet.Serialization.Dremel.ParquetDictionary`2 : Dictionary`2<TKey, TValue> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ParquetDictionaryElement<TKey, TValue>> _list;
    public ParquetDictionaryElement<TKey, TValue> Item { get; public set; }
    public bool IsReadOnly { get; }
    public int Count { get; }
    public sealed virtual ParquetDictionaryElement<TKey, TValue> get_Item(int index);
    public sealed virtual void set_Item(int index, ParquetDictionaryElement<TKey, TValue> value);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(ParquetDictionaryElement<TKey, TValue> item);
    public sealed virtual bool Contains(ParquetDictionaryElement<TKey, TValue> item);
    public sealed virtual void CopyTo(ParquetDictionaryElement[] array, int arrayIndex);
    public sealed virtual int IndexOf(ParquetDictionaryElement<TKey, TValue> item);
    public sealed virtual void Insert(int index, ParquetDictionaryElement<TKey, TValue> item);
    public sealed virtual bool Remove(ParquetDictionaryElement<TKey, TValue> item);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator`1<ParquetDictionaryElement<TKey, TValue>> System.Collections.Generic.IEnumerable<Parquet.Serialization.Dremel.ParquetDictionary<TKey,TValue>.ParquetDictionaryElement>.GetEnumerator();
    public sealed virtual int get_Count();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Parquet.Serialization.Dremel.ShreddedColumn : object {
    [NullableAttribute("1")]
public Array Data;
    [CompilerGeneratedAttribute]
private List`1<int> <DefinitionLevels>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<int> <RepetitionLevels>k__BackingField;
    public List`1<int> DefinitionLevels { get; public set; }
    public List`1<int> RepetitionLevels { get; public set; }
    public ShreddedColumn(Array data, List`1<int> definitionLevels, List`1<int> repetitionLevels);
    [CompilerGeneratedAttribute]
public List`1<int> get_DefinitionLevels();
    [CompilerGeneratedAttribute]
public void set_DefinitionLevels(List`1<int> value);
    [CompilerGeneratedAttribute]
public List`1<int> get_RepetitionLevels();
    [CompilerGeneratedAttribute]
public void set_RepetitionLevels(List`1<int> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Parquet.Serialization.Dremel.Striper`1 : object {
    [CompilerGeneratedAttribute]
private ParquetSchema <Schema>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<FieldStriper`1<TClass>> <FieldStripers>k__BackingField;
    public ParquetSchema Schema { get; }
    public IReadOnlyList`1<FieldStriper`1<TClass>> FieldStripers { get; }
    public Striper`1(ParquetSchema schema);
    [CompilerGeneratedAttribute]
public ParquetSchema get_Schema();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<FieldStriper`1<TClass>> get_FieldStripers();
    private FieldStriper`1<TClass> CreateStriper(DataField df);
    public static Striper`1<TClass> Create();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Parquet.Serialization.HttpEncoder : object {
    private static bool JavaScriptEncodeAmpersand;
    public static string JavaScriptStringEncode(string value);
    private static bool CharRequiresJavaScriptEncoding(char c);
    private static void AppendCharAsUnicodeJavaScript(StringBuilder builder, char c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Parquet.Serialization.ParquetSerializer : object {
    private static ConcurrentDictionary`2<Type, object> _typeToStriper;
    private static ConcurrentDictionary`2<ParquetSchema, object> _schemaToStriper;
    private static ConcurrentDictionary`2<Type, object> _typeToAssembler;
    private static ConcurrentDictionary`2<ParquetSchema, object> _schemaToAssembler;
    private static ParquetSerializer();
    [AsyncStateMachineAttribute("Parquet.Serialization.ParquetSerializer/<SerializeRowGroupAsync>d__4`1")]
private static Task SerializeRowGroupAsync(ParquetWriter writer, Striper`1<T> striper, IEnumerable`1<T> objectInstances, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Parquet.Serialization.ParquetSerializer/<SerializeRowGroupAsync>d__5")]
private static Task SerializeRowGroupAsync(ParquetWriter writer, Striper`1<IDictionary`2<string, object>> striper, ParquetSchema schema, IReadOnlyCollection`1<IDictionary`2<string, object>> data, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Parquet.Serialization.ParquetSerializer/<SerializeRowGroupAsync>d__6`1")]
public static Task SerializeRowGroupAsync(ParquetWriter writer, IEnumerable`1<T> objectInstances, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Parquet.Serialization.ParquetSerializer/<SerializeAsync>d__7`1")]
public static Task`1<ParquetSchema> SerializeAsync(IEnumerable`1<T> objectInstances, Stream destination, ParquetSerializerOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Parquet.Serialization.ParquetSerializer/<SerializeAsync>d__8")]
public static Task SerializeAsync(ParquetSchema schema, IReadOnlyCollection`1<IDictionary`2<string, object>> data, Stream destination, ParquetSerializerOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Parquet.Serialization.ParquetSerializer/<SerializeAsync>d__9`1")]
public static Task`1<ParquetSchema> SerializeAsync(IEnumerable`1<T> objectInstances, string filePath, ParquetSerializerOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Parquet.Serialization.ParquetSerializer/<DeserializeAsync>d__10`1")]
public static Task`1<IList`1<T>> DeserializeAsync(Stream source, int rowGroupIndex, ParquetOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Parquet.Serialization.ParquetSerializer/<DeserializeAsync>d__11`1")]
public static Task DeserializeAsync(Stream source, int rowGroupIndex, IList`1<T> result, ParquetOptions options, CancellationToken cancellationToken, bool resultsAlreadyAllocated);
    [AsyncStateMachineAttribute("Parquet.Serialization.ParquetSerializer/<DeserializeAsync>d__12`1")]
public static Task DeserializeAsync(ParquetReader reader, int rowGroupIndex, IList`1<T> result, CancellationToken cancellationToken, bool resultsAlreadyAllocated);
    [AsyncStateMachineAttribute("Parquet.Serialization.ParquetSerializer/<DeserializeAsync>d__13`1")]
public static Task`1<IList`1<T>> DeserializeAsync(string filePath, int rowGroupIndex, ParquetOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Parquet.Serialization.ParquetSerializer/<DeserializeAsync>d__14`1")]
public static Task`1<IList`1<T>> DeserializeAsync(Stream source, ParquetOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Parquet.Serialization.ParquetSerializer/<DeserializeAsync>d__15`1")]
public static Task`1<IList`1<T>> DeserializeAsync(string filePath, ParquetOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Parquet.Serialization.ParquetSerializer/<DeserializeAsync>d__17")]
public static Task`1<UntypedResult> DeserializeAsync(Stream source, ParquetOptions options, CancellationToken cancellationToken);
    [AsyncIteratorStateMachineAttribute("Parquet.Serialization.ParquetSerializer/<DeserializeAllAsync>d__18`1")]
public static IAsyncEnumerable`1<T> DeserializeAllAsync(Stream source, ParquetOptions options, CancellationToken cancellationToken);
    [AsyncIteratorStateMachineAttribute("Parquet.Serialization.ParquetSerializer/<DeserializeAllByGroupsAsync>d__19`1")]
public static IAsyncEnumerable`1<IList`1<T>> DeserializeAllByGroupsAsync(Stream source, ParquetOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Parquet.Serialization.ParquetSerializer/<DeserializeAsync>d__20`1")]
public static Task`1<IList`1<T>> DeserializeAsync(ParquetRowGroupReader rowGroupReader, ParquetSchema schema, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Parquet.Serialization.ParquetSerializer/<DeserializeRowGroupAsync>d__21`1")]
public static Task DeserializeRowGroupAsync(ParquetRowGroupReader rowGroupReader, ParquetSchema schema, ICollection`1<T> result, CancellationToken cancellationToken, bool resultsAlreadyAllocated);
    private static Assembler`1<T> GetAssembler();
    private static Assembler`1<Dictionary`2<string, object>> GetAssembler(ParquetSchema schema);
    [AsyncStateMachineAttribute("Parquet.Serialization.ParquetSerializer/<DeserializeRowGroupAsync>d__24`1")]
private static Task DeserializeRowGroupAsync(ParquetReader reader, int rgi, Assembler`1<T> asm, ICollection`1<T> result, CancellationToken cancellationToken, bool resultsAlreadyAllocated);
    [AsyncStateMachineAttribute("Parquet.Serialization.ParquetSerializer/<DeserializeRowGroupAsync>d__25")]
private static Task DeserializeRowGroupAsync(ParquetReader reader, int rgi, Assembler`1<Dictionary`2<string, object>> asm, List`1<Dictionary`2<string, object>> result, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Parquet.Serialization.ParquetSerializer/<DeserializeRowGroupAsync>d__26`1")]
private static Task DeserializeRowGroupAsync(ParquetRowGroupReader rg, ParquetSchema schema, Assembler`1<T> asm, ICollection`1<T> result, CancellationToken cancellationToken, bool resultsAlreadyAllocated);
    private static List`1<T> GetList(Nullable`1<long> requestedCapacity);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Parquet.Serialization.ParquetSerializerOptions : object {
    [CompilerGeneratedAttribute]
private bool <Append>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionMethod <CompressionMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionLevel <CompressionLevel>k__BackingField;
    public static int DefaultRowGroupSize;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <RowGroupSize>k__BackingField;
    [CompilerGeneratedAttribute]
private ParquetOptions <ParquetOptions>k__BackingField;
    public bool Append { get; public set; }
    public CompressionMethod CompressionMethod { get; public set; }
    public CompressionLevel CompressionLevel { get; public set; }
    public Nullable`1<int> RowGroupSize { get; public set; }
    public ParquetOptions ParquetOptions { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Append();
    [CompilerGeneratedAttribute]
public void set_Append(bool value);
    [CompilerGeneratedAttribute]
public CompressionMethod get_CompressionMethod();
    [CompilerGeneratedAttribute]
public void set_CompressionMethod(CompressionMethod value);
    [CompilerGeneratedAttribute]
public CompressionLevel get_CompressionLevel();
    [CompilerGeneratedAttribute]
public void set_CompressionLevel(CompressionLevel value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_RowGroupSize();
    [CompilerGeneratedAttribute]
public void set_RowGroupSize(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public ParquetOptions get_ParquetOptions();
    [CompilerGeneratedAttribute]
public void set_ParquetOptions(ParquetOptions value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Parquet.Serialization.TypeExtensions : object {
    private static ConcurrentDictionary`2<Type, ParquetSchema> _cachedWriteReflectedSchemas;
    private static ConcurrentDictionary`2<Type, ParquetSchema> _cachedReadReflectedSchemas;
    private static TypeExtensions();
    [ExtensionAttribute]
public static ParquetSchema GetParquetSchema(Type t, bool forWriting);
    private static List`1<ClassMember> FindMembers(Type t, bool forWriting);
    private static Field ConstructDataField(string name, string propertyName, Type t, ClassMember member, bool isCompiledWithNullable);
    private static MapField ConstructMapField(string name, string propertyName, Type tKey, Type tValue, bool forWriting, bool isCompiledWithNullable);
    private static ListField ConstructListField(string name, string propertyName, Type elementType, bool forWriting, bool isCompiledWithNullable);
    private static Field MakeField(ClassMember member, bool forWriting, bool isCompiledWithNullable);
    private static Field MakeField(Type t, string columnName, string propertyName, ClassMember member, bool forWriting, bool isCompiledWithNullable);
    private static ParquetSchema CreateSchema(Type t, bool forWriting);
    [ExtensionAttribute]
public static DateTimeTimeUnit Convert(ParquetTimestampResolution resolution);
    [ExtensionAttribute]
public static DateTimeTimeUnit Convert(TimeUnit unit);
}
public class Parquet.TableReaderProgressCallback : MulticastDelegate {
    public TableReaderProgressCallback(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Task Invoke(int progress, string message);
    public virtual IAsyncResult BeginInvoke(int progress, string message, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Parquet.ThriftExtensions : object {
    [ExtensionAttribute]
public static bool IsAnnotatedWithAny(SchemaElement schemaElement, ConvertedType[] convertedTypes);
    [ExtensionAttribute]
public static bool IsNullable(SchemaElement schemaElement);
    [ExtensionAttribute]
public static FieldPath GetPath(ColumnChunk columnChunk);
    [ExtensionAttribute]
public static string Describe(SchemaElement se);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Parquet.TypeExtensions : object {
    [ExtensionAttribute]
public static IList CreateGenericList(Type t);
    [ExtensionAttribute]
public static bool TryExtractIEnumerableType(Type t, Type& baseType);
    [ExtensionAttribute]
public static Type ExtractElementTypeFromEnumerableType(Type t);
    [ExtensionAttribute]
public static MethodInfo GetGenericListAddMethod(Type listType);
    [ExtensionAttribute]
public static bool IsGenericIDictionary(Type t);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool TryExtractDictionaryType(Type t, Type& keyType, Type& valueType);
    [ExtensionAttribute]
public static bool IsNullable(IList list);
    [ExtensionAttribute]
public static bool IsNullable(PropertyInfo pi);
    [ExtensionAttribute]
public static bool IsNullable(Type t);
    [ExtensionAttribute]
public static bool IsNullableStrict(Type t);
    [ExtensionAttribute]
public static bool IsSystemNullable(Type t);
    [ExtensionAttribute]
public static Type GetNonNullable(Type t);
    [ExtensionAttribute]
public static bool CanNullifyType(Type t);
    [ExtensionAttribute]
public static Type GetNullable(Type t);
    [ExtensionAttribute]
public static bool IsSimple(Type t);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parquet.Utils.FileMerger : object {
    private static string ParquetFileExtension;
    private List`1<FileInfo> _inputFiles;
    private List`1<Stream> _inputStreams;
    public IReadOnlyCollection`1<Stream> InputStreams { get; }
    public IReadOnlyCollection`1<FileInfo> InputFiles { get; }
    public FileMerger(DirectoryInfo directory);
    public FileMerger(IEnumerable`1<FileInfo> files);
    public IReadOnlyCollection`1<Stream> get_InputStreams();
    public IReadOnlyCollection`1<FileInfo> get_InputFiles();
    [AsyncStateMachineAttribute("Parquet.Utils.FileMerger/<MergeFilesAsync>d__9")]
public Task MergeFilesAsync(Stream destination, ParquetOptions options, CancellationToken cancellationToken, Dictionary`2<string, string> metadata, Nullable`1<CompressionMethod> compressionMethod);
    [AsyncStateMachineAttribute("Parquet.Utils.FileMerger/<MergeRowGroups>d__10")]
public Task MergeRowGroups(Stream destination, ParquetOptions options, CancellationToken cancellationToken, Dictionary`2<string, string> metadata, Nullable`1<CompressionMethod> compressionMethod);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Parquet.Utils.FlatTableConverter : object {
    private Stream _parquetInputStream;
    [NullableAttribute("2")]
private ParquetOptions _options;
    [CompilerGeneratedAttribute]
private string <ListSeparator>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Action`1<long> OnFileOpened;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Action`2<long, long> OnRowConverted;
    [CompilerGeneratedAttribute]
private long <TotalRows>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ConvertedRows>k__BackingField;
    public string ListSeparator { get; public set; }
    public long TotalRows { get; private set; }
    public long ConvertedRows { get; private set; }
    protected FlatTableConverter(Stream parquetInputStream, ParquetOptions options);
    [CompilerGeneratedAttribute]
public string get_ListSeparator();
    [CompilerGeneratedAttribute]
public void set_ListSeparator(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void add_OnFileOpened(Action`1<long> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void remove_OnFileOpened(Action`1<long> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void add_OnRowConverted(Action`2<long, long> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void remove_OnRowConverted(Action`2<long, long> value);
    [CompilerGeneratedAttribute]
public long get_TotalRows();
    [CompilerGeneratedAttribute]
private void set_TotalRows(long value);
    [CompilerGeneratedAttribute]
public long get_ConvertedRows();
    [CompilerGeneratedAttribute]
private void set_ConvertedRows(long value);
    [AsyncStateMachineAttribute("Parquet.Utils.FlatTableConverter/<ConvertAsync>d__21")]
public Task ConvertAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private object ConvertArray(object value);
    protected abstract virtual Task WriteHeaderAsync(ParquetSchema schema, CancellationToken cancellationToken);
    protected abstract virtual Task NewRow();
    protected abstract virtual Task WriteCellAsync(Field df, object value, CancellationToken cancellationToken);
    public virtual void Dispose();
}
public static class Parquet.Utils.NullableChecker : object {
    [NullableContextAttribute("1")]
public static bool IsNullableEnabled(Type type);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.ByteArrayExtensions : object {
    [NullableAttribute("1")]
private static Char[] LowerCaseHexAlphabet;
    [NullableAttribute("1")]
private static Char[] UpperCaseHexAlphabet;
    [NullableAttribute("1")]
private static MD5 _md5;
    [NullableAttribute("1")]
private static SHA256 _sha256;
    private static ByteArrayExtensions();
    [ExtensionAttribute]
public static string ToHexString(Byte[] bytes);
    [ExtensionAttribute]
private static string ToHexString(Byte[] bytes, bool lowerCase);
    [ExtensionAttribute]
public static Byte[] MD5(Byte[] bytes);
    [ExtensionAttribute]
public static Byte[] SHA256(Byte[] bytes);
    [ExtensionAttribute]
public static Byte[] HMACSHA256(Byte[] data, Byte[] key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.DateTimeExtensions : object {
    [ExtensionAttribute]
public static DateTime RoundToDay(DateTime time);
    [ExtensionAttribute]
public static DateTime EndOfDay(DateTime time);
    [ExtensionAttribute]
public static DateTime RoundToMinute(DateTime time, int round, bool roundLeft);
    [ExtensionAttribute]
public static DateTime RoundToSecond(DateTime time);
    [ExtensionAttribute]
public static DateTime RoundToMillisecond(DateTime time);
    [ExtensionAttribute]
public static DateTime RoundToMicrosecond(DateTime time);
    [ExtensionAttribute]
public static bool IsToday(DateTime time);
    [ExtensionAttribute]
public static bool IsTomorrow(DateTime time);
    [ExtensionAttribute]
public static string ToHourMinuteString(DateTime time);
    [ExtensionAttribute]
public static string ToIso8601DateString(DateTime time);
}
[ExtensionAttribute]
internal static class System.EnumerableExtensions : object {
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("System.EnumerableExtensions/<ForEach>d__0`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> ForEach(IEnumerable`1<T> source, Action`1<T> action);
}
[ExtensionAttribute]
internal static class System.GuidExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ToShortest(Guid g);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.IntExtensions : object {
    [ExtensionAttribute]
public static string ToFileSizeString(int number);
    [ExtensionAttribute]
public static string ToFileSizeUiString(int number);
    [ExtensionAttribute]
public static TimeSpan Seconds(int number);
    [ExtensionAttribute]
public static TimeSpan Minutes(int number);
    [ExtensionAttribute]
public static TimeSpan Hours(int number);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.LongExtensions : object {
    [ExtensionAttribute]
public static string ToFileSizeString(long number);
    [ExtensionAttribute]
public static string ToFileSizeUiString(long number);
}
[ExtensionAttribute]
internal static class System.SpanExtensions : object {
    [ExtensionAttribute]
public static int ReadInt32(Span`1<byte> span, int offset);
    [ExtensionAttribute]
public static long ReadInt64(Span`1<byte> span, int offset);
    [ExtensionAttribute]
public static void MinMax(ReadOnlySpan`1<byte> span, Byte& min, Byte& max);
    [ExtensionAttribute]
public static void MinMax(ReadOnlySpan`1<sbyte> span, SByte& min, SByte& max);
    [ExtensionAttribute]
public static void MinMax(ReadOnlySpan`1<short> span, Int16& min, Int16& max);
    [ExtensionAttribute]
public static void MinMax(ReadOnlySpan`1<ushort> span, UInt16& min, UInt16& max);
    [ExtensionAttribute]
public static void MinMax(ReadOnlySpan`1<int> span, Int32& min, Int32& max);
    [ExtensionAttribute]
public static int Max(Span`1<int> span);
    [ExtensionAttribute]
public static void MinMax(ReadOnlySpan`1<UInt32> span, UInt32& min, UInt32& max);
    [ExtensionAttribute]
public static void MinMax(ReadOnlySpan`1<long> span, Int64& min, Int64& max);
    [ExtensionAttribute]
public static long Max(Span`1<long> span);
    [ExtensionAttribute]
public static void MinMax(ReadOnlySpan`1<ulong> span, UInt64& min, UInt64& max);
    [ExtensionAttribute]
public static void MinMax(ReadOnlySpan`1<BigInteger> span, BigInteger& min, BigInteger& max);
    [ExtensionAttribute]
public static void MinMax(ReadOnlySpan`1<decimal> span, Decimal& min, Decimal& max);
    [ExtensionAttribute]
public static void MinMax(ReadOnlySpan`1<double> span, Double& min, Double& max);
    [ExtensionAttribute]
public static void MinMax(ReadOnlySpan`1<float> span, Single& min, Single& max);
    [ExtensionAttribute]
public static void MinMax(ReadOnlySpan`1<DateTime> span, DateTime& min, DateTime& max);
    [ExtensionAttribute]
public static void MinMax(ReadOnlySpan`1<DateOnly> span, DateOnly& min, DateOnly& max);
    [ExtensionAttribute]
public static void MinMax(ReadOnlySpan`1<TimeOnly> span, TimeOnly& min, TimeOnly& max);
    [ExtensionAttribute]
public static void MinMax(ReadOnlySpan`1<TimeSpan> span, TimeSpan& min, TimeSpan& max);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void MinMax(ReadOnlySpan`1<string> span, String& min, String& max);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void CopyWithLimitTo(Span`1<T> source, Span`1<T> target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.StreamExtensions : object {
    [ExtensionAttribute]
public static bool TryGetSize(Stream s, Int64& size);
    [ExtensionAttribute]
public static Nullable`1<long> TryGetSize(Stream s);
    [ExtensionAttribute]
public static Byte[] ReadUntil(Stream s, Byte[] stopSequence);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Byte[] ToByteArray(Stream stream);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static string ToString(Stream stream, Encoding encoding);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.StringExtensions : object {
    [NullableAttribute("1")]
private static string HtmlStripPattern;
    [NullableAttribute("1")]
private static Char[] Invalid;
    private static StringExtensions();
    [ExtensionAttribute]
public static Byte[] FromHexToBytes(string hex);
    [ExtensionAttribute]
public static string StripHtml(string s);
    [ExtensionAttribute]
public static string Base64Encode(string s);
    [ExtensionAttribute]
public static string Base64Decode(string s);
    [ExtensionAttribute]
public static Byte[] Base64DecodeAsBytes(string s);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Guid FromShortestGuid(string s);
    [ExtensionAttribute]
public static string UrlEncode(string value);
    [ExtensionAttribute]
public static string UrlDecode(string value);
    [ExtensionAttribute]
public static Byte[] UTF8Bytes(string s);
    [ExtensionAttribute]
public static string MD5(string s);
    [ExtensionAttribute]
public static string SHA256(string s);
    [ExtensionAttribute]
public static Byte[] HMACSHA256(string s, Byte[] key);
    [ExtensionAttribute]
public static MemoryStream ToMemoryStream(string s, Encoding encoding);
    [ExtensionAttribute]
public static MemoryStream ToMemoryStream(string s);
    [NullableContextAttribute("1")]
private static bool FindTagged(String& s, String& startToken, String& endToken, bool includeOuterTokens, Int32& startIdx, Int32& length);
    [ExtensionAttribute]
public static string FindTagged(string s, string startTag, string endTag, bool includeOuterTags);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ReplaceTagged(string s, string startTag, string endTag, string replacementText, bool replaceOuterTokens);
    [ExtensionAttribute]
public static string SpacedToCamelCase(string s);
    [ExtensionAttribute]
public static string Capitalize(string s);
    [ExtensionAttribute]
public static string Slice(string s, Nullable`1<int> start, Nullable`1<int> end);
    [ExtensionAttribute]
public static Tuple`2<string, string> SplitByDelimiter(string s, String[] delimiter);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string RemoveLinesContaining(string input, string substring, StringComparison stringComparison);
    [ExtensionAttribute]
public static string ToEscapedJsonValueString(string s);
    [AsyncStateMachineAttribute("System.StringExtensions/<DownloadUrlToTempFile>d__25")]
[ExtensionAttribute]
public static Task`1<TempFile> DownloadUrlToTempFile(string uri);
}
[ExtensionAttribute]
internal static class System.TaskExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Forget(Task task);
}
