[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public enum PCLCrypto.AsymmetricAlgorithm : Enum {
    public int value__;
    public static AsymmetricAlgorithm DsaSha1;
    public static AsymmetricAlgorithm DsaSha256;
    public static AsymmetricAlgorithm EcdsaP256Sha256;
    public static AsymmetricAlgorithm EcdsaP384Sha384;
    public static AsymmetricAlgorithm EcdsaP521Sha512;
    public static AsymmetricAlgorithm RsaOaepSha1;
    public static AsymmetricAlgorithm RsaOaepSha256;
    public static AsymmetricAlgorithm RsaOaepSha384;
    public static AsymmetricAlgorithm RsaOaepSha512;
    public static AsymmetricAlgorithm RsaPkcs1;
    public static AsymmetricAlgorithm RsaSignPkcs1Sha1;
    public static AsymmetricAlgorithm RsaSignPkcs1Sha256;
    public static AsymmetricAlgorithm RsaSignPkcs1Sha384;
    public static AsymmetricAlgorithm RsaSignPkcs1Sha512;
    public static AsymmetricAlgorithm RsaSignPssSha1;
    public static AsymmetricAlgorithm RsaSignPssSha256;
    public static AsymmetricAlgorithm RsaSignPssSha384;
    public static AsymmetricAlgorithm RsaSignPssSha512;
}
[ExtensionAttribute]
public static class PCLCrypto.AsymmetricAlgorithmExtensions : object {
    [ExtensionAttribute]
public static AsymmetricAlgorithmName GetName(AsymmetricAlgorithm algorithm);
    [ExtensionAttribute]
public static Nullable`1<AsymmetricSignaturePadding> GetSignaturePadding(AsymmetricAlgorithm algorithm);
    [ExtensionAttribute]
public static Nullable`1<AsymmetricEncryptionPadding> GetEncryptionPadding(AsymmetricAlgorithm algorithm);
    [ExtensionAttribute]
public static Nullable`1<HashAlgorithm> GetHashAlgorithm(AsymmetricAlgorithm algorithm);
}
public enum PCLCrypto.AsymmetricAlgorithmName : Enum {
    public int value__;
    public static AsymmetricAlgorithmName Dsa;
    public static AsymmetricAlgorithmName Ecdsa;
    public static AsymmetricAlgorithmName Rsa;
    public static AsymmetricAlgorithmName RsaSign;
}
public enum PCLCrypto.AsymmetricEncryptionPadding : Enum {
    public int value__;
    public static AsymmetricEncryptionPadding None;
    public static AsymmetricEncryptionPadding Pkcs1;
    public static AsymmetricEncryptionPadding Oaep;
}
internal class PCLCrypto.AsymmetricKeyAlgorithmProviderFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual IAsymmetricKeyAlgorithmProvider OpenAlgorithm(AsymmetricAlgorithm algorithm);
    internal static HashAlgorithm GetHashAlgorithmEnum(AsymmetricAlgorithm algorithm);
}
public enum PCLCrypto.AsymmetricSignaturePadding : Enum {
    public int value__;
    public static AsymmetricSignaturePadding None;
    public static AsymmetricSignaturePadding Pkcs1;
    public static AsymmetricSignaturePadding Pss;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PCLCrypto.BCryptRsaKeyFormatter : KeyFormatter {
    private MagicNumber keyType;
    protected bool IncludePrivateKey { get; }
    protected bool IncludeFullPrivateKey { get; }
    public BCryptRsaKeyFormatter(CryptographicPrivateKeyBlobType privateKeyType);
    public BCryptRsaKeyFormatter(CryptographicPublicKeyBlobType publicKeyType);
    protected bool get_IncludePrivateKey();
    protected bool get_IncludeFullPrivateKey();
    protected virtual RSAParameters ReadCore(Stream stream);
    protected virtual void WriteCore(Stream stream, RSAParameters parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PCLCrypto.CngAsymmetricKeyAlgorithmProvider : object {
    private AsymmetricAlgorithm algorithm;
    public AsymmetricAlgorithm Algorithm { get; }
    public IReadOnlyList`1<KeySizes> LegalKeySizes { get; }
    public CngAsymmetricKeyAlgorithmProvider(AsymmetricAlgorithm algorithm);
    public sealed virtual AsymmetricAlgorithm get_Algorithm();
    public sealed virtual IReadOnlyList`1<KeySizes> get_LegalKeySizes();
    public sealed virtual ICryptographicKey CreateKeyPair(int keySize);
    public sealed virtual ICryptographicKey ImportKeyPair(Byte[] keyBlob, CryptographicPrivateKeyBlobType blobType);
    public sealed virtual ICryptographicKey ImportPublicKey(Byte[] keyBlob, CryptographicPublicKeyBlobType blobType);
    internal static CngKeyBlobFormat GetPlatformKeyBlobType(CryptographicPrivateKeyBlobType blobType);
    internal static CngKeyBlobFormat GetPlatformKeyBlobType(CryptographicPublicKeyBlobType blobType);
    internal static CngAlgorithm GetCngAlgorithm(AsymmetricAlgorithm algorithm);
    [NullableContextAttribute("2")]
internal static CngAlgorithm GetHashCngAlgorithm(AsymmetricAlgorithm algorithm);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PCLCrypto.CngCryptographicKey : CryptographicKey {
    private CngKey key;
    private AsymmetricAlgorithm algorithm;
    [NullableAttribute("2")]
private Byte[] eccPrivateKeyBlob;
    public int KeySize { get; }
    internal CngCryptographicKey(CngKey key, Byte[] eccPrivateKeyBlob, AsymmetricAlgorithm algorithm);
    public sealed virtual int get_KeySize();
    public sealed virtual Byte[] Export(CryptographicPrivateKeyBlobType blobType);
    public sealed virtual Byte[] ExportPublicKey(CryptographicPublicKeyBlobType blobType);
    protected internal virtual Byte[] Sign(Byte[] data);
    protected internal virtual Byte[] SignHash(Byte[] data);
    protected internal virtual bool VerifySignature(Byte[] data, Byte[] signature);
    protected internal virtual bool VerifyHash(Byte[] data, Byte[] signature);
    protected virtual void Dispose(bool disposing);
    private ECDsaCng CreateCng();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PCLCrypto.CryptographicBuffer : object {
    public sealed virtual bool Compare(Byte[] object1, Byte[] object2);
    public sealed virtual string ConvertBinaryToString(Encoding encoding, Byte[] buffer);
    public sealed virtual Byte[] ConvertStringToBinary(string value, Encoding encoding);
    public sealed virtual void CopyToByteArray(Byte[] buffer, Byte[]& value);
    public sealed virtual Byte[] CreateFromByteArray(Byte[] value);
    public sealed virtual Byte[] DecodeFromBase64String(string value);
    public sealed virtual Byte[] DecodeFromHexString(string value);
    public sealed virtual string EncodeToBase64String(Byte[] buffer);
    public sealed virtual string EncodeToHexString(Byte[] buffer);
    public sealed virtual Byte[] GenerateRandom(int length);
    public sealed virtual UInt32 GenerateRandomNumber();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PCLCrypto.CryptographicEngine : object {
    public sealed virtual Byte[] Encrypt(ICryptographicKey key, Byte[] data, Byte[] iv);
    public sealed virtual ICryptoTransform CreateEncryptor(ICryptographicKey key, Byte[] iv);
    public sealed virtual Byte[] Decrypt(ICryptographicKey key, Byte[] data, Byte[] iv);
    public sealed virtual ICryptoTransform CreateDecryptor(ICryptographicKey key, Byte[] iv);
    public sealed virtual Byte[] Sign(ICryptographicKey key, Byte[] data);
    public sealed virtual Byte[] SignHashedData(ICryptographicKey key, Byte[] data);
    public sealed virtual bool VerifySignature(ICryptographicKey key, Byte[] data, Byte[] signature);
    public sealed virtual bool VerifySignatureWithHashInput(ICryptographicKey key, Byte[] data, Byte[] signature);
    public sealed virtual Byte[] DeriveKeyMaterial(ICryptographicKey key, IKeyDerivationParameters parameters, int desiredKeySize);
}
[ExtensionAttribute]
internal static class PCLCrypto.CryptographicExceptionExtensions : object {
    private static int NTE_NOT_SUPPORTED;
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool IsNotSupportedException(CryptographicException exception);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class PCLCrypto.CryptographicHash : object {
    private bool PCLCrypto.ICryptoTransform.CanReuseTransform { get; }
    private bool PCLCrypto.ICryptoTransform.CanTransformMultipleBlocks { get; }
    private int PCLCrypto.ICryptoTransform.InputBlockSize { get; }
    private int PCLCrypto.ICryptoTransform.OutputBlockSize { get; }
    protected bool CanReuseTransform { get; }
    protected bool CanTransformMultipleBlocks { get; }
    protected int InputBlockSize { get; }
    protected int OutputBlockSize { get; }
    private sealed virtual override bool PCLCrypto.ICryptoTransform.get_CanReuseTransform();
    private sealed virtual override bool PCLCrypto.ICryptoTransform.get_CanTransformMultipleBlocks();
    private sealed virtual override int PCLCrypto.ICryptoTransform.get_InputBlockSize();
    private sealed virtual override int PCLCrypto.ICryptoTransform.get_OutputBlockSize();
    protected virtual bool get_CanReuseTransform();
    protected virtual bool get_CanTransformMultipleBlocks();
    protected virtual int get_InputBlockSize();
    protected virtual int get_OutputBlockSize();
    private sealed virtual override int PCLCrypto.ICryptoTransform.TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    private sealed virtual override Byte[] PCLCrypto.ICryptoTransform.TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    public abstract virtual void Append(Byte[] data);
    public abstract virtual Byte[] GetValueAndReset();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected abstract virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    protected abstract virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class PCLCrypto.CryptographicKey : object {
    protected IHashAlgorithmProvider SignatureHashAlgorithm { get; }
    protected IHashAlgorithmProvider SignatureHashAlgorithmOrThrow { get; }
    protected virtual IHashAlgorithmProvider get_SignatureHashAlgorithm();
    protected IHashAlgorithmProvider get_SignatureHashAlgorithmOrThrow();
    public sealed virtual void Dispose();
    protected internal virtual Byte[] Sign(Byte[] data);
    protected internal virtual bool VerifySignature(Byte[] data, Byte[] signature);
    protected internal virtual Byte[] SignHash(Byte[] data);
    protected internal virtual bool VerifyHash(Byte[] data, Byte[] signature);
    protected internal virtual Byte[] Encrypt(Byte[] data, Byte[] iv);
    protected internal virtual Byte[] Decrypt(Byte[] data, Byte[] iv);
    protected internal virtual ICryptoTransform CreateEncryptor(Byte[] iv);
    protected internal virtual ICryptoTransform CreateDecryptor(Byte[] iv);
    protected internal virtual Byte[] DeriveKeyMaterial(IKeyDerivationParameters parameters, int desiredKeySize);
    protected virtual void Dispose(bool disposing);
}
public enum PCLCrypto.CryptographicPrivateKeyBlobType : Enum {
    public int value__;
    public static CryptographicPrivateKeyBlobType Pkcs8RawPrivateKeyInfo;
    public static CryptographicPrivateKeyBlobType Pkcs1RsaPrivateKey;
    public static CryptographicPrivateKeyBlobType BCryptPrivateKey;
    public static CryptographicPrivateKeyBlobType BCryptFullPrivateKey;
    public static CryptographicPrivateKeyBlobType Capi1PrivateKey;
}
public enum PCLCrypto.CryptographicPublicKeyBlobType : Enum {
    public int value__;
    public static CryptographicPublicKeyBlobType X509SubjectPublicKeyInfo;
    public static CryptographicPublicKeyBlobType Pkcs1RsaPublicKey;
    public static CryptographicPublicKeyBlobType BCryptPublicKey;
    public static CryptographicPublicKeyBlobType Capi1PublicKey;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PCLCrypto.CryptoStream : Stream {
    private Stream chainedStream;
    private ICryptoTransform transform;
    private CryptoStreamMode mode;
    private Byte[] inputBuffer;
    private Byte[] outputBuffer;
    private int inputBufferSize;
    private int outputBufferSize;
    private int outputBufferIndex;
    [CompilerGeneratedAttribute]
private bool <HasFlushedFinalBlock>k__BackingField;
    public bool HasFlushedFinalBlock { get; private set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CryptoStream(Stream stream, ICryptoTransform transform, CryptoStreamMode mode);
    [CompilerGeneratedAttribute]
public bool get_HasFlushedFinalBlock();
    [CompilerGeneratedAttribute]
private void set_HasFlushedFinalBlock(bool value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public static CryptoStream WriteTo(Stream stream, ICryptoTransform[] transforms);
    public static CryptoStream ReadFrom(Stream stream, ICryptoTransform[] transforms);
    public void FlushFinalBlock();
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
    private static CryptoStream Chain(Stream stream, CryptoStreamMode cryptoStreamMode, ICryptoTransform[] transforms);
    private static Stream ChainWrite(Stream stream, IEnumerator`1<ICryptoTransform> transforms);
}
public enum PCLCrypto.CryptoStreamMode : Enum {
    public int value__;
    public static CryptoStreamMode Read;
    public static CryptoStreamMode Write;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class PCLCrypto.CryptoUtilities : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static T[] AsTrimmedArray(ArraySegment`1<T> array);
    internal static void ApplyZeroPadding(Byte[]& buffer, int blockLength);
    internal static void ApplyZeroPadding(Byte[]& buffer, int blockLength, Int32& bufferOffset, Int32& bufferCount);
    internal static bool BufferEquals(Byte[] buffer1, Byte[] buffer2);
    [ExtensionAttribute]
internal static Byte[] CloneArray(Byte[] buffer);
    [ExtensionAttribute]
internal static ArraySegment`1<T> AsArraySegment(T[] buffer);
    [ExtensionAttribute]
internal static IReadOnlyList`1<KeySizes> GetTypicalLegalAsymmetricKeySizes(AsymmetricAlgorithm algorithm);
    [ExtensionAttribute]
internal static Char[] ToCharArrayWithNullTerminator(string value);
    internal static Byte[] CopyAndReverse(Byte[] data);
    internal static BigInteger FromPositiveBigEndian(Byte[] data);
}
internal class PCLCrypto.DeriveBytes : object {
    [NullableContextAttribute("1")]
public sealed virtual Byte[] GetBytes(string keyMaterial, Byte[] salt, int iterations, int countBytes, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public sealed virtual Byte[] GetBytes(Byte[] keyMaterial, Byte[] salt, int iterations, int countBytes, HashAlgorithmName hashAlgorithm);
}
internal class PCLCrypto.ECDiffieHellmanCngPublicKeyFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual IECDiffieHellmanPublicKey FromByteArray(Byte[] publicKey);
}
internal class PCLCrypto.ECDiffieHellmanFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual IECDiffieHellman Create();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class PCLCrypto.Formatters.Asn : object {
    [IteratorStateMachineAttribute("PCLCrypto.Formatters.Asn/<ReadAsn1Elements>d__3")]
[ExtensionAttribute]
internal static IEnumerable`1<DataElement> ReadAsn1Elements(Stream stream);
    internal static IEnumerable`1<DataElement> ReadAsn1Elements(Byte[] value);
    [ExtensionAttribute]
internal static void WriteAsn1Element(Stream stream, DataElement element);
    internal static Byte[] WriteAsn1Element(DataElement element);
    internal static Byte[] WriteAsn1Elements(DataElement[] elements);
    private static byte GetMinimumBytesRequiredToRepresent(UInt32 value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PCLCrypto.Formatters.CapiKeyFormatter : KeyFormatter {
    private static byte PublicKeyBlobHeader;
    private static byte PrivateKeyBlobHeader;
    private static byte CurrentBlobVersion;
    private static string PublicKeyMagicHeader;
    private static string PrivateKeyMagicHeader;
    private static int KeySpecKeyExchange;
    public static bool IsCapiCompatible(RSAParameters parameters);
    public static RSAParameters NegotiateSizes(RSAParameters parameters);
    internal static void VerifyCapiCompatibleParameters(RSAParameters parameters);
    protected virtual RSAParameters ReadCore(Stream stream);
    protected virtual void WriteCore(Stream stream, RSAParameters parameters);
    private static void WriteReversed(BinaryWriter writer, Byte[] data, int length);
    private static Byte[] ReadReversed(BinaryReader reader, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class PCLCrypto.Formatters.KeyFormatter : object {
    internal static KeyFormatter Pkcs1;
    internal static KeyFormatter Pkcs8;
    internal static KeyFormatter X509SubjectPublicKeyInfo;
    internal static KeyFormatter Capi;
    internal static KeyFormatter BCryptRsaPrivateKey;
    internal static KeyFormatter BCryptRsaFullPrivateKey;
    internal static KeyFormatter BCryptRsaPublicKey;
    protected static Byte[] Pkcs1ObjectIdentifier;
    protected static Byte[] RsaEncryptionObjectIdentifier;
    private static KeyFormatter();
    public static KeyFormatter GetFormatter(CryptographicPrivateKeyBlobType blobType);
    public static KeyFormatter GetFormatter(CryptographicPublicKeyBlobType blobType);
    public static RSAParameters ToPlatformParameters(RSAParameters value);
    public static RSAParameters ToPCLParameters(RSAParameters value);
    public void Write(Stream stream, RSAParameters parameters);
    public void Write(Stream stream, RSAParameters parameters, bool includePrivateKey);
    public Byte[] Write(RSAParameters parameters);
    public Byte[] Write(RSAParameters parameters, bool includePrivateKey);
    public RSAParameters Read(Stream stream);
    public RSAParameters Read(Byte[] keyBlob);
    protected internal static RSAParameters PublicKeyFilter(RSAParameters value);
    protected internal static bool HasPrivateKey(RSAParameters parameters);
    protected static bool BufferEqual(Byte[] buffer1, Byte[] buffer2);
    [NullableContextAttribute("2")]
protected static Byte[] TrimLeadingZero(Byte[] buffer);
    protected static RSAParameters TrimLeadingZeros(RSAParameters parameters);
    [NullableContextAttribute("2")]
protected static Byte[] TrimOrPadZeroToLength(Byte[] buffer, int desiredLength);
    protected static Byte[] PrependLeadingZero(Byte[] buffer, bool alwaysPrependZero);
    [NullableContextAttribute("2")]
protected static void VerifyFormat(bool condition, string message);
    protected static Exception FailFormat(string message);
    protected static Byte[] CopyAndReverse(Byte[] data);
    protected abstract virtual RSAParameters ReadCore(Stream stream);
    protected abstract virtual void WriteCore(Stream stream, RSAParameters parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PCLCrypto.Formatters.Pkcs1KeyFormatter : KeyFormatter {
    protected virtual RSAParameters ReadCore(Stream stream);
    protected virtual void WriteCore(Stream stream, RSAParameters value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PCLCrypto.Formatters.Pkcs8KeyFormatter : KeyFormatter {
    protected virtual RSAParameters ReadCore(Stream stream);
    protected virtual void WriteCore(Stream stream, RSAParameters parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PCLCrypto.Formatters.X509SubjectPublicKeyInfoFormatter : KeyFormatter {
    protected virtual RSAParameters ReadCore(Stream stream);
    protected virtual void WriteCore(Stream stream, RSAParameters parameters);
}
public enum PCLCrypto.HashAlgorithm : Enum {
    public int value__;
    public static HashAlgorithm Md5;
    public static HashAlgorithm Sha1;
    public static HashAlgorithm Sha256;
    public static HashAlgorithm Sha384;
    public static HashAlgorithm Sha512;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PCLCrypto.HashAlgorithmProvider : object {
    private HashAlgorithm algorithm;
    public HashAlgorithm Algorithm { get; }
    public int HashLength { get; }
    internal HashAlgorithmProvider(HashAlgorithm algorithm);
    public sealed virtual HashAlgorithm get_Algorithm();
    public sealed virtual int get_HashLength();
    public sealed virtual CryptographicHash CreateHash();
    public sealed virtual Byte[] HashData(Byte[] data);
    internal static HashAlgorithm CreateHashAlgorithm(HashAlgorithm algorithm);
}
internal class PCLCrypto.HashAlgorithmProviderFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual IHashAlgorithmProvider OpenAlgorithm(HashAlgorithm algorithm);
    [NullableContextAttribute("1")]
internal static string GetHashAlgorithmName(HashAlgorithm algorithm);
}
[NullableContextAttribute("1")]
public interface PCLCrypto.IAsymmetricKeyAlgorithmProvider {
    public AsymmetricAlgorithm Algorithm { get; }
    public IReadOnlyList`1<KeySizes> LegalKeySizes { get; }
    public abstract virtual AsymmetricAlgorithm get_Algorithm();
    public abstract virtual IReadOnlyList`1<KeySizes> get_LegalKeySizes();
    public abstract virtual ICryptographicKey CreateKeyPair(int keySize);
    public abstract virtual ICryptographicKey ImportKeyPair(Byte[] keyBlob, CryptographicPrivateKeyBlobType blobType);
    public abstract virtual ICryptographicKey ImportPublicKey(Byte[] keyBlob, CryptographicPublicKeyBlobType blobType);
}
[NullableContextAttribute("1")]
public interface PCLCrypto.IAsymmetricKeyAlgorithmProviderFactory {
    public abstract virtual IAsymmetricKeyAlgorithmProvider OpenAlgorithm(AsymmetricAlgorithm algorithm);
}
[NullableContextAttribute("1")]
public interface PCLCrypto.ICryptographicBuffer {
    public abstract virtual bool Compare(Byte[] object1, Byte[] object2);
    public abstract virtual string ConvertBinaryToString(Encoding encoding, Byte[] buffer);
    public abstract virtual Byte[] ConvertStringToBinary(string value, Encoding encoding);
    public abstract virtual void CopyToByteArray(Byte[] buffer, Byte[]& value);
    public abstract virtual Byte[] CreateFromByteArray(Byte[] value);
    public abstract virtual Byte[] DecodeFromBase64String(string value);
    public abstract virtual Byte[] DecodeFromHexString(string value);
    public abstract virtual string EncodeToBase64String(Byte[] buffer);
    public abstract virtual string EncodeToHexString(Byte[] buffer);
    public abstract virtual Byte[] GenerateRandom(int length);
    public abstract virtual UInt32 GenerateRandomNumber();
}
[NullableContextAttribute("1")]
public interface PCLCrypto.ICryptographicEngine {
    public abstract virtual Byte[] Encrypt(ICryptographicKey key, Byte[] data, Byte[] iv);
    public abstract virtual ICryptoTransform CreateEncryptor(ICryptographicKey key, Byte[] iv);
    public abstract virtual Byte[] Decrypt(ICryptographicKey key, Byte[] data, Byte[] iv);
    public abstract virtual ICryptoTransform CreateDecryptor(ICryptographicKey key, Byte[] iv);
    public abstract virtual Byte[] Sign(ICryptographicKey key, Byte[] data);
    public abstract virtual Byte[] SignHashedData(ICryptographicKey key, Byte[] data);
    public abstract virtual bool VerifySignature(ICryptographicKey key, Byte[] data, Byte[] signature);
    public abstract virtual bool VerifySignatureWithHashInput(ICryptographicKey key, Byte[] data, Byte[] signature);
    public abstract virtual Byte[] DeriveKeyMaterial(ICryptographicKey key, IKeyDerivationParameters parameters, int desiredKeySize);
}
[NullableContextAttribute("1")]
public interface PCLCrypto.ICryptographicKey {
    public int KeySize { get; }
    public abstract virtual int get_KeySize();
    public abstract virtual Byte[] Export(CryptographicPrivateKeyBlobType blobType);
    public abstract virtual Byte[] ExportPublicKey(CryptographicPublicKeyBlobType blobType);
}
[NullableContextAttribute("1")]
public interface PCLCrypto.ICryptoTransform {
    public bool CanReuseTransform { get; }
    public bool CanTransformMultipleBlocks { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public abstract virtual bool get_CanReuseTransform();
    public abstract virtual bool get_CanTransformMultipleBlocks();
    public abstract virtual int get_InputBlockSize();
    public abstract virtual int get_OutputBlockSize();
    public abstract virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public abstract virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
}
[NullableContextAttribute("1")]
public interface PCLCrypto.IDeriveBytes {
    public abstract virtual Byte[] GetBytes(string keyMaterial, Byte[] salt, int iterations, int countBytes, HashAlgorithmName hashAlgorithm);
    public abstract virtual Byte[] GetBytes(Byte[] keyMaterial, Byte[] salt, int iterations, int countBytes, HashAlgorithmName hashAlgorithm);
}
[NullableContextAttribute("1")]
public interface PCLCrypto.IECDiffieHellman {
    public int KeySize { get; public set; }
    public IECDiffieHellmanPublicKey PublicKey { get; }
    public abstract virtual int get_KeySize();
    public abstract virtual void set_KeySize(int value);
    public abstract virtual IECDiffieHellmanPublicKey get_PublicKey();
    public abstract virtual Byte[] DeriveKeyMaterial(IECDiffieHellmanPublicKey otherParty);
}
[NullableContextAttribute("1")]
public interface PCLCrypto.IECDiffieHellmanCngPublicKeyFactory {
    public abstract virtual IECDiffieHellmanPublicKey FromByteArray(Byte[] publicKey);
}
[NullableContextAttribute("1")]
public interface PCLCrypto.IECDiffieHellmanFactory {
    public abstract virtual IECDiffieHellman Create();
}
[NullableContextAttribute("1")]
public interface PCLCrypto.IECDiffieHellmanPublicKey {
    public abstract virtual Byte[] ToByteArray();
}
[NullableContextAttribute("1")]
public interface PCLCrypto.IHashAlgorithmProvider {
    public HashAlgorithm Algorithm { get; }
    public int HashLength { get; }
    public abstract virtual HashAlgorithm get_Algorithm();
    public abstract virtual int get_HashLength();
    public abstract virtual CryptographicHash CreateHash();
    public abstract virtual Byte[] HashData(Byte[] data);
}
[NullableContextAttribute("1")]
public interface PCLCrypto.IHashAlgorithmProviderFactory {
    public abstract virtual IHashAlgorithmProvider OpenAlgorithm(HashAlgorithm algorithm);
}
[NullableContextAttribute("1")]
public interface PCLCrypto.IKeyDerivationAlgorithmProvider {
    public KeyDerivationAlgorithm Algorithm { get; }
    public abstract virtual KeyDerivationAlgorithm get_Algorithm();
    public abstract virtual ICryptographicKey CreateKey(Byte[] keyMaterial);
}
[NullableContextAttribute("1")]
public interface PCLCrypto.IKeyDerivationAlgorithmProviderFactory {
    public abstract virtual IKeyDerivationAlgorithmProvider OpenAlgorithm(KeyDerivationAlgorithm algorithm);
}
[NullableContextAttribute("1")]
public interface PCLCrypto.IKeyDerivationParameters {
    public int IterationCount { get; }
    public Byte[] KdfGenericBinary { get; public set; }
    public abstract virtual int get_IterationCount();
    public abstract virtual Byte[] get_KdfGenericBinary();
    public abstract virtual void set_KdfGenericBinary(Byte[] value);
}
[NullableContextAttribute("1")]
public interface PCLCrypto.IKeyDerivationParametersFactory {
    public abstract virtual IKeyDerivationParameters BuildForPbkdf2(Byte[] pbkdf2Salt, int iterationCount);
    public abstract virtual IKeyDerivationParameters BuildForSP800108(Byte[] label, Byte[] context);
    public abstract virtual IKeyDerivationParameters BuildForSP80056a(Byte[] algorithmId, Byte[] partyUInfo, Byte[] partyVInfo, Byte[] suppPubInfo, Byte[] suppPrivInfo);
}
[NullableContextAttribute("1")]
public interface PCLCrypto.IMacAlgorithmProvider {
    public MacAlgorithm Algorithm { get; }
    public int MacLength { get; }
    public abstract virtual MacAlgorithm get_Algorithm();
    public abstract virtual int get_MacLength();
    public abstract virtual CryptographicHash CreateHash(Byte[] keyMaterial);
    public abstract virtual ICryptographicKey CreateKey(Byte[] keyMaterial);
}
[NullableContextAttribute("1")]
public interface PCLCrypto.IMacAlgorithmProviderFactory {
    public abstract virtual IMacAlgorithmProvider OpenAlgorithm(MacAlgorithm algorithm);
}
[NullableContextAttribute("1")]
public interface PCLCrypto.IRandomNumberGenerator {
    public abstract virtual void GetBytes(Byte[] buffer);
}
[NullableContextAttribute("1")]
public interface PCLCrypto.ISymmetricKeyAlgorithmProvider {
    public int BlockLength { get; }
    public IReadOnlyList`1<KeySizes> LegalKeySizes { get; }
    public SymmetricAlgorithmName Name { get; }
    public SymmetricAlgorithmMode Mode { get; }
    public SymmetricAlgorithmPadding Padding { get; }
    public abstract virtual int get_BlockLength();
    public abstract virtual IReadOnlyList`1<KeySizes> get_LegalKeySizes();
    public abstract virtual SymmetricAlgorithmName get_Name();
    public abstract virtual SymmetricAlgorithmMode get_Mode();
    public abstract virtual SymmetricAlgorithmPadding get_Padding();
    public abstract virtual ICryptographicKey CreateSymmetricKey(Byte[] keyMaterial);
}
[NullableContextAttribute("1")]
public interface PCLCrypto.ISymmetricKeyAlgorithmProviderFactory {
    public abstract virtual ISymmetricKeyAlgorithmProvider OpenAlgorithm(SymmetricAlgorithmName name, SymmetricAlgorithmMode mode, SymmetricAlgorithmPadding padding);
}
public enum PCLCrypto.KeyDerivationAlgorithm : Enum {
    public int value__;
    public static KeyDerivationAlgorithm Pbkdf2Md5;
    public static KeyDerivationAlgorithm Pbkdf2Sha1;
    public static KeyDerivationAlgorithm Pbkdf2Sha256;
    public static KeyDerivationAlgorithm Pbkdf2Sha384;
    public static KeyDerivationAlgorithm Pbkdf2Sha512;
    public static KeyDerivationAlgorithm Sp800108CtrHmacMd5;
    public static KeyDerivationAlgorithm Sp800108CtrHmacSha1;
    public static KeyDerivationAlgorithm Sp800108CtrHmacSha256;
    public static KeyDerivationAlgorithm Sp800108CtrHmacSha384;
    public static KeyDerivationAlgorithm Sp800108CtrHmacSha512;
    public static KeyDerivationAlgorithm Sp80056aConcatMd5;
    public static KeyDerivationAlgorithm Sp80056aConcatSha1;
    public static KeyDerivationAlgorithm Sp80056aConcatSha256;
    public static KeyDerivationAlgorithm Sp80056aConcatSha384;
    public static KeyDerivationAlgorithm Sp80056aConcatSha512;
}
internal class PCLCrypto.KeyDerivationAlgorithmProvider : object {
    private KeyDerivationAlgorithm algorithm;
    public KeyDerivationAlgorithm Algorithm { get; }
    internal KeyDerivationAlgorithmProvider(KeyDerivationAlgorithm algorithm);
    public sealed virtual KeyDerivationAlgorithm get_Algorithm();
    [NullableContextAttribute("1")]
public sealed virtual ICryptographicKey CreateKey(Byte[] keyMaterial);
}
internal class PCLCrypto.KeyDerivationAlgorithmProviderFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual IKeyDerivationAlgorithmProvider OpenAlgorithm(KeyDerivationAlgorithm algorithm);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PCLCrypto.KeyDerivationCryptographicKey : CryptographicKey {
    private KeyDerivationAlgorithm algorithm;
    private Byte[] key;
    public int KeySize { get; }
    internal Byte[] Key { get; }
    internal KeyDerivationAlgorithm Algorithm { get; }
    internal KeyDerivationCryptographicKey(KeyDerivationAlgorithm algorithm, Byte[] key);
    public sealed virtual int get_KeySize();
    internal Byte[] get_Key();
    internal KeyDerivationAlgorithm get_Algorithm();
    public sealed virtual Byte[] Export(CryptographicPrivateKeyBlobType blobType);
    public sealed virtual Byte[] ExportPublicKey(CryptographicPublicKeyBlobType blobType);
    protected internal virtual Byte[] DeriveKeyMaterial(IKeyDerivationParameters parameters, int desiredKeySize);
    private static HashAlgorithmName GetHashAlgorithm(KeyDerivationAlgorithm keyDerivationAlgorithm);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PCLCrypto.KeyDerivationParametersFactory : object {
    public sealed virtual IKeyDerivationParameters BuildForPbkdf2(Byte[] pbkdf2Salt, int iterationCount);
    public sealed virtual IKeyDerivationParameters BuildForSP800108(Byte[] label, Byte[] context);
    public sealed virtual IKeyDerivationParameters BuildForSP80056a(Byte[] algorithmId, Byte[] partyUInfo, Byte[] partyVInfo, Byte[] suppPubInfo, Byte[] suppPrivInfo);
}
public class PCLCrypto.KeySizes : ValueType {
    [CompilerGeneratedAttribute]
private int <MaxSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StepSize>k__BackingField;
    public int MaxSize { get; }
    public int MinSize { get; }
    public int StepSize { get; }
    public KeySizes(int minSize, int maxSize, int stepSize);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_MaxSize();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_MinSize();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_StepSize();
    public static bool op_Equality(KeySizes first, KeySizes second);
    public static bool op_Inequality(KeySizes first, KeySizes second);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("PCLCrypto.KeySizes/<GetEnumerator>d__12")]
public sealed virtual IEnumerator`1<int> GetEnumerator();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool Equals(KeySizes other);
    [NullableContextAttribute("1")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum PCLCrypto.MacAlgorithm : Enum {
    public int value__;
    public static MacAlgorithm AesCmac;
    public static MacAlgorithm HmacMd5;
    public static MacAlgorithm HmacSha1;
    public static MacAlgorithm HmacSha256;
    public static MacAlgorithm HmacSha384;
    public static MacAlgorithm HmacSha512;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PCLCrypto.MacAlgorithmProvider : object {
    private MacAlgorithm algorithm;
    public MacAlgorithm Algorithm { get; }
    public int MacLength { get; }
    internal MacAlgorithmProvider(MacAlgorithm algorithm);
    public sealed virtual MacAlgorithm get_Algorithm();
    public sealed virtual int get_MacLength();
    public sealed virtual CryptographicHash CreateHash(Byte[] keyMaterial);
    public sealed virtual ICryptographicKey CreateKey(Byte[] keyMaterial);
    internal static KeyedHashAlgorithm GetAlgorithm(MacAlgorithm algorithm);
}
internal class PCLCrypto.MacAlgorithmProviderFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual IMacAlgorithmProvider OpenAlgorithm(MacAlgorithm algorithm);
    [NullableContextAttribute("1")]
internal static string GetAlgorithmName(MacAlgorithm algorithm);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PCLCrypto.MacCryptographicKey : CryptographicKey {
    private MacAlgorithm algorithm;
    private Byte[] key;
    public int KeySize { get; }
    internal MacCryptographicKey(MacAlgorithm algorithm, Byte[] key);
    public sealed virtual int get_KeySize();
    public sealed virtual Byte[] Export(CryptographicPrivateKeyBlobType blobType);
    public sealed virtual Byte[] ExportPublicKey(CryptographicPublicKeyBlobType blobType);
    protected internal virtual Byte[] Sign(Byte[] data);
    protected internal virtual bool VerifySignature(Byte[] data, Byte[] signature);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class PCLCrypto.NetFxCrypto : object {
    [NullableAttribute("2")]
private static IRandomNumberGenerator randomNumberGenerator;
    public static IRandomNumberGenerator RandomNumberGenerator { get; }
    public static IDeriveBytes DeriveBytes { get; }
    public static IECDiffieHellmanFactory ECDiffieHellman { get; }
    public static IECDiffieHellmanCngPublicKeyFactory ECDiffieHellmanCngPublicKey { get; }
    public static IRandomNumberGenerator get_RandomNumberGenerator();
    public static IDeriveBytes get_DeriveBytes();
    public static IECDiffieHellmanFactory get_ECDiffieHellman();
    public static IECDiffieHellmanCngPublicKeyFactory get_ECDiffieHellmanCngPublicKey();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PCLCrypto.NetFxCryptographicHash : CryptographicHash {
    private static Byte[] EmptyBlock;
    private bool transformedFinalBlock;
    [CompilerGeneratedAttribute]
private HashAlgorithm <Algorithm>k__BackingField;
    protected HashAlgorithm Algorithm { get; private set; }
    protected bool CanReuseTransform { get; }
    protected bool CanTransformMultipleBlocks { get; }
    protected int InputBlockSize { get; }
    protected int OutputBlockSize { get; }
    internal NetFxCryptographicHash(HashAlgorithm algorithm);
    private static NetFxCryptographicHash();
    [CompilerGeneratedAttribute]
protected HashAlgorithm get_Algorithm();
    [CompilerGeneratedAttribute]
private void set_Algorithm(HashAlgorithm value);
    protected virtual bool get_CanReuseTransform();
    protected virtual bool get_CanTransformMultipleBlocks();
    protected virtual int get_InputBlockSize();
    protected virtual int get_OutputBlockSize();
    public virtual void Append(Byte[] data);
    public virtual Byte[] GetValueAndReset();
    protected virtual void Dispose(bool disposing);
    protected virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    protected virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
}
internal class PCLCrypto.NotImplementedByReferenceAssemblyException : NotImplementedException {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PCLCrypto.RandomNumberGenerator : RandomNumberGenerator {
    private static RandomNumberGenerator RandomSource;
    private static RandomNumberGenerator();
    public virtual void GetBytes(Byte[] buffer);
    public virtual void GetNonZeroBytes(Byte[] data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PCLCrypto.RsaAsymmetricKeyAlgorithmProvider : object {
    private AsymmetricAlgorithm algorithm;
    public AsymmetricAlgorithm Algorithm { get; }
    public IReadOnlyList`1<KeySizes> LegalKeySizes { get; }
    public RsaAsymmetricKeyAlgorithmProvider(AsymmetricAlgorithm algorithm);
    public sealed virtual AsymmetricAlgorithm get_Algorithm();
    public sealed virtual IReadOnlyList`1<KeySizes> get_LegalKeySizes();
    public sealed virtual ICryptographicKey CreateKeyPair(int keySize);
    public sealed virtual ICryptographicKey ImportKeyPair(Byte[] keyBlob, CryptographicPrivateKeyBlobType blobType);
    public sealed virtual ICryptographicKey ImportPublicKey(Byte[] keyBlob, CryptographicPublicKeyBlobType blobType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PCLCrypto.RsaCryptographicKey : CryptographicKey {
    private RSA key;
    private AsymmetricAlgorithm algorithm;
    public int KeySize { get; }
    internal RSA Rsa { get; }
    internal AsymmetricAlgorithm Algorithm { get; }
    internal RsaCryptographicKey(RSA key, AsymmetricAlgorithm algorithm);
    public sealed virtual int get_KeySize();
    internal RSA get_Rsa();
    internal AsymmetricAlgorithm get_Algorithm();
    public sealed virtual Byte[] Export(CryptographicPrivateKeyBlobType blobType);
    public sealed virtual Byte[] ExportPublicKey(CryptographicPublicKeyBlobType blobType);
    protected internal virtual Byte[] Sign(Byte[] data);
    protected internal virtual bool VerifySignature(Byte[] data, Byte[] signature);
    protected internal virtual Byte[] SignHash(Byte[] data);
    protected internal virtual bool VerifyHash(Byte[] data, Byte[] signature);
    protected internal virtual Byte[] Encrypt(Byte[] data, Byte[] iv);
    protected internal virtual Byte[] Decrypt(Byte[] data, Byte[] iv);
    protected virtual void Dispose(bool disposing);
    private HashAlgorithm GetHashAlgorithm();
    private AsymmetricSignatureFormatter GetSignatureFormatter();
    private AsymmetricSignatureDeformatter GetSignatureDeformatter();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class PCLCrypto.RSAParameters : ValueType {
    public Byte[] D;
    public Byte[] DP;
    public Byte[] DQ;
    public Byte[] Exponent;
    public Byte[] InverseQ;
    public Byte[] Modulus;
    public Byte[] P;
    public Byte[] Q;
    public static bool op_Equality(RSAParameters first, RSAParameters second);
    public static bool op_Inequality(RSAParameters first, RSAParameters second);
    [NullableContextAttribute("1")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(RSAParameters other);
    [NullableContextAttribute("0")]
private static bool Equals(ReadOnlySpan`1<byte> a, ReadOnlySpan`1<byte> b);
    [NullableContextAttribute("0")]
private static int GetHashCode(ReadOnlySpan`1<byte> span);
}
[ExtensionAttribute]
internal static class PCLCrypto.RSAParametersExtensions : object {
    [ExtensionAttribute]
internal static bool HasPrivateKey(RSAParameters rsa);
    [ExtensionAttribute]
internal static bool HasFullPrivateKeyData(RSAParameters rsa);
    [ExtensionAttribute]
internal static RSAParameters ComputeFullPrivateKeyData(RSAParameters rsa);
    [ExtensionAttribute]
internal static RSAParameters StripOptionalPrivateKeyData(RSAParameters rsa);
    [NullableContextAttribute("1")]
private static RSAParameters Create(Byte[] p, Byte[] q, Byte[] exponent, Byte[] modulus);
    private static RSAParameters GetFullPrivateParameters(BigInteger p, BigInteger q, BigInteger e, BigInteger n);
    private static BigInteger ModInverse(BigInteger a, BigInteger n);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class PCLCrypto.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string FinalBlockAlreadyTransformed { get; }
    internal static string InvalidFormatOrTooLong { get; }
    internal static string MustBePositive { get; }
    internal static string PrivateKeyNotAvailable { get; }
    internal static string PropertyXMustBeNonEmpty { get; }
    internal static string StreamMustBeReadable { get; }
    internal static string StreamMustBeWritable { get; }
    internal static string UnexpectedAlgorithm { get; }
    internal static string UnexpectedFormat { get; }
    internal static string UnrecognizedObjectIdentifier { get; }
    internal static string UnrecognizedVersion { get; }
    internal static string UnsupportedAlgorithm { get; }
    internal static string UnsupportedMode { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_FinalBlockAlreadyTransformed();
    internal static string get_InvalidFormatOrTooLong();
    internal static string get_MustBePositive();
    internal static string get_PrivateKeyNotAvailable();
    internal static string get_PropertyXMustBeNonEmpty();
    internal static string get_StreamMustBeReadable();
    internal static string get_StreamMustBeWritable();
    internal static string get_UnexpectedAlgorithm();
    internal static string get_UnexpectedFormat();
    internal static string get_UnrecognizedObjectIdentifier();
    internal static string get_UnrecognizedVersion();
    internal static string get_UnsupportedAlgorithm();
    internal static string get_UnsupportedMode();
}
public enum PCLCrypto.SymmetricAlgorithm : Enum {
    public int value__;
    public static SymmetricAlgorithm AesCbc;
    public static SymmetricAlgorithm AesCbcPkcs7;
    public static SymmetricAlgorithm AesCcm;
    public static SymmetricAlgorithm AesEcb;
    public static SymmetricAlgorithm AesEcbPkcs7;
    public static SymmetricAlgorithm AesGcm;
    public static SymmetricAlgorithm DesCbc;
    public static SymmetricAlgorithm DesCbcPkcs7;
    public static SymmetricAlgorithm DesEcb;
    public static SymmetricAlgorithm DesEcbPkcs7;
    public static SymmetricAlgorithm Rc2Cbc;
    public static SymmetricAlgorithm Rc2CbcPkcs7;
    public static SymmetricAlgorithm Rc2Ecb;
    public static SymmetricAlgorithm Rc2EcbPkcs7;
    public static SymmetricAlgorithm Rc4;
    public static SymmetricAlgorithm TripleDesCbc;
    public static SymmetricAlgorithm TripleDesCbcPkcs7;
    public static SymmetricAlgorithm TripleDesEcb;
    public static SymmetricAlgorithm TripleDesEcbPkcs7;
}
[ExtensionAttribute]
public static class PCLCrypto.SymmetricAlgorithmExtensions : object {
    [ExtensionAttribute]
public static bool IsBlockCipher(SymmetricAlgorithm algorithm);
    [ExtensionAttribute]
public static bool IsBlockCipher(SymmetricAlgorithmName algorithm);
    [ExtensionAttribute]
public static bool IsBlockCipher(SymmetricAlgorithmMode mode);
    [ExtensionAttribute]
public static bool IsAuthenticated(SymmetricAlgorithmMode mode);
    [ExtensionAttribute]
public static SymmetricAlgorithmName GetName(SymmetricAlgorithm algorithm);
    [ExtensionAttribute]
public static SymmetricAlgorithmMode GetMode(SymmetricAlgorithm algorithm);
    [ExtensionAttribute]
public static SymmetricAlgorithmPadding GetPadding(SymmetricAlgorithm algorithm);
    public static bool TryAssemblyAlgorithm(SymmetricAlgorithmName name, SymmetricAlgorithmMode mode, SymmetricAlgorithmPadding padding, SymmetricAlgorithm& algorithm);
    [ExtensionAttribute]
public static bool UsesIV(SymmetricAlgorithmMode mode);
    [ExtensionAttribute]
public static bool UsesIV(SymmetricAlgorithm algorithm);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetString(SymmetricAlgorithmName algorithm);
}
public enum PCLCrypto.SymmetricAlgorithmMode : Enum {
    public int value__;
    public static SymmetricAlgorithmMode Streaming;
    public static SymmetricAlgorithmMode Cbc;
    public static SymmetricAlgorithmMode Ecb;
    public static SymmetricAlgorithmMode Ccm;
    public static SymmetricAlgorithmMode Gcm;
}
public enum PCLCrypto.SymmetricAlgorithmName : Enum {
    public int value__;
    public static SymmetricAlgorithmName Aes;
    public static SymmetricAlgorithmName Des;
    public static SymmetricAlgorithmName TripleDes;
    public static SymmetricAlgorithmName Rc2;
    public static SymmetricAlgorithmName Rc4;
}
public enum PCLCrypto.SymmetricAlgorithmPadding : Enum {
    public int value__;
    public static SymmetricAlgorithmPadding None;
    public static SymmetricAlgorithmPadding PKCS7;
    public static SymmetricAlgorithmPadding Zeros;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PCLCrypto.SymmetricCryptographicKey : CryptographicKey {
    private SymmetricAlgorithm algorithm;
    [NullableAttribute("2")]
private ICryptoTransform encryptor;
    [NullableAttribute("2")]
private ICryptoTransform decryptor;
    [CompilerGeneratedAttribute]
private SymmetricAlgorithmName <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private SymmetricAlgorithmMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private SymmetricAlgorithmPadding <Padding>k__BackingField;
    public int KeySize { get; }
    public SymmetricAlgorithmName Name { get; }
    public SymmetricAlgorithmMode Mode { get; }
    public SymmetricAlgorithmPadding Padding { get; }
    private bool CanStreamAcrossTopLevelCipherOperations { get; }
    internal SymmetricCryptographicKey(SymmetricAlgorithm algorithm, SymmetricAlgorithmName name, SymmetricAlgorithmMode mode, SymmetricAlgorithmPadding padding);
    public sealed virtual int get_KeySize();
    public sealed virtual Byte[] Export(CryptographicPrivateKeyBlobType blobType);
    public sealed virtual Byte[] ExportPublicKey(CryptographicPublicKeyBlobType blobType);
    protected internal virtual Byte[] Encrypt(Byte[] data, Byte[] iv);
    protected internal virtual Byte[] Decrypt(Byte[] data, Byte[] iv);
    protected internal virtual ICryptoTransform CreateEncryptor(Byte[] iv);
    protected internal virtual ICryptoTransform CreateDecryptor(Byte[] iv);
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("2")]
private Byte[] ThisOrDefaultIV(Byte[] iv);
    private bool IsValidInputSize(int lengthInBytes);
    private Byte[] CipherOperation(ICryptoTransform& transformField, Func`3<SymmetricCryptographicKey, Byte[], ICryptoTransform> transformCreator, Byte[] data, Byte[] iv);
    [CompilerGeneratedAttribute]
public SymmetricAlgorithmName get_Name();
    [CompilerGeneratedAttribute]
public SymmetricAlgorithmMode get_Mode();
    [CompilerGeneratedAttribute]
public SymmetricAlgorithmPadding get_Padding();
    private bool get_CanStreamAcrossTopLevelCipherOperations();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PCLCrypto.SymmetricKeyAlgorithmProvider : object {
    [NullableAttribute("2")]
private IReadOnlyList`1<KeySizes> legalKeySizes;
    [CompilerGeneratedAttribute]
private SymmetricAlgorithmName <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private SymmetricAlgorithmMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private SymmetricAlgorithmPadding <Padding>k__BackingField;
    public int BlockLength { get; }
    public IReadOnlyList`1<KeySizes> LegalKeySizes { get; }
    public SymmetricAlgorithmName Name { get; }
    public SymmetricAlgorithmMode Mode { get; }
    public SymmetricAlgorithmPadding Padding { get; }
    public SymmetricKeyAlgorithmProvider(SymmetricAlgorithmName name, SymmetricAlgorithmMode mode, SymmetricAlgorithmPadding padding);
    public sealed virtual int get_BlockLength();
    public sealed virtual IReadOnlyList`1<KeySizes> get_LegalKeySizes();
    public sealed virtual ICryptographicKey CreateSymmetricKey(Byte[] keyMaterial);
    private static CipherMode GetMode(SymmetricAlgorithmMode mode);
    private static PaddingMode GetPadding(SymmetricAlgorithmPadding padding);
    private SymmetricAlgorithm GetAlgorithm();
    [CompilerGeneratedAttribute]
public sealed virtual SymmetricAlgorithmName get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual SymmetricAlgorithmMode get_Mode();
    [CompilerGeneratedAttribute]
public sealed virtual SymmetricAlgorithmPadding get_Padding();
}
internal class PCLCrypto.SymmetricKeyAlgorithmProviderFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual ISymmetricKeyAlgorithmProvider OpenAlgorithm(SymmetricAlgorithmName name, SymmetricAlgorithmMode mode, SymmetricAlgorithmPadding padding);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class PCLCrypto.WinRTCrypto : object {
    [NullableAttribute("2")]
private static IAsymmetricKeyAlgorithmProviderFactory asymmetricKeyAlgorithmProvider;
    [NullableAttribute("2")]
private static ISymmetricKeyAlgorithmProviderFactory symmetricKeyAlgorithmProvider;
    [NullableAttribute("2")]
private static IHashAlgorithmProviderFactory hashAlgorithmProvider;
    [NullableAttribute("2")]
private static IMacAlgorithmProviderFactory macAlgorithmProvider;
    [NullableAttribute("2")]
private static IKeyDerivationAlgorithmProviderFactory keyDerivationAlgorithmProvider;
    [NullableAttribute("2")]
private static IKeyDerivationParametersFactory keyDerivationParametersFactory;
    [NullableAttribute("2")]
private static ICryptographicEngine cryptographicEngine;
    [NullableAttribute("2")]
private static ICryptographicBuffer cryptographicBuffer;
    public static IAsymmetricKeyAlgorithmProviderFactory AsymmetricKeyAlgorithmProvider { get; }
    public static ISymmetricKeyAlgorithmProviderFactory SymmetricKeyAlgorithmProvider { get; }
    public static IHashAlgorithmProviderFactory HashAlgorithmProvider { get; }
    public static IMacAlgorithmProviderFactory MacAlgorithmProvider { get; }
    public static IKeyDerivationAlgorithmProviderFactory KeyDerivationAlgorithmProvider { get; }
    public static IKeyDerivationParametersFactory KeyDerivationParameters { get; }
    public static ICryptographicEngine CryptographicEngine { get; }
    public static ICryptographicBuffer CryptographicBuffer { get; }
    public static IAsymmetricKeyAlgorithmProviderFactory get_AsymmetricKeyAlgorithmProvider();
    public static ISymmetricKeyAlgorithmProviderFactory get_SymmetricKeyAlgorithmProvider();
    public static IHashAlgorithmProviderFactory get_HashAlgorithmProvider();
    public static IMacAlgorithmProviderFactory get_MacAlgorithmProvider();
    public static IKeyDerivationAlgorithmProviderFactory get_KeyDerivationAlgorithmProvider();
    public static IKeyDerivationParametersFactory get_KeyDerivationParameters();
    public static ICryptographicEngine get_CryptographicEngine();
    public static ICryptographicBuffer get_CryptographicBuffer();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class PCLCrypto.WinRTExtensions : object {
    [ExtensionAttribute]
public static ICryptographicKey ImportParameters(IAsymmetricKeyAlgorithmProvider provider, RSAParameters parameters);
    [ExtensionAttribute]
public static RSAParameters ExportParameters(ICryptographicKey key, bool includePrivateParameters);
    [ExtensionAttribute]
public static ISymmetricKeyAlgorithmProvider OpenAlgorithm(ISymmetricKeyAlgorithmProviderFactory factory, SymmetricAlgorithm algorithm);
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.2.31.56335")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyVersion;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyConfiguration;
    internal static string GitCommitId;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static bool IsPublicRelease;
    internal static bool IsPrerelease;
    internal static DateTime GitCommitDate;
    internal static string RootNamespace;
    private static ThisAssembly();
}
