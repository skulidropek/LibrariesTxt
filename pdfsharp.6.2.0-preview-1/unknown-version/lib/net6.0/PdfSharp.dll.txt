[CompilerGeneratedAttribute]
[ExcludeFromCodeCoverageAttribute]
internal static class GitVersionInformation : object {
    public static string Major;
    public static string Minor;
    public static string Patch;
    public static string PreReleaseTag;
    public static string PreReleaseTagWithDash;
    public static string PreReleaseLabel;
    public static string PreReleaseLabelWithDash;
    public static string PreReleaseNumber;
    public static string WeightedPreReleaseNumber;
    public static string BuildMetaData;
    public static string BuildMetaDataPadded;
    public static string FullBuildMetaData;
    public static string MajorMinorPatch;
    public static string SemVer;
    public static string LegacySemVer;
    public static string LegacySemVerPadded;
    public static string AssemblySemVer;
    public static string AssemblySemFileVer;
    public static string FullSemVer;
    public static string InformationalVersion;
    public static string BranchName;
    public static string EscapedBranchName;
    public static string Sha;
    public static string ShortSha;
    public static string NuGetVersionV2;
    public static string NuGetVersion;
    public static string NuGetPreReleaseTagV2;
    public static string NuGetPreReleaseTag;
    public static string VersionSourceSha;
    public static string CommitsSinceVersionSource;
    public static string CommitsSinceVersionSourcePadded;
    public static string UncommittedChanges;
    public static string CommitDate;
    private static GitVersionInformation();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal static class PdfSharp.BigGustave.Adam7 : object {
    [NullableAttribute("1")]
private static IReadOnlyDictionary`2<int, Int32[]> PassToScanlineGridIndex;
    [NullableAttribute("1")]
private static IReadOnlyDictionary`2<int, Int32[]> PassToScanlineColumnIndex;
    private static Adam7();
    public static int GetNumberOfScanlinesInPass(ImageHeader header, int pass);
    public static int GetPixelsPerScanlineInPass(ImageHeader header, int pass);
    public static ValueTuple`2<int, int> GetPixelIndexForScanlineInPass(ImageHeader header, int pass, int scanlineIndex, int indexInScanline);
}
public static class PdfSharp.BigGustave.Adler32Checksum : object {
    private static int AdlerModulus;
    [NullableContextAttribute("1")]
public static int Calculate(IEnumerable`1<byte> data, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class PdfSharp.BigGustave.ChunkHeader : ValueType {
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public long Position { get; }
    public int Length { get; }
    public string Name { get; }
    public bool IsCritical { get; }
    public bool IsPublic { get; }
    public bool IsSafeToCopy { get; }
    public ChunkHeader(long position, int length, string name);
    [CompilerGeneratedAttribute]
public long get_Position();
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
public string get_Name();
    public bool get_IsCritical();
    public bool get_IsPublic();
    public bool get_IsSafeToCopy();
    public virtual string ToString();
}
[FlagsAttribute]
public enum PdfSharp.BigGustave.ColorType : Enum {
    public byte value__;
    public static ColorType None;
    public static ColorType PaletteUsed;
    public static ColorType ColorUsed;
    public static ColorType AlphaChannelUsed;
}
public enum PdfSharp.BigGustave.CompressionMethod : Enum {
    public byte value__;
    public static CompressionMethod DeflateWithSlidingWindow;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class PdfSharp.BigGustave.Crc32 : object {
    private static UInt32 Polynomial;
    private static UInt32[] Lookup;
    private static Crc32();
    public static UInt32 Calculate(Byte[] data);
    public static UInt32 Calculate(List`1<byte> data);
    public static UInt32 Calculate(Byte[] data, Byte[] data2);
}
internal static class PdfSharp.BigGustave.Decoder : object {
    public static ValueTuple`2<byte, byte> GetBytesAndSamplesPerPixel(ImageHeader header);
    [NullableContextAttribute("1")]
public static Byte[] Decode(Byte[] decompressedData, ImageHeader header, byte bytesPerPixel, byte samplesPerPixel);
    private static byte SamplesPerPixel(ImageHeader header);
    private static int BytesPerScanline(ImageHeader header, byte samplesPerPixel);
    [NullableContextAttribute("1")]
private static void ReverseFilter(Byte[] data, FilterType type, int previousRowStartByteAbsolute, int rowStartByteAbsolute, int byteAbsolute, int rowByteIndex, int bytesPerPixel);
    private static byte GetPaethValue(byte a, byte b, byte c);
    [CompilerGeneratedAttribute]
internal static byte <ReverseFilter>g__GetLeftByteValue|4_0(<>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static byte <ReverseFilter>g__GetAboveByteValue|4_1(<>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static byte <ReverseFilter>g__GetAboveLeftByteValue|4_2(<>c__DisplayClass4_0& );
}
public enum PdfSharp.BigGustave.FilterMethod : Enum {
    public int value__;
    public static FilterMethod AdaptiveFiltering;
}
internal enum PdfSharp.BigGustave.FilterType : Enum {
    public int value__;
    public static FilterType None;
    public static FilterType Sub;
    public static FilterType Up;
    public static FilterType Average;
    public static FilterType Paeth;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class PdfSharp.BigGustave.HeaderValidationResult : ValueType {
    public static Byte[] ExpectedHeader;
    [CompilerGeneratedAttribute]
private int <Byte1>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Byte2>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Byte3>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Byte4>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Byte5>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Byte6>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Byte7>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Byte8>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    public int Byte1 { get; }
    public int Byte2 { get; }
    public int Byte3 { get; }
    public int Byte4 { get; }
    public int Byte5 { get; }
    public int Byte6 { get; }
    public int Byte7 { get; }
    public int Byte8 { get; }
    public bool IsValid { get; }
    public HeaderValidationResult(int byte1, int byte2, int byte3, int byte4, int byte5, int byte6, int byte7, int byte8);
    private static HeaderValidationResult();
    [CompilerGeneratedAttribute]
public int get_Byte1();
    [CompilerGeneratedAttribute]
public int get_Byte2();
    [CompilerGeneratedAttribute]
public int get_Byte3();
    [CompilerGeneratedAttribute]
public int get_Byte4();
    [CompilerGeneratedAttribute]
public int get_Byte5();
    [CompilerGeneratedAttribute]
public int get_Byte6();
    [CompilerGeneratedAttribute]
public int get_Byte7();
    [CompilerGeneratedAttribute]
public int get_Byte8();
    [CompilerGeneratedAttribute]
public bool get_IsValid();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
public interface PdfSharp.BigGustave.IChunkVisitor {
    public abstract virtual void Visit(Stream stream, ImageHeader header, ChunkHeader chunkHeader, Byte[] data, Byte[] crc);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class PdfSharp.BigGustave.ImageHeader : ValueType {
    internal static Byte[] HeaderBytes;
    private static IReadOnlyDictionary`2<ColorType, HashSet`1<byte>> PermittedBitDepths;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <BitDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private ColorType <ColorType>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionMethod <CompressionMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private FilterMethod <FilterMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private InterlaceMethod <InterlaceMethod>k__BackingField;
    public int Width { get; }
    public int Height { get; }
    public byte BitDepth { get; }
    public ColorType ColorType { get; }
    public CompressionMethod CompressionMethod { get; }
    public FilterMethod FilterMethod { get; }
    public InterlaceMethod InterlaceMethod { get; }
    public ImageHeader(int width, int height, byte bitDepth, ColorType colorType, CompressionMethod compressionMethod, FilterMethod filterMethod, InterlaceMethod interlaceMethod);
    private static ImageHeader();
    [CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public byte get_BitDepth();
    [CompilerGeneratedAttribute]
public ColorType get_ColorType();
    [CompilerGeneratedAttribute]
public CompressionMethod get_CompressionMethod();
    [CompilerGeneratedAttribute]
public FilterMethod get_FilterMethod();
    [CompilerGeneratedAttribute]
public InterlaceMethod get_InterlaceMethod();
    public virtual string ToString();
}
public enum PdfSharp.BigGustave.InterlaceMethod : Enum {
    public byte value__;
    public static InterlaceMethod None;
    public static InterlaceMethod Adam7;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.BigGustave.Palette : object {
    [CompilerGeneratedAttribute]
private bool <HasAlphaValues>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    public bool HasAlphaValues { get; private set; }
    public Byte[] Data { get; }
    public Palette(Byte[] data);
    [CompilerGeneratedAttribute]
public bool get_HasAlphaValues();
    [CompilerGeneratedAttribute]
private void set_HasAlphaValues(bool value);
    [CompilerGeneratedAttribute]
public Byte[] get_Data();
    public void SetAlphaValues(Byte[] bytes);
    public Pixel GetPixel(int index);
}
[IsReadOnlyAttribute]
public class PdfSharp.BigGustave.Pixel : ValueType {
    [CompilerGeneratedAttribute]
private byte <R>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <G>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <B>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <A>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGrayscale>k__BackingField;
    public byte R { get; }
    public byte G { get; }
    public byte B { get; }
    public byte A { get; }
    public bool IsGrayscale { get; }
    public Pixel(byte r, byte g, byte b, byte a, bool isGrayscale);
    public Pixel(byte r, byte g, byte b);
    public Pixel(byte grayscale);
    [CompilerGeneratedAttribute]
public byte get_R();
    [CompilerGeneratedAttribute]
public byte get_G();
    [CompilerGeneratedAttribute]
public byte get_B();
    [CompilerGeneratedAttribute]
public byte get_A();
    [CompilerGeneratedAttribute]
public bool get_IsGrayscale();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public bool Equals(Pixel other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.BigGustave.Png : object {
    private RawPngData data;
    private bool hasTransparencyChunk;
    [CompilerGeneratedAttribute]
private ImageHeader <Header>k__BackingField;
    public ImageHeader Header { get; }
    public int Width { get; }
    public int Height { get; }
    public bool HasAlphaChannel { get; }
    internal Png(ImageHeader header, RawPngData data, bool hasTransparencyChunk);
    [CompilerGeneratedAttribute]
public ImageHeader get_Header();
    public int get_Width();
    public int get_Height();
    public bool get_HasAlphaChannel();
    public int GetPixelIndex(int x, int y);
    [NullableContextAttribute("2")]
public Palette GetPalette();
    public Pixel GetPixel(int x, int y);
    public static Png Open(Stream stream, IChunkVisitor chunkVisitor);
    public static Png Open(Stream stream, PngOpenerSettings settings);
    public static Png Open(Byte[] bytes, IChunkVisitor chunkVisitor);
    public static Png Open(Byte[] bytes, PngOpenerSettings settings);
    public static Png Open(string filePath, IChunkVisitor chunkVisitor);
    public static Png Open(string filePath, PngOpenerSettings settings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.BigGustave.PngBuilder : object {
    private static byte Deflate32KbWindow;
    private static byte ChecksumBits;
    private Byte[] rawData;
    private bool hasAlphaChannel;
    private int width;
    private int height;
    private int bytesPerPixel;
    private bool hasTooManyColorsForPalette;
    private int backgroundColorInt;
    private Dictionary`2<int, int> colorCounts;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<string, Byte[]>> storedStrings;
    private PngBuilder(Byte[] rawData, bool hasAlphaChannel, int width, int height, int bytesPerPixel);
    public static PngBuilder Create(int width, int height, bool hasAlphaChannel);
    public static PngBuilder FromPng(Png png);
    public static PngBuilder FromPngBytes(Byte[] png);
    public static PngBuilder FromBgra32Pixels(Byte[] data, int width, int height, bool useAlphaChannel);
    public static PngBuilder FromBgra32Pixels(Stream data, int width, int height, bool useAlphaChannel);
    public PngBuilder SetPixel(byte r, byte g, byte b, int x, int y);
    public PngBuilder SetPixel(Pixel pixel, int x, int y);
    public PngBuilder StoreText(string keyword, string text);
    public Byte[] Save(SaveOptions options);
    public void Save(Stream outputStream, SaveOptions options);
    private static Byte[] Compress(Byte[] data, int dataLength, SaveOptions options);
    private void AttemptCompressionOfRawData(Byte[] rawData, SaveOptions options);
    private static int PixelToColorInt(Pixel p);
    private static int PixelToColorInt(byte r, byte g, byte b, byte a);
    [NullableContextAttribute("0")]
private static ValueTuple`4<byte, byte, byte, byte> ColorIntToPixel(int i);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class PdfSharp.BigGustave.PngOpener : object {
    public static Png Open(Stream stream, IChunkVisitor chunkVisitor);
    public static Png Open(Stream stream, PngOpenerSettings settings);
    private static HeaderValidationResult HasValidHeader(Stream stream);
    private static bool TryReadChunkHeader(Stream stream, ChunkHeader& chunkHeader);
    private static ImageHeader ReadImageHeader(Stream stream, Byte[] crc);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class PdfSharp.BigGustave.PngOpenerSettings : object {
    [CompilerGeneratedAttribute]
private IChunkVisitor <ChunkVisitor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisallowTrailingData>k__BackingField;
    public IChunkVisitor ChunkVisitor { get; public set; }
    public bool DisallowTrailingData { get; public set; }
    [CompilerGeneratedAttribute]
public IChunkVisitor get_ChunkVisitor();
    [CompilerGeneratedAttribute]
public void set_ChunkVisitor(IChunkVisitor value);
    [CompilerGeneratedAttribute]
public bool get_DisallowTrailingData();
    [CompilerGeneratedAttribute]
public void set_DisallowTrailingData(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.BigGustave.PngStreamWriteHelper : Stream {
    private Stream inner;
    private List`1<byte> written;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public PngStreamWriteHelper(Stream inner);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public void WriteChunkHeader(Byte[] header);
    public void WriteChunkLength(int length);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public void WriteCrc();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.BigGustave.RawPngData : object {
    private Byte[] data;
    private int bytesPerPixel;
    private int width;
    [NullableAttribute("2")]
private Palette palette;
    private ColorType colorType;
    private int rowOffset;
    private int bitDepth;
    public RawPngData(Byte[] data, int bytesPerPixel, Palette palette, ImageHeader imageHeader);
    public int GetPixelIndex(int x, int y);
    public Pixel GetPixel(int x, int y);
    private static byte ToSingleByte(byte first, byte second);
    [NullableContextAttribute("2")]
public Palette GetPalette();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class PdfSharp.BigGustave.StreamHelper : object {
    public static int ReadBigEndianInt32(Stream stream);
    public static int ReadBigEndianInt32(Byte[] bytes, int offset);
    public static void WriteBigEndianInt32(Stream stream, int value);
    private static byte ReadOrTerminate(Stream stream);
    public static bool TryReadHeaderBytes(Stream stream, Byte[]& bytes);
}
public static class PdfSharp.Capabilities : object {
    private static Capabilities();
    public static void ResetAll();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class PdfSharp.Config : object {
    public static string SignificantDecimalPlaces2;
    public static string SignificantDecimalPlaces3;
    public static string SignificantDecimalPlaces4;
    public static string SignificantDecimalPlaces7;
    public static string SignificantDecimalPlaces10;
    public static string SignificantDecimalPlaces1Plus9;
}
internal static class PdfSharp.Const : object {
    public static double Deg2Rad;
    public static double ItalicSkewAngleSinus;
    public static double BoldEmphasis;
    public static double κ;
}
public static class PdfSharp.Diagnostics.PdfSharpCore : object {
    public static void ResetAll();
    public static void ResetFontManagement();
}
public enum PdfSharp.Drawing.BarCodes.AnchorType : Enum {
    public int value__;
    public static AnchorType TopLeft;
    public static AnchorType TopCenter;
    public static AnchorType TopRight;
    public static AnchorType MiddleLeft;
    public static AnchorType MiddleCenter;
    public static AnchorType MiddleRight;
    public static AnchorType BottomLeft;
    public static AnchorType BottomCenter;
    public static AnchorType BottomRight;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class PdfSharp.Drawing.BarCodes.BarCode : CodeBase {
    private TextLocation _textLocation;
    private int _dataLength;
    private char _startChar;
    private char _endChar;
    private bool _turboBit;
    public double WideNarrowRatio { get; public set; }
    public TextLocation TextLocation { get; public set; }
    public int DataLength { get; public set; }
    public char StartChar { get; public set; }
    public char EndChar { get; public set; }
    public bool TurboBit { get; public set; }
    protected BarCode(string text, XSize size, CodeDirection direction);
    public static BarCode FromType(CodeType type, string text, XSize size, CodeDirection direction);
    public static BarCode FromType(CodeType type, string text, XSize size);
    public static BarCode FromType(CodeType type, string text);
    public static BarCode FromType(CodeType type);
    public virtual double get_WideNarrowRatio();
    public virtual void set_WideNarrowRatio(double value);
    public TextLocation get_TextLocation();
    public void set_TextLocation(TextLocation value);
    public int get_DataLength();
    public void set_DataLength(int value);
    public char get_StartChar();
    public void set_StartChar(char value);
    public char get_EndChar();
    public void set_EndChar(char value);
    public virtual bool get_TurboBit();
    public virtual void set_TurboBit(bool value);
    internal virtual void InitRendering(BarCodeRenderInfo info);
    protected internal abstract virtual void Render(XGraphics gfx, XBrush brush, XFont font, XPoint position);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Drawing.BarCodes.BarCodeRenderInfo : object {
    public XGraphics Gfx;
    public XBrush Brush;
    [NullableAttribute("2")]
public XFont Font;
    public XPoint Position;
    public double BarHeight;
    public XPoint CurrPos;
    public int CurrPosInString;
    public double ThinBarWidth;
    public BarCodeRenderInfo(XGraphics gfx, XBrush brush, XFont font, XPoint position);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Drawing.BarCodes.BcgSR : object {
    internal static string BarCodeNotSet { get; }
    internal static string EmptyBarCodeSize { get; }
    internal static string Invalid2of5Relation { get; }
    internal static string OmrAlreadyInitialized { get; }
    internal static string DataMatrixTooBig { get; }
    internal static string DataMatrixNotSupported { get; }
    internal static string DataMatrixNull { get; }
    internal static string Invalid2Of5Code(string code);
    internal static string Invalid3Of9Code(string code);
    internal static string get_BarCodeNotSet();
    internal static string get_EmptyBarCodeSize();
    internal static string get_Invalid2of5Relation();
    internal static string InvalidMarkName(string name);
    internal static string get_OmrAlreadyInitialized();
    internal static string get_DataMatrixTooBig();
    internal static string get_DataMatrixNotSupported();
    internal static string get_DataMatrixNull();
    internal static string DataMatrixInvalid(int columns, int rows);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Drawing.BarCodes.Code2of5Interleaved : ThickThinBarCode {
    private static Boolean[][] Lines;
    public Code2of5Interleaved(string code);
    public Code2of5Interleaved(string code, XSize size);
    public Code2of5Interleaved(string code, XSize size, CodeDirection direction);
    private static Code2of5Interleaved();
    private static Boolean[] ThickAndThinLines(int digit);
    protected internal virtual void Render(XGraphics gfx, XBrush brush, XFont font, XPoint position);
    internal virtual void CalcThinBarWidth(BarCodeRenderInfo info);
    private void RenderStart(BarCodeRenderInfo info);
    private void RenderStop(BarCodeRenderInfo info);
    private void RenderNextPair(BarCodeRenderInfo info);
    protected virtual void CheckCode(string text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Drawing.BarCodes.Code3of9Standard : ThickThinBarCode {
    private static Boolean[][] Lines;
    public Code3of9Standard(string code);
    public Code3of9Standard(string code, XSize size);
    public Code3of9Standard(string code, XSize size, CodeDirection direction);
    private static Code3of9Standard();
    private static Boolean[] ThickThinLines(char ch);
    internal virtual void CalcThinBarWidth(BarCodeRenderInfo info);
    protected virtual void CheckCode(string text);
    protected internal virtual void Render(XGraphics gfx, XBrush brush, XFont font, XPoint position);
    private void RenderNextChar(BarCodeRenderInfo info);
    private void RenderChar(BarCodeRenderInfo info, char ch);
    private void RenderStart(BarCodeRenderInfo info);
    private void RenderStop(BarCodeRenderInfo info);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class PdfSharp.Drawing.BarCodes.CodeBase : object {
    [CompilerGeneratedAttribute]
private XSize <Size>k__BackingField;
    private string _text;
    private AnchorType _anchor;
    private CodeDirection _direction;
    private static Delta[0...,0...] Deltas;
    public XSize Size { get; public set; }
    public string Text { get; public set; }
    public AnchorType Anchor { get; public set; }
    public CodeDirection Direction { get; public set; }
    protected CodeBase(string text, XSize size, CodeDirection direction);
    private static CodeBase();
    [CompilerGeneratedAttribute]
public XSize get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(XSize value);
    public string get_Text();
    public void set_Text(string value);
    public AnchorType get_Anchor();
    public void set_Anchor(AnchorType value);
    public CodeDirection get_Direction();
    public void set_Direction(CodeDirection value);
    protected abstract virtual void CheckCode(string text);
    public static XVector CalcDistance(AnchorType oldType, AnchorType newType, XSize size);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Drawing.BarCodes.CodeDataMatrix : MatrixCode {
    private int _quietZone;
    public int QuietZone { get; public set; }
    public CodeDataMatrix(string code, int length);
    public CodeDataMatrix(string code, int length, XSize size);
    public CodeDataMatrix(string code, DataMatrixEncoding dmEncoding, int length, XSize size);
    public CodeDataMatrix(string code, int rows, int columns);
    public CodeDataMatrix(string code, int rows, int columns, XSize size);
    public CodeDataMatrix(string code, DataMatrixEncoding dmEncoding, int rows, int columns, XSize size);
    public CodeDataMatrix(string code, int rows, int columns, int quietZone);
    public CodeDataMatrix(string code, string encoding, int rows, int columns, int quietZone, XSize size);
    public void SetEncoding(DataMatrixEncoding dmEncoding);
    private static string CreateEncoding(DataMatrixEncoding dmEncoding, int length);
    public int get_QuietZone();
    public void set_QuietZone(int value);
    protected internal virtual void Render(XGraphics gfx, XBrush brush, XPoint position);
    protected virtual void CheckCode(string text);
}
public enum PdfSharp.Drawing.BarCodes.CodeDirection : Enum {
    public int value__;
    public static CodeDirection LeftToRight;
    public static CodeDirection BottomToTop;
    public static CodeDirection RightToLeft;
    public static CodeDirection TopToBottom;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Drawing.BarCodes.CodeOmr : BarCode {
    private bool _synchronizeCode;
    private double _makerDistance;
    private double _makerThickness;
    public bool SynchronizeCode { get; public set; }
    public double MakerDistance { get; public set; }
    public double MakerThickness { get; public set; }
    public CodeOmr(string text, XSize size, CodeDirection direction);
    protected internal virtual void Render(XGraphics gfx, XBrush brush, XFont font, XPoint position);
    public bool get_SynchronizeCode();
    public void set_SynchronizeCode(bool value);
    public double get_MakerDistance();
    public void set_MakerDistance(double value);
    public double get_MakerThickness();
    public void set_MakerThickness(double value);
    protected virtual void CheckCode(string text);
}
public enum PdfSharp.Drawing.BarCodes.CodeType : Enum {
    public int value__;
    public static CodeType Code2of5Interleaved;
    public static CodeType Code3of9Standard;
    public static CodeType Omr;
    public static CodeType DataMatrix;
}
public enum PdfSharp.Drawing.BarCodes.DataMatrixEncoding : Enum {
    public int value__;
    public static DataMatrixEncoding Ascii;
    public static DataMatrixEncoding C40;
    public static DataMatrixEncoding Text;
    public static DataMatrixEncoding X12;
    public static DataMatrixEncoding EDIFACT;
    public static DataMatrixEncoding Base256;
}
internal class PdfSharp.Drawing.BarCodes.DataMatrixImage : object {
    private string _encoding;
    private string _text;
    private int _rows;
    private int _columns;
    private XBrush _brush;
    private static Ecc200Block[] ecc200Sizes;
    private static int gfpoly;
    private static int symsize;
    private static int logmod;
    private static int rlen;
    private static Int32[] log;
    private static Int32[] alog;
    private static Int32[] rspoly;
    public DataMatrixImage(string text, string encoding, int rows, int columns, XBrush brush);
    private static DataMatrixImage();
    public static XImage GenerateMatrixImage(string text, string encoding, int rows, int columns, XBrush brush);
    public XImage DrawMatrix();
    internal Char[] DataMatrix();
    internal Char[] Iec16022Ecc200(int columns, int rows, string encoding, int barcodeLength, string barcode, int len, int max, int ecc);
    internal bool Ecc200Encode(Char[]& t, int targetLength, string s, int sourceLength, string encoding, Int32& len);
    private int State255(int value, int position);
    private void Ecc200Placement(Int32[]& array, int NR, int NC);
    private void Ecc200PlacementBit(Int32[]& array, int NR, int NC, int r, int c, int p, int b);
    private void Ecc200PlacementBlock(Int32[]& array, int NR, int NC, int r, int c, int p);
    private void Ecc200PlacementCornerA(Int32[]& array, int NR, int NC, int p);
    private void Ecc200PlacementCornerB(Int32[]& array, int NR, int NC, int p);
    private void Ecc200PlacementCornerC(Int32[]& array, int NR, int NC, int p);
    private void Ecc200PlacementCornerD(Int32[]& array, int NR, int NC, int p);
    private void Ecc200(Char[] binary, int bytes, int datablock, int rsblock);
    public static void InitGalois(int poly);
    public static void InitReedSolomon(int nsym, int index);
    public void EncodeReedSolomon(int length, Int32[] data, Int32[]& result);
    public XImage CreateImage(Char[] code, int size);
    public XImage CreateImage(Char[] code, int rows, int columns);
    public XImage CreateImage(Char[] code, int rows, int columns, int pixelSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class PdfSharp.Drawing.BarCodes.MatrixCode : CodeBase {
    private string _encoding;
    private int _columns;
    private int _rows;
    [NullableAttribute("2")]
private XImage _matrixImage;
    public string Encoding { get; public set; }
    public int Columns { get; public set; }
    public int Rows { get; public set; }
    public string Text { get; public set; }
    internal XImage MatrixImage { get; internal set; }
    internal bool HasMatrixImage { get; }
    public MatrixCode(string text, string encoding, int rows, int columns, XSize size);
    public string get_Encoding();
    public void set_Encoding(string value);
    public int get_Columns();
    public void set_Columns(int value);
    public int get_Rows();
    public void set_Rows(int value);
    public string get_Text();
    public void set_Text(string value);
    internal XImage get_MatrixImage();
    internal void set_MatrixImage(XImage value);
    internal bool get_HasMatrixImage();
    protected internal abstract virtual void Render(XGraphics gfx, XBrush brush, XPoint center);
    protected virtual void CheckCode(string text);
}
public enum PdfSharp.Drawing.BarCodes.TextLocation : Enum {
    public int value__;
    public static TextLocation None;
    public static TextLocation Above;
    public static TextLocation Below;
    public static TextLocation AboveEmbedded;
    public static TextLocation BelowEmbedded;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class PdfSharp.Drawing.BarCodes.ThickThinBarCode : BarCode {
    private double _wideNarrowRatio;
    public double WideNarrowRatio { get; public set; }
    protected ThickThinBarCode(string code, XSize size, CodeDirection direction);
    internal virtual void InitRendering(BarCodeRenderInfo info);
    public virtual double get_WideNarrowRatio();
    public virtual void set_WideNarrowRatio(double value);
    internal void RenderBar(BarCodeRenderInfo info, bool isThick);
    internal void RenderGap(BarCodeRenderInfo info, bool isThick);
    internal void RenderTurboBit(BarCodeRenderInfo info, bool startBit);
    internal void RenderText(BarCodeRenderInfo info);
    internal double GetBarWidth(BarCodeRenderInfo info, bool isThick);
    internal abstract virtual void CalcThinBarWidth(BarCodeRenderInfo info);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Drawing.CoreGraphicsPath : object {
    private static byte PathPointTypeStart;
    private static byte PathPointTypeLine;
    private static byte PathPointTypeBézier;
    private static byte PathPointTypePathTypeMask;
    private static byte PathPointTypeCloseSubpath;
    private XFillMode _fillMode;
    private List`1<XPoint> _points;
    private List`1<byte> _types;
    private XFillMode FillMode { get; private set; }
    public XPoint[] PathPoints { get; }
    public Byte[] PathTypes { get; }
    public CoreGraphicsPath(CoreGraphicsPath path);
    public void MoveOrLineTo(double x, double y);
    public void MoveTo(double x, double y);
    public void LineTo(double x, double y, bool closeSubpath);
    public void BezierTo(double x1, double y1, double x2, double y2, double x3, double y3, bool closeSubpath);
    public void QuadrantArcTo(double x, double y, double width, double height, int quadrant, bool clockwise);
    public void CloseSubpath();
    private XFillMode get_FillMode();
    private void set_FillMode(XFillMode value);
    public void AddArc(double x, double y, double width, double height, double startAngle, double sweepAngle);
    public void AddArc(XPoint point1, XPoint point2, XSize size, double rotationAngle, bool isLargeArg, XSweepDirection sweepDirection);
    public void AddCurve(XPoint[] points, double tension);
    private void ToCurveSegment(XPoint pt0, XPoint pt1, XPoint pt2, XPoint pt3, double tension3);
    public XPoint[] get_PathPoints();
    public Byte[] get_PathTypes();
}
internal enum PdfSharp.Drawing.FontWeightValue : Enum {
    public int value__;
    public static FontWeightValue Thin;
    public static FontWeightValue UltraLight;
    public static FontWeightValue ExtraLight;
    public static FontWeightValue Light;
    public static FontWeightValue SemiLight;
    public static FontWeightValue Normal;
    public static FontWeightValue Medium;
    public static FontWeightValue SemiBold;
    public static FontWeightValue Bold;
    public static FontWeightValue ExtraBold;
    public static FontWeightValue Black;
    public static FontWeightValue ExtraBlack;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class PdfSharp.Drawing.GeometryHelper : object {
    public static List`1<XPoint> BezierCurveFromArc(double x, double y, double width, double height, double startAngle, double sweepAngle, PathStart pathStart, XMatrix& matrix);
    private static int Quadrant(double φ, bool start, bool clockwise);
    private static void AppendPartialArcQuadrant(List`1<XPoint> points, double x, double y, double width, double height, double α, double β, PathStart pathStart, XMatrix matrix);
    public static List`1<XPoint> BezierCurveFromArc(XPoint point1, XPoint point2, XSize size, double rotationAngle, bool isLargeArc, bool clockwise, PathStart pathStart);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Drawing.GraphicsStateStack : object {
    private InternalGraphicsState _current;
    private Stack`1<InternalGraphicsState> _stack;
    public int Count { get; }
    public InternalGraphicsState Current { get; }
    public GraphicsStateStack(XGraphics gfx);
    public int get_Count();
    public void Push(InternalGraphicsState state);
    public int Restore(InternalGraphicsState state);
    public InternalGraphicsState get_Current();
}
[NullableContextAttribute("1")]
internal interface PdfSharp.Drawing.IImageImporter {
    public abstract virtual ImportedImage ImportImage(StreamReaderHelper stream);
    public abstract virtual ImageData PrepareImage(ImagePrivateData data);
}
internal abstract class PdfSharp.Drawing.ImageData : object {
}
internal static class PdfSharp.Drawing.ImageHelper : object {
}
internal class PdfSharp.Drawing.ImageInformation : object {
    internal ImageFormats ImageFormat;
    internal UInt32 Width;
    internal UInt32 Height;
    internal double HorizontalDPI;
    internal double VerticalDPI;
    internal double HorizontalDPM;
    internal double VerticalDPM;
    internal double HorizontalAspectRatio;
    internal double VerticalAspectRatio;
    internal UInt32 BitCount;
    internal UInt32 ColorsUsed;
    internal double DefaultDPI;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class PdfSharp.Drawing.ImagePrivateData : object {
    [NullableAttribute("2")]
private ImportedImage _image;
    public ImportedImage Image { get; internal set; }
    public ImportedImage get_Image();
    internal void set_Image(ImportedImage value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class PdfSharp.Drawing.ImportedImage : object {
    [CompilerGeneratedAttribute]
private ImageInformation <Information>k__BackingField;
    [NullableAttribute("2")]
internal ImagePrivateData Data;
    public ImageInformation Information { get; private set; }
    protected ImportedImage(IImageImporter importer, ImagePrivateData data);
    protected ImportedImage(IImageImporter importer);
    [CompilerGeneratedAttribute]
public ImageInformation get_Information();
    [CompilerGeneratedAttribute]
private void set_Information(ImageInformation value);
    public ImageData ImageData(PdfDocumentOptions options);
    internal virtual ImageData PrepareImageData(PdfDocumentOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Drawing.Internal.ImageDataBitmap : ImageData {
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Byte[] <DataFax>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LengthFax>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <AlphaMask>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AlphaMaskLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <BitmapMask>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BitmapMaskLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <PaletteData>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PaletteDataLength>k__BackingField;
    public bool SegmentedColorMask;
    public int IsBitonal;
    public int K;
    public bool IsGray;
    [NullableAttribute("2")]
internal PdfDocumentOptions Options;
    public Byte[] Data { get; internal set; }
    public int Length { get; internal set; }
    [NullableAttribute("2")]
public Byte[] DataFax { get; internal set; }
    public int LengthFax { get; internal set; }
    public Byte[] AlphaMask { get; internal set; }
    public int AlphaMaskLength { get; internal set; }
    public Byte[] BitmapMask { get; internal set; }
    public int BitmapMaskLength { get; internal set; }
    public Byte[] PaletteData { get; public set; }
    public int PaletteDataLength { get; public set; }
    internal ImageDataBitmap(PdfDocumentOptions options);
    internal ImageDataBitmap(Byte[] data, Byte[] mask);
    [CompilerGeneratedAttribute]
public Byte[] get_Data();
    [CompilerGeneratedAttribute]
internal void set_Data(Byte[] value);
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
internal void set_Length(int value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Byte[] get_DataFax();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_DataFax(Byte[] value);
    [CompilerGeneratedAttribute]
public int get_LengthFax();
    [CompilerGeneratedAttribute]
internal void set_LengthFax(int value);
    [CompilerGeneratedAttribute]
public Byte[] get_AlphaMask();
    [CompilerGeneratedAttribute]
internal void set_AlphaMask(Byte[] value);
    [CompilerGeneratedAttribute]
public int get_AlphaMaskLength();
    [CompilerGeneratedAttribute]
internal void set_AlphaMaskLength(int value);
    [CompilerGeneratedAttribute]
public Byte[] get_BitmapMask();
    [CompilerGeneratedAttribute]
internal void set_BitmapMask(Byte[] value);
    [CompilerGeneratedAttribute]
public int get_BitmapMaskLength();
    [CompilerGeneratedAttribute]
internal void set_BitmapMaskLength(int value);
    [CompilerGeneratedAttribute]
public Byte[] get_PaletteData();
    [CompilerGeneratedAttribute]
public void set_PaletteData(Byte[] value);
    [CompilerGeneratedAttribute]
public int get_PaletteDataLength();
    [CompilerGeneratedAttribute]
public void set_PaletteDataLength(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Drawing.Internal.ImageDataDct : ImageData {
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public Byte[] Data { get; internal set; }
    public int Length { get; internal set; }
    [CompilerGeneratedAttribute]
public Byte[] get_Data();
    [CompilerGeneratedAttribute]
internal void set_Data(Byte[] value);
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
internal void set_Length(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Drawing.Internal.ImageImporter : object {
    private List`1<IImageImporter> _importers;
    public static ImageImporter GetImageImporter();
    public ImportedImage ImportImage(Stream stream);
    public ImportedImage ImportImage(string filename);
    private ImportedImage TryImageImport(StreamReaderHelper helper);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Drawing.Internal.ImageImporterBmp : ImageImporterRoot {
    public sealed virtual ImportedImage ImportImage(StreamReaderHelper stream);
    private bool TestBitmapFileHeader(StreamReaderHelper stream, Int32& offset);
    private bool TestBitmapInfoHeader(StreamReaderHelper stream, ImportedImage ii, int offset);
    public sealed virtual ImageData PrepareImage(ImagePrivateData data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Drawing.Internal.ImageImporterJpeg : ImageImporterRoot {
    public sealed virtual ImportedImage ImportImage(StreamReaderHelper stream);
    private bool TestFileHeader(StreamReaderHelper stream);
    private bool TestJfifHeader(StreamReaderHelper stream, ImportedImage ii);
    private bool TestJfifHeaderWorker(StreamReaderHelper stream, ImportedImage ii);
    private bool TestExifHeaderWorker(StreamReaderHelper stream);
    private bool TestApp2HeaderWorker(StreamReaderHelper stream);
    private bool TestApp13HeaderWorker(StreamReaderHelper stream);
    private bool TestColorFormatHeader(StreamReaderHelper stream, ImportedImage ii);
    private bool TestInfoHeader(StreamReaderHelper stream, ImportedImage ii);
    private bool MoveToNextHeader(StreamReaderHelper stream);
    public sealed virtual ImageData PrepareImage(ImagePrivateData data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Drawing.Internal.ImageImporterPng : ImageImporterRoot {
    public sealed virtual ImportedImage ImportImage(StreamReaderHelper stream);
    private bool TestPngFileHeader(StreamReaderHelper stream);
    private bool TestPngInfoHeader(StreamReaderHelper stream, ImportedImage ii);
    public sealed virtual ImageData PrepareImage(ImagePrivateData data);
}
internal abstract class PdfSharp.Drawing.Internal.ImageImporterRoot : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Drawing.Internal.ImagePrivateDataBitmap : ImagePrivateData {
    private Byte[] _data;
    private int _length;
    internal bool FlippedImage;
    internal int Offset;
    internal int ColorPaletteOffset;
    public Byte[] Data { get; }
    public int Length { get; }
    public ImagePrivateDataBitmap(Byte[] data, int length);
    public Byte[] get_Data();
    public int get_Length();
    internal void CopyBitmap(ImageDataBitmap dest, PdfDocumentOptions options);
    private void CopyTrueColorMemoryBitmap(int components, int bits, bool hasAlpha, ImageDataBitmap dest);
    private void CopyIndexedMemoryBitmap(int bits, bool checkTransparency, ImageDataBitmap dest, PdfDocumentOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Drawing.Internal.ImagePrivateDataDct : ImagePrivateData {
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public Byte[] Data { get; }
    public int Length { get; }
    public ImagePrivateDataDct(Byte[] data, int length);
    [CompilerGeneratedAttribute]
public Byte[] get_Data();
    [CompilerGeneratedAttribute]
public int get_Length();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class PdfSharp.Drawing.Internal.ImagePrivateDataPng : ImagePrivateData {
    [NullableAttribute("1")]
internal Byte[] Bitmap;
    internal Byte[] AlphaMask;
    [CompilerGeneratedAttribute]
private Byte[] <PaletteData>k__BackingField;
    internal Byte[] PaletteData { get; internal set; }
    [NullableContextAttribute("1")]
public ImagePrivateDataPng(Byte[] bitmap, Byte[] alphaMask);
    [CompilerGeneratedAttribute]
internal Byte[] get_PaletteData();
    [CompilerGeneratedAttribute]
internal void set_PaletteData(Byte[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Drawing.Internal.ImportedImageBitmap : ImportedImage {
    public ImportedImageBitmap(IImageImporter importer, ImagePrivateDataBitmap data);
    internal virtual ImageData PrepareImageData(PdfDocumentOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Drawing.Internal.ImportedImageJpeg : ImportedImage {
    public ImportedImageJpeg(IImageImporter importer, ImagePrivateDataDct data);
    internal virtual ImageData PrepareImageData(PdfDocumentOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Drawing.Internal.ImportedImagePng : ImportedImage {
    public ImportedImagePng(IImageImporter importer);
    internal virtual ImageData PrepareImageData(PdfDocumentOptions options);
}
[FlagsAttribute]
internal enum PdfSharp.Drawing.InternalGraphicsMode : Enum {
    public int value__;
    public static InternalGraphicsMode DrawingGdiGraphics;
    public static InternalGraphicsMode DrawingPdfContent;
    public static InternalGraphicsMode DrawingBitmap;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Drawing.InternalGraphicsState : object {
    [CompilerGeneratedAttribute]
private XMatrix <Transform>k__BackingField;
    public bool Invalid;
    private XGraphics _gfx;
    internal XGraphicsState State;
    public XMatrix Transform { get; public set; }
    public InternalGraphicsState(XGraphics gfx);
    public InternalGraphicsState(XGraphics gfx, XGraphicsState state);
    public InternalGraphicsState(XGraphics gfx, XGraphicsContainer container);
    [CompilerGeneratedAttribute]
public XMatrix get_Transform();
    [CompilerGeneratedAttribute]
public void set_Transform(XMatrix value);
    public void Pushed();
    public void Popped();
}
[NullableContextAttribute("1")]
internal interface PdfSharp.Drawing.IXGraphicsRenderer {
    public abstract virtual void Close();
    public abstract virtual void DrawLine(XPen pen, double x1, double y1, double x2, double y2);
    public abstract virtual void DrawLines(XPen pen, XPoint[] points);
    public abstract virtual void DrawBezier(XPen pen, double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4);
    public abstract virtual void DrawBeziers(XPen pen, XPoint[] points);
    public abstract virtual void DrawCurve(XPen pen, XPoint[] points, double tension);
    public abstract virtual void DrawArc(XPen pen, double x, double y, double width, double height, double startAngle, double sweepAngle);
    [NullableContextAttribute("2")]
public abstract virtual void DrawRectangle(XPen pen, XBrush brush, double x, double y, double width, double height);
    [NullableContextAttribute("2")]
public abstract virtual void DrawRectangles(XPen pen, XBrush brush, XRect[] rects);
    [NullableContextAttribute("2")]
public abstract virtual void DrawRoundedRectangle(XPen pen, XBrush brush, double x, double y, double width, double height, double ellipseWidth, double ellipseHeight);
    [NullableContextAttribute("2")]
public abstract virtual void DrawEllipse(XPen pen, XBrush brush, double x, double y, double width, double height);
    [NullableContextAttribute("2")]
public abstract virtual void DrawPolygon(XPen pen, XBrush brush, XPoint[] points, XFillMode fillmode);
    [NullableContextAttribute("2")]
public abstract virtual void DrawPie(XPen pen, XBrush brush, double x, double y, double width, double height, double startAngle, double sweepAngle);
    [NullableContextAttribute("2")]
public abstract virtual void DrawClosedCurve(XPen pen, XBrush brush, XPoint[] points, double tension, XFillMode fillmode);
    [NullableContextAttribute("2")]
public abstract virtual void DrawPath(XPen pen, XBrush brush, XGraphicsPath path);
    public abstract virtual void DrawString(string s, XFont font, XBrush brush, XRect layoutRectangle, XStringFormat format);
    [ObsoleteAttribute("Not yet implemented.")]
public abstract virtual void DrawString(string s, XGlyphTypeface typeface, XBrush brush, XRect layoutRectangle, XStringFormat format);
    public abstract virtual void DrawImage(XImage image, double x, double y, double width, double height);
    public abstract virtual void DrawImage(XImage image, XRect destRect, XRect srcRect, XGraphicsUnit srcUnit);
    public abstract virtual void Save(XGraphicsState state);
    public abstract virtual void Restore(XGraphicsState state);
    public abstract virtual void BeginContainer(XGraphicsContainer container, XRect dstrect, XRect srcrect, XGraphicsUnit unit);
    public abstract virtual void EndContainer(XGraphicsContainer container);
    public abstract virtual void AddTransform(XMatrix transform, XMatrixOrder matrixOrder);
    public abstract virtual void SetClip(XGraphicsPath path, XCombineMode combineMode);
    public abstract virtual void ResetClip();
    public abstract virtual void WriteComment(string comment);
}
public enum PdfSharp.Drawing.Layout.XParagraphAlignment : Enum {
    public int value__;
    public static XParagraphAlignment Default;
    public static XParagraphAlignment Left;
    public static XParagraphAlignment Center;
    public static XParagraphAlignment Right;
    public static XParagraphAlignment Justify;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Drawing.Layout.XTextFormatter : object {
    private XGraphics _gfx;
    private string _text;
    private XFont _font;
    private double _lineSpace;
    private double _cyAscent;
    private double _cyDescent;
    private double _spaceWidth;
    private XRect _layoutRectangle;
    private XParagraphAlignment _alignment;
    private List`1<Block> _blocks;
    public string Text { get; public set; }
    public XFont Font { get; public set; }
    public XRect LayoutRectangle { get; public set; }
    public XParagraphAlignment Alignment { get; public set; }
    public XTextFormatter(XGraphics gfx);
    public string get_Text();
    public void set_Text(string value);
    public XFont get_Font();
    public void set_Font(XFont value);
    public XRect get_LayoutRectangle();
    public void set_LayoutRectangle(XRect value);
    public XParagraphAlignment get_Alignment();
    public void set_Alignment(XParagraphAlignment value);
    public void DrawString(string text, XFont font, XBrush brush, XRect layoutRectangle);
    public void DrawString(string text, XFont font, XBrush brush, XRect layoutRectangle, XStringFormat format);
    private void CreateBlocks();
    private void CreateLayout();
    private void AlignLine(int firstIndex, int lastIndex, double layoutWidth);
}
internal enum PdfSharp.Drawing.PathStart : Enum {
    public int value__;
    public static PathStart MoveTo1st;
    public static PathStart LineTo1st;
    public static PathStart Ignore1st;
}
[FlagsAttribute]
internal enum PdfSharp.Drawing.Pdf.DirtyFlags : Enum {
    public int value__;
    public static DirtyFlags Ctm;
    public static DirtyFlags ClipPath;
    public static DirtyFlags LineWidth;
    public static DirtyFlags LineJoin;
    public static DirtyFlags MiterLimit;
    public static DirtyFlags StrokeFill;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Drawing.Pdf.PdfGraphicsState : object {
    [CompilerGeneratedAttribute]
private XGraphicsPdfRenderer <renderer>P;
    internal int Level;
    internal InternalGraphicsState InternalState;
    private double _realizedLineWith;
    private int _realizedLineCap;
    private int _realizedLineJoin;
    private double _realizedMiterLimit;
    private XDashStyle _realizedDashStyle;
    private string _realizedDashPattern;
    private XColor _realizedStrokeColor;
    private bool _realizedStrokeOverPrint;
    private XColor _realizedFillColor;
    private bool _realizedNonStrokeOverPrint;
    [NullableAttribute("2")]
private PdfFont _realizedFont;
    private string _realizedFontName;
    private double _realizedFontSize;
    private int _realizedRenderingMode;
    private double _realizedCharSpace;
    [NullableAttribute("2")]
private static string s_formatTf;
    public XPoint RealizedTextPosition;
    public bool ItalicSimulationOn;
    public XMatrix RealizedCtm;
    public XMatrix UnrealizedCtm;
    public XMatrix EffectiveCtm;
    public XMatrix InverseEffectiveCtm;
    public XMatrix WorldTransform;
    [NullableAttribute("2")]
private static string s_formatCtm;
    [NullableAttribute("2")]
internal PdfFont RealizedFont { get; }
    public PdfGraphicsState(XGraphicsPdfRenderer renderer);
    public PdfGraphicsState Clone();
    private sealed virtual override object System.ICloneable.Clone();
    public void PushState();
    public void PopState();
    public void RealizePen(XPen pen, PdfColorMode colorMode);
    public void RealizeBrush(XBrush brush, PdfColorMode colorMode, int renderingMode, double fontEmSize);
    private void RealizeFillColor(XColor color, bool overPrint, PdfColorMode colorMode);
    internal void RealizeNonStrokeTransparency(double transparency, PdfColorMode colorMode);
    [NullableContextAttribute("2")]
internal PdfFont get_RealizedFont();
    public void RealizeFont(XGlyphTypeface glyphTypeface, double emSize, XBrush brush, int renderingMode, FontType fontType);
    public void AddTransform(XMatrix value, XMatrixOrder matrixOrder);
    public void RealizeCtm();
    public void SetAndRealizeClipRect(XRect clipRect);
    public void SetAndRealizeClipPath(XGraphicsPath clipPath);
    private void RealizeClipPath(XGraphicsPath clipPath);
}
internal enum PdfSharp.Drawing.Pdf.StreamMode : Enum {
    public int value__;
    public static StreamMode Graphic;
    public static StreamMode Text;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer : object {
    [NullableAttribute("2")]
private static string s_format1;
    [NullableAttribute("2")]
private static string s_format2;
    [NullableAttribute("2")]
private static string s_format3;
    [NullableAttribute("2")]
private static string s_format4;
    private int _clipLevel;
    private StreamMode _streamMode;
    internal PdfPage _page;
    internal XForm _form;
    internal PdfColorMode _colorMode;
    private XGraphicsPdfPageOptions _options;
    private XGraphics _gfx;
    internal StringBuilder _content;
    private static int GraphicsStackLevelInitial;
    private static int GraphicsStackLevelPageSpace;
    private static int GraphicsStackLevelWorldSpace;
    private PdfGraphicsState _gfxState;
    private Stack`1<PdfGraphicsState> _gfxStateStack;
    public double PageHeightPt;
    public XMatrix DefaultViewMatrix;
    public XGraphicsPdfPageOptions PageOptions { get; }
    public XMatrix Transform { get; }
    internal PdfDocument Owner { get; }
    internal XGraphics Gfx { get; }
    internal PdfResources Resources { get; }
    internal XSize Size { get; }
    public XGraphicsPdfRenderer(PdfPage page, XGraphics gfx, XGraphicsPdfPageOptions options);
    public XGraphicsPdfRenderer(XForm form, XGraphics gfx);
    private string GetContent();
    public XGraphicsPdfPageOptions get_PageOptions();
    public sealed virtual void Close();
    public sealed virtual void DrawLine(XPen pen, double x1, double y1, double x2, double y2);
    public sealed virtual void DrawLines(XPen pen, XPoint[] points);
    public sealed virtual void DrawBezier(XPen pen, double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4);
    public sealed virtual void DrawBeziers(XPen pen, XPoint[] points);
    public sealed virtual void DrawCurve(XPen pen, XPoint[] points, double tension);
    public sealed virtual void DrawArc(XPen pen, double x, double y, double width, double height, double startAngle, double sweepAngle);
    [NullableContextAttribute("2")]
public sealed virtual void DrawRectangle(XPen pen, XBrush brush, double x, double y, double width, double height);
    [NullableContextAttribute("2")]
public sealed virtual void DrawRectangles(XPen pen, XBrush brush, XRect[] rects);
    [NullableContextAttribute("2")]
public sealed virtual void DrawRoundedRectangle(XPen pen, XBrush brush, double x, double y, double width, double height, double ellipseWidth, double ellipseHeight);
    [NullableContextAttribute("2")]
public sealed virtual void DrawEllipse(XPen pen, XBrush brush, double x, double y, double width, double height);
    [NullableContextAttribute("2")]
public sealed virtual void DrawPolygon(XPen pen, XBrush brush, XPoint[] points, XFillMode fillmode);
    [NullableContextAttribute("2")]
public sealed virtual void DrawPie(XPen pen, XBrush brush, double x, double y, double width, double height, double startAngle, double sweepAngle);
    [NullableContextAttribute("2")]
public sealed virtual void DrawClosedCurve(XPen pen, XBrush brush, XPoint[] points, double tension, XFillMode fillmode);
    [NullableContextAttribute("2")]
public sealed virtual void DrawPath(XPen pen, XBrush brush, XGraphicsPath path);
    public sealed virtual void DrawString(string s, XFont font, XBrush brush, XRect rect, XStringFormat format);
    private void RenderText(string text, XFont font, XBrush brush, double x, double y, double width);
    public sealed virtual void DrawString(string s, XGlyphTypeface typeface, XBrush brush, XRect rect, XStringFormat format);
    public sealed virtual void DrawImage(XImage image, double x, double y, double width, double height);
    public sealed virtual void DrawImage(XImage image, XRect destRect, XRect srcRect, XGraphicsUnit srcUnit);
    public sealed virtual void Save(XGraphicsState state);
    public sealed virtual void Restore(XGraphicsState state);
    public sealed virtual void BeginContainer(XGraphicsContainer container, XRect dstrect, XRect srcrect, XGraphicsUnit unit);
    public sealed virtual void EndContainer(XGraphicsContainer container);
    public XMatrix get_Transform();
    public sealed virtual void AddTransform(XMatrix value, XMatrixOrder matrixOrder);
    public sealed virtual void SetClip(XGraphicsPath path, XCombineMode combineMode);
    public sealed virtual void ResetClip();
    public sealed virtual void WriteComment(string comment);
    private void AppendPartialArc(double x, double y, double width, double height, double startAngle, double sweepAngle, PathStart pathStart, XMatrix matrix);
    private int Quadrant(double φ, bool start, bool clockwise);
    private void AppendPartialArcQuadrant(double x, double y, double width, double height, double α, double β, PathStart pathStart, XMatrix matrix);
    private void AppendCurveSegment(XPoint pt0, XPoint pt1, XPoint pt2, XPoint pt3, double tension3);
    internal void AppendPath(CoreGraphicsPath path);
    private void AppendPath(XPoint[] points, Byte[] types);
    internal void Append(string value);
    internal void AppendFormatArgs(string format, Object[] args);
    internal void AppendFormatString(string format, string s);
    internal void AppendFormatFont(string format, string s, double d);
    internal void AppendFormatInt(string format, int n);
    internal void AppendFormatDouble(string format, double d);
    internal void AppendFormatPoint(string format, double x, double y);
    internal void AppendFormatRect(string format, double x, double y, double width, double height);
    internal void AppendFormat3Points(string format, double x1, double y1, double x2, double y2, double x3, double y3);
    internal void AppendFormat(string format, XPoint point);
    internal void AppendFormat(string format, double x, double y, string s);
    internal void AppendFormatImage(string format, double x, double y, double width, double height, string name);
    [NullableContextAttribute("2")]
private void AppendStrokeFill(XPen pen, XBrush brush, XFillMode fillMode, bool closePath);
    internal void BeginPage();
    private void EndPage();
    internal void BeginGraphicMode();
    internal void BeginTextMode();
    internal bool IsInTextMode();
    [NullableContextAttribute("2")]
private void Realize(XPen pen, XBrush brush);
    private void Realize(XPen pen);
    private void Realize(XBrush brush);
    private void Realize(XGlyphTypeface glyphTypeface, double emSize, XBrush brush, int renderingMode, FontType fontType);
    private void AdjustTdOffset(XPoint& pos, double dy, bool adjustSkew);
    private string Realize(XImage image);
    private void RealizeTransform();
    internal XPoint WorldToView(XPoint point);
    [ConditionalAttribute("DEBUG")]
private void DumpPathData(XPoint[] points, Byte[] types);
    internal PdfDocument get_Owner();
    internal XGraphics get_Gfx();
    internal PdfResources get_Resources();
    internal XSize get_Size();
    internal string GetFontName(XGlyphTypeface glyphTypeface, FontType fontType, PdfFont& pdfFont);
    internal string GetImageName(XImage image);
    internal string GetFormName(XForm form);
    private void SaveState();
    private void RestoreState();
    private PdfGraphicsState RestoreState(InternalGraphicsState state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Drawing.StreamReaderHelper : object {
    [CompilerGeneratedAttribute]
private Stream <OriginalStream>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private MemoryStream <OwnedMemoryStream>k__BackingField;
    public Stream OriginalStream { get; }
    internal int CurrentOffset { get; internal set; }
    public Byte[] Data { get; }
    public int Length { get; }
    [NullableAttribute("2")]
public MemoryStream OwnedMemoryStream { get; private set; }
    internal StreamReaderHelper(Byte[] data);
    internal StreamReaderHelper(Stream stream, int streamLength);
    internal byte GetByte(int offset);
    internal ushort GetWord(int offset, bool bigEndian);
    internal UInt32 GetDWord(int offset, bool bigEndian);
    public void Reset();
    [CompilerGeneratedAttribute]
public Stream get_OriginalStream();
    [CompilerGeneratedAttribute]
internal int get_CurrentOffset();
    [CompilerGeneratedAttribute]
internal void set_CurrentOffset(int value);
    [CompilerGeneratedAttribute]
public Byte[] get_Data();
    [CompilerGeneratedAttribute]
public int get_Length();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public MemoryStream get_OwnedMemoryStream();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_OwnedMemoryStream(MemoryStream value);
    public sealed virtual void Dispose();
}
public class PdfSharp.Drawing.XBitmapDecoder : object {
    [NullableContextAttribute("1")]
public static XBitmapDecoder GetPngDecoder();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class PdfSharp.Drawing.XBitmapEncoder : object {
    [CompilerGeneratedAttribute]
private XBitmapSource <Source>k__BackingField;
    public XBitmapSource Source { get; public set; }
    public static XBitmapEncoder GetPngEncoder();
    [CompilerGeneratedAttribute]
public XBitmapSource get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(XBitmapSource value);
    public abstract virtual void Save(Stream stream);
}
public class PdfSharp.Drawing.XBitmapImage : XBitmapSource {
    internal XBitmapImage(int width, int height);
    [NullableContextAttribute("1")]
public static XBitmapSource CreateBitmap(int width, int height);
}
public abstract class PdfSharp.Drawing.XBitmapSource : XImage {
    public int PixelWidth { get; }
    public int PixelHeight { get; }
    public virtual int get_PixelWidth();
    public virtual int get_PixelHeight();
}
public abstract class PdfSharp.Drawing.XBrush : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class PdfSharp.Drawing.XBrushes : object {
    public static XSolidBrush AliceBlue { get; }
    public static XSolidBrush AntiqueWhite { get; }
    public static XSolidBrush Aqua { get; }
    public static XSolidBrush Aquamarine { get; }
    public static XSolidBrush Azure { get; }
    public static XSolidBrush Beige { get; }
    public static XSolidBrush Bisque { get; }
    public static XSolidBrush Black { get; }
    public static XSolidBrush BlanchedAlmond { get; }
    public static XSolidBrush Blue { get; }
    public static XSolidBrush BlueViolet { get; }
    public static XSolidBrush Brown { get; }
    public static XSolidBrush BurlyWood { get; }
    public static XSolidBrush CadetBlue { get; }
    public static XSolidBrush Chartreuse { get; }
    public static XSolidBrush Chocolate { get; }
    public static XSolidBrush Coral { get; }
    public static XSolidBrush CornflowerBlue { get; }
    public static XSolidBrush Cornsilk { get; }
    public static XSolidBrush Crimson { get; }
    public static XSolidBrush Cyan { get; }
    public static XSolidBrush DarkBlue { get; }
    public static XSolidBrush DarkCyan { get; }
    public static XSolidBrush DarkGoldenrod { get; }
    public static XSolidBrush DarkGray { get; }
    public static XSolidBrush DarkGreen { get; }
    public static XSolidBrush DarkKhaki { get; }
    public static XSolidBrush DarkMagenta { get; }
    public static XSolidBrush DarkOliveGreen { get; }
    public static XSolidBrush DarkOrange { get; }
    public static XSolidBrush DarkOrchid { get; }
    public static XSolidBrush DarkRed { get; }
    public static XSolidBrush DarkSalmon { get; }
    public static XSolidBrush DarkSeaGreen { get; }
    public static XSolidBrush DarkSlateBlue { get; }
    public static XSolidBrush DarkSlateGray { get; }
    public static XSolidBrush DarkTurquoise { get; }
    public static XSolidBrush DarkViolet { get; }
    public static XSolidBrush DeepPink { get; }
    public static XSolidBrush DeepSkyBlue { get; }
    public static XSolidBrush DimGray { get; }
    public static XSolidBrush DodgerBlue { get; }
    public static XSolidBrush Firebrick { get; }
    public static XSolidBrush FloralWhite { get; }
    public static XSolidBrush ForestGreen { get; }
    public static XSolidBrush Fuchsia { get; }
    public static XSolidBrush Gainsboro { get; }
    public static XSolidBrush GhostWhite { get; }
    public static XSolidBrush Gold { get; }
    public static XSolidBrush Goldenrod { get; }
    public static XSolidBrush Gray { get; }
    public static XSolidBrush Green { get; }
    public static XSolidBrush GreenYellow { get; }
    public static XSolidBrush Honeydew { get; }
    public static XSolidBrush HotPink { get; }
    public static XSolidBrush IndianRed { get; }
    public static XSolidBrush Indigo { get; }
    public static XSolidBrush Ivory { get; }
    public static XSolidBrush Khaki { get; }
    public static XSolidBrush Lavender { get; }
    public static XSolidBrush LavenderBlush { get; }
    public static XSolidBrush LawnGreen { get; }
    public static XSolidBrush LemonChiffon { get; }
    public static XSolidBrush LightBlue { get; }
    public static XSolidBrush LightCoral { get; }
    public static XSolidBrush LightCyan { get; }
    public static XSolidBrush LightGoldenrodYellow { get; }
    public static XSolidBrush LightGray { get; }
    public static XSolidBrush LightGreen { get; }
    public static XSolidBrush LightPink { get; }
    public static XSolidBrush LightSalmon { get; }
    public static XSolidBrush LightSeaGreen { get; }
    public static XSolidBrush LightSkyBlue { get; }
    public static XSolidBrush LightSlateGray { get; }
    public static XSolidBrush LightSteelBlue { get; }
    public static XSolidBrush LightYellow { get; }
    public static XSolidBrush Lime { get; }
    public static XSolidBrush LimeGreen { get; }
    public static XSolidBrush Linen { get; }
    public static XSolidBrush Magenta { get; }
    public static XSolidBrush Maroon { get; }
    public static XSolidBrush MediumAquamarine { get; }
    public static XSolidBrush MediumBlue { get; }
    public static XSolidBrush MediumOrchid { get; }
    public static XSolidBrush MediumPurple { get; }
    public static XSolidBrush MediumSeaGreen { get; }
    public static XSolidBrush MediumSlateBlue { get; }
    public static XSolidBrush MediumSpringGreen { get; }
    public static XSolidBrush MediumTurquoise { get; }
    public static XSolidBrush MediumVioletRed { get; }
    public static XSolidBrush MidnightBlue { get; }
    public static XSolidBrush MintCream { get; }
    public static XSolidBrush MistyRose { get; }
    public static XSolidBrush Moccasin { get; }
    public static XSolidBrush NavajoWhite { get; }
    public static XSolidBrush Navy { get; }
    public static XSolidBrush OldLace { get; }
    public static XSolidBrush Olive { get; }
    public static XSolidBrush OliveDrab { get; }
    public static XSolidBrush Orange { get; }
    public static XSolidBrush OrangeRed { get; }
    public static XSolidBrush Orchid { get; }
    public static XSolidBrush PaleGoldenrod { get; }
    public static XSolidBrush PaleGreen { get; }
    public static XSolidBrush PaleTurquoise { get; }
    public static XSolidBrush PaleVioletRed { get; }
    public static XSolidBrush PapayaWhip { get; }
    public static XSolidBrush PeachPuff { get; }
    public static XSolidBrush Peru { get; }
    public static XSolidBrush Pink { get; }
    public static XSolidBrush Plum { get; }
    public static XSolidBrush PowderBlue { get; }
    public static XSolidBrush Purple { get; }
    public static XSolidBrush Red { get; }
    public static XSolidBrush RosyBrown { get; }
    public static XSolidBrush RoyalBlue { get; }
    public static XSolidBrush SaddleBrown { get; }
    public static XSolidBrush Salmon { get; }
    public static XSolidBrush SandyBrown { get; }
    public static XSolidBrush SeaGreen { get; }
    public static XSolidBrush SeaShell { get; }
    public static XSolidBrush Sienna { get; }
    public static XSolidBrush Silver { get; }
    public static XSolidBrush SkyBlue { get; }
    public static XSolidBrush SlateBlue { get; }
    public static XSolidBrush SlateGray { get; }
    public static XSolidBrush Snow { get; }
    public static XSolidBrush SpringGreen { get; }
    public static XSolidBrush SteelBlue { get; }
    public static XSolidBrush Tan { get; }
    public static XSolidBrush Teal { get; }
    public static XSolidBrush Thistle { get; }
    public static XSolidBrush Tomato { get; }
    public static XSolidBrush Transparent { get; }
    public static XSolidBrush Turquoise { get; }
    public static XSolidBrush Violet { get; }
    public static XSolidBrush Wheat { get; }
    public static XSolidBrush White { get; }
    public static XSolidBrush WhiteSmoke { get; }
    public static XSolidBrush Yellow { get; }
    public static XSolidBrush YellowGreen { get; }
    public static XSolidBrush get_AliceBlue();
    public static XSolidBrush get_AntiqueWhite();
    public static XSolidBrush get_Aqua();
    public static XSolidBrush get_Aquamarine();
    public static XSolidBrush get_Azure();
    public static XSolidBrush get_Beige();
    public static XSolidBrush get_Bisque();
    public static XSolidBrush get_Black();
    public static XSolidBrush get_BlanchedAlmond();
    public static XSolidBrush get_Blue();
    public static XSolidBrush get_BlueViolet();
    public static XSolidBrush get_Brown();
    public static XSolidBrush get_BurlyWood();
    public static XSolidBrush get_CadetBlue();
    public static XSolidBrush get_Chartreuse();
    public static XSolidBrush get_Chocolate();
    public static XSolidBrush get_Coral();
    public static XSolidBrush get_CornflowerBlue();
    public static XSolidBrush get_Cornsilk();
    public static XSolidBrush get_Crimson();
    public static XSolidBrush get_Cyan();
    public static XSolidBrush get_DarkBlue();
    public static XSolidBrush get_DarkCyan();
    public static XSolidBrush get_DarkGoldenrod();
    public static XSolidBrush get_DarkGray();
    public static XSolidBrush get_DarkGreen();
    public static XSolidBrush get_DarkKhaki();
    public static XSolidBrush get_DarkMagenta();
    public static XSolidBrush get_DarkOliveGreen();
    public static XSolidBrush get_DarkOrange();
    public static XSolidBrush get_DarkOrchid();
    public static XSolidBrush get_DarkRed();
    public static XSolidBrush get_DarkSalmon();
    public static XSolidBrush get_DarkSeaGreen();
    public static XSolidBrush get_DarkSlateBlue();
    public static XSolidBrush get_DarkSlateGray();
    public static XSolidBrush get_DarkTurquoise();
    public static XSolidBrush get_DarkViolet();
    public static XSolidBrush get_DeepPink();
    public static XSolidBrush get_DeepSkyBlue();
    public static XSolidBrush get_DimGray();
    public static XSolidBrush get_DodgerBlue();
    public static XSolidBrush get_Firebrick();
    public static XSolidBrush get_FloralWhite();
    public static XSolidBrush get_ForestGreen();
    public static XSolidBrush get_Fuchsia();
    public static XSolidBrush get_Gainsboro();
    public static XSolidBrush get_GhostWhite();
    public static XSolidBrush get_Gold();
    public static XSolidBrush get_Goldenrod();
    public static XSolidBrush get_Gray();
    public static XSolidBrush get_Green();
    public static XSolidBrush get_GreenYellow();
    public static XSolidBrush get_Honeydew();
    public static XSolidBrush get_HotPink();
    public static XSolidBrush get_IndianRed();
    public static XSolidBrush get_Indigo();
    public static XSolidBrush get_Ivory();
    public static XSolidBrush get_Khaki();
    public static XSolidBrush get_Lavender();
    public static XSolidBrush get_LavenderBlush();
    public static XSolidBrush get_LawnGreen();
    public static XSolidBrush get_LemonChiffon();
    public static XSolidBrush get_LightBlue();
    public static XSolidBrush get_LightCoral();
    public static XSolidBrush get_LightCyan();
    public static XSolidBrush get_LightGoldenrodYellow();
    public static XSolidBrush get_LightGray();
    public static XSolidBrush get_LightGreen();
    public static XSolidBrush get_LightPink();
    public static XSolidBrush get_LightSalmon();
    public static XSolidBrush get_LightSeaGreen();
    public static XSolidBrush get_LightSkyBlue();
    public static XSolidBrush get_LightSlateGray();
    public static XSolidBrush get_LightSteelBlue();
    public static XSolidBrush get_LightYellow();
    public static XSolidBrush get_Lime();
    public static XSolidBrush get_LimeGreen();
    public static XSolidBrush get_Linen();
    public static XSolidBrush get_Magenta();
    public static XSolidBrush get_Maroon();
    public static XSolidBrush get_MediumAquamarine();
    public static XSolidBrush get_MediumBlue();
    public static XSolidBrush get_MediumOrchid();
    public static XSolidBrush get_MediumPurple();
    public static XSolidBrush get_MediumSeaGreen();
    public static XSolidBrush get_MediumSlateBlue();
    public static XSolidBrush get_MediumSpringGreen();
    public static XSolidBrush get_MediumTurquoise();
    public static XSolidBrush get_MediumVioletRed();
    public static XSolidBrush get_MidnightBlue();
    public static XSolidBrush get_MintCream();
    public static XSolidBrush get_MistyRose();
    public static XSolidBrush get_Moccasin();
    public static XSolidBrush get_NavajoWhite();
    public static XSolidBrush get_Navy();
    public static XSolidBrush get_OldLace();
    public static XSolidBrush get_Olive();
    public static XSolidBrush get_OliveDrab();
    public static XSolidBrush get_Orange();
    public static XSolidBrush get_OrangeRed();
    public static XSolidBrush get_Orchid();
    public static XSolidBrush get_PaleGoldenrod();
    public static XSolidBrush get_PaleGreen();
    public static XSolidBrush get_PaleTurquoise();
    public static XSolidBrush get_PaleVioletRed();
    public static XSolidBrush get_PapayaWhip();
    public static XSolidBrush get_PeachPuff();
    public static XSolidBrush get_Peru();
    public static XSolidBrush get_Pink();
    public static XSolidBrush get_Plum();
    public static XSolidBrush get_PowderBlue();
    public static XSolidBrush get_Purple();
    public static XSolidBrush get_Red();
    public static XSolidBrush get_RosyBrown();
    public static XSolidBrush get_RoyalBlue();
    public static XSolidBrush get_SaddleBrown();
    public static XSolidBrush get_Salmon();
    public static XSolidBrush get_SandyBrown();
    public static XSolidBrush get_SeaGreen();
    public static XSolidBrush get_SeaShell();
    public static XSolidBrush get_Sienna();
    public static XSolidBrush get_Silver();
    public static XSolidBrush get_SkyBlue();
    public static XSolidBrush get_SlateBlue();
    public static XSolidBrush get_SlateGray();
    public static XSolidBrush get_Snow();
    public static XSolidBrush get_SpringGreen();
    public static XSolidBrush get_SteelBlue();
    public static XSolidBrush get_Tan();
    public static XSolidBrush get_Teal();
    public static XSolidBrush get_Thistle();
    public static XSolidBrush get_Tomato();
    public static XSolidBrush get_Transparent();
    public static XSolidBrush get_Turquoise();
    public static XSolidBrush get_Violet();
    public static XSolidBrush get_Wheat();
    public static XSolidBrush get_White();
    public static XSolidBrush get_WhiteSmoke();
    public static XSolidBrush get_Yellow();
    public static XSolidBrush get_YellowGreen();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("clr=(A={A}, R={R}, G={G}, B={B} C={C}, M={M}, Y={Y}, K={K})")]
public class PdfSharp.Drawing.XColor : ValueType {
    public static XColor Empty;
    private XColorSpace _cs;
    private float _a;
    private byte _r;
    private byte _g;
    private byte _b;
    private float _c;
    private float _m;
    private float _y;
    private float _k;
    private float _gs;
    public XColorSpace ColorSpace { get; public set; }
    public bool IsEmpty { get; }
    public bool IsKnownColor { get; }
    public double A { get; public set; }
    public byte R { get; public set; }
    public byte G { get; public set; }
    public byte B { get; public set; }
    internal UInt32 Rgb { get; }
    internal UInt32 Argb { get; }
    public double C { get; public set; }
    public double M { get; public set; }
    public double Y { get; public set; }
    public double K { get; public set; }
    public double GS { get; public set; }
    public string RgbCmykG { get; public set; }
    private XColor(UInt32 argb);
    private XColor(byte alpha, byte red, byte green, byte blue);
    private XColor(double alpha, double cyan, double magenta, double yellow, double black);
    private XColor(double cyan, double magenta, double yellow, double black);
    private XColor(double gray);
    internal XColor(XKnownColor knownColor);
    private static XColor();
    public static XColor FromArgb(int argb);
    public static XColor FromArgb(UInt32 argb);
    public static XColor FromArgb(int red, int green, int blue);
    public static XColor FromArgb(int alpha, int red, int green, int blue);
    public static XColor FromArgb(int alpha, XColor color);
    public static XColor FromCmyk(double cyan, double magenta, double yellow, double black);
    public static XColor FromCmyk(double alpha, double cyan, double magenta, double yellow, double black);
    public static XColor FromGrayScale(double grayScale);
    public static XColor FromKnownColor(XKnownColor color);
    [ObsoleteAttribute("Not really implemented and not useful. See XColorResourceManager.")]
public static XColor FromName(string name);
    public XColorSpace get_ColorSpace();
    public void set_ColorSpace(XColorSpace value);
    public bool get_IsEmpty();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(XColor left, XColor right);
    public static bool op_Inequality(XColor left, XColor right);
    public bool get_IsKnownColor();
    public double GetHue();
    public double GetSaturation();
    public double GetBrightness();
    private void RgbChanged();
    private void CmykChanged();
    private void GrayChanged();
    public double get_A();
    public void set_A(double value);
    public byte get_R();
    public void set_R(byte value);
    public byte get_G();
    public void set_G(byte value);
    public byte get_B();
    public void set_B(byte value);
    internal UInt32 get_Rgb();
    internal UInt32 get_Argb();
    public double get_C();
    public void set_C(double value);
    public double get_M();
    public void set_M(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_K();
    public void set_K(double value);
    public double get_GS();
    public void set_GS(double value);
    public string get_RgbCmykG();
    public void set_RgbCmykG(string value);
    private static void CheckByte(int val, string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Drawing.XColorResourceManager : object {
    private CultureInfo _cultureInfo;
    internal static ColorResourceInfo[] colorInfos;
    public XColorResourceManager(CultureInfo cultureInfo);
    private static XColorResourceManager();
    public static XKnownColor GetKnownColor(UInt32 argb);
    public static XKnownColor[] GetKnownColors(bool includeTransparent);
    public string ToColorName(XKnownColor knownColor);
    public string ToColorName(XColor color);
    private static ColorResourceInfo GetColorInfo(XKnownColor knownColor);
}
public static class PdfSharp.Drawing.XColors : object {
    public static XColor AliceBlue { get; }
    public static XColor AntiqueWhite { get; }
    public static XColor Aqua { get; }
    public static XColor Aquamarine { get; }
    public static XColor Azure { get; }
    public static XColor Beige { get; }
    public static XColor Bisque { get; }
    public static XColor Black { get; }
    public static XColor BlanchedAlmond { get; }
    public static XColor Blue { get; }
    public static XColor BlueViolet { get; }
    public static XColor Brown { get; }
    public static XColor BurlyWood { get; }
    public static XColor CadetBlue { get; }
    public static XColor Chartreuse { get; }
    public static XColor Chocolate { get; }
    public static XColor Coral { get; }
    public static XColor CornflowerBlue { get; }
    public static XColor Cornsilk { get; }
    public static XColor Crimson { get; }
    public static XColor Cyan { get; }
    public static XColor DarkBlue { get; }
    public static XColor DarkCyan { get; }
    public static XColor DarkGoldenrod { get; }
    public static XColor DarkGray { get; }
    public static XColor DarkGreen { get; }
    public static XColor DarkKhaki { get; }
    public static XColor DarkMagenta { get; }
    public static XColor DarkOliveGreen { get; }
    public static XColor DarkOrange { get; }
    public static XColor DarkOrchid { get; }
    public static XColor DarkRed { get; }
    public static XColor DarkSalmon { get; }
    public static XColor DarkSeaGreen { get; }
    public static XColor DarkSlateBlue { get; }
    public static XColor DarkSlateGray { get; }
    public static XColor DarkTurquoise { get; }
    public static XColor DarkViolet { get; }
    public static XColor DeepPink { get; }
    public static XColor DeepSkyBlue { get; }
    public static XColor DimGray { get; }
    public static XColor DodgerBlue { get; }
    public static XColor Firebrick { get; }
    public static XColor FloralWhite { get; }
    public static XColor ForestGreen { get; }
    public static XColor Fuchsia { get; }
    public static XColor Gainsboro { get; }
    public static XColor GhostWhite { get; }
    public static XColor Gold { get; }
    public static XColor Goldenrod { get; }
    public static XColor Gray { get; }
    public static XColor Green { get; }
    public static XColor GreenYellow { get; }
    public static XColor Honeydew { get; }
    public static XColor HotPink { get; }
    public static XColor IndianRed { get; }
    public static XColor Indigo { get; }
    public static XColor Ivory { get; }
    public static XColor Khaki { get; }
    public static XColor Lavender { get; }
    public static XColor LavenderBlush { get; }
    public static XColor LawnGreen { get; }
    public static XColor LemonChiffon { get; }
    public static XColor LightBlue { get; }
    public static XColor LightCoral { get; }
    public static XColor LightCyan { get; }
    public static XColor LightGoldenrodYellow { get; }
    public static XColor LightGray { get; }
    public static XColor LightGreen { get; }
    public static XColor LightPink { get; }
    public static XColor LightSalmon { get; }
    public static XColor LightSeaGreen { get; }
    public static XColor LightSkyBlue { get; }
    public static XColor LightSlateGray { get; }
    public static XColor LightSteelBlue { get; }
    public static XColor LightYellow { get; }
    public static XColor Lime { get; }
    public static XColor LimeGreen { get; }
    public static XColor Linen { get; }
    public static XColor Magenta { get; }
    public static XColor Maroon { get; }
    public static XColor MediumAquamarine { get; }
    public static XColor MediumBlue { get; }
    public static XColor MediumOrchid { get; }
    public static XColor MediumPurple { get; }
    public static XColor MediumSeaGreen { get; }
    public static XColor MediumSlateBlue { get; }
    public static XColor MediumSpringGreen { get; }
    public static XColor MediumTurquoise { get; }
    public static XColor MediumVioletRed { get; }
    public static XColor MidnightBlue { get; }
    public static XColor MintCream { get; }
    public static XColor MistyRose { get; }
    public static XColor Moccasin { get; }
    public static XColor NavajoWhite { get; }
    public static XColor Navy { get; }
    public static XColor OldLace { get; }
    public static XColor Olive { get; }
    public static XColor OliveDrab { get; }
    public static XColor Orange { get; }
    public static XColor OrangeRed { get; }
    public static XColor Orchid { get; }
    public static XColor PaleGoldenrod { get; }
    public static XColor PaleGreen { get; }
    public static XColor PaleTurquoise { get; }
    public static XColor PaleVioletRed { get; }
    public static XColor PapayaWhip { get; }
    public static XColor PeachPuff { get; }
    public static XColor Peru { get; }
    public static XColor Pink { get; }
    public static XColor Plum { get; }
    public static XColor PowderBlue { get; }
    public static XColor Purple { get; }
    public static XColor Red { get; }
    public static XColor RosyBrown { get; }
    public static XColor RoyalBlue { get; }
    public static XColor SaddleBrown { get; }
    public static XColor Salmon { get; }
    public static XColor SandyBrown { get; }
    public static XColor SeaGreen { get; }
    public static XColor SeaShell { get; }
    public static XColor Sienna { get; }
    public static XColor Silver { get; }
    public static XColor SkyBlue { get; }
    public static XColor SlateBlue { get; }
    public static XColor SlateGray { get; }
    public static XColor Snow { get; }
    public static XColor SpringGreen { get; }
    public static XColor SteelBlue { get; }
    public static XColor Tan { get; }
    public static XColor Teal { get; }
    public static XColor Thistle { get; }
    public static XColor Tomato { get; }
    public static XColor Transparent { get; }
    public static XColor Turquoise { get; }
    public static XColor Violet { get; }
    public static XColor Wheat { get; }
    public static XColor White { get; }
    public static XColor WhiteSmoke { get; }
    public static XColor Yellow { get; }
    public static XColor YellowGreen { get; }
    public static XColor get_AliceBlue();
    public static XColor get_AntiqueWhite();
    public static XColor get_Aqua();
    public static XColor get_Aquamarine();
    public static XColor get_Azure();
    public static XColor get_Beige();
    public static XColor get_Bisque();
    public static XColor get_Black();
    public static XColor get_BlanchedAlmond();
    public static XColor get_Blue();
    public static XColor get_BlueViolet();
    public static XColor get_Brown();
    public static XColor get_BurlyWood();
    public static XColor get_CadetBlue();
    public static XColor get_Chartreuse();
    public static XColor get_Chocolate();
    public static XColor get_Coral();
    public static XColor get_CornflowerBlue();
    public static XColor get_Cornsilk();
    public static XColor get_Crimson();
    public static XColor get_Cyan();
    public static XColor get_DarkBlue();
    public static XColor get_DarkCyan();
    public static XColor get_DarkGoldenrod();
    public static XColor get_DarkGray();
    public static XColor get_DarkGreen();
    public static XColor get_DarkKhaki();
    public static XColor get_DarkMagenta();
    public static XColor get_DarkOliveGreen();
    public static XColor get_DarkOrange();
    public static XColor get_DarkOrchid();
    public static XColor get_DarkRed();
    public static XColor get_DarkSalmon();
    public static XColor get_DarkSeaGreen();
    public static XColor get_DarkSlateBlue();
    public static XColor get_DarkSlateGray();
    public static XColor get_DarkTurquoise();
    public static XColor get_DarkViolet();
    public static XColor get_DeepPink();
    public static XColor get_DeepSkyBlue();
    public static XColor get_DimGray();
    public static XColor get_DodgerBlue();
    public static XColor get_Firebrick();
    public static XColor get_FloralWhite();
    public static XColor get_ForestGreen();
    public static XColor get_Fuchsia();
    public static XColor get_Gainsboro();
    public static XColor get_GhostWhite();
    public static XColor get_Gold();
    public static XColor get_Goldenrod();
    public static XColor get_Gray();
    public static XColor get_Green();
    public static XColor get_GreenYellow();
    public static XColor get_Honeydew();
    public static XColor get_HotPink();
    public static XColor get_IndianRed();
    public static XColor get_Indigo();
    public static XColor get_Ivory();
    public static XColor get_Khaki();
    public static XColor get_Lavender();
    public static XColor get_LavenderBlush();
    public static XColor get_LawnGreen();
    public static XColor get_LemonChiffon();
    public static XColor get_LightBlue();
    public static XColor get_LightCoral();
    public static XColor get_LightCyan();
    public static XColor get_LightGoldenrodYellow();
    public static XColor get_LightGray();
    public static XColor get_LightGreen();
    public static XColor get_LightPink();
    public static XColor get_LightSalmon();
    public static XColor get_LightSeaGreen();
    public static XColor get_LightSkyBlue();
    public static XColor get_LightSlateGray();
    public static XColor get_LightSteelBlue();
    public static XColor get_LightYellow();
    public static XColor get_Lime();
    public static XColor get_LimeGreen();
    public static XColor get_Linen();
    public static XColor get_Magenta();
    public static XColor get_Maroon();
    public static XColor get_MediumAquamarine();
    public static XColor get_MediumBlue();
    public static XColor get_MediumOrchid();
    public static XColor get_MediumPurple();
    public static XColor get_MediumSeaGreen();
    public static XColor get_MediumSlateBlue();
    public static XColor get_MediumSpringGreen();
    public static XColor get_MediumTurquoise();
    public static XColor get_MediumVioletRed();
    public static XColor get_MidnightBlue();
    public static XColor get_MintCream();
    public static XColor get_MistyRose();
    public static XColor get_Moccasin();
    public static XColor get_NavajoWhite();
    public static XColor get_Navy();
    public static XColor get_OldLace();
    public static XColor get_Olive();
    public static XColor get_OliveDrab();
    public static XColor get_Orange();
    public static XColor get_OrangeRed();
    public static XColor get_Orchid();
    public static XColor get_PaleGoldenrod();
    public static XColor get_PaleGreen();
    public static XColor get_PaleTurquoise();
    public static XColor get_PaleVioletRed();
    public static XColor get_PapayaWhip();
    public static XColor get_PeachPuff();
    public static XColor get_Peru();
    public static XColor get_Pink();
    public static XColor get_Plum();
    public static XColor get_PowderBlue();
    public static XColor get_Purple();
    public static XColor get_Red();
    public static XColor get_RosyBrown();
    public static XColor get_RoyalBlue();
    public static XColor get_SaddleBrown();
    public static XColor get_Salmon();
    public static XColor get_SandyBrown();
    public static XColor get_SeaGreen();
    public static XColor get_SeaShell();
    public static XColor get_Sienna();
    public static XColor get_Silver();
    public static XColor get_SkyBlue();
    public static XColor get_SlateBlue();
    public static XColor get_SlateGray();
    public static XColor get_Snow();
    public static XColor get_SpringGreen();
    public static XColor get_SteelBlue();
    public static XColor get_Tan();
    public static XColor get_Teal();
    public static XColor get_Thistle();
    public static XColor get_Tomato();
    public static XColor get_Transparent();
    public static XColor get_Turquoise();
    public static XColor get_Violet();
    public static XColor get_Wheat();
    public static XColor get_White();
    public static XColor get_WhiteSmoke();
    public static XColor get_Yellow();
    public static XColor get_YellowGreen();
}
public enum PdfSharp.Drawing.XColorSpace : Enum {
    public int value__;
    public static XColorSpace Rgb;
    public static XColorSpace Cmyk;
    public static XColorSpace GrayScale;
}
public enum PdfSharp.Drawing.XCombineMode : Enum {
    public int value__;
    public static XCombineMode Replace;
    public static XCombineMode Intersect;
    public static XCombineMode Union;
    public static XCombineMode Xor;
    public static XCombineMode Exclude;
    public static XCombineMode Complement;
}
internal static class PdfSharp.Drawing.XConvert : object {
}
public enum PdfSharp.Drawing.XDashStyle : Enum {
    public int value__;
    public static XDashStyle Solid;
    public static XDashStyle Dash;
    public static XDashStyle Dot;
    public static XDashStyle DashDot;
    public static XDashStyle DashDotDot;
    public static XDashStyle Custom;
}
public enum PdfSharp.Drawing.XFillMode : Enum {
    public int value__;
    public static XFillMode Alternate;
    public static XFillMode Winding;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharp.Drawing.XFont : object {
    private double _emSize;
    private XFontStyleEx _style;
    private XPdfFontOptions _pdfOptions;
    private int _cellSpace;
    [CompilerGeneratedAttribute]
private int <CellAscent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CellDescent>k__BackingField;
    private XFontMetrics _fontMetrics;
    [CompilerGeneratedAttribute]
private XGlyphTypeface <GlyphTypeface>k__BackingField;
    [CompilerGeneratedAttribute]
private OpenTypeDescriptor <OpenTypeDescriptor>k__BackingField;
    private string _familyName;
    [CompilerGeneratedAttribute]
private int <UnitsPerEm>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OverrideStyleSimulations>k__BackingField;
    [CompilerGeneratedAttribute]
private XStyleSimulations <StyleSimulations>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <PdfFontSelector>k__BackingField;
    [BrowsableAttribute("False")]
public XFontFamily FontFamily { get; }
    public string Name { get; }
    internal string FaceName { get; }
    public double Size { get; }
    [BrowsableAttribute("False")]
public XFontStyleEx Style { get; }
    public bool Bold { get; }
    public bool Italic { get; }
    public bool Strikeout { get; }
    public bool Underline { get; }
    public bool IsSymbolFont { get; }
    public XPdfFontOptions PdfOptions { get; }
    internal bool UnicodeEncoding { get; }
    internal bool AnsiEncoding { get; }
    internal bool AutoEncoding { get; }
    internal FontType FontTypeFromUnicodeFlag { get; }
    public int CellSpace { get; internal set; }
    public int CellAscent { get; internal set; }
    public int CellDescent { get; internal set; }
    public XFontMetrics Metrics { get; }
    [BrowsableAttribute("False")]
public int Height { get; }
    internal XGlyphTypeface GlyphTypeface { get; private set; }
    internal OpenTypeDescriptor OpenTypeDescriptor { get; private set; }
    internal string FamilyName { get; }
    internal int UnitsPerEm { get; private set; }
    internal bool OverrideStyleSimulations { get; internal set; }
    internal XStyleSimulations StyleSimulations { get; internal set; }
    [NullableAttribute("2")]
internal string PdfFontSelector { get; internal set; }
    private string DebuggerDisplay { get; }
    public XFont(string familyName, double emSize);
    public XFont(string familyName, double emSize, XFontStyleEx style);
    public XFont(string familyName, double emSize, XFontStyleEx style, XPdfFontOptions pdfOptions);
    internal XFont(string familyName, double emSize, XFontStyleEx style, XPdfFontOptions pdfOptions, XStyleSimulations styleSimulations);
    [ObsoleteAttribute("Not yet implemented.")]
public XFont(string familyName, double emSize, XFontStyle style, XFontWeight weight, XFontStretch fontStretch, XPdfFontOptions pdfOptions, Nullable`1<XStyleSimulations> styleSimulations);
    [ObsoleteAttribute("Not yet implemented.")]
public XFont(XTypeface typeface, double emSize, XPdfFontOptions pdfOptions, Nullable`1<XStyleSimulations> styleSimulations);
    public XFont(XGlyphTypeface glyphTypeface, double emSize, XPdfFontOptions pdfOptions, Nullable`1<XStyleSimulations> styleSimulations);
    private void Initialize();
    private void CreateDescriptorAndInitializeFontMetrics();
    public XFontFamily get_FontFamily();
    public string get_Name();
    internal string get_FaceName();
    public double get_Size();
    public XFontStyleEx get_Style();
    public bool get_Bold();
    public bool get_Italic();
    public bool get_Strikeout();
    public bool get_Underline();
    public bool get_IsSymbolFont();
    public XPdfFontOptions get_PdfOptions();
    internal bool get_UnicodeEncoding();
    internal bool get_AnsiEncoding();
    internal bool get_AutoEncoding();
    internal FontType get_FontTypeFromUnicodeFlag();
    public int get_CellSpace();
    internal void set_CellSpace(int value);
    [CompilerGeneratedAttribute]
public int get_CellAscent();
    [CompilerGeneratedAttribute]
internal void set_CellAscent(int value);
    [CompilerGeneratedAttribute]
public int get_CellDescent();
    [CompilerGeneratedAttribute]
internal void set_CellDescent(int value);
    public XFontMetrics get_Metrics();
    public double GetHeight();
    [ObsoleteAttribute("Use GetHeight() without parameter.")]
public double GetHeight(XGraphics graphics);
    public int get_Height();
    [CompilerGeneratedAttribute]
internal XGlyphTypeface get_GlyphTypeface();
    [CompilerGeneratedAttribute]
private void set_GlyphTypeface(XGlyphTypeface value);
    [CompilerGeneratedAttribute]
internal OpenTypeDescriptor get_OpenTypeDescriptor();
    [CompilerGeneratedAttribute]
private void set_OpenTypeDescriptor(OpenTypeDescriptor value);
    internal string get_FamilyName();
    [CompilerGeneratedAttribute]
internal int get_UnitsPerEm();
    [CompilerGeneratedAttribute]
private void set_UnitsPerEm(int value);
    [CompilerGeneratedAttribute]
internal bool get_OverrideStyleSimulations();
    [CompilerGeneratedAttribute]
internal void set_OverrideStyleSimulations(bool value);
    [CompilerGeneratedAttribute]
internal XStyleSimulations get_StyleSimulations();
    [CompilerGeneratedAttribute]
internal void set_StyleSimulations(XStyleSimulations value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal string get_PdfFontSelector();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_PdfFontSelector(string value);
    internal void CheckVersion();
    private string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Drawing.XFontFamily : object {
    internal FontFamilyInternal FamilyInternal;
    public string Name { get; }
    [ObsoleteAttribute("Use platform API directly.")]
public static XFontFamily[] Families { get; }
    public XFontFamily(string familyName);
    internal XFontFamily(string familyName, bool createPlatformObjects);
    private XFontFamily(FontFamilyInternal fontFamilyInternal);
    internal static XFontFamily CreateFromName_not_used(string name, bool createPlatformFamily);
    internal static XFontFamily GetOrCreateFontFamily(string name);
    public string get_Name();
    public int GetCellAscent(XFontStyleEx style);
    public int GetCellDescent(XFontStyleEx style);
    public int GetEmHeight(XFontStyleEx style);
    public int GetLineSpacing(XFontStyleEx style);
    public bool IsStyleAvailable(XFontStyleEx style);
    public static XFontFamily[] get_Families();
    [ObsoleteAttribute("Use platform API directly.")]
public static XFontFamily[] GetFamilies(XGraphics graphics);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Drawing.XFontMetrics : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UnitsPerEm>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Ascent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Descent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AverageWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CapHeight>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Leading>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineSpacing>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StemH>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StemV>k__BackingField;
    [CompilerGeneratedAttribute]
private int <XHeight>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UnderlinePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UnderlineThickness>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StrikethroughPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StrikethroughThickness>k__BackingField;
    public string Name { get; }
    public int UnitsPerEm { get; }
    public int Ascent { get; }
    public int Descent { get; }
    public int AverageWidth { get; }
    public int CapHeight { get; }
    public int Leading { get; }
    public int LineSpacing { get; }
    public int MaxWidth { get; }
    public int StemH { get; }
    public int StemV { get; }
    public int XHeight { get; }
    public int UnderlinePosition { get; }
    public int UnderlineThickness { get; }
    public int StrikethroughPosition { get; }
    public int StrikethroughThickness { get; }
    internal XFontMetrics(string name, int unitsPerEm, int ascent, int descent, int leading, int lineSpacing, int capHeight, int xHeight, int stemV, int stemH, int averageWidth, int maxWidth, int underlinePosition, int underlineThickness, int strikethroughPosition, int strikethroughThickness);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public int get_UnitsPerEm();
    [CompilerGeneratedAttribute]
public int get_Ascent();
    [CompilerGeneratedAttribute]
public int get_Descent();
    [CompilerGeneratedAttribute]
public int get_AverageWidth();
    [CompilerGeneratedAttribute]
public int get_CapHeight();
    [CompilerGeneratedAttribute]
public int get_Leading();
    [CompilerGeneratedAttribute]
public int get_LineSpacing();
    [CompilerGeneratedAttribute]
public int get_MaxWidth();
    [CompilerGeneratedAttribute]
public int get_StemH();
    [CompilerGeneratedAttribute]
public int get_StemV();
    [CompilerGeneratedAttribute]
public int get_XHeight();
    [CompilerGeneratedAttribute]
public int get_UnderlinePosition();
    [CompilerGeneratedAttribute]
public int get_UnderlineThickness();
    [CompilerGeneratedAttribute]
public int get_StrikethroughPosition();
    [CompilerGeneratedAttribute]
public int get_StrikethroughThickness();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharp.Drawing.XFontSource : object {
    private static UInt32 ttcf;
    private OpenTypeFontFace _fontFace;
    private ulong _key;
    private string _fontName;
    [CompilerGeneratedAttribute]
private Byte[] <Bytes>k__BackingField;
    internal OpenTypeFontFace FontFace { get; internal set; }
    internal ulong Key { get; }
    public string FontName { get; }
    public Byte[] Bytes { get; }
    internal string DebuggerDisplay { get; }
    private XFontSource(Byte[] bytes, ulong key);
    public static XFontSource GetOrCreateFrom(Byte[] bytes);
    public static XFontSource CreateFromFile(string path);
    internal static XFontSource GetOrCreateFromGlyphTypeface(string typefaceKey, XGlyphTypeface glyphTypeface);
    private static XFontSource GetOrCreateFrom(string typefaceKey, Byte[] fontBytes);
    public static XFontSource CreateCompiledFont(Byte[] bytes);
    internal OpenTypeFontFace get_FontFace();
    internal void set_FontFace(OpenTypeFontFace value);
    internal ulong get_Key();
    public string get_FontName();
    [CompilerGeneratedAttribute]
public Byte[] get_Bytes();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    internal string get_DebuggerDisplay();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class PdfSharp.Drawing.XFontStretch : ValueType {
    private int _stretch;
    private int RealStretch { get; }
    internal XFontStretch(XFontStretchValue stretch);
    public static XFontStretch FromOpenTypeStretch(int stretchValue);
    public int ToOpenTypeStretch();
    public static int Compare(XFontStretch left, XFontStretch right);
    public static bool op_LessThan(XFontStretch left, XFontStretch right);
    public static bool op_LessThanOrEqual(XFontStretch left, XFontStretch right);
    public static bool op_GreaterThan(XFontStretch left, XFontStretch right);
    public static bool op_GreaterThanOrEqual(XFontStretch left, XFontStretch right);
    public static bool op_Equality(XFontStretch left, XFontStretch right);
    public static bool op_Inequality(XFontStretch left, XFontStretch right);
    public bool Equals(XFontStretch obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    private string ConvertToString(string format, IFormatProvider provider);
    private int get_RealStretch();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class PdfSharp.Drawing.XFontStretches : object {
    public static XFontStretch UltraCondensed { get; }
    public static XFontStretch ExtraCondensed { get; }
    public static XFontStretch Condensed { get; }
    public static XFontStretch SemiCondensed { get; }
    public static XFontStretch Normal { get; }
    public static XFontStretch Medium { get; }
    public static XFontStretch SemiExpanded { get; }
    public static XFontStretch Expanded { get; }
    public static XFontStretch ExtraExpanded { get; }
    public static XFontStretch UltraExpanded { get; }
    public static XFontStretch get_UltraCondensed();
    public static XFontStretch get_ExtraCondensed();
    public static XFontStretch get_Condensed();
    public static XFontStretch get_SemiCondensed();
    public static XFontStretch get_Normal();
    public static XFontStretch get_Medium();
    public static XFontStretch get_SemiExpanded();
    public static XFontStretch get_Expanded();
    public static XFontStretch get_ExtraExpanded();
    public static XFontStretch get_UltraExpanded();
    internal static bool XFontStretchStringToKnownStretch(string stretch, IFormatProvider provider, XFontStretch& xFontStretch);
    [NullableContextAttribute("2")]
internal static bool XFontStretchToString(XFontStretchValue stretch, String& convertedValue);
    internal static XFontStretch FontStretchFromFaceName(string faceName);
}
internal enum PdfSharp.Drawing.XFontStretchValue : Enum {
    public int value__;
    public static XFontStretchValue UltraCondensed;
    public static XFontStretchValue ExtraCondensed;
    public static XFontStretchValue Condensed;
    public static XFontStretchValue SemiCondensed;
    public static XFontStretchValue Normal;
    public static XFontStretchValue SemiExpanded;
    public static XFontStretchValue Expanded;
    public static XFontStretchValue ExtraExpanded;
    public static XFontStretchValue UltraExpanded;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("'{_style}'")]
public class PdfSharp.Drawing.XFontStyle : ValueType {
    private XFontStyleValue _style;
    internal XFontStyle(XFontStyleValue style);
    public static bool op_Equality(XFontStyle left, XFontStyle right);
    public static bool op_Inequality(XFontStyle left, XFontStyle right);
    public bool Equals(XFontStyle obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal int GetStyleForInternalConstruction();
    private string ConvertToString(string format, IFormatProvider provider);
    internal static XFontStyle FromGdiFontStyle(XFontStyleEx style);
}
[FlagsAttribute]
public enum PdfSharp.Drawing.XFontStyleEx : Enum {
    public int value__;
    public static XFontStyleEx Regular;
    public static XFontStyleEx Bold;
    public static XFontStyleEx Italic;
    public static XFontStyleEx BoldItalic;
    public static XFontStyleEx Underline;
    public static XFontStyleEx Strikeout;
}
public static class PdfSharp.Drawing.XFontStyles : object {
    public static XFontStyle Normal { get; }
    public static XFontStyle Oblique { get; }
    public static XFontStyle Italic { get; }
    public static XFontStyle get_Normal();
    public static XFontStyle get_Oblique();
    public static XFontStyle get_Italic();
    [NullableContextAttribute("1")]
internal static bool XFontStyleStringToKnownStyle(string style, IFormatProvider provider, XFontStyle& xFontStyle);
}
internal enum PdfSharp.Drawing.XFontStyleValue : Enum {
    public int value__;
    public static XFontStyleValue Normal;
    public static XFontStyleValue Oblique;
    public static XFontStyleValue Italic;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("'{Weight}'")]
public class PdfSharp.Drawing.XFontWeight : ValueType {
    [CompilerGeneratedAttribute]
private int <Weight>k__BackingField;
    public int Weight { get; }
    internal XFontWeight(int weight);
    [CompilerGeneratedAttribute]
public int get_Weight();
    public static int Compare(XFontWeight left, XFontWeight right);
    public static bool op_LessThan(XFontWeight left, XFontWeight right);
    public static bool op_LessThanOrEqual(XFontWeight left, XFontWeight right);
    public static bool op_GreaterThan(XFontWeight left, XFontWeight right);
    public static bool op_GreaterThanOrEqual(XFontWeight left, XFontWeight right);
    public static bool op_Equality(XFontWeight left, XFontWeight right);
    public static bool op_Inequality(XFontWeight left, XFontWeight right);
    public bool Equals(XFontWeight obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    internal static XFontWeight FromGdiFontStyle(XFontStyleEx style);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class PdfSharp.Drawing.XFontWeights : object {
    public static XFontWeight Thin { get; }
    public static XFontWeight ExtraLight { get; }
    public static XFontWeight UltraLight { get; }
    public static XFontWeight Light { get; }
    public static XFontWeight SemiLight { get; }
    public static XFontWeight Normal { get; }
    public static XFontWeight Regular { get; }
    public static XFontWeight Medium { get; }
    public static XFontWeight SemiBold { get; }
    public static XFontWeight DemiBold { get; }
    public static XFontWeight Bold { get; }
    public static XFontWeight ExtraBold { get; }
    public static XFontWeight UltraBold { get; }
    public static XFontWeight Heavy { get; }
    public static XFontWeight Black { get; }
    public static XFontWeight ExtraBlack { get; }
    public static XFontWeight UltraBlack { get; }
    internal static bool FontWeightStringToKnownWeight(string s, IFormatProvider provider, XFontWeight& fontWeight);
    [NullableContextAttribute("2")]
internal static bool FontWeightToString(int weight, String& convertedValue);
    internal static XFontWeight FontWeightFromFaceName(string faceName);
    public static XFontWeight get_Thin();
    public static XFontWeight get_ExtraLight();
    public static XFontWeight get_UltraLight();
    public static XFontWeight get_Light();
    public static XFontWeight get_SemiLight();
    public static XFontWeight get_Normal();
    public static XFontWeight get_Regular();
    public static XFontWeight get_Medium();
    public static XFontWeight get_SemiBold();
    public static XFontWeight get_DemiBold();
    public static XFontWeight get_Bold();
    public static XFontWeight get_ExtraBold();
    public static XFontWeight get_UltraBold();
    public static XFontWeight get_Heavy();
    public static XFontWeight get_Black();
    public static XFontWeight get_ExtraBlack();
    public static XFontWeight get_UltraBlack();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Drawing.XForm : XImage {
    internal XGraphics Gfx;
    private PdfDocument _document;
    internal FormState _formState;
    private XRect _viewBox;
    [CompilerGeneratedAttribute]
private XRect <BoundingBox>k__BackingField;
    internal XMatrix _transform;
    [NullableAttribute("2")]
internal PdfFormXObject _pdfForm;
    internal XGraphicsPdfRenderer PdfRenderer;
    internal PdfDocument Owner { get; }
    internal PdfColorMode ColorMode { get; }
    internal bool IsTemplate { get; }
    [ObsoleteAttribute("Use either PixelWidth or PointWidth. Temporarily obsolete because of rearrangements for WPF. Currently same as PixelWidth, but will become PointWidth in future releases of PDFsharp.")]
public double Width { get; }
    [ObsoleteAttribute("Use either PixelHeight or PointHeight. Temporarily obsolete because of rearrangements for WPF. Currently same as PixelHeight, but will become PointHeight in future releases of PDFsharp.")]
public double Height { get; }
    public double PointWidth { get; }
    public double PointHeight { get; }
    public int PixelWidth { get; }
    public int PixelHeight { get; }
    public XSize Size { get; }
    public XRect ViewBox { get; }
    public double HorizontalResolution { get; }
    public double VerticalResolution { get; }
    public XRect BoundingBox { get; public set; }
    public XMatrix Transform { get; public set; }
    internal PdfResources Resources { get; }
    private PdfResources PdfSharp.Pdf.Advanced.IContentStream.Resources { get; }
    internal PdfFormXObject PdfForm { get; }
    public XForm(PdfDocument document, XRect viewBox);
    public XForm(PdfDocument document, XSize size);
    public XForm(PdfDocument document, XUnit width, XUnit height);
    public void DrawingFinished();
    internal void AssociateGraphics(XGraphics gfx);
    internal virtual void Finish();
    internal PdfDocument get_Owner();
    internal PdfColorMode get_ColorMode();
    internal bool get_IsTemplate();
    public virtual double get_Width();
    public virtual double get_Height();
    public virtual double get_PointWidth();
    public virtual double get_PointHeight();
    public virtual int get_PixelWidth();
    public virtual int get_PixelHeight();
    public virtual XSize get_Size();
    public XRect get_ViewBox();
    public virtual double get_HorizontalResolution();
    public virtual double get_VerticalResolution();
    [CompilerGeneratedAttribute]
public XRect get_BoundingBox();
    [CompilerGeneratedAttribute]
public void set_BoundingBox(XRect value);
    public virtual XMatrix get_Transform();
    public virtual void set_Transform(XMatrix value);
    internal PdfResources get_Resources();
    private sealed virtual override PdfResources PdfSharp.Pdf.Advanced.IContentStream.get_Resources();
    internal string GetFontName(XGlyphTypeface glyphTypeface, FontType fontType, PdfFont& pdfFont);
    private sealed virtual override string PdfSharp.Pdf.Advanced.IContentStream.GetFontName(XGlyphTypeface glyphTypeface, FontType fontType, PdfFont& pdfFont);
    [NullableContextAttribute("2")]
internal string TryGetFontName(string idName, PdfFont& pdfFont);
    internal string GetFontName(string idName, Byte[] fontData, PdfFont& pdfFont);
    private sealed virtual override string PdfSharp.Pdf.Advanced.IContentStream.GetFontName(string idName, Byte[] fontData, PdfFont& pdfFont);
    internal string GetImageName(XImage image);
    private sealed virtual override string PdfSharp.Pdf.Advanced.IContentStream.GetImageName(XImage image);
    internal PdfFormXObject get_PdfForm();
    internal string GetFormName(XForm form);
    private sealed virtual override string PdfSharp.Pdf.Advanced.IContentStream.GetFormName(XForm form);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharp.Drawing.XGlyphTypeface : object {
    private static string KeySuffix;
    [CompilerGeneratedAttribute]
private XFontFamily <FontFamily>k__BackingField;
    [CompilerGeneratedAttribute]
private OpenTypeFontFace <FontFace>k__BackingField;
    [CompilerGeneratedAttribute]
private XFontSource <FontSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FamilyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StyleName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBold>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsItalic>k__BackingField;
    [CompilerGeneratedAttribute]
private XStyleSimulations <StyleSimulations>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    private int _globalFontStorageVersion;
    public XFontFamily FontFamily { get; }
    internal OpenTypeFontFace FontFace { get; }
    public XFontSource FontSource { get; }
    internal string FaceName { get; private set; }
    public string FamilyName { get; private set; }
    public string StyleName { get; private set; }
    public string DisplayName { get; private set; }
    public bool IsBold { get; private set; }
    public bool IsItalic { get; private set; }
    public XStyleSimulations StyleSimulations { get; }
    internal string Key { get; }
    internal string DebuggerDisplay { get; }
    private XGlyphTypeface(string key, XFontFamily fontFamily, XFontSource fontSource, XStyleSimulations styleSimulations);
    public XGlyphTypeface(XFontSource fontSource);
    internal static XGlyphTypeface GetOrCreateFrom(string familyName, FontResolvingOptions fontResolvingOptions);
    [CompilerGeneratedAttribute]
public XFontFamily get_FontFamily();
    [CompilerGeneratedAttribute]
internal OpenTypeFontFace get_FontFace();
    [CompilerGeneratedAttribute]
public XFontSource get_FontSource();
    private void Initialize();
    [CompilerGeneratedAttribute]
internal string get_FaceName();
    [CompilerGeneratedAttribute]
private void set_FaceName(string value);
    [CompilerGeneratedAttribute]
public string get_FamilyName();
    [CompilerGeneratedAttribute]
private void set_FamilyName(string value);
    [CompilerGeneratedAttribute]
public string get_StyleName();
    [CompilerGeneratedAttribute]
private void set_StyleName(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
private void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public bool get_IsBold();
    [CompilerGeneratedAttribute]
private void set_IsBold(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsItalic();
    [CompilerGeneratedAttribute]
private void set_IsItalic(bool value);
    [CompilerGeneratedAttribute]
public XStyleSimulations get_StyleSimulations();
    private string GetFaceNameSuffix();
    internal string GetBaseName();
    internal static string ComputeGtfKey(string familyName, FontResolvingOptions fontResolvingOptions);
    internal static string ComputeGtfKey(string familyName, bool isBold, bool isItalic);
    [CompilerGeneratedAttribute]
internal string get_Key();
    internal void CheckVersion();
    internal string get_DebuggerDisplay();
}
public abstract class PdfSharp.Drawing.XGradientBrush : XBrush {
    internal bool _extendLeft;
    internal bool _extendRight;
    public bool ExtendLeft { get; public set; }
    public bool ExtendRight { get; public set; }
    public bool get_ExtendLeft();
    public void set_ExtendLeft(bool value);
    public bool get_ExtendRight();
    public void set_ExtendRight(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Drawing.XGraphics : object {
    private bool _disposed;
    internal XGraphicTargetContext TargetContext;
    private XGraphicsUnit _pageUnit;
    private XPageDirection _pageDirection;
    private XPoint _pageOrigin;
    private XSize _pageSize;
    private XSize _pageSizePoints;
    [NullableAttribute("2")]
private PdfDocument _owner;
    private bool _tryGetOwner;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private RenderEvents <RenderEvents>k__BackingField;
    private XSmoothingMode _smoothingMode;
    private XGraphicsInternals _internals;
    private SpaceTransformer _transformer;
    private InternalGraphicsMode _internalGraphicsMode;
    [NullableAttribute("2")]
private XImage _associatedImage;
    internal XMatrix DefaultViewMatrix;
    private bool _drawGraphics;
    private XForm _form;
    [NullableAttribute("2")]
internal IXGraphicsRenderer _renderer;
    private XMatrix _transform;
    private GraphicsStateStack _gsStack;
    public XGraphicsUnit PageUnit { get; }
    public XPageDirection PageDirection { get; public set; }
    public XPoint PageOrigin { get; public set; }
    public XSize PageSize { get; }
    [NullableAttribute("2")]
internal PdfDocument Owner { get; }
    [NullableAttribute("2")]
private RenderEvents RenderEvents { get; }
    public int GraphicsStateLevel { get; }
    public XSmoothingMode SmoothingMode { get; public set; }
    public XMatrix Transform { get; }
    public XGraphicsInternals Internals { get; }
    public SpaceTransformer Transformer { get; }
    internal InternalGraphicsMode InternalGraphicsMode { get; internal set; }
    [NullableAttribute("2")]
internal XImage AssociatedImage { get; internal set; }
    [NullableAttribute("2")]
public PdfPage PdfPage { get; }
    private XGraphics(PdfPage page, XGraphicsPdfPageOptions options, XGraphicsUnit pageUnit, XPageDirection pageDirection);
    [NullableContextAttribute("2")]
private XGraphics(XGraphicsUnit pageUnit, XPageDirection pageDirection, RenderEvents renderEvents);
    private XGraphics(XForm form, RenderEvents renderEvents);
    public static XGraphics CreateMeasureContext(XSize size, XGraphicsUnit pageUnit, XPageDirection pageDirection, RenderEvents renderEvents);
    public static XGraphics FromPdfPage(PdfPage page);
    public static XGraphics FromPdfPage(PdfPage page, XGraphicsUnit unit);
    public static XGraphics FromPdfPage(PdfPage page, XPageDirection pageDirection);
    public static XGraphics FromPdfPage(PdfPage page, XGraphicsPdfPageOptions options);
    public static XGraphics FromPdfPage(PdfPage page, XGraphicsPdfPageOptions options, XPageDirection pageDirection);
    public static XGraphics FromPdfPage(PdfPage page, XGraphicsPdfPageOptions options, XGraphicsUnit unit);
    public static XGraphics FromPdfPage(PdfPage page, XGraphicsPdfPageOptions options, XGraphicsUnit unit, XPageDirection pageDirection);
    public static XGraphics FromPdfForm(XPdfForm form);
    public static XGraphics FromForm(XForm form);
    public static XGraphics FromImage(XImage image, RenderEvents renderEvents);
    public static XGraphics FromImage(XImage image, XGraphicsUnit unit, RenderEvents renderEvents);
    private void Initialize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public XGraphicsUnit get_PageUnit();
    public XPageDirection get_PageDirection();
    public void set_PageDirection(XPageDirection value);
    public XPoint get_PageOrigin();
    public void set_PageOrigin(XPoint value);
    public XSize get_PageSize();
    [NullableContextAttribute("2")]
internal PdfDocument get_Owner();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private RenderEvents get_RenderEvents();
    public void DrawLine(XPen pen, XPoint pt1, XPoint pt2);
    public void DrawLine(XPen pen, double x1, double y1, double x2, double y2);
    public void DrawLines(XPen pen, XPoint[] points);
    public void DrawLines(XPen pen, double x, double y, Double[] value);
    public void DrawBezier(XPen pen, XPoint pt1, XPoint pt2, XPoint pt3, XPoint pt4);
    public void DrawBezier(XPen pen, double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4);
    public void DrawBeziers(XPen pen, XPoint[] points);
    public void DrawCurve(XPen pen, XPoint[] points);
    public void DrawCurve(XPen pen, XPoint[] points, int offset, int numberOfSegments, double tension);
    public void DrawCurve(XPen pen, XPoint[] points, double tension);
    public void DrawArc(XPen pen, XRect rect, double startAngle, double sweepAngle);
    public void DrawArc(XPen pen, double x, double y, double width, double height, double startAngle, double sweepAngle);
    public void DrawRectangle(XPen pen, XRect rect);
    public void DrawRectangle(XPen pen, double x, double y, double width, double height);
    public void DrawRectangle(XBrush brush, XRect rect);
    public void DrawRectangle(XBrush brush, double x, double y, double width, double height);
    [NullableContextAttribute("2")]
public void DrawRectangle(XPen pen, XBrush brush, XRect rect);
    [NullableContextAttribute("2")]
public void DrawRectangle(XPen pen, XBrush brush, double x, double y, double width, double height);
    public void DrawRectangles(XPen pen, XRect[] rectangles);
    public void DrawRectangles(XBrush brush, XRect[] rectangles);
    [NullableContextAttribute("2")]
public void DrawRectangles(XPen pen, XBrush brush, XRect[] rectangles);
    public void DrawRoundedRectangle(XPen pen, XRect rect, XSize ellipseSize);
    public void DrawRoundedRectangle(XPen pen, double x, double y, double width, double height, double ellipseWidth, double ellipseHeight);
    public void DrawRoundedRectangle(XBrush brush, XRect rect, XSize ellipseSize);
    public void DrawRoundedRectangle(XBrush brush, double x, double y, double width, double height, double ellipseWidth, double ellipseHeight);
    [NullableContextAttribute("2")]
public void DrawRoundedRectangle(XPen pen, XBrush brush, XRect rect, XSize ellipseSize);
    [NullableContextAttribute("2")]
public void DrawRoundedRectangle(XPen pen, XBrush brush, double x, double y, double width, double height, double ellipseWidth, double ellipseHeight);
    public void DrawEllipse(XPen pen, XRect rect);
    public void DrawEllipse(XPen pen, double x, double y, double width, double height);
    public void DrawEllipse(XBrush brush, XRect rect);
    public void DrawEllipse(XBrush brush, double x, double y, double width, double height);
    [NullableContextAttribute("2")]
public void DrawEllipse(XPen pen, XBrush brush, XRect rect);
    [NullableContextAttribute("2")]
public void DrawEllipse(XPen pen, XBrush brush, double x, double y, double width, double height);
    public void DrawPolygon(XPen pen, XPoint[] points);
    public void DrawPolygon(XBrush brush, XPoint[] points, XFillMode fillMode);
    [NullableContextAttribute("2")]
public void DrawPolygon(XPen pen, XBrush brush, XPoint[] points, XFillMode fillMode);
    public void DrawPie(XPen pen, XRect rect, double startAngle, double sweepAngle);
    public void DrawPie(XPen pen, double x, double y, double width, double height, double startAngle, double sweepAngle);
    public void DrawPie(XBrush brush, XRect rect, double startAngle, double sweepAngle);
    public void DrawPie(XBrush brush, double x, double y, double width, double height, double startAngle, double sweepAngle);
    [NullableContextAttribute("2")]
public void DrawPie(XPen pen, XBrush brush, XRect rect, double startAngle, double sweepAngle);
    [NullableContextAttribute("2")]
public void DrawPie(XPen pen, XBrush brush, double x, double y, double width, double height, double startAngle, double sweepAngle);
    public void DrawClosedCurve(XPen pen, XPoint[] points);
    public void DrawClosedCurve(XPen pen, XPoint[] points, double tension);
    public void DrawClosedCurve(XBrush brush, XPoint[] points);
    public void DrawClosedCurve(XBrush brush, XPoint[] points, XFillMode fillMode);
    public void DrawClosedCurve(XBrush brush, XPoint[] points, XFillMode fillMode, double tension);
    [NullableContextAttribute("2")]
public void DrawClosedCurve(XPen pen, XBrush brush, XPoint[] points);
    [NullableContextAttribute("2")]
public void DrawClosedCurve(XPen pen, XBrush brush, XPoint[] points, XFillMode fillMode);
    [NullableContextAttribute("2")]
public void DrawClosedCurve(XPen pen, XBrush brush, XPoint[] points, XFillMode fillMode, double tension);
    public void DrawPath(XPen pen, XGraphicsPath path);
    public void DrawPath(XBrush brush, XGraphicsPath path);
    [NullableContextAttribute("2")]
public void DrawPath(XPen pen, XBrush brush, XGraphicsPath path);
    public void DrawString(string s, XFont font, XBrush brush, XPoint point);
    public void DrawString(string s, XFont font, XBrush brush, XPoint point, XStringFormat format);
    public void DrawString(string s, XFont font, XBrush brush, double x, double y);
    public void DrawString(string s, XFont font, XBrush brush, double x, double y, XStringFormat format);
    public void DrawString(string s, XFont font, XBrush brush, XRect layoutRectangle);
    public void DrawString(string text, XFont font, XBrush brush, XRect layoutRectangle, XStringFormat format);
    public XSize MeasureString(string text, XFont font, XStringFormat stringFormat);
    public XSize MeasureString(string text, XFont font);
    public void DrawImage(XImage image, XPoint point);
    public void DrawImage(XImage image, double x, double y);
    public void DrawImage(XImage image, XRect rect);
    public void DrawImage(XImage image, double x, double y, double width, double height);
    public void DrawImage(XImage image, XRect destRect, XRect srcRect, XGraphicsUnit srcUnit);
    private void DrawMissingImageRect(XRect rect);
    private void CheckXPdfFormConsistence(XImage image);
    public void DrawBarCode(BarCode barcode, XPoint position);
    public void DrawBarCode(BarCode barcode, XBrush brush, XPoint position);
    public void DrawBarCode(BarCode barcode, XBrush brush, XFont font, XPoint position);
    public void DrawMatrixCode(MatrixCode matrixcode, XPoint position);
    public void DrawMatrixCode(MatrixCode matrixcode, XBrush brush, XPoint position);
    public XGraphicsState Save();
    public void Restore(XGraphicsState state);
    public void Restore();
    public XGraphicsContainer BeginContainer();
    public XGraphicsContainer BeginContainer(XRect dstRect, XRect srcRect, XGraphicsUnit unit);
    public void EndContainer(XGraphicsContainer container);
    public int get_GraphicsStateLevel();
    public XSmoothingMode get_SmoothingMode();
    public void set_SmoothingMode(XSmoothingMode value);
    public void TranslateTransform(double dx, double dy);
    public void TranslateTransform(double dx, double dy, XMatrixOrder order);
    public void ScaleTransform(double scaleX, double scaleY);
    public void ScaleTransform(double scaleX, double scaleY, XMatrixOrder order);
    public void ScaleTransform(double scaleXY);
    public void ScaleTransform(double scaleXY, XMatrixOrder order);
    public void ScaleAtTransform(double scaleX, double scaleY, double centerX, double centerY);
    public void ScaleAtTransform(double scaleX, double scaleY, XPoint center);
    public void RotateTransform(double angle);
    public void RotateTransform(double angle, XMatrixOrder order);
    public void RotateAtTransform(double angle, XPoint point);
    public void RotateAtTransform(double angle, XPoint point, XMatrixOrder order);
    public void ShearTransform(double shearX, double shearY);
    public void ShearTransform(double shearX, double shearY, XMatrixOrder order);
    public void SkewAtTransform(double shearX, double shearY, double centerX, double centerY);
    public void SkewAtTransform(double shearX, double shearY, XPoint center);
    public void MultiplyTransform(XMatrix matrix);
    public void MultiplyTransform(XMatrix matrix, XMatrixOrder order);
    public XMatrix get_Transform();
    private void AddTransform(XMatrix transform, XMatrixOrder order);
    public void IntersectClip(XRect rect);
    public void IntersectClip(XGraphicsPath path);
    public void WriteComment(string comment);
    public XGraphicsInternals get_Internals();
    public SpaceTransformer get_Transformer();
    internal void DisassociateImage();
    internal InternalGraphicsMode get_InternalGraphicsMode();
    internal void set_InternalGraphicsMode(InternalGraphicsMode value);
    [NullableContextAttribute("2")]
internal XImage get_AssociatedImage();
    [NullableContextAttribute("2")]
internal void set_AssociatedImage(XImage value);
    internal void AppendToContentStream(string str);
    [NullableContextAttribute("2")]
public PdfPage get_PdfPage();
}
public class PdfSharp.Drawing.XGraphicsContainer : object {
    [NullableAttribute("1")]
internal InternalGraphicsState InternalState;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Drawing.XGraphicsPath : object {
    private XFillMode _fillMode;
    internal CoreGraphicsPath CorePath;
    private static string AddStringMessage;
    public XFillMode FillMode { get; public set; }
    public XGraphicsPathInternals Internals { get; }
    public XGraphicsPath Clone();
    public void AddLine(XPoint pt1, XPoint pt2);
    public void AddLine(double x1, double y1, double x2, double y2);
    public void AddLines(XPoint[] points);
    public void AddBezier(XPoint pt1, XPoint pt2, XPoint pt3, XPoint pt4);
    public void AddBezier(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4);
    public void AddBeziers(XPoint[] points);
    public void AddCurve(XPoint[] points);
    public void AddCurve(XPoint[] points, double tension);
    public void AddCurve(XPoint[] points, int offset, int numberOfSegments, double tension);
    public void AddArc(XRect rect, double startAngle, double sweepAngle);
    public void AddArc(double x, double y, double width, double height, double startAngle, double sweepAngle);
    public void AddArc(XPoint point1, XPoint point2, XSize size, double rotationAngle, bool isLargeArg, XSweepDirection sweepDirection);
    public void AddRectangle(XRect rect);
    public void AddRectangle(double x, double y, double width, double height);
    public void AddRectangles(XRect[] rects);
    public void AddRoundedRectangle(double x, double y, double width, double height, double ellipseWidth, double ellipseHeight);
    public void AddEllipse(XRect rect);
    public void AddEllipse(double x, double y, double width, double height);
    public void AddPolygon(XPoint[] points);
    public void AddPie(XRect rect, double startAngle, double sweepAngle);
    public void AddPie(double x, double y, double width, double height, double startAngle, double sweepAngle);
    public void AddClosedCurve(XPoint[] points);
    public void AddClosedCurve(XPoint[] points, double tension);
    public void AddPath(XGraphicsPath path, bool connect);
    public void AddString(string s, XFontFamily family, XFontStyleEx style, double emSize, XPoint origin, XStringFormat format);
    public void AddString(string s, XFontFamily family, XFontStyleEx style, double emSize, XRect layoutRect, XStringFormat format);
    public void CloseFigure();
    public void StartFigure();
    public XFillMode get_FillMode();
    public void set_FillMode(XFillMode value);
    public void Flatten();
    public void Flatten(XMatrix matrix);
    public void Flatten(XMatrix matrix, double flatness);
    public void Widen(XPen pen);
    public void Widen(XPen pen, XMatrix matrix);
    public void Widen(XPen pen, XMatrix matrix, double flatness);
    public XGraphicsPathInternals get_Internals();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Drawing.XGraphicsPathInternals : object {
    private XGraphicsPath _path;
    internal XGraphicsPathInternals(XGraphicsPath path);
}
internal enum PdfSharp.Drawing.XGraphicsPathItemType : Enum {
    public int value__;
    public static XGraphicsPathItemType Lines;
    public static XGraphicsPathItemType Beziers;
    public static XGraphicsPathItemType Curve;
    public static XGraphicsPathItemType Arc;
    public static XGraphicsPathItemType Rectangle;
    public static XGraphicsPathItemType RoundedRectangle;
    public static XGraphicsPathItemType Ellipse;
    public static XGraphicsPathItemType Polygon;
    public static XGraphicsPathItemType CloseFigure;
    public static XGraphicsPathItemType StartFigure;
}
public enum PdfSharp.Drawing.XGraphicsPdfPageOptions : Enum {
    public int value__;
    public static XGraphicsPdfPageOptions Append;
    public static XGraphicsPdfPageOptions Prepend;
    public static XGraphicsPdfPageOptions Replace;
}
public class PdfSharp.Drawing.XGraphicsState : object {
    [NullableAttribute("1")]
internal InternalGraphicsState InternalState;
}
public enum PdfSharp.Drawing.XGraphicsUnit : Enum {
    public int value__;
    public static XGraphicsUnit Point;
    public static XGraphicsUnit Inch;
    public static XGraphicsUnit Millimeter;
    public static XGraphicsUnit Centimeter;
    public static XGraphicsUnit Presentation;
}
internal enum PdfSharp.Drawing.XGraphicTargetContext : Enum {
    public int value__;
    public static XGraphicTargetContext NONE;
    public static XGraphicTargetContext CORE;
    public static XGraphicTargetContext GDI;
    public static XGraphicTargetContext WPF;
    public static XGraphicTargetContext WUI;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Drawing.XImage : object {
    [CompilerGeneratedAttribute]
private XImageState <XImageState>k__BackingField;
    private bool _disposed;
    private static double FactorDPM72;
    private static double FactorDPM;
    private bool _interpolate;
    [NullableAttribute("2")]
private XImageFormat _format;
    [NullableAttribute("2")]
private XGraphics _associatedGraphics;
    [NullableAttribute("2")]
internal ImportedImage _importedImage;
    internal string _path;
    internal Stream _stream;
    internal ImageSelector _selector;
    internal XImageState XImageState { get; internal set; }
    [ObsoleteAttribute("Use either PixelWidth or PointWidth. Temporarily obsolete because of rearrangements for WPF. Currently same as PixelWidth, but will become PointWidth in future releases of PDFsharp.")]
public double Width { get; }
    [ObsoleteAttribute("Use either PixelHeight or PointHeight. Temporarily obsolete because of rearrangements for WPF. Currently same as PixelHeight, but will become PointHeight in future releases of PDFsharp.")]
public double Height { get; }
    public double PointWidth { get; }
    public double PointHeight { get; }
    public int PixelWidth { get; }
    public int PixelHeight { get; }
    public XSize Size { get; }
    public double HorizontalResolution { get; }
    public double VerticalResolution { get; }
    public bool Interpolate { get; public set; }
    public XImageFormat Format { get; }
    [NullableAttribute("2")]
internal XGraphics AssociatedGraphics { get; internal set; }
    private XImage(ImportedImage image);
    private XImage(string path);
    private XImage(Stream stream);
    public static XImage FromFile(string path);
    public static XImage FromStream(Stream stream);
    public static XImage FromBitmapImageStreamThatCannotSeek(Stream stream);
    public static bool ExistsFile(string path);
    [CompilerGeneratedAttribute]
internal XImageState get_XImageState();
    [CompilerGeneratedAttribute]
internal void set_XImageState(XImageState value);
    internal void Initialize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual double get_Width();
    public virtual double get_Height();
    public virtual double get_PointWidth();
    public virtual double get_PointHeight();
    public virtual int get_PixelWidth();
    public virtual int get_PixelHeight();
    public virtual XSize get_Size();
    public virtual double get_HorizontalResolution();
    public virtual double get_VerticalResolution();
    public virtual bool get_Interpolate();
    public virtual void set_Interpolate(bool value);
    public XImageFormat get_Format();
    internal void AssociateWithGraphics(XGraphics gfx);
    internal void DisassociateWithGraphics();
    internal void DisassociateWithGraphics(XGraphics gfx);
    [NullableContextAttribute("2")]
internal XGraphics get_AssociatedGraphics();
    [NullableContextAttribute("2")]
internal void set_AssociatedGraphics(XGraphics value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Drawing.XImageFormat : object {
    private Guid _guid;
    private static XImageFormat _png;
    private static XImageFormat _gif;
    private static XImageFormat _jpeg;
    private static XImageFormat _tiff;
    private static XImageFormat _icon;
    private static XImageFormat _pdf;
    internal Guid Guid { get; }
    public static XImageFormat Png { get; }
    public static XImageFormat Gif { get; }
    public static XImageFormat Jpeg { get; }
    public static XImageFormat Tiff { get; }
    public static XImageFormat Pdf { get; }
    public static XImageFormat Icon { get; }
    private XImageFormat(Guid guid);
    private static XImageFormat();
    internal Guid get_Guid();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static XImageFormat get_Png();
    public static XImageFormat get_Gif();
    public static XImageFormat get_Jpeg();
    public static XImageFormat get_Tiff();
    public static XImageFormat get_Pdf();
    public static XImageFormat get_Icon();
}
[FlagsAttribute]
internal enum PdfSharp.Drawing.XImageState : Enum {
    public int value__;
    public static XImageState UsedInDrawingContext;
    public static XImageState StateMask;
}
public enum PdfSharp.Drawing.XKnownColor : Enum {
    public int value__;
    public static XKnownColor AliceBlue;
    public static XKnownColor AntiqueWhite;
    public static XKnownColor Aqua;
    public static XKnownColor Aquamarine;
    public static XKnownColor Azure;
    public static XKnownColor Beige;
    public static XKnownColor Bisque;
    public static XKnownColor Black;
    public static XKnownColor BlanchedAlmond;
    public static XKnownColor Blue;
    public static XKnownColor BlueViolet;
    public static XKnownColor Brown;
    public static XKnownColor BurlyWood;
    public static XKnownColor CadetBlue;
    public static XKnownColor Chartreuse;
    public static XKnownColor Chocolate;
    public static XKnownColor Coral;
    public static XKnownColor CornflowerBlue;
    public static XKnownColor Cornsilk;
    public static XKnownColor Crimson;
    public static XKnownColor Cyan;
    public static XKnownColor DarkBlue;
    public static XKnownColor DarkCyan;
    public static XKnownColor DarkGoldenrod;
    public static XKnownColor DarkGray;
    public static XKnownColor DarkGreen;
    public static XKnownColor DarkKhaki;
    public static XKnownColor DarkMagenta;
    public static XKnownColor DarkOliveGreen;
    public static XKnownColor DarkOrange;
    public static XKnownColor DarkOrchid;
    public static XKnownColor DarkRed;
    public static XKnownColor DarkSalmon;
    public static XKnownColor DarkSeaGreen;
    public static XKnownColor DarkSlateBlue;
    public static XKnownColor DarkSlateGray;
    public static XKnownColor DarkTurquoise;
    public static XKnownColor DarkViolet;
    public static XKnownColor DeepPink;
    public static XKnownColor DeepSkyBlue;
    public static XKnownColor DimGray;
    public static XKnownColor DodgerBlue;
    public static XKnownColor Firebrick;
    public static XKnownColor FloralWhite;
    public static XKnownColor ForestGreen;
    public static XKnownColor Fuchsia;
    public static XKnownColor Gainsboro;
    public static XKnownColor GhostWhite;
    public static XKnownColor Gold;
    public static XKnownColor Goldenrod;
    public static XKnownColor Gray;
    public static XKnownColor Green;
    public static XKnownColor GreenYellow;
    public static XKnownColor Honeydew;
    public static XKnownColor HotPink;
    public static XKnownColor IndianRed;
    public static XKnownColor Indigo;
    public static XKnownColor Ivory;
    public static XKnownColor Khaki;
    public static XKnownColor Lavender;
    public static XKnownColor LavenderBlush;
    public static XKnownColor LawnGreen;
    public static XKnownColor LemonChiffon;
    public static XKnownColor LightBlue;
    public static XKnownColor LightCoral;
    public static XKnownColor LightCyan;
    public static XKnownColor LightGoldenrodYellow;
    public static XKnownColor LightGray;
    public static XKnownColor LightGreen;
    public static XKnownColor LightPink;
    public static XKnownColor LightSalmon;
    public static XKnownColor LightSeaGreen;
    public static XKnownColor LightSkyBlue;
    public static XKnownColor LightSlateGray;
    public static XKnownColor LightSteelBlue;
    public static XKnownColor LightYellow;
    public static XKnownColor Lime;
    public static XKnownColor LimeGreen;
    public static XKnownColor Linen;
    public static XKnownColor Magenta;
    public static XKnownColor Maroon;
    public static XKnownColor MediumAquamarine;
    public static XKnownColor MediumBlue;
    public static XKnownColor MediumOrchid;
    public static XKnownColor MediumPurple;
    public static XKnownColor MediumSeaGreen;
    public static XKnownColor MediumSlateBlue;
    public static XKnownColor MediumSpringGreen;
    public static XKnownColor MediumTurquoise;
    public static XKnownColor MediumVioletRed;
    public static XKnownColor MidnightBlue;
    public static XKnownColor MintCream;
    public static XKnownColor MistyRose;
    public static XKnownColor Moccasin;
    public static XKnownColor NavajoWhite;
    public static XKnownColor Navy;
    public static XKnownColor OldLace;
    public static XKnownColor Olive;
    public static XKnownColor OliveDrab;
    public static XKnownColor Orange;
    public static XKnownColor OrangeRed;
    public static XKnownColor Orchid;
    public static XKnownColor PaleGoldenrod;
    public static XKnownColor PaleGreen;
    public static XKnownColor PaleTurquoise;
    public static XKnownColor PaleVioletRed;
    public static XKnownColor PapayaWhip;
    public static XKnownColor PeachPuff;
    public static XKnownColor Peru;
    public static XKnownColor Pink;
    public static XKnownColor Plum;
    public static XKnownColor PowderBlue;
    public static XKnownColor Purple;
    public static XKnownColor Red;
    public static XKnownColor RosyBrown;
    public static XKnownColor RoyalBlue;
    public static XKnownColor SaddleBrown;
    public static XKnownColor Salmon;
    public static XKnownColor SandyBrown;
    public static XKnownColor SeaGreen;
    public static XKnownColor SeaShell;
    public static XKnownColor Sienna;
    public static XKnownColor Silver;
    public static XKnownColor SkyBlue;
    public static XKnownColor SlateBlue;
    public static XKnownColor SlateGray;
    public static XKnownColor Snow;
    public static XKnownColor SpringGreen;
    public static XKnownColor SteelBlue;
    public static XKnownColor Tan;
    public static XKnownColor Teal;
    public static XKnownColor Thistle;
    public static XKnownColor Tomato;
    public static XKnownColor Transparent;
    public static XKnownColor Turquoise;
    public static XKnownColor Violet;
    public static XKnownColor Wheat;
    public static XKnownColor White;
    public static XKnownColor WhiteSmoke;
    public static XKnownColor Yellow;
    public static XKnownColor YellowGreen;
}
internal static class PdfSharp.Drawing.XKnownColorTable : object {
    [NullableAttribute("1")]
internal static UInt32[] ColorTable;
    private static XKnownColorTable();
    public static UInt32 KnownColorToArgb(XKnownColor color);
    public static bool IsKnownColor(UInt32 argb);
    public static XKnownColor GetKnownColor(UInt32 argb);
}
public enum PdfSharp.Drawing.XLineAlignment : Enum {
    public int value__;
    public static XLineAlignment Near;
    public static XLineAlignment Center;
    public static XLineAlignment Far;
    public static XLineAlignment BaseLine;
}
public class PdfSharp.Drawing.XLinearGradientBrush : XGradientBrush {
    internal bool _useRect;
    internal XPoint _point1;
    internal XPoint _point2;
    internal XColor _color1;
    internal XColor _color2;
    internal XRect _rect;
    internal XLinearGradientMode _linearGradientMode;
    internal XMatrix _matrix;
    public XMatrix Transform { get; public set; }
    public XLinearGradientBrush(XPoint point1, XPoint point2, XColor color1, XColor color2);
    public XLinearGradientBrush(XRect rect, XColor color1, XColor color2, XLinearGradientMode linearGradientMode);
    public XMatrix get_Transform();
    public void set_Transform(XMatrix value);
    public void TranslateTransform(double dx, double dy);
    public void TranslateTransform(double dx, double dy, XMatrixOrder order);
    public void ScaleTransform(double sx, double sy);
    public void ScaleTransform(double sx, double sy, XMatrixOrder order);
    public void RotateTransform(double angle);
    public void RotateTransform(double angle, XMatrixOrder order);
    public void MultiplyTransform(XMatrix matrix);
    public void MultiplyTransform(XMatrix matrix, XMatrixOrder order);
    public void ResetTransform();
}
public enum PdfSharp.Drawing.XLinearGradientMode : Enum {
    public int value__;
    public static XLinearGradientMode Horizontal;
    public static XLinearGradientMode Vertical;
    public static XLinearGradientMode ForwardDiagonal;
    public static XLinearGradientMode BackwardDiagonal;
}
public enum PdfSharp.Drawing.XLineCap : Enum {
    public int value__;
    public static XLineCap Flat;
    public static XLineCap Round;
    public static XLineCap Square;
}
public enum PdfSharp.Drawing.XLineJoin : Enum {
    public int value__;
    public static XLineJoin Miter;
    public static XLineJoin Round;
    public static XLineJoin Bevel;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharp.Drawing.XMatrix : ValueType {
    private double _m11;
    private double _m12;
    private double _m21;
    private double _m22;
    private double _offsetX;
    private double _offsetY;
    private XMatrixTypes _type;
    private static XMatrix s_identity;
    public static XMatrix Identity { get; }
    public bool IsIdentity { get; }
    public double Determinant { get; }
    public bool HasInverse { get; }
    public double M11 { get; public set; }
    public double M12 { get; public set; }
    public double M21 { get; public set; }
    public double M22 { get; public set; }
    public double OffsetX { get; public set; }
    public double OffsetY { get; public set; }
    private bool IsDistinguishedIdentity { get; }
    private string DebuggerDisplay { get; }
    public XMatrix(double m11, double m12, double m21, double m22, double offsetX, double offsetY);
    private static XMatrix();
    public static XMatrix get_Identity();
    public void SetIdentity();
    public bool get_IsIdentity();
    public Double[] GetElements();
    public static XMatrix op_Multiply(XMatrix trans1, XMatrix trans2);
    public static XMatrix Multiply(XMatrix trans1, XMatrix trans2);
    public void Append(XMatrix matrix);
    public void Prepend(XMatrix matrix);
    [ObsoleteAttribute("Use Append.")]
public void Multiply(XMatrix matrix);
    [ObsoleteAttribute("Use Prepend.")]
public void MultiplyPrepend(XMatrix matrix);
    public void Multiply(XMatrix matrix, XMatrixOrder order);
    [ObsoleteAttribute("Use TranslateAppend or TranslatePrepend explicitly, because in GDI+ and WPF the defaults are contrary.", "True")]
public void Translate(double offsetX, double offsetY);
    public void TranslateAppend(double offsetX, double offsetY);
    public void TranslatePrepend(double offsetX, double offsetY);
    public void Translate(double offsetX, double offsetY, XMatrixOrder order);
    [ObsoleteAttribute("Use ScaleAppend or ScalePrepend explicitly, because in GDI+ and WPF the defaults are contrary.", "True")]
public void Scale(double scaleX, double scaleY);
    public void ScaleAppend(double scaleX, double scaleY);
    public void ScalePrepend(double scaleX, double scaleY);
    public void Scale(double scaleX, double scaleY, XMatrixOrder order);
    [ObsoleteAttribute("Use ScaleAppend or ScalePrepend explicitly, because in GDI+ and WPF the defaults are contrary.", "True")]
public void Scale(double scaleXY);
    public void ScaleAppend(double scaleXY);
    public void ScalePrepend(double scaleXY);
    public void Scale(double scaleXY, XMatrixOrder order);
    [ObsoleteAttribute("Use ScaleAtAppend or ScaleAtPrepend explicitly, because in GDI+ and WPF the defaults are contrary.", "True")]
public void ScaleAt(double scaleX, double scaleY, double centerX, double centerY);
    public void ScaleAtAppend(double scaleX, double scaleY, double centerX, double centerY);
    public void ScaleAtPrepend(double scaleX, double scaleY, double centerX, double centerY);
    [ObsoleteAttribute("Use RotateAppend or RotatePrepend explicitly, because in GDI+ and WPF the defaults are contrary.", "True")]
public void Rotate(double angle);
    public void RotateAppend(double angle);
    public void RotatePrepend(double angle);
    public void Rotate(double angle, XMatrixOrder order);
    [ObsoleteAttribute("Use RotateAtAppend or RotateAtPrepend explicitly, because in GDI+ and WPF the defaults are contrary.", "True")]
public void RotateAt(double angle, double centerX, double centerY);
    public void RotateAtAppend(double angle, double centerX, double centerY);
    public void RotateAtPrepend(double angle, double centerX, double centerY);
    [ObsoleteAttribute("Use RotateAtAppend or RotateAtPrepend explicitly, because in GDI+ and WPF the defaults are contrary.", "True")]
public void RotateAt(double angle, XPoint point);
    public void RotateAtAppend(double angle, XPoint point);
    public void RotateAtPrepend(double angle, XPoint point);
    public void RotateAt(double angle, XPoint point, XMatrixOrder order);
    [ObsoleteAttribute("Use ShearAppend or ShearPrepend explicitly, because in GDI+ and WPF the defaults are contrary.", "True")]
public void Shear(double shearX, double shearY);
    public void ShearAppend(double shearX, double shearY);
    public void ShearPrepend(double shearX, double shearY);
    public void Shear(double shearX, double shearY, XMatrixOrder order);
    [ObsoleteAttribute("Use SkewAppend or SkewPrepend explicitly, because in GDI+ and WPF the defaults are contrary.", "True")]
public void Skew(double skewX, double skewY);
    public void SkewAppend(double skewX, double skewY);
    public void SkewPrepend(double skewX, double skewY);
    public XPoint Transform(XPoint point);
    public void Transform(XPoint[] points);
    public void TransformPoints(XPoint[] points);
    public XVector Transform(XVector vector);
    public void Transform(XVector[] vectors);
    public double get_Determinant();
    public bool get_HasInverse();
    public void Invert();
    public double get_M11();
    public void set_M11(double value);
    public double get_M12();
    public void set_M12(double value);
    public double get_M21();
    public void set_M21(double value);
    public double get_M22();
    public void set_M22(double value);
    public double get_OffsetX();
    public void set_OffsetX(double value);
    public double get_OffsetY();
    public void set_OffsetY(double value);
    public static bool op_Equality(XMatrix matrix1, XMatrix matrix2);
    public static bool op_Inequality(XMatrix matrix1, XMatrix matrix2);
    public static bool Equals(XMatrix matrix1, XMatrix matrix2);
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public bool Equals(XMatrix value);
    public virtual int GetHashCode();
    public static XMatrix Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    [NullableContextAttribute("2")]
internal string ConvertToString(string format, IFormatProvider provider);
    internal void MultiplyVector(Double& x, Double& y);
    internal void MultiplyPoint(Double& x, Double& y);
    internal static XMatrix CreateTranslation(double offsetX, double offsetY);
    internal static XMatrix CreateRotationRadians(double angle);
    internal static XMatrix CreateRotationRadians(double angle, double centerX, double centerY);
    internal static XMatrix CreateScaling(double scaleX, double scaleY);
    internal static XMatrix CreateScaling(double scaleX, double scaleY, double centerX, double centerY);
    internal static XMatrix CreateSkewRadians(double skewX, double skewY, double centerX, double centerY);
    internal static XMatrix CreateSkewRadians(double skewX, double skewY);
    private static XMatrix CreateIdentity();
    private void SetMatrix(double m11, double m12, double m21, double m22, double offsetX, double offsetY, XMatrixTypes type);
    private void DeriveMatrixType();
    private bool get_IsDistinguishedIdentity();
    private string get_DebuggerDisplay();
}
public enum PdfSharp.Drawing.XMatrixOrder : Enum {
    public int value__;
    public static XMatrixOrder Prepend;
    public static XMatrixOrder Append;
}
public enum PdfSharp.Drawing.XPageDirection : Enum {
    public int value__;
    public static XPageDirection Downwards;
    [ObsoleteAttribute("Not implemeted - yagni")]
public static XPageDirection Upwards;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Drawing.XPdfFontOptions : object {
    [CompilerGeneratedAttribute]
private PdfFontEmbedding <FontEmbedding>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfFontEncoding <FontEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfFontColoredGlyphs <ColoredGlyphs>k__BackingField;
    public PdfFontEmbedding FontEmbedding { get; }
    public PdfFontEncoding FontEncoding { get; }
    public PdfFontColoredGlyphs ColoredGlyphs { get; }
    public static XPdfFontOptions AutomaticEncoding { get; }
    public static XPdfFontOptions WinAnsiDefault { get; }
    public static XPdfFontOptions UnicodeDefault { get; }
    public XPdfFontOptions(PdfFontEncoding encoding, PdfFontEmbedding embedding);
    public XPdfFontOptions(PdfFontEncoding encoding);
    public XPdfFontOptions(PdfFontEmbedding embedding);
    public XPdfFontOptions(PdfFontEncoding encoding, PdfFontEmbedding embedding, PdfFontColoredGlyphs coloredGlyphs);
    public XPdfFontOptions(PdfFontEmbedding embedding, PdfFontColoredGlyphs coloredGlyphs);
    public XPdfFontOptions(PdfFontEncoding encoding, PdfFontColoredGlyphs coloredGlyphs);
    public XPdfFontOptions(PdfFontColoredGlyphs coloredGlyphs);
    [CompilerGeneratedAttribute]
public PdfFontEmbedding get_FontEmbedding();
    [CompilerGeneratedAttribute]
public PdfFontEncoding get_FontEncoding();
    [CompilerGeneratedAttribute]
public PdfFontColoredGlyphs get_ColoredGlyphs();
    public static XPdfFontOptions get_AutomaticEncoding();
    public static XPdfFontOptions get_WinAnsiDefault();
    public static XPdfFontOptions get_UnicodeDefault();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Drawing.XPdfForm : XForm {
    private bool _disposed;
    [NullableAttribute("2")]
private XImage _placeHolder;
    private int _pageCount;
    private int _pageNumber;
    [NullableAttribute("2")]
private PdfDocument _externalDocument;
    [NullableAttribute("2")]
public XImage PlaceHolder { get; public set; }
    [NullableAttribute("2")]
public PdfPage Page { get; }
    public int PageCount { get; }
    public double PointWidth { get; }
    public double PointHeight { get; }
    public int PixelWidth { get; }
    public int PixelHeight { get; }
    public XSize Size { get; }
    public XMatrix Transform { get; public set; }
    public int PageNumber { get; public set; }
    public int PageIndex { get; public set; }
    internal PdfDocument ExternalDocument { get; }
    internal XPdfForm(string path);
    internal XPdfForm(Stream stream);
    public static XPdfForm FromFile(string path);
    public static XPdfForm FromStream(Stream stream);
    internal virtual void Finish();
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("2")]
public XImage get_PlaceHolder();
    [NullableContextAttribute("2")]
public void set_PlaceHolder(XImage value);
    [NullableContextAttribute("2")]
public PdfPage get_Page();
    public int get_PageCount();
    public virtual double get_PointWidth();
    public virtual double get_PointHeight();
    public virtual int get_PixelWidth();
    public virtual int get_PixelHeight();
    public virtual XSize get_Size();
    public virtual XMatrix get_Transform();
    public virtual void set_Transform(XMatrix value);
    public int get_PageNumber();
    public void set_PageNumber(int value);
    public int get_PageIndex();
    public void set_PageIndex(int value);
    internal PdfDocument get_ExternalDocument();
    public static string ExtractPageNumber(string path, Int32& pageNumber);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Drawing.XPen : object {
    private XColor _color;
    private double _width;
    private XLineJoin _lineJoin;
    private XLineCap _lineCap;
    private double _miterLimit;
    private XDashStyle _dashStyle;
    private double _dashOffset;
    [NullableAttribute("2")]
internal Double[] _dashPattern;
    private bool _overprint;
    private bool _dirty;
    private bool _immutable;
    public XColor Color { get; public set; }
    public double Width { get; public set; }
    public XLineJoin LineJoin { get; public set; }
    public XLineCap LineCap { get; public set; }
    public double MiterLimit { get; public set; }
    public XDashStyle DashStyle { get; public set; }
    public double DashOffset { get; public set; }
    public Double[] DashPattern { get; public set; }
    public bool Overprint { get; public set; }
    public XPen(XColor color);
    public XPen(XColor color, double width);
    internal XPen(XColor color, double width, bool immutable);
    public XPen(XPen pen);
    public XPen Clone();
    public XColor get_Color();
    public void set_Color(XColor value);
    public double get_Width();
    public void set_Width(double value);
    public XLineJoin get_LineJoin();
    public void set_LineJoin(XLineJoin value);
    public XLineCap get_LineCap();
    public void set_LineCap(XLineCap value);
    public double get_MiterLimit();
    public void set_MiterLimit(double value);
    public XDashStyle get_DashStyle();
    public void set_DashStyle(XDashStyle value);
    public double get_DashOffset();
    public void set_DashOffset(double value);
    public Double[] get_DashPattern();
    public void set_DashPattern(Double[] value);
    public bool get_Overprint();
    public void set_Overprint(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class PdfSharp.Drawing.XPens : object {
    public static XPen AliceBlue { get; }
    public static XPen AntiqueWhite { get; }
    public static XPen Aqua { get; }
    public static XPen Aquamarine { get; }
    public static XPen Azure { get; }
    public static XPen Beige { get; }
    public static XPen Bisque { get; }
    public static XPen Black { get; }
    public static XPen BlanchedAlmond { get; }
    public static XPen Blue { get; }
    public static XPen BlueViolet { get; }
    public static XPen Brown { get; }
    public static XPen BurlyWood { get; }
    public static XPen CadetBlue { get; }
    public static XPen Chartreuse { get; }
    public static XPen Chocolate { get; }
    public static XPen Coral { get; }
    public static XPen CornflowerBlue { get; }
    public static XPen Cornsilk { get; }
    public static XPen Crimson { get; }
    public static XPen Cyan { get; }
    public static XPen DarkBlue { get; }
    public static XPen DarkCyan { get; }
    public static XPen DarkGoldenrod { get; }
    public static XPen DarkGray { get; }
    public static XPen DarkGreen { get; }
    public static XPen DarkKhaki { get; }
    public static XPen DarkMagenta { get; }
    public static XPen DarkOliveGreen { get; }
    public static XPen DarkOrange { get; }
    public static XPen DarkOrchid { get; }
    public static XPen DarkRed { get; }
    public static XPen DarkSalmon { get; }
    public static XPen DarkSeaGreen { get; }
    public static XPen DarkSlateBlue { get; }
    public static XPen DarkSlateGray { get; }
    public static XPen DarkTurquoise { get; }
    public static XPen DarkViolet { get; }
    public static XPen DeepPink { get; }
    public static XPen DeepSkyBlue { get; }
    public static XPen DimGray { get; }
    public static XPen DodgerBlue { get; }
    public static XPen Firebrick { get; }
    public static XPen FloralWhite { get; }
    public static XPen ForestGreen { get; }
    public static XPen Fuchsia { get; }
    public static XPen Gainsboro { get; }
    public static XPen GhostWhite { get; }
    public static XPen Gold { get; }
    public static XPen Goldenrod { get; }
    public static XPen Gray { get; }
    public static XPen Green { get; }
    public static XPen GreenYellow { get; }
    public static XPen Honeydew { get; }
    public static XPen HotPink { get; }
    public static XPen IndianRed { get; }
    public static XPen Indigo { get; }
    public static XPen Ivory { get; }
    public static XPen Khaki { get; }
    public static XPen Lavender { get; }
    public static XPen LavenderBlush { get; }
    public static XPen LawnGreen { get; }
    public static XPen LemonChiffon { get; }
    public static XPen LightBlue { get; }
    public static XPen LightCoral { get; }
    public static XPen LightCyan { get; }
    public static XPen LightGoldenrodYellow { get; }
    public static XPen LightGray { get; }
    public static XPen LightGreen { get; }
    public static XPen LightPink { get; }
    public static XPen LightSalmon { get; }
    public static XPen LightSeaGreen { get; }
    public static XPen LightSkyBlue { get; }
    public static XPen LightSlateGray { get; }
    public static XPen LightSteelBlue { get; }
    public static XPen LightYellow { get; }
    public static XPen Lime { get; }
    public static XPen LimeGreen { get; }
    public static XPen Linen { get; }
    public static XPen Magenta { get; }
    public static XPen Maroon { get; }
    public static XPen MediumAquamarine { get; }
    public static XPen MediumBlue { get; }
    public static XPen MediumOrchid { get; }
    public static XPen MediumPurple { get; }
    public static XPen MediumSeaGreen { get; }
    public static XPen MediumSlateBlue { get; }
    public static XPen MediumSpringGreen { get; }
    public static XPen MediumTurquoise { get; }
    public static XPen MediumVioletRed { get; }
    public static XPen MidnightBlue { get; }
    public static XPen MintCream { get; }
    public static XPen MistyRose { get; }
    public static XPen Moccasin { get; }
    public static XPen NavajoWhite { get; }
    public static XPen Navy { get; }
    public static XPen OldLace { get; }
    public static XPen Olive { get; }
    public static XPen OliveDrab { get; }
    public static XPen Orange { get; }
    public static XPen OrangeRed { get; }
    public static XPen Orchid { get; }
    public static XPen PaleGoldenrod { get; }
    public static XPen PaleGreen { get; }
    public static XPen PaleTurquoise { get; }
    public static XPen PaleVioletRed { get; }
    public static XPen PapayaWhip { get; }
    public static XPen PeachPuff { get; }
    public static XPen Peru { get; }
    public static XPen Pink { get; }
    public static XPen Plum { get; }
    public static XPen PowderBlue { get; }
    public static XPen Purple { get; }
    public static XPen Red { get; }
    public static XPen RosyBrown { get; }
    public static XPen RoyalBlue { get; }
    public static XPen SaddleBrown { get; }
    public static XPen Salmon { get; }
    public static XPen SandyBrown { get; }
    public static XPen SeaGreen { get; }
    public static XPen SeaShell { get; }
    public static XPen Sienna { get; }
    public static XPen Silver { get; }
    public static XPen SkyBlue { get; }
    public static XPen SlateBlue { get; }
    public static XPen SlateGray { get; }
    public static XPen Snow { get; }
    public static XPen SpringGreen { get; }
    public static XPen SteelBlue { get; }
    public static XPen Tan { get; }
    public static XPen Teal { get; }
    public static XPen Thistle { get; }
    public static XPen Tomato { get; }
    public static XPen Transparent { get; }
    public static XPen Turquoise { get; }
    public static XPen Violet { get; }
    public static XPen Wheat { get; }
    public static XPen White { get; }
    public static XPen WhiteSmoke { get; }
    public static XPen Yellow { get; }
    public static XPen YellowGreen { get; }
    public static XPen get_AliceBlue();
    public static XPen get_AntiqueWhite();
    public static XPen get_Aqua();
    public static XPen get_Aquamarine();
    public static XPen get_Azure();
    public static XPen get_Beige();
    public static XPen get_Bisque();
    public static XPen get_Black();
    public static XPen get_BlanchedAlmond();
    public static XPen get_Blue();
    public static XPen get_BlueViolet();
    public static XPen get_Brown();
    public static XPen get_BurlyWood();
    public static XPen get_CadetBlue();
    public static XPen get_Chartreuse();
    public static XPen get_Chocolate();
    public static XPen get_Coral();
    public static XPen get_CornflowerBlue();
    public static XPen get_Cornsilk();
    public static XPen get_Crimson();
    public static XPen get_Cyan();
    public static XPen get_DarkBlue();
    public static XPen get_DarkCyan();
    public static XPen get_DarkGoldenrod();
    public static XPen get_DarkGray();
    public static XPen get_DarkGreen();
    public static XPen get_DarkKhaki();
    public static XPen get_DarkMagenta();
    public static XPen get_DarkOliveGreen();
    public static XPen get_DarkOrange();
    public static XPen get_DarkOrchid();
    public static XPen get_DarkRed();
    public static XPen get_DarkSalmon();
    public static XPen get_DarkSeaGreen();
    public static XPen get_DarkSlateBlue();
    public static XPen get_DarkSlateGray();
    public static XPen get_DarkTurquoise();
    public static XPen get_DarkViolet();
    public static XPen get_DeepPink();
    public static XPen get_DeepSkyBlue();
    public static XPen get_DimGray();
    public static XPen get_DodgerBlue();
    public static XPen get_Firebrick();
    public static XPen get_FloralWhite();
    public static XPen get_ForestGreen();
    public static XPen get_Fuchsia();
    public static XPen get_Gainsboro();
    public static XPen get_GhostWhite();
    public static XPen get_Gold();
    public static XPen get_Goldenrod();
    public static XPen get_Gray();
    public static XPen get_Green();
    public static XPen get_GreenYellow();
    public static XPen get_Honeydew();
    public static XPen get_HotPink();
    public static XPen get_IndianRed();
    public static XPen get_Indigo();
    public static XPen get_Ivory();
    public static XPen get_Khaki();
    public static XPen get_Lavender();
    public static XPen get_LavenderBlush();
    public static XPen get_LawnGreen();
    public static XPen get_LemonChiffon();
    public static XPen get_LightBlue();
    public static XPen get_LightCoral();
    public static XPen get_LightCyan();
    public static XPen get_LightGoldenrodYellow();
    public static XPen get_LightGray();
    public static XPen get_LightGreen();
    public static XPen get_LightPink();
    public static XPen get_LightSalmon();
    public static XPen get_LightSeaGreen();
    public static XPen get_LightSkyBlue();
    public static XPen get_LightSlateGray();
    public static XPen get_LightSteelBlue();
    public static XPen get_LightYellow();
    public static XPen get_Lime();
    public static XPen get_LimeGreen();
    public static XPen get_Linen();
    public static XPen get_Magenta();
    public static XPen get_Maroon();
    public static XPen get_MediumAquamarine();
    public static XPen get_MediumBlue();
    public static XPen get_MediumOrchid();
    public static XPen get_MediumPurple();
    public static XPen get_MediumSeaGreen();
    public static XPen get_MediumSlateBlue();
    public static XPen get_MediumSpringGreen();
    public static XPen get_MediumTurquoise();
    public static XPen get_MediumVioletRed();
    public static XPen get_MidnightBlue();
    public static XPen get_MintCream();
    public static XPen get_MistyRose();
    public static XPen get_Moccasin();
    public static XPen get_NavajoWhite();
    public static XPen get_Navy();
    public static XPen get_OldLace();
    public static XPen get_Olive();
    public static XPen get_OliveDrab();
    public static XPen get_Orange();
    public static XPen get_OrangeRed();
    public static XPen get_Orchid();
    public static XPen get_PaleGoldenrod();
    public static XPen get_PaleGreen();
    public static XPen get_PaleTurquoise();
    public static XPen get_PaleVioletRed();
    public static XPen get_PapayaWhip();
    public static XPen get_PeachPuff();
    public static XPen get_Peru();
    public static XPen get_Pink();
    public static XPen get_Plum();
    public static XPen get_PowderBlue();
    public static XPen get_Purple();
    public static XPen get_Red();
    public static XPen get_RosyBrown();
    public static XPen get_RoyalBlue();
    public static XPen get_SaddleBrown();
    public static XPen get_Salmon();
    public static XPen get_SandyBrown();
    public static XPen get_SeaGreen();
    public static XPen get_SeaShell();
    public static XPen get_Sienna();
    public static XPen get_Silver();
    public static XPen get_SkyBlue();
    public static XPen get_SlateBlue();
    public static XPen get_SlateGray();
    public static XPen get_Snow();
    public static XPen get_SpringGreen();
    public static XPen get_SteelBlue();
    public static XPen get_Tan();
    public static XPen get_Teal();
    public static XPen get_Thistle();
    public static XPen get_Tomato();
    public static XPen get_Transparent();
    public static XPen get_Turquoise();
    public static XPen get_Violet();
    public static XPen get_Wheat();
    public static XPen get_White();
    public static XPen get_WhiteSmoke();
    public static XPen get_Yellow();
    public static XPen get_YellowGreen();
}
internal class PdfSharp.Drawing.XPngBitmapDecoder : XBitmapDecoder {
}
internal class PdfSharp.Drawing.XPngBitmapEncoder : XBitmapEncoder {
    [NullableContextAttribute("1")]
public virtual void Save(Stream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharp.Drawing.XPoint : ValueType {
    private double _x;
    private double _y;
    public double X { get; public set; }
    public double Y { get; public set; }
    private string DebuggerDisplay { get; }
    public XPoint(double x, double y);
    public static bool op_Equality(XPoint point1, XPoint point2);
    public static bool op_Inequality(XPoint point1, XPoint point2);
    public static bool Equals(XPoint point1, XPoint point2);
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public bool Equals(XPoint value);
    public virtual int GetHashCode();
    public static XPoint Parse(string source);
    public static XPoint[] ParsePoints(string value);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    [NullableContextAttribute("2")]
internal string ConvertToString(string format, IFormatProvider provider);
    public void Offset(double offsetX, double offsetY);
    public static XPoint op_Addition(XPoint point, XVector vector);
    public static XPoint op_Addition(XPoint point, XSize size);
    public static XPoint Add(XPoint point, XVector vector);
    public static XPoint op_Subtraction(XPoint point, XVector vector);
    public static XPoint Subtract(XPoint point, XVector vector);
    public static XVector op_Subtraction(XPoint point1, XPoint point2);
    [ObsoleteAttribute("Use XVector instead of XSize as second parameter.")]
public static XPoint op_Subtraction(XPoint point, XSize size);
    public static XVector Subtract(XPoint point1, XPoint point2);
    public static XPoint op_Multiply(XPoint point, XMatrix matrix);
    public static XPoint Multiply(XPoint point, XMatrix matrix);
    public static XPoint op_Multiply(XPoint point, double value);
    public static XPoint op_Multiply(double value, XPoint point);
    public static XSize op_Explicit(XPoint point);
    public static XVector op_Explicit(XPoint point);
    private string get_DebuggerDisplay();
}
[ObsoleteAttribute("XPrivateFontCollection is out of order now. Use a font resolver instead.")]
public class PdfSharp.Drawing.XPrivateFontCollection : object {
}
public class PdfSharp.Drawing.XRadialGradientBrush : XGradientBrush {
    internal XPoint _point1;
    internal XPoint _point2;
    internal XColor _color1;
    internal XColor _color2;
    internal double _innerRadius;
    internal double _outerRadius;
    internal XMatrix _matrix;
    public XMatrix Transform { get; public set; }
    public double InnerRadius { get; public set; }
    public double OuterRadius { get; public set; }
    public XRadialGradientBrush(XPoint point1, XPoint point2, double innerRadius, double outerRadius, XColor color1, XColor color2);
    public XMatrix get_Transform();
    public void set_Transform(XMatrix value);
    public double get_InnerRadius();
    public void set_InnerRadius(double value);
    public double get_OuterRadius();
    public void set_OuterRadius(double value);
    public void TranslateTransform(double dx, double dy);
    public void TranslateTransform(double dx, double dy, XMatrixOrder order);
    public void ScaleTransform(double sx, double sy);
    public void ScaleTransform(double sx, double sy, XMatrixOrder order);
    public void RotateTransform(double angle);
    public void RotateTransform(double angle, XMatrixOrder order);
    public void MultiplyTransform(XMatrix matrix);
    public void MultiplyTransform(XMatrix matrix, XMatrixOrder order);
    public void ResetTransform();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharp.Drawing.XRect : ValueType {
    private double _x;
    private double _y;
    private double _width;
    private double _height;
    private static XRect s_empty;
    public static XRect Empty { get; }
    public bool IsEmpty { get; }
    public XPoint Location { get; public set; }
    public XSize Size { get; public set; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Width { get; public set; }
    public double Height { get; public set; }
    public double Left { get; }
    public double Top { get; }
    public double Right { get; }
    public double Bottom { get; }
    public XPoint TopLeft { get; }
    public XPoint TopRight { get; }
    public XPoint BottomLeft { get; }
    public XPoint BottomRight { get; }
    public XPoint Center { get; }
    private string DebuggerDisplay { get; }
    public XRect(double x, double y, double width, double height);
    public XRect(XPoint point1, XPoint point2);
    public XRect(XPoint point, XVector vector);
    public XRect(XPoint location, XSize size);
    public XRect(XSize size);
    private static XRect();
    public static XRect FromLTRB(double left, double top, double right, double bottom);
    public static bool op_Equality(XRect rect1, XRect rect2);
    public static bool op_Inequality(XRect rect1, XRect rect2);
    public static bool Equals(XRect rect1, XRect rect2);
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public bool Equals(XRect value);
    public virtual int GetHashCode();
    public static XRect Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    [NullableContextAttribute("2")]
internal string ConvertToString(string format, IFormatProvider provider);
    public static XRect get_Empty();
    public bool get_IsEmpty();
    public XPoint get_Location();
    public void set_Location(XPoint value);
    public XSize get_Size();
    public void set_Size(XSize value);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Width();
    public void set_Width(double value);
    public double get_Height();
    public void set_Height(double value);
    public double get_Left();
    public double get_Top();
    public double get_Right();
    public double get_Bottom();
    public XPoint get_TopLeft();
    public XPoint get_TopRight();
    public XPoint get_BottomLeft();
    public XPoint get_BottomRight();
    public XPoint get_Center();
    public bool Contains(XPoint point);
    public bool Contains(double x, double y);
    public bool Contains(XRect rect);
    public bool IntersectsWith(XRect rect);
    public void Intersect(XRect rect);
    public static XRect Intersect(XRect rect1, XRect rect2);
    public void Union(XRect rect);
    public static XRect Union(XRect rect1, XRect rect2);
    public void Union(XPoint point);
    public static XRect Union(XRect rect, XPoint point);
    public void Offset(XVector offsetVector);
    public void Offset(double offsetX, double offsetY);
    public static XRect Offset(XRect rect, XVector offsetVector);
    public static XRect Offset(XRect rect, double offsetX, double offsetY);
    public static XRect op_Addition(XRect rect, XPoint point);
    public static XRect op_Subtraction(XRect rect, XPoint point);
    public void Inflate(XSize size);
    public void Inflate(double width, double height);
    public static XRect Inflate(XRect rect, XSize size);
    public static XRect Inflate(XRect rect, double width, double height);
    public static XRect Transform(XRect rect, XMatrix matrix);
    public void Transform(XMatrix matrix);
    public void Scale(double scaleX, double scaleY);
    private bool ContainsInternal(double x, double y);
    private static XRect CreateEmptyRect();
    private string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharp.Drawing.XSize : ValueType {
    private static XSize s_empty;
    private double _width;
    private double _height;
    public static XSize Empty { get; }
    public bool IsEmpty { get; }
    public double Width { get; public set; }
    public double Height { get; public set; }
    private string DebuggerDisplay { get; }
    public XSize(double width, double height);
    private static XSize();
    public static bool op_Equality(XSize size1, XSize size2);
    public static bool op_Inequality(XSize size1, XSize size2);
    public static bool Equals(XSize size1, XSize size2);
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public bool Equals(XSize value);
    public virtual int GetHashCode();
    public static XSize Parse(string source);
    public XPoint ToXPoint();
    public XVector ToXVector();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    [NullableContextAttribute("2")]
internal string ConvertToString(string format, IFormatProvider provider);
    public static XSize get_Empty();
    public bool get_IsEmpty();
    public double get_Width();
    public void set_Width(double value);
    public double get_Height();
    public void set_Height(double value);
    public static XVector op_Explicit(XSize size);
    public static XPoint op_Explicit(XSize size);
    private string get_DebuggerDisplay();
}
[FlagsAttribute]
public enum PdfSharp.Drawing.XSmoothingMode : Enum {
    public int value__;
    public static XSmoothingMode Invalid;
    public static XSmoothingMode Default;
    public static XSmoothingMode HighSpeed;
    public static XSmoothingMode HighQuality;
    public static XSmoothingMode None;
    public static XSmoothingMode AntiAlias;
}
public class PdfSharp.Drawing.XSolidBrush : XBrush {
    private XColor _color;
    private bool _overprint;
    private bool _immutable;
    public XColor Color { get; public set; }
    public bool Overprint { get; public set; }
    public XSolidBrush(XColor color);
    internal XSolidBrush(XColor color, bool immutable);
    [NullableContextAttribute("1")]
public XSolidBrush(XSolidBrush brush);
    public XColor get_Color();
    public void set_Color(XColor value);
    public bool get_Overprint();
    public void set_Overprint(bool value);
}
public enum PdfSharp.Drawing.XStringAlignment : Enum {
    public int value__;
    public static XStringAlignment Near;
    public static XStringAlignment Center;
    public static XStringAlignment Far;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Drawing.XStringFormat : object {
    private XStringAlignment _alignment;
    private XLineAlignment _lineAlignment;
    public XStringAlignment Alignment { get; public set; }
    public XLineAlignment LineAlignment { get; public set; }
    [ObsoleteAttribute("Use XStringFormats.Default. (Note plural in class name.)")]
public static XStringFormat Default { get; }
    [ObsoleteAttribute("Use XStringFormats.Default. (Note plural in class name.)")]
public static XStringFormat TopLeft { get; }
    [ObsoleteAttribute("Use XStringFormats.Center. (Note plural in class name.)")]
public static XStringFormat Center { get; }
    [ObsoleteAttribute("Use XStringFormats.TopCenter. (Note plural in class name.)")]
public static XStringFormat TopCenter { get; }
    [ObsoleteAttribute("Use XStringFormats.BottomCenter. (Note plural in class name.)")]
public static XStringFormat BottomCenter { get; }
    public XStringAlignment get_Alignment();
    public void set_Alignment(XStringAlignment value);
    public XLineAlignment get_LineAlignment();
    public void set_LineAlignment(XLineAlignment value);
    public static XStringFormat get_Default();
    public static XStringFormat get_TopLeft();
    public static XStringFormat get_Center();
    public static XStringFormat get_TopCenter();
    public static XStringFormat get_BottomCenter();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class PdfSharp.Drawing.XStringFormats : object {
    public static XStringFormat Default { get; }
    public static XStringFormat BaseLineLeft { get; }
    public static XStringFormat TopLeft { get; }
    public static XStringFormat CenterLeft { get; }
    public static XStringFormat BottomLeft { get; }
    public static XStringFormat BaseLineCenter { get; }
    public static XStringFormat TopCenter { get; }
    public static XStringFormat Center { get; }
    public static XStringFormat BottomCenter { get; }
    public static XStringFormat BaseLineRight { get; }
    public static XStringFormat TopRight { get; }
    public static XStringFormat CenterRight { get; }
    public static XStringFormat BottomRight { get; }
    public static XStringFormat get_Default();
    public static XStringFormat get_BaseLineLeft();
    public static XStringFormat get_TopLeft();
    public static XStringFormat get_CenterLeft();
    public static XStringFormat get_BottomLeft();
    public static XStringFormat get_BaseLineCenter();
    public static XStringFormat get_TopCenter();
    public static XStringFormat get_Center();
    public static XStringFormat get_BottomCenter();
    public static XStringFormat get_BaseLineRight();
    public static XStringFormat get_TopRight();
    public static XStringFormat get_CenterRight();
    public static XStringFormat get_BottomRight();
}
[FlagsAttribute]
public enum PdfSharp.Drawing.XStyleSimulations : Enum {
    public int value__;
    public static XStyleSimulations None;
    public static XStyleSimulations BoldSimulation;
    public static XStyleSimulations ItalicSimulation;
    public static XStyleSimulations BoldItalicSimulation;
}
public enum PdfSharp.Drawing.XSweepDirection : Enum {
    public int value__;
    public static XSweepDirection Counterclockwise;
    public static XSweepDirection Clockwise;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharp.Drawing.XTypeface : object {
    [CompilerGeneratedAttribute]
private XFontFamily <Family>k__BackingField;
    [CompilerGeneratedAttribute]
private XFontStyle <Style>k__BackingField;
    [CompilerGeneratedAttribute]
private XFontWeight <Weight>k__BackingField;
    [CompilerGeneratedAttribute]
private XFontStretch <Stretch>k__BackingField;
    public XFontFamily Family { get; }
    public XFontStyle Style { get; }
    public XFontWeight Weight { get; }
    public XFontStretch Stretch { get; }
    private string DebuggerDisplay { get; }
    public XTypeface(string typefaceName);
    public XTypeface(XFontFamily family, XFontStyle style, XFontWeight weight, XFontStretch stretch);
    [CompilerGeneratedAttribute]
public XFontFamily get_Family();
    [CompilerGeneratedAttribute]
public XFontStyle get_Style();
    [CompilerGeneratedAttribute]
public XFontWeight get_Weight();
    [CompilerGeneratedAttribute]
public XFontStretch get_Stretch();
    [NullableContextAttribute("2")]
public bool TryGetGlyphTypeface(XGlyphTypeface& glyphTypeface);
    private string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharp.Drawing.XUnit : ValueType {
    internal static double PointFactor;
    internal static double InchFactor;
    internal static double MillimeterFactor;
    internal static double CentimeterFactor;
    internal static double PresentationFactor;
    internal static double PointFactorWpf;
    internal static double InchFactorWpf;
    internal static double MillimeterFactorWpf;
    internal static double CentimeterFactorWpf;
    internal static double PresentationFactorWpf;
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    private double _pointValue;
    [CompilerGeneratedAttribute]
private XGraphicsUnit <Type>k__BackingField;
    public static XUnit Zero;
    public double Value { get; private set; }
    private double PointValue { get; private set; }
    public XGraphicsUnit Type { get; private set; }
    public double Point { get; public set; }
    public double Inch { get; public set; }
    public double Millimeter { get; public set; }
    public double Centimeter { get; public set; }
    public double Presentation { get; public set; }
    private string DebuggerDisplay { get; }
    public XUnit(double point);
    private XUnit(double inch, double point);
    public XUnit(double value, XGraphicsUnit type);
    private static XUnit();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(double value);
    [IsReadOnlyAttribute]
private double get_PointValue();
    private void set_PointValue(double value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public XGraphicsUnit get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(XGraphicsUnit value);
    public double get_Point();
    public void set_Point(double value);
    public double get_Inch();
    public void set_Inch(double value);
    public double get_Millimeter();
    public void set_Millimeter(double value);
    public double get_Centimeter();
    public void set_Centimeter(double value);
    public double get_Presentation();
    public void set_Presentation(double value);
    public string ToString(IFormatProvider formatProvider);
    [NullableContextAttribute("2")]
private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
    public virtual string ToString();
    private string GetSuffix();
    public static XUnit FromPoint(double value);
    public static XUnit FromInch(double value);
    public static XUnit FromMillimeter(double value);
    public static XUnit FromCentimeter(double value);
    public static XUnit FromPresentation(double value);
    public static XUnit op_Implicit(string value);
    [ObsoleteAttribute("In PDFsharp 6.1 implicit conversion from int is marked obsolete, because it led to misunderstandings and unexpected behavior. Provide the unit by XUnit.FromPoint() or use the new class XUnitPt instead.")]
public static XUnit op_Implicit(int value);
    [ObsoleteAttribute("In PDFsharp 6.1 implicit conversion from double is marked obsolete, because it led to misunderstandings and unexpected behavior. Provide the unit by XUnit.FromPoint() or use the new class XUnitPt instead.")]
public static XUnit op_Implicit(double value);
    [ObsoleteAttribute("In PDFsharp 6.1 implicit conversion to double is marked obsolete, because it led to misunderstandings and unexpected behavior. Use the XUnit.Point property instead.")]
public static double op_Implicit(XUnit value);
    public static bool op_Equality(XUnit l, XUnit r);
    public static bool op_Inequality(XUnit l, XUnit r);
    public static bool op_GreaterThan(XUnit l, XUnit r);
    public static bool op_GreaterThanOrEqual(XUnit l, XUnit r);
    public static bool op_LessThan(XUnit l, XUnit r);
    public static bool op_LessThanOrEqual(XUnit l, XUnit r);
    public static XUnit op_UnaryNegation(XUnit value);
    public static XUnit op_Addition(XUnit l, XUnit r);
    public static XUnit op_Addition(XUnit l, string r);
    public static XUnit op_Subtraction(XUnit l, XUnit r);
    public static XUnit op_Subtraction(XUnit l, string r);
    public static XUnit op_Multiply(XUnit l, double r);
    public static XUnit op_Division(XUnit l, double r);
    public sealed virtual int CompareTo(XUnit other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public bool IsSameValue(XUnit other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static XUnit Parse(string value);
    public void ConvertType(XGraphicsUnit type);
    private string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharp.Drawing.XUnitPt : ValueType {
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    public static XUnitPt Zero;
    public double Value { get; public set; }
    public double Point { get; public set; }
    public double Inch { get; public set; }
    public double Millimeter { get; public set; }
    public double Centimeter { get; public set; }
    public double Presentation { get; public set; }
    private string DebuggerDisplay { get; }
    public XUnitPt(double value);
    private static XUnitPt();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(double value);
    public double get_Point();
    public void set_Point(double value);
    public double get_Inch();
    public void set_Inch(double value);
    public double get_Millimeter();
    public void set_Millimeter(double value);
    public double get_Centimeter();
    public void set_Centimeter(double value);
    public double get_Presentation();
    public void set_Presentation(double value);
    public string ToString(IFormatProvider formatProvider);
    [NullableContextAttribute("2")]
private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
    public virtual string ToString();
    public static XUnitPt FromPoint(double value);
    public static XUnitPt FromInch(double value);
    public static XUnitPt FromMillimeter(double value);
    public static XUnitPt FromCentimeter(double value);
    public static XUnitPt FromPresentation(double value);
    public static XUnitPt op_Implicit(string value);
    public static XUnitPt op_Implicit(int value);
    public static XUnitPt op_Implicit(double value);
    public static double op_Implicit(XUnitPt value);
    public static XUnitPt op_Implicit(XUnit value);
    public static XUnit op_Implicit(XUnitPt value);
    public static bool op_Equality(XUnitPt l, XUnitPt r);
    public static bool op_Inequality(XUnitPt l, XUnitPt r);
    public static bool op_GreaterThan(XUnitPt l, XUnitPt r);
    public static bool op_GreaterThanOrEqual(XUnitPt l, XUnitPt r);
    public static bool op_LessThan(XUnitPt l, XUnitPt r);
    public static bool op_LessThanOrEqual(XUnitPt l, XUnitPt r);
    public static XUnitPt op_UnaryNegation(XUnitPt value);
    public static XUnitPt op_Addition(XUnitPt l, XUnitPt r);
    public static XUnitPt op_Addition(XUnitPt l, string r);
    public static XUnitPt op_Subtraction(XUnitPt l, XUnitPt r);
    public static XUnitPt op_Subtraction(XUnitPt l, string r);
    public static XUnitPt op_Multiply(XUnitPt l, double r);
    public static XUnitPt op_Division(XUnitPt l, double r);
    public sealed virtual int CompareTo(XUnitPt other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public bool IsSameValue(XUnitPt other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharp.Drawing.XVector : ValueType {
    private double _x;
    private double _y;
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Length { get; }
    public double LengthSquared { get; }
    private string DebuggerDisplay { get; }
    public XVector(double x, double y);
    public static bool op_Equality(XVector vector1, XVector vector2);
    public static bool op_Inequality(XVector vector1, XVector vector2);
    public static bool Equals(XVector vector1, XVector vector2);
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public bool Equals(XVector value);
    public virtual int GetHashCode();
    public static XVector Parse(string source);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    [NullableContextAttribute("2")]
internal string ConvertToString(string format, IFormatProvider provider);
    public double get_Length();
    public double get_LengthSquared();
    public void Normalize();
    public static double CrossProduct(XVector vector1, XVector vector2);
    public static double AngleBetween(XVector vector1, XVector vector2);
    public static XVector op_UnaryNegation(XVector vector);
    public void Negate();
    public static XVector op_Addition(XVector vector1, XVector vector2);
    public static XVector Add(XVector vector1, XVector vector2);
    public static XVector op_Subtraction(XVector vector1, XVector vector2);
    public static XVector Subtract(XVector vector1, XVector vector2);
    public static XPoint op_Addition(XVector vector, XPoint point);
    public static XPoint Add(XVector vector, XPoint point);
    public static XVector op_Multiply(XVector vector, double scalar);
    public static XVector Multiply(XVector vector, double scalar);
    public static XVector op_Multiply(double scalar, XVector vector);
    public static XVector Multiply(double scalar, XVector vector);
    public static XVector op_Division(XVector vector, double scalar);
    public static XVector Divide(XVector vector, double scalar);
    public static XVector op_Multiply(XVector vector, XMatrix matrix);
    public static XVector Multiply(XVector vector, XMatrix matrix);
    public static double op_Multiply(XVector vector1, XVector vector2);
    public static double Multiply(XVector vector1, XVector vector2);
    public static double Determinant(XVector vector1, XVector vector2);
    public static XSize op_Explicit(XVector vector);
    public static XPoint op_Explicit(XVector vector);
    private string get_DebuggerDisplay();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class PdfSharp.Events.DocumentEvents : object {
    [CompilerGeneratedAttribute]
private PageAddedOrRemovedEventHandler PageAdded;
    [CompilerGeneratedAttribute]
private PageAddedOrRemovedEventHandler PageRemoved;
    [CompilerGeneratedAttribute]
private PageGraphicsEventHandler PageGraphicsCreated;
    [CompilerGeneratedAttribute]
private PageGraphicsEventHandler PageGraphicsAction;
    [NullableContextAttribute("1")]
public void OnPageAdded(object sender, PageEventArgs args);
    [CompilerGeneratedAttribute]
public void add_PageAdded(PageAddedOrRemovedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PageAdded(PageAddedOrRemovedEventHandler value);
    [NullableContextAttribute("1")]
public void OnPageRemoved(object sender, PageEventArgs args);
    [CompilerGeneratedAttribute]
public void add_PageRemoved(PageAddedOrRemovedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PageRemoved(PageAddedOrRemovedEventHandler value);
    [NullableContextAttribute("1")]
public void OnPageGraphicsCreated(object sender, PageGraphicsEventArgs args);
    [CompilerGeneratedAttribute]
public void add_PageGraphicsCreated(PageGraphicsEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PageGraphicsCreated(PageGraphicsEventHandler value);
    [NullableContextAttribute("1")]
public void OnPageGraphicsAction(object sender, PageGraphicsEventArgs args);
    [CompilerGeneratedAttribute]
public void add_PageGraphicsAction(PageGraphicsEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PageGraphicsAction(PageGraphicsEventHandler value);
}
public class PdfSharp.Events.PageAddedOrRemovedEventHandler : MulticastDelegate {
    public PageAddedOrRemovedEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, PageEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PageEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Events.PageEventArgs : PdfSharpEventArgs {
    [CompilerGeneratedAttribute]
private PdfPage <Page>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PageIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private PageEventType <EventType>k__BackingField;
    public PdfPage Page { get; public set; }
    public int PageIndex { get; public set; }
    public PageEventType EventType { get; internal set; }
    public PageEventArgs(PdfObject source);
    [CompilerGeneratedAttribute]
public PdfPage get_Page();
    [CompilerGeneratedAttribute]
public void set_Page(PdfPage value);
    [CompilerGeneratedAttribute]
public int get_PageIndex();
    [CompilerGeneratedAttribute]
public void set_PageIndex(int value);
    [CompilerGeneratedAttribute]
public PageEventType get_EventType();
    [CompilerGeneratedAttribute]
internal void set_EventType(PageEventType value);
}
public enum PdfSharp.Events.PageEventType : Enum {
    public int value__;
    public static PageEventType Created;
    public static PageEventType Moved;
    public static PageEventType Imported;
    public static PageEventType Removed;
}
public enum PdfSharp.Events.PageGraphicsActionType : Enum {
    public int value__;
    public static PageGraphicsActionType GraphicsCreated;
    public static PageGraphicsActionType DrawString;
    public static PageGraphicsActionType Draw;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Events.PageGraphicsEventArgs : PdfSharpEventArgs {
    [CompilerGeneratedAttribute]
private PdfPage <Page>k__BackingField;
    [CompilerGeneratedAttribute]
private XGraphics <Graphics>k__BackingField;
    [CompilerGeneratedAttribute]
private PageGraphicsActionType <ActionType>k__BackingField;
    public PdfPage Page { get; internal set; }
    public XGraphics Graphics { get; internal set; }
    public PageGraphicsActionType ActionType { get; internal set; }
    public PageGraphicsEventArgs(PdfObject source);
    [CompilerGeneratedAttribute]
public PdfPage get_Page();
    [CompilerGeneratedAttribute]
internal void set_Page(PdfPage value);
    [CompilerGeneratedAttribute]
public XGraphics get_Graphics();
    [CompilerGeneratedAttribute]
internal void set_Graphics(XGraphics value);
    [CompilerGeneratedAttribute]
public PageGraphicsActionType get_ActionType();
    [CompilerGeneratedAttribute]
internal void set_ActionType(PageGraphicsActionType value);
}
public class PdfSharp.Events.PageGraphicsEventHandler : MulticastDelegate {
    public PageGraphicsEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, PageGraphicsEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PageGraphicsEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class PdfSharp.Events.PdfSharpEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private PdfObject <Source>k__BackingField;
    public PdfObject Source { get; public set; }
    protected PdfSharpEventArgs(PdfObject source);
    [CompilerGeneratedAttribute]
public PdfObject get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(PdfObject value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Events.PrepareTextEventArgs : PdfSharpEventArgs {
    [CompilerGeneratedAttribute]
private XFont <Font>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public XFont Font { get; public set; }
    public string Text { get; public set; }
    public PrepareTextEventArgs(PdfObject source, XFont font, string text);
    [CompilerGeneratedAttribute]
public XFont get_Font();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Font(XFont value);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
}
public class PdfSharp.Events.PrepareTextEventHandler : MulticastDelegate {
    public PrepareTextEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, PrepareTextEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PrepareTextEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class PdfSharp.Events.RenderEvents : object {
    [CompilerGeneratedAttribute]
private PrepareTextEventHandler PrepareTextEvent;
    [CompilerGeneratedAttribute]
private RenderTextEventHandler RenderTextEvent;
    [NullableContextAttribute("1")]
public void OnPrepareTextEvent(object sender, PrepareTextEventArgs args);
    [CompilerGeneratedAttribute]
public void add_PrepareTextEvent(PrepareTextEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PrepareTextEvent(PrepareTextEventHandler value);
    [NullableContextAttribute("1")]
public void OnRenderTextEvent(object sender, RenderTextEventArgs args);
    [CompilerGeneratedAttribute]
public void add_RenderTextEvent(RenderTextEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_RenderTextEvent(RenderTextEventHandler value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Events.RenderTextEventArgs : PdfSharpEventArgs {
    [CompilerGeneratedAttribute]
private bool <ReevaluateGlyphIndices>k__BackingField;
    [CompilerGeneratedAttribute]
private XFont <Font>k__BackingField;
    [CompilerGeneratedAttribute]
private CodePointGlyphIndexPair[] <CodePointGlyphIndexPairs>k__BackingField;
    public bool ReevaluateGlyphIndices { get; public set; }
    public XFont Font { get; public set; }
    public CodePointGlyphIndexPair[] CodePointGlyphIndexPairs { get; public set; }
    public RenderTextEventArgs(PdfObject source, XFont font, CodePointGlyphIndexPair[] codePointGlyphIndexPair);
    [CompilerGeneratedAttribute]
public bool get_ReevaluateGlyphIndices();
    [CompilerGeneratedAttribute]
public void set_ReevaluateGlyphIndices(bool value);
    [CompilerGeneratedAttribute]
public XFont get_Font();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Font(XFont value);
    [CompilerGeneratedAttribute]
public CodePointGlyphIndexPair[] get_CodePointGlyphIndexPairs();
    [CompilerGeneratedAttribute]
public void set_CodePointGlyphIndexPairs(CodePointGlyphIndexPair[] value);
}
public class PdfSharp.Events.RenderTextEventHandler : MulticastDelegate {
    public RenderTextEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, RenderTextEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, RenderTextEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum PdfSharp.FeatureNotAvailableBehavior : Enum {
    public int value__;
    public static FeatureNotAvailableBehavior SilentlyIgnore;
    public static FeatureNotAvailableBehavior LogInformation;
    public static FeatureNotAvailableBehavior LogWarning;
    public static FeatureNotAvailableBehavior LogError;
    public static FeatureNotAvailableBehavior ThrowException;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.CMapInfo : object {
    private OpenTypeDescriptor _descriptor;
    public int MinCodePoint;
    public int MaxCodePoint;
    public Dictionary`2<int, ushort> CodePointsToGlyphIndices;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<ushort, object> GlyphIndices;
    public Int32[] Chars { get; }
    public CMapInfo(OpenTypeDescriptor descriptor);
    public void AddChars(CodePointGlyphIndexPair[] codePoints);
    internal bool Contains(char ch);
    public Int32[] get_Chars();
    public UInt16[] GetGlyphIndices();
}
public class PdfSharp.Fonts.CodePointGlyphIndexPair : ValueType {
    public int CodePoint;
    public ushort GlyphIndex;
    public CodePointGlyphIndexPair(int codePoint, ushort glyphIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.CoreBuildFontResolver : object {
    private static List`1<TypefaceInfo> TypefaceInfos;
    private Nullable`1<bool> _isWindows;
    private Nullable`1<bool> _isLinux;
    private static List`1<string> WindowsFontLocations;
    private static List`1<string> LinuxFontLocations;
    private static CoreBuildFontResolver();
    public sealed virtual FontResolverInfo ResolveTypeface(string familyName, bool isBold, bool isItalic);
    public sealed virtual Byte[] GetFont(string faceName);
    private Byte[] GetWindowsFontFace(string faceName);
    private Byte[] GetLinuxFontFace(string faceName);
    private string FindFileRecursive(string basePath, string faceName);
    private String[] FaceNameToFilenameCandidates(string faceName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class PdfSharp.Fonts.FontDescriptorCache : object {
    public static FontDescriptor GetOrCreateDescriptorFor(XFont font);
    public static FontDescriptor GetOrCreateDescriptorFor(XGlyphTypeface glyphTypeface);
    public static FontDescriptor GetOrCreateDescriptor(string fontFamilyName, XFontStyleEx style);
    internal static void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class PdfSharp.Fonts.FontFactory : object {
    private static bool _fallbackFontResolverInvoked;
    public static bool HasFontSources { get; }
    public static FontResolverInfo ResolveTypeface(string familyName, FontResolvingOptions fontResolvingOptions, string typefaceKey, bool useFallbackFontResolver);
    internal static void RegisterResolverResult(IFontResolver fontResolver, string familyName, FontResolvingOptions fontResolvingOptions, FontResolverInfo fontResolverInfo, string typefaceKey);
    public static XFontSource GetFontSourceByFontName(string fontName);
    public static XFontSource GetFontSourceByTypefaceKey(string typefaceKey);
    public static bool TryGetFontSourceByKey(ulong key, XFontSource& fontSource);
    public static bool get_HasFontSources();
    public static bool TryGetFontResolverInfoByTypefaceKey(string typeFaceKey, FontResolverInfo& info);
    public static bool TryGetFontSourceByTypefaceKey(string typefaceKey, XFontSource& source);
    internal static void CacheFontResolverInfo(string typefaceKey, FontResolverInfo fontResolverInfo);
    public static XFontSource CacheFontSource(XFontSource fontSource);
    public static XFontSource CacheNewFontSource(string typefaceKey, XFontSource fontSource);
    public static void CacheExistingFontSourceWithNewTypefaceKey(string typefaceKey, XFontSource fontSource);
    public static void CheckInvocationOfPlatformFontResolver();
    internal static void Reset();
    internal static string GetFontCachesState();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class PdfSharp.Fonts.FontFamilyCache : object {
    public static FontFamilyInternal GetFamilyByName(string familyName);
    public static FontFamilyInternal CacheOrGetFontFamily(FontFamilyInternal fontFamily);
    internal static void Reset();
    internal static string GetCacheState();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharp.Fonts.FontFamilyInternal : object {
    private string _sourceName;
    private string _name;
    public string SourceName { get; }
    public string Name { get; }
    internal string DebuggerDisplay { get; }
    private FontFamilyInternal(string familyName, bool createPlatformObjects);
    internal static FontFamilyInternal GetOrCreateFromName(string familyName, bool createPlatformObject);
    public string get_SourceName();
    public string get_Name();
    internal string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharp.Fonts.FontResolverInfo : object {
    private static string KeySuffix;
    [NullableAttribute("2")]
private string _key;
    [CompilerGeneratedAttribute]
private string <FaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MustSimulateBold>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MustSimulateItalic>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CollectionNumber>k__BackingField;
    internal string Key { get; }
    public string FaceName { get; }
    public bool MustSimulateBold { get; internal set; }
    public bool MustSimulateItalic { get; internal set; }
    public XStyleSimulations StyleSimulations { get; }
    internal int CollectionNumber { get; }
    internal string DebuggerDisplay { get; }
    public FontResolverInfo(string faceName);
    internal FontResolverInfo(string faceName, bool mustSimulateBold, bool mustSimulateItalic, int collectionNumber);
    public FontResolverInfo(string faceName, bool mustSimulateBold, bool mustSimulateItalic);
    public FontResolverInfo(string faceName, XStyleSimulations styleSimulations);
    internal string get_Key();
    [CompilerGeneratedAttribute]
public string get_FaceName();
    [CompilerGeneratedAttribute]
public bool get_MustSimulateBold();
    [CompilerGeneratedAttribute]
internal void set_MustSimulateBold(bool value);
    [CompilerGeneratedAttribute]
public bool get_MustSimulateItalic();
    [CompilerGeneratedAttribute]
internal void set_MustSimulateItalic(bool value);
    public XStyleSimulations get_StyleSimulations();
    [CompilerGeneratedAttribute]
internal int get_CollectionNumber();
    internal string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.FontWriter : object {
    private Stream _stream;
    public int Position { get; public set; }
    internal Stream Stream { get; }
    public FontWriter(Stream stream);
    public void Close(bool closeUnderlyingStream);
    public void Close();
    public int get_Position();
    public void set_Position(int value);
    public void WriteByte(byte value);
    public void WriteByte(int value);
    public void WriteShort(short value);
    public void WriteShort(int value);
    public void WriteUShort(ushort value);
    public void WriteUShort(int value);
    public void WriteInt(int value);
    public void WriteUInt(UInt32 value);
    public void Write(Byte[] buffer);
    public void Write(Byte[] buffer, int offset, int count);
    internal Stream get_Stream();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class PdfSharp.Fonts.GlobalFontSettings : object {
    [NullableAttribute("1")]
[ObsoleteAttribute("DefaultFontName is deprecated. Do not use it anymore. Use Arial instead.")]
public static string DefaultFontName_;
    public static IFontResolver FontResolver { get; public set; }
    public static IFontResolver FallbackFontResolver { get; public set; }
    public static PdfFontEncoding DefaultFontEncoding { get; public set; }
    public static IFontResolver get_FontResolver();
    public static void set_FontResolver(IFontResolver value);
    public static IFontResolver get_FallbackFontResolver();
    public static void set_FallbackFontResolver(IFontResolver value);
    [NullableContextAttribute("1")]
private static void SetFontResolver(IFontResolver value, IFontResolver& location);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("Not yet implemented.")]
private static void AddFontResolver(IFontResolverMarker fontResolver);
    internal static void ResetAll(bool calledFromResetFontManagement);
    public static PdfFontEncoding get_DefaultFontEncoding();
    public static void set_DefaultFontEncoding(PdfFontEncoding value);
    public static void ResetFontManagement();
    internal static void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class PdfSharp.Fonts.GlyphHelper : object {
    public static ushort GlyphIndexFromCodePoint(int codePoint, XFont font);
    public static CodePointGlyphIndexPair[] GlyphIndicesFromString(string s, XFont font);
}
internal class PdfSharp.Fonts.GlyphIndexGlyphColorRecordPair : ValueType {
    public ushort GlyphIndex;
    internal Nullable`1<GlyphRecord> ColorRecord;
    public GlyphIndexGlyphColorRecordPair(ushort glyphIndex, Nullable`1<GlyphRecord> colorRecord);
}
[NullableContextAttribute("1")]
public interface PdfSharp.Fonts.IFontResolver {
    public abstract virtual FontResolverInfo ResolveTypeface(string familyName, bool bold, bool italic);
    public abstract virtual Byte[] GetFont(string faceName);
}
public interface PdfSharp.Fonts.IFontResolver2 {
    [NullableContextAttribute("1")]
public abstract virtual FontResolverInfo ResolveTypeface(string familyName, XFontStyle style, XFontWeight weight, XFontStretch stretch);
    public abstract virtual ReadOnlyMemory`1<byte> GetFont(string faceName);
}
public interface PdfSharp.Fonts.IFontResolverMarker {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class PdfSharp.Fonts.Internal.FontHelper : object {
    public static XSize MeasureString(CodePointGlyphIndexPair[] codeRun, XFont font);
    public static XTypeface CreateTypeface(XFontFamily family, XFontStyleEx style);
    public static ulong CalcChecksum(Byte[] buffer);
    public static XFontStyleEx CreateStyle(bool isBold, bool isItalic);
    public static int CountGlyphs(XFont font);
}
internal class PdfSharp.Fonts.Internal.FontResolvingOptions : object {
    [CompilerGeneratedAttribute]
private XFontStyle <Style>k__BackingField;
    [CompilerGeneratedAttribute]
private XFontWeight <Weight>k__BackingField;
    [CompilerGeneratedAttribute]
private XFontStretch <Stretch>k__BackingField;
    [CompilerGeneratedAttribute]
private XFontStyleEx <FontStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OverrideStyleSimulations>k__BackingField;
    [CompilerGeneratedAttribute]
private XStyleSimulations <StyleSimulations>k__BackingField;
    public XFontStyle Style { get; }
    public XFontWeight Weight { get; }
    public XFontStretch Stretch { get; }
    public bool IsBold { get; }
    public bool IsItalic { get; }
    public bool IsBoldItalic { get; }
    public bool MustSimulateBold { get; }
    public bool MustSimulateItalic { get; }
    public XFontStyleEx FontStyle { get; }
    public bool OverrideStyleSimulations { get; }
    public XStyleSimulations StyleSimulations { get; }
    public FontResolvingOptions(XFontStyleEx fontStyle);
    public FontResolvingOptions(XFontStyleEx fontStyle, XStyleSimulations styleSimulations);
    public FontResolvingOptions(XFontStyle style, XFontWeight weight, XFontStretch stretch, Nullable`1<XStyleSimulations> styleSimulations);
    [CompilerGeneratedAttribute]
public XFontStyle get_Style();
    [CompilerGeneratedAttribute]
public XFontWeight get_Weight();
    [CompilerGeneratedAttribute]
public XFontStretch get_Stretch();
    public bool get_IsBold();
    public bool get_IsItalic();
    public bool get_IsBoldItalic();
    public bool get_MustSimulateBold();
    public bool get_MustSimulateItalic();
    [CompilerGeneratedAttribute]
public XFontStyleEx get_FontStyle();
    [CompilerGeneratedAttribute]
public bool get_OverrideStyleSimulations();
    [CompilerGeneratedAttribute]
public XStyleSimulations get_StyleSimulations();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class PdfSharp.Fonts.Internal.UnicodeHelper : object {
    internal static char HighSurrogateStart;
    internal static char HighSurrogateEnd;
    internal static char LowSurrogateStart;
    internal static char LowSurrogateEnd;
    internal static int HighSurrogateRange;
    internal static int UnicodePlane01Start;
    public static Int32[] Utf32FromString(string s, bool coerceAnsi, byte nonAnsi);
    public static Int32[] SymbolCodePointsFromString(string s, OpenTypeDescriptor openTypeDescriptor);
    public static int ConvertToUtf32(char highSurrogate, char lowSurrogate);
    internal static bool IsInRange(char c, char min, char max);
}
[DefaultMemberAttribute("Item")]
internal class PdfSharp.Fonts.OpenType.CharacterMap : object {
    private ushort _glyphCount;
    [NullableAttribute("1")]
private Dictionary`2<int, ushort> _map;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ushort Item { get; public set; }
    [NullableAttribute("1")]
public ICollection`1<int> Keys { get; }
    [NullableAttribute("1")]
public ICollection`1<ushort> Values { get; }
    internal void SetGlyphCount(ushort glyphCount);
    internal void SetCharacterEntry(int i, ushort value);
    private int GetGlyphPointer(int key);
    public sealed virtual IEnumerator`1<KeyValuePair`2<int, ushort>> GetEnumerator();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<int, ushort> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<int, ushort> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<int, ushort> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(int key, ushort value);
    public sealed virtual bool ContainsKey(int key);
    public sealed virtual bool Remove(int key);
    public sealed virtual bool TryGetValue(int key, UInt16& value);
    public sealed virtual ushort get_Item(int key);
    public sealed virtual void set_Item(int key, ushort value);
    [NullableContextAttribute("1")]
public sealed virtual ICollection`1<int> get_Keys();
    [NullableContextAttribute("1")]
public sealed virtual ICollection`1<ushort> get_Values();
}
internal class PdfSharp.Fonts.OpenType.CMap12 : OpenTypeFontTable {
    public WinEncodingId encodingId;
    public ushort format;
    public UInt32 length;
    public UInt32 language;
    public UInt32 numGroups;
    [NullableAttribute("1")]
public SequentialMapGroup[] groups;
    [NullableContextAttribute("1")]
public CMap12(OpenTypeFontFace fontData, WinEncodingId encodingId);
    internal void Read();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.OpenType.CMap4 : OpenTypeFontTable {
    public WinEncodingId encodingId;
    public ushort format;
    public ushort length;
    public ushort language;
    public ushort segCountX2;
    public ushort searchRange;
    public ushort entrySelector;
    public ushort rangeShift;
    public UInt16[] endCount;
    public UInt16[] startCount;
    public Int16[] idDelta;
    public UInt16[] idRangeOffs;
    public int glyphCount;
    public UInt16[] glyphIdArray;
    public CMap4(OpenTypeFontFace fontData, WinEncodingId encodingId);
    internal void Read();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.OpenType.CMapTable : OpenTypeFontTable {
    public static string Tag;
    public ushort version;
    public ushort numTables;
    public bool symbol;
    public CMap4 cmap4;
    public CMap12 cmap12;
    public CMapTable(OpenTypeFontFace fontData);
    internal void Read();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.OpenType.ColorPalletTable : OpenTypeFontTable {
    public static string Tag;
    public ushort version;
    public ushort numPaletteEntries;
    public ushort numPalettes;
    public ushort numColorRecords;
    public UInt32 colorRecordsArrayOffset;
    public UInt16[] colorRecordIndices;
    public XColor[] colorRecords;
    public ColorPalletTable(OpenTypeFontFace fontData);
    private void Read(OpenTypeFontFace fontData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.OpenType.ColorTable : OpenTypeFontTable {
    public static string Tag;
    public ushort version;
    public ushort numBaseGlyphRecords;
    public UInt32 baseGlyphRecordsOffset;
    public UInt32 layerRecordsOffset;
    public ushort numLayerRecords;
    public GlyphRecord[] baseGlyphRecords;
    public LayerRecord[] layerRecords;
    private Int32[] glyphRecordsHelperArray;
    public ColorTable(OpenTypeFontFace fontData);
    public Nullable`1<GlyphRecord> GetLayers(int glyphId);
    private void Read(OpenTypeFontFace fontData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.OpenType.ControlValueProgram : OpenTypeFontTable {
    public static string Tag;
    private Byte[] bytes;
    public ControlValueProgram(OpenTypeFontFace fontData);
    public void Read();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.OpenType.ControlValueTable : OpenTypeFontTable {
    public static string Tag;
    private Int16[] array;
    public ControlValueTable(OpenTypeFontFace fontData);
    public void Read();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.OpenType.FontDescriptor : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FontName2>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Weight>k__BackingField;
    [CompilerGeneratedAttribute]
private float <ItalicAngle>k__BackingField;
    [CompilerGeneratedAttribute]
private int <XMin>k__BackingField;
    [CompilerGeneratedAttribute]
private int <YMin>k__BackingField;
    [CompilerGeneratedAttribute]
private int <XMax>k__BackingField;
    [CompilerGeneratedAttribute]
private int <YMax>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFixedPitch>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UnderlinePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UnderlineThickness>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StrikeoutPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StrikeoutSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncodingScheme>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UnitsPerEm>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CapHeight>k__BackingField;
    [CompilerGeneratedAttribute]
private int <XHeight>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Ascender>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Descender>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Leading>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StemV>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineSpacing>k__BackingField;
    internal int GlobalVersion;
    public string Key { get; }
    public string FontName2 { get; public set; }
    public string Weight { get; private set; }
    public bool IsBoldFace { get; }
    public float ItalicAngle { get; protected set; }
    public bool IsItalicFace { get; }
    public int XMin { get; protected set; }
    public int YMin { get; protected set; }
    public int XMax { get; protected set; }
    public int YMax { get; protected set; }
    public bool IsFixedPitch { get; public set; }
    public int UnderlinePosition { get; protected set; }
    public int UnderlineThickness { get; protected set; }
    public int StrikeoutPosition { get; protected set; }
    public int StrikeoutSize { get; protected set; }
    public string Version { get; private set; }
    public string EncodingScheme { get; private set; }
    public int UnitsPerEm { get; protected set; }
    public int CapHeight { get; protected set; }
    public int XHeight { get; protected set; }
    public int Ascender { get; protected set; }
    public int Descender { get; protected set; }
    public int Leading { get; protected set; }
    public int Flags { get; private set; }
    public int StemV { get; protected set; }
    public int LineSpacing { get; protected set; }
    protected FontDescriptor(string key);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public string get_FontName2();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FontName2(string value);
    [CompilerGeneratedAttribute]
public string get_Weight();
    [CompilerGeneratedAttribute]
private void set_Weight(string value);
    public virtual bool get_IsBoldFace();
    [CompilerGeneratedAttribute]
public float get_ItalicAngle();
    [CompilerGeneratedAttribute]
protected void set_ItalicAngle(float value);
    public virtual bool get_IsItalicFace();
    [CompilerGeneratedAttribute]
public int get_XMin();
    [CompilerGeneratedAttribute]
protected void set_XMin(int value);
    [CompilerGeneratedAttribute]
public int get_YMin();
    [CompilerGeneratedAttribute]
protected void set_YMin(int value);
    [CompilerGeneratedAttribute]
public int get_XMax();
    [CompilerGeneratedAttribute]
protected void set_XMax(int value);
    [CompilerGeneratedAttribute]
public int get_YMax();
    [CompilerGeneratedAttribute]
protected void set_YMax(int value);
    [CompilerGeneratedAttribute]
public bool get_IsFixedPitch();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsFixedPitch(bool value);
    [CompilerGeneratedAttribute]
public int get_UnderlinePosition();
    [CompilerGeneratedAttribute]
protected void set_UnderlinePosition(int value);
    [CompilerGeneratedAttribute]
public int get_UnderlineThickness();
    [CompilerGeneratedAttribute]
protected void set_UnderlineThickness(int value);
    [CompilerGeneratedAttribute]
public int get_StrikeoutPosition();
    [CompilerGeneratedAttribute]
protected void set_StrikeoutPosition(int value);
    [CompilerGeneratedAttribute]
public int get_StrikeoutSize();
    [CompilerGeneratedAttribute]
protected void set_StrikeoutSize(int value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(string value);
    [CompilerGeneratedAttribute]
public string get_EncodingScheme();
    [CompilerGeneratedAttribute]
private void set_EncodingScheme(string value);
    [CompilerGeneratedAttribute]
public int get_UnitsPerEm();
    [CompilerGeneratedAttribute]
protected void set_UnitsPerEm(int value);
    [CompilerGeneratedAttribute]
public int get_CapHeight();
    [CompilerGeneratedAttribute]
protected void set_CapHeight(int value);
    [CompilerGeneratedAttribute]
public int get_XHeight();
    [CompilerGeneratedAttribute]
protected void set_XHeight(int value);
    [CompilerGeneratedAttribute]
public int get_Ascender();
    [CompilerGeneratedAttribute]
protected void set_Ascender(int value);
    [CompilerGeneratedAttribute]
public int get_Descender();
    [CompilerGeneratedAttribute]
protected void set_Descender(int value);
    [CompilerGeneratedAttribute]
public int get_Leading();
    [CompilerGeneratedAttribute]
protected void set_Leading(int value);
    [CompilerGeneratedAttribute]
public int get_Flags();
    [CompilerGeneratedAttribute]
private void set_Flags(int value);
    [CompilerGeneratedAttribute]
public int get_StemV();
    [CompilerGeneratedAttribute]
protected void set_StemV(int value);
    [CompilerGeneratedAttribute]
public int get_LineSpacing();
    [CompilerGeneratedAttribute]
protected void set_LineSpacing(int value);
    internal static string ComputeFdKey(string name, XFontStyleEx style);
    internal static string ComputeFdKey(string name, bool isBold, bool isItalic);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.OpenType.FontHeaderTable : OpenTypeFontTable {
    public static string Tag;
    public int version;
    public int fontRevision;
    public UInt32 checkSumAdjustment;
    public UInt32 magicNumber;
    public ushort flags;
    public ushort unitsPerEm;
    public long created;
    public long modified;
    public short xMin;
    public short yMin;
    public short xMax;
    public short yMax;
    public ushort macStyle;
    public ushort lowestRecPPEM;
    public short fontDirectionHint;
    public short indexToLocFormat;
    public short glyphDataFormat;
    public FontHeaderTable(OpenTypeFontFace fontData);
    public void Read();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.OpenType.FontProgram : OpenTypeFontTable {
    public static string Tag;
    private Byte[] bytes;
    public FontProgram(OpenTypeFontFace fontData);
    public void Read();
}
internal enum PdfSharp.Fonts.OpenType.FontTechnology : Enum {
    public int value__;
    public static FontTechnology PostscriptOutlines;
    public static FontTechnology TrueTypeOutlines;
    public static FontTechnology TrueTypeCollection;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.OpenType.GlyphDataTable : OpenTypeFontTable {
    public static string Tag;
    internal Byte[] GlyphTable;
    private static int ARG_1_AND_2_ARE_WORDS;
    private static int WE_HAVE_A_SCALE;
    private static int MORE_COMPONENTS;
    private static int WE_HAVE_AN_X_AND_Y_SCALE;
    private static int WE_HAVE_A_TWO_BY_TWO;
    public GlyphDataTable(OpenTypeFontFace fontData);
    public void Read();
    public Byte[] GetGlyphData(int glyph);
    public int GetGlyphSize(int glyph);
    public int GetOffset(int glyph);
    public void CompleteGlyphClosure(Dictionary`2<ushort, object> glyphs);
    private void AddCompositeGlyphs(Dictionary`2<ushort, object> glyphs, int glyph);
    public virtual void PrepareForCompilation();
    public virtual void Write(OpenTypeFontWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.OpenType.GlyphSubstitutionTable : OpenTypeFontTable {
    public static string Tag;
    public GlyphSubstitutionTable(OpenTypeFontFace fontData);
    public void Read();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class PdfSharp.Fonts.OpenType.GlyphTypefaceCache : object {
    public static bool TryGetGlyphTypeface(string key, XGlyphTypeface& glyphTypeface);
    public static void AddGlyphTypeface(XGlyphTypeface glyphTypeface);
    internal static void Reset();
    internal static string GetCacheState();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.OpenType.HorizontalHeaderTable : OpenTypeFontTable {
    public static string Tag;
    public int version;
    public short ascender;
    public short descender;
    public short lineGap;
    public ushort advanceWidthMax;
    public short minLeftSideBearing;
    public short minRightSideBearing;
    public short xMaxExtent;
    public short caretSlopeRise;
    public short caretSlopeRun;
    public short reserved1;
    public short reserved2;
    public short reserved3;
    public short reserved4;
    public short reserved5;
    public short metricDataFormat;
    public ushort numberOfHMetrics;
    public HorizontalHeaderTable(OpenTypeFontFace fontData);
    public void Read();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.OpenType.HorizontalMetrics : OpenTypeFontTable {
    public static string Tag;
    public ushort advanceWidth;
    public short lsb;
    public HorizontalMetrics(OpenTypeFontFace fontData);
    public void Read();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.OpenType.HorizontalMetricsTable : OpenTypeFontTable {
    public static string Tag;
    public HorizontalMetrics[] Metrics;
    public Int16[] LeftSideBearing;
    public HorizontalMetricsTable(OpenTypeFontFace fontData);
    public void Read();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.OpenType.IndexToLocationTable : OpenTypeFontTable {
    public static string Tag;
    internal Int32[] LocaTable;
    public bool ShortIndex;
    private Byte[] _bytes;
    public IndexToLocationTable(OpenTypeFontFace fontData);
    public void Read();
    public virtual void PrepareForCompilation();
    public virtual void Write(OpenTypeFontWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.OpenType.IRefFontTable : OpenTypeFontTable {
    private TableDirectoryEntry _irefDirectoryEntry;
    public IRefFontTable(OpenTypeFontFace fontData, OpenTypeFontTable fontTable);
    public virtual void PrepareForCompilation();
    public virtual void Write(OpenTypeFontWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.OpenType.MaximumProfileTable : OpenTypeFontTable {
    public static string Tag;
    public int version;
    public ushort numGlyphs;
    public ushort maxPoints;
    public ushort maxContours;
    public ushort maxCompositePoints;
    public ushort maxCompositeContours;
    public ushort maxZones;
    public ushort maxTwilightPoints;
    public ushort maxStorage;
    public ushort maxFunctionDefs;
    public ushort maxInstructionDefs;
    public ushort maxStackElements;
    public ushort maxSizeOfInstructions;
    public ushort maxComponentElements;
    public ushort maxComponentDepth;
    public MaximumProfileTable(OpenTypeFontFace fontData);
    public void Read();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.OpenType.NameTable : OpenTypeFontTable {
    public static string Tag;
    public string Name;
    public string Style;
    public string FullFontName;
    public ushort format;
    public ushort count;
    public ushort stringOffset;
    private Byte[] bytes;
    public NameTable(OpenTypeFontFace fontData);
    public void Read();
    private NameRecord ReadNameRecord();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.OpenType.OpenTypeDescriptor : FontDescriptor {
    internal OpenTypeFontFace FontFace;
    public Int32[] Widths;
    public bool IsBoldFace { get; }
    public bool IsItalicFace { get; }
    public bool IsSymbolFont { get; }
    public OpenTypeDescriptor(string fontDescriptorKey, XFont font);
    public OpenTypeDescriptor(string fontDescriptorKey, XGlyphTypeface glyphTypeface);
    internal OpenTypeDescriptor(string fontDescriptorKey, string idName, Byte[] fontData);
    private void Initialize();
    public virtual bool get_IsBoldFace();
    public virtual bool get_IsItalicFace();
    internal int DesignUnitsToPdf(double value);
    public ushort BmpCodepointToGlyphIndex(char ch);
    public ushort SurrogatePairToGlyphIndex(char highSurrogate, char lowSurrogate);
    public ushort CodepointToGlyphIndex(int codePoint);
    public int GlyphIndexToPdfWidth(ushort glyphIndex);
    public double GlyphIndexToEmWidth(UInt32 glyphIndex, double emSize);
    public int GlyphIndexToWidth(int glyphIndex);
    public bool get_IsSymbolFont();
    public CodePointGlyphIndexPair[] GlyphIndicesFromString(string s, bool useAnsiCharactersOnly);
    public CodePointGlyphIndexPair[] GlyphIndicesFromCodePoints(Int32[] codePoints, bool useAnsiCharactersOnly);
    public Nullable`1[] GlyphColorRecordsFromGlyphIndices(CodePointGlyphIndexPair[] pairs);
    public char RemapSymbolChar(char ch);
    public Nullable`1<GlyphRecord> GetColorRecord(int glyphIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
internal class PdfSharp.Fonts.OpenType.OpenTypeFontFace : object {
    private string _fullFaceName;
    private ulong _checkSum;
    private PdfFontEmbedding _fontEmbedding;
    [NullableAttribute("2")]
private XFontSource _fontSource;
    private Nullable`1<FontTechnology> _fontTechnology;
    private OffsetTable _offsetTable;
    internal Dictionary`2<string, TableDirectoryEntry> TableDictionary;
    internal CMapTable cmap;
    [NullableAttribute("2")]
internal ColorTable colr;
    [NullableAttribute("2")]
internal ColorPalletTable cpal;
    internal ControlValueTable cvt;
    internal FontProgram fpgm;
    internal MaximumProfileTable maxp;
    internal NameTable name;
    [NullableAttribute("2")]
internal ControlValueProgram prep;
    [NullableAttribute("2")]
internal FontHeaderTable head;
    internal HorizontalHeaderTable hhea;
    internal HorizontalMetricsTable hmtx;
    internal OS2Table os2;
    internal PostScriptTable post;
    internal GlyphDataTable glyf;
    internal IndexToLocationTable loca;
    internal GlyphSubstitutionTable gsub;
    [NullableAttribute("2")]
internal VerticalHeaderTable vhea;
    [NullableAttribute("2")]
internal VerticalMetricsTable vmtx;
    private static Int32[] _entrySelectors;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    public string FullFaceName { get; }
    public ulong CheckSum { get; }
    public XFontSource FontSource { get; private set; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public int Position { get; public set; }
    internal string DebuggerDisplay { get; }
    private OpenTypeFontFace(OpenTypeFontFace fontFace);
    public OpenTypeFontFace(Byte[] data, string faceName);
    public OpenTypeFontFace(XFontSource fontSource);
    private static OpenTypeFontFace();
    public static OpenTypeFontFace CetOrCreateFrom(XFontSource fontSource);
    public string get_FullFaceName();
    public ulong get_CheckSum();
    public void SetFontEmbedding(PdfFontEmbedding fontEmbedding);
    public XFontSource get_FontSource();
    private void set_FontSource(XFontSource value);
    public bool get_CanRead();
    public bool get_CanWrite();
    public void AddTable(OpenTypeFontTable fontTable);
    internal void Read();
    public OpenTypeFontFace CreateFontSubset(Dictionary`2<ushort, object> glyphs, bool cidFont);
    private void Compile();
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(int value);
    public int Seek(string tag);
    public int SeekOffset(int offset);
    public byte ReadByte();
    public short ReadShort();
    public ushort ReadUShort();
    public int ReadLong();
    public UInt32 ReadULong();
    public int ReadFixed();
    public short ReadFWord();
    public ushort ReadUFWord();
    public long ReadLongDate();
    public string ReadString(int size);
    public Byte[] ReadBytes(int size);
    public void Read(Byte[] buffer);
    public void Read(Byte[] buffer, int offset, int length);
    public string ReadTag();
    internal string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
internal static class PdfSharp.Fonts.OpenType.OpenTypeFontFaceCache : object {
    private static string DebuggerDisplay { get; }
    public static bool TryGetFontFace(string key, OpenTypeFontFace& fontFace);
    public static bool TryGetFontFace(ulong checkSum, OpenTypeFontFace& fontFace);
    public static OpenTypeFontFace AddFontFace(OpenTypeFontFace fontFace);
    internal static void Reset();
    internal static string GetCacheState();
    private static string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.OpenType.OpenTypeFontTable : object {
    [NullableAttribute("2")]
internal OpenTypeFontFace _fontData;
    public TableDirectoryEntry DirectoryEntry;
    [NullableAttribute("2")]
public OpenTypeFontFace FontData { get; }
    public OpenTypeFontTable(OpenTypeFontFace fontData, string tag);
    public sealed virtual object Clone();
    protected virtual OpenTypeFontTable DeepCopy();
    [NullableContextAttribute("2")]
public OpenTypeFontFace get_FontData();
    public virtual void PrepareForCompilation();
    public virtual void Write(OpenTypeFontWriter writer);
    public static UInt32 CalcChecksum(Byte[] bytes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.OpenType.OpenTypeFontWriter : FontWriter {
    public OpenTypeFontWriter(Stream stream);
    public void WriteTag(string tag);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.OpenType.OS2Table : OpenTypeFontTable {
    public static string Tag;
    public ushort version;
    public short xAvgCharWidth;
    public ushort usWeightClass;
    public ushort usWidthClass;
    public ushort fsType;
    public short ySubscriptXSize;
    public short ySubscriptYSize;
    public short ySubscriptXOffset;
    public short ySubscriptYOffset;
    public short ySuperscriptXSize;
    public short ySuperscriptYSize;
    public short ySuperscriptXOffset;
    public short ySuperscriptYOffset;
    public short yStrikeoutSize;
    public short yStrikeoutPosition;
    public short sFamilyClass;
    public Byte[] panose;
    public UInt32 ulUnicodeRange1;
    public UInt32 ulUnicodeRange2;
    public UInt32 ulUnicodeRange3;
    public UInt32 ulUnicodeRange4;
    public string achVendID;
    public ushort fsSelection;
    public ushort usFirstCharIndex;
    public ushort usLastCharIndex;
    public short sTypoAscender;
    public short sTypoDescender;
    public short sTypoLineGap;
    public ushort usWinAscent;
    public ushort usWinDescent;
    public UInt32 ulCodePageRange1;
    public UInt32 ulCodePageRange2;
    public short sxHeight;
    public short sCapHeight;
    public ushort usDefaultChar;
    public ushort usBreakChar;
    public ushort usMaxContext;
    public bool IsBold { get; }
    public bool IsItalic { get; }
    public OS2Table(OpenTypeFontFace fontData);
    public void Read();
    public bool get_IsBold();
    public bool get_IsItalic();
}
internal enum PdfSharp.Fonts.OpenType.PlatformId : Enum {
    public int value__;
    public static PlatformId Apple;
    public static PlatformId Mac;
    public static PlatformId Iso;
    public static PlatformId Win;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.OpenType.PostScriptTable : OpenTypeFontTable {
    public static string Tag;
    public int formatType;
    public float italicAngle;
    public short underlinePosition;
    public short underlineThickness;
    public ulong isFixedPitch;
    public ulong minMemType42;
    public ulong maxMemType42;
    public ulong minMemType1;
    public ulong maxMemType1;
    public PostScriptTable(OpenTypeFontFace fontData);
    public void Read();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.OpenType.TableDirectoryEntry : object {
    public string Tag;
    public UInt32 CheckSum;
    public int Offset;
    public int Length;
    public OpenTypeFontTable FontTable;
    public int PaddedLength { get; }
    public TableDirectoryEntry(string tag);
    public int get_PaddedLength();
    public static TableDirectoryEntry ReadFrom(OpenTypeFontFace fontData);
    public void Read(OpenTypeFontFace fontData);
    public void Write(OpenTypeFontWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class PdfSharp.Fonts.OpenType.TableTagNames : object {
    public static string CMap;
    public static string Head;
    public static string HHea;
    public static string HMtx;
    public static string MaxP;
    public static string Name;
    public static string OS2;
    public static string Post;
    public static string Cvt;
    public static string Fpgm;
    public static string Glyf;
    public static string Loca;
    public static string Prep;
    public static string Cff;
    public static string VOrg;
    public static string EBDT;
    public static string EBLC;
    public static string EBSC;
    public static string BASE;
    public static string GDEF;
    public static string GPOS;
    public static string GSUB;
    public static string JSTF;
    public static string COLR;
    public static string CPAL;
    public static string DSIG;
    public static string Gasp;
    public static string Hdmx;
    public static string Kern;
    public static string LTSH;
    public static string PCLT;
    public static string VDMX;
    public static string VHea;
    public static string VMtx;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.OpenType.VerticalHeaderTable : OpenTypeFontTable {
    public static string Tag;
    public int Version;
    public short Ascender;
    public short Descender;
    public short LineGap;
    public ushort AdvanceWidthMax;
    public short MinLeftSideBearing;
    public short MinRightSideBearing;
    public short xMaxExtent;
    public short caretSlopeRise;
    public short caretSlopeRun;
    public short reserved1;
    public short reserved2;
    public short reserved3;
    public short reserved4;
    public short reserved5;
    public short metricDataFormat;
    public ushort numberOfHMetrics;
    public VerticalHeaderTable(OpenTypeFontFace fontData);
    public void Read();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.OpenType.VerticalMetrics : OpenTypeFontTable {
    public static string Tag;
    public ushort advanceWidth;
    public short lsb;
    public VerticalMetrics(OpenTypeFontFace fontData);
    public void Read();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Fonts.OpenType.VerticalMetricsTable : OpenTypeFontTable {
    public static string Tag;
    public HorizontalMetrics[] metrics;
    public Int16[] leftSideBearing;
    public VerticalMetricsTable(OpenTypeFontFace fontData);
    public void Read();
}
internal enum PdfSharp.Fonts.OpenType.WinEncodingId : Enum {
    public int value__;
    public static WinEncodingId Symbol;
    public static WinEncodingId UnicodeUSC_2;
    public static WinEncodingId UnicodeUSC_4;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class PdfSharp.Fonts.PlatformFontResolver : object {
    private static IFontResolver CoreBuildFontResolver;
    private static PlatformFontResolver();
    public static FontResolverInfo ResolveTypeface(string familyName, bool bold, bool italic);
    internal static FontResolverInfo ResolveTypeface(string familyName, FontResolvingOptions fontResolvingOptions, string typefaceKey);
    internal static FontResolverInfo TryCoreBuildFontResolver(string familyName, FontResolvingOptions fontResolvingOptions, string typefaceKey);
}
internal class PdfSharp.Fonts.PlatformFontResolverInfo : FontResolverInfo {
    [NullableContextAttribute("1")]
public PlatformFontResolverInfo(string faceName, bool mustSimulateBold, bool mustSimulateItalic);
}
internal static class PdfSharp.Internal.Calc : object {
    public static double Deg2Rad;
    public static XSize PageSizeToSize(PageSize value);
}
internal static class PdfSharp.Internal.ColorHelper : object {
    public static float sRgbToScRgb(byte bval);
    public static byte ScRgbTosRgb(float val);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class PdfSharp.Internal.ContentReaderDiagnostics : object {
    public static void ThrowContentReaderException(string message);
    public static void ThrowContentReaderException(string message, Exception innerException);
    public static void ThrowNumberOutOfIntegerRange(long value);
    public static void HandleUnexpectedCharacter(char ch);
}
public static class PdfSharp.Internal.DebugBreak : object {
    public static void Break(bool always);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class PdfSharp.Internal.DiagnosticsHelper : object {
    public static void HandleNotImplemented(string message, FeatureNotAvailableBehavior behavior);
    public static void ThrowNotImplementedException(string message);
    public static void ThrowNotSupportedException(string message);
}
public static class PdfSharp.Internal.DoubleUtil : object {
    private static double Epsilon;
    private static double TenTimesEpsilon;
    private static float FloatMinimum;
    [NullableAttribute("1")]
private static Double[] decs;
    private static DoubleUtil();
    public static bool AreClose(double value1, double value2);
    public static bool AreRoughlyEqual(double value1, double value2, int decimalPlace);
    public static bool AreClose(XPoint point1, XPoint point2);
    public static bool AreClose(XRect rect1, XRect rect2);
    public static bool AreClose(XSize size1, XSize size2);
    public static bool AreClose(XVector vector1, XVector vector2);
    public static bool GreaterThan(double value1, double value2);
    public static bool GreaterThanOrClose(double value1, double value2);
    public static bool LessThan(double value1, double value2);
    public static bool LessThanOrClose(double value1, double value2);
    public static bool IsBetweenZeroAndOne(double value);
    public static bool IsNaN(double value);
    public static bool RectHasNaN(XRect r);
    public static bool IsOne(double value);
    public static bool IsZero(double value);
    public static int DoubleToInt(double value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class PdfSharp.Internal.FontsDevHelper : object {
    public static XFont CreateSpecialFont(string familyName, double emSize, XFontStyleEx style, XPdfFontOptions pdfOptions, XStyleSimulations styleSimulations);
    public static string GetFontCachesState();
    public static ValueTuple`2<string, string> TryGetStretchAndWeight(XGlyphTypeface glyphTypeface);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Internal.Globals : object {
    private int _version;
    public FontStorage Fonts;
    private static int _globalVersionCount;
    private static Globals _global;
    public static Globals Global { get; }
    public int Version { get; }
    private static Globals();
    public static Globals get_Global();
    internal void RecreateGlobals();
    internal void IncrementVersion();
    public int get_Version();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class PdfSharp.Internal.Lock : object {
    private static object GdiPlusLock;
    private static int _gdiPlusLockCount;
    private static object FontFactoryLock;
    private static int _fontFactoryLockCount;
    public static bool IsGdiPlusLockedByCurrentThread { get; }
    public static bool IsFontFactoryLockedByCurrentThread { get; }
    private static Lock();
    public static void EnterGdiPlus();
    public static void ExitGdiPlus();
    public static bool get_IsGdiPlusLockedByCurrentThread();
    public static bool IsGdiPlusLookTaken();
    public static void EnterFontFactory();
    public static void ExitFontFactory();
    public static bool get_IsFontFactoryLockedByCurrentThread();
    public static bool IsFontFactoryLookTaken();
}
internal enum PdfSharp.Internal.NotSupportedBehavior : Enum {
    public int value__;
    public static NotSupportedBehavior DoNothing;
    public static NotSupportedBehavior Log;
    public static NotSupportedBehavior LogError;
    public static NotSupportedBehavior Throw;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class PdfSharp.Internal.ParserDiagnostics : object {
    public static void ThrowParserException(string message);
    public static void ThrowParserException(string message, Exception innerException);
    public static void HandleUnexpectedCharacter(char ch, string dump);
    public static void HandleUnexpectedToken(string token, string dump);
    public static void CannotFindEndOfStream(PdfDictionary dict);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class PdfSharp.Internal.PsMsg : ValueType {
    [CompilerGeneratedAttribute]
private PsMsgId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public PsMsgId Id { get; public set; }
    public string Message { get; public set; }
    public EventId EventId { get; }
    public string EventName { get; }
    public PsMsg(PsMsgId id, string message);
    [CompilerGeneratedAttribute]
public PsMsgId get_Id();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Id(PsMsgId value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Message(string value);
    public EventId get_EventId();
    public string get_EventName();
}
internal enum PdfSharp.Internal.PsMsgId : Enum {
    public int value__;
    public static PsMsgId None;
    public static PsMsgId SampleMessage1;
    public static PsMsgId SampleMessage2;
    public static PsMsgId NameMustStartWithSlash;
    public static PsMsgId UserOrOwnerPasswordRequired;
    public static PsMsgId UnexpectedToken;
    public static PsMsgId UnknownEncryption;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class PdfSharp.Internal.PsMsgs : object {
    public static string ListEnumCurrentOutOfRange { get; }
    public static string PageIndexOutOfRange { get; }
    public static string OutlineIndexOutOfRange { get; }
    public static string SetValueMustNotBeNull { get; }
    public static string ObsoleteFunctionCalled { get; }
    public static string OwningDocumentRequired { get; }
    public static string FontDataReadOnly { get; }
    public static string ErrorReadingFontData { get; }
    public static string PointArrayEmpty { get; }
    public static string NeedPenOrBrush { get; }
    public static string InvalidPdf { get; }
    public static string PasswordRequired { get; }
    public static string InvalidPassword { get; }
    public static string OwnerPasswordRequired { get; }
    public static string UserOrOwnerPasswordRequired { get; }
    public static string CannotModify { get; }
    public static string NameMustStartWithSlash { get; }
    public static string MultiplePageInsert { get; }
    public static string UnexpectedTokenInPdfFile { get; }
    public static string get_ListEnumCurrentOutOfRange();
    public static string get_PageIndexOutOfRange();
    public static string get_OutlineIndexOutOfRange();
    public static string get_SetValueMustNotBeNull();
    public static string InvalidValue(int val, string name, int min, int max);
    public static string get_ObsoleteFunctionCalled();
    public static string get_OwningDocumentRequired();
    public static string FileNotFound(string path);
    public static string get_FontDataReadOnly();
    public static string get_ErrorReadingFontData();
    public static string get_PointArrayEmpty();
    public static string PointArrayAtLeast(int count);
    public static string get_NeedPenOrBrush();
    public static string CannotChangeImmutableObject(string typename);
    public static string FontAlreadyAdded(string fontName);
    public static string NotImplementedForFontsRetrievedWithFontResolver(string name);
    public static string get_InvalidPdf();
    public static string InvalidVersionNumber(int value);
    public static string get_PasswordRequired();
    public static string get_InvalidPassword();
    public static string get_OwnerPasswordRequired();
    public static string get_UserOrOwnerPasswordRequired();
    public static string get_CannotModify();
    public static string get_NameMustStartWithSlash();
    public static string ImportPageNumberOutOfRange(int pageNumber, int maxPage, string path);
    public static string get_MultiplePageInsert();
    public static string get_UnexpectedTokenInPdfFile();
    public static string InappropriateColorSpace(PdfColorMode colorMode, XColorSpace colorSpace);
    public static string CannotGetGlyphTypeface(string fontName);
    public static string UnexpectedToken(string token);
}
internal class PdfSharp.Internal.SCColor : ValueType {
    public float a;
    public float r;
    public float g;
    public float b;
}
internal class PdfSharp.Internal.SColor : ValueType {
    public byte a;
    public byte r;
    public byte g;
    public byte b;
}
internal class PdfSharp.Internal.SuppressExceptions : object {
    [CompilerGeneratedAttribute]
private bool <ErrorOccurred>k__BackingField;
    public bool ErrorOccurred { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_ErrorOccurred();
    [CompilerGeneratedAttribute]
private void set_ErrorOccurred(bool value);
    [NullableContextAttribute("1")]
public static void HandleError(SuppressExceptions suppressExceptions, Action throwException);
    [NullableContextAttribute("2")]
public static bool HasError(SuppressExceptions suppressExceptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class PdfSharp.Internal.TH : object {
    private static string SendUsTheFile;
    public static InvalidOperationException InvalidOperationException_CouldNotFindMetadataDictionary();
    public static ObjectNotAvailableException ObjectNotAvailableException_CannotRetrieveStreamLength(Exception innerException);
    public static InvalidOperationException InvalidOperationException_ReferencesOfObjectStreamNotYetRead();
    public static PdfReaderException PdfReaderException_ObjectCouldNotBeFoundInObjectStreams();
    public static PdfReaderException PdfReaderException_UnknownEncryption();
    public static InvalidOperationException InvalidOperationException_NoEncryptionSet();
    public static InvalidOperationException InvalidOperationException_EncryptionRevisionValueNotYetCalculated();
    public static CryptographicException CryptographicException_InputDataTooShort();
    public static InvalidOperationException InvalidOperationException_InvalidVersionValueForEncryptionVersion1To4();
    public static InvalidOperationException InvalidOperationException_InvalidPasswordKeyLengthForEncryptionVersion1To4(int len);
    public static InvalidOperationException InvalidOperationException_EncryptionKeyNotSetForEncryptionVersion1To4();
    public static InvalidOperationException InvalidOperationException_InvalidKeyLengthForEncryptionVersion2();
    public static InvalidOperationException InvalidOperationException_AESNotSupportedForChosenEncryptionVersion();
    public static InvalidOperationException InvalidOperationException_InvalidVersionValueForEncryptionVersion5();
    public static InvalidOperationException InvalidOperationException_InvalidRevisionValueForEncryptionVersion5();
    public static InvalidOperationException InvalidOperationException_InvalidLengthValueForEncryptionVersion5();
    public static PdfReaderException PdfReaderException_CouldNotVerifyPWithPermsKey();
    public static NotImplementedException NotImplementedException_EncryptEmbeddedFileStreamsOnlyCurrentlyShutOff();
    public static InvalidOperationException InvalidOperationException_InvalidVersionForEncryptEmbeddedFilesOnly();
    public static InvalidOperationException InvalidOperationException_MissingDefaultCryptFilter(string filterName);
    public static InvalidOperationException InvalidOperationException_CryptFiltersNotSupportedForChosenEncryptionVersion();
    public static InvalidOperationException InvalidOperationException_CryptFiltersNotSupportedForChosenEncryptionRevision();
    public static InvalidOperationException InvalidOperationException_CryptFiltersNeededForChosenEncryptionVersion();
    public static InvalidOperationException InvalidOperationException_InvalidCryptFilterMethod();
    public static InvalidOperationException InvalidOperationException_InvalidCryptFilterMethodForEncryptionRevision4();
    public static InvalidOperationException InvalidOperationException_InvalidCryptFilterMethodForEncryptionRevision6();
    public static InvalidOperationException InvalidOperationException_InvalidLengthValueForCryptFilterMethodV2();
    public static InvalidOperationException InvalidOperationException_InvalidLengthValueForCryptFilterMethodAESV2();
    public static InvalidOperationException InvalidOperationException_InvalidLengthValueForCryptFilterMethodAESV3();
    public static InvalidOperationException InvalidOperationException_CryptFilterDecodeParmsNotInitializedCorrectly();
    public static ArgumentException ArgumentException_UnknownCryptFilter();
    public static ArgumentException ArgumentException_UnknownCryptFilterSetToDefault();
    public static ArgumentException ArgumentException_WrappingSASLprepException(Exception innerException);
    public static ArgumentException ArgumentException_SASLprepProhibitedCharacter(int codePoint, int position);
    public static ArgumentException ArgumentException_SASLprepProhibitedUnassignedCodepoint(int codePoint, int position);
    public static ArgumentException ArgumentException_SASLprepRandALCatAndLCatCharacters();
    public static ArgumentException ArgumentException_SASLprepRandALCatButFirstOrLastDivergent();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class PdfSharp.Internal.TokenizerHelper : object {
    private bool _foundSeparator;
    private char _argSeparator;
    private int _charIndex;
    private int _currentTokenIndex;
    private int _currentTokenLength;
    private char _quoteChar;
    private string _str;
    private int _strLen;
    public bool FoundSeparator { get; }
    [NullableContextAttribute("1")]
public TokenizerHelper(string str, IFormatProvider formatProvider);
    public TokenizerHelper(string str, char quoteChar, char separator);
    private void Initialize(string str, char quoteChar, char separator);
    public string NextTokenRequired();
    public string NextTokenRequired(bool allowQuotedToken);
    public string GetCurrentToken();
    public void LastTokenRequired();
    public bool NextToken();
    public bool NextToken(bool allowQuotedToken);
    public bool NextToken(bool allowQuotedToken, char separator);
    private void ScanToNextToken(char separator);
    public static char GetNumericListSeparator(IFormatProvider provider);
    public bool get_FoundSeparator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class PdfSharp.Logging.LogMessages : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.9.3103")]
private static Action`3<ILogger, string, Exception> __PdfDocumentCreatedCallback;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.9.3103")]
private static Action`3<ILogger, string, Exception> __PdfDocumentSavedCallback;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.9.3103")]
private static Action`3<ILogger, string, Exception> __NewPdfPageCreatedCallback;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.9.3103")]
private static Action`3<ILogger, string, Exception> __ExistingPdfPageAddedCallback;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.9.3103")]
private static Action`3<ILogger, string, Exception> __XGraphicsCreatedCallback;
    private static LogMessages();
    [ExtensionAttribute]
[LoggerMessageAttribute]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.9.3103")]
public static void PdfDocumentCreated(ILogger logger, string documentName);
    [ExtensionAttribute]
[LoggerMessageAttribute]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.9.3103")]
public static void PdfDocumentSaved(ILogger logger, string documentName);
    [ExtensionAttribute]
[LoggerMessageAttribute]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.9.3103")]
public static void NewPdfPageCreated(ILogger logger, string documentName);
    [ExtensionAttribute]
[LoggerMessageAttribute]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.9.3103")]
public static void ExistingPdfPageAdded(ILogger logger, string documentName);
    [ExtensionAttribute]
[LoggerMessageAttribute]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.9.3103")]
public static void XGraphicsCreated(ILogger logger, string source);
}
public static class PdfSharp.Logging.PdfSharpEvent : object {
    public static EventId DocumentCreate;
    public static EventId DocumentSaved;
    public static EventId PageCreate;
    public static EventId PageAdded;
    public static EventId FontCreate;
    public static EventId PdfReaderIssue;
    public static EventId Placeholder;
    private static PdfSharpEvent();
}
public static class PdfSharp.Logging.PdfSharpEventId : object {
    public static int DocumentCreated;
    public static int DocumentSaved;
    public static int PageCreated;
    public static int PageAdded;
    public static int GraphicsCreated;
    public static int FontCreated;
    public static int PdfReaderIssue;
    internal static int Placeholder;
    private static int StartId;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class PdfSharp.Logging.PdfSharpEventName : object {
    public static string DocumentCreated;
    public static string DocumentSaved;
    public static string PageCreated;
    public static string PageAdded;
    public static string GraphicsCreated;
    public static string FontCreated;
    public static string PdfReaderIssue;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class PdfSharp.Logging.PdfSharpLogCategory : object {
    public static string DocumentProcessing;
    public static string ImageProcessing;
    public static string FontManagement;
    public static string PdfReading;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class PdfSharp.Logging.PdfSharpLogHost : object {
    [NullableAttribute("2")]
private static ILogger _documentProcessingLogger;
    [NullableAttribute("2")]
private static ILogger _imageProcessingLogger;
    [NullableAttribute("2")]
private static ILogger _fontManagementLogger;
    [NullableAttribute("2")]
private static ILogger _pdfReadingLogger;
    [NullableAttribute("2")]
private static ILoggerFactory _factory;
    public static ILogger Logger { get; }
    public static ILogger DocumentProcessingLogger { get; }
    public static ILogger ImageProcessingLogger { get; }
    public static ILogger FontManagementLogger { get; }
    public static ILogger PdfReadingLogger { get; }
    public static ILogger get_Logger();
    public static ILogger get_DocumentProcessingLogger();
    public static ILogger get_ImageProcessingLogger();
    public static ILogger get_FontManagementLogger();
    public static ILogger get_PdfReadingLogger();
    private static void CheckFactoryHasChanged();
    internal static void ResetLogging();
}
public enum PdfSharp.PageOrientation : Enum {
    public int value__;
    public static PageOrientation Portrait;
    public static PageOrientation Landscape;
}
public enum PdfSharp.PageRotation : Enum {
    public int value__;
    public static PageRotation None;
    public static PageRotation Rotate90DegreesRight;
    public static PageRotation RotateUpsideDown;
    public static PageRotation Rotate90DegreesLeft;
}
public enum PdfSharp.PageSize : Enum {
    public int value__;
    public static PageSize Undefined;
    public static PageSize A0;
    public static PageSize A1;
    public static PageSize A2;
    public static PageSize A3;
    public static PageSize A4;
    public static PageSize A5;
    public static PageSize RA0;
    public static PageSize RA1;
    public static PageSize RA2;
    public static PageSize RA3;
    public static PageSize RA4;
    public static PageSize RA5;
    public static PageSize B0;
    public static PageSize B1;
    public static PageSize B2;
    public static PageSize B3;
    public static PageSize B4;
    public static PageSize B5;
    public static PageSize Quarto;
    public static PageSize Foolscap;
    public static PageSize Executive;
    public static PageSize GovernmentLetter;
    public static PageSize Letter;
    public static PageSize Legal;
    public static PageSize Ledger;
    public static PageSize Tabloid;
    public static PageSize Post;
    public static PageSize Crown;
    public static PageSize LargePost;
    public static PageSize Demy;
    public static PageSize Medium;
    public static PageSize Royal;
    public static PageSize Elephant;
    public static PageSize DoubleDemy;
    public static PageSize QuadDemy;
    public static PageSize STMT;
    public static PageSize Folio;
    public static PageSize Statement;
    public static PageSize Size10x14;
}
public static class PdfSharp.PageSizeConverter : object {
    public static XSize ToSize(PageSize value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public abstract class PdfSharp.Pdf.AcroForms.PdfAcroField : PdfDictionary {
    [NullableAttribute("2")]
private PdfAcroFieldCollection _fields;
    public string Name { get; }
    public PdfAcroFieldFlags Flags { get; }
    internal PdfAcroFieldFlags SetFlags { get; internal set; }
    [NullableAttribute("2")]
public PdfItem Value { get; public set; }
    public bool ReadOnly { get; public set; }
    [NullableAttribute("2")]
public PdfAcroField Item { get; }
    public bool HasKids { get; }
    [ObsoleteAttribute("Use GetDescendantNames")]
public String[] DescendantNames { get; }
    public PdfAcroFieldCollection Fields { get; }
    internal PdfAcroField(PdfDocument document);
    protected PdfAcroField(PdfDictionary dict);
    public string get_Name();
    public PdfAcroFieldFlags get_Flags();
    internal PdfAcroFieldFlags get_SetFlags();
    internal void set_SetFlags(PdfAcroFieldFlags value);
    [NullableContextAttribute("2")]
public virtual PdfItem get_Value();
    [NullableContextAttribute("2")]
public virtual void set_Value(PdfItem value);
    public bool get_ReadOnly();
    public void set_ReadOnly(bool value);
    public PdfAcroField get_Item(string name);
    protected virtual PdfAcroField GetValue(string name);
    public bool get_HasKids();
    public String[] get_DescendantNames();
    public String[] GetDescendantNames();
    public String[] GetAppearanceNames();
    private static void AppDict(PdfDictionary dict, Dictionary`2<string, object> names);
    private static void AppDict2(PdfDictionary dict, Dictionary`2<string, object> names);
    internal virtual void GetDescendantNames(List`1& names, string partialName);
    public PdfAcroFieldCollection get_Fields();
}
[FlagsAttribute]
public enum PdfSharp.Pdf.AcroForms.PdfAcroFieldFlags : Enum {
    public int value__;
    public static PdfAcroFieldFlags ReadOnly;
    public static PdfAcroFieldFlags Required;
    public static PdfAcroFieldFlags NoExport;
    public static PdfAcroFieldFlags Pushbutton;
    public static PdfAcroFieldFlags Radio;
    public static PdfAcroFieldFlags NoToggleToOff;
    public static PdfAcroFieldFlags RadiosInUnison;
    public static PdfAcroFieldFlags Multiline;
    public static PdfAcroFieldFlags Password;
    public static PdfAcroFieldFlags FileSelect;
    public static PdfAcroFieldFlags DoNotSpellCheckTextField;
    public static PdfAcroFieldFlags DoNotScroll;
    public static PdfAcroFieldFlags CombTextField;
    public static PdfAcroFieldFlags RichTextTextField;
    public static PdfAcroFieldFlags Combo;
    public static PdfAcroFieldFlags Edit;
    public static PdfAcroFieldFlags Sort;
    public static PdfAcroFieldFlags MultiSelect;
    public static PdfAcroFieldFlags DoNotSpellCheckChoiceField;
    public static PdfAcroFieldFlags CommitOnSelChangeChoiceField;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.AcroForms.PdfAcroForm : PdfDictionary {
    [NullableAttribute("2")]
private PdfAcroFieldCollection _fields;
    public PdfAcroFieldCollection Fields { get; }
    internal DictionaryMeta Meta { get; }
    internal PdfAcroForm(PdfDocument document);
    internal PdfAcroForm(PdfDictionary dictionary);
    public PdfAcroFieldCollection get_Fields();
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class PdfSharp.Pdf.AcroForms.PdfButtonField : PdfAcroField {
    protected PdfButtonField(PdfDocument document);
    protected PdfButtonField(PdfDictionary dict);
    protected string GetNonOffValue();
    internal virtual void GetDescendantNames(List`1& names, string partialName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.AcroForms.PdfCheckBoxField : PdfButtonField {
    private string _checkedName;
    private string _uncheckedName;
    public bool Checked { get; public set; }
    public string CheckedName { get; public set; }
    public string UncheckedName { get; public set; }
    internal DictionaryMeta Meta { get; }
    internal PdfCheckBoxField(PdfDocument document);
    internal PdfCheckBoxField(PdfDictionary dict);
    public bool get_Checked();
    public void set_Checked(bool value);
    public string get_CheckedName();
    public void set_CheckedName(string value);
    public string get_UncheckedName();
    public void set_UncheckedName(string value);
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class PdfSharp.Pdf.AcroForms.PdfChoiceField : PdfAcroField {
    internal DictionaryMeta Meta { get; }
    protected PdfChoiceField(PdfDocument document);
    protected PdfChoiceField(PdfDictionary dict);
    protected int IndexInOptArray(string value);
    protected string ValueInOptArray(int index);
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.AcroForms.PdfComboBoxField : PdfChoiceField {
    public int SelectedIndex { get; public set; }
    [NullableAttribute("2")]
public PdfItem Value { get; public set; }
    internal DictionaryMeta Meta { get; }
    internal PdfComboBoxField(PdfDocument document);
    internal PdfComboBoxField(PdfDictionary dict);
    public int get_SelectedIndex();
    public void set_SelectedIndex(int value);
    [NullableContextAttribute("2")]
public virtual PdfItem get_Value();
    [NullableContextAttribute("2")]
public virtual void set_Value(PdfItem value);
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.AcroForms.PdfGenericField : PdfAcroField {
    internal DictionaryMeta Meta { get; }
    internal PdfGenericField(PdfDocument document);
    internal PdfGenericField(PdfDictionary dict);
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.AcroForms.PdfListBoxField : PdfChoiceField {
    public int SelectedIndex { get; public set; }
    internal DictionaryMeta Meta { get; }
    internal PdfListBoxField(PdfDocument document);
    internal PdfListBoxField(PdfDictionary dict);
    public int get_SelectedIndex();
    public void set_SelectedIndex(int value);
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.AcroForms.PdfPushButtonField : PdfButtonField {
    internal DictionaryMeta Meta { get; }
    internal PdfPushButtonField(PdfDocument document);
    internal PdfPushButtonField(PdfDictionary dict);
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.AcroForms.PdfRadioButtonField : PdfButtonField {
    public int SelectedIndex { get; public set; }
    internal DictionaryMeta Meta { get; }
    internal PdfRadioButtonField(PdfDocument document);
    internal PdfRadioButtonField(PdfDictionary dict);
    public int get_SelectedIndex();
    public void set_SelectedIndex(int value);
    private int IndexInOptStrings(string value);
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.AcroForms.PdfSignatureField : PdfAcroField {
    [CompilerGeneratedAttribute]
private IAnnotationAppearanceHandler <CustomAppearanceHandler>k__BackingField;
    public IAnnotationAppearanceHandler CustomAppearanceHandler { get; internal set; }
    internal DictionaryMeta Meta { get; }
    internal PdfSignatureField(PdfDocument document);
    internal PdfSignatureField(PdfDictionary dict);
    [CompilerGeneratedAttribute]
public IAnnotationAppearanceHandler get_CustomAppearanceHandler();
    [CompilerGeneratedAttribute]
internal void set_CustomAppearanceHandler(IAnnotationAppearanceHandler value);
    private void RenderCustomAppearance();
    internal virtual void PrepareForSave();
    internal virtual void WriteDictionaryElement(PdfWriter writer, PdfName key);
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.AcroForms.PdfTextField : PdfAcroField {
    [CompilerGeneratedAttribute]
private XFont <Font>k__BackingField;
    [CompilerGeneratedAttribute]
private XColor <ForeColor>k__BackingField;
    [CompilerGeneratedAttribute]
private XColor <BackColor>k__BackingField;
    public string Text { get; public set; }
    public XFont Font { get; public set; }
    public XColor ForeColor { get; public set; }
    public XColor BackColor { get; public set; }
    public int MaxLength { get; public set; }
    public bool MultiLine { get; public set; }
    public bool Password { get; public set; }
    internal DictionaryMeta Meta { get; }
    internal PdfTextField(PdfDocument document);
    internal PdfTextField(PdfDictionary dict);
    public string get_Text();
    public void set_Text(string value);
    [CompilerGeneratedAttribute]
public XFont get_Font();
    [CompilerGeneratedAttribute]
public void set_Font(XFont value);
    [CompilerGeneratedAttribute]
public XColor get_ForeColor();
    [CompilerGeneratedAttribute]
public void set_ForeColor(XColor value);
    [CompilerGeneratedAttribute]
public XColor get_BackColor();
    [CompilerGeneratedAttribute]
public void set_BackColor(XColor value);
    public int get_MaxLength();
    public void set_MaxLength(int value);
    public bool get_MultiLine();
    public void set_MultiLine(bool value);
    public bool get_Password();
    public void set_Password(bool value);
    private void RenderAppearance();
    internal virtual void PrepareForSave();
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class PdfSharp.Pdf.Actions.PdfAction : PdfDictionary {
    protected PdfAction(PdfDocument document);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Actions.PdfEmbeddedGoToAction : PdfAction {
    [NullableAttribute("2")]
private string _documentPath;
    [NullableAttribute("2")]
private string _destinationPath;
    private Nullable`1<bool> _newWindow;
    public static char Separator;
    public static string ParentString;
    public PdfEmbeddedGoToAction(PdfDocument document);
    public static PdfEmbeddedGoToAction CreatePdfEmbeddedGoToAction(string destinationPath, Nullable`1<bool> newWindow);
    public static PdfEmbeddedGoToAction CreatePdfEmbeddedGoToAction(string documentPath, string destinationPath, Nullable`1<bool> newWindow);
    private void Inititalize();
    internal virtual void WriteObject(PdfWriter writer);
    private string EncodePath(string path);
    private void ParseDestinationName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Actions.PdfGoToAction : PdfAction {
    private string _destinationName;
    public PdfGoToAction(PdfDocument document);
    public static PdfGoToAction CreateGoToAction(string destinationName);
    private void Inititalize();
    internal virtual void WriteObject(PdfWriter writer);
}
public enum PdfSharp.Pdf.Actions.PdfNamedActionNames : Enum {
    public int value__;
    public static PdfNamedActionNames NextPage;
    public static PdfNamedActionNames PrevPage;
    public static PdfNamedActionNames FirstPage;
    public static PdfNamedActionNames LastPage;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Actions.PdfRemoteGoToAction : PdfAction {
    private string _documentPath;
    private string _destinationName;
    private Nullable`1<bool> _newWindow;
    public PdfRemoteGoToAction(PdfDocument document);
    public static PdfRemoteGoToAction CreateRemoteGoToAction(string documentPath, string destinationName, Nullable`1<bool> newWindow);
    private void Inititalize();
    internal virtual void WriteObject(PdfWriter writer);
    private string EncodePath(string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Advanced.BitReader : object {
    private Byte[] _imageBits;
    private UInt32 _bytesOffsetRead;
    private UInt32 _bytesFileOffset;
    private byte _buffer;
    private UInt32 _bitsInBuffer;
    private UInt32 _bitsTotal;
    internal BitReader(Byte[] imageBits, UInt32 bytesFileOffset, UInt32 bits);
    internal void SetPosition(UInt32 position);
    internal bool GetBit(UInt32 position);
    internal byte PeekByte(UInt32& bits);
    internal void NextByte();
    internal void SkipBits(UInt32 bits);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Advanced.BitWriter : object {
    private static UInt32[] masks;
    private int _bytesOffsetWrite;
    private Byte[] _imageData;
    private UInt32 _buffer;
    private UInt32 _bitsInBuffer;
    internal BitWriter(Byte[]& imageData);
    private static BitWriter();
    internal void FlushBuffer();
    internal void WriteBits(UInt32 value, UInt32 bits);
    internal void WriteTableLine(UInt32[] table, UInt32 line);
    [ObsoleteAttribute]
internal void WriteEOL();
    internal int BytesWritten();
}
internal enum PdfSharp.Pdf.Advanced.FontType : Enum {
    public int value__;
    public static FontType Undefined;
    public static FontType TrueTypeWinAnsi;
    public static FontType Type0Unicode;
}
[NullableContextAttribute("1")]
internal interface PdfSharp.Pdf.Advanced.IContentStream {
    public PdfResources Resources { get; }
    public abstract virtual PdfResources get_Resources();
    public abstract virtual string GetFontName(XGlyphTypeface glyphTypeface, FontType fontType, PdfFont& pdfFont);
    public abstract virtual string GetFontName(string idName, Byte[] fontData, PdfFont& pdfFont);
    public abstract virtual string GetImageName(XImage image);
    public abstract virtual string GetFormName(XForm form);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Advanced.MonochromeMask : object {
    private Byte[] _maskData;
    private int _sizeX;
    private int _sizeY;
    private int _writeOffset;
    private int _byteBuffer;
    private int _bitsWritten;
    private bool _used;
    public Byte[] MaskData { get; }
    public bool MaskUsed { get; }
    public MonochromeMask(int sizeX, int sizeY);
    public Byte[] get_MaskData();
    public bool get_MaskUsed();
    public void StartLine(int newCurrentLine);
    public void AddPel(bool isTransparent);
    public void AddPel(int shade);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Advanced.PdfCatalog : PdfDictionary {
    private string _version;
    [NullableAttribute("2")]
private PdfPages _pages;
    [NullableAttribute("2")]
private PdfViewerPreferences _viewerPreferences;
    [NullableAttribute("2")]
private PdfOutline _outline;
    [NullableAttribute("2")]
private PdfNameDictionary _names;
    [NullableAttribute("2")]
private PdfAcroForm _acroForm;
    public string Version { get; public set; }
    public PdfPages Pages { get; }
    internal PdfPageLayout PageLayout { get; internal set; }
    internal PdfPageMode PageMode { get; internal set; }
    internal PdfViewerPreferences ViewerPreferences { get; }
    internal PdfOutlineCollection Outlines { get; }
    public PdfNameDictionary Names { get; }
    public PdfAcroForm AcroForm { get; }
    public string Language { get; public set; }
    internal DictionaryMeta Meta { get; }
    public PdfCatalog(PdfDocument document);
    internal PdfCatalog(PdfDictionary dictionary);
    public string get_Version();
    public void set_Version(string value);
    public PdfPages get_Pages();
    internal PdfPageLayout get_PageLayout();
    internal void set_PageLayout(PdfPageLayout value);
    internal PdfPageMode get_PageMode();
    internal void set_PageMode(PdfPageMode value);
    internal PdfViewerPreferences get_ViewerPreferences();
    internal PdfOutlineCollection get_Outlines();
    public PdfNameDictionary get_Names();
    public PdfAcroForm get_AcroForm();
    public string get_Language();
    public void set_Language(string value);
    internal virtual void PrepareForSave();
    internal virtual void WriteObject(PdfWriter writer);
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Advanced.PdfCIDFont : PdfFont {
    public string BaseFont { get; public set; }
    internal DictionaryMeta Meta { get; }
    public PdfCIDFont(PdfDocument document);
    public PdfCIDFont(PdfDocument document, PdfFontDescriptor fontDescriptor);
    public PdfCIDFont(PdfDocument document, PdfFontDescriptor fontDescriptor, Byte[] fontData);
    public string get_BaseFont();
    public void set_BaseFont(string value);
    internal virtual void PrepareForSave();
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Advanced.PdfContent : PdfDictionary {
    [NullableAttribute("2")]
internal XGraphicsPdfRenderer _pdfRenderer;
    unknown bool Compressed {public set; }
    internal DictionaryMeta Meta { get; }
    public PdfContent(PdfDocument document);
    internal PdfContent(PdfPage page);
    public PdfContent(PdfDictionary dict);
    public void set_Compressed(bool value);
    private void Decode();
    internal void PreserveGraphicsState();
    internal virtual void WriteObject(PdfWriter writer);
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Advanced.PdfContents : PdfArray {
    private bool _modified;
    public PdfContents(PdfDocument document);
    internal PdfContents(PdfArray array);
    public PdfContent AppendContent();
    public PdfContent PrependContent();
    public PdfContent CreateSingleContent();
    public PdfContent ReplaceContent(CSequence cseq);
    private PdfContent ReplaceContent(Byte[] contentBytes);
    private void SetModified();
    internal virtual void WriteObject(PdfWriter writer);
    public IEnumerator`1<PdfContent> GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Advanced.PdfCrossReferenceStream : PdfTrailer {
    public List`1<CrossReferenceStreamEntry> Entries;
    internal DictionaryMeta Meta { get; }
    public PdfCrossReferenceStream(PdfDocument document);
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class PdfSharp.Pdf.Advanced.PdfCrossReferenceTable : object {
    private PdfDocument _document;
    public Dictionary`2<PdfObjectID, PdfReference> ObjectTable;
    [CompilerGeneratedAttribute]
private bool <IsUnderConstruction>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxObjectNumber>k__BackingField;
    private static int _nestingLevel;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<PdfItem, object> _overflow;
    [NullableAttribute("2")]
private PdfDictionary _deadObject;
    internal bool IsUnderConstruction { get; internal set; }
    [NullableAttribute("2")]
public PdfReference Item { get; }
    internal int MaxObjectNumber { get; internal set; }
    internal PdfObjectID[] AllObjectIDs { get; }
    internal PdfReference[] AllReferences { get; }
    public PdfReference DeadObject { get; }
    public PdfCrossReferenceTable(PdfDocument document);
    [CompilerGeneratedAttribute]
internal bool get_IsUnderConstruction();
    [CompilerGeneratedAttribute]
internal void set_IsUnderConstruction(bool value);
    public void Add(PdfReference iref);
    public void Add(PdfObject value);
    public bool TryAdd(PdfObject value);
    public void Remove(PdfReference iref);
    [NullableContextAttribute("2")]
public PdfReference get_Item(PdfObjectID objectID);
    public bool Contains(PdfObjectID objectID);
    public int GetNewObjectNumber();
    [CompilerGeneratedAttribute]
internal int get_MaxObjectNumber();
    [CompilerGeneratedAttribute]
internal void set_MaxObjectNumber(int value);
    internal void WriteObject(PdfWriter writer);
    internal PdfObjectID[] get_AllObjectIDs();
    internal PdfReference[] get_AllReferences();
    internal void HandleOrphanedReferences();
    internal int Compact();
    internal void Renumber();
    internal long GetPositionOfObjectBehind(PdfObject obj, long position);
    [ConditionalAttribute("DEBUG_")]
public void CheckConsistence();
    public PdfReference[] TransitiveClosure(PdfObject pdfObject, int depth);
    private void TransitiveClosureImplementation(Dictionary`2<PdfItem, object> objects, PdfObject pdfObject);
    public PdfReference get_DeadObject();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class PdfSharp.Pdf.Advanced.PdfDictionaryWithContentStream : PdfDictionary {
    [NullableAttribute("2")]
private PdfResources _resources;
    internal PdfResources Resources { get; }
    private PdfResources PdfSharp.Pdf.Advanced.IContentStream.Resources { get; }
    protected PdfDictionaryWithContentStream(PdfDocument document);
    protected PdfDictionaryWithContentStream(PdfDictionary dict);
    internal PdfResources get_Resources();
    private sealed virtual override PdfResources PdfSharp.Pdf.Advanced.IContentStream.get_Resources();
    internal string GetFontName(XGlyphTypeface glyphTypeface, FontType fontType, PdfFont& pdfFont);
    private sealed virtual override string PdfSharp.Pdf.Advanced.IContentStream.GetFontName(XGlyphTypeface glyphTypeface, FontType fontType, PdfFont& pdfFont);
    internal string GetFontName(string idName, Byte[] fontData, PdfFont& pdfFont);
    private sealed virtual override string PdfSharp.Pdf.Advanced.IContentStream.GetFontName(string idName, Byte[] fontData, PdfFont& pdfFont);
    internal string GetImageName(XImage image);
    private sealed virtual override string PdfSharp.Pdf.Advanced.IContentStream.GetImageName(XImage image);
    internal string GetFormName(XForm form);
    private sealed virtual override string PdfSharp.Pdf.Advanced.IContentStream.GetFormName(XForm form);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Advanced.PdfEmbeddedFileStream : PdfDictionary {
    private Byte[] _data;
    private static string TypeValue;
    public PdfEmbeddedFileStream(PdfDocument document, Stream stream);
    private void Initialize();
    public static bool IsEmbeddedFile(PdfDictionary dictionary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Advanced.PdfExtGState : PdfDictionary {
    private double _strokeAlpha;
    private double _nonStrokeAlpha;
    private bool _strokeOverprint;
    private bool _nonStrokeOverprint;
    private string _key;
    unknown double StrokeAlpha {public set; }
    unknown double NonStrokeAlpha {public set; }
    unknown bool StrokeOverprint {public set; }
    unknown bool NonStrokeOverprint {public set; }
    unknown PdfSoftMask SoftMask {public set; }
    internal string Key { get; }
    internal DictionaryMeta Meta { get; }
    public PdfExtGState(PdfDocument document);
    internal void SetDefault1();
    internal void SetDefault2();
    public void set_StrokeAlpha(double value);
    public void set_NonStrokeAlpha(double value);
    public void set_StrokeOverprint(bool value);
    public void set_NonStrokeOverprint(bool value);
    public void set_SoftMask(PdfSoftMask value);
    internal string get_Key();
    private void UpdateKey();
    internal static string MakeKey(double alpha, bool overPaint);
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Advanced.PdfExtGStateTable : PdfResourceTable {
    private Dictionary`2<string, PdfExtGState> _strokeAlphaValues;
    private Dictionary`2<string, PdfExtGState> _nonStrokeStates;
    public PdfExtGStateTable(PdfDocument document);
    public PdfExtGState GetExtGStateStroke(double alpha, bool overprint);
    public PdfExtGState GetExtGStateNonStroke(double alpha, bool overprint);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Advanced.PdfFileSpecification : PdfDictionary {
    private PdfEmbeddedFileStream _embeddedFileStream;
    private string _name;
    public PdfFileSpecification(PdfDocument document, PdfEmbeddedFileStream embeddedFileStream, string name);
    private void Initialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Advanced.PdfFont : PdfDictionary {
    private PdfFontDescriptor _fontDescriptor;
    [CompilerGeneratedAttribute]
private PdfFontEncoding <FontEncoding>k__BackingField;
    internal CMapInfo _cmapInfo;
    [NullableAttribute("2")]
internal PdfToUnicodeMap _toUnicodeMap;
    internal PdfFontDescriptor FontDescriptor { get; internal set; }
    internal PdfFontEncoding FontEncoding { get; internal set; }
    public bool IsSymbolFont { get; }
    internal CMapInfo CMapInfo { get; internal set; }
    internal PdfToUnicodeMap ToUnicodeMap { get; internal set; }
    protected PdfFont(PdfDocument document);
    internal PdfFontDescriptor get_FontDescriptor();
    internal void set_FontDescriptor(PdfFontDescriptor value);
    [CompilerGeneratedAttribute]
internal PdfFontEncoding get_FontEncoding();
    [CompilerGeneratedAttribute]
internal Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FontEncoding(PdfFontEncoding value);
    public bool get_IsSymbolFont();
    internal void AddChars(CodePointGlyphIndexPair[] codePoints);
    internal CMapInfo get_CMapInfo();
    internal void set_CMapInfo(CMapInfo value);
    internal PdfToUnicodeMap get_ToUnicodeMap();
    internal void set_ToUnicodeMap(PdfToUnicodeMap value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Advanced.PdfFontDescriptor : PdfDictionary {
    [CompilerGeneratedAttribute]
private OpenTypeDescriptor <Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSymbolFont>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddCmapTable>k__BackingField;
    private CMapInfo _cmapInfo;
    private bool _prepared;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, object> _fontSubsetNames;
    internal OpenTypeDescriptor Descriptor { get; }
    public string FontName { get; public set; }
    public bool IsSymbolFont { get; private set; }
    internal bool AddCmapTable { get; internal set; }
    internal CMapInfo CMapInfo { get; }
    internal DictionaryMeta Meta { get; }
    internal PdfFontDescriptor(PdfDocument document, OpenTypeDescriptor otDescriptor);
    [CompilerGeneratedAttribute]
internal OpenTypeDescriptor get_Descriptor();
    public string get_FontName();
    public void set_FontName(string value);
    [CompilerGeneratedAttribute]
public bool get_IsSymbolFont();
    [CompilerGeneratedAttribute]
private void set_IsSymbolFont(bool value);
    private PdfFontDescriptorFlags FlagsFromDescriptor(OpenTypeDescriptor descriptor);
    [CompilerGeneratedAttribute]
internal bool get_AddCmapTable();
    [CompilerGeneratedAttribute]
internal void set_AddCmapTable(bool value);
    internal CMapInfo get_CMapInfo();
    internal virtual void PrepareForSave();
    internal string CreateEmbeddedFontSubsetName(string name);
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Advanced.PdfFontDescriptorCache : object {
    [CompilerGeneratedAttribute]
private PdfDocument <Owner>k__BackingField;
    private Dictionary`2<string, PdfFontDescriptor> _cache;
    private PdfDocument Owner { get; }
    public PdfFontDescriptorCache(PdfDocument doc);
    public PdfFontDescriptor GetOrCreatePdfDescriptorFor(OpenTypeDescriptor otDescriptor, string baseName);
    [CompilerGeneratedAttribute]
private PdfDocument get_Owner();
}
[FlagsAttribute]
internal enum PdfSharp.Pdf.Advanced.PdfFontDescriptorFlags : Enum {
    public int value__;
    public static PdfFontDescriptorFlags FixedPitch;
    public static PdfFontDescriptorFlags Serif;
    public static PdfFontDescriptorFlags Symbolic;
    public static PdfFontDescriptorFlags Script;
    public static PdfFontDescriptorFlags Nonsymbolic;
    public static PdfFontDescriptorFlags Italic;
    public static PdfFontDescriptorFlags AllCap;
    public static PdfFontDescriptorFlags SmallCap;
    public static PdfFontDescriptorFlags ForceBold;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Advanced.PdfFontProgram : PdfDictionary {
    internal PdfFontProgram(PdfDocument document);
    internal void CreateFontFileAndAddToDescriptor(PdfFontDescriptor pdfFontDescriptor, CMapInfo cmapInfo, bool cidFont);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Advanced.PdfFontTable : PdfResourceTable {
    private Dictionary`2<string, PdfFont> _fonts;
    public PdfFontTable(PdfDocument document);
    public PdfFont GetOrCreateFont(XGlyphTypeface glyphTypeface, FontType fontType);
    public PdfFont GetFont(string idName, Byte[] fontData);
    public PdfFont TryGetFont(string idName);
    internal static string ComputePdfFontKey(XGlyphTypeface glyphTypeface, FontType fontType);
    public void PrepareForSave();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Advanced.PdfFormXObject : PdfXObject {
    [CompilerGeneratedAttribute]
private double <DpiX>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DpiY>k__BackingField;
    [NullableAttribute("2")]
private PdfResources _resources;
    internal double DpiX { get; internal set; }
    internal double DpiY { get; internal set; }
    public PdfResources Resources { get; }
    private PdfResources PdfSharp.Pdf.Advanced.IContentStream.Resources { get; }
    internal DictionaryMeta Meta { get; }
    internal PdfFormXObject(PdfDocument thisDocument);
    internal PdfFormXObject(PdfDocument thisDocument, XForm form);
    internal PdfFormXObject(PdfDocument thisDocument, PdfImportedObjectTable importedObjectTable, XPdfForm form);
    [CompilerGeneratedAttribute]
internal double get_DpiX();
    [CompilerGeneratedAttribute]
internal void set_DpiX(double value);
    [CompilerGeneratedAttribute]
internal double get_DpiY();
    [CompilerGeneratedAttribute]
internal void set_DpiY(double value);
    public PdfResources get_Resources();
    private sealed virtual override PdfResources PdfSharp.Pdf.Advanced.IContentStream.get_Resources();
    internal string GetFontName(XGlyphTypeface glyphTypeface, FontType fontType, PdfFont& pdfFont);
    private sealed virtual override string PdfSharp.Pdf.Advanced.IContentStream.GetFontName(XGlyphTypeface glyphTypeface, FontType fontType, PdfFont& pdfFont);
    internal string GetFontName(string idName, Byte[] fontData, PdfFont& pdfFont);
    private sealed virtual override string PdfSharp.Pdf.Advanced.IContentStream.GetFontName(string idName, Byte[] fontData, PdfFont& pdfFont);
    private sealed virtual override string PdfSharp.Pdf.Advanced.IContentStream.GetImageName(XImage image);
    private sealed virtual override string PdfSharp.Pdf.Advanced.IContentStream.GetFormName(XForm form);
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Advanced.PdfFormXObjectTable : PdfResourceTable {
    private Dictionary`2<Selector, PdfImportedObjectTable> _forms;
    public PdfFormXObjectTable(PdfDocument document);
    public PdfFormXObject GetForm(XForm form);
    public PdfImportedObjectTable GetImportedObjectTable(PdfPage page);
    public PdfImportedObjectTable GetImportedObjectTable(PdfDocument document);
    public void DetachDocument(DocumentHandle handle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class PdfSharp.Pdf.Advanced.PdfGroupAttributes : PdfDictionary {
    internal DictionaryMeta Meta { get; }
    internal PdfGroupAttributes(PdfDocument thisDocument);
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Advanced.PdfImage : PdfXObject {
    private XImage _image;
    internal static UInt32[] WhiteTerminatingCodes;
    internal static UInt32[] BlackTerminatingCodes;
    internal static UInt32[] WhiteMakeUpCodes;
    internal static UInt32[] BlackMakeUpCodes;
    internal static UInt32[] HorizontalCodes;
    internal static UInt32[] PassCodes;
    internal static UInt32[] VerticalCodes;
    private static UInt32[] _zeroRuns;
    private static UInt32[] _oneRuns;
    public XImage Image { get; }
    public PdfImage(PdfDocument document, XImage image);
    private static PdfImage();
    public XImage get_Image();
    public virtual string ToString();
    private void InitializeJpeg(PdfDocumentOptions options);
    private void InitializeNonJpeg(PdfDocumentOptions options);
    private void CreateIndexedMemoryBitmap(int bits, PdfDocumentOptions options);
    private void CreateTrueColorMemoryBitmap(int components, int bits, bool hasAlpha, PdfDocumentOptions options);
    private static int ReadWord(Byte[] ab, int offset);
    private static int ReadDWord(Byte[] ab, int offset);
    [NullableContextAttribute("0")]
private static int ReadWord(ReadOnlySpan`1<byte> bytes, int offset);
    [NullableContextAttribute("0")]
private static int ReadDWord(ReadOnlySpan`1<byte> bytes, int offset);
    private void ReadTrueColorMemoryBitmap(int components, int bits, bool hasAlpha);
    private void ReadIndexedMemoryBitmap(int bits);
    private static UInt32 CountOneBits(BitReader reader, UInt32 bitsLeft);
    private static UInt32 CountZeroBits(BitReader reader, UInt32 bitsLeft);
    private static UInt32 FindDifference(BitReader reader, UInt32 bitStart, UInt32 bitEnd, bool searchOne);
    private static UInt32 FindDifferenceWithCheck(BitReader reader, UInt32 bitStart, UInt32 bitEnd, bool searchOne);
    private static void FaxEncode2DRow(BitWriter writer, UInt32 bytesFileOffset, Byte[] imageBits, UInt32 currentRow, UInt32 referenceRow, UInt32 width, UInt32 height, UInt32 bytesPerLineBmp);
    private static int DoFaxEncoding(Byte[]& imageData, Byte[] imageBits, UInt32 bytesFileOffset, UInt32 width, UInt32 height);
    internal static int DoFaxEncodingGroup4(Byte[]& imageData, Byte[] imageBits, UInt32 bytesFileOffset, UInt32 width, UInt32 height);
    private static void WriteSample(BitWriter writer, UInt32 count, bool white);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Advanced.PdfImageTable : PdfResourceTable {
    private Dictionary`2<ImageSelector, PdfImage> _images;
    public PdfImageTable(PdfDocument document);
    public PdfImage GetImage(XImage image);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class PdfSharp.Pdf.Advanced.PdfImportedObjectTable : object {
    private PdfFormXObject[] _xObjects;
    [CompilerGeneratedAttribute]
private PdfDocument <Owner>k__BackingField;
    private DocumentHandle _externalDocumentHandle;
    private Dictionary`2<string, PdfReference> _externalIDs;
    public PdfDocument Owner { get; }
    [NullableAttribute("2")]
public PdfDocument ExternalDocument { get; }
    public PdfReference Item { get; }
    public PdfImportedObjectTable(PdfDocument owner, PdfDocument externalDocument);
    [CompilerGeneratedAttribute]
public PdfDocument get_Owner();
    [NullableContextAttribute("2")]
public PdfDocument get_ExternalDocument();
    public PdfFormXObject GetXObject(int pageNumber);
    public void SetXObject(int pageNumber, PdfFormXObject xObject);
    public bool Contains(PdfObjectID externalID);
    public void Add(PdfObjectID externalID, PdfReference iref);
    public PdfReference get_Item(PdfObjectID externalID);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Advanced.PdfInternals : object {
    private PdfDocument _document;
    public string CustomValueKey;
    public string FirstDocumentID { get; public set; }
    public Guid FirstDocumentGuid { get; }
    public string SecondDocumentID { get; public set; }
    public Guid SecondDocumentGuid { get; }
    public PdfCatalog Catalog { get; }
    public PdfExtGStateTable ExtGStateTable { get; }
    [NullableAttribute("2")]
public object UAManager { get; }
    [ObsoleteAttribute("Use GetAllObjects.")]
public PdfObject[] AllObjects { get; }
    internal PdfInternals(PdfDocument document);
    public string get_FirstDocumentID();
    public void set_FirstDocumentID(string value);
    public Guid get_FirstDocumentGuid();
    public string get_SecondDocumentID();
    public void set_SecondDocumentID(string value);
    public Guid get_SecondDocumentGuid();
    private Guid GuidFromString(string id);
    public PdfCatalog get_Catalog();
    public PdfExtGStateTable get_ExtGStateTable();
    [NullableContextAttribute("2")]
public object get_UAManager();
    [NullableContextAttribute("2")]
public PdfObject GetObject(PdfObjectID objectID);
    public PdfObject MapExternalObject(PdfObject externalObject);
    public static PdfReference GetReference(PdfObject obj);
    public static PdfObjectID GetObjectID(PdfObject obj);
    public static int GetObjectNumber(PdfObject obj);
    public static int GenerationNumber(PdfObject obj);
    public PdfObject[] GetAllObjects();
    public PdfObject[] get_AllObjects();
    public T CreateIndirectObject();
    public void AddObject(PdfObject obj);
    public void RemoveObject(PdfObject obj);
    public PdfObject[] GetClosure(PdfObject obj);
    public PdfObject[] GetClosure(PdfObject obj, int depth);
    public void WriteObject(Stream stream, PdfItem item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Advanced.PdfNamedDestinationParameters : object {
    private string _parameters;
    private PdfNamedDestinationParameters(string parameters);
    private static PdfNamedDestinationParameters CreateXYZ(Nullable`1<double> left, Nullable`1<double> top, Nullable`1<double> zoom);
    public static PdfNamedDestinationParameters CreateUnchangedPosition();
    public static PdfNamedDestinationParameters CreateVerticalPosition(Nullable`1<double> top, Nullable`1<double> zoom);
    public static PdfNamedDestinationParameters CreatePosition(Nullable`1<double> left, Nullable`1<double> top, Nullable`1<double> zoom);
    public static PdfNamedDestinationParameters CreatePosition(XPoint position, Nullable`1<double> zoom);
    public static PdfNamedDestinationParameters CreateFit();
    public static PdfNamedDestinationParameters CreateFitHorizontally(Nullable`1<double> top);
    public static PdfNamedDestinationParameters CreateFitVertically(Nullable`1<double> left);
    public static PdfNamedDestinationParameters CreateFitRectangle(double left, double top, double right, double bottom);
    public static PdfNamedDestinationParameters CreateFitRectangle(XRect rect);
    public static PdfNamedDestinationParameters CreateFitRectangle(XPoint point1, XPoint point2);
    public static PdfNamedDestinationParameters CreateFitBoundingBox();
    public static PdfNamedDestinationParameters CreateFitBoundingBoxHorizontally(Nullable`1<double> top);
    public static PdfNamedDestinationParameters CreateFitBoundingBoxVertically(Nullable`1<double> left);
    private static string Format(string format, Nullable`1[] values);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Advanced.PdfNameDictionary : PdfDictionary {
    [NullableAttribute("2")]
private PdfNameTreeNode _dests;
    [NullableAttribute("2")]
private PdfNameTreeNode _embeddedFiles;
    public PdfNameDictionary(PdfDocument document);
    internal PdfNameDictionary(PdfDictionary dictionary);
    internal void AddNamedDestination(string destinationName, int destinationPage, PdfNamedDestinationParameters parameters);
    internal void AddEmbeddedFile(string name, Stream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Advanced.PdfObjectInternals : object {
    private PdfObject _obj;
    public PdfObjectID ObjectID { get; }
    public int ObjectNumber { get; }
    public int GenerationNumber { get; }
    public string TypeID { get; }
    internal PdfObjectInternals(PdfObject obj);
    public PdfObjectID get_ObjectID();
    public int get_ObjectNumber();
    public int get_GenerationNumber();
    public string get_TypeID();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Advanced.PdfObjectStream : PdfDictionary {
    private Int32[][] _header;
    [NullableAttribute("2")]
private Dictionary`2<PdfObjectID, long> _objectOffsets;
    public PdfObjectStream(PdfDocument document);
    internal PdfObjectStream(PdfDictionary dict, Parser documentParser);
    internal void ReadReferences(PdfCrossReferenceTable xrefTable);
    [NullableContextAttribute("2")]
internal bool TryGetObjectOffset(PdfObjectID pdfObjectID, Int64& offset, SuppressExceptions suppressObjectOrderExceptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Advanced.PdfPageInheritableObjects : PdfDictionary {
    private PdfRectangle _mediaBox;
    private PdfRectangle _cropBox;
    private int _rotate;
    public PdfRectangle MediaBox { get; public set; }
    public PdfRectangle CropBox { get; public set; }
    public int Rotate { get; public set; }
    public PdfRectangle get_MediaBox();
    public void set_MediaBox(PdfRectangle value);
    public PdfRectangle get_CropBox();
    public void set_CropBox(PdfRectangle value);
    public int get_Rotate();
    public void set_Rotate(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("iref({ObjectNumber}, {GenerationNumber})")]
public class PdfSharp.Pdf.Advanced.PdfReference : PdfItem {
    private PdfObjectID _objectID;
    private long _position;
    private PdfObject _value;
    [NullableAttribute("2")]
private PdfDocument _document;
    public PdfObjectID ObjectID { get; public set; }
    public int ObjectNumber { get; }
    public int GenerationNumber { get; }
    public long Position { get; public set; }
    public PdfObject Value { get; public set; }
    public PdfDocument Document { get; public set; }
    internal static PdfReferenceComparer Comparer { get; }
    public PdfReference(PdfObject pdfObject);
    public PdfReference(PdfObjectID objectID, long position);
    internal void WriteXRefEntry(PdfWriter writer);
    internal virtual void WriteObject(PdfWriter writer);
    public PdfObjectID get_ObjectID();
    public void set_ObjectID(PdfObjectID value);
    public int get_ObjectNumber();
    public int get_GenerationNumber();
    public long get_Position();
    public void set_Position(long value);
    public PdfObject get_Value();
    public void set_Value(PdfObject value);
    internal void SetObject(PdfObject value);
    public PdfDocument get_Document();
    public void set_Document(PdfDocument value);
    public virtual string ToString();
    public static void Dereference(Object& item);
    public static void Dereference(PdfItem& item);
    internal static PdfReferenceComparer get_Comparer();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Advanced.PdfResourceMap : PdfDictionary {
    public PdfResourceMap(PdfDocument document);
    protected PdfResourceMap(PdfDictionary dict);
    internal void CollectResourceNames(Dictionary`2<string, object> usedResourceNames);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Advanced.PdfResources : PdfDictionary {
    [NullableAttribute("2")]
private PdfResourceMap _fonts;
    [NullableAttribute("2")]
private PdfResourceMap _xObjects;
    [NullableAttribute("2")]
private PdfResourceMap _extGStates;
    [NullableAttribute("2")]
private PdfResourceMap _colorSpaces;
    [NullableAttribute("2")]
private PdfResourceMap _patterns;
    [NullableAttribute("2")]
private PdfResourceMap _shadings;
    [NullableAttribute("2")]
private PdfResourceMap _properties;
    private int _fontNumber;
    private int _imageNumber;
    private int _formNumber;
    private int _extGStateNumber;
    private int _patternNumber;
    private int _shadingNumber;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, object> _importedResourceNames;
    private Dictionary`2<PdfObject, string> _resources;
    internal PdfResourceMap Fonts { get; }
    internal PdfResourceMap XObjects { get; }
    internal PdfResourceMap ExtGStates { get; }
    internal PdfResourceMap ColorSpaces { get; }
    internal PdfResourceMap Patterns { get; }
    internal PdfResourceMap Shadings { get; }
    internal PdfResourceMap Properties { get; }
    private string NextFontName { get; }
    private string NextImageName { get; }
    private string NextFormName { get; }
    private string NextExtGStateName { get; }
    private string NextPatternName { get; }
    private string NextShadingName { get; }
    internal DictionaryMeta Meta { get; }
    public PdfResources(PdfDocument document);
    internal PdfResources(PdfDictionary dict);
    public string AddFont(PdfFont font);
    public string AddImage(PdfImage image);
    public string AddForm(PdfFormXObject form);
    public string AddExtGState(PdfExtGState extGState);
    public string AddPattern(PdfShadingPattern pattern);
    public string AddPattern(PdfTilingPattern pattern);
    public string AddShading(PdfShading shading);
    internal PdfResourceMap get_Fonts();
    internal PdfResourceMap get_XObjects();
    internal PdfResourceMap get_ExtGStates();
    internal PdfResourceMap get_ColorSpaces();
    internal PdfResourceMap get_Patterns();
    internal PdfResourceMap get_Shadings();
    internal PdfResourceMap get_Properties();
    private string get_NextFontName();
    private string get_NextImageName();
    private string get_NextFormName();
    private string get_NextExtGStateName();
    private string get_NextPatternName();
    private string get_NextShadingName();
    internal bool ExistsResourceName(string name);
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Advanced.PdfResourceTable : object {
    [CompilerGeneratedAttribute]
private PdfDocument <Owner>k__BackingField;
    protected PdfDocument Owner { get; }
    public PdfResourceTable(PdfDocument owner);
    [CompilerGeneratedAttribute]
protected PdfDocument get_Owner();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Advanced.PdfShading : PdfDictionary {
    internal DictionaryMeta Meta { get; }
    public PdfShading(PdfDocument document);
    internal void SetupFromBrush(XLinearGradientBrush brush, XGraphicsPdfRenderer renderer);
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Advanced.PdfShadingPattern : PdfDictionaryWithContentStream {
    internal DictionaryMeta Meta { get; }
    public PdfShadingPattern(PdfDocument document);
    internal void SetupFromBrush(XLinearGradientBrush brush, XMatrix matrix, XGraphicsPdfRenderer renderer);
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Advanced.PdfSoftMask : PdfDictionary {
    public PdfSoftMask(PdfDocument document);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Advanced.PdfTilingPattern : PdfDictionaryWithContentStream {
    internal DictionaryMeta Meta { get; }
    public PdfTilingPattern(PdfDocument document);
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Advanced.PdfToUnicodeMap : PdfDictionary {
    [CompilerGeneratedAttribute]
private CMapInfo <CMapInfo>k__BackingField;
    public CMapInfo CMapInfo { get; public set; }
    public PdfToUnicodeMap(PdfDocument document);
    public PdfToUnicodeMap(PdfDocument document, CMapInfo cmapInfo);
    [CompilerGeneratedAttribute]
public CMapInfo get_CMapInfo();
    [CompilerGeneratedAttribute]
public void set_CMapInfo(CMapInfo value);
    internal virtual void PrepareForSave();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Advanced.PdfTrailer : PdfDictionary {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PdfTrailer <PreviousTrailer>k__BackingField;
    [NullableAttribute("2")]
internal PdfStandardSecurityHandler SecurityHandlerInternal;
    public int Size { get; public set; }
    public PdfDocumentInformation Info { get; }
    public PdfCatalog Root { get; }
    [NullableAttribute("2")]
public PdfTrailer PreviousTrailer { get; public set; }
    public PdfStandardSecurityHandler SecurityHandler { get; }
    [NullableAttribute("2")]
public PdfStandardSecurityHandler EffectiveSecurityHandler { get; }
    internal DictionaryMeta Meta { get; }
    public PdfTrailer(PdfDocument document);
    public PdfTrailer(PdfCrossReferenceStream trailer);
    public int get_Size();
    public void set_Size(int value);
    public PdfDocumentInformation get_Info();
    public PdfCatalog get_Root();
    public string GetDocumentID(int index);
    public void SetDocumentID(int index, string value);
    internal PdfArray CreateNewDocumentIDs();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public PdfTrailer get_PreviousTrailer();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_PreviousTrailer(PdfTrailer value);
    public PdfStandardSecurityHandler get_SecurityHandler();
    [NullableContextAttribute("2")]
public PdfStandardSecurityHandler get_EffectiveSecurityHandler();
    internal virtual void WriteObject(PdfWriter writer);
    internal void Finish();
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Advanced.PdfTransparencyGroupAttributes : PdfGroupAttributes {
    internal DictionaryMeta Meta { get; }
    internal PdfTransparencyGroupAttributes(PdfDocument thisDocument);
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Advanced.PdfTrueTypeFont : PdfFont {
    public string BaseFont { get; public set; }
    public int FirstChar { get; public set; }
    public int LastChar { get; public set; }
    public PdfArray Widths { get; }
    public string Encoding { get; public set; }
    internal DictionaryMeta Meta { get; }
    public PdfTrueTypeFont(PdfDocument document);
    public PdfTrueTypeFont(PdfDocument document, XFont font);
    public PdfTrueTypeFont(PdfDocument document, XGlyphTypeface glyphTypeface);
    public string get_BaseFont();
    public void set_BaseFont(string value);
    public int get_FirstChar();
    public void set_FirstChar(int value);
    public int get_LastChar();
    public void set_LastChar(int value);
    public PdfArray get_Widths();
    public string get_Encoding();
    public void set_Encoding(string value);
    internal virtual void PrepareForSave();
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Advanced.PdfType0Font : PdfFont {
    [CompilerGeneratedAttribute]
private XPdfFontOptions <FontOptions>k__BackingField;
    private PdfCIDFont _descendantFont;
    private XPdfFontOptions FontOptions { get; }
    public string BaseFont { get; public set; }
    internal PdfCIDFont DescendantFont { get; }
    internal DictionaryMeta Meta { get; }
    public PdfType0Font(PdfDocument document);
    public PdfType0Font(PdfDocument document, XGlyphTypeface glyphTypeface, bool vertical);
    [CompilerGeneratedAttribute]
private XPdfFontOptions get_FontOptions();
    public string get_BaseFont();
    public void set_BaseFont(string value);
    internal PdfCIDFont get_DescendantFont();
    internal virtual void PrepareForSave();
    internal virtual DictionaryMeta get_Meta();
}
public abstract class PdfSharp.Pdf.Advanced.PdfXObject : PdfDictionary {
    [NullableContextAttribute("1")]
protected PdfXObject(PdfDocument document);
}
[NullableContextAttribute("1")]
public interface PdfSharp.Pdf.Annotations.IAnnotationAppearanceHandler {
    public abstract virtual void DrawAppearance(XGraphics gfx, XRect rect);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class PdfSharp.Pdf.Annotations.PdfAnnotation : PdfDictionary {
    [NullableAttribute("2")]
private PdfAnnotations _parent;
    public PdfAnnotationFlags Flags { get; public set; }
    public PdfAnnotations Parent { get; public set; }
    public PdfRectangle Rectangle { get; public set; }
    public string Title { get; public set; }
    public string Subject { get; public set; }
    public string Contents { get; public set; }
    public XColor Color { get; public set; }
    public double Opacity { get; public set; }
    protected PdfAnnotation(PdfDocument document);
    internal PdfAnnotation(PdfDictionary dict);
    private void Initialize();
    [ObsoleteAttribute("Use 'Parent.Remove(this)'")]
public void Delete();
    public PdfAnnotationFlags get_Flags();
    public void set_Flags(PdfAnnotationFlags value);
    public PdfAnnotations get_Parent();
    public void set_Parent(PdfAnnotations value);
    public PdfRectangle get_Rectangle();
    public void set_Rectangle(PdfRectangle value);
    public string get_Title();
    public void set_Title(string value);
    public string get_Subject();
    public void set_Subject(string value);
    public string get_Contents();
    public void set_Contents(string value);
    public XColor get_Color();
    public void set_Color(XColor value);
    public double get_Opacity();
    public void set_Opacity(double value);
}
[FlagsAttribute]
public enum PdfSharp.Pdf.Annotations.PdfAnnotationFlags : Enum {
    public int value__;
    public static PdfAnnotationFlags Invisible;
    public static PdfAnnotationFlags Hidden;
    public static PdfAnnotationFlags Print;
    public static PdfAnnotationFlags NoZoom;
    public static PdfAnnotationFlags NoRotate;
    public static PdfAnnotationFlags NoView;
    public static PdfAnnotationFlags ReadOnly;
    public static PdfAnnotationFlags Locked;
    public static PdfAnnotationFlags ToggleNoView;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class PdfSharp.Pdf.Annotations.PdfAnnotations : PdfArray {
    [NullableAttribute("2")]
private PdfPage _page;
    public int Count { get; }
    public PdfAnnotation Item { get; }
    internal PdfPage Page { get; internal set; }
    internal PdfAnnotations(PdfDocument document);
    internal PdfAnnotations(PdfArray array);
    public void Add(PdfAnnotation annotation);
    public void Remove(PdfAnnotation annotation);
    public void Clear();
    public int get_Count();
    public PdfAnnotation get_Item(int index);
    internal PdfPage get_Page();
    internal void set_Page(PdfPage value);
    internal static void FixImportedAnnotation(PdfPage page);
    public virtual IEnumerator`1<PdfItem> GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Annotations.PdfGenericAnnotation : PdfAnnotation {
    internal DictionaryMeta Meta { get; }
    public PdfGenericAnnotation(PdfDictionary dict);
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Annotations.PdfLinkAnnotation : PdfAnnotation {
    private int _destPage;
    private LinkType _linkType;
    private string _url;
    private Nullable`1<XPoint> _point;
    private PdfAction _action;
    internal DictionaryMeta Meta { get; }
    public PdfLinkAnnotation(PdfDocument document);
    public static PdfLinkAnnotation CreateDocumentLink(PdfRectangle rect, int destinationPage, Nullable`1<XPoint> point);
    public static PdfLinkAnnotation CreateDocumentLink(PdfRectangle rect, string destinationName);
    public static PdfLinkAnnotation CreateDocumentLink(PdfRectangle rect, string documentPath, string destinationName, Nullable`1<bool> newWindow);
    public static PdfLinkAnnotation CreateEmbeddedDocumentLink(PdfRectangle rect, string destinationPath, Nullable`1<bool> newWindow);
    public static PdfLinkAnnotation CreateEmbeddedDocumentLink(PdfRectangle rect, string documentPath, string destinationPath, Nullable`1<bool> newWindow);
    public static PdfLinkAnnotation CreateWebLink(PdfRectangle rect, string url);
    public static PdfLinkAnnotation CreateFileLink(PdfRectangle rect, string fileName);
    internal virtual void WriteObject(PdfWriter writer);
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Annotations.PdfRubberStampAnnotation : PdfAnnotation {
    public PdfRubberStampAnnotationIcon Icon { get; public set; }
    internal DictionaryMeta Meta { get; }
    public PdfRubberStampAnnotation(PdfDocument document);
    private void Initialize();
    public PdfRubberStampAnnotationIcon get_Icon();
    public void set_Icon(PdfRubberStampAnnotationIcon value);
    internal virtual DictionaryMeta get_Meta();
}
public enum PdfSharp.Pdf.Annotations.PdfRubberStampAnnotationIcon : Enum {
    public int value__;
    public static PdfRubberStampAnnotationIcon NoIcon;
    public static PdfRubberStampAnnotationIcon Approved;
    public static PdfRubberStampAnnotationIcon AsIs;
    public static PdfRubberStampAnnotationIcon Confidential;
    public static PdfRubberStampAnnotationIcon Departmental;
    public static PdfRubberStampAnnotationIcon Draft;
    public static PdfRubberStampAnnotationIcon Experimental;
    public static PdfRubberStampAnnotationIcon Expired;
    public static PdfRubberStampAnnotationIcon Final;
    public static PdfRubberStampAnnotationIcon ForComment;
    public static PdfRubberStampAnnotationIcon ForPublicRelease;
    public static PdfRubberStampAnnotationIcon NotApproved;
    public static PdfRubberStampAnnotationIcon NotForPublicRelease;
    public static PdfRubberStampAnnotationIcon Sold;
    public static PdfRubberStampAnnotationIcon TopSecret;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Annotations.PdfTextAnnotation : PdfAnnotation {
    public bool Open { get; public set; }
    public PdfTextAnnotationIcon Icon { get; public set; }
    internal DictionaryMeta Meta { get; }
    public PdfTextAnnotation(PdfDocument document);
    private void Initialize();
    public bool get_Open();
    public void set_Open(bool value);
    public PdfTextAnnotationIcon get_Icon();
    public void set_Icon(PdfTextAnnotationIcon value);
    internal virtual DictionaryMeta get_Meta();
}
public enum PdfSharp.Pdf.Annotations.PdfTextAnnotationIcon : Enum {
    public int value__;
    public static PdfTextAnnotationIcon NoIcon;
    public static PdfTextAnnotationIcon Comment;
    public static PdfTextAnnotationIcon Help;
    public static PdfTextAnnotationIcon Insert;
    public static PdfTextAnnotationIcon Key;
    public static PdfTextAnnotationIcon NewParagraph;
    public static PdfTextAnnotationIcon Note;
    public static PdfTextAnnotationIcon Paragraph;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Annotations.PdfWidgetAnnotation : PdfAnnotation {
    internal DictionaryMeta Meta { get; }
    public PdfWidgetAnnotation(PdfDocument document);
    private void Initialize();
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.ArrayOrSingleItemHelper : object {
    private PdfDictionary _dictionary;
    private DictionaryElements _elements;
    public ArrayOrSingleItemHelper(DictionaryElements elements);
    public void Add(string key, PdfItem value, bool prepend);
    [IteratorStateMachineAttribute("PdfSharp.Pdf.ArrayOrSingleItemHelper/<GetAll>d__2")]
public IEnumerable`1<PdfItem> GetAll(string key);
    private IEnumerable`1<PdfItem> Get(string key, Func`2<PdfItem, bool> predicate);
    public IEnumerable`1<T> Get(string key, Func`2<T, bool> predicate);
    public IEnumerable`1<T> Get(string key, object value);
    public IEnumerable`1<T> Get(string key, T value);
    public bool Contains(string key, Func`2<T, bool> predicate);
    public bool Contains(string key, object value);
    public bool Contains(string key, T value);
    private bool Remove(string key, Func`2<PdfItem, bool> predicate);
    public bool Remove(string key, Func`2<T, bool> predicate);
    public bool Remove(string key, object value);
    public bool Remove(string key, T value);
}
internal static class PdfSharp.Pdf.Content.Chars : object {
    public static char EOF;
    public static char NUL;
    public static char CR;
    public static char LF;
    public static char BEL;
    public static char BS;
    public static char FF;
    public static char HT;
    public static char VT;
    public static char NBSP;
    public static char SP;
    public static char QuoteDouble;
    public static char QuoteSingle;
    public static char ParenLeft;
    public static char ParenRight;
    public static char BraceLeft;
    public static char BraceRight;
    public static char BracketLeft;
    public static char BracketRight;
    public static char Less;
    public static char Greater;
    public static char Equal;
    public static char Period;
    public static char Semicolon;
    public static char Colon;
    public static char Slash;
    public static char Bar;
    public static char BackSlash;
    public static char Percent;
    public static char Dollar;
    public static char At;
    public static char NumberSign;
    public static char Asterisk;
    public static char Question;
    public static char Hyphen;
    public static char SoftHyphen;
    public static char Currency;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Content.CLexer : object {
    private static Double[] PowersOf10;
    [CompilerGeneratedAttribute]
private CSymbol <Symbol>k__BackingField;
    private Byte[] _content;
    private int _charIndex;
    private char _currChar;
    private char _nextChar;
    private StringBuilder _token;
    private long _tokenAsLong;
    private double _tokenAsReal;
    public CSymbol Symbol { get; public set; }
    public string Token { get; }
    internal int TokenToInteger { get; }
    internal double TokenToReal { get; }
    public int ContLength { get; }
    public int Position { get; public set; }
    public CLexer(Byte[] content);
    public CLexer(MemoryStream content);
    private static CLexer();
    public CSymbol ScanNextToken();
    public CSymbol ScanComment();
    public CSymbol ScanInlineImage();
    public CSymbol ScanName();
    protected CSymbol ScanDictionary();
    public CSymbol ScanNumber();
    public CSymbol ScanOperator();
    public CSymbol ScanLiteralString();
    public CSymbol ScanHexadecimalString();
    private char ScanNextChar();
    private void ClearToken();
    internal char AppendAndScanNextChar();
    public char MoveToNonWhiteSpace();
    [CompilerGeneratedAttribute]
public CSymbol get_Symbol();
    [CompilerGeneratedAttribute]
public void set_Symbol(CSymbol value);
    public string get_Token();
    internal int get_TokenToInteger();
    internal double get_TokenToReal();
    internal static bool IsWhiteSpace(char ch);
    internal static bool IsOperatorChar(char ch);
    internal static bool IsDelimiter(char ch);
    public int get_ContLength();
    public int get_Position();
    public void set_Position(int value);
    [CompilerGeneratedAttribute]
internal static char <ScanName>g__LogError|5_0(char ch);
    [CompilerGeneratedAttribute]
internal static char <ScanHexadecimalString>g__LogError|11_0(char ch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class PdfSharp.Pdf.Content.ContentReader : object {
    public static CSequence ReadContent(PdfPage page);
    public static CSequence ReadContent(Byte[] content);
    public static CSequence ReadContent(MemoryStream content);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Content.ContentReaderException : PdfSharpException {
    public ContentReaderException(string message);
    public ContentReaderException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Content.ContentWriter : object {
    protected int _indent;
    private int _writeIndent;
    private CharCat _lastCat;
    [NullableAttribute("2")]
private Stream _stream;
    public int Position { get; }
    internal int Indent { get; internal set; }
    private string IndentBlanks { get; }
    internal Stream Stream { get; }
    public ContentWriter(Stream contentStream);
    public void Close(bool closeUnderlyingStream);
    public void Close();
    public int get_Position();
    public void Write(bool value);
    public void WriteRaw(string rawString);
    public void WriteLineRaw(string rawString);
    public void WriteRaw(char ch);
    internal int get_Indent();
    internal void set_Indent(int value);
    private void IncreaseIndent();
    private void DecreaseIndent();
    private string get_IndentBlanks();
    private void WriteIndent();
    private void WriteSeparator(CharCat cat, char ch);
    private void WriteSeparator(CharCat cat);
    public void NewLine();
    private CharCat GetCategory(char ch);
    internal Stream get_Stream();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Content.CParser : object {
    private CSequence _operands;
    private PdfPage _page;
    private CLexer _lexer;
    public CSymbol Symbol { get; }
    public CParser(PdfPage page);
    public CParser(Byte[] content);
    public CParser(MemoryStream content);
    public CParser(CLexer lexer);
    public CSymbol get_Symbol();
    public CSequence ReadContent();
    private void ParseObject(CSequence sequence, CSymbol stop);
    private COperator CreateOperator();
    private COperator CreateOperator(OpCodeName nameop);
    private COperator CreateOperator(COperator op);
    private CSymbol ScanNextToken();
    private CSymbol ScanNextToken(String& token);
    private CSymbol ReadSymbol(CSymbol symbol);
}
public enum PdfSharp.Pdf.Content.CSymbol : Enum {
    public int value__;
    public static CSymbol None;
    public static CSymbol Comment;
    public static CSymbol Integer;
    public static CSymbol Real;
    public static CSymbol String;
    public static CSymbol HexString;
    public static CSymbol UnicodeString;
    public static CSymbol UnicodeHexString;
    public static CSymbol Name;
    public static CSymbol Operator;
    public static CSymbol BeginArray;
    public static CSymbol EndArray;
    public static CSymbol Dictionary;
    public static CSymbol Eof;
    public static CSymbol Error;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("(count={Count})")]
public class PdfSharp.Pdf.Content.Objects.CArray : CSequence {
    public CArray Clone();
    public virtual string ToString();
    internal virtual void WriteObject(ContentWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("({Text})")]
public class PdfSharp.Pdf.Content.Objects.CComment : CObject {
    [NullableAttribute("2")]
private string _text;
    public string Text { get; public set; }
    public CComment Clone();
    public string get_Text();
    public void set_Text(string value);
    public virtual string ToString();
    internal virtual void WriteObject(ContentWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharp.Pdf.Content.Objects.CInteger : CNumber {
    private int _value;
    public int Value { get; public set; }
    public CInteger Clone();
    public int get_Value();
    public void set_Value(int value);
    public virtual string ToString();
    internal virtual void WriteObject(ContentWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("({Name})")]
public class PdfSharp.Pdf.Content.Objects.CName : CObject {
    [NullableAttribute("2")]
private string _name;
    public string Name { get; public set; }
    public CName(string name);
    public CName Clone();
    public string get_Name();
    public void set_Name(string value);
    [NullableContextAttribute("2")]
public virtual string ToString();
    internal virtual void WriteObject(ContentWriter writer);
}
public abstract class PdfSharp.Pdf.Content.Objects.CNumber : CObject {
    [NullableContextAttribute("1")]
public CNumber Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class PdfSharp.Pdf.Content.Objects.CObject : object {
    private sealed virtual override object System.ICloneable.Clone();
    public CObject Clone();
    protected virtual CObject Copy();
    internal abstract virtual void WriteObject(ContentWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
[DebuggerTypeProxyAttribute("PdfSharp.Pdf.Content.Objects.COperator/COperatorDebuggerDisplay")]
public class PdfSharp.Pdf.Content.Objects.COperator : CObject {
    [NullableAttribute("2")]
private CSequence _sequence;
    private OpCode _opCode;
    [CompilerGeneratedAttribute]
private static Func`2<COperator, string> <debuggerDisplay>k__BackingField;
    public string Name { get; }
    public CSequence Operands { get; }
    public OpCode OpCode { get; }
    public static Func`2<COperator, string> debuggerDisplay { get; public set; }
    private string DebuggerDisplay { get; }
    internal COperator(OpCode opcode);
    private static COperator();
    public COperator Clone();
    public virtual string get_Name();
    public CSequence get_Operands();
    public OpCode get_OpCode();
    public virtual string ToString();
    internal virtual void WriteObject(ContentWriter writer);
    [CompilerGeneratedAttribute]
public static Func`2<COperator, string> get_debuggerDisplay();
    [CompilerGeneratedAttribute]
public static void set_debuggerDisplay(Func`2<COperator, string> value);
    private string get_DebuggerDisplay();
    public string ToString(int maxOperandsStringLength);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharp.Pdf.Content.Objects.CReal : CNumber {
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    public double Value { get; public set; }
    public CReal Clone();
    [CompilerGeneratedAttribute]
public double get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(double value);
    public virtual string ToString();
    internal virtual void WriteObject(ContentWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("(count={Count})")]
public class PdfSharp.Pdf.Content.Objects.CSequence : CObject {
    private List`1<CObject> _items;
    public CObject Item { get; public set; }
    public int Count { get; }
    private CObject System.Collections.Generic.IList<PdfSharp.Pdf.Content.Objects.CObject>.Item { get; private set; }
    private int System.Collections.Generic.ICollection<PdfSharp.Pdf.Content.Objects.CObject>.Count { get; }
    private bool System.Collections.Generic.ICollection<PdfSharp.Pdf.Content.Objects.CObject>.IsReadOnly { get; }
    public CSequence Clone();
    protected virtual CObject Copy();
    public void Add(CSequence sequence);
    public void Add(CObject value);
    public void Clear();
    public bool Contains(CObject value);
    public int IndexOf(CObject value);
    public void Insert(int index, CObject value);
    public bool Remove(CObject value);
    public void RemoveAt(int index);
    public CObject get_Item(int index);
    public void set_Item(int index, CObject value);
    public void CopyTo(CObject[] array, int index);
    public int get_Count();
    public IEnumerator`1<CObject> GetEnumerator();
    public Byte[] ToContent();
    public virtual string ToString();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal virtual void WriteObject(ContentWriter writer);
    private sealed virtual override int System.Collections.Generic.IList<PdfSharp.Pdf.Content.Objects.CObject>.IndexOf(CObject item);
    private sealed virtual override void System.Collections.Generic.IList<PdfSharp.Pdf.Content.Objects.CObject>.Insert(int index, CObject item);
    private sealed virtual override void System.Collections.Generic.IList<PdfSharp.Pdf.Content.Objects.CObject>.RemoveAt(int index);
    private sealed virtual override CObject System.Collections.Generic.IList<PdfSharp.Pdf.Content.Objects.CObject>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<PdfSharp.Pdf.Content.Objects.CObject>.set_Item(int index, CObject value);
    private sealed virtual override void System.Collections.Generic.ICollection<PdfSharp.Pdf.Content.Objects.CObject>.Add(CObject item);
    private sealed virtual override void System.Collections.Generic.ICollection<PdfSharp.Pdf.Content.Objects.CObject>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<PdfSharp.Pdf.Content.Objects.CObject>.Contains(CObject item);
    private sealed virtual override void System.Collections.Generic.ICollection<PdfSharp.Pdf.Content.Objects.CObject>.CopyTo(CObject[] array, int arrayIndex);
    private sealed virtual override int System.Collections.Generic.ICollection<PdfSharp.Pdf.Content.Objects.CObject>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<PdfSharp.Pdf.Content.Objects.CObject>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<PdfSharp.Pdf.Content.Objects.CObject>.Remove(CObject item);
    private sealed virtual override IEnumerator`1<CObject> System.Collections.Generic.IEnumerable<PdfSharp.Pdf.Content.Objects.CObject>.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharp.Pdf.Content.Objects.CString : CObject {
    [NullableAttribute("2")]
private string _value;
    private Nullable`1<CStringType> _cStringType;
    public string Value { get; public set; }
    public CStringType CStringType { get; public set; }
    public CString Clone();
    public string get_Value();
    public void set_Value(string value);
    public CStringType get_CStringType();
    public void set_CStringType(CStringType value);
    public virtual string ToString();
    internal virtual void WriteObject(ContentWriter writer);
}
public enum PdfSharp.Pdf.Content.Objects.CStringType : Enum {
    public int value__;
    public static CStringType String;
    public static CStringType HexString;
    public static CStringType UnicodeString;
    public static CStringType UnicodeHexString;
    public static CStringType Dictionary;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Content.Objects.OpCode : object {
    public string Name;
    public OpCodeName OpCodeName;
    public int Operands;
    public OpCodeFlags Flags;
    [NullableAttribute("2")]
public string Postscript;
    public string Description;
    internal OpCode(string name, OpCodeName opCodeName, int operands, string postscript, OpCodeFlags flags, string description);
}
[FlagsAttribute]
public enum PdfSharp.Pdf.Content.Objects.OpCodeFlags : Enum {
    public int value__;
    public static OpCodeFlags None;
    public static OpCodeFlags TextOut;
}
public enum PdfSharp.Pdf.Content.Objects.OpCodeName : Enum {
    public int value__;
    public static OpCodeName Dictionary;
    public static OpCodeName b;
    public static OpCodeName B;
    public static OpCodeName bx;
    public static OpCodeName Bx;
    public static OpCodeName BDC;
    public static OpCodeName BI;
    public static OpCodeName BMC;
    public static OpCodeName BT;
    public static OpCodeName BX;
    public static OpCodeName c;
    public static OpCodeName cm;
    public static OpCodeName CS;
    public static OpCodeName cs;
    public static OpCodeName d;
    public static OpCodeName d0;
    public static OpCodeName d1;
    public static OpCodeName Do;
    public static OpCodeName DP;
    public static OpCodeName EI;
    public static OpCodeName EMC;
    public static OpCodeName ET;
    public static OpCodeName EX;
    public static OpCodeName f;
    public static OpCodeName F;
    public static OpCodeName fx;
    public static OpCodeName G;
    public static OpCodeName g;
    public static OpCodeName gs;
    public static OpCodeName h;
    public static OpCodeName i;
    public static OpCodeName ID;
    public static OpCodeName j;
    public static OpCodeName J;
    public static OpCodeName K;
    public static OpCodeName k;
    public static OpCodeName l;
    public static OpCodeName m;
    public static OpCodeName M;
    public static OpCodeName MP;
    public static OpCodeName n;
    public static OpCodeName q;
    public static OpCodeName Q;
    public static OpCodeName re;
    public static OpCodeName RG;
    public static OpCodeName rg;
    public static OpCodeName ri;
    public static OpCodeName s;
    public static OpCodeName S;
    public static OpCodeName SC;
    public static OpCodeName sc;
    public static OpCodeName SCN;
    public static OpCodeName scn;
    public static OpCodeName sh;
    public static OpCodeName Tx;
    public static OpCodeName Tc;
    public static OpCodeName Td;
    public static OpCodeName TD;
    public static OpCodeName Tf;
    public static OpCodeName Tj;
    public static OpCodeName TJ;
    public static OpCodeName TL;
    public static OpCodeName Tm;
    public static OpCodeName Tr;
    public static OpCodeName Ts;
    public static OpCodeName Tw;
    public static OpCodeName Tz;
    public static OpCodeName v;
    public static OpCodeName w;
    public static OpCodeName W;
    public static OpCodeName Wx;
    public static OpCodeName y;
    public static OpCodeName QuoteSingle;
    public static OpCodeName QuoteDouble;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class PdfSharp.Pdf.Content.Objects.OpCodes : object {
    private static Dictionary`2<string, OpCode> StringToOpCode;
    private static OpCode Dictionary;
    private static OpCode b;
    private static OpCode B;
    private static OpCode bx;
    private static OpCode Bx;
    private static OpCode BDC;
    private static OpCode BI;
    private static OpCode BMC;
    private static OpCode BT;
    private static OpCode BX;
    private static OpCode c;
    private static OpCode cm;
    private static OpCode CS;
    private static OpCode cs;
    private static OpCode d;
    private static OpCode d0;
    private static OpCode d1;
    private static OpCode Do;
    private static OpCode DP;
    private static OpCode EI;
    private static OpCode EMC;
    private static OpCode ET;
    private static OpCode EX;
    private static OpCode f;
    private static OpCode F;
    private static OpCode fx;
    private static OpCode G;
    private static OpCode g;
    private static OpCode gs;
    private static OpCode h;
    private static OpCode i;
    private static OpCode ID;
    private static OpCode j;
    private static OpCode J;
    private static OpCode K;
    private static OpCode k;
    private static OpCode l;
    private static OpCode m;
    private static OpCode M;
    private static OpCode MP;
    private static OpCode n;
    private static OpCode q;
    private static OpCode Q;
    private static OpCode re;
    private static OpCode RG;
    private static OpCode rg;
    private static OpCode ri;
    private static OpCode s;
    private static OpCode S;
    private static OpCode SC;
    private static OpCode sc;
    private static OpCode SCN;
    private static OpCode scn;
    private static OpCode sh;
    private static OpCode Tx;
    private static OpCode Tc;
    private static OpCode Td;
    private static OpCode TD;
    private static OpCode Tf;
    private static OpCode Tj;
    private static OpCode TJ;
    private static OpCode TL;
    private static OpCode Tm;
    private static OpCode Tr;
    private static OpCode Ts;
    private static OpCode Tw;
    private static OpCode Tz;
    private static OpCode v;
    private static OpCode w;
    private static OpCode W;
    private static OpCode Wx;
    private static OpCode y;
    private static OpCode QuoteSingle;
    private static OpCode QuoteDouble;
    private static OpCode[] ops;
    private static OpCodes();
    public static COperator OperatorFromName(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class PdfSharp.Pdf.DictionaryMeta : object {
    private Dictionary`2<string, KeyDescriptor> _keyDescriptors;
    [NullableAttribute("2")]
private KeyDescriptor _defaultContentKeyDescriptor;
    [NullableAttribute("2")]
public KeyDescriptor Item { get; }
    public DictionaryMeta(Type type);
    public DictionaryMeta(Type type, KeyType defaultContentKeyType, Type defaultContentType);
    public KeyDescriptor get_Item(string key);
}
[FlagsAttribute]
internal enum PdfSharp.Pdf.DocumentState : Enum {
    public int value__;
    public static DocumentState Created;
    public static DocumentState Imported;
    public static DocumentState Disposed;
    public static DocumentState Saved;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Filters.Ascii85Decode : Filter {
    public virtual Byte[] Encode(Byte[] data);
    public virtual Byte[] Decode(Byte[] data, FilterParms parms);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Filters.AsciiHexDecode : Filter {
    public virtual Byte[] Encode(Byte[] data);
    public virtual Byte[] Decode(Byte[] data, FilterParms parms);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Filters.DctDecode : NoOpFiler {
    public virtual Byte[] Encode(Byte[] data);
    public virtual Byte[] Decode(Byte[] data, FilterParms parms);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class PdfSharp.Pdf.Filters.Filter : object {
    public abstract virtual Byte[] Encode(Byte[] data);
    public virtual Byte[] Encode(string rawString);
    public abstract virtual Byte[] Decode(Byte[] data, FilterParms parms);
    public Byte[] Decode(Byte[] data, PdfDictionary decodeParms);
    public virtual string DecodeToString(Byte[] data, FilterParms parms);
    public string DecodeToString(Byte[] data);
    protected Byte[] RemoveWhiteSpace(Byte[] data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class PdfSharp.Pdf.Filters.Filtering : object {
    [NullableAttribute("2")]
private static AsciiHexDecode _asciiHexDecode;
    [NullableAttribute("2")]
private static Ascii85Decode _ascii85Decode;
    [NullableAttribute("2")]
private static LzwDecode _lzwDecode;
    [NullableAttribute("2")]
private static FlateDecode _flateDecode;
    [NullableAttribute("2")]
private static DctDecode _dctDecode;
    public static AsciiHexDecode AsciiHexDecode { get; }
    public static Ascii85Decode Ascii85Decode { get; }
    public static LzwDecode LzwDecode { get; }
    public static FlateDecode FlateDecode { get; }
    public static DctDecode DctDecode { get; }
    public static Filter GetFilter(string filterName);
    public static AsciiHexDecode get_AsciiHexDecode();
    public static Ascii85Decode get_Ascii85Decode();
    public static LzwDecode get_LzwDecode();
    public static FlateDecode get_FlateDecode();
    public static DctDecode get_DctDecode();
    public static Byte[] Encode(Byte[] data, string filterName);
    public static Byte[] Encode(string rawString, string filterName);
    public static Byte[] Decode(Byte[] data, string filterName, FilterParms parms);
    public static Byte[] Decode(Byte[] data, string filterName);
    public static Byte[] Decode(Byte[] data, PdfItem filterItem, PdfItem decodeParms);
    public static string DecodeToString(Byte[] data, string filterName, FilterParms parms);
    public static string DecodeToString(Byte[] data, string filterName);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Filters.FilterParms : object {
    [CompilerGeneratedAttribute]
private PdfDictionary <DecodeParms>k__BackingField;
    public PdfDictionary DecodeParms { get; private set; }
    public FilterParms(PdfDictionary decodeParms);
    [CompilerGeneratedAttribute]
public PdfDictionary get_DecodeParms();
    [CompilerGeneratedAttribute]
private void set_DecodeParms(PdfDictionary value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Filters.FlateDecode : Filter {
    public virtual Byte[] Encode(Byte[] data);
    public Byte[] Encode(Byte[] data, PdfFlateEncodeMode mode);
    public virtual Byte[] Decode(Byte[] data, FilterParms parms);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Filters.LzwDecode : Filter {
    private Int32[] _andTable;
    private Byte[][] _stringTable;
    private Byte[] _data;
    private int _tableIndex;
    private int _bitsToGet;
    private int _bytePointer;
    private int _nextData;
    private int _nextBits;
    private int NextCode { get; }
    public virtual Byte[] Encode(Byte[] data);
    public virtual Byte[] Decode(Byte[] data, FilterParms parms);
    private void InitializeDictionary();
    private void AddEntry(Byte[] oldstring, byte newstring);
    private int get_NextCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class PdfSharp.Pdf.Filters.NoOpFiler : Filter {
    public virtual Byte[] Encode(Byte[] data);
    public virtual Byte[] Decode(Byte[] data, FilterParms parms);
}
internal static class PdfSharp.Pdf.Filters.PngFilter : object {
    [NullableContextAttribute("1")]
internal static void Unfilter(int stride, int bpp, Byte[] inData, Byte[] outData);
    private static byte PaethPredictor(byte a, byte b, byte c);
}
internal static class PdfSharp.Pdf.Filters.StreamDecoder : object {
    [NullableContextAttribute("1")]
public static Byte[] Decode(Byte[] data, PdfDictionary decodeParms);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Internal.AnsiEncoding : Encoding {
    private static Char[] AnsiToUnicode;
    private static AnsiEncoding();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public static bool IsAnsi(char ch);
    public static bool IsAnsi(string s);
    public static bool IsAnsi(Int32[] codePoints);
    public static char UnicodeToAnsi(char ch, char nonAnsi);
}
internal static class PdfSharp.Pdf.Internal.ColorSpaceHelper : object {
    public static XColor EnsureColorMode(PdfColorMode colorMode, XColor color);
    [NullableContextAttribute("1")]
public static XColor EnsureColorMode(PdfDocument document, XColor color);
    public static bool IsEqualCmyk(XColor x, XColor y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Internal.DocEncoding : Encoding {
    private static Byte[] AnsiToDoc;
    private static Char[] PdfDocToUnicode;
    private static DocEncoding();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
}
internal class PdfSharp.Pdf.Internal.PdfDiagnostics : object {
    private static bool _traceCompressedObjects;
    private static bool _traceXrefStreams;
    private static bool _traceObjectStreams;
    public static bool TraceCompressedObjects { get; public set; }
    public static bool TraceXrefStreams { get; public set; }
    public static bool TraceObjectStreams { get; public set; }
    private static PdfDiagnostics();
    public static bool get_TraceCompressedObjects();
    public static void set_TraceCompressedObjects(bool value);
    public static bool get_TraceXrefStreams();
    public static void set_TraceXrefStreams(bool value);
    public static bool get_TraceObjectStreams();
    public static void set_TraceObjectStreams(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class PdfSharp.Pdf.Internal.PdfEncoders : object {
    [NullableAttribute("2")]
private static Encoding _rawEncoding;
    [NullableAttribute("2")]
private static Encoding _rawUnicodeEncoding;
    [NullableAttribute("2")]
private static Encoding _winAnsiEncoding;
    [NullableAttribute("2")]
private static Encoding _docEncoding;
    [NullableAttribute("2")]
private static Encoding _unicodeEncoding;
    private static Byte[] docencode_______;
    [NullableAttribute("2")]
private static string s_formatRGB;
    [NullableAttribute("2")]
private static string s_formatCMYK;
    public static Encoding RawEncoding { get; }
    public static Encoding RawUnicodeEncoding { get; }
    public static Encoding WinAnsiEncoding { get; }
    public static Encoding DocEncoding { get; }
    public static Encoding UnicodeEncoding { get; }
    private static PdfEncoders();
    public static Encoding get_RawEncoding();
    public static Encoding get_RawUnicodeEncoding();
    public static Encoding get_WinAnsiEncoding();
    public static Encoding get_DocEncoding();
    public static Encoding get_UnicodeEncoding();
    public static string ToStringLiteral(string text, PdfStringEncoding encoding, PdfStandardSecurityHandler effectiveSecurityHandler);
    [NullableContextAttribute("2")]
public static string ToStringLiteral(Byte[] bytes, bool unicode, PdfStandardSecurityHandler effectiveSecurityHandler);
    public static string ToHexStringLiteral(string text, PdfStringEncoding encoding, PdfStandardSecurityHandler effectiveSecurityHandler);
    [NullableContextAttribute("2")]
public static string ToHexStringLiteral(Byte[] bytes, bool unicode, bool prefix, PdfStandardSecurityHandler securityHandler);
    [NullableContextAttribute("2")]
public static Byte[] FormatStringLiteral(Byte[] bytes, bool unicode, bool prefix, bool hex, PdfStandardSecurityHandler effectiveSecurityHandler);
    public static string Format(string format, Object[] args);
    public static string ToString(double val);
    public static string ToString(XColor color, PdfColorMode colorMode);
    public static string ToString(XMatrix matrix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Internal.RawEncoding : Encoding {
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Internal.RawUnicodeEncoding : Encoding {
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Internal.ThreadLocalStorage : object {
    private Dictionary`2<string, DocumentHandle> _importedDocuments;
    public PdfDocument[] Documents { get; }
    public void AddDocument(string path, PdfDocument document);
    public void RemoveDocument(string path);
    public PdfDocument GetDocument(string path);
    public PdfDocument[] get_Documents();
    public void DetachDocument(DocumentHandle handle);
}
public static class PdfSharp.Pdf.IO.Chars : object {
    public static char EOF;
    public static char NUL;
    public static char CR;
    public static char LF;
    public static char BEL;
    public static char BS;
    public static char FF;
    public static char HT;
    public static char VT;
    public static char NonBreakableSpace;
    public static char SP;
    public static char QuoteDouble;
    public static char QuoteSingle;
    public static char ParenLeft;
    public static char ParenRight;
    public static char BraceLeft;
    public static char BraceRight;
    public static char BracketLeft;
    public static char BracketRight;
    public static char Less;
    public static char Greater;
    public static char Equal;
    public static char Period;
    public static char Semicolon;
    public static char Colon;
    public static char Slash;
    public static char Bar;
    public static char BackSlash;
    public static char Percent;
    public static char Dollar;
    public static char At;
    public static char NumberSign;
    public static char Question;
    public static char Hyphen;
    public static char SoftHyphen;
    public static char Currency;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.IO.Lexer : object {
    private static Double[] PowersOf10;
    [CompilerGeneratedAttribute]
private Symbol <Symbol>k__BackingField;
    private long _pdfLength;
    private long _idxChar;
    private char _currChar;
    private char _nextChar;
    private StringBuilder _token;
    private long _tokenAsLong;
    private double _tokenAsReal;
    [NullableAttribute("0")]
private ValueTuple`2<int, int> _tokenAsObjectID;
    private Stream _pdfStream;
    private ILogger _logger;
    public long Position { get; public set; }
    public Symbol Symbol { get; public set; }
    public string Token { get; }
    public bool TokenToBoolean { get; }
    public int TokenToInteger { get; }
    public long TokenToLongInteger { get; }
    public double TokenToReal { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("0")]
public ValueTuple`2<int, int> TokenToObjectID { get; }
    public long PdfLength { get; }
    public Lexer(Stream pdfInputStream, ILogger logger);
    private static Lexer();
    public long get_Position();
    public void set_Position(long value);
    public Symbol ScanNextToken(bool testForObjectReference);
    public string RandomReadRawString(long position, int length);
    public Symbol ScanComment();
    public Symbol ScanName();
    public Symbol ScanNumber(bool testForObjectReference);
    public Symbol ScanKeyword();
    public Symbol ScanStringLiteral();
    public Symbol ScanHexadecimalString();
    public bool TryScanLiterally(string literal);
    public long FindStreamStartPosition(PdfObjectID id);
    public Byte[] ScanStream(long position, int length);
    [NullableContextAttribute("2")]
public int DetermineStreamLength(long start, int searchLength, SuppressExceptions suppressObjectOrderExceptions);
    public bool TryScanEndStreamSymbol();
    public string ScanRawString(long position, int length);
    internal char ScanNextChar(bool handleCRLF);
    private void ClearToken();
    private char AppendAndScanNextChar();
    public char MoveToNonWhiteSpace();
    public string DumpNeighborhoodOfPosition(long position, bool hex, int range);
    [CompilerGeneratedAttribute]
public Symbol get_Symbol();
    [CompilerGeneratedAttribute]
public void set_Symbol(Symbol value);
    public string get_Token();
    public bool get_TokenToBoolean();
    public int get_TokenToInteger();
    public long get_TokenToLongInteger();
    public double get_TokenToReal();
    [NullableContextAttribute("0")]
public ValueTuple`2<int, int> get_TokenToObjectID();
    internal static bool IsWhiteSpace(char ch);
    internal static bool IsDelimiter(char ch);
    public long get_PdfLength();
    [CompilerGeneratedAttribute]
internal static char <ScanName>g__LogError|7_0(char ch);
    [CompilerGeneratedAttribute]
private int <ScanNumber>g__TryReadReference|8_0();
    [CompilerGeneratedAttribute]
internal static char <ScanHexadecimalString>g__LogError|12_0(char ch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.IO.ObjectNotAvailableException : PdfReaderException {
    public ObjectNotAvailableException(string message);
    public ObjectNotAvailableException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.IO.Parser : object {
    private PdfDocument _document;
    private PdfReaderOptions _options;
    private Lexer _lexer;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<PdfObjectID, ValueTuple`2<PdfObjectStream, Parser>> _objectStreamsWithParsers;
    private Parser _documentParser;
    private int _endStreamNotFoundCounter;
    private ILogger _logger;
    public Symbol Symbol { get; }
    public Parser(PdfDocument document, PdfReaderOptions options, ILogger logger);
    public Parser(PdfDocument document, Stream objectStream, Parser documentParser);
    [NullableContextAttribute("2")]
public long MoveToObject(PdfObjectID objectID, SuppressExceptions suppressObjectOrderExceptions);
    public Symbol get_Symbol();
    public PdfObjectID ReadObjectNumber(long position);
    [NullableContextAttribute("2")]
private PdfObject ReadObjectInternal(PdfObject pdfObject, PdfObjectID objectID, bool includeReferences, bool fromObjectStream, SuppressExceptions suppressObjectOrderExceptions);
    private void ReadDictionaryStream(PdfDictionary dict, SuppressExceptions suppressObjectOrderExceptions);
    private int GetStreamLength(PdfDictionary dict, SuppressExceptions suppressObjectOrderExceptions);
    private bool TryReadEndStream(PdfDictionary dict, long streamStart, Int32& streamLength, SuppressExceptions suppressObjectOrderExceptions);
    public PdfArray ReadArray(PdfArray array, bool includeReferences);
    internal PdfDictionary ReadDictionary(PdfDictionary dict, bool includeReferences);
    private List`1<PdfItem> ParseObject(Symbol stopSymbol);
    private Symbol ScanNextToken(bool testForObjectReference);
    private Symbol SkipCharsUntil(Symbol stop);
    private Symbol SkipCharsUntil(string text, Symbol stop);
    [NullableContextAttribute("2")]
private void ReadObjectID(PdfObject obj);
    private PdfItem ReadReference(PdfReference iref, bool includeReferences);
    private Symbol ReadSymbol(Symbol symbol);
    private string ReadName();
    private int ReadInteger();
    private long ReadSize();
    internal PdfObject ReadIndirectObject(PdfReference pdfReference, SuppressExceptions suppressObjectOrderExceptions, bool withoutDecrypting);
    private PdfObject ReadIndirectObjectFromObjectStreamInternal(PdfObjectID objectID, SuppressExceptions suppressObjectOrderExceptions);
    internal void ReadAllIndirectObjects();
    private List`1<PdfObjectID> LoadObjectStreamIDs(PdfReference[] pdfReferences);
    internal void ReadAllObjectStreamsAndTheirReferences();
    private PdfObjectStream ReadObjectStream(PdfReference reference, SuppressExceptions suppressObjectOrderExceptions);
    internal Int32[][] ReadObjectStreamHeader(int n, int first);
    internal PdfTrailer ReadTrailer();
    private PdfTrailer ReadXRefTableAndTrailer(PdfCrossReferenceTable xrefTable);
    private bool CheckXRefTableEntry(long position, int id, int generation, Int32& idChecked, Int32& generationChecked);
    private PdfTrailer ReadXRefStream(PdfCrossReferenceTable xrefTable);
    internal static DateTime ParseDateTime(string date, DateTime errorValue);
    private ParserState SaveState();
    private void RestoreState(ParserState state);
}
public enum PdfSharp.Pdf.IO.PasswordValidity : Enum {
    public int value__;
    public static PasswordValidity Invalid;
    public static PasswordValidity UserPassword;
    public static PasswordValidity OwnerPassword;
}
public enum PdfSharp.Pdf.IO.PdfDocumentOpenMode : Enum {
    public int value__;
    public static PdfDocumentOpenMode Modify;
    public static PdfDocumentOpenMode Import;
    [ObsoleteAttribute("ReadOnly is not implemented, use Import instead.")]
public static PdfDocumentOpenMode ReadOnly;
    [ObsoleteAttribute("InformationOnly is not implemented, use Import instead.")]
public static PdfDocumentOpenMode InformationOnly;
}
public class PdfSharp.Pdf.IO.PdfPasswordProvider : MulticastDelegate {
    public PdfPasswordProvider(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(PdfPasswordProviderArgs args);
    public virtual IAsyncResult BeginInvoke(PdfPasswordProviderArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class PdfSharp.Pdf.IO.PdfPasswordProviderArgs : object {
    [NullableAttribute("1")]
public string Password;
    public bool Abort;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.IO.PdfReader : object {
    private PdfReaderOptions _options;
    private PdfDocument _document;
    private ILogger _logger;
    [NullableContextAttribute("2")]
private PdfReader(ILogger logger, PdfReaderOptions options);
    public static int TestPdfFile(string path);
    public static int TestPdfFile(Stream stream);
    public static int TestPdfFile(Byte[] data);
    internal static int GetPdfFileVersion(Byte[] bytes);
    public static PdfDocument Open(string path, PdfDocumentOpenMode openMode, PdfReaderOptions options);
    public static PdfDocument Open(string path, PdfDocumentOpenMode openMode, PdfPasswordProvider passwordProvider, PdfReaderOptions options);
    public static PdfDocument Open(string path, string password, PdfDocumentOpenMode openMode, PdfReaderOptions options);
    [NullableContextAttribute("2")]
public static PdfDocument Open(string path, string password, PdfDocumentOpenMode openMode, PdfPasswordProvider passwordProvider, PdfReaderOptions options);
    public static PdfDocument Open(string path, PdfReaderOptions options);
    public static PdfDocument Open(string path, string password, PdfReaderOptions options);
    public static PdfDocument Open(Stream stream);
    public static PdfDocument Open(Stream stream, PdfDocumentOpenMode openMode, PdfReaderOptions options);
    public static PdfDocument Open(Stream stream, PdfDocumentOpenMode openMode, PdfPasswordProvider passwordProvider, PdfReaderOptions options);
    public static PdfDocument Open(Stream stream, string password, PdfDocumentOpenMode openMode, PdfReaderOptions options);
    [NullableContextAttribute("2")]
public static PdfDocument Open(Stream stream, string password, PdfDocumentOpenMode openMode, PdfPasswordProvider passwordProvider, PdfReaderOptions options);
    private PdfDocument OpenFromFile(string path, string password, PdfDocumentOpenMode openMode, PdfPasswordProvider passwordProvider);
    [NullableContextAttribute("2")]
private PdfDocument OpenFromStream(Stream stream, string password, PdfDocumentOpenMode openMode, PdfPasswordProvider passwordProvider, PdfReaderOptions options);
    private void FinishReferences();
    private void FinishItemReferences(PdfItem pdfItem, PdfDocument document, HashSet`1<PdfObject> finishedObjects);
    private void FinishChildReferences(PdfDictionary dictionary, HashSet`1<PdfObject> finishedObjects);
    private void FinishChildReferences(PdfArray array, HashSet`1<PdfObject> finishedObjects);
    private bool FinishReference(PdfReference currentReference, PdfItem& actualReference, PdfItem& value);
    private void RereadUnicodeStrings();
    private static void RereadUnicodeStrings(PdfItem pdfItem);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.IO.PdfReaderException : PdfSharpException {
    public PdfReaderException(string message);
    public PdfReaderException(string message, Exception innerException);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.IO.PdfReaderOptions : object {
    [CompilerGeneratedAttribute]
private PdfReaderProblemBehavior <InvalidStreamLength>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfReaderProblemBehavior <ReferenceToUndefinedObject>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfReaderProblemBehavior <IssuesWithDecryption>k__BackingField;
    [CompilerGeneratedAttribute]
private ReaderProblemDelegate <ReaderProblemCallback>k__BackingField;
    public PdfReaderProblemBehavior InvalidStreamLength { get; public set; }
    public PdfReaderProblemBehavior ReferenceToUndefinedObject { get; public set; }
    public PdfReaderProblemBehavior IssuesWithDecryption { get; public set; }
    public ReaderProblemDelegate ReaderProblemCallback { get; public set; }
    [CompilerGeneratedAttribute]
public PdfReaderProblemBehavior get_InvalidStreamLength();
    [CompilerGeneratedAttribute]
public void set_InvalidStreamLength(PdfReaderProblemBehavior value);
    [CompilerGeneratedAttribute]
public PdfReaderProblemBehavior get_ReferenceToUndefinedObject();
    [CompilerGeneratedAttribute]
public void set_ReferenceToUndefinedObject(PdfReaderProblemBehavior value);
    [CompilerGeneratedAttribute]
public PdfReaderProblemBehavior get_IssuesWithDecryption();
    [CompilerGeneratedAttribute]
public void set_IssuesWithDecryption(PdfReaderProblemBehavior value);
    [CompilerGeneratedAttribute]
public ReaderProblemDelegate get_ReaderProblemCallback();
    [CompilerGeneratedAttribute]
public void set_ReaderProblemCallback(ReaderProblemDelegate value);
}
public enum PdfSharp.Pdf.IO.PdfReaderProblemBehavior : Enum {
    public int value__;
    public static PdfReaderProblemBehavior SilentlyIgnore;
    public static PdfReaderProblemBehavior LogInformation;
    public static PdfReaderProblemBehavior LogWarning;
    public static PdfReaderProblemBehavior LogError;
    public static PdfReaderProblemBehavior ThrowException;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.IO.PdfReaderProblemDetails : object {
    [CompilerGeneratedAttribute]
private PdfReaderProblemType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Behavior>k__BackingField;
    public PdfReaderProblemType Type { get; public set; }
    public string Title { get; public set; }
    public string Description { get; public set; }
    public string Behavior { get; public set; }
    [CompilerGeneratedAttribute]
public PdfReaderProblemType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(PdfReaderProblemType value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_Behavior();
    [CompilerGeneratedAttribute]
public void set_Behavior(string value);
}
public enum PdfSharp.Pdf.IO.PdfReaderProblemType : Enum {
    public int value__;
    public static PdfReaderProblemType InvalidObjectReference;
    public static PdfReaderProblemType InvalidStreamLength;
    public static PdfReaderProblemType UnreachableStreamLength;
    public static PdfReaderProblemType MultipleObjectId;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.IO.PdfWriter : object {
    [CompilerGeneratedAttribute]
private PdfWriterLayout <Layout>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfWriterOptions <Options>k__BackingField;
    private int _indent;
    private int _writeIndent;
    private CharCat _lastCat;
    private Stream _stream;
    private PdfDocument _document;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PdfStandardSecurityHandler <EffectiveSecurityHandler>k__BackingField;
    private List`1<StackItem> _stack;
    private int _commentPosition;
    public long Position { get; }
    public PdfWriterLayout Layout { get; public set; }
    public PdfWriterOptions Options { get; public set; }
    internal int Indent { get; internal set; }
    private string IndentBlanks { get; }
    internal Stream Stream { get; }
    [NullableAttribute("2")]
internal PdfStandardSecurityHandler EffectiveSecurityHandler { get; internal set; }
    public PdfWriter(Stream pdfStream, PdfDocument document, PdfStandardSecurityHandler effectiveSecurityHandler);
    public void Close(bool closeUnderlyingStream);
    public void Close();
    public long get_Position();
    [CompilerGeneratedAttribute]
public PdfWriterLayout get_Layout();
    [CompilerGeneratedAttribute]
public void set_Layout(PdfWriterLayout value);
    [CompilerGeneratedAttribute]
public PdfWriterOptions get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(PdfWriterOptions value);
    public void Write(bool value);
    public void Write(PdfBoolean value);
    public void Write(int value);
    public void Write(long value);
    public void Write(UInt32 value);
    public void Write(PdfInteger value);
    public void Write(PdfUInteger value);
    public void Write(PdfLongInteger value);
    public void Write(double value);
    public void Write(PdfReal value);
    public void Write(PdfString value);
    public void Write(PdfSignaturePlaceholderItem item, Int64& startPosition, Int64& endPosition);
    public void Write(PdfName value);
    public void Write(PdfLiteral value);
    public void Write(PdfRectangle rect);
    public void Write(PdfReference iref);
    public void WriteDocString(string text, bool unicode);
    public void WriteDocString(string text);
    public void WriteDocStringHex(string text);
    public void WriteBeginObject(PdfObject obj);
    public void WriteEndObject();
    public void WriteStream(PdfDictionary value, bool omitStream);
    public void WriteRaw(string rawString);
    public void WriteRaw(char ch);
    public void Write(Byte[] bytes);
    private void WriteObjectAddress(PdfObject value);
    public void WriteFileHeader(PdfDocument document);
    public void WriteEof(PdfDocument document, long startxref);
    internal int get_Indent();
    internal void set_Indent(int value);
    private void IncreaseIndent();
    private void DecreaseIndent();
    private string get_IndentBlanks();
    private void WriteIndent();
    private void WriteSeparator(CharCat cat);
    public void NewLine();
    private static CharCat GetCategory(char ch);
    internal Stream get_Stream();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal PdfStandardSecurityHandler get_EffectiveSecurityHandler();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_EffectiveSecurityHandler(PdfStandardSecurityHandler value);
}
public enum PdfSharp.Pdf.IO.PdfWriterLayout : Enum {
    public int value__;
    public static PdfWriterLayout Compact;
    public static PdfWriterLayout Standard;
    public static PdfWriterLayout Indented;
    public static PdfWriterLayout Verbose;
}
[FlagsAttribute]
internal enum PdfSharp.Pdf.IO.PdfWriterOptions : Enum {
    public int value__;
    public static PdfWriterOptions Regular;
    public static PdfWriterOptions OmitStream;
    public static PdfWriterOptions OmitInflation;
}
public class PdfSharp.Pdf.IO.ReaderProblemDelegate : MulticastDelegate {
    public ReaderProblemDelegate(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(PdfReaderProblemDetails details);
    public virtual IAsyncResult BeginInvoke(PdfReaderProblemDetails details, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class PdfSharp.Pdf.IO.StreamHelper : object {
    public static int WSize(Int32[] w);
    public static UInt32 ReadBytes(Byte[] bytes, int index, int byteCount);
}
public enum PdfSharp.Pdf.IO.Symbol : Enum {
    public int value__;
    public static Symbol None;
    public static Symbol Comment;
    public static Symbol Null;
    public static Symbol Integer;
    public static Symbol LongInteger;
    public static Symbol Real;
    public static Symbol Boolean;
    public static Symbol String;
    public static Symbol HexString;
    public static Symbol UnicodeString;
    public static Symbol UnicodeHexString;
    public static Symbol Name;
    public static Symbol Keyword;
    public static Symbol BeginStream;
    public static Symbol EndStream;
    public static Symbol BeginArray;
    public static Symbol EndArray;
    public static Symbol BeginDictionary;
    public static Symbol EndDictionary;
    public static Symbol Obj;
    public static Symbol EndObj;
    public static Symbol R;
    public static Symbol XRef;
    public static Symbol Trailer;
    public static Symbol StartXRef;
    public static Symbol Eof;
    public static Symbol ObjRef;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.KeyDescriptor : object {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyType <KeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FixedValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ObjectType>k__BackingField;
    public string Version { get; public set; }
    public KeyType KeyType { get; public set; }
    public string KeyValue { get; public set; }
    public string FixedValue { get; }
    public Type ObjectType { get; public set; }
    public bool CanBeIndirect { get; }
    public KeyDescriptor(KeyInfoAttribute attribute);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public KeyType get_KeyType();
    [CompilerGeneratedAttribute]
public void set_KeyType(KeyType value);
    [CompilerGeneratedAttribute]
public string get_KeyValue();
    [CompilerGeneratedAttribute]
public void set_KeyValue(string value);
    [CompilerGeneratedAttribute]
public string get_FixedValue();
    [CompilerGeneratedAttribute]
public Type get_ObjectType();
    [CompilerGeneratedAttribute]
public void set_ObjectType(Type value);
    public bool get_CanBeIndirect();
    public Type GetValueType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.KeyInfoAttribute : Attribute {
    [NullableAttribute("2")]
private string _version;
    private KeyType _entryType;
    [NullableAttribute("2")]
private Type _objectType;
    [NullableAttribute("2")]
private string _fixedValue;
    public string Version { get; public set; }
    public KeyType KeyType { get; public set; }
    public Type ObjectType { get; public set; }
    public string FixedValue { get; public set; }
    public KeyInfoAttribute(KeyType keyType);
    public KeyInfoAttribute(string version, KeyType keyType);
    public KeyInfoAttribute(KeyType keyType, Type objectType);
    public KeyInfoAttribute(string version, KeyType keyType, Type objectType);
    public string get_Version();
    public void set_Version(string value);
    public KeyType get_KeyType();
    public void set_KeyType(KeyType value);
    public Type get_ObjectType();
    public void set_ObjectType(Type value);
    public string get_FixedValue();
    public void set_FixedValue(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.KeysBase : object {
    internal static DictionaryMeta CreateMeta(Type type);
    internal static DictionaryMeta CreateMeta(Type type, KeyType defaultContentKeyType, Type defaultContentType);
}
[FlagsAttribute]
internal enum PdfSharp.Pdf.KeyType : Enum {
    public int value__;
    public static KeyType Name;
    public static KeyType String;
    public static KeyType Boolean;
    public static KeyType Integer;
    public static KeyType Real;
    public static KeyType Date;
    public static KeyType Rectangle;
    public static KeyType Array;
    public static KeyType Dictionary;
    public static KeyType Stream;
    public static KeyType NumberTree;
    public static KeyType Function;
    public static KeyType TextString;
    public static KeyType ByteString;
    public static KeyType NameTree;
    public static KeyType FileSpecification;
    public static KeyType NameOrArray;
    public static KeyType NameOrDictionary;
    public static KeyType ArrayOrDictionary;
    public static KeyType StreamOrArray;
    public static KeyType StreamOrName;
    public static KeyType ArrayOrNameOrString;
    public static KeyType FunctionOrName;
    public static KeyType Various;
    public static KeyType TypeMask;
    public static KeyType Optional;
    public static KeyType Required;
    public static KeyType Inheritable;
    public static KeyType MustBeIndirect;
    public static KeyType MustNotBeIndirect;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharp.Pdf.PdfArray : PdfObject {
    [NullableAttribute("2")]
private ArrayElements _elements;
    public ArrayElements Elements { get; }
    private string DebuggerDisplay { get; }
    public PdfArray(PdfDocument document);
    public PdfArray(PdfDocument document, PdfItem[] items);
    protected PdfArray(PdfArray array);
    public PdfArray Clone();
    protected virtual object Copy();
    public ArrayElements get_Elements();
    public virtual IEnumerator`1<PdfItem> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
    private string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharp.Pdf.PdfBoolean : PdfItem {
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public static PdfBoolean True;
    public static PdfBoolean False;
    public bool Value { get; }
    public PdfBoolean(bool value);
    private static PdfBoolean();
    [CompilerGeneratedAttribute]
public bool get_Value();
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharp.Pdf.PdfBooleanObject : PdfObject {
    private bool _value;
    public bool Value { get; }
    public PdfBooleanObject(bool value);
    public PdfBooleanObject(PdfDocument document, bool value);
    public bool get_Value();
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
}
public enum PdfSharp.Pdf.PdfColorMode : Enum {
    public int value__;
    public static PdfColorMode Undefined;
    public static PdfColorMode Rgb;
    public static PdfColorMode Cmyk;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.PdfCustomValue : PdfDictionary {
    public PdfCustomValueCompressionMode CompressionMode;
    [NullableAttribute("2")]
public Byte[] Value { get; public set; }
    public PdfCustomValue(Byte[] bytes);
    internal PdfCustomValue(PdfDocument document);
    internal PdfCustomValue(PdfDictionary dict);
    [NullableContextAttribute("2")]
public Byte[] get_Value();
    [NullableContextAttribute("2")]
public void set_Value(Byte[] value);
}
public enum PdfSharp.Pdf.PdfCustomValueCompressionMode : Enum {
    public int value__;
    public static PdfCustomValueCompressionMode Default;
    public static PdfCustomValueCompressionMode Uncompressed;
    public static PdfCustomValueCompressionMode Compressed;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class PdfSharp.Pdf.PdfCustomValues : PdfDictionary {
    unknown PdfCustomValueCompressionMode CompressionMode {public set; }
    [NullableAttribute("2")]
public PdfCustomValue Item { get; public set; }
    internal PdfCustomValues(PdfDocument document);
    internal PdfCustomValues(PdfDictionary dict);
    public void set_CompressionMode(PdfCustomValueCompressionMode value);
    public bool Contains(string key);
    public PdfCustomValue get_Item(string key);
    public void set_Item(string key, PdfCustomValue value);
    public static void ClearAllCustomValues(PdfDocument document);
    internal static PdfCustomValues Get(DictionaryElements elem);
    internal static void Remove(DictionaryElements elem);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharp.Pdf.PdfDate : PdfItem {
    [CompilerGeneratedAttribute]
private DateTime <Value>k__BackingField;
    public DateTime Value { get; }
    public PdfDate(string value);
    public PdfDate(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_Value();
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharp.Pdf.PdfDictionary : PdfObject {
    [NullableAttribute("2")]
internal DictionaryElements _elements;
    [NullableAttribute("2")]
private PdfStream _stream;
    public DictionaryElements Elements { get; }
    public PdfStream Stream { get; public set; }
    internal DictionaryMeta Meta { get; }
    private string DebuggerDisplay { get; }
    public PdfDictionary(PdfDocument document);
    protected PdfDictionary(PdfDictionary dict);
    public PdfDictionary Clone();
    protected virtual object Copy();
    public DictionaryElements get_Elements();
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, PdfItem>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
    internal virtual void WriteDictionaryElement(PdfWriter writer, PdfName key);
    internal virtual void WriteDictionaryStream(PdfWriter writer);
    public PdfStream get_Stream();
    public void set_Stream(PdfStream value);
    public PdfStream CreateStream(Byte[] value);
    internal virtual DictionaryMeta get_Meta();
    private string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("(Name={Name})")]
public class PdfSharp.Pdf.PdfDocument : PdfObject {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <Tag>k__BackingField;
    private bool _isPdfA;
    [NullableAttribute("2")]
private DocumentEvents _documentEvents;
    [NullableAttribute("2")]
private RenderEvents _renderEvents;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private static int _nameCount;
    [NullableAttribute("2")]
private PdfDocumentOptions _options;
    [NullableAttribute("2")]
private PdfDocumentSettings _settings;
    internal int _version;
    [CompilerGeneratedAttribute]
private long <FileSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullPath>k__BackingField;
    private Guid _guid;
    [NullableAttribute("2")]
private DocumentHandle _handle;
    [NullableAttribute("2")]
private PdfDocumentInformation _info;
    [NullableAttribute("2")]
private PdfCustomValues _customValues;
    [NullableAttribute("2")]
private PdfPages _pages;
    [NullableAttribute("2")]
internal PdfSecuritySettings _securitySettings;
    [NullableAttribute("2")]
private PdfFontTable _fontTable;
    [NullableAttribute("2")]
private PdfImageTable _imageTable;
    [NullableAttribute("2")]
private PdfFormXObjectTable _formTable;
    [NullableAttribute("2")]
private PdfExtGStateTable _extGStateTable;
    [NullableAttribute("2")]
private PdfFontDescriptorCache _pdfFontDescriptorCache;
    [NullableAttribute("2")]
private PdfCatalog _catalog;
    [NullableAttribute("2")]
private PdfInternals _internals;
    [CompilerGeneratedAttribute]
private PdfTrailer <Trailer>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfCrossReferenceTable <IrefTable>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Stream <OutStream>k__BackingField;
    [NullableAttribute("2")]
internal Lexer _lexer;
    internal DateTime _creation;
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static ThreadLocalStorage tls;
    internal DocumentState _state;
    internal PdfDocumentOpenMode _openMode;
    [NullableAttribute("2")]
internal UAManager _uaManager;
    [NullableAttribute("2")]
internal DigitalSignatureHandler _digitalSignatureHandler;
    [NullableAttribute("2")]
public object Tag { get; public set; }
    public bool IsPdfA { get; }
    public DocumentEvents Events { get; }
    public RenderEvents RenderEvents { get; }
    internal string Name { get; internal set; }
    internal bool CanModify { get; }
    public PdfDocumentOptions Options { get; }
    public PdfDocumentSettings Settings { get; }
    public int Version { get; public set; }
    public int PageCount { get; }
    public long FileSize { get; internal set; }
    public string FullPath { get; internal set; }
    public Guid Guid { get; }
    internal DocumentHandle Handle { get; }
    public bool IsImported { get; }
    public bool IsReadOnly { get; }
    public PdfDocumentInformation Info { get; }
    [NullableAttribute("2")]
public PdfCustomValues CustomValues { get; public set; }
    public PdfPages Pages { get; }
    public PdfPageLayout PageLayout { get; public set; }
    public PdfPageMode PageMode { get; public set; }
    public PdfViewerPreferences ViewerPreferences { get; }
    public PdfOutlineCollection Outlines { get; }
    public PdfAcroForm AcroForm { get; }
    public string Language { get; public set; }
    public PdfSecuritySettings SecuritySettings { get; }
    internal PdfFontTable FontTable { get; }
    internal PdfImageTable ImageTable { get; }
    internal PdfFormXObjectTable FormTable { get; }
    internal PdfExtGStateTable ExtGStateTable { get; }
    internal PdfFontDescriptorCache PdfFontDescriptorCache { get; }
    internal PdfCatalog Catalog { get; }
    public PdfInternals Internals { get; }
    public PdfStandardSecurityHandler SecurityHandler { get; }
    [NullableAttribute("2")]
internal PdfStandardSecurityHandler EffectiveSecurityHandler { get; }
    internal PdfTrailer Trailer { get; internal set; }
    internal PdfCrossReferenceTable IrefTable { get; internal set; }
    [NullableAttribute("2")]
internal Stream OutStream { get; internal set; }
    internal static ThreadLocalStorage Tls { get; }
    public PdfDocument(string outputFilename);
    public PdfDocument(Stream outputStream);
    internal PdfDocument(Lexer lexer);
    private void Initialize();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_Tag();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Tag(object value);
    public void SetPdfA();
    public bool get_IsPdfA();
    public DocumentEvents get_Events();
    public RenderEvents get_RenderEvents();
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    private static string NewName();
    internal bool get_CanModify();
    public void Close();
    public void Save(string path);
    [AsyncStateMachineAttribute("PdfSharp.Pdf.PdfDocument/<SaveAsync>d__32")]
public Task SaveAsync(string path);
    public void Save(Stream stream, bool closeStream);
    [AsyncStateMachineAttribute("PdfSharp.Pdf.PdfDocument/<SaveAsync>d__34")]
public Task SaveAsync(Stream stream, bool closeStream);
    [AsyncStateMachineAttribute("PdfSharp.Pdf.PdfDocument/<DoSaveAsync>d__35")]
private Task DoSaveAsync(PdfWriter writer);
    private void PrepareForPdfA();
    internal virtual void PrepareForSave();
    public bool CanSave(String& message);
    internal bool HasVersion(string version);
    public PdfDocumentOptions get_Options();
    public PdfDocumentSettings get_Settings();
    public int get_Version();
    public void set_Version(int value);
    public bool SetRequiredVersion(int requiredVersion);
    public int get_PageCount();
    [CompilerGeneratedAttribute]
public long get_FileSize();
    [CompilerGeneratedAttribute]
internal void set_FileSize(long value);
    [CompilerGeneratedAttribute]
public string get_FullPath();
    [CompilerGeneratedAttribute]
internal void set_FullPath(string value);
    public Guid get_Guid();
    internal DocumentHandle get_Handle();
    public bool get_IsImported();
    public bool get_IsReadOnly();
    public PdfDocumentInformation get_Info();
    [NullableContextAttribute("2")]
public PdfCustomValues get_CustomValues();
    [NullableContextAttribute("2")]
public void set_CustomValues(PdfCustomValues value);
    public PdfPages get_Pages();
    public PdfPageLayout get_PageLayout();
    public void set_PageLayout(PdfPageLayout value);
    public PdfPageMode get_PageMode();
    public void set_PageMode(PdfPageMode value);
    public PdfViewerPreferences get_ViewerPreferences();
    public PdfOutlineCollection get_Outlines();
    public PdfAcroForm get_AcroForm();
    public string get_Language();
    public void set_Language(string value);
    public PdfSecuritySettings get_SecuritySettings();
    public void AddCharacters(XFont font, string chars);
    internal PdfFontTable get_FontTable();
    internal PdfImageTable get_ImageTable();
    internal PdfFormXObjectTable get_FormTable();
    internal PdfExtGStateTable get_ExtGStateTable();
    internal PdfFontDescriptorCache get_PdfFontDescriptorCache();
    internal PdfCatalog get_Catalog();
    public PdfInternals get_Internals();
    public PdfPage AddPage();
    public PdfPage AddPage(PdfPage page);
    public PdfPage InsertPage(int index);
    public PdfPage InsertPage(int index, PdfPage page);
    public void AddNamedDestination(string destinationName, int destinationPage, PdfNamedDestinationParameters parameters);
    public void AddEmbeddedFile(string name, string path);
    public void AddEmbeddedFile(string name, Stream stream);
    public void Flatten();
    public PdfStandardSecurityHandler get_SecurityHandler();
    [NullableContextAttribute("2")]
internal PdfStandardSecurityHandler get_EffectiveSecurityHandler();
    [CompilerGeneratedAttribute]
internal PdfTrailer get_Trailer();
    [CompilerGeneratedAttribute]
internal void set_Trailer(PdfTrailer value);
    [CompilerGeneratedAttribute]
internal PdfCrossReferenceTable get_IrefTable();
    [CompilerGeneratedAttribute]
internal void set_IrefTable(PdfCrossReferenceTable value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal Stream get_OutStream();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_OutStream(Stream value);
    internal void OnExternalDocumentFinalized(DocumentHandle handle);
    internal static ThreadLocalStorage get_Tls();
    internal void EnsureNotYetSaved();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.PdfDocumentInformation : PdfDictionary {
    public string Title { get; public set; }
    public string Author { get; public set; }
    public string Subject { get; public set; }
    public string Keywords { get; public set; }
    public string Creator { get; public set; }
    public string Producer { get; }
    public DateTime CreationDate { get; public set; }
    public DateTime ModificationDate { get; public set; }
    internal DictionaryMeta Meta { get; }
    public PdfDocumentInformation(PdfDocument document);
    internal PdfDocumentInformation(PdfDictionary dict);
    public string get_Title();
    public void set_Title(string value);
    public string get_Author();
    public void set_Author(string value);
    public string get_Subject();
    public void set_Subject(string value);
    public string get_Keywords();
    public void set_Keywords(string value);
    public string get_Creator();
    public void set_Creator(string value);
    public string get_Producer();
    public DateTime get_CreationDate();
    public void set_CreationDate(DateTime value);
    public DateTime get_ModificationDate();
    public void set_ModificationDate(DateTime value);
    internal virtual DictionaryMeta get_Meta();
}
public class PdfSharp.Pdf.PdfDocumentOptions : object {
    private PdfColorMode _colorMode;
    private bool _compressContentStreams;
    private bool _noCompression;
    private PdfFlateEncodeMode _flateEncodeMode;
    private bool _enableCcittCompressionForBilevelImages;
    private PdfUseFlateDecoderForJpegImages _useFlateDecoderForJpegImages;
    public PdfColorMode ColorMode { get; public set; }
    public bool CompressContentStreams { get; public set; }
    public bool NoCompression { get; public set; }
    public PdfFlateEncodeMode FlateEncodeMode { get; public set; }
    public bool EnableCcittCompressionForBilevelImages { get; public set; }
    public PdfUseFlateDecoderForJpegImages UseFlateDecoderForJpegImages { get; public set; }
    [NullableContextAttribute("1")]
internal PdfDocumentOptions(PdfDocument document);
    public PdfColorMode get_ColorMode();
    public void set_ColorMode(PdfColorMode value);
    public bool get_CompressContentStreams();
    public void set_CompressContentStreams(bool value);
    public bool get_NoCompression();
    public void set_NoCompression(bool value);
    public PdfFlateEncodeMode get_FlateEncodeMode();
    public void set_FlateEncodeMode(PdfFlateEncodeMode value);
    public bool get_EnableCcittCompressionForBilevelImages();
    public void set_EnableCcittCompressionForBilevelImages(bool value);
    public PdfUseFlateDecoderForJpegImages get_UseFlateDecoderForJpegImages();
    public void set_UseFlateDecoderForJpegImages(PdfUseFlateDecoderForJpegImages value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.PdfDocumentSettings : object {
    private TrimMargins _trimMargins;
    public TrimMargins TrimMargins { get; public set; }
    internal PdfDocumentSettings(PdfDocument document);
    public TrimMargins get_TrimMargins();
    public void set_TrimMargins(TrimMargins value);
}
public enum PdfSharp.Pdf.PdfFlateEncodeMode : Enum {
    public int value__;
    public static PdfFlateEncodeMode Default;
    public static PdfFlateEncodeMode BestSpeed;
    public static PdfFlateEncodeMode BestCompression;
}
public enum PdfSharp.Pdf.PdfFontColoredGlyphs : Enum {
    public int value__;
    public static PdfFontColoredGlyphs None;
    public static PdfFontColoredGlyphs Version0;
}
public enum PdfSharp.Pdf.PdfFontEmbedding : Enum {
    public int value__;
    public static PdfFontEmbedding TryComputeSubset;
    [ObsoleteAttribute("Renamed to TryComputeSubset.")]
public static PdfFontEmbedding Automatic;
    public static PdfFontEmbedding EmbedCompleteFontFile;
    [ObsoleteAttribute("Renamed to EmbedCompleteFontFile.")]
public static PdfFontEmbedding Always;
    [ObsoleteAttribute("Fonts must always be embedded. Treated as Automatic.")]
public static PdfFontEmbedding None;
    [ObsoleteAttribute("Treated as Automatic.")]
public static PdfFontEmbedding Default;
}
public enum PdfSharp.Pdf.PdfFontEncoding : Enum {
    public int value__;
    public static PdfFontEncoding Automatic;
    public static PdfFontEncoding WinAnsi;
    public static PdfFontEncoding Unicode;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharp.Pdf.PdfInteger : PdfNumber {
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    public int Value { get; }
    public PdfInteger(int value);
    [CompilerGeneratedAttribute]
public int get_Value();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
internal virtual void WriteObject(PdfWriter writer);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("1")]
private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("1")]
private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharp.Pdf.PdfIntegerObject : PdfNumberObject {
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    public int Value { get; }
    public PdfIntegerObject(int value);
    public PdfIntegerObject(PdfDocument document, int value);
    [CompilerGeneratedAttribute]
public int get_Value();
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class PdfSharp.Pdf.PdfItem : object {
    private sealed virtual override object System.ICloneable.Clone();
    public PdfItem Clone();
    protected virtual object Copy();
    internal abstract virtual void WriteObject(PdfWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.PdfLiteral : PdfItem {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public PdfLiteral(string value);
    public PdfLiteral(string format, Object[] args);
    public static PdfLiteral FromMatrix(XMatrix matrix);
    [CompilerGeneratedAttribute]
public string get_Value();
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharp.Pdf.PdfLongInteger : PdfNumber {
    [CompilerGeneratedAttribute]
private long <Value>k__BackingField;
    public long Value { get; }
    public PdfLongInteger(long value);
    [CompilerGeneratedAttribute]
public long get_Value();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
internal virtual void WriteObject(PdfWriter writer);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("1")]
private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("1")]
private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharp.Pdf.PdfLongIntegerObject : PdfNumberObject {
    [CompilerGeneratedAttribute]
private long <Value>k__BackingField;
    public long Value { get; }
    public PdfLongIntegerObject(long value);
    public PdfLongIntegerObject(PdfDocument document, long value);
    [CompilerGeneratedAttribute]
public long get_Value();
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.PdfMetadata : PdfDictionary {
    public PdfMetadata(PdfDocument document);
    private void SetupStream();
    private string GenerateXmp();
    private void Foo();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharp.Pdf.PdfName : PdfItem {
    private string _value;
    public static PdfName Empty;
    public string Value { get; }
    public static PdfXNameComparer Comparer { get; }
    public PdfName(string value);
    private static PdfName();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public string get_Value();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public static bool op_Equality(PdfName name, string str);
    [NullableContextAttribute("2")]
public static bool op_Inequality(PdfName name, string str);
    public static string AddSlash(string value);
    public static string RemoveSlash(string value);
    internal virtual void WriteObject(PdfWriter writer);
    public static PdfXNameComparer get_Comparer();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharp.Pdf.PdfNameObject : PdfObject {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; public set; }
    public PdfNameObject(PdfDocument document, string value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public static bool op_Equality(PdfNameObject name, string str);
    [NullableContextAttribute("2")]
public static bool op_Inequality(PdfNameObject name, string str);
    internal virtual void WriteObject(PdfWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("({DebuggerDisplay})")]
public class PdfSharp.Pdf.PdfNameTreeNode : PdfDictionary {
    private bool _isRoot;
    private bool _updateRequired;
    public bool IsRoot { get; private set; }
    public int KidsCount { get; }
    public int NamesCount { get; }
    public string LeastKey { get; }
    public string GreatestKey { get; }
    internal DictionaryMeta Meta { get; }
    private string DebuggerDisplay { get; }
    public PdfNameTreeNode(bool isRoot);
    public bool get_IsRoot();
    private void set_IsRoot(bool value);
    public int get_KidsCount();
    public int get_NamesCount();
    public void AddKid(PdfNameTreeNode kidNode);
    public void AddName(string key, PdfItem value);
    public string get_LeastKey();
    public string get_GreatestKey();
    private void UpdateLimits();
    internal virtual void PrepareForSave();
    internal virtual void WriteObject(PdfWriter writer);
    internal virtual DictionaryMeta get_Meta();
    private string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.PdfNull : PdfItem {
    public static PdfNull Value;
    private static PdfNull();
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.PdfNullObject : PdfObject {
    public PdfNullObject(PdfDocument document);
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
}
public abstract class PdfSharp.Pdf.PdfNumber : PdfItem {
    [CompilerGeneratedAttribute]
private bool <IsInteger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLongInteger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReal>k__BackingField;
    public bool IsInteger { get; protected set; }
    public bool IsLongInteger { get; protected set; }
    public bool IsReal { get; protected set; }
    [CompilerGeneratedAttribute]
public bool get_IsInteger();
    [CompilerGeneratedAttribute]
protected void set_IsInteger(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsLongInteger();
    [CompilerGeneratedAttribute]
protected void set_IsLongInteger(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsReal();
    [CompilerGeneratedAttribute]
protected void set_IsReal(bool value);
}
public abstract class PdfSharp.Pdf.PdfNumberObject : PdfObject {
    [NullableContextAttribute("1")]
protected PdfNumberObject(PdfDocument document);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("({DebuggerDisplay})")]
public class PdfSharp.Pdf.PdfNumberTreeNode : PdfDictionary {
    [CompilerGeneratedAttribute]
private bool <IsRoot>k__BackingField;
    private bool _updateRequired;
    public bool IsRoot { get; private set; }
    public int KidsCount { get; }
    public int NumsCount { get; }
    public string LeastKey { get; }
    public string GreatestKey { get; }
    public PdfNumberTreeNode(bool isRoot);
    [CompilerGeneratedAttribute]
public bool get_IsRoot();
    [CompilerGeneratedAttribute]
private Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsRoot(bool value);
    public int get_KidsCount();
    public int get_NumsCount();
    public void AddKid(PdfNumberTreeNode kidNode);
    public void AddNumber(int key, PdfObject value);
    public string get_LeastKey();
    public string get_GreatestKey();
    private void UpdateLimits();
    internal virtual void PrepareForSave();
    internal virtual void WriteObject(PdfWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class PdfSharp.Pdf.PdfObject : PdfItem {
    internal PdfDocument _document;
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [NullableAttribute("2")]
private PdfObjectInternals _internals;
    [NullableAttribute("2")]
private PdfReference _iref;
    public PdfDocument Owner { get; }
    unknown PdfDocument Document {internal set; }
    public string Comment { get; public set; }
    public bool IsIndirect { get; }
    public PdfObjectInternals Internals { get; }
    internal PdfObjectID ObjectID { get; }
    internal int ObjectNumber { get; }
    internal int GenerationNumber { get; }
    [NullableAttribute("2")]
public PdfReference Reference { get; internal set; }
    public PdfReference ReferenceNotNull { get; }
    protected PdfObject(PdfDocument document);
    protected PdfObject(PdfObject obj);
    public PdfObject Clone();
    protected virtual object Copy();
    internal void SetObjectID(int objectNumber, int generationNumber);
    public virtual PdfDocument get_Owner();
    internal virtual void set_Document(PdfDocument value);
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
public void set_Comment(string value);
    public bool get_IsIndirect();
    public PdfObjectInternals get_Internals();
    internal virtual void PrepareForSave();
    internal virtual void WriteObject(PdfWriter writer);
    internal PdfObjectID get_ObjectID();
    internal int get_ObjectNumber();
    internal int get_GenerationNumber();
    internal static PdfObject DeepCopyClosure(PdfDocument owner, PdfObject externalObject);
    internal static PdfObject ImportClosure(PdfImportedObjectTable importedObjectTable, PdfDocument owner, PdfObject externalObject);
    private static void FixUpObject(PdfImportedObjectTable iot, PdfDocument owner, PdfObject value);
    [ConditionalAttribute("DEBUG")]
private static void DebugCheckNonObjects(PdfItem item);
    [NullableContextAttribute("2")]
public PdfReference get_Reference();
    [NullableContextAttribute("2")]
internal void set_Reference(PdfReference value);
    public PdfReference get_ReferenceNotNull();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharp.Pdf.PdfObjectID : ValueType {
    private int _objectNumber;
    private ushort _generationNumber;
    public int ObjectNumber { get; }
    public int GenerationNumber { get; }
    public bool IsEmpty { get; }
    public static PdfObjectID Empty { get; }
    internal string DebuggerDisplay { get; }
    public PdfObjectID(int objectNumber);
    public PdfObjectID(int objectNumber, int generationNumber);
    public int get_ObjectNumber();
    public int get_GenerationNumber();
    public bool get_IsEmpty();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(PdfObjectID left, PdfObjectID right);
    public static bool op_Inequality(PdfObjectID left, PdfObjectID right);
    public virtual string ToString();
    public static PdfObjectID get_Empty();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    internal string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.PdfOutline : PdfDictionary {
    private int _count;
    internal int OpenCount;
    [NullableAttribute("2")]
private PdfOutline _parent;
    [NullableAttribute("2")]
private PdfPage _destinationPage;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Top>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Bottom>k__BackingField;
    private Nullable`1<double> _zoom;
    private bool _opened;
    private PdfPageDestinationType _pageDestinationType;
    [CompilerGeneratedAttribute]
private XColor <TextColor>k__BackingField;
    [NullableAttribute("2")]
private PdfOutlineCollection _outlines;
    internal int Count { get; internal set; }
    public PdfOutline Parent { get; internal set; }
    public string Title { get; public set; }
    public PdfPage DestinationPage { get; public set; }
    public Nullable`1<double> Left { get; public set; }
    public Nullable`1<double> Top { get; public set; }
    public double Right { get; public set; }
    public double Bottom { get; public set; }
    public Nullable`1<double> Zoom { get; public set; }
    public bool Opened { get; public set; }
    public PdfOutlineStyle Style { get; public set; }
    public PdfPageDestinationType PageDestinationType { get; public set; }
    public XColor TextColor { get; public set; }
    public bool HasChildren { get; }
    public PdfOutlineCollection Outlines { get; }
    internal DictionaryMeta Meta { get; }
    internal PdfOutline(PdfDocument document);
    public PdfOutline(PdfDictionary dict);
    public PdfOutline(string title, PdfPage destinationPage, bool opened, PdfOutlineStyle style, XColor textColor);
    public PdfOutline(string title, PdfPage destinationPage, bool opened, PdfOutlineStyle style);
    public PdfOutline(string title, PdfPage destinationPage, bool opened);
    public PdfOutline(string title, PdfPage destinationPage);
    internal int get_Count();
    internal void set_Count(int value);
    internal int CountOpen();
    public PdfOutline get_Parent();
    internal void set_Parent(PdfOutline value);
    public string get_Title();
    public void set_Title(string value);
    public PdfPage get_DestinationPage();
    public void set_DestinationPage(PdfPage value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Top();
    [CompilerGeneratedAttribute]
public void set_Top(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public double get_Right();
    [CompilerGeneratedAttribute]
public void set_Right(double value);
    [CompilerGeneratedAttribute]
public double get_Bottom();
    [CompilerGeneratedAttribute]
public void set_Bottom(double value);
    public Nullable`1<double> get_Zoom();
    public void set_Zoom(Nullable`1<double> value);
    public bool get_Opened();
    public void set_Opened(bool value);
    public PdfOutlineStyle get_Style();
    public void set_Style(PdfOutlineStyle value);
    public PdfPageDestinationType get_PageDestinationType();
    public void set_PageDestinationType(PdfPageDestinationType value);
    [CompilerGeneratedAttribute]
public XColor get_TextColor();
    [CompilerGeneratedAttribute]
public void set_TextColor(XColor value);
    public bool get_HasChildren();
    public PdfOutlineCollection get_Outlines();
    private void Initialize();
    private void SplitDestinationPage(PdfArray destination);
    private void InitializeChildren();
    internal virtual void PrepareForSave();
    private PdfArray CreateDestArray();
    private static string Fd(double value);
    private static string Fd(Nullable`1<double> value);
    internal virtual void WriteObject(PdfWriter writer);
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class PdfSharp.Pdf.PdfOutlineCollection : PdfObject {
    private PdfOutline _parent;
    private List`1<PdfOutline> _outlines;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public PdfOutline Item { get; public set; }
    internal PdfOutlineCollection(PdfDocument document, PdfOutline parent);
    public sealed virtual bool Remove(PdfOutline item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(PdfOutline outline);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(PdfOutline item);
    public sealed virtual void CopyTo(PdfOutline[] array, int arrayIndex);
    public PdfOutline Add(string title, PdfPage destinationPage, bool opened, PdfOutlineStyle style, XColor textColor);
    public PdfOutline Add(string title, PdfPage destinationPage, bool opened, PdfOutlineStyle style);
    public PdfOutline Add(string title, PdfPage destinationPage, bool opened);
    public PdfOutline Add(string title, PdfPage destinationPage);
    public sealed virtual int IndexOf(PdfOutline item);
    public sealed virtual void Insert(int index, PdfOutline outline);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual PdfOutline get_Item(int index);
    public sealed virtual void set_Item(int index, PdfOutline value);
    public sealed virtual IEnumerator`1<PdfOutline> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal int CountOpen();
    private void AddToOutlinesTree(PdfOutline outline);
    private void RemoveFromOutlinesTree(PdfOutline outline);
}
[FlagsAttribute]
public enum PdfSharp.Pdf.PdfOutlineStyle : Enum {
    public int value__;
    public static PdfOutlineStyle Regular;
    public static PdfOutlineStyle Italic;
    public static PdfOutlineStyle Bold;
    public static PdfOutlineStyle BoldItalic;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.PdfPage : PdfDictionary {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <Tag>k__BackingField;
    private bool _closed;
    private PageOrientation _orientation;
    private PageSize _pageSize;
    private TrimMargins _trimMargins;
    private XUnit _height;
    private XUnit _width;
    [NullableAttribute("2")]
internal PdfContent RenderContent;
    [NullableAttribute("2")]
private PdfContents _contents;
    private Nullable`1<bool> _hasAnnotations;
    [NullableAttribute("2")]
private PdfAnnotations _annotations;
    [NullableAttribute("2")]
private PdfCustomValues _customValues;
    [NullableAttribute("2")]
private PdfResources _resources;
    internal bool TransparencyUsed;
    [NullableAttribute("2")]
public object Tag { get; public set; }
    internal bool IsClosed { get; }
    unknown PdfDocument Document {internal set; }
    public PageOrientation Orientation { get; public set; }
    public PageSize Size { get; public set; }
    public TrimMargins TrimMargins { get; public set; }
    public PdfRectangle MediaBox { get; public set; }
    public PdfRectangle CropBox { get; public set; }
    public PdfRectangle BleedBox { get; public set; }
    public PdfRectangle ArtBox { get; public set; }
    public PdfRectangle TrimBox { get; public set; }
    public XUnit Height { get; public set; }
    public XUnit Width { get; public set; }
    public int Rotate { get; public set; }
    public PageRotation Rotation { get; public set; }
    public PdfContents Contents { get; }
    public bool HasAnnotations { get; }
    public PdfAnnotations Annotations { get; }
    public PdfCustomValues CustomValues { get; public set; }
    public PdfResources Resources { get; }
    private PdfResources PdfSharp.Pdf.Advanced.IContentStream.Resources { get; }
    internal DictionaryMeta Meta { get; }
    public PdfPage(PdfDocument document);
    internal PdfPage(PdfDictionary dict);
    private void Initialize();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_Tag();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Tag(object value);
    public void Close();
    internal bool get_IsClosed();
    internal virtual void set_Document(PdfDocument value);
    public PageOrientation get_Orientation();
    public void set_Orientation(PageOrientation value);
    private void UpdateOrientation();
    [ObsoleteAttribute("Use PageSize to get the absolute size of the page.")]
public PageSize get_Size();
    public void set_Size(PageSize value);
    public TrimMargins get_TrimMargins();
    public void set_TrimMargins(TrimMargins value);
    public PdfRectangle get_MediaBox();
    public void set_MediaBox(PdfRectangle value);
    public PdfRectangle get_CropBox();
    public void set_CropBox(PdfRectangle value);
    public PdfRectangle get_BleedBox();
    public void set_BleedBox(PdfRectangle value);
    public PdfRectangle get_ArtBox();
    public void set_ArtBox(PdfRectangle value);
    public PdfRectangle get_TrimBox();
    public void set_TrimBox(PdfRectangle value);
    public XUnit get_Height();
    public void set_Height(XUnit value);
    public XUnit get_Width();
    public void set_Width(XUnit value);
    public int get_Rotate();
    public void set_Rotate(int value);
    public PageRotation get_Rotation();
    public void set_Rotation(PageRotation value);
    public PdfContents get_Contents();
    public bool get_HasAnnotations();
    public PdfAnnotations get_Annotations();
    public PdfLinkAnnotation AddDocumentLink(PdfRectangle rect, int destinationPage, Nullable`1<XPoint> point);
    public PdfLinkAnnotation AddDocumentLink(PdfRectangle rect, string destinationName);
    public PdfLinkAnnotation AddDocumentLink(PdfRectangle rect, string documentPath, string destinationName, Nullable`1<bool> newWindow);
    public PdfLinkAnnotation AddEmbeddedDocumentLink(PdfRectangle rect, string destinationPath, Nullable`1<bool> newWindow);
    public PdfLinkAnnotation AddEmbeddedDocumentLink(PdfRectangle rect, string documentPath, string destinationPath, Nullable`1<bool> newWindow);
    public PdfLinkAnnotation AddWebLink(PdfRectangle rect, string url);
    public PdfLinkAnnotation AddFileLink(PdfRectangle rect, string fileName);
    public PdfCustomValues get_CustomValues();
    public void set_CustomValues(PdfCustomValues value);
    public PdfResources get_Resources();
    private sealed virtual override PdfResources PdfSharp.Pdf.Advanced.IContentStream.get_Resources();
    internal string GetFontName(XGlyphTypeface glyphTypeface, FontType fontType, PdfFont& pdfFont);
    private sealed virtual override string PdfSharp.Pdf.Advanced.IContentStream.GetFontName(XGlyphTypeface glyphTypeface, FontType fontType, PdfFont& pdfFont);
    [NullableContextAttribute("2")]
internal string TryGetFontName(string idName, PdfFont& pdfFont);
    internal string GetFontName(string idName, Byte[] fontData, PdfFont& pdfFont);
    private sealed virtual override string PdfSharp.Pdf.Advanced.IContentStream.GetFontName(string idName, Byte[] fontData, PdfFont& pdfFont);
    internal string GetImageName(XImage image);
    private sealed virtual override string PdfSharp.Pdf.Advanced.IContentStream.GetImageName(XImage image);
    internal string GetFormName(XForm form);
    private sealed virtual override string PdfSharp.Pdf.Advanced.IContentStream.GetFormName(XForm form);
    internal virtual void WriteObject(PdfWriter writer);
    internal static void InheritValues(PdfDictionary page, InheritedValues values);
    internal static void InheritValues(PdfDictionary page, InheritedValues& values);
    internal virtual void PrepareForSave();
    internal virtual DictionaryMeta get_Meta();
}
public enum PdfSharp.Pdf.PdfPageDestinationType : Enum {
    public int value__;
    public static PdfPageDestinationType Xyz;
    public static PdfPageDestinationType Fit;
    public static PdfPageDestinationType FitH;
    public static PdfPageDestinationType FitV;
    public static PdfPageDestinationType FitR;
    public static PdfPageDestinationType FitB;
    public static PdfPageDestinationType FitBH;
    public static PdfPageDestinationType FitBV;
}
public enum PdfSharp.Pdf.PdfPageLayout : Enum {
    public int value__;
    public static PdfPageLayout SinglePage;
    public static PdfPageLayout OneColumn;
    public static PdfPageLayout TwoColumnLeft;
    public static PdfPageLayout TwoColumnRight;
    public static PdfPageLayout TwoPageLeft;
    public static PdfPageLayout TwoPageRight;
}
public enum PdfSharp.Pdf.PdfPageMode : Enum {
    public int value__;
    public static PdfPageMode UseNone;
    public static PdfPageMode UseOutlines;
    public static PdfPageMode UseThumbs;
    public static PdfPageMode FullScreen;
    public static PdfPageMode UseOC;
    public static PdfPageMode UseAttachments;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("(PageCount={Count})")]
public class PdfSharp.Pdf.PdfPages : PdfDictionary {
    [NullableAttribute("2")]
private PdfArray _pagesArray;
    public int Count { get; }
    public PdfPage Item { get; }
    public PdfArray PagesArray { get; }
    internal DictionaryMeta Meta { get; }
    internal PdfPages(PdfDocument document);
    internal PdfPages(PdfDictionary dictionary);
    public int get_Count();
    public PdfPage get_Item(int index);
    [NullableContextAttribute("2")]
internal PdfPage FindPage(PdfObjectID id);
    public PdfPage Add();
    public PdfPage Add(PdfPage page);
    public PdfPage Insert(int index);
    public PdfPage Insert(int index, PdfPage page);
    public void InsertRange(int index, PdfDocument document, int startIndex, int pageCount);
    public void InsertRange(int index, PdfDocument document);
    public void InsertRange(int index, PdfDocument document, int startIndex);
    public void Remove(PdfPage page);
    public void RemoveAt(int index);
    public void MovePage(int oldIndex, int newIndex);
    private PdfPage ImportExternalPage(PdfPage importPage);
    private void CloneElement(PdfPage page, PdfPage importPage, string key, bool deepcopy);
    private static PdfReference RemapReference(PdfPage[] newPages, PdfPage[] impPages, PdfReference iref);
    public PdfArray get_PagesArray();
    internal void FlattenPageTree();
    private static PdfDictionary[] GetKids(PdfReference iref, InheritedValues values, PdfDictionary parentNotUsed);
    internal virtual void PrepareForSave();
    public sealed virtual IEnumerator`1<PdfPage> GetEnumerator();
    internal virtual DictionaryMeta get_Meta();
}
public enum PdfSharp.Pdf.PdfReadingDirection : Enum {
    public int value__;
    public static PdfReadingDirection LeftToRight;
    public static PdfReadingDirection RightToLeft;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharp.Pdf.PdfReal : PdfNumber {
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    public double Value { get; }
    public PdfReal(double value);
    [CompilerGeneratedAttribute]
public double get_Value();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
internal virtual void WriteObject(PdfWriter writer);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("1")]
private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("1")]
private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.PdfRealObject : PdfNumberObject {
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    public double Value { get; public set; }
    public PdfRealObject(double value);
    public PdfRealObject(PdfDocument document, double value);
    [CompilerGeneratedAttribute]
public double get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(double value);
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharp.Pdf.PdfRectangle : PdfItem {
    private double _x1;
    private double _y1;
    private double _x2;
    private double _y2;
    public static PdfRectangle Empty;
    public bool IsEmpty { get; }
    public double X1 { get; }
    public double Y1 { get; }
    public double X2 { get; }
    public double Y2 { get; }
    public double Width { get; }
    public double Height { get; }
    public XPoint Location { get; }
    public XSize Size { get; }
    private string DebuggerDisplay { get; }
    internal PdfRectangle(double x1, double y1, double x2, double y2);
    public PdfRectangle(XPoint pt1, XPoint pt2);
    public PdfRectangle(XPoint pt, XSize size);
    public PdfRectangle(XRect rect);
    internal PdfRectangle(PdfItem item);
    private static PdfRectangle();
    public PdfRectangle Clone();
    protected virtual object Copy();
    public bool get_IsEmpty();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(PdfRectangle left, PdfRectangle right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(PdfRectangle left, PdfRectangle right);
    public double get_X1();
    public double get_Y1();
    public double get_X2();
    public double get_Y2();
    public double get_Width();
    public double get_Height();
    public XPoint get_Location();
    public XSize get_Size();
    public bool Contains(XPoint pt);
    public bool Contains(double x, double y);
    public bool Contains(XRect rect);
    public bool Contains(PdfRectangle rect);
    public XRect ToXRect();
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
    private string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharp.Pdf.PdfString : PdfItem {
    private PdfStringFlags _flags;
    [NullableAttribute("2")]
private string _value;
    private static Char[] Encode;
    public int Length { get; }
    public PdfStringEncoding Encoding { get; }
    public bool HexLiteral { get; }
    internal PdfStringFlags Flags { get; }
    public string Value { get; }
    public PdfString(string value);
    public PdfString(string value, PdfStringEncoding encoding);
    [NullableContextAttribute("2")]
internal PdfString(string value, PdfStringFlags flags);
    private static PdfString();
    public int get_Length();
    public PdfStringEncoding get_Encoding();
    public bool get_HexLiteral();
    internal PdfStringFlags get_Flags();
    public string get_Value();
    internal static Byte[] ToRawBytes(string value);
    internal static string FromRawBytes(Byte[] value);
    internal static string FromRawBytes(Byte[] value, PdfStringFlags& flagsToUpdate, Nullable`1<PdfStringEncoding> encoding);
    private static void ChangeEncoding(PdfStringFlags& flagsToUpdate, PdfStringEncoding encoding);
    internal Byte[] GetRawBytes();
    internal void SetRawBytes(Byte[] value, Nullable`1<PdfStringEncoding> encoding);
    internal bool TryRereadAsUnicode();
    [NullableContextAttribute("2")]
internal static bool TryRereadAsUnicode(String& value, PdfStringFlags& flagsToUpdate);
    [NullableContextAttribute("2")]
private static bool TryRereadAsUnicode(String& value);
    public virtual string ToString();
    [ConditionalAttribute("DEBUG")]
private static void AssertRawEncoding(string s);
    private static bool IsRawEncoding(string s);
    internal virtual void WriteObject(PdfWriter writer);
}
[FlagsAttribute]
public enum PdfSharp.Pdf.PdfStringEncoding : Enum {
    public int value__;
    public static PdfStringEncoding RawEncoding;
    public static PdfStringEncoding StandardEncoding;
    public static PdfStringEncoding PDFDocEncoding;
    public static PdfStringEncoding WinAnsiEncoding;
    public static PdfStringEncoding MacRomanEncoding;
    public static PdfStringEncoding MacExpertEncoding;
    public static PdfStringEncoding Unicode;
}
[FlagsAttribute]
internal enum PdfSharp.Pdf.PdfStringFlags : Enum {
    public int value__;
    public static PdfStringFlags RawEncoding;
    public static PdfStringFlags StandardEncoding;
    public static PdfStringFlags PDFDocEncoding;
    public static PdfStringFlags WinAnsiEncoding;
    public static PdfStringFlags MacRomanEncoding;
    public static PdfStringFlags MacExpertEncoding;
    public static PdfStringFlags Unicode;
    public static PdfStringFlags EncodingMask;
    public static PdfStringFlags HexLiteral;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharp.Pdf.PdfStringObject : PdfObject {
    private PdfStringFlags _flags;
    private string _value;
    public int Length { get; }
    public PdfStringEncoding Encoding { get; public set; }
    public bool HexLiteral { get; public set; }
    public string Value { get; public set; }
    public PdfStringObject(PdfDocument document, string value);
    public PdfStringObject(string value, PdfStringEncoding encoding);
    internal PdfStringObject(string value, PdfStringFlags flags);
    public int get_Length();
    public PdfStringEncoding get_Encoding();
    public void set_Encoding(PdfStringEncoding value);
    public bool get_HexLiteral();
    public void set_HexLiteral(bool value);
    public string get_Value();
    public void set_Value(string value);
    internal Byte[] GetRawBytes();
    internal void SetRawBytes(Byte[] value, Nullable`1<PdfStringEncoding> encoding);
    internal bool TryRereadAsUnicode();
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
}
public enum PdfSharp.Pdf.PdfTextStringEncoding : Enum {
    public int value__;
    public static PdfTextStringEncoding PDFDocEncoding;
    public static PdfTextStringEncoding Unicode;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("({Value})")]
[ObsoleteAttribute("This class is deprecated and will be removed.")]
public class PdfSharp.Pdf.PdfUInteger : PdfNumber {
    [CompilerGeneratedAttribute]
private UInt32 <Value>k__BackingField;
    public UInt32 Value { get; }
    public PdfUInteger(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Value();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
internal virtual void WriteObject(PdfWriter writer);
    public sealed virtual ulong ToUInt64(IFormatProvider provider);
    public sealed virtual sbyte ToSByte(IFormatProvider provider);
    public sealed virtual double ToDouble(IFormatProvider provider);
    public sealed virtual DateTime ToDateTime(IFormatProvider provider);
    public sealed virtual float ToSingle(IFormatProvider provider);
    public sealed virtual bool ToBoolean(IFormatProvider provider);
    public sealed virtual int ToInt32(IFormatProvider provider);
    public sealed virtual ushort ToUInt16(IFormatProvider provider);
    public sealed virtual short ToInt16(IFormatProvider provider);
    [NullableContextAttribute("1")]
private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    public sealed virtual byte ToByte(IFormatProvider provider);
    public sealed virtual char ToChar(IFormatProvider provider);
    public sealed virtual long ToInt64(IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    public sealed virtual decimal ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("1")]
public sealed virtual object ToType(Type conversionType, IFormatProvider provider);
    public sealed virtual UInt32 ToUInt32(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("({Value})")]
[ObsoleteAttribute("This class is deprecated and will be removed.")]
public class PdfSharp.Pdf.PdfUIntegerObject : PdfNumberObject {
    [CompilerGeneratedAttribute]
private UInt32 <Value>k__BackingField;
    public UInt32 Value { get; }
    public PdfUIntegerObject(UInt32 value);
    public PdfUIntegerObject(PdfDocument document, UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Value();
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
}
public enum PdfSharp.Pdf.PdfUseFlateDecoderForJpegImages : Enum {
    public int value__;
    public static PdfUseFlateDecoderForJpegImages Automatic;
    public static PdfUseFlateDecoderForJpegImages Never;
    public static PdfUseFlateDecoderForJpegImages Always;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.PdfViewerPreferences : PdfDictionary {
    public bool HideToolbar { get; public set; }
    public bool HideMenubar { get; public set; }
    public bool HideWindowUI { get; public set; }
    public bool FitWindow { get; public set; }
    public bool CenterWindow { get; public set; }
    public bool DisplayDocTitle { get; public set; }
    public Nullable`1<PdfReadingDirection> Direction { get; public set; }
    internal DictionaryMeta Meta { get; }
    internal PdfViewerPreferences(PdfDocument document);
    public bool get_HideToolbar();
    public void set_HideToolbar(bool value);
    public bool get_HideMenubar();
    public void set_HideMenubar(bool value);
    public bool get_HideWindowUI();
    public void set_HideWindowUI(bool value);
    public bool get_FitWindow();
    public void set_FitWindow(bool value);
    public bool get_CenterWindow();
    public void set_CenterWindow(bool value);
    public bool get_DisplayDocTitle();
    public void set_DisplayDocTitle(bool value);
    public Nullable`1<PdfReadingDirection> get_Direction();
    public void set_Direction(Nullable`1<PdfReadingDirection> value);
    internal virtual DictionaryMeta get_Meta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class PdfSharp.Pdf.Security.CryptFilterBase : PdfDictionary {
    protected CryptFilterBase(PdfDictionary dict);
    internal abstract virtual bool EncryptForEnteredObject(Byte[]& bytes);
    internal abstract virtual bool DecryptForEnteredObject(Byte[]& bytes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class PdfSharp.Pdf.Security.Encryption.PdfEncryptionBase : object {
    protected PdfStandardSecurityHandler SecurityHandler;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <VersionValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <RevisionValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LengthValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ActualLength>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EncryptMetadata>k__BackingField;
    public Nullable`1<int> VersionValue { get; protected set; }
    public Nullable`1<int> RevisionValue { get; protected set; }
    public Nullable`1<int> LengthValue { get; protected set; }
    public Nullable`1<int> ActualLength { get; protected set; }
    public bool EncryptMetadata { get; protected set; }
    protected PdfEncryptionBase(PdfStandardSecurityHandler securityHandler);
    public abstract virtual void InitializeFromLoadedSecurityHandler();
    public abstract virtual void EnterObject(PdfObjectID id);
    public abstract virtual void LeaveObject();
    public abstract virtual void EncryptForEnteredObject(Byte[]& bytes);
    public abstract virtual void DecryptForEnteredObject(Byte[]& bytes);
    protected bool HandleCryptographicExceptionOnDecryption();
    public abstract virtual void PrepareEncryptionForSaving(string userPassword, string ownerPassword);
    public abstract virtual PasswordValidity ValidatePassword(string inputPassword);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_VersionValue();
    [CompilerGeneratedAttribute]
protected void set_VersionValue(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_RevisionValue();
    [CompilerGeneratedAttribute]
protected void set_RevisionValue(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LengthValue();
    [CompilerGeneratedAttribute]
protected void set_LengthValue(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ActualLength();
    [CompilerGeneratedAttribute]
protected void set_ActualLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_EncryptMetadata();
    [CompilerGeneratedAttribute]
protected void set_EncryptMetadata(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Security.Encryption.PdfEncryptionV1To4 : PdfEncryptionBase {
    private static Byte[] PasswordPadding;
    private Byte[] _globalEncryptionKey;
    private Nullable`1<PdfObjectID> _objectId;
    [NullableAttribute("2")]
private Byte[] _objectEncryptionKeyRC4;
    [NullableAttribute("2")]
private Byte[] _objectEncryptionKeyAES;
    private int _objectEncryptionKeySize;
    private MD5 _md5;
    private RC4 _rc4;
    public PdfEncryptionV1To4(PdfStandardSecurityHandler securityHandler);
    private static PdfEncryptionV1To4();
    public void SetEncryptionToV1();
    public void SetEncryptionToV2(int length);
    public void SetEncryptionToV4UsingRC4(bool encryptMetadata);
    public void SetEncryptionToV4UsingAES(bool encryptMetadata);
    public virtual void InitializeFromLoadedSecurityHandler();
    private void Initialize(int versionValue, Nullable`1<int> lengthValue, bool encryptMetadata);
    private void UpdateActualLength();
    private static void CheckVersionAndLength(Nullable`1<int> versionValue, Nullable`1<int> lengthValue);
    public static bool IsVersionSupported(Nullable`1<int> versionValue);
    private void EnsureIsAESSupported();
    public virtual void PrepareEncryptionForSaving(string userPassword, string ownerPassword);
    private int CalculateRevisionValue(int versionValue, UInt32 permissionsValue);
    private static Byte[] PadPassword(string password);
    private ValueTuple`2<Byte[], Byte[]> ComputeOwnerAndUserValues(string userPassword, string ownerPassword, Byte[] documentId, UInt32 permissionsValue);
    private Byte[] ComputeOwnerValue(Byte[] userPad, Byte[] ownerPad);
    private Byte[] ComputeUserValue(Byte[] documentId, string userPassword, Byte[] ownerValue, UInt32 permissions);
    private Byte[] ComputeUserValueByEncryptionKey(Byte[] documentId);
    private void ComputeAndStoreEncryptionKey(Byte[] documentId, Byte[] paddedPassword, Byte[] ownerValue, UInt32 permissions);
    public virtual PasswordValidity ValidatePassword(string inputPassword);
    private bool ValidateUserPassword(Byte[] documentId, string inputPassword, Byte[] userValue, Byte[] ownerValue, UInt32 permissionsValue);
    private bool ValidateOwnerPassword(Byte[] documentId, string inputPassword, Byte[] userValue, Byte[] ownerValue, UInt32 permissionsValue);
    private bool EqualsPasswordValue(Byte[] value1, Byte[] value2);
    public virtual void EnterObject(PdfObjectID id);
    public virtual void LeaveObject();
    public virtual void EncryptForEnteredObject(Byte[]& bytes);
    public virtual void DecryptForEnteredObject(Byte[]& bytes);
    public void EncryptForEnteredObjectUsingRC4(Byte[]& bytes);
    public void DecryptForEnteredObjectUsingRC4(Byte[]& bytes);
    public void EncryptForEnteredObjectUsingAES(Byte[]& bytes);
    public void DecryptForEnteredObjectUsingAES(Byte[]& bytes);
    [NullableContextAttribute("2")]
private Byte[] ComputeObjectEncryptionKey(bool useAES);
    [NullableContextAttribute("2")]
private Byte[] GetObjectEncryptionKeyRC4();
    [NullableContextAttribute("2")]
private Byte[] GetObjectEncryptionKeyAES();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Security.Encryption.PdfEncryptionV5 : PdfEncryptionBase {
    private Byte[] _encryptionKey;
    public PdfEncryptionV5(PdfStandardSecurityHandler securityHandler);
    public void Initialize(bool encryptMetadata);
    public virtual void InitializeFromLoadedSecurityHandler();
    private static void CheckValues(Nullable`1<int> versionValue, Nullable`1<int> revisionValue, Nullable`1<int> lengthValue);
    public static bool IsVersionSupported(Nullable`1<int> versionValue);
    public virtual void EnterObject(PdfObjectID id);
    public virtual void LeaveObject();
    public virtual void EncryptForEnteredObject(Byte[]& bytes);
    public virtual void DecryptForEnteredObject(Byte[]& bytes);
    private static Aes CreateAesForObjectsCryptography();
    private static Aes CreateAesForHashCryptography();
    private static Aes CreateAesForKeyCryptography();
    private static Aes CreateAesForPermissionsCryptography();
    public virtual void PrepareEncryptionForSaving(string userPassword, string ownerPassword);
    private void CreateAndStoreEncryptionKey();
    private static Byte[] CreateUtf8Password(string password);
    private ValueTuple`2<Byte[], Byte[]> ComputeUserValues(Byte[] utf8InputPassword);
    private ValueTuple`2<Byte[], Byte[]> ComputeOwnerValues(Byte[] utf8InputPassword, Byte[] userValue);
    private static Byte[] ComputeUserHash(Byte[] password, Byte[] salt);
    private static Byte[] ComputeOwnerHash(Byte[] password, Byte[] salt, Byte[] userValue);
    private static Byte[] ComputeHashInternal(Byte[] password, Byte[] salt, bool computeOwnerHash, Byte[] userValue);
    private Byte[] ComputePermsValue(UInt32 pValue);
    public virtual PasswordValidity ValidatePassword(string inputPassword);
    private void RetrieveAndStoreEncryptionKey(Byte[] utf8InputPassword, Byte[] userValue, Byte[] userEValue, Byte[] ownerValue, Byte[] ownerEValue);
    private static Byte[] GetUserOwnerHashValue(Byte[] userOwnerValue);
    private static Byte[] GetUserOwnerValidationSalt(Byte[] userOwnerValue);
    private static Byte[] GetUserOwnerKeySalt(Byte[] userOwnerValue);
    private static bool ValidateUserPassword(Byte[] utf8InputPassword, Byte[] userValue);
    private static bool ValidateOwnerPassword(Byte[] utf8InputPassword, Byte[] userValue, Byte[] ownerValue);
    private bool ValidatePermissions(Byte[] permsValue, UInt32 pValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Security.Encryption.RC4 : object {
    private Byte[] _state;
    public void SetKey(Byte[] key);
    public void SetKey(Byte[] key, int length);
    public void SetKey(Byte[] key, int offset, int length);
    public void Encrypt(Byte[] data);
    public void Encrypt(Byte[] data, int length);
    public void Encrypt(Byte[] data, int offset, int length);
    public void Encrypt(Byte[] inputData, Byte[] outputData);
    public void Encrypt(Byte[] inputData, int offset, int length, Byte[] outputData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Security.Encryption.SASLprep : object {
    public static string PrepareStoredString(string str);
    public static string PrepareQuery(string str);
    private static string Prepare(string str, bool allowUnassignedCodepoints);
    private static bool IsNonAsciiSpace(char c);
    private static bool IsCommonlyMappedToNothing(char c);
    private static bool IsProhibited(int codePoint);
    private static bool IsAsciiControlCharacter(char ch);
    private static bool IsNonAsciiControlCharacter(int codePoint);
    private static bool IsPrivateUseCharacter(int codePoint);
    private static bool IsNonCharacterCodePoint(int codePoint);
    private static bool IsSurrogateCodePoint(int codePoint);
    private static bool IsInappropriateForPlainTextCharacter(int codePoint);
    private static bool IsInappropriateForCanonicalRepresentationCharacter(int codePoint);
    private static bool IsChangeDisplayPropertyDeprecatedCharacter(int codePoint);
    private static bool IsTaggingCharacter(int codePoint);
    private static bool IsRandAlCat(int codePoint);
    private static bool IsLCat(int codePoint);
    private static bool IsUnassignedCodePoint(int codePoint);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Security.IdentityCryptFilter : CryptFilterBase {
    [CompilerGeneratedAttribute]
private static IdentityCryptFilter <Instance>k__BackingField;
    internal static IdentityCryptFilter Instance { get; }
    private static IdentityCryptFilter();
    [CompilerGeneratedAttribute]
internal static IdentityCryptFilter get_Instance();
    internal virtual bool EncryptForEnteredObject(Byte[]& bytes);
    internal virtual bool DecryptForEnteredObject(Byte[]& bytes);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Security.PdfCryptFilter : CryptFilterBase {
    private Nullable`1<CryptFilterMethod> _cryptFilterMethod;
    private PdfEncryptionBase _encryption;
    private PdfEncryptionV1To4 _encryptionV1To4;
    private PdfEncryptionV5 _encryptionV5;
    private PdfStandardSecurityHandler _parentStandardSecurityHandler;
    public PdfCryptFilter(PdfStandardSecurityHandler parentStandardSecurityHandler);
    [NullableContextAttribute("1")]
internal PdfCryptFilter(PdfDictionary dict);
    public void Initialize(PdfStandardSecurityHandler parentStandardSecurityHandler);
    public void SetEncryptionToNone();
    public void SetEncryptionToRC4ForV4(int length);
    public void SetEncryptionToAESForV4();
    public void SetEncryptionToAESForV5();
    private void Initialize(CryptFilterMethod method, int lengthValue);
    private static void CheckLength(CryptFilterMethod method, int lengthValue);
    public void SetAuthEventForEmbeddedFiles();
    internal void PrepareForProcessing();
    [NullableContextAttribute("1")]
internal virtual bool EncryptForEnteredObject(Byte[]& bytes);
    [NullableContextAttribute("1")]
internal virtual bool DecryptForEnteredObject(Byte[]& bytes);
    private void SetCryptFilterMethod(CryptFilterMethod cryptFilterMethod);
    private CryptFilterMethod GetCryptFilterMethod();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Security.PdfCryptFilters : PdfDictionary {
    internal PdfCryptFilters(PdfDictionary dict);
    public PdfCryptFilter GetCryptFilter(string name);
    public void AddCryptFilter(string name, PdfCryptFilter cryptFilter);
    public bool RemoveCryptFilter(string name);
    [IteratorStateMachineAttribute("PdfSharp.Pdf.Security.PdfCryptFilters/<GetCryptFilters>d__5")]
public IEnumerable`1<ValueTuple`2<string, PdfCryptFilter>> GetCryptFilters();
    public Dictionary`2<string, PdfCryptFilter> GetCryptFiltersAsDictionary();
    public bool IsEmpty();
    private PdfCryptFilter Convert(PdfItem pdfItem, string keyToUpdate);
}
public enum PdfSharp.Pdf.Security.PdfDefaultEncryption : Enum {
    public int value__;
    public static PdfDefaultEncryption None;
    public static PdfDefaultEncryption Default;
    public static PdfDefaultEncryption V1;
    public static PdfDefaultEncryption V2With40Bits;
    public static PdfDefaultEncryption V2With128Bits;
    public static PdfDefaultEncryption V4UsingRC4;
    public static PdfDefaultEncryption V4UsingAES;
    public static PdfDefaultEncryption V5;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class PdfSharp.Pdf.Security.PdfSecurityHandler : PdfDictionary {
    internal PdfSecurityHandler(PdfDocument document);
    internal PdfSecurityHandler(PdfDictionary dict);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Security.PdfSecuritySettings : object {
    private PdfDocument _document;
    private bool _hasOwnerPermissions;
    internal bool HasOwnerPermissions { get; public set; }
    unknown string UserPassword {public set; }
    unknown string OwnerPassword {public set; }
    public bool IsEncrypted { get; }
    public bool PermitPrint { get; public set; }
    public bool PermitModifyDocument { get; public set; }
    public bool PermitExtractContent { get; public set; }
    public bool PermitAnnotations { get; public set; }
    public bool PermitFormsFill { get; public set; }
    public bool PermitAssembleDocument { get; public set; }
    public bool PermitFullQualityPrint { get; public set; }
    internal PdfStandardSecurityHandler SecurityHandler { get; }
    [NullableAttribute("2")]
internal PdfStandardSecurityHandler EffectiveSecurityHandler { get; }
    internal PdfSecuritySettings(PdfDocument document);
    internal bool get_HasOwnerPermissions();
    public void set_HasOwnerPermissions(bool value);
    public void set_UserPassword(string value);
    public void set_OwnerPassword(string value);
    public bool get_IsEncrypted();
    internal bool CanSave(String& message);
    public bool get_PermitPrint();
    public void set_PermitPrint(bool value);
    public bool get_PermitModifyDocument();
    public void set_PermitModifyDocument(bool value);
    public bool get_PermitExtractContent();
    public void set_PermitExtractContent(bool value);
    public bool get_PermitAnnotations();
    public void set_PermitAnnotations(bool value);
    public bool get_PermitFormsFill();
    public void set_PermitFormsFill(bool value);
    public bool get_PermitAssembleDocument();
    public void set_PermitAssembleDocument(bool value);
    public bool get_PermitFullQualityPrint();
    public void set_PermitFullQualityPrint(bool value);
    public static bool HasPermissionsOfRevision3OrHigherSetTo0(UInt32 permission);
    internal PdfStandardSecurityHandler get_SecurityHandler();
    [NullableContextAttribute("2")]
internal PdfStandardSecurityHandler get_EffectiveSecurityHandler();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Security.PdfStandardSecurityHandler : PdfSecurityHandler {
    private string _userPassword;
    private string _ownerPassword;
    [NullableAttribute("2")]
private PdfEncryptionBase _encryption;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, PdfCryptFilter> _loadedCryptFilters;
    [NullableAttribute("2")]
private CryptFilterBase _defaultCryptFilterStreams;
    [NullableAttribute("2")]
private CryptFilterBase _defaultCryptFilterStrings;
    [NullableAttribute("2")]
private CryptFilterBase _defaultCryptFilterEmbeddedFileStreams;
    private bool IsEncrypted { get; }
    internal string UserPassword { get; public set; }
    internal string OwnerPassword { get; public set; }
    internal PdfUserAccessPermission Permissions { get; internal set; }
    internal DictionaryMeta Meta { get; }
    internal PdfStandardSecurityHandler(PdfDocument document);
    internal PdfStandardSecurityHandler(PdfDictionary dict);
    private void EnsureEncryptionIsSet();
    private void SetDefaultEncryption();
    public void SetEncryptionToNoneAndResetPasswords();
    [ObsoleteAttribute("Use SetEncryption(PdfDefaultEncryption encryption) instead.")]
public void SetEncryption(DefaultEncryption encryption);
    public void SetEncryption(PdfDefaultEncryption encryption);
    public void SetEncryptionToV1();
    public void SetEncryptionToV2(int length);
    public void SetEncryptionToV2With128Bits();
    public void SetEncryptionToV4UsingRC4(bool encryptMetadata);
    public void SetEncryptionToV4UsingAES(bool encryptMetadata);
    public void SetEncryptionToV5(bool encryptMetadata);
    private PdfEncryptionV1To4 SetEncryptionFieldToV1To4();
    private PdfEncryptionV5 SetEncryptionFieldToV5();
    [NullableContextAttribute("2")]
internal PdfStandardSecurityHandler GetIfEncryptionIsActive();
    private bool get_IsEncrypted();
    internal string get_UserPassword();
    public void set_UserPassword(string value);
    internal string get_OwnerPassword();
    public void set_OwnerPassword(string value);
    internal PdfUserAccessPermission get_Permissions();
    internal void set_Permissions(PdfUserAccessPermission value);
    internal UInt32 GetCorrectedPermissionsValue();
    internal void EnterObject(PdfObjectID id);
    internal void LeaveObject();
    private bool IsSecurityHandler(PdfObject pdfObject);
    public void DecryptObject(PdfObject value);
    private void DecryptDictionary(PdfDictionary dict);
    private void DecryptArray(PdfArray array);
    private void DecryptString(PdfStringObject value);
    private void DecryptString(PdfString value);
    internal void EncryptString(Byte[]& bytes);
    internal void DecryptString(Byte[]& bytes);
    internal void EncryptStream(Byte[]& bytes, PdfDictionary dictionary);
    internal void DecryptStream(Byte[]& bytes, PdfDictionary dictionary);
    internal void PrepareForReading();
    internal void PrepareForWriting();
    [NullableContextAttribute("2")]
internal PasswordValidity ValidatePassword(string inputPassword);
    internal virtual void WriteObject(PdfWriter writer);
    internal PdfEncryptionBase GetEncryption();
    private bool VersionSupportsCryptFilter();
    private void EnsureCryptFiltersAreSupported();
    private bool VersionNeedsCryptFilter();
    private void EnsureCryptFiltersAreNotNeeded();
    public void RemoveCryptFilters();
    private void RemoveCryptFilters(bool force);
    public PdfCryptFilter CreateCryptFilter();
    public PdfCryptFilter GetOrAddStandardCryptFilter(bool asDefaultIfNew);
    public void AddCryptFilter(string name, PdfCryptFilter cryptFilter, bool asDefault);
    public void EncryptEmbeddedFileStreamsOnly();
    [NullableContextAttribute("2")]
public void SetCryptFilterAsDefault(string name);
    [NullableContextAttribute("2")]
public void SetCryptFilterAsDefaultForStreams(string name);
    [NullableContextAttribute("2")]
public void SetCryptFilterAsDefaultForStrings(string name);
    [NullableContextAttribute("2")]
public void SetCryptFilterAsDefaultForEmbeddedFileStreams(string name);
    private void SetCryptFilterAsDefaultInternal(string key, string name);
    private void LoadCryptFilters(bool initializeCryptFilters);
    private CryptFilterBase GetDefaultCryptFilter(string cryptFilterName);
    private CryptFilterBase GetDefaultCryptFilter(string cryptFilterName, CryptFilterBase default);
    public void ResetCryptFilter(PdfDictionary dictionary);
    private void ResetCryptFilterEntriesInAllElements();
    public void SetIdentityCryptFilter(PdfDictionary dictionary);
    public void SetCryptFilter(PdfDictionary dictionary, string cryptFilterName);
    public CryptFilterBase GetCryptFilter(PdfDictionary dictionary);
    internal virtual DictionaryMeta get_Meta();
}
[FlagsAttribute]
internal enum PdfSharp.Pdf.Security.PdfUserAccessPermission : Enum {
    public UInt32 value__;
    public static PdfUserAccessPermission PermitAll;
    public static PdfUserAccessPermission PermitPrint;
    public static PdfUserAccessPermission PermitModifyDocument;
    public static PdfUserAccessPermission PermitExtractContent;
    public static PdfUserAccessPermission PermitAnnotations;
    public static PdfUserAccessPermission PermitFormsFill;
    public static PdfUserAccessPermission PermitAssembleDocument;
    public static PdfUserAccessPermission PermitFullQualityPrint;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Signatures.DefaultSignatureAppearanceHandler : object {
    [CompilerGeneratedAttribute]
private string <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Signer>k__BackingField;
    public string Location { get; public set; }
    public string Reason { get; public set; }
    public string Signer { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Location();
    [CompilerGeneratedAttribute]
public void set_Location(string value);
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
    [CompilerGeneratedAttribute]
public string get_Signer();
    [CompilerGeneratedAttribute]
public void set_Signer(string value);
    [NullableContextAttribute("1")]
public sealed virtual void DrawAppearance(XGraphics gfx, XRect rect);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Signatures.DigitalSignatureHandler : object {
    private static int ByteRangePaddingLength;
    [CompilerGeneratedAttribute]
private PdfDocument <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private DigitalSignatureOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private IDigitalSigner <Signer>k__BackingField;
    [NullableAttribute("2")]
private PdfSignaturePlaceholderItem _placeholderItem;
    [NullableAttribute("2")]
private PdfArrayWithPadding _signatureFieldByteRangePdfArray;
    public PdfDocument Document { get; public set; }
    public DigitalSignatureOptions Options { get; public set; }
    private IDigitalSigner Signer { get; private set; }
    private DigitalSignatureHandler(PdfDocument document, IDigitalSigner signer, DigitalSignatureOptions options);
    public static DigitalSignatureHandler ForDocument(PdfDocument document, IDigitalSigner signer, DigitalSignatureOptions options);
    [CompilerGeneratedAttribute]
public PdfDocument get_Document();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Document(PdfDocument value);
    [CompilerGeneratedAttribute]
public DigitalSignatureOptions get_Options();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Options(DigitalSignatureOptions value);
    [CompilerGeneratedAttribute]
private IDigitalSigner get_Signer();
    [CompilerGeneratedAttribute]
private Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Signer(IDigitalSigner value);
    [AsyncStateMachineAttribute("PdfSharp.Pdf.Signatures.DigitalSignatureHandler/<ComputeSignatureAndRange>d__15")]
internal Task ComputeSignatureAndRange(PdfWriter writer);
    private string FormatHex(Byte[] bytes);
    private ValueTuple`2<RangedStream, PdfArray> GetRangeToSignAndByteRangeArray(Stream stream);
    [AsyncStateMachineAttribute("PdfSharp.Pdf.Signatures.DigitalSignatureHandler/<AddSignatureComponentsAsync>d__18")]
internal Task AddSignatureComponentsAsync();
    private PdfSignatureField GetSignatureField(PdfDictionary signatureDic);
    private PdfDictionary GetSignatureDictionary(PdfSignaturePlaceholderItem contents, PdfArray byteRange);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Signatures.DigitalSignatureOptions : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IAnnotationAppearanceHandler <AppearanceHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContactInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppName>k__BackingField;
    [CompilerGeneratedAttribute]
private XRect <Rectangle>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PageIndex>k__BackingField;
    [NullableAttribute("2")]
public IAnnotationAppearanceHandler AppearanceHandler { get; public set; }
    public string ContactInfo { get; public set; }
    public string Location { get; public set; }
    public string Reason { get; public set; }
    public string AppName { get; public set; }
    public XRect Rectangle { get; public set; }
    public int PageIndex { get; public set; }
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IAnnotationAppearanceHandler get_AppearanceHandler();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AppearanceHandler(IAnnotationAppearanceHandler value);
    [CompilerGeneratedAttribute]
public string get_ContactInfo();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ContactInfo(string value);
    [CompilerGeneratedAttribute]
public string get_Location();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Location(string value);
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Reason(string value);
    [CompilerGeneratedAttribute]
public string get_AppName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AppName(string value);
    [CompilerGeneratedAttribute]
public XRect get_Rectangle();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Rectangle(XRect value);
    [CompilerGeneratedAttribute]
public int get_PageIndex();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PageIndex(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Signatures.PdfArrayWithPadding : PdfArray {
    [CompilerGeneratedAttribute]
private int <PaddingRight>k__BackingField;
    [CompilerGeneratedAttribute]
private long <StartPosition>k__BackingField;
    public int PaddingRight { get; public set; }
    public long StartPosition { get; internal set; }
    public PdfArrayWithPadding(PdfDocument document, int paddingRight, PdfItem[] items);
    [CompilerGeneratedAttribute]
public int get_PaddingRight();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PaddingRight(int value);
    internal virtual void WriteObject(PdfWriter writer);
    [CompilerGeneratedAttribute]
public long get_StartPosition();
    [CompilerGeneratedAttribute]
internal void set_StartPosition(long value);
}
public class PdfSharp.Pdf.Signatures.PdfSignature : PdfDictionary {
    [NullableContextAttribute("1")]
public PdfSignature(PdfDocument dict);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("({Size})")]
internal class PdfSharp.Pdf.Signatures.PdfSignaturePlaceholderItem : PdfItem {
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    private long _startPosition;
    private long _endPosition;
    public int Size { get; public set; }
    public long StartPosition { get; }
    public long EndPosition { get; }
    public PdfSignaturePlaceholderItem(int size);
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Size(int value);
    public long get_StartPosition();
    public long get_EndPosition();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.Pdf.Signatures.RangedStream : Stream {
    private Range[] _ranges;
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    private Stream Stream { get; }
    public RangedStream(Stream originalStream, List`1<Range> ranges);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    private IEnumerable`1<Range> GetPreviousRanges(long position);
    [NullableContextAttribute("2")]
private Range GetCurrentRange(long position);
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    private void PerformSkipIfNeeded();
    private Range GetNextRange();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [CompilerGeneratedAttribute]
private Stream get_Stream();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <GetNextRange>b__18_1(Range item);
}
public abstract class PdfSharp.Pdf.Structure.PdfAttributesBase : PdfDictionary {
    [NullableContextAttribute("1")]
internal PdfAttributesBase(PdfDocument document);
}
public class PdfSharp.Pdf.Structure.PdfLayoutAttributes : PdfAttributesBase {
    [NullableContextAttribute("1")]
internal PdfLayoutAttributes(PdfDocument document);
    private void SetOwner();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Structure.PdfMarkedContentReference : PdfDictionary {
    public PdfMarkedContentReference(PdfDocument document);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Structure.PdfMarkInformation : PdfDictionary {
    public PdfMarkInformation(PdfDocument document);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Structure.PdfObjectReference : PdfDictionary {
    public PdfObjectReference(PdfDocument document);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Structure.PdfStructureElement : PdfDictionary {
    public PdfLayoutAttributes LayoutAttributes { get; }
    public PdfTableAttributes TableAttributes { get; }
    public PdfStructureElement(PdfDocument document);
    internal virtual void PrepareForSave();
    [IteratorStateMachineAttribute("PdfSharp.Pdf.Structure.PdfStructureElement/<GetKids>d__3")]
internal static IEnumerable`1<PdfDictionary> GetKids(DictionaryElements elements);
    [NullableContextAttribute("2")]
private static PdfDictionary GetPdfDictionary(PdfItem item);
    private void SimplifyKidsArray();
    private void SimplifyAttributes();
    private bool AttributeDictionaryIsEmpty(PdfDictionary dictionary);
    public PdfLayoutAttributes get_LayoutAttributes();
    public PdfTableAttributes get_TableAttributes();
    private T GetAttributes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Structure.PdfStructureTreeRoot : PdfDictionary {
    public PdfStructureTreeRoot(PdfDocument document);
    internal virtual void PrepareForSave();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.Pdf.Structure.PdfTableAttributes : PdfAttributesBase {
    internal PdfTableAttributes(PdfDocument document);
    private void SetOwner();
}
[DebuggerDisplayAttribute("(Left={Left.Millimeter}mm, Right={Right.Millimeter}mm, Top={Top.Millimeter}mm, Bottom={Bottom.Millimeter}mm)")]
public class PdfSharp.Pdf.TrimMargins : object {
    [CompilerGeneratedAttribute]
private XUnit <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private XUnit <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private XUnit <Top>k__BackingField;
    [CompilerGeneratedAttribute]
private XUnit <Bottom>k__BackingField;
    unknown XUnit All {public set; }
    public XUnit Left { get; public set; }
    public XUnit Right { get; public set; }
    public XUnit Top { get; public set; }
    public XUnit Bottom { get; public set; }
    public bool AreSet { get; }
    public void set_All(XUnit value);
    [CompilerGeneratedAttribute]
public XUnit get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(XUnit value);
    [CompilerGeneratedAttribute]
public XUnit get_Right();
    [CompilerGeneratedAttribute]
public void set_Right(XUnit value);
    [CompilerGeneratedAttribute]
public XUnit get_Top();
    [CompilerGeneratedAttribute]
public void set_Top(XUnit value);
    [CompilerGeneratedAttribute]
public XUnit get_Bottom();
    [CompilerGeneratedAttribute]
public void set_Bottom(XUnit value);
    public bool get_AreSet();
}
public enum PdfSharp.Pdf.VCF : Enum {
    public int value__;
    public static VCF None;
    public static VCF Create;
    public static VCF CreateIndirect;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.PdfSharpException : Exception {
    public PdfSharpException(string message);
    public PdfSharpException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class PdfSharp.PdfSharpProductVersionInformation : object {
    public static string Title;
    public static string Description;
    public static string VersionMajor;
    public static string VersionMinor;
    public static string VersionPatch;
    public static string VersionPreRelease;
    public static string Creator;
    public static string Producer;
    public static string Version;
    public static string SemanticVersion;
    public static string Url;
    public static string Configuration;
    public static string Company;
    public static string Product;
    public static string Copyright;
    public static string Trademark;
    public static string Culture;
    public static string Technology;
    private static PdfSharpProductVersionInformation();
}
internal class PdfSharp.UniversalAccessibility.ArtifactItem : MarkedContentItem {
    public virtual void BeginItem();
    public virtual void EndItem();
}
internal class PdfSharp.UniversalAccessibility.BlockLevelItem : StructureElementItem {
    [NullableContextAttribute("1")]
public BlockLevelItem(PdfStructureElement element);
    public virtual void BeginItem();
    public virtual void EndItem();
    public virtual void OnDrawString();
    public virtual void OnDraw();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class PdfSharp.UniversalAccessibility.Drawing.XGraphicsExtensions : object {
    [ExtensionAttribute]
public static void DrawString(XGraphics gfx, string text, XFont font, XBrush brush, double x, double y, XStringFormat format, PdfBlockLevelElementTag tag);
    [ExtensionAttribute]
public static void DrawString(XGraphics gfx, string text, XFont font, XBrush brush, double x, double y, XStringFormat format, PdfInlineLevelElementTag tag);
    [ExtensionAttribute]
public static void DrawString(XGraphics gfx, string text, XFont font, XBrush brush, XPoint point, XStringFormat format, PdfBlockLevelElementTag tag);
    [ExtensionAttribute]
public static void DrawString(XGraphics gfx, string text, XFont font, XBrush brush, XPoint point, XStringFormat format, PdfInlineLevelElementTag tag);
    [ExtensionAttribute]
public static void DrawString(XGraphics gfx, string text, XFont font, XBrush brush, double x, double y, PdfBlockLevelElementTag tag);
    [ExtensionAttribute]
public static void DrawString(XGraphics gfx, string text, XFont font, XBrush brush, double x, double y, PdfInlineLevelElementTag tag);
    [ExtensionAttribute]
public static void DrawString(XGraphics gfx, string text, XFont font, XBrush brush, XPoint point, PdfBlockLevelElementTag tag);
    [ExtensionAttribute]
public static void DrawString(XGraphics gfx, string text, XFont font, XBrush brush, XPoint point, PdfInlineLevelElementTag tag);
    [ExtensionAttribute]
public static void DrawAbbreviation(XGraphics gfx, string abbreviation, string expandedText, XFont font, XBrush brush, double x, double y, XStringFormat format, PdfInlineLevelElementTag tag);
    [ExtensionAttribute]
public static void DrawAbbreviation(XGraphics gfx, string abbreviation, string expandedText, XFont font, XBrush brush, double x, double y, XStringFormat format);
    [ExtensionAttribute]
public static void DrawAbbreviation(XGraphics gfx, string abbreviation, string expandedText, XFont font, XBrush brush, XPoint point, XStringFormat format);
    [ExtensionAttribute]
public static void DrawAbbreviation(XGraphics gfx, string abbreviation, string expandedText, XFont font, XBrush brush, double x, double y);
    [ExtensionAttribute]
public static void DrawAbbreviation(XGraphics gfx, string abbreviation, string expandedText, XFont font, XBrush brush, XPoint point);
    [ExtensionAttribute]
public static void DrawImage(XGraphics gfx, XImage image, double x, double y, string altText, XRect boundingBox);
    [ExtensionAttribute]
public static void DrawImage(XGraphics gfx, XImage image, double x, double y, double width, double height, string altText, XRect boundingBox);
    [ExtensionAttribute]
public static void DrawImage(XGraphics gfx, XImage image, XPoint point, string altText, XRect boundingBox);
    [ExtensionAttribute]
public static void DrawImage(XGraphics gfx, XImage image, XPoint point, double width, double height, string altText, XRect boundingBox);
    [ExtensionAttribute]
public static void DrawImage(XGraphics gfx, XImage image, XRect rect, string altText, XRect boundingBox);
    [ExtensionAttribute]
public static void DrawImage(XGraphics gfx, XImage image, double x, double y, string altText);
    [ExtensionAttribute]
public static void DrawImage(XGraphics gfx, XImage image, double x, double y, double width, double height, string altText);
    [ExtensionAttribute]
public static void DrawImage(XGraphics gfx, XImage image, XPoint point, string altText);
    [ExtensionAttribute]
public static void DrawImage(XGraphics gfx, XImage image, XPoint point, double width, double height, string altText);
    [ExtensionAttribute]
public static void DrawImage(XGraphics gfx, XImage image, XRect rect, string altText);
    private static XRect GetBoundingBox(XImage image, double x, double y);
    private static XRect GetBoundingBox(XImage image, double x, double y, double width, double height);
    [ExtensionAttribute]
public static void DrawLink(XGraphics gfx, string s, XFont font, XBrush brush, double x, double y, XStringFormat format, PdfLinkAnnotation linkAnnotation, string altText);
    [ExtensionAttribute]
public static void DrawLink(XGraphics gfx, string s, XFont font, XBrush brush, XPoint point, XStringFormat format, PdfLinkAnnotation linkAnnotation, string altText);
    [ExtensionAttribute]
public static void DrawLink(XGraphics gfx, string s, XFont font, XBrush brush, double x, double y, PdfLinkAnnotation linkAnnotation, string altText);
    [ExtensionAttribute]
public static void DrawLink(XGraphics gfx, string s, XFont font, XBrush brush, XPoint point, PdfLinkAnnotation linkAnnotation, string altText);
    [ExtensionAttribute]
public static void DrawListItem(XGraphics gfx, string label, string text, XFont font, XBrush brush, double x, double y, double labelWidth, XStringFormat format);
    [ExtensionAttribute]
public static void DrawListItem(XGraphics gfx, string label, string text, XFont font, XBrush brush, XPoint point, double labelWidth, XStringFormat format);
    [ExtensionAttribute]
public static void DrawListItem(XGraphics gfx, string label, string text, XFont font, XBrush brush, double x, double y, double labelWidth);
    [ExtensionAttribute]
public static void DrawListItem(XGraphics gfx, string label, string text, XFont font, XBrush brush, XPoint point, double labelWidth);
    private static UAManager GetUAManager(XGraphics gfx);
    private static StructureBuilder GetStructureBuilder(XGraphics gfx);
}
internal class PdfSharp.UniversalAccessibility.GroupingItem : StructureElementItem {
    [NullableContextAttribute("1")]
public GroupingItem(PdfStructureElement element);
    public virtual void BeginItem();
    public virtual void EndItem();
    public virtual void OnDrawString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class PdfSharp.UniversalAccessibility.IllustrationItem : StructureElementItem {
    [CompilerGeneratedAttribute]
private string <AltText>k__BackingField;
    [CompilerGeneratedAttribute]
private XRect <BoundingRect>k__BackingField;
    public string AltText { get; public set; }
    public XRect BoundingRect { get; public set; }
    [NullableContextAttribute("1")]
public IllustrationItem(PdfStructureElement element);
    [CompilerGeneratedAttribute]
public string get_AltText();
    [CompilerGeneratedAttribute]
public void set_AltText(string value);
    [CompilerGeneratedAttribute]
public XRect get_BoundingRect();
    [CompilerGeneratedAttribute]
public void set_BoundingRect(XRect value);
    public virtual void BeginItem();
    public virtual void EndItem();
    public virtual void OnDrawString();
    public virtual void OnDraw();
}
internal class PdfSharp.UniversalAccessibility.InlineLevelItem : StructureElementItem {
    [NullableContextAttribute("1")]
public InlineLevelItem(PdfStructureElement element);
    public virtual void BeginItem();
    public virtual void EndItem();
    public virtual void OnDrawString();
    public virtual void OnDraw();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.UniversalAccessibility.MarkedContentItem : StructureItem {
    public string Tag;
    public bool InTextMode;
    public MarkedContentItem(string tag);
    public virtual void BeginItem();
    public virtual void EndItem();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.UniversalAccessibility.MarkedContentItemWithId : MarkedContentItem {
    public StructureElementItem StructureElementItem;
    public int Mcid;
    public MarkedContentItemWithId(StructureElementItem item, string tag, int mcid);
    public virtual void BeginItem();
    public virtual void EndItem();
}
public enum PdfSharp.UniversalAccessibility.PdfBlockLevelElementTag : Enum {
    public int value__;
    [ObsoleteAttribute("Use 'Paragraph'.")]
public static PdfBlockLevelElementTag P;
    public static PdfBlockLevelElementTag Paragraph;
    [ObsoleteAttribute("Use 'Heading'.")]
public static PdfBlockLevelElementTag H;
    public static PdfBlockLevelElementTag Heading;
    [ObsoleteAttribute("Use 'Heading1'.")]
public static PdfBlockLevelElementTag H1;
    [ObsoleteAttribute("Use 'Heading2'.")]
public static PdfBlockLevelElementTag H2;
    [ObsoleteAttribute("Use 'Heading3'.")]
public static PdfBlockLevelElementTag H3;
    [ObsoleteAttribute("Use 'Heading4'.")]
public static PdfBlockLevelElementTag H4;
    [ObsoleteAttribute("Use 'Heading5'.")]
public static PdfBlockLevelElementTag H5;
    [ObsoleteAttribute("Use 'Heading6'.")]
public static PdfBlockLevelElementTag H6;
    public static PdfBlockLevelElementTag Heading1;
    public static PdfBlockLevelElementTag Heading2;
    public static PdfBlockLevelElementTag Heading3;
    public static PdfBlockLevelElementTag Heading4;
    public static PdfBlockLevelElementTag Heading5;
    public static PdfBlockLevelElementTag Heading6;
    [ObsoleteAttribute("Use 'List'.")]
public static PdfBlockLevelElementTag L;
    public static PdfBlockLevelElementTag List;
    [ObsoleteAttribute("Use 'Label'.")]
public static PdfBlockLevelElementTag Lbl;
    public static PdfBlockLevelElementTag Label;
    [ObsoleteAttribute("Use 'ListItem'.")]
public static PdfBlockLevelElementTag LI;
    public static PdfBlockLevelElementTag ListItem;
    [ObsoleteAttribute("Use 'ListBody'.")]
public static PdfBlockLevelElementTag LBody;
    public static PdfBlockLevelElementTag ListBody;
    public static PdfBlockLevelElementTag Table;
    [ObsoleteAttribute("Use 'TableRow'.")]
public static PdfBlockLevelElementTag TR;
    public static PdfBlockLevelElementTag TableRow;
    [ObsoleteAttribute("Use 'TableHeaderCell'.")]
public static PdfBlockLevelElementTag TH;
    public static PdfBlockLevelElementTag TableHeaderCell;
    [ObsoleteAttribute("Use 'TableDataCell'.")]
public static PdfBlockLevelElementTag TD;
    public static PdfBlockLevelElementTag TableDataCell;
    [ObsoleteAttribute("Use 'TableHeadRowGroup'.")]
public static PdfBlockLevelElementTag THead;
    public static PdfBlockLevelElementTag TableHeadRowGroup;
    [ObsoleteAttribute("Use 'TableBodyRowGroup'.")]
public static PdfBlockLevelElementTag TBody;
    public static PdfBlockLevelElementTag TableBodyRowGroup;
    [ObsoleteAttribute("Use 'TableFooterRowGroup'.")]
public static PdfBlockLevelElementTag TFoot;
    public static PdfBlockLevelElementTag TableFooterRowGroup;
}
public enum PdfSharp.UniversalAccessibility.PdfGroupingElementTag : Enum {
    public int value__;
    public static PdfGroupingElementTag Document;
    public static PdfGroupingElementTag Part;
    public static PdfGroupingElementTag Article;
    [ObsoleteAttribute("Use 'Article'.")]
public static PdfGroupingElementTag Art;
    public static PdfGroupingElementTag Section;
    [ObsoleteAttribute("Use 'Section'.")]
public static PdfGroupingElementTag Sect;
    public static PdfGroupingElementTag Division;
    [ObsoleteAttribute("Use 'Division'.")]
public static PdfGroupingElementTag Div;
    public static PdfGroupingElementTag BlockQuotation;
    [ObsoleteAttribute("Use 'BlockQuotation'.")]
public static PdfGroupingElementTag BlockQuote;
    public static PdfGroupingElementTag Caption;
    public static PdfGroupingElementTag TableOfContents;
    [ObsoleteAttribute("Use 'TableOfContents'.")]
public static PdfGroupingElementTag TOC;
    public static PdfGroupingElementTag TableOfContentsItem;
    [ObsoleteAttribute("Use 'TableOfContentsItem'.")]
public static PdfGroupingElementTag TOCI;
    public static PdfGroupingElementTag Index;
    public static PdfGroupingElementTag NonstructuralElement;
    [ObsoleteAttribute("Use 'NonstructuralElement'.")]
public static PdfGroupingElementTag NonStruct;
    public static PdfGroupingElementTag PrivateElement;
    [ObsoleteAttribute("Use 'PrivateElement'.")]
public static PdfGroupingElementTag Private;
}
public enum PdfSharp.UniversalAccessibility.PdfIllustrationElementTag : Enum {
    public int value__;
    public static PdfIllustrationElementTag Figure;
    public static PdfIllustrationElementTag Formula;
    public static PdfIllustrationElementTag Form;
}
public enum PdfSharp.UniversalAccessibility.PdfInlineLevelElementTag : Enum {
    public int value__;
    public static PdfInlineLevelElementTag Span;
    public static PdfInlineLevelElementTag Quotation;
    [ObsoleteAttribute("Use 'Quotation'.")]
public static PdfInlineLevelElementTag Quote;
    public static PdfInlineLevelElementTag Note;
    public static PdfInlineLevelElementTag Reference;
    public static PdfInlineLevelElementTag BibliographyEntry;
    [ObsoleteAttribute("Use 'BibliographyEntry'.")]
public static PdfInlineLevelElementTag BibEntry;
    public static PdfInlineLevelElementTag Code;
    public static PdfInlineLevelElementTag Link;
    public static PdfInlineLevelElementTag Annotation;
    [ObsoleteAttribute("Use 'Annotation'.")]
public static PdfInlineLevelElementTag Annot;
    public static PdfInlineLevelElementTag Ruby;
    public static PdfInlineLevelElementTag Warichu;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class PdfSharp.UniversalAccessibility.PdfRendererExtensions : object {
    public static void BeginTextMode(XGraphics gfx);
    public static void BeginGraphicMode(XGraphics gfx);
    public static bool IsInTextMode(XGraphics gfx);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.UniversalAccessibility.StructureBuilder : object {
    [CompilerGeneratedAttribute]
private int <NextMcid>k__BackingField;
    internal UAManager UaManager;
    private StructureStack _elementStack;
    public PdfStructureElement CurrentStructureElement { get; }
    internal int NextMcid { get; internal set; }
    internal ContentWriter Content { get; }
    internal StructureBuilder(UAManager uaManager);
    public void BeginElement(PdfGroupingElementTag tag);
    public void BeginGroupingElement(string tag);
    public void BeginElement(PdfBlockLevelElementTag tag);
    public void BeginBlockLevelElement(string tag);
    public void BeginElement(PdfInlineLevelElementTag tag);
    public void BeginInlineLevelElement(string tag);
    public void BeginElement(PdfIllustrationElementTag tag, string altText, XRect boundingBox);
    public void BeginIllustrationElement(string tag, string altText, XRect boundingRect);
    public void BeginArtifact();
    public void BeginElement(PdfLinkAnnotation linkAnnotation, string altText);
    public void End();
    public PdfStructureElement get_CurrentStructureElement();
    public void SetAltText(string altText);
    public void SetExpandedText(string expandedText);
    public void SetLanguage(string language);
    public void SetRowSpan(int rowSpan);
    public void SetColSpan(int colSpan);
    internal void BeginMarkedContentInternal(StructureElementItem steItem);
    public void EndMarkedContentsWithId();
    [CompilerGeneratedAttribute]
internal int get_NextMcid();
    [CompilerGeneratedAttribute]
internal void set_NextMcid(int value);
    private PdfStructureElement CreateStructureElement(string tag);
    private void AddMarkedContentToStructureElement(PdfStructureElement ste, int mcid);
    private void AddToParentTree(PdfStructureElement ste, int mcid);
    private void AddToParentTree(PdfStructureElement ste, PdfAnnotation annotation);
    private void AddAnnotationToStructureElement(PdfStructureElement ste, PdfAnnotation annotation);
    internal void OnAddPage();
    internal void OnDrawString();
    internal void OnDraw();
    internal ContentWriter get_Content();
    private string TagToString(PdfGroupingElementTag tag);
    private string TagToString(PdfBlockLevelElementTag tag);
    private string TagToString(PdfInlineLevelElementTag tag);
    private string TagToString(PdfIllustrationElementTag tag);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.UniversalAccessibility.StructureElementItem : StructureItem {
    public PdfStructureElement Element;
    public StructureTypeCategory Category;
    protected StructureElementItem(PdfStructureElement element, StructureTypeCategory category);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.UniversalAccessibility.StructureItem : object {
    [CompilerGeneratedAttribute]
private StructureBuilder <StructureBuilder>k__BackingField;
    public bool EndMark;
    public StructureBuilder StructureBuilder { get; public set; }
    [CompilerGeneratedAttribute]
public StructureBuilder get_StructureBuilder();
    [CompilerGeneratedAttribute]
public void set_StructureBuilder(StructureBuilder value);
    public virtual void BeginItem();
    public virtual void EndItem();
    public virtual void OnDrawString();
    public virtual void OnDraw();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PdfSharp.UniversalAccessibility.StructureStack : object {
    private UAManager _uaManager;
    private List`1<StructureItem> _list;
    public PdfStructureElement MostInnerStructureElement { get; }
    [NullableAttribute("2")]
public StructureItem Current { get; }
    public IEnumerable`1<StructureItem> Items { get; }
    public StructureStack(UAManager uaManager);
    public PdfStructureElement get_MostInnerStructureElement();
    public void Push(StructureItem item);
    public StructureItem Pop();
    [NullableContextAttribute("2")]
public StructureItem get_Current();
    public IEnumerable`1<StructureItem> get_Items();
}
internal enum PdfSharp.UniversalAccessibility.StructureTypeCategory : Enum {
    public int value__;
    public static StructureTypeCategory GroupingElement;
    public static StructureTypeCategory BlockLevelStructureElement;
    public static StructureTypeCategory InlineLevelStructureElement;
    public static StructureTypeCategory IllustrationElement;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class PdfSharp.UniversalAccessibility.UAManager : object {
    [CompilerGeneratedAttribute]
private PdfStructureTreeRoot <StructureTreeRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfStructureElement <StructureTreeElementDocument>k__BackingField;
    [NullableAttribute("2")]
private StructureBuilder _sb;
    private PdfDocument _document;
    [CompilerGeneratedAttribute]
private PdfPage <CurrentPage>k__BackingField;
    [CompilerGeneratedAttribute]
private XGraphics <CurrentGraphics>k__BackingField;
    public PdfStructureTreeRoot StructureTreeRoot { get; public set; }
    public PdfStructureElement StructureTreeElementDocument { get; public set; }
    public StructureBuilder StructureBuilder { get; }
    public PdfDocument Owner { get; }
    public PdfPage CurrentPage { get; private set; }
    public XGraphics CurrentGraphics { get; private set; }
    private UAManager(PdfDocument document);
    [CompilerGeneratedAttribute]
public PdfStructureTreeRoot get_StructureTreeRoot();
    [CompilerGeneratedAttribute]
public void set_StructureTreeRoot(PdfStructureTreeRoot value);
    [CompilerGeneratedAttribute]
public PdfStructureElement get_StructureTreeElementDocument();
    [CompilerGeneratedAttribute]
public void set_StructureTreeElementDocument(PdfStructureElement value);
    public static UAManager ForDocument(PdfDocument document);
    public StructureBuilder get_StructureBuilder();
    private void OnPageAdded(object sender, PageEventArgs e);
    private void OnPageRemoved(object sender, PageEventArgs e);
    private void OnPageGraphicsCreated(object sender, PageGraphicsEventArgs e);
    private void OnPageGraphicsAction(object sender, PageGraphicsEventArgs e);
    public PdfDocument get_Owner();
    [CompilerGeneratedAttribute]
public PdfPage get_CurrentPage();
    [CompilerGeneratedAttribute]
private void set_CurrentPage(PdfPage value);
    [CompilerGeneratedAttribute]
public XGraphics get_CurrentGraphics();
    [CompilerGeneratedAttribute]
private void set_CurrentGraphics(XGraphics value);
    public void SetDocumentLanguage(string lang);
    public void BeginTextMode();
    public void BeginGraphicMode();
    public bool IsInTextMode();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
internal static class System.Runtime.CompilerServices.RuntimeHelpers : object {
    [NullableContextAttribute("1")]
public static T[] GetSubArray(T[] array, Range range);
}
