[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public abstract class MigraDocCore.DocumentObjectModel.MigraDoc.DocumentObjectModel.Shapes.ImageSource : object {
    [CompilerGeneratedAttribute]
private static ImageSource <ImageSourceImpl>k__BackingField;
    public static ImageSource ImageSourceImpl { get; public set; }
    [CompilerGeneratedAttribute]
public static ImageSource get_ImageSourceImpl();
    [CompilerGeneratedAttribute]
public static void set_ImageSourceImpl(ImageSource value);
    protected abstract virtual IImageSource FromFileImpl(string path, Nullable`1<int> quality);
    protected abstract virtual IImageSource FromBinaryImpl(string name, Func`1<Byte[]> imageSource, Nullable`1<int> quality);
    protected abstract virtual IImageSource FromStreamImpl(string name, Func`1<Stream> imageStream, Nullable`1<int> quality);
    public static IImageSource FromFile(string path, Nullable`1<int> quality);
    public static IImageSource FromBinary(string name, Func`1<Byte[]> imageSource, Nullable`1<int> quality);
    public static IImageSource FromStream(string name, Func`1<Stream> imageStream, Nullable`1<int> quality);
}
internal static class PdfSharpCore.Config : object {
    public static string SignificantFigures2;
    public static string SignificantFigures3;
    public static string SignificantFigures4;
    public static string SignificantFigures7;
    public static string SignificantFigures10;
    public static string SignificantFigures1Plus9;
}
internal static class PdfSharpCore.Const : object {
    public static double Deg2Rad;
    public static double ItalicSkewAngleSinus;
    public static double BoldEmphasis;
    public static double κ;
}
public enum PdfSharpCore.Drawing.BarCodes.AnchorType : Enum {
    public int value__;
    public static AnchorType TopLeft;
    public static AnchorType TopCenter;
    public static AnchorType TopRight;
    public static AnchorType MiddleLeft;
    public static AnchorType MiddleCenter;
    public static AnchorType MiddleRight;
    public static AnchorType BottomLeft;
    public static AnchorType BottomCenter;
    public static AnchorType BottomRight;
}
public abstract class PdfSharpCore.Drawing.BarCodes.BarCode : CodeBase {
    private TextLocation _textLocation;
    private int _dataLength;
    private char _startChar;
    private char _endChar;
    private bool _turboBit;
    public double WideNarrowRatio { get; public set; }
    public TextLocation TextLocation { get; public set; }
    public int DataLength { get; public set; }
    public char StartChar { get; public set; }
    public char EndChar { get; public set; }
    public bool TurboBit { get; public set; }
    public BarCode(string text, XSize size, CodeDirection direction);
    public static BarCode FromType(CodeType type, string text, XSize size, CodeDirection direction);
    public static BarCode FromType(CodeType type, string text, XSize size);
    public static BarCode FromType(CodeType type, string text);
    public static BarCode FromType(CodeType type);
    public virtual double get_WideNarrowRatio();
    public virtual void set_WideNarrowRatio(double value);
    public TextLocation get_TextLocation();
    public void set_TextLocation(TextLocation value);
    public int get_DataLength();
    public void set_DataLength(int value);
    public char get_StartChar();
    public void set_StartChar(char value);
    public char get_EndChar();
    public void set_EndChar(char value);
    public virtual bool get_TurboBit();
    public virtual void set_TurboBit(bool value);
    internal virtual void InitRendering(BarCodeRenderInfo info);
    protected internal abstract virtual void Render(XGraphics gfx, XBrush brush, XFont font, XPoint position);
}
internal class PdfSharpCore.Drawing.BarCodes.BarCodeRenderInfo : object {
    public XGraphics Gfx;
    public XBrush Brush;
    public XFont Font;
    public XPoint Position;
    public double BarHeight;
    public XPoint CurrPos;
    public int CurrPosInString;
    public double ThinBarWidth;
    public BarCodeRenderInfo(XGraphics gfx, XBrush brush, XFont font, XPoint position);
}
internal class PdfSharpCore.Drawing.BarCodes.BcgSR : object {
    internal static string BarCodeNotSet { get; }
    internal static string EmptyBarCodeSize { get; }
    internal static string Invalid2of5Relation { get; }
    internal static string OmrAlreadyInitialized { get; }
    internal static string DataMatrixTooBig { get; }
    internal static string DataMatrixNotSupported { get; }
    internal static string DataMatrixNull { get; }
    internal static string Invalid2Of5Code(string code);
    internal static string Invalid3Of9Code(string code);
    internal static string get_BarCodeNotSet();
    internal static string get_EmptyBarCodeSize();
    internal static string get_Invalid2of5Relation();
    internal static string InvalidMarkName(string name);
    internal static string get_OmrAlreadyInitialized();
    internal static string get_DataMatrixTooBig();
    internal static string get_DataMatrixNotSupported();
    internal static string get_DataMatrixNull();
    internal static string DataMatrixInvalid(int columns, int rows);
}
public class PdfSharpCore.Drawing.BarCodes.Code2of5Interleaved : ThickThinBarCode {
    private static Boolean[][] Lines;
    public Code2of5Interleaved(string code);
    public Code2of5Interleaved(string code, XSize size);
    public Code2of5Interleaved(string code, XSize size, CodeDirection direction);
    private static Code2of5Interleaved();
    private static Boolean[] ThickAndThinLines(int digit);
    protected internal virtual void Render(XGraphics gfx, XBrush brush, XFont font, XPoint position);
    internal virtual void CalcThinBarWidth(BarCodeRenderInfo info);
    private void RenderStart(BarCodeRenderInfo info);
    private void RenderStop(BarCodeRenderInfo info);
    private void RenderNextPair(BarCodeRenderInfo info);
    protected virtual void CheckCode(string text);
}
public class PdfSharpCore.Drawing.BarCodes.Code3of9Standard : ThickThinBarCode {
    private static Boolean[][] Lines;
    public Code3of9Standard(string code);
    public Code3of9Standard(string code, XSize size);
    public Code3of9Standard(string code, XSize size, CodeDirection direction);
    private static Code3of9Standard();
    private static Boolean[] ThickThinLines(char ch);
    internal virtual void CalcThinBarWidth(BarCodeRenderInfo info);
    protected virtual void CheckCode(string text);
    protected internal virtual void Render(XGraphics gfx, XBrush brush, XFont font, XPoint position);
    private void RenderNextChar(BarCodeRenderInfo info);
    private void RenderChar(BarCodeRenderInfo info, char ch);
    private void RenderStart(BarCodeRenderInfo info);
    private void RenderStop(BarCodeRenderInfo info);
}
public abstract class PdfSharpCore.Drawing.BarCodes.CodeBase : object {
    private XSize _size;
    private string _text;
    private AnchorType _anchor;
    private CodeDirection _direction;
    private static Delta[0...,0...] Deltas;
    public XSize Size { get; public set; }
    public string Text { get; public set; }
    public AnchorType Anchor { get; public set; }
    public CodeDirection Direction { get; public set; }
    public CodeBase(string text, XSize size, CodeDirection direction);
    private static CodeBase();
    public XSize get_Size();
    public void set_Size(XSize value);
    public string get_Text();
    public void set_Text(string value);
    public AnchorType get_Anchor();
    public void set_Anchor(AnchorType value);
    public CodeDirection get_Direction();
    public void set_Direction(CodeDirection value);
    protected abstract virtual void CheckCode(string text);
    public static XVector CalcDistance(AnchorType oldType, AnchorType newType, XSize size);
}
public class PdfSharpCore.Drawing.BarCodes.CodeDataMatrix : MatrixCode {
    private int _quietZone;
    public int QuietZone { get; public set; }
    public CodeDataMatrix(string code, int length);
    public CodeDataMatrix(string code, int length, XSize size);
    public CodeDataMatrix(string code, DataMatrixEncoding dmEncoding, int length, XSize size);
    public CodeDataMatrix(string code, int rows, int columns);
    public CodeDataMatrix(string code, int rows, int columns, XSize size);
    public CodeDataMatrix(string code, DataMatrixEncoding dmEncoding, int rows, int columns, XSize size);
    public CodeDataMatrix(string code, int rows, int columns, int quietZone);
    public CodeDataMatrix(string code, string encoding, int rows, int columns, int quietZone, XSize size);
    public void SetEncoding(DataMatrixEncoding dmEncoding);
    private static string CreateEncoding(DataMatrixEncoding dmEncoding, int length);
    public int get_QuietZone();
    public void set_QuietZone(int value);
    protected internal virtual void Render(XGraphics gfx, XBrush brush, XPoint position);
    protected virtual void CheckCode(string text);
}
public enum PdfSharpCore.Drawing.BarCodes.CodeDirection : Enum {
    public int value__;
    public static CodeDirection LeftToRight;
    public static CodeDirection BottomToTop;
    public static CodeDirection RightToLeft;
    public static CodeDirection TopToBottom;
}
public class PdfSharpCore.Drawing.BarCodes.CodeOmr : BarCode {
    private bool _synchronizeCode;
    private double _makerDistance;
    private double _makerThickness;
    public bool SynchronizeCode { get; public set; }
    public double MakerDistance { get; public set; }
    public double MakerThickness { get; public set; }
    public CodeOmr(string text, XSize size, CodeDirection direction);
    protected internal virtual void Render(XGraphics gfx, XBrush brush, XFont font, XPoint position);
    public bool get_SynchronizeCode();
    public void set_SynchronizeCode(bool value);
    public double get_MakerDistance();
    public void set_MakerDistance(double value);
    public double get_MakerThickness();
    public void set_MakerThickness(double value);
    protected virtual void CheckCode(string text);
}
public enum PdfSharpCore.Drawing.BarCodes.CodeType : Enum {
    public int value__;
    public static CodeType Code2of5Interleaved;
    public static CodeType Code3of9Standard;
    public static CodeType Omr;
    public static CodeType DataMatrix;
}
public enum PdfSharpCore.Drawing.BarCodes.DataMatrixEncoding : Enum {
    public int value__;
    public static DataMatrixEncoding Ascii;
    public static DataMatrixEncoding C40;
    public static DataMatrixEncoding Text;
    public static DataMatrixEncoding X12;
    public static DataMatrixEncoding EDIFACT;
    public static DataMatrixEncoding Base256;
}
internal class PdfSharpCore.Drawing.BarCodes.DataMatrixImage : object {
    private string text;
    private string encoding;
    private int rows;
    private int columns;
    private static Ecc200Block[] ecc200Sizes;
    public DataMatrixImage(string text, string encoding, int rows, int columns);
    private static DataMatrixImage();
    public static XImage GenerateMatrixImage(string text, string encoding, int rows, int columns);
    public XImage DrawMatrix();
    internal Char[] DataMatrix();
    internal Char[] Iec16022Ecc200(int columns, int rows, string encoding, int barcodelen, string barcode, int len, int max, int ecc);
    public XImage CreateImage(Char[] code, int size);
    public XImage CreateImage(Char[] code, int rows, int columns);
    public XImage CreateImage(Char[] code, int rows, int columns, int pixelsize);
}
internal class PdfSharpCore.Drawing.BarCodes.Ecc200Block : ValueType {
    public int Height;
    public int Width;
    public int CellHeight;
    public int CellWidth;
    public int Bytes;
    public int DataBlock;
    public int RSBlock;
    public Ecc200Block(int h, int w, int ch, int cw, int bytes, int datablock, int rsblock);
}
public abstract class PdfSharpCore.Drawing.BarCodes.MatrixCode : CodeBase {
    private string _encoding;
    private int _columns;
    private int _rows;
    private XImage _matrixImage;
    public string Encoding { get; public set; }
    public int Columns { get; public set; }
    public int Rows { get; public set; }
    public string Text { get; public set; }
    internal XImage MatrixImage { get; internal set; }
    public MatrixCode(string text, string encoding, int rows, int columns, XSize size);
    public string get_Encoding();
    public void set_Encoding(string value);
    public int get_Columns();
    public void set_Columns(int value);
    public int get_Rows();
    public void set_Rows(int value);
    public string get_Text();
    public void set_Text(string value);
    internal XImage get_MatrixImage();
    internal void set_MatrixImage(XImage value);
    protected internal abstract virtual void Render(XGraphics gfx, XBrush brush, XPoint center);
    protected virtual void CheckCode(string text);
}
public enum PdfSharpCore.Drawing.BarCodes.TextLocation : Enum {
    public int value__;
    public static TextLocation None;
    public static TextLocation Above;
    public static TextLocation Below;
    public static TextLocation AboveEmbedded;
    public static TextLocation BelowEmbedded;
}
public abstract class PdfSharpCore.Drawing.BarCodes.ThickThinBarCode : BarCode {
    private double _wideNarrowRatio;
    public double WideNarrowRatio { get; public set; }
    public ThickThinBarCode(string code, XSize size, CodeDirection direction);
    internal virtual void InitRendering(BarCodeRenderInfo info);
    public virtual double get_WideNarrowRatio();
    public virtual void set_WideNarrowRatio(double value);
    internal void RenderBar(BarCodeRenderInfo info, bool isThick);
    internal void RenderGap(BarCodeRenderInfo info, bool isThick);
    internal void RenderTurboBit(BarCodeRenderInfo info, bool startBit);
    internal void RenderText(BarCodeRenderInfo info);
    internal double GetBarWidth(BarCodeRenderInfo info, bool isThick);
    internal abstract virtual void CalcThinBarWidth(BarCodeRenderInfo info);
}
internal class PdfSharpCore.Drawing.CoreGraphicsPath : object {
    private static byte PathPointTypeStart;
    private static byte PathPointTypeLine;
    private static byte PathPointTypeBezier;
    private static byte PathPointTypePathTypeMask;
    private static byte PathPointTypeCloseSubpath;
    private XFillMode _fillMode;
    private List`1<XPoint> _points;
    private List`1<byte> _types;
    private XFillMode FillMode { get; private set; }
    public XPoint[] PathPoints { get; }
    public Byte[] PathTypes { get; }
    public CoreGraphicsPath(CoreGraphicsPath path);
    public void MoveOrLineTo(double x, double y);
    public void MoveTo(double x, double y);
    public void LineTo(double x, double y, bool closeSubpath);
    public void BezierTo(double x1, double y1, double x2, double y2, double x3, double y3, bool closeSubpath);
    public void QuadrantArcTo(double x, double y, double width, double height, int quadrant, bool clockwise);
    public void CloseSubpath();
    private XFillMode get_FillMode();
    private void set_FillMode(XFillMode value);
    public void AddArc(double x, double y, double width, double height, double startAngle, double sweepAngle);
    public void AddArc(XPoint point1, XPoint point2, XSize size, double rotationAngle, bool isLargeArg, XSweepDirection sweepDirection);
    public void AddCurve(XPoint[] points, double tension);
    private void ToCurveSegment(XPoint pt0, XPoint pt1, XPoint pt2, XPoint pt3, double tension3);
    public XPoint[] get_PathPoints();
    public Byte[] get_PathTypes();
}
internal class PdfSharpCore.Drawing.FontFamilyCache : object {
    private static FontFamilyCache modreq(System.Runtime.CompilerServices.IsVolatile) _singleton;
    private Dictionary`2<string, FontFamilyInternal> _familiesByName;
    private static FontFamilyCache Singleton { get; }
    public static FontFamilyInternal GetFamilyByName(string familyName);
    public static FontFamilyInternal CacheOrGetFontFamily(FontFamilyInternal fontFamily);
    private static FontFamilyCache get_Singleton();
    internal static string GetCacheState();
}
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
internal class PdfSharpCore.Drawing.FontFamilyInternal : object {
    private string _sourceName;
    private string _name;
    public string SourceName { get; }
    public string Name { get; }
    internal string DebuggerDisplay { get; }
    private FontFamilyInternal(string familyName, bool createPlatformObjects);
    internal static FontFamilyInternal GetOrCreateFromName(string familyName, bool createPlatformObject);
    public string get_SourceName();
    public string get_Name();
    internal string get_DebuggerDisplay();
}
internal static class PdfSharpCore.Drawing.FontHelper : object {
    public static XSize MeasureString(string text, XFont font, XStringFormat stringFormat);
    public static ulong CalcChecksum(Byte[] buffer);
    public static XFontStyle CreateStyle(bool isBold, bool isItalic);
}
internal enum PdfSharpCore.Drawing.FontWeightValues : Enum {
    public int value__;
    public static FontWeightValues Thin;
    public static FontWeightValues ExtraLight;
    public static FontWeightValues Light;
    public static FontWeightValues Normal;
    public static FontWeightValues Medium;
    public static FontWeightValues SemiBold;
    public static FontWeightValues Bold;
    public static FontWeightValues ExtraBold;
    public static FontWeightValues Black;
    public static FontWeightValues ExtraBlack;
}
internal static class PdfSharpCore.Drawing.GeometryHelper : object {
    public static List`1<XPoint> BezierCurveFromArc(double x, double y, double width, double height, double startAngle, double sweepAngle, PathStart pathStart, XMatrix& matrix);
    private static int Quadrant(double φ, bool start, bool clockwise);
    private static void AppendPartialArcQuadrant(List`1<XPoint> points, double x, double y, double width, double height, double α, double β, PathStart pathStart, XMatrix matrix);
    public static List`1<XPoint> BezierCurveFromArc(XPoint point1, XPoint point2, XSize size, double rotationAngle, bool isLargeArc, bool clockwise, PathStart pathStart);
}
internal class PdfSharpCore.Drawing.GraphicsStateStack : object {
    private InternalGraphicsState _current;
    private Stack`1<InternalGraphicsState> _stack;
    public int Count { get; }
    public InternalGraphicsState Current { get; }
    public GraphicsStateStack(XGraphics gfx);
    public int get_Count();
    public void Push(InternalGraphicsState state);
    public int Restore(InternalGraphicsState state);
    public InternalGraphicsState get_Current();
}
internal interface PdfSharpCore.Drawing.IImageImporter {
    public abstract virtual ImportedImage ImportImage(StreamReaderHelper stream, PdfDocument document);
    public abstract virtual ImageData PrepareImage(ImagePrivateData data);
}
internal abstract class PdfSharpCore.Drawing.ImageData : object {
}
internal class PdfSharpCore.Drawing.ImageInformation : object {
    internal ImageFormats ImageFormat;
    internal UInt32 Width;
    internal UInt32 Height;
    internal decimal HorizontalDPI;
    internal decimal VerticalDPI;
    internal decimal HorizontalDPM;
    internal decimal VerticalDPM;
    internal decimal HorizontalAspectRatio;
    internal decimal VerticalAspectRatio;
    internal UInt32 ColorsUsed;
}
internal abstract class PdfSharpCore.Drawing.ImagePrivateData : object {
    private ImportedImage _image;
    public ImportedImage Image { get; internal set; }
    public ImportedImage get_Image();
    internal void set_Image(ImportedImage value);
}
internal abstract class PdfSharpCore.Drawing.ImportedImage : object {
    private ImageInformation _information;
    private ImageData _imageData;
    private IImageImporter _importer;
    internal ImagePrivateData Data;
    internal PdfDocument _document;
    public ImageInformation Information { get; private set; }
    public bool HasImageData { get; }
    public ImageData ImageData { get; private set; }
    protected ImportedImage(IImageImporter importer, ImagePrivateData data, PdfDocument document);
    public ImageInformation get_Information();
    private void set_Information(ImageInformation value);
    public bool get_HasImageData();
    public ImageData get_ImageData();
    private void set_ImageData(ImageData value);
    internal virtual ImageData PrepareImageData();
}
internal class PdfSharpCore.Drawing.Internal.ImageDataBitmap : ImageData {
    private Byte[] _data;
    private int _length;
    private Byte[] _dataFax;
    private int _lengthFax;
    private Byte[] _alphaMask;
    private int _alphaMaskLength;
    private Byte[] _bitmapMask;
    private int _bitmapMaskLength;
    private Byte[] _paletteData;
    private int _paletteDataLength;
    public bool SegmentedColorMask;
    public int IsBitonal;
    public int K;
    public bool IsGray;
    internal PdfDocument _document;
    public Byte[] Data { get; internal set; }
    public int Length { get; internal set; }
    public Byte[] DataFax { get; internal set; }
    public int LengthFax { get; internal set; }
    public Byte[] AlphaMask { get; internal set; }
    public int AlphaMaskLength { get; internal set; }
    public Byte[] BitmapMask { get; internal set; }
    public int BitmapMaskLength { get; internal set; }
    public Byte[] PaletteData { get; public set; }
    public int PaletteDataLength { get; public set; }
    internal ImageDataBitmap(PdfDocument document);
    public Byte[] get_Data();
    internal void set_Data(Byte[] value);
    public int get_Length();
    internal void set_Length(int value);
    public Byte[] get_DataFax();
    internal void set_DataFax(Byte[] value);
    public int get_LengthFax();
    internal void set_LengthFax(int value);
    public Byte[] get_AlphaMask();
    internal void set_AlphaMask(Byte[] value);
    public int get_AlphaMaskLength();
    internal void set_AlphaMaskLength(int value);
    public Byte[] get_BitmapMask();
    internal void set_BitmapMask(Byte[] value);
    public int get_BitmapMaskLength();
    internal void set_BitmapMaskLength(int value);
    public Byte[] get_PaletteData();
    public void set_PaletteData(Byte[] value);
    public int get_PaletteDataLength();
    public void set_PaletteDataLength(int value);
}
internal class PdfSharpCore.Drawing.Internal.ImageDataDct : ImageData {
    private Byte[] _data;
    private int _length;
    public Byte[] Data { get; internal set; }
    public int Length { get; internal set; }
    public Byte[] get_Data();
    internal void set_Data(Byte[] value);
    public int get_Length();
    internal void set_Length(int value);
}
internal class PdfSharpCore.Drawing.Internal.ImageImporter : object {
    private List`1<IImageImporter> _importers;
    public static ImageImporter GetImageImporter();
    public ImportedImage ImportImage(Stream stream, PdfDocument document);
}
internal class PdfSharpCore.Drawing.Internal.ImageImporterBmp : ImageImporterRoot {
    public sealed virtual ImportedImage ImportImage(StreamReaderHelper stream, PdfDocument document);
    private bool TestBitmapFileHeader(StreamReaderHelper stream, Int32& offset);
    private bool TestBitmapInfoHeader(StreamReaderHelper stream, ImportedImage ii, int offset);
    public sealed virtual ImageData PrepareImage(ImagePrivateData data);
}
internal class PdfSharpCore.Drawing.Internal.ImageImporterJpeg : ImageImporterRoot {
    public sealed virtual ImportedImage ImportImage(StreamReaderHelper stream, PdfDocument document);
    private bool TestFileHeader(StreamReaderHelper stream);
    private bool TestJfifHeader(StreamReaderHelper stream, ImportedImage ii);
    private bool TestColorFormatHeader(StreamReaderHelper stream, ImportedImage ii);
    private bool TestInfoHeader(StreamReaderHelper stream, ImportedImage ii);
    private bool MoveToNextHeader(StreamReaderHelper stream);
    public sealed virtual ImageData PrepareImage(ImagePrivateData data);
}
internal abstract class PdfSharpCore.Drawing.Internal.ImageImporterRoot : object {
}
internal class PdfSharpCore.Drawing.Internal.ImagePrivateDataBitmap : ImagePrivateData {
    private Byte[] _data;
    private int _length;
    internal bool FlippedImage;
    internal int Offset;
    internal int ColorPaletteOffset;
    public Byte[] Data { get; }
    public int Length { get; }
    public ImagePrivateDataBitmap(Byte[] data, int length);
    public Byte[] get_Data();
    public int get_Length();
    internal void CopyBitmap(ImageDataBitmap dest);
    private void CopyTrueColorMemoryBitmap(int components, int bits, bool hasAlpha, ImageDataBitmap dest);
    private void CopyIndexedMemoryBitmap(int bits, ImageDataBitmap dest);
}
internal class PdfSharpCore.Drawing.Internal.ImagePrivateDataDct : ImagePrivateData {
    private Byte[] _data;
    private int _length;
    public Byte[] Data { get; }
    public int Length { get; }
    public ImagePrivateDataDct(Byte[] data, int length);
    public Byte[] get_Data();
    public int get_Length();
}
internal class PdfSharpCore.Drawing.Internal.ImportedImageBitmap : ImportedImage {
    public ImportedImageBitmap(IImageImporter importer, ImagePrivateDataBitmap data, PdfDocument document);
    internal virtual ImageData PrepareImageData();
}
internal class PdfSharpCore.Drawing.Internal.ImportedImageJpeg : ImportedImage {
    public ImportedImageJpeg(IImageImporter importer, ImagePrivateDataDct data, PdfDocument document);
    internal virtual ImageData PrepareImageData();
}
[FlagsAttribute]
internal enum PdfSharpCore.Drawing.InternalGraphicsMode : Enum {
    public int value__;
    public static InternalGraphicsMode DrawingGdiGraphics;
    public static InternalGraphicsMode DrawingPdfContent;
    public static InternalGraphicsMode DrawingBitmap;
}
internal class PdfSharpCore.Drawing.InternalGraphicsState : object {
    private XMatrix _transform;
    public bool Invalid;
    private XGraphics _gfx;
    internal XGraphicsState State;
    public XMatrix Transform { get; public set; }
    public InternalGraphicsState(XGraphics gfx);
    public InternalGraphicsState(XGraphics gfx, XGraphicsState state);
    public InternalGraphicsState(XGraphics gfx, XGraphicsContainer container);
    public XMatrix get_Transform();
    public void set_Transform(XMatrix value);
    public void Pushed();
    public void Popped();
}
public interface PdfSharpCore.Drawing.IXGraphicsRenderer {
    public abstract virtual void Close();
    public abstract virtual void DrawLine(XPen pen, double x1, double y1, double x2, double y2);
    public abstract virtual void DrawLines(XPen pen, XPoint[] points);
    public abstract virtual void DrawBezier(XPen pen, double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4);
    public abstract virtual void DrawBeziers(XPen pen, XPoint[] points);
    public abstract virtual void DrawCurve(XPen pen, XPoint[] points, double tension);
    public abstract virtual void DrawArc(XPen pen, double x, double y, double width, double height, double startAngle, double sweepAngle);
    public abstract virtual void DrawRectangle(XPen pen, XBrush brush, double x, double y, double width, double height);
    public abstract virtual void DrawRectangles(XPen pen, XBrush brush, XRect[] rects);
    public abstract virtual void DrawRoundedRectangle(XPen pen, XBrush brush, double x, double y, double width, double height, double ellipseWidth, double ellipseHeight);
    public abstract virtual void DrawEllipse(XPen pen, XBrush brush, double x, double y, double width, double height);
    public abstract virtual void DrawPolygon(XPen pen, XBrush brush, XPoint[] points, XFillMode fillmode);
    public abstract virtual void DrawPie(XPen pen, XBrush brush, double x, double y, double width, double height, double startAngle, double sweepAngle);
    public abstract virtual void DrawClosedCurve(XPen pen, XBrush brush, XPoint[] points, double tension, XFillMode fillmode);
    public abstract virtual void DrawPath(XPen pen, XBrush brush, XGraphicsPath path);
    public abstract virtual void DrawString(string s, XFont font, XBrush brush, XRect layoutRectangle, XStringFormat format);
    public abstract virtual void DrawImage(XImage image, double x, double y, double width, double height);
    public abstract virtual void DrawImage(XImage image, XRect destRect, XRect srcRect, XGraphicsUnit srcUnit);
    public abstract virtual void Save(XGraphicsState state);
    public abstract virtual void Restore(XGraphicsState state);
    public abstract virtual void BeginContainer(XGraphicsContainer container, XRect dstrect, XRect srcrect, XGraphicsUnit unit);
    public abstract virtual void EndContainer(XGraphicsContainer container);
    public abstract virtual void AddTransform(XMatrix transform, XMatrixOrder matrixOrder);
    public abstract virtual void SetClip(XGraphicsPath path, XCombineMode combineMode);
    public abstract virtual void ResetClip();
    public abstract virtual void WriteComment(string comment);
}
internal class PdfSharpCore.Drawing.Layout.Block : object {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private BlockType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private XPoint <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private XParagraphAlignment <Alignment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Stop>k__BackingField;
    [CompilerGeneratedAttribute]
private FormatterEnvironment <Environment>k__BackingField;
    [CompilerGeneratedAttribute]
private double <LineIndent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipParagraphAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NextBlockBelongsToMe>k__BackingField;
    public string Text { get; public set; }
    public BlockType Type { get; }
    public double Width { get; public set; }
    public XPoint Location { get; public set; }
    public XParagraphAlignment Alignment { get; public set; }
    public bool Stop { get; public set; }
    public FormatterEnvironment Environment { get; public set; }
    public double LineIndent { get; public set; }
    public bool SkipParagraphAlignment { get; public set; }
    public bool NextBlockBelongsToMe { get; public set; }
    public Block(string text, BlockType type, double width);
    public Block(BlockType type);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    [CompilerGeneratedAttribute]
public BlockType get_Type();
    [CompilerGeneratedAttribute]
public double get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(double value);
    [CompilerGeneratedAttribute]
public XPoint get_Location();
    [CompilerGeneratedAttribute]
public void set_Location(XPoint value);
    [CompilerGeneratedAttribute]
public XParagraphAlignment get_Alignment();
    [CompilerGeneratedAttribute]
public void set_Alignment(XParagraphAlignment value);
    [CompilerGeneratedAttribute]
public bool get_Stop();
    [CompilerGeneratedAttribute]
public void set_Stop(bool value);
    [CompilerGeneratedAttribute]
public FormatterEnvironment get_Environment();
    [CompilerGeneratedAttribute]
public void set_Environment(FormatterEnvironment value);
    [CompilerGeneratedAttribute]
public double get_LineIndent();
    [CompilerGeneratedAttribute]
public void set_LineIndent(double value);
    [CompilerGeneratedAttribute]
public bool get_SkipParagraphAlignment();
    [CompilerGeneratedAttribute]
public void set_SkipParagraphAlignment(bool value);
    [CompilerGeneratedAttribute]
public bool get_NextBlockBelongsToMe();
    [CompilerGeneratedAttribute]
public void set_NextBlockBelongsToMe(bool value);
}
internal enum PdfSharpCore.Drawing.Layout.enums.BlockType : Enum {
    public int value__;
    public static BlockType Text;
    public static BlockType Space;
    public static BlockType Hyphen;
    public static BlockType LineBreak;
}
public enum PdfSharpCore.Drawing.Layout.enums.XVerticalAlignment : Enum {
    public int value__;
    public static XVerticalAlignment Top;
    public static XVerticalAlignment Middle;
    public static XVerticalAlignment Bottom;
}
internal class PdfSharpCore.Drawing.Layout.FormatterEnvironment : object {
    [CompilerGeneratedAttribute]
private XFont <Font>k__BackingField;
    [CompilerGeneratedAttribute]
private XBrush <Brush>k__BackingField;
    [CompilerGeneratedAttribute]
private double <LineSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private double <CyAscent>k__BackingField;
    [CompilerGeneratedAttribute]
private double <CyDescent>k__BackingField;
    [CompilerGeneratedAttribute]
private double <SpaceWidth>k__BackingField;
    public XFont Font { get; public set; }
    public XBrush Brush { get; public set; }
    public double LineSpace { get; public set; }
    public double CyAscent { get; public set; }
    public double CyDescent { get; public set; }
    public double SpaceWidth { get; public set; }
    [CompilerGeneratedAttribute]
public XFont get_Font();
    [CompilerGeneratedAttribute]
public void set_Font(XFont value);
    [CompilerGeneratedAttribute]
public XBrush get_Brush();
    [CompilerGeneratedAttribute]
public void set_Brush(XBrush value);
    [CompilerGeneratedAttribute]
public double get_LineSpace();
    [CompilerGeneratedAttribute]
public void set_LineSpace(double value);
    [CompilerGeneratedAttribute]
public double get_CyAscent();
    [CompilerGeneratedAttribute]
public void set_CyAscent(double value);
    [CompilerGeneratedAttribute]
public double get_CyDescent();
    [CompilerGeneratedAttribute]
public void set_CyDescent(double value);
    [CompilerGeneratedAttribute]
public double get_SpaceWidth();
    [CompilerGeneratedAttribute]
public void set_SpaceWidth(double value);
}
public class PdfSharpCore.Drawing.Layout.TextFormatAlignment : object {
    [CompilerGeneratedAttribute]
private XParagraphAlignment <Horizontal>k__BackingField;
    [CompilerGeneratedAttribute]
private XVerticalAlignment <Vertical>k__BackingField;
    public XParagraphAlignment Horizontal { get; public set; }
    public XVerticalAlignment Vertical { get; public set; }
    [CompilerGeneratedAttribute]
public XParagraphAlignment get_Horizontal();
    [CompilerGeneratedAttribute]
public void set_Horizontal(XParagraphAlignment value);
    [CompilerGeneratedAttribute]
public XVerticalAlignment get_Vertical();
    [CompilerGeneratedAttribute]
public void set_Vertical(XVerticalAlignment value);
}
public class PdfSharpCore.Drawing.Layout.TextSegment : object {
    [CompilerGeneratedAttribute]
private XFont <Font>k__BackingField;
    [CompilerGeneratedAttribute]
private XBrush <Brush>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private double <LineIndent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipParagraphAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private double <LineSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private double <CyAscent>k__BackingField;
    [CompilerGeneratedAttribute]
private double <CyDescent>k__BackingField;
    [CompilerGeneratedAttribute]
private double <SpaceWidth>k__BackingField;
    public XFont Font { get; public set; }
    public XBrush Brush { get; public set; }
    public string Text { get; public set; }
    public double LineIndent { get; public set; }
    public bool SkipParagraphAlignment { get; public set; }
    public double LineSpace { get; public set; }
    public double CyAscent { get; public set; }
    public double CyDescent { get; public set; }
    public double SpaceWidth { get; public set; }
    [CompilerGeneratedAttribute]
public XFont get_Font();
    [CompilerGeneratedAttribute]
public void set_Font(XFont value);
    [CompilerGeneratedAttribute]
public XBrush get_Brush();
    [CompilerGeneratedAttribute]
public void set_Brush(XBrush value);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    [CompilerGeneratedAttribute]
public double get_LineIndent();
    [CompilerGeneratedAttribute]
public void set_LineIndent(double value);
    [CompilerGeneratedAttribute]
public bool get_SkipParagraphAlignment();
    [CompilerGeneratedAttribute]
public void set_SkipParagraphAlignment(bool value);
    [CompilerGeneratedAttribute]
public double get_LineSpace();
    [CompilerGeneratedAttribute]
public void set_LineSpace(double value);
    [CompilerGeneratedAttribute]
public double get_CyAscent();
    [CompilerGeneratedAttribute]
public void set_CyAscent(double value);
    [CompilerGeneratedAttribute]
public double get_CyDescent();
    [CompilerGeneratedAttribute]
public void set_CyDescent(double value);
    [CompilerGeneratedAttribute]
public double get_SpaceWidth();
    [CompilerGeneratedAttribute]
public void set_SpaceWidth(double value);
}
public enum PdfSharpCore.Drawing.Layout.XParagraphAlignment : Enum {
    public int value__;
    public static XParagraphAlignment Default;
    public static XParagraphAlignment Left;
    public static XParagraphAlignment Center;
    public static XParagraphAlignment Right;
    public static XParagraphAlignment Justify;
}
public class PdfSharpCore.Drawing.Layout.XTextFormatter : object {
    private XGraphics _gfx;
    private string _text;
    private XFont _font;
    private double _lineSpace;
    private double _cyAscent;
    private double _cyDescent;
    private double _spaceWidth;
    private double _lineHeight;
    private XRect _textLayout;
    private XRect _layoutRectangle;
    [CompilerGeneratedAttribute]
private bool <AllowVerticalOverflow>k__BackingField;
    [CompilerGeneratedAttribute]
private XParagraphAlignment <Alignment>k__BackingField;
    [CompilerGeneratedAttribute]
private XVerticalAlignment <VerticalAlignment>k__BackingField;
    private List`1<Block> _blocks;
    public string Text { get; public set; }
    public XFont Font { get; public set; }
    public XRect LayoutRectangle { get; public set; }
    public bool AllowVerticalOverflow { get; public set; }
    public XParagraphAlignment Alignment { get; public set; }
    public XVerticalAlignment VerticalAlignment { get; public set; }
    public XTextFormatter(XGraphics gfx);
    public string get_Text();
    public void set_Text(string value);
    public XFont get_Font();
    public void set_Font(XFont value);
    public XRect get_LayoutRectangle();
    public void set_LayoutRectangle(XRect value);
    [CompilerGeneratedAttribute]
public bool get_AllowVerticalOverflow();
    [CompilerGeneratedAttribute]
public void set_AllowVerticalOverflow(bool value);
    [CompilerGeneratedAttribute]
public XParagraphAlignment get_Alignment();
    [CompilerGeneratedAttribute]
public void set_Alignment(XParagraphAlignment value);
    [CompilerGeneratedAttribute]
public XVerticalAlignment get_VerticalAlignment();
    [CompilerGeneratedAttribute]
public void set_VerticalAlignment(XVerticalAlignment value);
    public void SetAlignment(TextFormatAlignment alignments);
    public void DrawString(string text, XFont font, XBrush brush, XRect layoutRectangle, Nullable`1<XUnit> lineHeight);
    public void DrawString(string text, XFont font, XBrush brush, XRect layoutRectangle, XStringFormat format, Nullable`1<XUnit> lineHeight);
    private void CreateBlocks();
    private void CreateLayout();
    private void HorizontalAlignLine(int firstIndex, int lastIndex, double layoutWidth);
    [CompilerGeneratedAttribute]
private double <CreateLayout>b__36_1(Block b);
}
public class PdfSharpCore.Drawing.Layout.XTextSegmentFormatter : object {
    private XGraphics _gfx;
    [CompilerGeneratedAttribute]
private XParagraphAlignment <Alignment>k__BackingField;
    public XParagraphAlignment Alignment { get; public set; }
    public XTextSegmentFormatter(XGraphics gfx);
    [CompilerGeneratedAttribute]
public XParagraphAlignment get_Alignment();
    [CompilerGeneratedAttribute]
public void set_Alignment(XParagraphAlignment value);
    public void DrawString(string text, XFont font, XBrush brush, XRect layoutRectangle);
    public void DrawString(string text, XFont font, XBrush brush, XRect layoutRectangle, XStringFormat format);
    public void DrawString(IEnumerable`1<TextSegment> textSegments, XRect layoutRectangle);
    public void DrawString(IEnumerable`1<TextSegment> textSegments, XRect layoutRectangle, XStringFormat format);
    public XSize CalculateTextSize(string text, XFont font, XBrush brush, double width);
    public XSize CalculateTextSize(string text, XFont font, XBrush brush, double width, XStringFormat format);
    public XSize CalculateTextSize(IEnumerable`1<TextSegment> textSegments, double width);
    public XSize CalculateTextSize(IEnumerable`1<TextSegment> textSegments, double width, XStringFormat format);
    private void ProcessTextSegments(IEnumerable`1<TextSegment> textSegments, XRect layoutRectangle, XStringFormat format, Action`3<Block, double, double> applyBlock, bool applyBlockIfLineBreak);
    private List`1<Block> CreateBlocks(IEnumerable`1<TextSegment> textSegments);
    private void CreateLayout(List`1<List`1<Block>> blockUnits, XRect layoutRectangle);
    private double RemovedLeadingSpace(Block block, double width);
    private void AlignLine(IList`1<Block> blockUnit, int firstIndex, int lastIndex, double layoutWidth);
    private void SetFormatterEnvironment(Block block, TextSegment textSegment);
    private void SetFontSpacings(TextSegment segment);
    [CompilerGeneratedAttribute]
private void <DrawString>b__9_0(Block block, double dx, double dy);
}
internal enum PdfSharpCore.Drawing.PathStart : Enum {
    public int value__;
    public static PathStart MoveTo1st;
    public static PathStart LineTo1st;
    public static PathStart Ignore1st;
}
[FlagsAttribute]
internal enum PdfSharpCore.Drawing.Pdf.DirtyFlags : Enum {
    public int value__;
    public static DirtyFlags Ctm;
    public static DirtyFlags ClipPath;
    public static DirtyFlags LineWidth;
    public static DirtyFlags LineJoin;
    public static DirtyFlags MiterLimit;
    public static DirtyFlags StrokeFill;
}
internal class PdfSharpCore.Drawing.Pdf.PdfGraphicsState : object {
    private XGraphicsPdfRenderer _renderer;
    internal int Level;
    internal InternalGraphicsState InternalState;
    private double _realizedLineWith;
    private int _realizedLineCap;
    private int _realizedLineJoin;
    private double _realizedMiterLimit;
    private XDashStyle _realizedDashStyle;
    private string _realizedDashPattern;
    private XColor _realizedStrokeColor;
    private bool _realizedStrokeOverPrint;
    private XColor _realizedFillColor;
    private bool _realizedNonStrokeOverPrint;
    internal PdfFont _realizedFont;
    private string _realizedFontName;
    private double _realizedFontSize;
    private int _realizedRenderingMode;
    private double _realizedCharSpace;
    public XPoint RealizedTextPosition;
    public bool ItalicSimulationOn;
    public XMatrix RealizedCtm;
    public XMatrix UnrealizedCtm;
    public XMatrix EffectiveCtm;
    public XMatrix InverseEffectiveCtm;
    public XMatrix WorldTransform;
    public PdfGraphicsState(XGraphicsPdfRenderer renderer);
    public PdfGraphicsState Clone();
    private sealed virtual override object System.ICloneable.Clone();
    public void PushState();
    public void PopState();
    public void RealizePen(XPen pen, PdfColorMode colorMode);
    public void RealizeBrush(XBrush brush, PdfColorMode colorMode, int renderingMode, double fontEmSize, bool isForPen);
    private void RealizeFillColor(XColor color, bool overPrint, PdfColorMode colorMode);
    internal void RealizeNonStrokeTransparency(double transparency, PdfColorMode colorMode);
    public void RealizeFont(XFont font, XBrush brush, int renderingMode);
    public void AddTransform(XMatrix value, XMatrixOrder matrixOrder);
    public void RealizeCtm();
    public void SetAndRealizeClipRect(XRect clipRect);
    public void SetAndRealizeClipPath(XGraphicsPath clipPath);
    private void RealizeClipPath(XGraphicsPath clipPath);
}
internal enum PdfSharpCore.Drawing.Pdf.StreamMode : Enum {
    public int value__;
    public static StreamMode Graphic;
    public static StreamMode Text;
}
internal class PdfSharpCore.Drawing.Pdf.XGraphicsPdfRenderer : object {
    private int _clipLevel;
    private StreamMode _streamMode;
    internal PdfPage _page;
    internal XForm _form;
    internal PdfColorMode _colorMode;
    private XGraphicsPdfPageOptions _options;
    private XGraphics _gfx;
    private StringBuilder _content;
    private static int GraphicsStackLevelInitial;
    private static int GraphicsStackLevelPageSpace;
    private static int GraphicsStackLevelWorldSpace;
    private PdfGraphicsState _gfxState;
    private Stack`1<PdfGraphicsState> _gfxStateStack;
    public double PageHeightPt;
    public XMatrix DefaultViewMatrix;
    public XGraphicsPdfPageOptions PageOptions { get; }
    public XMatrix Transform { get; }
    internal PdfDocument Owner { get; }
    internal XGraphics Gfx { get; }
    internal PdfResources Resources { get; }
    internal XSize Size { get; }
    public XGraphicsPdfRenderer(PdfPage page, XGraphics gfx, XGraphicsPdfPageOptions options);
    public XGraphicsPdfRenderer(XForm form, XGraphics gfx);
    private string GetContent();
    public XGraphicsPdfPageOptions get_PageOptions();
    public sealed virtual void Close();
    public sealed virtual void DrawLine(XPen pen, double x1, double y1, double x2, double y2);
    public sealed virtual void DrawLines(XPen pen, XPoint[] points);
    public sealed virtual void DrawBezier(XPen pen, double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4);
    public sealed virtual void DrawBeziers(XPen pen, XPoint[] points);
    public sealed virtual void DrawCurve(XPen pen, XPoint[] points, double tension);
    public sealed virtual void DrawArc(XPen pen, double x, double y, double width, double height, double startAngle, double sweepAngle);
    public sealed virtual void DrawRectangle(XPen pen, XBrush brush, double x, double y, double width, double height);
    public sealed virtual void DrawRectangles(XPen pen, XBrush brush, XRect[] rects);
    public sealed virtual void DrawRoundedRectangle(XPen pen, XBrush brush, double x, double y, double width, double height, double ellipseWidth, double ellipseHeight);
    public sealed virtual void DrawEllipse(XPen pen, XBrush brush, double x, double y, double width, double height);
    public sealed virtual void DrawPolygon(XPen pen, XBrush brush, XPoint[] points, XFillMode fillmode);
    public sealed virtual void DrawPie(XPen pen, XBrush brush, double x, double y, double width, double height, double startAngle, double sweepAngle);
    public sealed virtual void DrawClosedCurve(XPen pen, XBrush brush, XPoint[] points, double tension, XFillMode fillmode);
    public sealed virtual void DrawPath(XPen pen, XBrush brush, XGraphicsPath path);
    public sealed virtual void DrawString(string s, XFont font, XBrush brush, XRect rect, XStringFormat format);
    public sealed virtual void DrawImage(XImage image, double x, double y, double width, double height);
    public sealed virtual void DrawImage(XImage image, XRect destRect, XRect srcRect, XGraphicsUnit srcUnit);
    public sealed virtual void Save(XGraphicsState state);
    public sealed virtual void Restore(XGraphicsState state);
    public sealed virtual void BeginContainer(XGraphicsContainer container, XRect dstrect, XRect srcrect, XGraphicsUnit unit);
    public sealed virtual void EndContainer(XGraphicsContainer container);
    public XMatrix get_Transform();
    public sealed virtual void AddTransform(XMatrix value, XMatrixOrder matrixOrder);
    public sealed virtual void SetClip(XGraphicsPath path, XCombineMode combineMode);
    public sealed virtual void ResetClip();
    public sealed virtual void WriteComment(string comment);
    private void AppendPartialArc(double x, double y, double width, double height, double startAngle, double sweepAngle, PathStart pathStart, XMatrix matrix);
    private int Quadrant(double φ, bool start, bool clockwise);
    private void AppendPartialArcQuadrant(double x, double y, double width, double height, double α, double β, PathStart pathStart, XMatrix matrix);
    private void AppendCurveSegment(XPoint pt0, XPoint pt1, XPoint pt2, XPoint pt3, double tension3);
    internal void AppendPath(CoreGraphicsPath path);
    private void AppendPath(XPoint[] points, Byte[] types);
    internal void Append(string value);
    internal void AppendFormatArgs(string format, Object[] args);
    internal void AppendFormatString(string format, string s);
    internal void AppendFormatFont(string format, string s, double d);
    internal void AppendFormatInt(string format, int n);
    internal void AppendFormatDouble(string format, double d);
    internal void AppendFormatPoint(string format, double x, double y);
    internal void AppendFormatRect(string format, double x, double y, double width, double height);
    internal void AppendFormat3Points(string format, double x1, double y1, double x2, double y2, double x3, double y3);
    internal void AppendFormat(string format, XPoint point);
    internal void AppendFormat(string format, double x, double y, string s);
    internal void AppendFormatImage(string format, double x, double y, double width, double height, string name);
    private void AppendStrokeFill(XPen pen, XBrush brush, XFillMode fillMode, bool closePath);
    private void BeginPage();
    private void EndPage();
    internal void BeginGraphicMode();
    internal void BeginTextMode();
    private void Realize(XPen pen, XBrush brush);
    private void Realize(XPen pen);
    private void Realize(XBrush brush);
    private void Realize(XFont font, XBrush brush, int renderingMode);
    private void AdjustTdOffset(XPoint& pos, double dy, bool adjustSkew);
    private string Realize(XImage image);
    private void RealizeTransform();
    internal XPoint WorldToView(XPoint point);
    internal PdfDocument get_Owner();
    internal XGraphics get_Gfx();
    internal PdfResources get_Resources();
    internal XSize get_Size();
    internal string GetFontName(XFont font, PdfFont& pdfFont);
    internal string GetImageName(XImage image);
    internal string GetFormName(XForm form);
    private void SaveState();
    private void RestoreState();
    private PdfGraphicsState RestoreState(InternalGraphicsState state);
}
internal class PdfSharpCore.Drawing.StreamReaderHelper : object {
    private Stream _stream;
    private int _currentOffset;
    private Byte[] _data;
    private int _length;
    public Stream OriginalStream { get; }
    internal int CurrentOffset { get; internal set; }
    public Byte[] Data { get; }
    public int Length { get; }
    internal StreamReaderHelper(Stream stream);
    internal byte GetByte(int offset);
    internal ushort GetWord(int offset, bool bigEndian);
    internal UInt32 GetDWord(int offset, bool bigEndian);
    private static void CopyStream(Stream input, Stream output);
    public void Reset();
    public Stream get_OriginalStream();
    internal int get_CurrentOffset();
    internal void set_CurrentOffset(int value);
    public Byte[] get_Data();
    public int get_Length();
}
public class PdfSharpCore.Drawing.XBaseGradientBrush : XBrush {
    internal XColor _color1;
    internal XColor _color2;
    internal XMatrix _matrix;
    public XMatrix Transform { get; public set; }
    protected XBaseGradientBrush(XColor color1, XColor color2);
    public XMatrix get_Transform();
    public void set_Transform(XMatrix value);
    public void TranslateTransform(double dx, double dy);
    public void TranslateTransform(double dx, double dy, XMatrixOrder order);
    public void ScaleTransform(double sx, double sy);
    public void ScaleTransform(double sx, double sy, XMatrixOrder order);
    public void RotateTransform(double angle);
    public void RotateTransform(double angle, XMatrixOrder order);
    public void MultiplyTransform(XMatrix matrix);
    public void MultiplyTransform(XMatrix matrix, XMatrixOrder order);
    public void ResetTransform();
}
public class PdfSharpCore.Drawing.XBitmapDecoder : object {
    public static XBitmapDecoder GetPngDecoder();
}
public abstract class PdfSharpCore.Drawing.XBitmapEncoder : object {
    private XBitmapSource _source;
    public XBitmapSource Source { get; public set; }
    public static XBitmapEncoder GetPngEncoder();
    public XBitmapSource get_Source();
    public void set_Source(XBitmapSource value);
    public abstract virtual void Save(Stream stream);
}
public class PdfSharpCore.Drawing.XBitmapImage : XBitmapSource {
    internal XBitmapImage(int width, int height);
    public static XBitmapSource CreateBitmap(int width, int height);
}
public abstract class PdfSharpCore.Drawing.XBitmapSource : XImage {
    public int PixelWidth { get; }
    public int PixelHeight { get; }
    public virtual int get_PixelWidth();
    public virtual int get_PixelHeight();
}
public abstract class PdfSharpCore.Drawing.XBrush : object {
}
public static class PdfSharpCore.Drawing.XBrushes : object {
    public static XSolidBrush AliceBlue { get; }
    public static XSolidBrush AntiqueWhite { get; }
    public static XSolidBrush Aqua { get; }
    public static XSolidBrush Aquamarine { get; }
    public static XSolidBrush Azure { get; }
    public static XSolidBrush Beige { get; }
    public static XSolidBrush Bisque { get; }
    public static XSolidBrush Black { get; }
    public static XSolidBrush BlanchedAlmond { get; }
    public static XSolidBrush Blue { get; }
    public static XSolidBrush BlueViolet { get; }
    public static XSolidBrush Brown { get; }
    public static XSolidBrush BurlyWood { get; }
    public static XSolidBrush CadetBlue { get; }
    public static XSolidBrush Chartreuse { get; }
    public static XSolidBrush Chocolate { get; }
    public static XSolidBrush Coral { get; }
    public static XSolidBrush CornflowerBlue { get; }
    public static XSolidBrush Cornsilk { get; }
    public static XSolidBrush Crimson { get; }
    public static XSolidBrush Cyan { get; }
    public static XSolidBrush DarkBlue { get; }
    public static XSolidBrush DarkCyan { get; }
    public static XSolidBrush DarkGoldenrod { get; }
    public static XSolidBrush DarkGray { get; }
    public static XSolidBrush DarkGreen { get; }
    public static XSolidBrush DarkKhaki { get; }
    public static XSolidBrush DarkMagenta { get; }
    public static XSolidBrush DarkOliveGreen { get; }
    public static XSolidBrush DarkOrange { get; }
    public static XSolidBrush DarkOrchid { get; }
    public static XSolidBrush DarkRed { get; }
    public static XSolidBrush DarkSalmon { get; }
    public static XSolidBrush DarkSeaGreen { get; }
    public static XSolidBrush DarkSlateBlue { get; }
    public static XSolidBrush DarkSlateGray { get; }
    public static XSolidBrush DarkTurquoise { get; }
    public static XSolidBrush DarkViolet { get; }
    public static XSolidBrush DeepPink { get; }
    public static XSolidBrush DeepSkyBlue { get; }
    public static XSolidBrush DimGray { get; }
    public static XSolidBrush DodgerBlue { get; }
    public static XSolidBrush Firebrick { get; }
    public static XSolidBrush FloralWhite { get; }
    public static XSolidBrush ForestGreen { get; }
    public static XSolidBrush Fuchsia { get; }
    public static XSolidBrush Gainsboro { get; }
    public static XSolidBrush GhostWhite { get; }
    public static XSolidBrush Gold { get; }
    public static XSolidBrush Goldenrod { get; }
    public static XSolidBrush Gray { get; }
    public static XSolidBrush Green { get; }
    public static XSolidBrush GreenYellow { get; }
    public static XSolidBrush Honeydew { get; }
    public static XSolidBrush HotPink { get; }
    public static XSolidBrush IndianRed { get; }
    public static XSolidBrush Indigo { get; }
    public static XSolidBrush Ivory { get; }
    public static XSolidBrush Khaki { get; }
    public static XSolidBrush Lavender { get; }
    public static XSolidBrush LavenderBlush { get; }
    public static XSolidBrush LawnGreen { get; }
    public static XSolidBrush LemonChiffon { get; }
    public static XSolidBrush LightBlue { get; }
    public static XSolidBrush LightCoral { get; }
    public static XSolidBrush LightCyan { get; }
    public static XSolidBrush LightGoldenrodYellow { get; }
    public static XSolidBrush LightGray { get; }
    public static XSolidBrush LightGreen { get; }
    public static XSolidBrush LightPink { get; }
    public static XSolidBrush LightSalmon { get; }
    public static XSolidBrush LightSeaGreen { get; }
    public static XSolidBrush LightSkyBlue { get; }
    public static XSolidBrush LightSlateGray { get; }
    public static XSolidBrush LightSteelBlue { get; }
    public static XSolidBrush LightYellow { get; }
    public static XSolidBrush Lime { get; }
    public static XSolidBrush LimeGreen { get; }
    public static XSolidBrush Linen { get; }
    public static XSolidBrush Magenta { get; }
    public static XSolidBrush Maroon { get; }
    public static XSolidBrush MediumAquamarine { get; }
    public static XSolidBrush MediumBlue { get; }
    public static XSolidBrush MediumOrchid { get; }
    public static XSolidBrush MediumPurple { get; }
    public static XSolidBrush MediumSeaGreen { get; }
    public static XSolidBrush MediumSlateBlue { get; }
    public static XSolidBrush MediumSpringGreen { get; }
    public static XSolidBrush MediumTurquoise { get; }
    public static XSolidBrush MediumVioletRed { get; }
    public static XSolidBrush MidnightBlue { get; }
    public static XSolidBrush MintCream { get; }
    public static XSolidBrush MistyRose { get; }
    public static XSolidBrush Moccasin { get; }
    public static XSolidBrush NavajoWhite { get; }
    public static XSolidBrush Navy { get; }
    public static XSolidBrush OldLace { get; }
    public static XSolidBrush Olive { get; }
    public static XSolidBrush OliveDrab { get; }
    public static XSolidBrush Orange { get; }
    public static XSolidBrush OrangeRed { get; }
    public static XSolidBrush Orchid { get; }
    public static XSolidBrush PaleGoldenrod { get; }
    public static XSolidBrush PaleGreen { get; }
    public static XSolidBrush PaleTurquoise { get; }
    public static XSolidBrush PaleVioletRed { get; }
    public static XSolidBrush PapayaWhip { get; }
    public static XSolidBrush PeachPuff { get; }
    public static XSolidBrush Peru { get; }
    public static XSolidBrush Pink { get; }
    public static XSolidBrush Plum { get; }
    public static XSolidBrush PowderBlue { get; }
    public static XSolidBrush Purple { get; }
    public static XSolidBrush Red { get; }
    public static XSolidBrush RosyBrown { get; }
    public static XSolidBrush RoyalBlue { get; }
    public static XSolidBrush SaddleBrown { get; }
    public static XSolidBrush Salmon { get; }
    public static XSolidBrush SandyBrown { get; }
    public static XSolidBrush SeaGreen { get; }
    public static XSolidBrush SeaShell { get; }
    public static XSolidBrush Sienna { get; }
    public static XSolidBrush Silver { get; }
    public static XSolidBrush SkyBlue { get; }
    public static XSolidBrush SlateBlue { get; }
    public static XSolidBrush SlateGray { get; }
    public static XSolidBrush Snow { get; }
    public static XSolidBrush SpringGreen { get; }
    public static XSolidBrush SteelBlue { get; }
    public static XSolidBrush Tan { get; }
    public static XSolidBrush Teal { get; }
    public static XSolidBrush Thistle { get; }
    public static XSolidBrush Tomato { get; }
    public static XSolidBrush Transparent { get; }
    public static XSolidBrush Turquoise { get; }
    public static XSolidBrush Violet { get; }
    public static XSolidBrush Wheat { get; }
    public static XSolidBrush White { get; }
    public static XSolidBrush WhiteSmoke { get; }
    public static XSolidBrush Yellow { get; }
    public static XSolidBrush YellowGreen { get; }
    public static XSolidBrush get_AliceBlue();
    public static XSolidBrush get_AntiqueWhite();
    public static XSolidBrush get_Aqua();
    public static XSolidBrush get_Aquamarine();
    public static XSolidBrush get_Azure();
    public static XSolidBrush get_Beige();
    public static XSolidBrush get_Bisque();
    public static XSolidBrush get_Black();
    public static XSolidBrush get_BlanchedAlmond();
    public static XSolidBrush get_Blue();
    public static XSolidBrush get_BlueViolet();
    public static XSolidBrush get_Brown();
    public static XSolidBrush get_BurlyWood();
    public static XSolidBrush get_CadetBlue();
    public static XSolidBrush get_Chartreuse();
    public static XSolidBrush get_Chocolate();
    public static XSolidBrush get_Coral();
    public static XSolidBrush get_CornflowerBlue();
    public static XSolidBrush get_Cornsilk();
    public static XSolidBrush get_Crimson();
    public static XSolidBrush get_Cyan();
    public static XSolidBrush get_DarkBlue();
    public static XSolidBrush get_DarkCyan();
    public static XSolidBrush get_DarkGoldenrod();
    public static XSolidBrush get_DarkGray();
    public static XSolidBrush get_DarkGreen();
    public static XSolidBrush get_DarkKhaki();
    public static XSolidBrush get_DarkMagenta();
    public static XSolidBrush get_DarkOliveGreen();
    public static XSolidBrush get_DarkOrange();
    public static XSolidBrush get_DarkOrchid();
    public static XSolidBrush get_DarkRed();
    public static XSolidBrush get_DarkSalmon();
    public static XSolidBrush get_DarkSeaGreen();
    public static XSolidBrush get_DarkSlateBlue();
    public static XSolidBrush get_DarkSlateGray();
    public static XSolidBrush get_DarkTurquoise();
    public static XSolidBrush get_DarkViolet();
    public static XSolidBrush get_DeepPink();
    public static XSolidBrush get_DeepSkyBlue();
    public static XSolidBrush get_DimGray();
    public static XSolidBrush get_DodgerBlue();
    public static XSolidBrush get_Firebrick();
    public static XSolidBrush get_FloralWhite();
    public static XSolidBrush get_ForestGreen();
    public static XSolidBrush get_Fuchsia();
    public static XSolidBrush get_Gainsboro();
    public static XSolidBrush get_GhostWhite();
    public static XSolidBrush get_Gold();
    public static XSolidBrush get_Goldenrod();
    public static XSolidBrush get_Gray();
    public static XSolidBrush get_Green();
    public static XSolidBrush get_GreenYellow();
    public static XSolidBrush get_Honeydew();
    public static XSolidBrush get_HotPink();
    public static XSolidBrush get_IndianRed();
    public static XSolidBrush get_Indigo();
    public static XSolidBrush get_Ivory();
    public static XSolidBrush get_Khaki();
    public static XSolidBrush get_Lavender();
    public static XSolidBrush get_LavenderBlush();
    public static XSolidBrush get_LawnGreen();
    public static XSolidBrush get_LemonChiffon();
    public static XSolidBrush get_LightBlue();
    public static XSolidBrush get_LightCoral();
    public static XSolidBrush get_LightCyan();
    public static XSolidBrush get_LightGoldenrodYellow();
    public static XSolidBrush get_LightGray();
    public static XSolidBrush get_LightGreen();
    public static XSolidBrush get_LightPink();
    public static XSolidBrush get_LightSalmon();
    public static XSolidBrush get_LightSeaGreen();
    public static XSolidBrush get_LightSkyBlue();
    public static XSolidBrush get_LightSlateGray();
    public static XSolidBrush get_LightSteelBlue();
    public static XSolidBrush get_LightYellow();
    public static XSolidBrush get_Lime();
    public static XSolidBrush get_LimeGreen();
    public static XSolidBrush get_Linen();
    public static XSolidBrush get_Magenta();
    public static XSolidBrush get_Maroon();
    public static XSolidBrush get_MediumAquamarine();
    public static XSolidBrush get_MediumBlue();
    public static XSolidBrush get_MediumOrchid();
    public static XSolidBrush get_MediumPurple();
    public static XSolidBrush get_MediumSeaGreen();
    public static XSolidBrush get_MediumSlateBlue();
    public static XSolidBrush get_MediumSpringGreen();
    public static XSolidBrush get_MediumTurquoise();
    public static XSolidBrush get_MediumVioletRed();
    public static XSolidBrush get_MidnightBlue();
    public static XSolidBrush get_MintCream();
    public static XSolidBrush get_MistyRose();
    public static XSolidBrush get_Moccasin();
    public static XSolidBrush get_NavajoWhite();
    public static XSolidBrush get_Navy();
    public static XSolidBrush get_OldLace();
    public static XSolidBrush get_Olive();
    public static XSolidBrush get_OliveDrab();
    public static XSolidBrush get_Orange();
    public static XSolidBrush get_OrangeRed();
    public static XSolidBrush get_Orchid();
    public static XSolidBrush get_PaleGoldenrod();
    public static XSolidBrush get_PaleGreen();
    public static XSolidBrush get_PaleTurquoise();
    public static XSolidBrush get_PaleVioletRed();
    public static XSolidBrush get_PapayaWhip();
    public static XSolidBrush get_PeachPuff();
    public static XSolidBrush get_Peru();
    public static XSolidBrush get_Pink();
    public static XSolidBrush get_Plum();
    public static XSolidBrush get_PowderBlue();
    public static XSolidBrush get_Purple();
    public static XSolidBrush get_Red();
    public static XSolidBrush get_RosyBrown();
    public static XSolidBrush get_RoyalBlue();
    public static XSolidBrush get_SaddleBrown();
    public static XSolidBrush get_Salmon();
    public static XSolidBrush get_SandyBrown();
    public static XSolidBrush get_SeaGreen();
    public static XSolidBrush get_SeaShell();
    public static XSolidBrush get_Sienna();
    public static XSolidBrush get_Silver();
    public static XSolidBrush get_SkyBlue();
    public static XSolidBrush get_SlateBlue();
    public static XSolidBrush get_SlateGray();
    public static XSolidBrush get_Snow();
    public static XSolidBrush get_SpringGreen();
    public static XSolidBrush get_SteelBlue();
    public static XSolidBrush get_Tan();
    public static XSolidBrush get_Teal();
    public static XSolidBrush get_Thistle();
    public static XSolidBrush get_Tomato();
    public static XSolidBrush get_Transparent();
    public static XSolidBrush get_Turquoise();
    public static XSolidBrush get_Violet();
    public static XSolidBrush get_Wheat();
    public static XSolidBrush get_White();
    public static XSolidBrush get_WhiteSmoke();
    public static XSolidBrush get_Yellow();
    public static XSolidBrush get_YellowGreen();
}
[DebuggerDisplayAttribute("clr=(A={A}, R={R}, G={G}, B={B} C={C}, M={M}, Y={Y}, K={K})")]
public class PdfSharpCore.Drawing.XColor : ValueType {
    public static XColor Empty;
    private XColorSpace _cs;
    private float _a;
    private byte _r;
    private byte _g;
    private byte _b;
    private float _c;
    private float _m;
    private float _y;
    private float _k;
    private float _gs;
    public XColorSpace ColorSpace { get; public set; }
    public bool IsEmpty { get; }
    public bool IsKnownColor { get; }
    public double A { get; public set; }
    public byte R { get; public set; }
    public byte G { get; public set; }
    public byte B { get; public set; }
    internal UInt32 Rgb { get; }
    internal UInt32 Argb { get; }
    public double C { get; public set; }
    public double M { get; public set; }
    public double Y { get; public set; }
    public double K { get; public set; }
    public double GS { get; public set; }
    public string RgbCmykG { get; public set; }
    private XColor(UInt32 argb);
    private XColor(byte alpha, byte red, byte green, byte blue);
    private XColor(double alpha, double cyan, double magenta, double yellow, double black);
    private XColor(double cyan, double magenta, double yellow, double black);
    private XColor(double gray);
    internal XColor(XKnownColor knownColor);
    public static XColor FromArgb(int argb);
    public static XColor FromArgb(UInt32 argb);
    public static XColor FromArgb(int red, int green, int blue);
    public static XColor FromArgb(int alpha, int red, int green, int blue);
    public static XColor FromArgb(int alpha, XColor color);
    public static XColor FromCmyk(double cyan, double magenta, double yellow, double black);
    public static XColor FromCmyk(double alpha, double cyan, double magenta, double yellow, double black);
    public static XColor FromGrayScale(double grayScale);
    public static XColor FromKnownColor(XKnownColor color);
    public static XColor FromName(string name);
    public XColorSpace get_ColorSpace();
    public void set_ColorSpace(XColorSpace value);
    public bool get_IsEmpty();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(XColor left, XColor right);
    public static bool op_Inequality(XColor left, XColor right);
    public bool get_IsKnownColor();
    public double GetHue();
    public double GetSaturation();
    public double GetBrightness();
    private void RgbChanged();
    private void CmykChanged();
    private void GrayChanged();
    public double get_A();
    public void set_A(double value);
    public byte get_R();
    public void set_R(byte value);
    public byte get_G();
    public void set_G(byte value);
    public byte get_B();
    public void set_B(byte value);
    internal UInt32 get_Rgb();
    internal UInt32 get_Argb();
    public double get_C();
    public void set_C(double value);
    public double get_M();
    public void set_M(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_K();
    public void set_K(double value);
    public double get_GS();
    public void set_GS(double value);
    public string get_RgbCmykG();
    public void set_RgbCmykG(string value);
    private static void CheckByte(int val, string name);
}
public class PdfSharpCore.Drawing.XColorResourceManager : object {
    private CultureInfo _cultureInfo;
    internal static ColorResourceInfo[] colorInfos;
    public XColorResourceManager(CultureInfo cultureInfo);
    private static XColorResourceManager();
    public static XKnownColor GetKnownColor(UInt32 argb);
    public static XKnownColor[] GetKnownColors(bool includeTransparent);
    public string ToColorName(XKnownColor knownColor);
    public string ToColorName(XColor color);
    private static ColorResourceInfo GetColorInfo(XKnownColor knownColor);
}
public static class PdfSharpCore.Drawing.XColors : object {
    public static XColor AliceBlue { get; }
    public static XColor AntiqueWhite { get; }
    public static XColor Aqua { get; }
    public static XColor Aquamarine { get; }
    public static XColor Azure { get; }
    public static XColor Beige { get; }
    public static XColor Bisque { get; }
    public static XColor Black { get; }
    public static XColor BlanchedAlmond { get; }
    public static XColor Blue { get; }
    public static XColor BlueViolet { get; }
    public static XColor Brown { get; }
    public static XColor BurlyWood { get; }
    public static XColor CadetBlue { get; }
    public static XColor Chartreuse { get; }
    public static XColor Chocolate { get; }
    public static XColor Coral { get; }
    public static XColor CornflowerBlue { get; }
    public static XColor Cornsilk { get; }
    public static XColor Crimson { get; }
    public static XColor Cyan { get; }
    public static XColor DarkBlue { get; }
    public static XColor DarkCyan { get; }
    public static XColor DarkGoldenrod { get; }
    public static XColor DarkGray { get; }
    public static XColor DarkGreen { get; }
    public static XColor DarkKhaki { get; }
    public static XColor DarkMagenta { get; }
    public static XColor DarkOliveGreen { get; }
    public static XColor DarkOrange { get; }
    public static XColor DarkOrchid { get; }
    public static XColor DarkRed { get; }
    public static XColor DarkSalmon { get; }
    public static XColor DarkSeaGreen { get; }
    public static XColor DarkSlateBlue { get; }
    public static XColor DarkSlateGray { get; }
    public static XColor DarkTurquoise { get; }
    public static XColor DarkViolet { get; }
    public static XColor DeepPink { get; }
    public static XColor DeepSkyBlue { get; }
    public static XColor DimGray { get; }
    public static XColor DodgerBlue { get; }
    public static XColor Firebrick { get; }
    public static XColor FloralWhite { get; }
    public static XColor ForestGreen { get; }
    public static XColor Fuchsia { get; }
    public static XColor Gainsboro { get; }
    public static XColor GhostWhite { get; }
    public static XColor Gold { get; }
    public static XColor Goldenrod { get; }
    public static XColor Gray { get; }
    public static XColor Green { get; }
    public static XColor GreenYellow { get; }
    public static XColor Honeydew { get; }
    public static XColor HotPink { get; }
    public static XColor IndianRed { get; }
    public static XColor Indigo { get; }
    public static XColor Ivory { get; }
    public static XColor Khaki { get; }
    public static XColor Lavender { get; }
    public static XColor LavenderBlush { get; }
    public static XColor LawnGreen { get; }
    public static XColor LemonChiffon { get; }
    public static XColor LightBlue { get; }
    public static XColor LightCoral { get; }
    public static XColor LightCyan { get; }
    public static XColor LightGoldenrodYellow { get; }
    public static XColor LightGray { get; }
    public static XColor LightGreen { get; }
    public static XColor LightPink { get; }
    public static XColor LightSalmon { get; }
    public static XColor LightSeaGreen { get; }
    public static XColor LightSkyBlue { get; }
    public static XColor LightSlateGray { get; }
    public static XColor LightSteelBlue { get; }
    public static XColor LightYellow { get; }
    public static XColor Lime { get; }
    public static XColor LimeGreen { get; }
    public static XColor Linen { get; }
    public static XColor Magenta { get; }
    public static XColor Maroon { get; }
    public static XColor MediumAquamarine { get; }
    public static XColor MediumBlue { get; }
    public static XColor MediumOrchid { get; }
    public static XColor MediumPurple { get; }
    public static XColor MediumSeaGreen { get; }
    public static XColor MediumSlateBlue { get; }
    public static XColor MediumSpringGreen { get; }
    public static XColor MediumTurquoise { get; }
    public static XColor MediumVioletRed { get; }
    public static XColor MidnightBlue { get; }
    public static XColor MintCream { get; }
    public static XColor MistyRose { get; }
    public static XColor Moccasin { get; }
    public static XColor NavajoWhite { get; }
    public static XColor Navy { get; }
    public static XColor OldLace { get; }
    public static XColor Olive { get; }
    public static XColor OliveDrab { get; }
    public static XColor Orange { get; }
    public static XColor OrangeRed { get; }
    public static XColor Orchid { get; }
    public static XColor PaleGoldenrod { get; }
    public static XColor PaleGreen { get; }
    public static XColor PaleTurquoise { get; }
    public static XColor PaleVioletRed { get; }
    public static XColor PapayaWhip { get; }
    public static XColor PeachPuff { get; }
    public static XColor Peru { get; }
    public static XColor Pink { get; }
    public static XColor Plum { get; }
    public static XColor PowderBlue { get; }
    public static XColor Purple { get; }
    public static XColor Red { get; }
    public static XColor RosyBrown { get; }
    public static XColor RoyalBlue { get; }
    public static XColor SaddleBrown { get; }
    public static XColor Salmon { get; }
    public static XColor SandyBrown { get; }
    public static XColor SeaGreen { get; }
    public static XColor SeaShell { get; }
    public static XColor Sienna { get; }
    public static XColor Silver { get; }
    public static XColor SkyBlue { get; }
    public static XColor SlateBlue { get; }
    public static XColor SlateGray { get; }
    public static XColor Snow { get; }
    public static XColor SpringGreen { get; }
    public static XColor SteelBlue { get; }
    public static XColor Tan { get; }
    public static XColor Teal { get; }
    public static XColor Thistle { get; }
    public static XColor Tomato { get; }
    public static XColor Transparent { get; }
    public static XColor Turquoise { get; }
    public static XColor Violet { get; }
    public static XColor Wheat { get; }
    public static XColor White { get; }
    public static XColor WhiteSmoke { get; }
    public static XColor Yellow { get; }
    public static XColor YellowGreen { get; }
    public static XColor get_AliceBlue();
    public static XColor get_AntiqueWhite();
    public static XColor get_Aqua();
    public static XColor get_Aquamarine();
    public static XColor get_Azure();
    public static XColor get_Beige();
    public static XColor get_Bisque();
    public static XColor get_Black();
    public static XColor get_BlanchedAlmond();
    public static XColor get_Blue();
    public static XColor get_BlueViolet();
    public static XColor get_Brown();
    public static XColor get_BurlyWood();
    public static XColor get_CadetBlue();
    public static XColor get_Chartreuse();
    public static XColor get_Chocolate();
    public static XColor get_Coral();
    public static XColor get_CornflowerBlue();
    public static XColor get_Cornsilk();
    public static XColor get_Crimson();
    public static XColor get_Cyan();
    public static XColor get_DarkBlue();
    public static XColor get_DarkCyan();
    public static XColor get_DarkGoldenrod();
    public static XColor get_DarkGray();
    public static XColor get_DarkGreen();
    public static XColor get_DarkKhaki();
    public static XColor get_DarkMagenta();
    public static XColor get_DarkOliveGreen();
    public static XColor get_DarkOrange();
    public static XColor get_DarkOrchid();
    public static XColor get_DarkRed();
    public static XColor get_DarkSalmon();
    public static XColor get_DarkSeaGreen();
    public static XColor get_DarkSlateBlue();
    public static XColor get_DarkSlateGray();
    public static XColor get_DarkTurquoise();
    public static XColor get_DarkViolet();
    public static XColor get_DeepPink();
    public static XColor get_DeepSkyBlue();
    public static XColor get_DimGray();
    public static XColor get_DodgerBlue();
    public static XColor get_Firebrick();
    public static XColor get_FloralWhite();
    public static XColor get_ForestGreen();
    public static XColor get_Fuchsia();
    public static XColor get_Gainsboro();
    public static XColor get_GhostWhite();
    public static XColor get_Gold();
    public static XColor get_Goldenrod();
    public static XColor get_Gray();
    public static XColor get_Green();
    public static XColor get_GreenYellow();
    public static XColor get_Honeydew();
    public static XColor get_HotPink();
    public static XColor get_IndianRed();
    public static XColor get_Indigo();
    public static XColor get_Ivory();
    public static XColor get_Khaki();
    public static XColor get_Lavender();
    public static XColor get_LavenderBlush();
    public static XColor get_LawnGreen();
    public static XColor get_LemonChiffon();
    public static XColor get_LightBlue();
    public static XColor get_LightCoral();
    public static XColor get_LightCyan();
    public static XColor get_LightGoldenrodYellow();
    public static XColor get_LightGray();
    public static XColor get_LightGreen();
    public static XColor get_LightPink();
    public static XColor get_LightSalmon();
    public static XColor get_LightSeaGreen();
    public static XColor get_LightSkyBlue();
    public static XColor get_LightSlateGray();
    public static XColor get_LightSteelBlue();
    public static XColor get_LightYellow();
    public static XColor get_Lime();
    public static XColor get_LimeGreen();
    public static XColor get_Linen();
    public static XColor get_Magenta();
    public static XColor get_Maroon();
    public static XColor get_MediumAquamarine();
    public static XColor get_MediumBlue();
    public static XColor get_MediumOrchid();
    public static XColor get_MediumPurple();
    public static XColor get_MediumSeaGreen();
    public static XColor get_MediumSlateBlue();
    public static XColor get_MediumSpringGreen();
    public static XColor get_MediumTurquoise();
    public static XColor get_MediumVioletRed();
    public static XColor get_MidnightBlue();
    public static XColor get_MintCream();
    public static XColor get_MistyRose();
    public static XColor get_Moccasin();
    public static XColor get_NavajoWhite();
    public static XColor get_Navy();
    public static XColor get_OldLace();
    public static XColor get_Olive();
    public static XColor get_OliveDrab();
    public static XColor get_Orange();
    public static XColor get_OrangeRed();
    public static XColor get_Orchid();
    public static XColor get_PaleGoldenrod();
    public static XColor get_PaleGreen();
    public static XColor get_PaleTurquoise();
    public static XColor get_PaleVioletRed();
    public static XColor get_PapayaWhip();
    public static XColor get_PeachPuff();
    public static XColor get_Peru();
    public static XColor get_Pink();
    public static XColor get_Plum();
    public static XColor get_PowderBlue();
    public static XColor get_Purple();
    public static XColor get_Red();
    public static XColor get_RosyBrown();
    public static XColor get_RoyalBlue();
    public static XColor get_SaddleBrown();
    public static XColor get_Salmon();
    public static XColor get_SandyBrown();
    public static XColor get_SeaGreen();
    public static XColor get_SeaShell();
    public static XColor get_Sienna();
    public static XColor get_Silver();
    public static XColor get_SkyBlue();
    public static XColor get_SlateBlue();
    public static XColor get_SlateGray();
    public static XColor get_Snow();
    public static XColor get_SpringGreen();
    public static XColor get_SteelBlue();
    public static XColor get_Tan();
    public static XColor get_Teal();
    public static XColor get_Thistle();
    public static XColor get_Tomato();
    public static XColor get_Transparent();
    public static XColor get_Turquoise();
    public static XColor get_Violet();
    public static XColor get_Wheat();
    public static XColor get_White();
    public static XColor get_WhiteSmoke();
    public static XColor get_Yellow();
    public static XColor get_YellowGreen();
}
public enum PdfSharpCore.Drawing.XColorSpace : Enum {
    public int value__;
    public static XColorSpace Rgb;
    public static XColorSpace Cmyk;
    public static XColorSpace GrayScale;
}
public enum PdfSharpCore.Drawing.XCombineMode : Enum {
    public int value__;
    public static XCombineMode Replace;
    public static XCombineMode Intersect;
    public static XCombineMode Union;
    public static XCombineMode Xor;
    public static XCombineMode Exclude;
    public static XCombineMode Complement;
}
internal static class PdfSharpCore.Drawing.XConvert : object {
}
public enum PdfSharpCore.Drawing.XDashStyle : Enum {
    public int value__;
    public static XDashStyle Solid;
    public static XDashStyle Dash;
    public static XDashStyle Dot;
    public static XDashStyle DashDot;
    public static XDashStyle DashDotDot;
    public static XDashStyle Custom;
}
public enum PdfSharpCore.Drawing.XFillMode : Enum {
    public int value__;
    public static XFillMode Alternate;
    public static XFillMode Winding;
}
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharpCore.Drawing.XFont : object {
    private double _emSize;
    private XFontStyle _style;
    private bool _isVertical;
    private XPdfFontOptions _pdfOptions;
    private int _cellSpace;
    private int _cellAscent;
    private int _cellDescent;
    private XFontMetrics _fontMetrics;
    private XGlyphTypeface _glyphTypeface;
    private OpenTypeDescriptor _descriptor;
    private string _familyName;
    internal int _unitsPerEm;
    internal bool OverrideStyleSimulations;
    internal XStyleSimulations StyleSimulations;
    private string _selector;
    [BrowsableAttribute("False")]
public XFontFamily FontFamily { get; }
    public string Name { get; }
    internal string FaceName { get; }
    public double Size { get; }
    [BrowsableAttribute("False")]
public XFontStyle Style { get; }
    public bool Bold { get; }
    public bool Italic { get; }
    public bool Strikeout { get; }
    public bool Underline { get; }
    internal bool IsVertical { get; internal set; }
    public XPdfFontOptions PdfOptions { get; }
    internal bool Unicode { get; }
    public int CellSpace { get; internal set; }
    public int CellAscent { get; internal set; }
    public int CellDescent { get; internal set; }
    public XFontMetrics Metrics { get; }
    [BrowsableAttribute("False")]
public int Height { get; }
    internal XGlyphTypeface GlyphTypeface { get; }
    internal OpenTypeDescriptor Descriptor { get; private set; }
    internal string FamilyName { get; }
    internal int UnitsPerEm { get; private set; }
    internal string Selector { get; internal set; }
    private string DebuggerDisplay { get; }
    public XFont(string familyName, double emSize);
    public XFont(string familyName, double emSize, XFontStyle style);
    public XFont(string familyName, double emSize, XFontStyle style, XPdfFontOptions pdfOptions);
    internal XFont(string familyName, double emSize, XFontStyle style, XPdfFontOptions pdfOptions, XStyleSimulations styleSimulations);
    private void Initialize();
    private void CreateDescriptorAndInitializeFontMetrics();
    public XFontFamily get_FontFamily();
    public string get_Name();
    internal string get_FaceName();
    public double get_Size();
    public XFontStyle get_Style();
    public bool get_Bold();
    public bool get_Italic();
    public bool get_Strikeout();
    public bool get_Underline();
    internal bool get_IsVertical();
    internal void set_IsVertical(bool value);
    public XPdfFontOptions get_PdfOptions();
    internal bool get_Unicode();
    public int get_CellSpace();
    internal void set_CellSpace(int value);
    public int get_CellAscent();
    internal void set_CellAscent(int value);
    public int get_CellDescent();
    internal void set_CellDescent(int value);
    public XFontMetrics get_Metrics();
    public double GetHeight();
    public int get_Height();
    internal XGlyphTypeface get_GlyphTypeface();
    internal OpenTypeDescriptor get_Descriptor();
    private void set_Descriptor(OpenTypeDescriptor value);
    internal string get_FamilyName();
    internal int get_UnitsPerEm();
    private void set_UnitsPerEm(int value);
    internal string get_Selector();
    internal void set_Selector(string value);
    private string get_DebuggerDisplay();
}
public class PdfSharpCore.Drawing.XFontFamily : object {
    internal FontFamilyInternal FamilyInternal;
    public string Name { get; }
    public XFontFamily(string familyName);
    internal XFontFamily(string familyName, bool createPlatformObjects);
    private XFontFamily(FontFamilyInternal fontFamilyInternal);
    internal static XFontFamily CreateFromName_not_used(string name, bool createPlatformFamily);
    internal static XFontFamily CreateSolitary(string name);
    public string get_Name();
    public int GetCellAscent(XFontStyle style);
    public int GetCellDescent(XFontStyle style);
    public int GetEmHeight(XFontStyle style);
    public int GetLineSpacing(XFontStyle style);
    public bool IsStyleAvailable(XFontStyle style);
}
public class PdfSharpCore.Drawing.XFontMetrics : object {
    private string _name;
    private int _unitsPerEm;
    private int _ascent;
    private int _descent;
    private int _averageWidth;
    private int _capHeight;
    private int _leading;
    private int _lineSpacing;
    private int _maxWidth;
    private int _stemH;
    private int _stemV;
    private int _xHeight;
    private int _underlinePosition;
    private int _underlineThickness;
    private int _strikethroughPosition;
    private int _strikethroughThickness;
    public string Name { get; }
    public int UnitsPerEm { get; }
    public int Ascent { get; }
    public int Descent { get; }
    public int AverageWidth { get; }
    public int CapHeight { get; }
    public int Leading { get; }
    public int LineSpacing { get; }
    public int MaxWidth { get; }
    public int StemH { get; }
    public int StemV { get; }
    public int XHeight { get; }
    public int UnderlinePosition { get; }
    public int UnderlineThickness { get; }
    public int StrikethroughPosition { get; }
    public int StrikethroughThickness { get; }
    internal XFontMetrics(string name, int unitsPerEm, int ascent, int descent, int leading, int lineSpacing, int capHeight, int xHeight, int stemV, int stemH, int averageWidth, int maxWidth, int underlinePosition, int underlineThickness, int strikethroughPosition, int strikethroughThickness);
    public string get_Name();
    public int get_UnitsPerEm();
    public int get_Ascent();
    public int get_Descent();
    public int get_AverageWidth();
    public int get_CapHeight();
    public int get_Leading();
    public int get_LineSpacing();
    public int get_MaxWidth();
    public int get_StemH();
    public int get_StemV();
    public int get_XHeight();
    public int get_UnderlinePosition();
    public int get_UnderlineThickness();
    public int get_StrikethroughPosition();
    public int get_StrikethroughThickness();
}
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
internal class PdfSharpCore.Drawing.XFontSource : object {
    private static UInt32 ttcf;
    private OpenTypeFontface _fontface;
    private ulong _key;
    private string _fontName;
    private Byte[] _bytes;
    internal OpenTypeFontface Fontface { get; internal set; }
    internal ulong Key { get; }
    public string FontName { get; }
    public Byte[] Bytes { get; }
    internal string DebuggerDisplay { get; }
    private XFontSource(Byte[] bytes, ulong key);
    public static XFontSource GetOrCreateFrom(Byte[] bytes);
    public static XFontSource GetOrCreateFrom(string typefaceKey, Byte[] fontBytes);
    public static XFontSource CreateCompiledFont(Byte[] bytes);
    internal OpenTypeFontface get_Fontface();
    internal void set_Fontface(OpenTypeFontface value);
    internal ulong get_Key();
    public void IncrementKey();
    public string get_FontName();
    public Byte[] get_Bytes();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    internal string get_DebuggerDisplay();
}
[FlagsAttribute]
public enum PdfSharpCore.Drawing.XFontStyle : Enum {
    public int value__;
    public static XFontStyle Regular;
    public static XFontStyle Bold;
    public static XFontStyle Italic;
    public static XFontStyle BoldItalic;
    public static XFontStyle Underline;
    public static XFontStyle Strikeout;
}
public class PdfSharpCore.Drawing.XForm : XImage {
    internal XGraphics Gfx;
    private PdfDocument _document;
    internal FormState _formState;
    private XRect _viewBox;
    private XRect _boundingBox;
    internal XMatrix _transform;
    internal PdfFormXObject _pdfForm;
    internal XGraphicsPdfRenderer PdfRenderer;
    internal PdfDocument Owner { get; }
    internal PdfColorMode ColorMode { get; }
    internal bool IsTemplate { get; }
    public double PointWidth { get; }
    public double PointHeight { get; }
    public int PixelWidth { get; }
    public int PixelHeight { get; }
    public XSize Size { get; }
    public XRect ViewBox { get; }
    public double HorizontalResolution { get; }
    public double VerticalResolution { get; }
    public XRect BoundingBox { get; public set; }
    public XMatrix Transform { get; public set; }
    internal PdfResources Resources { get; }
    private PdfResources PdfSharpCore.Pdf.Advanced.IContentStream.Resources { get; }
    internal PdfFormXObject PdfForm { get; }
    public XForm(PdfDocument document, XRect viewBox);
    public XForm(PdfDocument document, XSize size);
    public XForm(PdfDocument document, XUnit width, XUnit height);
    public void DrawingFinished();
    internal void AssociateGraphics(XGraphics gfx);
    protected virtual void Dispose(bool disposing);
    internal virtual void Finish();
    internal PdfDocument get_Owner();
    internal PdfColorMode get_ColorMode();
    internal bool get_IsTemplate();
    public virtual double get_PointWidth();
    public virtual double get_PointHeight();
    public virtual int get_PixelWidth();
    public virtual int get_PixelHeight();
    public virtual XSize get_Size();
    public XRect get_ViewBox();
    public virtual double get_HorizontalResolution();
    public virtual double get_VerticalResolution();
    public XRect get_BoundingBox();
    public void set_BoundingBox(XRect value);
    public virtual XMatrix get_Transform();
    public virtual void set_Transform(XMatrix value);
    internal PdfResources get_Resources();
    private sealed virtual override PdfResources PdfSharpCore.Pdf.Advanced.IContentStream.get_Resources();
    internal string GetFontName(XFont font, PdfFont& pdfFont);
    private sealed virtual override string PdfSharpCore.Pdf.Advanced.IContentStream.GetFontName(XFont font, PdfFont& pdfFont);
    internal string TryGetFontName(string idName, PdfFont& pdfFont);
    internal string GetFontName(string idName, Byte[] fontData, PdfFont& pdfFont);
    private sealed virtual override string PdfSharpCore.Pdf.Advanced.IContentStream.GetFontName(string idName, Byte[] fontData, PdfFont& pdfFont);
    internal string GetImageName(XImage image);
    private sealed virtual override string PdfSharpCore.Pdf.Advanced.IContentStream.GetImageName(XImage image);
    internal PdfFormXObject get_PdfForm();
    internal string GetFormName(XForm form);
    private sealed virtual override string PdfSharpCore.Pdf.Advanced.IContentStream.GetFormName(XForm form);
}
[FlagsAttribute]
internal enum PdfSharpCore.Drawing.XGdiFontStyle : Enum {
    public int value__;
    public static XGdiFontStyle Regular;
    public static XGdiFontStyle Bold;
    public static XGdiFontStyle Italic;
    public static XGdiFontStyle BoldItalic;
    public static XGdiFontStyle Underline;
    public static XGdiFontStyle Strikeout;
}
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
internal class PdfSharpCore.Drawing.XGlyphTypeface : object {
    private static string KeyPrefix;
    private XFontFamily _fontFamily;
    private OpenTypeFontface _fontface;
    private XFontSource _fontSource;
    private string _faceName;
    private string _familyName;
    private string _styleName;
    private string _displayName;
    private bool _isBold;
    private bool _isItalic;
    private XStyleSimulations _styleSimulations;
    private string _key;
    public XFontFamily FontFamily { get; }
    internal OpenTypeFontface Fontface { get; }
    public XFontSource FontSource { get; }
    internal string FaceName { get; }
    public string FamilyName { get; }
    public string StyleName { get; }
    public string DisplayName { get; }
    public bool IsBold { get; }
    public bool IsItalic { get; }
    public XStyleSimulations StyleSimulations { get; }
    public string Key { get; }
    internal string DebuggerDisplay { get; }
    public XGlyphTypeface(string key, XFontSource fontSource);
    public XGlyphTypeface(string key, XFontFamily fontFamily, XFontSource fontSource, XStyleSimulations styleSimulations);
    public static XGlyphTypeface GetOrCreateFrom(string familyName, FontResolvingOptions fontResolvingOptions);
    public XFontFamily get_FontFamily();
    internal OpenTypeFontface get_Fontface();
    public XFontSource get_FontSource();
    private void Initialize();
    internal string get_FaceName();
    public string get_FamilyName();
    public string get_StyleName();
    public string get_DisplayName();
    public bool get_IsBold();
    public bool get_IsItalic();
    public XStyleSimulations get_StyleSimulations();
    private string GetFaceNameSuffix();
    internal string GetBaseName();
    internal static string ComputeKey(string familyName, FontResolvingOptions fontResolvingOptions);
    internal static string ComputeKey(string familyName, bool isBold, bool isItalic);
    public string get_Key();
    internal string get_DebuggerDisplay();
}
public class PdfSharpCore.Drawing.XGraphics : object {
    private bool _disposed;
    private PdfFontEncoding _muh;
    private XGraphicsUnit _pageUnit;
    private XPageDirection _pageDirection;
    private XPoint _pageOrigin;
    private XSize _pageSize;
    private XSize _pageSizePoints;
    private XSmoothingMode _smoothingMode;
    private XGraphicsInternals _internals;
    private SpaceTransformer _transformer;
    private InternalGraphicsMode _internalGraphicsMode;
    private XImage _associatedImage;
    internal XMatrix DefaultViewMatrix;
    private bool _drawGraphics;
    private XForm _form;
    private IXGraphicsRenderer _renderer;
    private XMatrix _transform;
    private GraphicsStateStack _gsStack;
    public PdfFontEncoding MUH { get; public set; }
    public XGraphicsUnit PageUnit { get; }
    public XPageDirection PageDirection { get; public set; }
    public XPoint PageOrigin { get; public set; }
    public XSize PageSize { get; }
    public int GraphicsStateLevel { get; }
    public XSmoothingMode SmoothingMode { get; public set; }
    public XMatrix Transform { get; }
    public XGraphicsInternals Internals { get; }
    public SpaceTransformer Transformer { get; }
    internal InternalGraphicsMode InternalGraphicsMode { get; internal set; }
    internal XImage AssociatedImage { get; internal set; }
    public PdfPage PdfPage { get; }
    private XGraphics(PdfPage page, XGraphicsPdfPageOptions options, XGraphicsUnit pageUnit, XPageDirection pageDirection);
    private XGraphics(XSize size, XGraphicsUnit pageUnit, XPageDirection pageDirection);
    private XGraphics(IXGraphicsRenderer renderer, XSize size, XGraphicsUnit pageUnit, XPageDirection pageDirection);
    private XGraphics(XForm form);
    public static XGraphics CreateMeasureContext(XSize size, XGraphicsUnit pageUnit, XPageDirection pageDirection);
    public static XGraphics FromRenderer(IXGraphicsRenderer renderer, XSize size, XGraphicsUnit pageUnit, XPageDirection pageDirection);
    public static XGraphics FromPdfPage(PdfPage page);
    public static XGraphics FromPdfPage(PdfPage page, XGraphicsUnit unit);
    public static XGraphics FromPdfPage(PdfPage page, XPageDirection pageDirection);
    public static XGraphics FromPdfPage(PdfPage page, XGraphicsPdfPageOptions options);
    public static XGraphics FromPdfPage(PdfPage page, XGraphicsPdfPageOptions options, XPageDirection pageDirection);
    public static XGraphics FromPdfPage(PdfPage page, XGraphicsPdfPageOptions options, XGraphicsUnit unit);
    public static XGraphics FromPdfPage(PdfPage page, XGraphicsPdfPageOptions options, XGraphicsUnit unit, XPageDirection pageDirection);
    public static XGraphics FromPdfForm(XPdfForm form);
    public static XGraphics FromForm(XForm form);
    public static XGraphics FromImage(XImage image);
    public static XGraphics FromImage(XImage image, XGraphicsUnit unit);
    private void Initialize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public PdfFontEncoding get_MUH();
    public void set_MUH(PdfFontEncoding value);
    public XGraphicsUnit get_PageUnit();
    public XPageDirection get_PageDirection();
    public void set_PageDirection(XPageDirection value);
    public XPoint get_PageOrigin();
    public void set_PageOrigin(XPoint value);
    public XSize get_PageSize();
    public void DrawLine(XPen pen, XPoint pt1, XPoint pt2);
    public void DrawLine(XPen pen, double x1, double y1, double x2, double y2);
    public void DrawLines(XPen pen, XPoint[] points);
    public void DrawLines(XPen pen, double x, double y, Double[] value);
    public void DrawBezier(XPen pen, XPoint pt1, XPoint pt2, XPoint pt3, XPoint pt4);
    public void DrawBezier(XPen pen, double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4);
    public void DrawBeziers(XPen pen, XPoint[] points);
    public void DrawCurve(XPen pen, XPoint[] points);
    public void DrawCurve(XPen pen, XPoint[] points, int offset, int numberOfSegments, double tension);
    public void DrawCurve(XPen pen, XPoint[] points, double tension);
    public void DrawArc(XPen pen, XRect rect, double startAngle, double sweepAngle);
    public void DrawArc(XPen pen, double x, double y, double width, double height, double startAngle, double sweepAngle);
    public void DrawRectangle(XPen pen, XRect rect);
    public void DrawRectangle(XPen pen, double x, double y, double width, double height);
    public void DrawRectangle(XBrush brush, XRect rect);
    public void DrawRectangle(XBrush brush, double x, double y, double width, double height);
    public void DrawRectangle(XPen pen, XBrush brush, XRect rect);
    public void DrawRectangle(XPen pen, XBrush brush, double x, double y, double width, double height);
    public void DrawRectangles(XPen pen, XRect[] rectangles);
    public void DrawRectangles(XBrush brush, XRect[] rectangles);
    public void DrawRectangles(XPen pen, XBrush brush, XRect[] rectangles);
    public void DrawRoundedRectangle(XPen pen, XRect rect, XSize ellipseSize);
    public void DrawRoundedRectangle(XPen pen, double x, double y, double width, double height, double ellipseWidth, double ellipseHeight);
    public void DrawRoundedRectangle(XBrush brush, XRect rect, XSize ellipseSize);
    public void DrawRoundedRectangle(XBrush brush, double x, double y, double width, double height, double ellipseWidth, double ellipseHeight);
    public void DrawRoundedRectangle(XPen pen, XBrush brush, XRect rect, XSize ellipseSize);
    public void DrawRoundedRectangle(XPen pen, XBrush brush, double x, double y, double width, double height, double ellipseWidth, double ellipseHeight);
    public void DrawEllipse(XPen pen, XRect rect);
    public void DrawEllipse(XPen pen, double x, double y, double width, double height);
    public void DrawEllipse(XBrush brush, XRect rect);
    public void DrawEllipse(XBrush brush, double x, double y, double width, double height);
    public void DrawEllipse(XPen pen, XBrush brush, XRect rect);
    public void DrawEllipse(XPen pen, XBrush brush, double x, double y, double width, double height);
    public void DrawPolygon(XPen pen, XPoint[] points);
    public void DrawPolygon(XBrush brush, XPoint[] points, XFillMode fillmode);
    public void DrawPolygon(XPen pen, XBrush brush, XPoint[] points, XFillMode fillmode);
    public void DrawPie(XPen pen, XRect rect, double startAngle, double sweepAngle);
    public void DrawPie(XPen pen, double x, double y, double width, double height, double startAngle, double sweepAngle);
    public void DrawPie(XBrush brush, XRect rect, double startAngle, double sweepAngle);
    public void DrawPie(XBrush brush, double x, double y, double width, double height, double startAngle, double sweepAngle);
    public void DrawPie(XPen pen, XBrush brush, XRect rect, double startAngle, double sweepAngle);
    public void DrawPie(XPen pen, XBrush brush, double x, double y, double width, double height, double startAngle, double sweepAngle);
    public void DrawClosedCurve(XPen pen, XPoint[] points);
    public void DrawClosedCurve(XPen pen, XPoint[] points, double tension);
    public void DrawClosedCurve(XBrush brush, XPoint[] points);
    public void DrawClosedCurve(XBrush brush, XPoint[] points, XFillMode fillmode);
    public void DrawClosedCurve(XBrush brush, XPoint[] points, XFillMode fillmode, double tension);
    public void DrawClosedCurve(XPen pen, XBrush brush, XPoint[] points);
    public void DrawClosedCurve(XPen pen, XBrush brush, XPoint[] points, XFillMode fillmode);
    public void DrawClosedCurve(XPen pen, XBrush brush, XPoint[] points, XFillMode fillmode, double tension);
    public void DrawPath(XPen pen, XGraphicsPath path);
    public void DrawPath(XBrush brush, XGraphicsPath path);
    public void DrawPath(XPen pen, XBrush brush, XGraphicsPath path);
    public void DrawString(string s, XFont font, XBrush brush, XPoint point);
    public void DrawString(string s, XFont font, XBrush brush, XPoint point, XStringFormat format);
    public void DrawString(string s, XFont font, XBrush brush, double x, double y);
    public void DrawString(string s, XFont font, XBrush brush, double x, double y, XStringFormat format);
    public void DrawString(string s, XFont font, XBrush brush, XRect layoutRectangle);
    public void DrawString(string text, XFont font, XBrush brush, XRect layoutRectangle, XStringFormat format);
    public XSize MeasureString(string text, XFont font, XStringFormat stringFormat);
    public XSize MeasureString(string text, XFont font);
    public void DrawImage(XImage image, XPoint point);
    public void DrawImage(XImage image, double x, double y);
    public void DrawImage(XImage image, XRect rect);
    public void DrawImage(XImage image, double x, double y, double width, double height);
    public void DrawImage(XImage image, XRect destRect, XRect srcRect, XGraphicsUnit srcUnit);
    private void DrawMissingImageRect(XRect rect);
    private void CheckXPdfFormConsistence(XImage image);
    public void DrawBarCode(BarCode barcode, XPoint position);
    public void DrawBarCode(BarCode barcode, XBrush brush, XPoint position);
    public void DrawBarCode(BarCode barcode, XBrush brush, XFont font, XPoint position);
    public void DrawMatrixCode(MatrixCode matrixcode, XPoint position);
    public void DrawMatrixCode(MatrixCode matrixcode, XBrush brush, XPoint position);
    public XGraphicsState Save();
    public void Restore(XGraphicsState state);
    public void Restore();
    public XGraphicsContainer BeginContainer();
    public XGraphicsContainer BeginContainer(XRect dstrect, XRect srcrect, XGraphicsUnit unit);
    public void EndContainer(XGraphicsContainer container);
    public int get_GraphicsStateLevel();
    public XSmoothingMode get_SmoothingMode();
    public void set_SmoothingMode(XSmoothingMode value);
    public void TranslateTransform(double dx, double dy);
    public void TranslateTransform(double dx, double dy, XMatrixOrder order);
    public void ScaleTransform(double scaleX, double scaleY);
    public void ScaleTransform(double scaleX, double scaleY, XMatrixOrder order);
    public void ScaleTransform(double scaleXY);
    public void ScaleTransform(double scaleXY, XMatrixOrder order);
    public void ScaleAtTransform(double scaleX, double scaleY, double centerX, double centerY);
    public void ScaleAtTransform(double scaleX, double scaleY, XPoint center);
    public void RotateTransform(double angle);
    public void RotateTransform(double angle, XMatrixOrder order);
    public void RotateAtTransform(double angle, XPoint point);
    public void RotateAtTransform(double angle, XPoint point, XMatrixOrder order);
    public void ShearTransform(double shearX, double shearY);
    public void ShearTransform(double shearX, double shearY, XMatrixOrder order);
    public void SkewAtTransform(double shearX, double shearY, double centerX, double centerY);
    public void SkewAtTransform(double shearX, double shearY, XPoint center);
    public void MultiplyTransform(XMatrix matrix);
    public void MultiplyTransform(XMatrix matrix, XMatrixOrder order);
    public XMatrix get_Transform();
    private void AddTransform(XMatrix transform, XMatrixOrder order);
    public void IntersectClip(XRect rect);
    public void IntersectClip(XGraphicsPath path);
    public void WriteComment(string comment);
    public XGraphicsInternals get_Internals();
    public SpaceTransformer get_Transformer();
    internal void DisassociateImage();
    internal InternalGraphicsMode get_InternalGraphicsMode();
    internal void set_InternalGraphicsMode(InternalGraphicsMode value);
    internal XImage get_AssociatedImage();
    internal void set_AssociatedImage(XImage value);
    public PdfPage get_PdfPage();
}
public class PdfSharpCore.Drawing.XGraphicsContainer : object {
    internal InternalGraphicsState InternalState;
}
public class PdfSharpCore.Drawing.XGraphicsPath : object {
    private XFillMode _fillMode;
    internal CoreGraphicsPath _corePath;
    public XFillMode FillMode { get; public set; }
    public XGraphicsPathInternals Internals { get; }
    public XGraphicsPath Clone();
    public void AddLine(XPoint pt1, XPoint pt2);
    public void AddMove(double x1, double y1);
    public void AddLine(double x1, double y1, double x2, double y2);
    public void AddLines(XPoint[] points);
    public void AddBezier(XPoint pt1, XPoint pt2, XPoint pt3, XPoint pt4);
    public void AddBezier(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4);
    public void AddBeziers(XPoint[] points);
    public void AddCurve(XPoint[] points);
    public void AddCurve(XPoint[] points, double tension);
    public void AddCurve(XPoint[] points, int offset, int numberOfSegments, double tension);
    public void AddArc(XRect rect, double startAngle, double sweepAngle);
    public void AddArc(double x, double y, double width, double height, double startAngle, double sweepAngle);
    public void AddArc(XPoint point1, XPoint point2, XSize size, double rotationAngle, bool isLargeArg, XSweepDirection sweepDirection);
    public void AddRectangle(XRect rect);
    public void AddRectangle(double x, double y, double width, double height);
    public void AddRectangles(XRect[] rects);
    public void AddRoundedRectangle(double x, double y, double width, double height, double ellipseWidth, double ellipseHeight);
    public void AddEllipse(XRect rect);
    public void AddEllipse(double x, double y, double width, double height);
    public void AddPolygon(XPoint[] points);
    public void AddPie(XRect rect, double startAngle, double sweepAngle);
    public void AddPie(double x, double y, double width, double height, double startAngle, double sweepAngle);
    public void AddClosedCurve(XPoint[] points);
    public void AddClosedCurve(XPoint[] points, double tension);
    public void AddPath(XGraphicsPath path, bool connect);
    public void AddString(string s, XFontFamily family, XFontStyle style, double emSize, XPoint origin, XStringFormat format);
    public void AddString(string s, XFontFamily family, XFontStyle style, double emSize, XRect layoutRect, XStringFormat format);
    public void CloseFigure();
    public void StartFigure();
    public XFillMode get_FillMode();
    public void set_FillMode(XFillMode value);
    public void Flatten();
    public void Flatten(XMatrix matrix);
    public void Flatten(XMatrix matrix, double flatness);
    public void Widen(XPen pen);
    public void Widen(XPen pen, XMatrix matrix);
    public void Widen(XPen pen, XMatrix matrix, double flatness);
    public XGraphicsPathInternals get_Internals();
}
public class PdfSharpCore.Drawing.XGraphicsPathInternals : object {
    private XGraphicsPath _path;
    internal XGraphicsPathInternals(XGraphicsPath path);
}
internal enum PdfSharpCore.Drawing.XGraphicsPathItemType : Enum {
    public int value__;
    public static XGraphicsPathItemType Lines;
    public static XGraphicsPathItemType Beziers;
    public static XGraphicsPathItemType Curve;
    public static XGraphicsPathItemType Arc;
    public static XGraphicsPathItemType Rectangle;
    public static XGraphicsPathItemType RoundedRectangle;
    public static XGraphicsPathItemType Ellipse;
    public static XGraphicsPathItemType Polygon;
    public static XGraphicsPathItemType CloseFigure;
    public static XGraphicsPathItemType StartFigure;
}
public enum PdfSharpCore.Drawing.XGraphicsPdfPageOptions : Enum {
    public int value__;
    public static XGraphicsPdfPageOptions Append;
    public static XGraphicsPdfPageOptions Prepend;
    public static XGraphicsPdfPageOptions Replace;
}
public class PdfSharpCore.Drawing.XGraphicsState : object {
    internal InternalGraphicsState InternalState;
}
public enum PdfSharpCore.Drawing.XGraphicsUnit : Enum {
    public int value__;
    public static XGraphicsUnit Point;
    public static XGraphicsUnit Inch;
    public static XGraphicsUnit Millimeter;
    public static XGraphicsUnit Centimeter;
    public static XGraphicsUnit Presentation;
}
internal enum PdfSharpCore.Drawing.XGraphicTargetContext : Enum {
    public int value__;
    public static XGraphicTargetContext NONE;
    public static XGraphicTargetContext CORE;
    public static XGraphicTargetContext GDI;
    public static XGraphicTargetContext WPF;
    public static XGraphicTargetContext UWP;
}
public class PdfSharpCore.Drawing.XImage : object {
    private XImageState _xImageState;
    private bool _disposed;
    private bool _interpolate;
    private XImageFormat _format;
    private XGraphics _associatedGraphics;
    internal string _path;
    internal ImageSelector _selector;
    private IImageSource _source;
    internal XImageState XImageState { get; internal set; }
    public double PointWidth { get; }
    public double PointHeight { get; }
    public int PixelWidth { get; }
    public int PixelHeight { get; }
    public XSize Size { get; }
    public double HorizontalResolution { get; }
    public double VerticalResolution { get; }
    public bool Interpolate { get; public set; }
    public XImageFormat Format { get; }
    internal XGraphics AssociatedGraphics { get; internal set; }
    private XImage(string path);
    private XImage(IImageSource imageSource);
    private XImage(Func`1<Stream> stream);
    private XImage(Func`1<Byte[]> data);
    public static XImage FromFile(string path);
    public static XImage FromFile(string path, PdfReadAccuracy accuracy);
    public static XImage FromStream(Func`1<Stream> stream);
    public static XImage FromImageSource(IImageSource imageSouce);
    public static bool ExistsFile(string path);
    internal XImageState get_XImageState();
    internal void set_XImageState(XImageState value);
    internal void Initialize();
    public MemoryStream AsJpeg();
    public MemoryStream AsBitmap();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual double get_PointWidth();
    public virtual double get_PointHeight();
    public virtual int get_PixelWidth();
    public virtual int get_PixelHeight();
    public virtual XSize get_Size();
    public virtual double get_HorizontalResolution();
    public virtual double get_VerticalResolution();
    public virtual bool get_Interpolate();
    public virtual void set_Interpolate(bool value);
    public XImageFormat get_Format();
    internal void AssociateWithGraphics(XGraphics gfx);
    internal void DisassociateWithGraphics();
    internal void DisassociateWithGraphics(XGraphics gfx);
    internal XGraphics get_AssociatedGraphics();
    internal void set_AssociatedGraphics(XGraphics value);
}
public class PdfSharpCore.Drawing.XImageFormat : object {
    private Guid _guid;
    private static XImageFormat _png;
    private static XImageFormat _gif;
    private static XImageFormat _jpeg;
    private static XImageFormat _tiff;
    private static XImageFormat _icon;
    private static XImageFormat _pdf;
    internal Guid Guid { get; }
    public static XImageFormat Png { get; }
    public static XImageFormat Gif { get; }
    public static XImageFormat Jpeg { get; }
    public static XImageFormat Tiff { get; }
    public static XImageFormat Pdf { get; }
    public static XImageFormat Icon { get; }
    private XImageFormat(Guid guid);
    private static XImageFormat();
    internal Guid get_Guid();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static XImageFormat get_Png();
    public static XImageFormat get_Gif();
    public static XImageFormat get_Jpeg();
    public static XImageFormat get_Tiff();
    public static XImageFormat get_Pdf();
    public static XImageFormat get_Icon();
}
[FlagsAttribute]
internal enum PdfSharpCore.Drawing.XImageState : Enum {
    public int value__;
    public static XImageState UsedInDrawingContext;
    public static XImageState StateMask;
}
public enum PdfSharpCore.Drawing.XKnownColor : Enum {
    public int value__;
    public static XKnownColor AliceBlue;
    public static XKnownColor AntiqueWhite;
    public static XKnownColor Aqua;
    public static XKnownColor Aquamarine;
    public static XKnownColor Azure;
    public static XKnownColor Beige;
    public static XKnownColor Bisque;
    public static XKnownColor Black;
    public static XKnownColor BlanchedAlmond;
    public static XKnownColor Blue;
    public static XKnownColor BlueViolet;
    public static XKnownColor Brown;
    public static XKnownColor BurlyWood;
    public static XKnownColor CadetBlue;
    public static XKnownColor Chartreuse;
    public static XKnownColor Chocolate;
    public static XKnownColor Coral;
    public static XKnownColor CornflowerBlue;
    public static XKnownColor Cornsilk;
    public static XKnownColor Crimson;
    public static XKnownColor Cyan;
    public static XKnownColor DarkBlue;
    public static XKnownColor DarkCyan;
    public static XKnownColor DarkGoldenrod;
    public static XKnownColor DarkGray;
    public static XKnownColor DarkGreen;
    public static XKnownColor DarkKhaki;
    public static XKnownColor DarkMagenta;
    public static XKnownColor DarkOliveGreen;
    public static XKnownColor DarkOrange;
    public static XKnownColor DarkOrchid;
    public static XKnownColor DarkRed;
    public static XKnownColor DarkSalmon;
    public static XKnownColor DarkSeaGreen;
    public static XKnownColor DarkSlateBlue;
    public static XKnownColor DarkSlateGray;
    public static XKnownColor DarkTurquoise;
    public static XKnownColor DarkViolet;
    public static XKnownColor DeepPink;
    public static XKnownColor DeepSkyBlue;
    public static XKnownColor DimGray;
    public static XKnownColor DodgerBlue;
    public static XKnownColor Firebrick;
    public static XKnownColor FloralWhite;
    public static XKnownColor ForestGreen;
    public static XKnownColor Fuchsia;
    public static XKnownColor Gainsboro;
    public static XKnownColor GhostWhite;
    public static XKnownColor Gold;
    public static XKnownColor Goldenrod;
    public static XKnownColor Gray;
    public static XKnownColor Green;
    public static XKnownColor GreenYellow;
    public static XKnownColor Honeydew;
    public static XKnownColor HotPink;
    public static XKnownColor IndianRed;
    public static XKnownColor Indigo;
    public static XKnownColor Ivory;
    public static XKnownColor Khaki;
    public static XKnownColor Lavender;
    public static XKnownColor LavenderBlush;
    public static XKnownColor LawnGreen;
    public static XKnownColor LemonChiffon;
    public static XKnownColor LightBlue;
    public static XKnownColor LightCoral;
    public static XKnownColor LightCyan;
    public static XKnownColor LightGoldenrodYellow;
    public static XKnownColor LightGray;
    public static XKnownColor LightGreen;
    public static XKnownColor LightPink;
    public static XKnownColor LightSalmon;
    public static XKnownColor LightSeaGreen;
    public static XKnownColor LightSkyBlue;
    public static XKnownColor LightSlateGray;
    public static XKnownColor LightSteelBlue;
    public static XKnownColor LightYellow;
    public static XKnownColor Lime;
    public static XKnownColor LimeGreen;
    public static XKnownColor Linen;
    public static XKnownColor Magenta;
    public static XKnownColor Maroon;
    public static XKnownColor MediumAquamarine;
    public static XKnownColor MediumBlue;
    public static XKnownColor MediumOrchid;
    public static XKnownColor MediumPurple;
    public static XKnownColor MediumSeaGreen;
    public static XKnownColor MediumSlateBlue;
    public static XKnownColor MediumSpringGreen;
    public static XKnownColor MediumTurquoise;
    public static XKnownColor MediumVioletRed;
    public static XKnownColor MidnightBlue;
    public static XKnownColor MintCream;
    public static XKnownColor MistyRose;
    public static XKnownColor Moccasin;
    public static XKnownColor NavajoWhite;
    public static XKnownColor Navy;
    public static XKnownColor OldLace;
    public static XKnownColor Olive;
    public static XKnownColor OliveDrab;
    public static XKnownColor Orange;
    public static XKnownColor OrangeRed;
    public static XKnownColor Orchid;
    public static XKnownColor PaleGoldenrod;
    public static XKnownColor PaleGreen;
    public static XKnownColor PaleTurquoise;
    public static XKnownColor PaleVioletRed;
    public static XKnownColor PapayaWhip;
    public static XKnownColor PeachPuff;
    public static XKnownColor Peru;
    public static XKnownColor Pink;
    public static XKnownColor Plum;
    public static XKnownColor PowderBlue;
    public static XKnownColor Purple;
    public static XKnownColor Red;
    public static XKnownColor RosyBrown;
    public static XKnownColor RoyalBlue;
    public static XKnownColor SaddleBrown;
    public static XKnownColor Salmon;
    public static XKnownColor SandyBrown;
    public static XKnownColor SeaGreen;
    public static XKnownColor SeaShell;
    public static XKnownColor Sienna;
    public static XKnownColor Silver;
    public static XKnownColor SkyBlue;
    public static XKnownColor SlateBlue;
    public static XKnownColor SlateGray;
    public static XKnownColor Snow;
    public static XKnownColor SpringGreen;
    public static XKnownColor SteelBlue;
    public static XKnownColor Tan;
    public static XKnownColor Teal;
    public static XKnownColor Thistle;
    public static XKnownColor Tomato;
    public static XKnownColor Transparent;
    public static XKnownColor Turquoise;
    public static XKnownColor Violet;
    public static XKnownColor Wheat;
    public static XKnownColor White;
    public static XKnownColor WhiteSmoke;
    public static XKnownColor Yellow;
    public static XKnownColor YellowGreen;
}
internal class PdfSharpCore.Drawing.XKnownColorTable : object {
    internal static UInt32[] ColorTable;
    public static UInt32 KnownColorToArgb(XKnownColor color);
    public static bool IsKnownColor(UInt32 argb);
    public static XKnownColor GetKnownColor(UInt32 argb);
    private static void InitColorTable();
}
public enum PdfSharpCore.Drawing.XLineAlignment : Enum {
    public int value__;
    public static XLineAlignment Near;
    public static XLineAlignment Center;
    public static XLineAlignment Far;
    public static XLineAlignment BaseLine;
}
public class PdfSharpCore.Drawing.XLinearGradientBrush : XBaseGradientBrush {
    internal bool _useRect;
    internal XPoint _point1;
    internal XPoint _point2;
    internal XRect _rect;
    internal XLinearGradientMode _linearGradientMode;
    public XLinearGradientBrush(XPoint point1, XPoint point2, XColor color1, XColor color2);
    public XLinearGradientBrush(XRect rect, XColor color1, XColor color2, XLinearGradientMode linearGradientMode);
}
public enum PdfSharpCore.Drawing.XLinearGradientMode : Enum {
    public int value__;
    public static XLinearGradientMode Horizontal;
    public static XLinearGradientMode Vertical;
    public static XLinearGradientMode ForwardDiagonal;
    public static XLinearGradientMode BackwardDiagonal;
}
public enum PdfSharpCore.Drawing.XLineCap : Enum {
    public int value__;
    public static XLineCap Flat;
    public static XLineCap Round;
    public static XLineCap Square;
}
public enum PdfSharpCore.Drawing.XLineJoin : Enum {
    public int value__;
    public static XLineJoin Miter;
    public static XLineJoin Round;
    public static XLineJoin Bevel;
}
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharpCore.Drawing.XMatrix : ValueType {
    private double _m11;
    private double _m12;
    private double _m21;
    private double _m22;
    private double _offsetX;
    private double _offsetY;
    private XMatrixTypes _type;
    private static XMatrix s_identity;
    public static XMatrix Identity { get; }
    public bool IsIdentity { get; }
    public double Determinant { get; }
    public bool HasInverse { get; }
    public double M11 { get; public set; }
    public double M12 { get; public set; }
    public double M21 { get; public set; }
    public double M22 { get; public set; }
    public double OffsetX { get; public set; }
    public double OffsetY { get; public set; }
    private bool IsDistinguishedIdentity { get; }
    private string DebuggerDisplay { get; }
    public XMatrix(double m11, double m12, double m21, double m22, double offsetX, double offsetY);
    private static XMatrix();
    public static XMatrix get_Identity();
    public void SetIdentity();
    public bool get_IsIdentity();
    public Double[] GetElements();
    public static XMatrix op_Multiply(XMatrix trans1, XMatrix trans2);
    public static XMatrix Multiply(XMatrix trans1, XMatrix trans2);
    public void Append(XMatrix matrix);
    public void Prepend(XMatrix matrix);
    public void Multiply(XMatrix matrix, XMatrixOrder order);
    [ObsoleteAttribute("Use TranslateAppend or TranslatePrepend explicitly, because in GDI+ and WPF the defaults are contrary.", "True")]
public void Translate(double offsetX, double offsetY);
    public void TranslateAppend(double offsetX, double offsetY);
    public void TranslatePrepend(double offsetX, double offsetY);
    public void Translate(double offsetX, double offsetY, XMatrixOrder order);
    [ObsoleteAttribute("Use ScaleAppend or ScalePrepend explicitly, because in GDI+ and WPF the defaults are contrary.", "True")]
public void Scale(double scaleX, double scaleY);
    public void ScaleAppend(double scaleX, double scaleY);
    public void ScalePrepend(double scaleX, double scaleY);
    public void Scale(double scaleX, double scaleY, XMatrixOrder order);
    [ObsoleteAttribute("Use ScaleAppend or ScalePrepend explicitly, because in GDI+ and WPF the defaults are contrary.", "True")]
public void Scale(double scaleXY);
    public void ScaleAppend(double scaleXY);
    public void ScalePrepend(double scaleXY);
    public void Scale(double scaleXY, XMatrixOrder order);
    [ObsoleteAttribute("Use ScaleAtAppend or ScaleAtPrepend explicitly, because in GDI+ and WPF the defaults are contrary.", "True")]
public void ScaleAt(double scaleX, double scaleY, double centerX, double centerY);
    public void ScaleAtAppend(double scaleX, double scaleY, double centerX, double centerY);
    public void ScaleAtPrepend(double scaleX, double scaleY, double centerX, double centerY);
    [ObsoleteAttribute("Use RotateAppend or RotatePrepend explicitly, because in GDI+ and WPF the defaults are contrary.", "True")]
public void Rotate(double angle);
    public void RotateAppend(double angle);
    public void RotatePrepend(double angle);
    public void Rotate(double angle, XMatrixOrder order);
    [ObsoleteAttribute("Use RotateAtAppend or RotateAtPrepend explicitly, because in GDI+ and WPF the defaults are contrary.", "True")]
public void RotateAt(double angle, double centerX, double centerY);
    public void RotateAtAppend(double angle, double centerX, double centerY);
    public void RotateAtPrepend(double angle, double centerX, double centerY);
    [ObsoleteAttribute("Use RotateAtAppend or RotateAtPrepend explicitly, because in GDI+ and WPF the defaults are contrary.", "True")]
public void RotateAt(double angle, XPoint point);
    public void RotateAtAppend(double angle, XPoint point);
    public void RotateAtPrepend(double angle, XPoint point);
    public void RotateAt(double angle, XPoint point, XMatrixOrder order);
    [ObsoleteAttribute("Use ShearAppend or ShearPrepend explicitly, because in GDI+ and WPF the defaults are contrary.", "True")]
public void Shear(double shearX, double shearY);
    public void ShearAppend(double shearX, double shearY);
    public void ShearPrepend(double shearX, double shearY);
    public void Shear(double shearX, double shearY, XMatrixOrder order);
    [ObsoleteAttribute("Use SkewAppend or SkewPrepend explicitly, because in GDI+ and WPF the defaults are contrary.", "True")]
public void Skew(double skewX, double skewY);
    public void SkewAppend(double skewX, double skewY);
    public void SkewPrepend(double skewX, double skewY);
    public XPoint Transform(XPoint point);
    public void Transform(XPoint[] points);
    public void TransformPoints(XPoint[] points);
    public XVector Transform(XVector vector);
    public void Transform(XVector[] vectors);
    public double get_Determinant();
    public bool get_HasInverse();
    public void Invert();
    public double get_M11();
    public void set_M11(double value);
    public double get_M12();
    public void set_M12(double value);
    public double get_M21();
    public void set_M21(double value);
    public double get_M22();
    public void set_M22(double value);
    public double get_OffsetX();
    public void set_OffsetX(double value);
    public double get_OffsetY();
    public void set_OffsetY(double value);
    public static bool op_Equality(XMatrix matrix1, XMatrix matrix2);
    public static bool op_Inequality(XMatrix matrix1, XMatrix matrix2);
    public static bool Equals(XMatrix matrix1, XMatrix matrix2);
    public virtual bool Equals(object o);
    public bool Equals(XMatrix value);
    public virtual int GetHashCode();
    public static XMatrix Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    internal void MultiplyVector(Double& x, Double& y);
    internal void MultiplyPoint(Double& x, Double& y);
    internal static XMatrix CreateTranslation(double offsetX, double offsetY);
    internal static XMatrix CreateRotationRadians(double angle);
    internal static XMatrix CreateRotationRadians(double angle, double centerX, double centerY);
    internal static XMatrix CreateScaling(double scaleX, double scaleY);
    internal static XMatrix CreateScaling(double scaleX, double scaleY, double centerX, double centerY);
    internal static XMatrix CreateSkewRadians(double skewX, double skewY, double centerX, double centerY);
    internal static XMatrix CreateSkewRadians(double skewX, double skewY);
    private static XMatrix CreateIdentity();
    private void SetMatrix(double m11, double m12, double m21, double m22, double offsetX, double offsetY, XMatrixTypes type);
    private void DeriveMatrixType();
    private bool get_IsDistinguishedIdentity();
    private string get_DebuggerDisplay();
}
public enum PdfSharpCore.Drawing.XMatrixOrder : Enum {
    public int value__;
    public static XMatrixOrder Prepend;
    public static XMatrixOrder Append;
}
public enum PdfSharpCore.Drawing.XPageDirection : Enum {
    public int value__;
    public static XPageDirection Downwards;
    [ObsoleteAttribute("Not implemeted - yagni")]
public static XPageDirection Upwards;
}
public class PdfSharpCore.Drawing.XPdfFontOptions : object {
    private PdfFontEncoding _fontEncoding;
    public PdfFontEncoding FontEncoding { get; }
    public static XPdfFontOptions WinAnsiDefault { get; }
    public static XPdfFontOptions UnicodeDefault { get; }
    public XPdfFontOptions(PdfFontEncoding encoding);
    public PdfFontEncoding get_FontEncoding();
    public static XPdfFontOptions get_WinAnsiDefault();
    public static XPdfFontOptions get_UnicodeDefault();
}
public class PdfSharpCore.Drawing.XPdfForm : XForm {
    private bool _disposed;
    private XImage _placeHolder;
    private int _pageCount;
    private int _pageNumber;
    internal PdfDocument _externalDocument;
    private PdfReadAccuracy _pathReadAccuracy;
    public XImage PlaceHolder { get; public set; }
    public PdfPage Page { get; }
    public int PageCount { get; }
    public double PointWidth { get; }
    public double PointHeight { get; }
    public int PixelWidth { get; }
    public int PixelHeight { get; }
    public XSize Size { get; }
    public XMatrix Transform { get; public set; }
    public int PageNumber { get; public set; }
    public int PageIndex { get; public set; }
    internal PdfDocument ExternalDocument { get; }
    internal XPdfForm(string path, PdfReadAccuracy accuracy);
    internal XPdfForm(Stream stream, PdfReadAccuracy accuracy);
    internal XPdfForm(Stream stream, string password, PdfReadAccuracy accuracy);
    public static XPdfForm FromFile(string path);
    public static XPdfForm FromFile(string path, PdfReadAccuracy accuracy);
    public static XPdfForm FromStream(Stream stream);
    public static XPdfForm FromStream(Stream stream, PdfReadAccuracy accuracy);
    public static XPdfForm FromStream(Stream stream, string password);
    public static XPdfForm FromStream(Stream stream, string password, PdfReadAccuracy accuracy);
    internal virtual void Finish();
    protected virtual void Dispose(bool disposing);
    public XImage get_PlaceHolder();
    public void set_PlaceHolder(XImage value);
    public PdfPage get_Page();
    public int get_PageCount();
    public virtual double get_PointWidth();
    public virtual double get_PointHeight();
    public virtual int get_PixelWidth();
    public virtual int get_PixelHeight();
    public virtual XSize get_Size();
    public virtual XMatrix get_Transform();
    public virtual void set_Transform(XMatrix value);
    public int get_PageNumber();
    public void set_PageNumber(int value);
    public int get_PageIndex();
    public void set_PageIndex(int value);
    internal PdfDocument get_ExternalDocument();
    public static string ExtractPageNumber(string path, Int32& pageNumber);
}
public class PdfSharpCore.Drawing.XPen : object {
    internal XBrush _brush;
    internal XColor _color;
    internal double _width;
    internal XLineJoin _lineJoin;
    internal XLineCap _lineCap;
    internal double _miterLimit;
    internal XDashStyle _dashStyle;
    internal double _dashOffset;
    internal Double[] _dashPattern;
    internal bool _overprint;
    private bool _dirty;
    private bool _immutable;
    public XBrush Brush { get; public set; }
    public XColor Color { get; public set; }
    public double Width { get; public set; }
    public XLineJoin LineJoin { get; public set; }
    public XLineCap LineCap { get; public set; }
    public double MiterLimit { get; public set; }
    public XDashStyle DashStyle { get; public set; }
    public double DashOffset { get; public set; }
    public Double[] DashPattern { get; public set; }
    public bool Overprint { get; public set; }
    public XPen(XColor color);
    public XPen(XColor color, double width);
    internal XPen(XColor color, double width, bool immutable);
    public XPen(XBrush brush);
    public XPen(XBrush brush, double width);
    internal XPen(XBrush brush, double width, bool immutable);
    public XPen(XPen pen);
    public XPen Clone();
    public XBrush get_Brush();
    public void set_Brush(XBrush value);
    public XColor get_Color();
    public void set_Color(XColor value);
    public double get_Width();
    public void set_Width(double value);
    public XLineJoin get_LineJoin();
    public void set_LineJoin(XLineJoin value);
    public XLineCap get_LineCap();
    public void set_LineCap(XLineCap value);
    public double get_MiterLimit();
    public void set_MiterLimit(double value);
    public XDashStyle get_DashStyle();
    public void set_DashStyle(XDashStyle value);
    public double get_DashOffset();
    public void set_DashOffset(double value);
    public Double[] get_DashPattern();
    public void set_DashPattern(Double[] value);
    public bool get_Overprint();
    public void set_Overprint(bool value);
}
public static class PdfSharpCore.Drawing.XPens : object {
    public static XPen AliceBlue { get; }
    public static XPen AntiqueWhite { get; }
    public static XPen Aqua { get; }
    public static XPen Aquamarine { get; }
    public static XPen Azure { get; }
    public static XPen Beige { get; }
    public static XPen Bisque { get; }
    public static XPen Black { get; }
    public static XPen BlanchedAlmond { get; }
    public static XPen Blue { get; }
    public static XPen BlueViolet { get; }
    public static XPen Brown { get; }
    public static XPen BurlyWood { get; }
    public static XPen CadetBlue { get; }
    public static XPen Chartreuse { get; }
    public static XPen Chocolate { get; }
    public static XPen Coral { get; }
    public static XPen CornflowerBlue { get; }
    public static XPen Cornsilk { get; }
    public static XPen Crimson { get; }
    public static XPen Cyan { get; }
    public static XPen DarkBlue { get; }
    public static XPen DarkCyan { get; }
    public static XPen DarkGoldenrod { get; }
    public static XPen DarkGray { get; }
    public static XPen DarkGreen { get; }
    public static XPen DarkKhaki { get; }
    public static XPen DarkMagenta { get; }
    public static XPen DarkOliveGreen { get; }
    public static XPen DarkOrange { get; }
    public static XPen DarkOrchid { get; }
    public static XPen DarkRed { get; }
    public static XPen DarkSalmon { get; }
    public static XPen DarkSeaGreen { get; }
    public static XPen DarkSlateBlue { get; }
    public static XPen DarkSlateGray { get; }
    public static XPen DarkTurquoise { get; }
    public static XPen DarkViolet { get; }
    public static XPen DeepPink { get; }
    public static XPen DeepSkyBlue { get; }
    public static XPen DimGray { get; }
    public static XPen DodgerBlue { get; }
    public static XPen Firebrick { get; }
    public static XPen FloralWhite { get; }
    public static XPen ForestGreen { get; }
    public static XPen Fuchsia { get; }
    public static XPen Gainsboro { get; }
    public static XPen GhostWhite { get; }
    public static XPen Gold { get; }
    public static XPen Goldenrod { get; }
    public static XPen Gray { get; }
    public static XPen Green { get; }
    public static XPen GreenYellow { get; }
    public static XPen Honeydew { get; }
    public static XPen HotPink { get; }
    public static XPen IndianRed { get; }
    public static XPen Indigo { get; }
    public static XPen Ivory { get; }
    public static XPen Khaki { get; }
    public static XPen Lavender { get; }
    public static XPen LavenderBlush { get; }
    public static XPen LawnGreen { get; }
    public static XPen LemonChiffon { get; }
    public static XPen LightBlue { get; }
    public static XPen LightCoral { get; }
    public static XPen LightCyan { get; }
    public static XPen LightGoldenrodYellow { get; }
    public static XPen LightGray { get; }
    public static XPen LightGreen { get; }
    public static XPen LightPink { get; }
    public static XPen LightSalmon { get; }
    public static XPen LightSeaGreen { get; }
    public static XPen LightSkyBlue { get; }
    public static XPen LightSlateGray { get; }
    public static XPen LightSteelBlue { get; }
    public static XPen LightYellow { get; }
    public static XPen Lime { get; }
    public static XPen LimeGreen { get; }
    public static XPen Linen { get; }
    public static XPen Magenta { get; }
    public static XPen Maroon { get; }
    public static XPen MediumAquamarine { get; }
    public static XPen MediumBlue { get; }
    public static XPen MediumOrchid { get; }
    public static XPen MediumPurple { get; }
    public static XPen MediumSeaGreen { get; }
    public static XPen MediumSlateBlue { get; }
    public static XPen MediumSpringGreen { get; }
    public static XPen MediumTurquoise { get; }
    public static XPen MediumVioletRed { get; }
    public static XPen MidnightBlue { get; }
    public static XPen MintCream { get; }
    public static XPen MistyRose { get; }
    public static XPen Moccasin { get; }
    public static XPen NavajoWhite { get; }
    public static XPen Navy { get; }
    public static XPen OldLace { get; }
    public static XPen Olive { get; }
    public static XPen OliveDrab { get; }
    public static XPen Orange { get; }
    public static XPen OrangeRed { get; }
    public static XPen Orchid { get; }
    public static XPen PaleGoldenrod { get; }
    public static XPen PaleGreen { get; }
    public static XPen PaleTurquoise { get; }
    public static XPen PaleVioletRed { get; }
    public static XPen PapayaWhip { get; }
    public static XPen PeachPuff { get; }
    public static XPen Peru { get; }
    public static XPen Pink { get; }
    public static XPen Plum { get; }
    public static XPen PowderBlue { get; }
    public static XPen Purple { get; }
    public static XPen Red { get; }
    public static XPen RosyBrown { get; }
    public static XPen RoyalBlue { get; }
    public static XPen SaddleBrown { get; }
    public static XPen Salmon { get; }
    public static XPen SandyBrown { get; }
    public static XPen SeaGreen { get; }
    public static XPen SeaShell { get; }
    public static XPen Sienna { get; }
    public static XPen Silver { get; }
    public static XPen SkyBlue { get; }
    public static XPen SlateBlue { get; }
    public static XPen SlateGray { get; }
    public static XPen Snow { get; }
    public static XPen SpringGreen { get; }
    public static XPen SteelBlue { get; }
    public static XPen Tan { get; }
    public static XPen Teal { get; }
    public static XPen Thistle { get; }
    public static XPen Tomato { get; }
    public static XPen Transparent { get; }
    public static XPen Turquoise { get; }
    public static XPen Violet { get; }
    public static XPen Wheat { get; }
    public static XPen White { get; }
    public static XPen WhiteSmoke { get; }
    public static XPen Yellow { get; }
    public static XPen YellowGreen { get; }
    public static XPen get_AliceBlue();
    public static XPen get_AntiqueWhite();
    public static XPen get_Aqua();
    public static XPen get_Aquamarine();
    public static XPen get_Azure();
    public static XPen get_Beige();
    public static XPen get_Bisque();
    public static XPen get_Black();
    public static XPen get_BlanchedAlmond();
    public static XPen get_Blue();
    public static XPen get_BlueViolet();
    public static XPen get_Brown();
    public static XPen get_BurlyWood();
    public static XPen get_CadetBlue();
    public static XPen get_Chartreuse();
    public static XPen get_Chocolate();
    public static XPen get_Coral();
    public static XPen get_CornflowerBlue();
    public static XPen get_Cornsilk();
    public static XPen get_Crimson();
    public static XPen get_Cyan();
    public static XPen get_DarkBlue();
    public static XPen get_DarkCyan();
    public static XPen get_DarkGoldenrod();
    public static XPen get_DarkGray();
    public static XPen get_DarkGreen();
    public static XPen get_DarkKhaki();
    public static XPen get_DarkMagenta();
    public static XPen get_DarkOliveGreen();
    public static XPen get_DarkOrange();
    public static XPen get_DarkOrchid();
    public static XPen get_DarkRed();
    public static XPen get_DarkSalmon();
    public static XPen get_DarkSeaGreen();
    public static XPen get_DarkSlateBlue();
    public static XPen get_DarkSlateGray();
    public static XPen get_DarkTurquoise();
    public static XPen get_DarkViolet();
    public static XPen get_DeepPink();
    public static XPen get_DeepSkyBlue();
    public static XPen get_DimGray();
    public static XPen get_DodgerBlue();
    public static XPen get_Firebrick();
    public static XPen get_FloralWhite();
    public static XPen get_ForestGreen();
    public static XPen get_Fuchsia();
    public static XPen get_Gainsboro();
    public static XPen get_GhostWhite();
    public static XPen get_Gold();
    public static XPen get_Goldenrod();
    public static XPen get_Gray();
    public static XPen get_Green();
    public static XPen get_GreenYellow();
    public static XPen get_Honeydew();
    public static XPen get_HotPink();
    public static XPen get_IndianRed();
    public static XPen get_Indigo();
    public static XPen get_Ivory();
    public static XPen get_Khaki();
    public static XPen get_Lavender();
    public static XPen get_LavenderBlush();
    public static XPen get_LawnGreen();
    public static XPen get_LemonChiffon();
    public static XPen get_LightBlue();
    public static XPen get_LightCoral();
    public static XPen get_LightCyan();
    public static XPen get_LightGoldenrodYellow();
    public static XPen get_LightGray();
    public static XPen get_LightGreen();
    public static XPen get_LightPink();
    public static XPen get_LightSalmon();
    public static XPen get_LightSeaGreen();
    public static XPen get_LightSkyBlue();
    public static XPen get_LightSlateGray();
    public static XPen get_LightSteelBlue();
    public static XPen get_LightYellow();
    public static XPen get_Lime();
    public static XPen get_LimeGreen();
    public static XPen get_Linen();
    public static XPen get_Magenta();
    public static XPen get_Maroon();
    public static XPen get_MediumAquamarine();
    public static XPen get_MediumBlue();
    public static XPen get_MediumOrchid();
    public static XPen get_MediumPurple();
    public static XPen get_MediumSeaGreen();
    public static XPen get_MediumSlateBlue();
    public static XPen get_MediumSpringGreen();
    public static XPen get_MediumTurquoise();
    public static XPen get_MediumVioletRed();
    public static XPen get_MidnightBlue();
    public static XPen get_MintCream();
    public static XPen get_MistyRose();
    public static XPen get_Moccasin();
    public static XPen get_NavajoWhite();
    public static XPen get_Navy();
    public static XPen get_OldLace();
    public static XPen get_Olive();
    public static XPen get_OliveDrab();
    public static XPen get_Orange();
    public static XPen get_OrangeRed();
    public static XPen get_Orchid();
    public static XPen get_PaleGoldenrod();
    public static XPen get_PaleGreen();
    public static XPen get_PaleTurquoise();
    public static XPen get_PaleVioletRed();
    public static XPen get_PapayaWhip();
    public static XPen get_PeachPuff();
    public static XPen get_Peru();
    public static XPen get_Pink();
    public static XPen get_Plum();
    public static XPen get_PowderBlue();
    public static XPen get_Purple();
    public static XPen get_Red();
    public static XPen get_RosyBrown();
    public static XPen get_RoyalBlue();
    public static XPen get_SaddleBrown();
    public static XPen get_Salmon();
    public static XPen get_SandyBrown();
    public static XPen get_SeaGreen();
    public static XPen get_SeaShell();
    public static XPen get_Sienna();
    public static XPen get_Silver();
    public static XPen get_SkyBlue();
    public static XPen get_SlateBlue();
    public static XPen get_SlateGray();
    public static XPen get_Snow();
    public static XPen get_SpringGreen();
    public static XPen get_SteelBlue();
    public static XPen get_Tan();
    public static XPen get_Teal();
    public static XPen get_Thistle();
    public static XPen get_Tomato();
    public static XPen get_Transparent();
    public static XPen get_Turquoise();
    public static XPen get_Violet();
    public static XPen get_Wheat();
    public static XPen get_White();
    public static XPen get_WhiteSmoke();
    public static XPen get_Yellow();
    public static XPen get_YellowGreen();
}
internal class PdfSharpCore.Drawing.XPngBitmapDecoder : XBitmapDecoder {
}
internal class PdfSharpCore.Drawing.XPngBitmapEncoder : XBitmapEncoder {
    public virtual void Save(Stream stream);
}
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharpCore.Drawing.XPoint : ValueType {
    private double _x;
    private double _y;
    public double X { get; public set; }
    public double Y { get; public set; }
    private string DebuggerDisplay { get; }
    public XPoint(double x, double y);
    public static bool op_Equality(XPoint point1, XPoint point2);
    public static bool op_Inequality(XPoint point1, XPoint point2);
    public static bool Equals(XPoint point1, XPoint point2);
    public virtual bool Equals(object o);
    public bool Equals(XPoint value);
    public virtual int GetHashCode();
    public static XPoint Parse(string source);
    public static XPoint[] ParsePoints(string value);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public void Offset(double offsetX, double offsetY);
    public static XPoint op_Addition(XPoint point, XVector vector);
    public static XPoint op_Addition(XPoint point, XSize size);
    public static XPoint Add(XPoint point, XVector vector);
    public static XPoint op_Subtraction(XPoint point, XVector vector);
    public static XPoint Subtract(XPoint point, XVector vector);
    public static XVector op_Subtraction(XPoint point1, XPoint point2);
    public static XVector Subtract(XPoint point1, XPoint point2);
    public static XPoint op_Multiply(XPoint point, XMatrix matrix);
    public static XPoint Multiply(XPoint point, XMatrix matrix);
    public static XPoint op_Multiply(XPoint point, double value);
    public static XPoint op_Multiply(double value, XPoint point);
    public static XSize op_Explicit(XPoint point);
    public static XVector op_Explicit(XPoint point);
    private string get_DebuggerDisplay();
}
public class PdfSharpCore.Drawing.XPrivateFontCollection : object {
    internal static XPrivateFontCollection _singleton;
    private Dictionary`2<string, XGlyphTypeface> _typefaces;
    internal static XPrivateFontCollection Singleton { get; }
    private static XPrivateFontCollection();
    internal static XPrivateFontCollection get_Singleton();
    private static string MakeKey(string familyName, XFontStyle style);
    private static string MakeKey(string familyName, bool bold, bool italic);
}
public class PdfSharpCore.Drawing.XRadialGradientBrush : XBaseGradientBrush {
    internal XPoint _center1;
    internal XPoint _center2;
    internal double _r1;
    internal double _r2;
    public XRadialGradientBrush(XPoint center1, XPoint center2, double r1, double r2, XColor color1, XColor color2);
    public XRadialGradientBrush(XPoint center, double r1, double r2, XColor color1, XColor color2);
}
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharpCore.Drawing.XRect : ValueType {
    private double _x;
    private double _y;
    private double _width;
    private double _height;
    private static XRect s_empty;
    public static XRect Empty { get; }
    public bool IsEmpty { get; }
    public XPoint Location { get; public set; }
    public XSize Size { get; public set; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Width { get; public set; }
    public double Height { get; public set; }
    public double Left { get; }
    public double Top { get; }
    public double Right { get; }
    public double Bottom { get; }
    public XPoint TopLeft { get; }
    public XPoint TopRight { get; }
    public XPoint BottomLeft { get; }
    public XPoint BottomRight { get; }
    public XPoint Center { get; }
    private string DebuggerDisplay { get; }
    public XRect(double x, double y, double width, double height);
    public XRect(XPoint point1, XPoint point2);
    public XRect(XPoint point, XVector vector);
    public XRect(XPoint location, XSize size);
    public XRect(XSize size);
    private static XRect();
    public static XRect FromLTRB(double left, double top, double right, double bottom);
    public static bool op_Equality(XRect rect1, XRect rect2);
    public static bool op_Inequality(XRect rect1, XRect rect2);
    public static bool Equals(XRect rect1, XRect rect2);
    public virtual bool Equals(object o);
    public bool Equals(XRect value);
    public virtual int GetHashCode();
    public static XRect Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public static XRect get_Empty();
    public bool get_IsEmpty();
    public XPoint get_Location();
    public void set_Location(XPoint value);
    public XSize get_Size();
    public void set_Size(XSize value);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Width();
    public void set_Width(double value);
    public double get_Height();
    public void set_Height(double value);
    public double get_Left();
    public double get_Top();
    public double get_Right();
    public double get_Bottom();
    public XPoint get_TopLeft();
    public XPoint get_TopRight();
    public XPoint get_BottomLeft();
    public XPoint get_BottomRight();
    public XPoint get_Center();
    public bool Contains(XPoint point);
    public bool Contains(double x, double y);
    public bool Contains(XRect rect);
    public bool IntersectsWith(XRect rect);
    public void Intersect(XRect rect);
    public static XRect Intersect(XRect rect1, XRect rect2);
    public void Union(XRect rect);
    public static XRect Union(XRect rect1, XRect rect2);
    public void Union(XPoint point);
    public static XRect Union(XRect rect, XPoint point);
    public void Offset(XVector offsetVector);
    public void Offset(double offsetX, double offsetY);
    public static XRect Offset(XRect rect, XVector offsetVector);
    public static XRect Offset(XRect rect, double offsetX, double offsetY);
    public static XRect op_Addition(XRect rect, XPoint point);
    public static XRect op_Subtraction(XRect rect, XPoint point);
    public void Inflate(XSize size);
    public void Inflate(double width, double height);
    public static XRect Inflate(XRect rect, XSize size);
    public static XRect Inflate(XRect rect, double width, double height);
    public static XRect Transform(XRect rect, XMatrix matrix);
    public void Transform(XMatrix matrix);
    public void Scale(double scaleX, double scaleY);
    private bool ContainsInternal(double x, double y);
    private static XRect CreateEmptyRect();
    private string get_DebuggerDisplay();
}
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharpCore.Drawing.XSize : ValueType {
    private static XSize s_empty;
    private double _width;
    private double _height;
    public static XSize Empty { get; }
    public bool IsEmpty { get; }
    public double Width { get; public set; }
    public double Height { get; public set; }
    private string DebuggerDisplay { get; }
    public XSize(double width, double height);
    private static XSize();
    public static bool op_Equality(XSize size1, XSize size2);
    public static bool op_Inequality(XSize size1, XSize size2);
    public static bool Equals(XSize size1, XSize size2);
    public virtual bool Equals(object o);
    public bool Equals(XSize value);
    public virtual int GetHashCode();
    public static XSize Parse(string source);
    public XPoint ToXPoint();
    public XVector ToXVector();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public static XSize get_Empty();
    public bool get_IsEmpty();
    public double get_Width();
    public void set_Width(double value);
    public double get_Height();
    public void set_Height(double value);
    public static XVector op_Explicit(XSize size);
    public static XPoint op_Explicit(XSize size);
    private static XSize CreateEmptySize();
    private string get_DebuggerDisplay();
}
[FlagsAttribute]
public enum PdfSharpCore.Drawing.XSmoothingMode : Enum {
    public int value__;
    public static XSmoothingMode Invalid;
    public static XSmoothingMode Default;
    public static XSmoothingMode HighSpeed;
    public static XSmoothingMode HighQuality;
    public static XSmoothingMode None;
    public static XSmoothingMode AntiAlias;
}
public class PdfSharpCore.Drawing.XSolidBrush : XBrush {
    internal XColor _color;
    internal bool _overprint;
    private bool _immutable;
    public XColor Color { get; public set; }
    public bool Overprint { get; public set; }
    public XSolidBrush(XColor color);
    internal XSolidBrush(XColor color, bool immutable);
    public XSolidBrush(XSolidBrush brush);
    public XColor get_Color();
    public void set_Color(XColor value);
    public bool get_Overprint();
    public void set_Overprint(bool value);
}
public enum PdfSharpCore.Drawing.XStringAlignment : Enum {
    public int value__;
    public static XStringAlignment Near;
    public static XStringAlignment Center;
    public static XStringAlignment Far;
}
public class PdfSharpCore.Drawing.XStringFormat : object {
    private XStringAlignment _alignment;
    private XLineAlignment _lineAlignment;
    public XStringAlignment Alignment { get; public set; }
    public XLineAlignment LineAlignment { get; public set; }
    public XStringAlignment get_Alignment();
    public void set_Alignment(XStringAlignment value);
    public XLineAlignment get_LineAlignment();
    public void set_LineAlignment(XLineAlignment value);
}
public static class PdfSharpCore.Drawing.XStringFormats : object {
    public static XStringFormat Default { get; }
    public static XStringFormat BaseLineLeft { get; }
    public static XStringFormat TopLeft { get; }
    public static XStringFormat CenterLeft { get; }
    public static XStringFormat BottomLeft { get; }
    public static XStringFormat BaseLineCenter { get; }
    public static XStringFormat TopCenter { get; }
    public static XStringFormat Center { get; }
    public static XStringFormat BottomCenter { get; }
    public static XStringFormat BaseLineRight { get; }
    public static XStringFormat TopRight { get; }
    public static XStringFormat CenterRight { get; }
    public static XStringFormat BottomRight { get; }
    public static XStringFormat get_Default();
    public static XStringFormat get_BaseLineLeft();
    public static XStringFormat get_TopLeft();
    public static XStringFormat get_CenterLeft();
    public static XStringFormat get_BottomLeft();
    public static XStringFormat get_BaseLineCenter();
    public static XStringFormat get_TopCenter();
    public static XStringFormat get_Center();
    public static XStringFormat get_BottomCenter();
    public static XStringFormat get_BaseLineRight();
    public static XStringFormat get_TopRight();
    public static XStringFormat get_CenterRight();
    public static XStringFormat get_BottomRight();
}
[FlagsAttribute]
public enum PdfSharpCore.Drawing.XStyleSimulations : Enum {
    public int value__;
    public static XStyleSimulations None;
    public static XStyleSimulations BoldSimulation;
    public static XStyleSimulations ItalicSimulation;
    public static XStyleSimulations BoldItalicSimulation;
}
public enum PdfSharpCore.Drawing.XSweepDirection : Enum {
    public int value__;
    public static XSweepDirection Counterclockwise;
    public static XSweepDirection Clockwise;
}
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharpCore.Drawing.XUnit : ValueType {
    internal static double PointFactor;
    internal static double InchFactor;
    internal static double MillimeterFactor;
    internal static double CentimeterFactor;
    internal static double PresentationFactor;
    internal static double PointFactorWpf;
    internal static double InchFactorWpf;
    internal static double MillimeterFactorWpf;
    internal static double CentimeterFactorWpf;
    internal static double PresentationFactorWpf;
    public static XUnit Zero;
    private double _value;
    private XGraphicsUnit _type;
    public double Value { get; }
    public XGraphicsUnit Type { get; }
    public double Point { get; public set; }
    public double Inch { get; public set; }
    public double Millimeter { get; public set; }
    public double Centimeter { get; public set; }
    public double Presentation { get; public set; }
    private string DebuggerDisplay { get; }
    public XUnit(double point);
    public XUnit(double value, XGraphicsUnit type);
    private static XUnit();
    public double get_Value();
    public XGraphicsUnit get_Type();
    public double get_Point();
    public void set_Point(double value);
    public double get_Inch();
    public void set_Inch(double value);
    public double get_Millimeter();
    public void set_Millimeter(double value);
    public double get_Centimeter();
    public void set_Centimeter(double value);
    public double get_Presentation();
    public void set_Presentation(double value);
    public string ToString(IFormatProvider formatProvider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
    public virtual string ToString();
    private string GetSuffix();
    public static XUnit FromPoint(double value);
    public static XUnit FromInch(double value);
    public static XUnit FromMillimeter(double value);
    public static XUnit FromCentimeter(double value);
    public static XUnit FromPresentation(double value);
    public static XUnit op_Implicit(string value);
    public static XUnit op_Implicit(int value);
    public static XUnit op_Implicit(double value);
    public static double op_Implicit(XUnit value);
    public static bool op_Equality(XUnit value1, XUnit value2);
    public static bool op_Inequality(XUnit value1, XUnit value2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static XUnit Parse(string value);
    public void ConvertType(XGraphicsUnit type);
    private string get_DebuggerDisplay();
}
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharpCore.Drawing.XVector : ValueType {
    private double _x;
    private double _y;
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Length { get; }
    public double LengthSquared { get; }
    private string DebuggerDisplay { get; }
    public XVector(double x, double y);
    public static bool op_Equality(XVector vector1, XVector vector2);
    public static bool op_Inequality(XVector vector1, XVector vector2);
    public static bool Equals(XVector vector1, XVector vector2);
    public virtual bool Equals(object o);
    public bool Equals(XVector value);
    public virtual int GetHashCode();
    public static XVector Parse(string source);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public double get_Length();
    public double get_LengthSquared();
    public void Normalize();
    public static double CrossProduct(XVector vector1, XVector vector2);
    public static double AngleBetween(XVector vector1, XVector vector2);
    public static XVector op_UnaryNegation(XVector vector);
    public void Negate();
    public static XVector op_Addition(XVector vector1, XVector vector2);
    public static XVector Add(XVector vector1, XVector vector2);
    public static XVector op_Subtraction(XVector vector1, XVector vector2);
    public static XVector Subtract(XVector vector1, XVector vector2);
    public static XPoint op_Addition(XVector vector, XPoint point);
    public static XPoint Add(XVector vector, XPoint point);
    public static XVector op_Multiply(XVector vector, double scalar);
    public static XVector Multiply(XVector vector, double scalar);
    public static XVector op_Multiply(double scalar, XVector vector);
    public static XVector Multiply(double scalar, XVector vector);
    public static XVector op_Division(XVector vector, double scalar);
    public static XVector Divide(XVector vector, double scalar);
    public static XVector op_Multiply(XVector vector, XMatrix matrix);
    public static XVector Multiply(XVector vector, XMatrix matrix);
    public static double op_Multiply(XVector vector1, XVector vector2);
    public static double Multiply(XVector vector1, XVector vector2);
    public static double Determinant(XVector vector1, XVector vector2);
    public static XSize op_Explicit(XVector vector);
    public static XPoint op_Explicit(XVector vector);
    private string get_DebuggerDisplay();
}
public class PdfSharpCore.Exceptions.PositionNotFoundException : Exception {
    public PositionNotFoundException(PdfObjectID id);
}
internal class PdfSharpCore.Fonts.CMapInfo : object {
    internal OpenTypeDescriptor _descriptor;
    public char MinChar;
    public char MaxChar;
    public Dictionary`2<char, int> CharacterToGlyphIndex;
    public Dictionary`2<int, object> GlyphIndices;
    public Char[] Chars { get; }
    public CMapInfo(OpenTypeDescriptor descriptor);
    public void AddChars(string text);
    public void AddGlyphIndices(string glyphIndices);
    internal void AddAnsiChars();
    internal bool Contains(char ch);
    public Char[] get_Chars();
    public Int32[] GetGlyphIndices();
}
internal class PdfSharpCore.Fonts.FontDescriptorCache : object {
    private static FontDescriptorCache modreq(System.Runtime.CompilerServices.IsVolatile) _singleton;
    private Dictionary`2<string, FontDescriptor> _cache;
    private static FontDescriptorCache Singleton { get; }
    public static FontDescriptor GetOrCreateDescriptorFor(XFont font);
    public static FontDescriptor GetOrCreateDescriptor(string fontFamilyName, XFontStyle style);
    public static FontDescriptor GetOrCreateDescriptor(string idName, Byte[] fontData);
    private static OpenTypeDescriptor GetOrCreateOpenTypeDescriptor(string fontDescriptorKey, string idName, Byte[] fontData);
    private static FontDescriptorCache get_Singleton();
}
internal static class PdfSharpCore.Fonts.FontFactory : object {
    private static Dictionary`2<string, FontResolverInfo> FontResolverInfosByName;
    private static Dictionary`2<string, XFontSource> FontSourcesByName;
    private static Dictionary`2<ulong, XFontSource> FontSourcesByKey;
    public static bool HasFontSources { get; }
    private static FontFactory();
    public static FontResolverInfo ResolveTypeface(string familyName, FontResolvingOptions fontResolvingOptions, string typefaceKey);
    public static XFontSource GetFontSourceByFontName(string fontName);
    public static XFontSource GetFontSourceByTypefaceKey(string typefaceKey);
    public static bool TryGetFontSourceByKey(ulong key, XFontSource& fontSource);
    public static bool get_HasFontSources();
    public static bool TryGetFontResolverInfoByTypefaceKey(string typeFaceKey, FontResolverInfo& info);
    public static bool TryGetFontSourceByTypefaceKey(string typefaceKey, XFontSource& source);
    internal static void CacheFontResolverInfo(string typefaceKey, FontResolverInfo fontResolverInfo);
    public static XFontSource CacheFontSource(XFontSource fontSource);
    public static XFontSource CacheNewFontSource(string typefaceKey, XFontSource fontSource);
    public static void CacheExistingFontSourceWithNewTypefaceKey(string typefaceKey, XFontSource fontSource);
    internal static string GetFontCachesState();
}
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharpCore.Fonts.FontResolverInfo : object {
    private static string KeyPrefix;
    private string _key;
    private string _faceName;
    private bool _mustSimulateBold;
    private bool _mustSimulateItalic;
    private int _collectionNumber;
    internal string Key { get; }
    public string FaceName { get; }
    public bool MustSimulateBold { get; }
    public bool MustSimulateItalic { get; }
    public XStyleSimulations StyleSimulations { get; }
    internal int CollectionNumber { get; }
    internal string DebuggerDisplay { get; }
    public FontResolverInfo(string faceName);
    internal FontResolverInfo(string faceName, bool mustSimulateBold, bool mustSimulateItalic, int collectionNumber);
    public FontResolverInfo(string faceName, bool mustSimulateBold, bool mustSimulateItalic);
    public FontResolverInfo(string faceName, XStyleSimulations styleSimulations);
    internal string get_Key();
    public string get_FaceName();
    public bool get_MustSimulateBold();
    public bool get_MustSimulateItalic();
    public XStyleSimulations get_StyleSimulations();
    internal int get_CollectionNumber();
    internal string get_DebuggerDisplay();
}
internal class PdfSharpCore.Fonts.FontResolvingOptions : object {
    public XFontStyle FontStyle;
    public bool OverrideStyleSimulations;
    public XStyleSimulations StyleSimulations;
    public bool IsBold { get; }
    public bool IsItalic { get; }
    public bool IsBoldItalic { get; }
    public bool MustSimulateBold { get; }
    public bool MustSimulateItalic { get; }
    public FontResolvingOptions(XFontStyle fontStyle);
    public FontResolvingOptions(XFontStyle fontStyle, XStyleSimulations styleSimulations);
    public bool get_IsBold();
    public bool get_IsItalic();
    public bool get_IsBoldItalic();
    public bool get_MustSimulateBold();
    public bool get_MustSimulateItalic();
}
internal class PdfSharpCore.Fonts.FontWriter : object {
    private Stream _stream;
    public int Position { get; public set; }
    internal Stream Stream { get; }
    public FontWriter(Stream stream);
    public void Close(bool closeUnderlyingStream);
    public void Close();
    public int get_Position();
    public void set_Position(int value);
    public void WriteByte(byte value);
    public void WriteByte(int value);
    public void WriteShort(short value);
    public void WriteShort(int value);
    public void WriteUShort(ushort value);
    public void WriteUShort(int value);
    public void WriteInt(int value);
    public void WriteUInt(UInt32 value);
    public void Write(Byte[] buffer);
    public void Write(Byte[] buffer, int offset, int count);
    internal Stream get_Stream();
}
public static class PdfSharpCore.Fonts.GlobalFontSettings : object {
    public static string DefaultFontName;
    private static IFontResolver _fontResolver;
    private static PdfFontEncoding _fontEncoding;
    private static bool _fontEncodingInitialized;
    public static IFontResolver FontResolver { get; public set; }
    public static PdfFontEncoding DefaultFontEncoding { get; public set; }
    public static IFontResolver get_FontResolver();
    public static void set_FontResolver(IFontResolver value);
    public static PdfFontEncoding get_DefaultFontEncoding();
    public static void set_DefaultFontEncoding(PdfFontEncoding value);
}
public interface PdfSharpCore.Fonts.IFontResolver {
    public string DefaultFontName { get; }
    public abstract virtual FontResolverInfo ResolveTypeface(string familyName, bool isBold, bool isItalic);
    public abstract virtual Byte[] GetFont(string faceName);
    public abstract virtual string get_DefaultFontName();
}
internal enum PdfSharpCore.Fonts.OpenType.AppleEncodingId : Enum {
    public int value__;
    public static AppleEncodingId Default;
    public static AppleEncodingId Version11;
    public static AppleEncodingId ISO;
    public static AppleEncodingId Unicode20BmpOnly;
    public static AppleEncodingId Unicode20;
    public static AppleEncodingId UnicodeVariation;
    public static AppleEncodingId FullUnicode;
}
internal class PdfSharpCore.Fonts.OpenType.CMap4 : OpenTypeFontTable {
    public WinEncodingId encodingId;
    public ushort format;
    public ushort length;
    public ushort language;
    public ushort segCountX2;
    public ushort searchRange;
    public ushort entrySelector;
    public ushort rangeShift;
    public UInt16[] endCount;
    public UInt16[] startCount;
    public Int16[] idDelta;
    public UInt16[] idRangeOffs;
    public int glyphCount;
    public UInt16[] glyphIdArray;
    public CMap4(OpenTypeFontface fontData, WinEncodingId encodingId);
    internal void Read();
}
internal class PdfSharpCore.Fonts.OpenType.CMapTable : OpenTypeFontTable {
    public static string Tag;
    public ushort version;
    public ushort numTables;
    public bool symbol;
    public CMap4 cmap4;
    public CMapTable(OpenTypeFontface fontData);
    internal void Read();
}
internal class PdfSharpCore.Fonts.OpenType.ControlValueProgram : OpenTypeFontTable {
    public static string Tag;
    private Byte[] bytes;
    public ControlValueProgram(OpenTypeFontface fontData);
    public void Read();
}
internal class PdfSharpCore.Fonts.OpenType.ControlValueTable : OpenTypeFontTable {
    public static string Tag;
    private Int16[] array;
    public ControlValueTable(OpenTypeFontface fontData);
    public void Read();
}
internal class PdfSharpCore.Fonts.OpenType.FontDescriptor : object {
    private string _key;
    private string _fontName;
    private string _weight;
    private float _italicAngle;
    private int _xMin;
    private int _yMin;
    private int _xMax;
    private int _yMax;
    private bool _isFixedPitch;
    private int _underlinePosition;
    private int _underlineThickness;
    private int _strikeoutPosition;
    private int _strikeoutSize;
    private string _version;
    private string _encodingScheme;
    private int _unitsPerEm;
    private int _capHeight;
    private int _xHeight;
    private int _ascender;
    private int _descender;
    private int _leading;
    private int _flags;
    private int _stemV;
    private int _lineSpacing;
    public string Key { get; }
    public string FontName { get; protected set; }
    public string Weight { get; private set; }
    public bool IsBoldFace { get; }
    public float ItalicAngle { get; protected set; }
    public bool IsItalicFace { get; }
    public int XMin { get; protected set; }
    public int YMin { get; protected set; }
    public int XMax { get; protected set; }
    public int YMax { get; protected set; }
    public bool IsFixedPitch { get; private set; }
    public int UnderlinePosition { get; protected set; }
    public int UnderlineThickness { get; protected set; }
    public int StrikeoutPosition { get; protected set; }
    public int StrikeoutSize { get; protected set; }
    public string Version { get; private set; }
    public string EncodingScheme { get; private set; }
    public int UnitsPerEm { get; protected set; }
    public int CapHeight { get; protected set; }
    public int XHeight { get; protected set; }
    public int Ascender { get; protected set; }
    public int Descender { get; protected set; }
    public int Leading { get; protected set; }
    public int Flags { get; private set; }
    public int StemV { get; protected set; }
    public int LineSpacing { get; protected set; }
    protected FontDescriptor(string key);
    public string get_Key();
    public string get_FontName();
    protected void set_FontName(string value);
    public string get_Weight();
    private void set_Weight(string value);
    public virtual bool get_IsBoldFace();
    public float get_ItalicAngle();
    protected void set_ItalicAngle(float value);
    public virtual bool get_IsItalicFace();
    public int get_XMin();
    protected void set_XMin(int value);
    public int get_YMin();
    protected void set_YMin(int value);
    public int get_XMax();
    protected void set_XMax(int value);
    public int get_YMax();
    protected void set_YMax(int value);
    public bool get_IsFixedPitch();
    private void set_IsFixedPitch(bool value);
    public int get_UnderlinePosition();
    protected void set_UnderlinePosition(int value);
    public int get_UnderlineThickness();
    protected void set_UnderlineThickness(int value);
    public int get_StrikeoutPosition();
    protected void set_StrikeoutPosition(int value);
    public int get_StrikeoutSize();
    protected void set_StrikeoutSize(int value);
    public string get_Version();
    private void set_Version(string value);
    public string get_EncodingScheme();
    private void set_EncodingScheme(string value);
    public int get_UnitsPerEm();
    protected void set_UnitsPerEm(int value);
    public int get_CapHeight();
    protected void set_CapHeight(int value);
    public int get_XHeight();
    protected void set_XHeight(int value);
    public int get_Ascender();
    protected void set_Ascender(int value);
    public int get_Descender();
    protected void set_Descender(int value);
    public int get_Leading();
    protected void set_Leading(int value);
    public int get_Flags();
    private void set_Flags(int value);
    public int get_StemV();
    protected void set_StemV(int value);
    public int get_LineSpacing();
    protected void set_LineSpacing(int value);
    internal static string ComputeKey(XFont font);
    internal static string ComputeKey(string name, XFontStyle style);
    internal static string ComputeKey(string name, bool isBold, bool isItalic);
    internal static string ComputeKey(string name);
}
internal class PdfSharpCore.Fonts.OpenType.FontHeaderTable : OpenTypeFontTable {
    public static string Tag;
    public int version;
    public int fontRevision;
    public UInt32 checkSumAdjustment;
    public UInt32 magicNumber;
    public ushort flags;
    public ushort unitsPerEm;
    public long created;
    public long modified;
    public short xMin;
    public short yMin;
    public short xMax;
    public short yMax;
    public ushort macStyle;
    public ushort lowestRecPPEM;
    public short fontDirectionHint;
    public short indexToLocFormat;
    public short glyphDataFormat;
    public FontHeaderTable(OpenTypeFontface fontData);
    public void Read();
}
internal class PdfSharpCore.Fonts.OpenType.FontProgram : OpenTypeFontTable {
    public static string Tag;
    private Byte[] bytes;
    public FontProgram(OpenTypeFontface fontData);
    public void Read();
}
internal enum PdfSharpCore.Fonts.OpenType.FontTechnology : Enum {
    public int value__;
    public static FontTechnology PostscriptOutlines;
    public static FontTechnology TrueTypeOutlines;
    public static FontTechnology TrueTypeCollection;
}
internal class PdfSharpCore.Fonts.OpenType.GlyphDataTable : OpenTypeFontTable {
    public static string Tag;
    internal Byte[] GlyphTable;
    private static int ARG_1_AND_2_ARE_WORDS;
    private static int WE_HAVE_A_SCALE;
    private static int MORE_COMPONENTS;
    private static int WE_HAVE_AN_X_AND_Y_SCALE;
    private static int WE_HAVE_A_TWO_BY_TWO;
    public GlyphDataTable(OpenTypeFontface fontData);
    public void Read();
    public Byte[] GetGlyphData(int glyph);
    public int GetGlyphSize(int glyph);
    public int GetOffset(int glyph);
    public void CompleteGlyphClosure(Dictionary`2<int, object> glyphs);
    private void AddCompositeGlyphs(Dictionary`2<int, object> glyphs, int glyph);
    public virtual void PrepareForCompilation();
    public virtual void Write(OpenTypeFontWriter writer);
}
internal class PdfSharpCore.Fonts.OpenType.GlyphSubstitutionTable : OpenTypeFontTable {
    public static string Tag;
    public GlyphSubstitutionTable(OpenTypeFontface fontData);
    public void Read();
}
internal class PdfSharpCore.Fonts.OpenType.GlyphTypefaceCache : object {
    private static GlyphTypefaceCache modreq(System.Runtime.CompilerServices.IsVolatile) _singleton;
    private ConcurrentDictionary`2<string, XGlyphTypeface> _glyphTypefacesByKey;
    private static GlyphTypefaceCache Singleton { get; }
    public static bool TryGetGlyphTypeface(string key, XGlyphTypeface& glyphTypeface);
    public static void AddGlyphTypeface(XGlyphTypeface glyphTypeface);
    private static GlyphTypefaceCache get_Singleton();
    internal static string GetCacheState();
}
internal class PdfSharpCore.Fonts.OpenType.HorizontalHeaderTable : OpenTypeFontTable {
    public static string Tag;
    public int version;
    public short ascender;
    public short descender;
    public short lineGap;
    public ushort advanceWidthMax;
    public short minLeftSideBearing;
    public short minRightSideBearing;
    public short xMaxExtent;
    public short caretSlopeRise;
    public short caretSlopeRun;
    public short reserved1;
    public short reserved2;
    public short reserved3;
    public short reserved4;
    public short reserved5;
    public short metricDataFormat;
    public ushort numberOfHMetrics;
    public HorizontalHeaderTable(OpenTypeFontface fontData);
    public void Read();
}
internal class PdfSharpCore.Fonts.OpenType.HorizontalMetrics : OpenTypeFontTable {
    public static string Tag;
    public ushort advanceWidth;
    public short lsb;
    public HorizontalMetrics(OpenTypeFontface fontData);
    public void Read();
}
internal class PdfSharpCore.Fonts.OpenType.HorizontalMetricsTable : OpenTypeFontTable {
    public static string Tag;
    public HorizontalMetrics[] Metrics;
    public Int16[] LeftSideBearing;
    public HorizontalMetricsTable(OpenTypeFontface fontData);
    public void Read();
}
internal class PdfSharpCore.Fonts.OpenType.IndexToLocationTable : OpenTypeFontTable {
    public static string Tag;
    internal Int32[] LocaTable;
    public bool ShortIndex;
    private Byte[] _bytes;
    public IndexToLocationTable(OpenTypeFontface fontData);
    public void Read();
    public virtual void PrepareForCompilation();
    public virtual void Write(OpenTypeFontWriter writer);
}
internal class PdfSharpCore.Fonts.OpenType.IRefFontTable : OpenTypeFontTable {
    private TableDirectoryEntry _irefDirectoryEntry;
    public IRefFontTable(OpenTypeFontface fontData, OpenTypeFontTable fontTable);
    public virtual void PrepareForCompilation();
    public virtual void Write(OpenTypeFontWriter writer);
}
internal class PdfSharpCore.Fonts.OpenType.MaximumProfileTable : OpenTypeFontTable {
    public static string Tag;
    public int version;
    public ushort numGlyphs;
    public ushort maxPoints;
    public ushort maxContours;
    public ushort maxCompositePoints;
    public ushort maxCompositeContours;
    public ushort maxZones;
    public ushort maxTwilightPoints;
    public ushort maxStorage;
    public ushort maxFunctionDefs;
    public ushort maxInstructionDefs;
    public ushort maxStackElements;
    public ushort maxSizeOfInstructions;
    public ushort maxComponentElements;
    public ushort maxComponentDepth;
    public MaximumProfileTable(OpenTypeFontface fontData);
    public void Read();
}
internal class PdfSharpCore.Fonts.OpenType.NameTable : OpenTypeFontTable {
    public static string Tag;
    public string Name;
    public string Style;
    public string FullFontName;
    public ushort format;
    public ushort count;
    public ushort stringOffset;
    private Byte[] bytes;
    public NameTable(OpenTypeFontface fontData);
    public void Read();
    private NameRecord ReadNameRecord();
}
internal class PdfSharpCore.Fonts.OpenType.OpenTypeDescriptor : FontDescriptor {
    internal OpenTypeFontface FontFace;
    public Int32[] Widths;
    public bool IsBoldFace { get; }
    public bool IsItalicFace { get; }
    public OpenTypeDescriptor(string fontDescriptorKey, string name, XFontStyle stlye, OpenTypeFontface fontface, XPdfFontOptions options);
    public OpenTypeDescriptor(string fontDescriptorKey, XFont font);
    internal OpenTypeDescriptor(string fontDescriptorKey, string idName, Byte[] fontData);
    private void Initialize();
    public virtual bool get_IsBoldFace();
    public virtual bool get_IsItalicFace();
    internal int DesignUnitsToPdf(double value);
    public int CharCodeToGlyphIndex(char value);
    public int GlyphIndexToPdfWidth(int glyphIndex);
    public int PdfWidthFromCharCode(char ch);
    public double GlyphIndexToEmfWidth(int glyphIndex, double emSize);
    public int GlyphIndexToWidth(int glyphIndex);
}
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
internal class PdfSharpCore.Fonts.OpenType.OpenTypeFontface : object {
    private string _fullFaceName;
    private ulong _checkSum;
    private XFontSource _fontSource;
    internal FontTechnology _fontTechnology;
    internal OffsetTable _offsetTable;
    internal Dictionary`2<string, TableDirectoryEntry> TableDictionary;
    internal CMapTable cmap;
    internal ControlValueTable cvt;
    internal FontProgram fpgm;
    internal MaximumProfileTable maxp;
    internal NameTable name;
    internal ControlValueProgram prep;
    internal FontHeaderTable head;
    internal HorizontalHeaderTable hhea;
    internal HorizontalMetricsTable hmtx;
    internal OS2Table os2;
    internal PostScriptTable post;
    internal GlyphDataTable glyf;
    internal IndexToLocationTable loca;
    internal GlyphSubstitutionTable gsub;
    internal VerticalHeaderTable vhea;
    internal VerticalMetricsTable vmtx;
    private static Int32[] _entrySelectors;
    private int _pos;
    public string FullFaceName { get; }
    public ulong CheckSum { get; }
    public XFontSource FontSource { get; private set; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public int Position { get; public set; }
    internal string DebuggerDisplay { get; }
    private OpenTypeFontface(OpenTypeFontface fontface);
    public OpenTypeFontface(Byte[] data, string faceName);
    public OpenTypeFontface(XFontSource fontSource);
    private static OpenTypeFontface();
    public static OpenTypeFontface CetOrCreateFrom(XFontSource fontSource);
    public string get_FullFaceName();
    public ulong get_CheckSum();
    public XFontSource get_FontSource();
    private void set_FontSource(XFontSource value);
    public bool get_CanRead();
    public bool get_CanWrite();
    public void AddTable(OpenTypeFontTable fontTable);
    internal void Read();
    public OpenTypeFontface CreateFontSubSet(Dictionary`2<int, object> glyphs, bool cidFont);
    private void Compile();
    public int get_Position();
    public void set_Position(int value);
    public int Seek(string tag);
    public int SeekOffset(int offset);
    public byte ReadByte();
    public short ReadShort();
    public ushort ReadUShort();
    public int ReadLong();
    public UInt32 ReadULong();
    public int ReadFixed();
    public short ReadFWord();
    public ushort ReadUFWord();
    public long ReadLongDate();
    public string ReadString(int size);
    public Byte[] ReadBytes(int size);
    public void Read(Byte[] buffer);
    public void Read(Byte[] buffer, int offset, int length);
    public string ReadTag();
    internal string get_DebuggerDisplay();
}
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
internal class PdfSharpCore.Fonts.OpenType.OpenTypeFontfaceCache : object {
    private static OpenTypeFontfaceCache modreq(System.Runtime.CompilerServices.IsVolatile) _singleton;
    private Dictionary`2<string, OpenTypeFontface> _fontfaceCache;
    private Dictionary`2<ulong, OpenTypeFontface> _fontfacesByCheckSum;
    private static OpenTypeFontfaceCache Singleton { get; }
    private string DebuggerDisplay { get; }
    public static bool TryGetFontface(string key, OpenTypeFontface& fontface);
    public static bool TryGetFontface(ulong checkSum, OpenTypeFontface& fontface);
    public static OpenTypeFontface AddFontface(OpenTypeFontface fontface);
    private static OpenTypeFontfaceCache get_Singleton();
    internal static string GetCacheState();
    private string get_DebuggerDisplay();
}
internal class PdfSharpCore.Fonts.OpenType.OpenTypeFontTable : object {
    internal OpenTypeFontface _fontData;
    public TableDirectoryEntry DirectoryEntry;
    public OpenTypeFontface FontData { get; }
    public OpenTypeFontTable(OpenTypeFontface fontData, string tag);
    public sealed virtual object Clone();
    protected virtual OpenTypeFontTable DeepCopy();
    public OpenTypeFontface get_FontData();
    public virtual void PrepareForCompilation();
    public virtual void Write(OpenTypeFontWriter writer);
    public static UInt32 CalcChecksum(Byte[] bytes);
}
internal class PdfSharpCore.Fonts.OpenType.OpenTypeFontWriter : FontWriter {
    public OpenTypeFontWriter(Stream stream);
    public void WriteTag(string tag);
}
internal class PdfSharpCore.Fonts.OpenType.OS2Table : OpenTypeFontTable {
    public static string Tag;
    public ushort version;
    public short xAvgCharWidth;
    public ushort usWeightClass;
    public ushort usWidthClass;
    public ushort fsType;
    public short ySubscriptXSize;
    public short ySubscriptYSize;
    public short ySubscriptXOffset;
    public short ySubscriptYOffset;
    public short ySuperscriptXSize;
    public short ySuperscriptYSize;
    public short ySuperscriptXOffset;
    public short ySuperscriptYOffset;
    public short yStrikeoutSize;
    public short yStrikeoutPosition;
    public short sFamilyClass;
    public Byte[] panose;
    public UInt32 ulUnicodeRange1;
    public UInt32 ulUnicodeRange2;
    public UInt32 ulUnicodeRange3;
    public UInt32 ulUnicodeRange4;
    public string achVendID;
    public ushort fsSelection;
    public ushort usFirstCharIndex;
    public ushort usLastCharIndex;
    public short sTypoAscender;
    public short sTypoDescender;
    public short sTypoLineGap;
    public ushort usWinAscent;
    public ushort usWinDescent;
    public UInt32 ulCodePageRange1;
    public UInt32 ulCodePageRange2;
    public short sxHeight;
    public short sCapHeight;
    public ushort usDefaultChar;
    public ushort usBreakChar;
    public ushort usMaxContext;
    public bool IsBold { get; }
    public bool IsItalic { get; }
    public OS2Table(OpenTypeFontface fontData);
    public void Read();
    public bool get_IsBold();
    public bool get_IsItalic();
}
internal enum PdfSharpCore.Fonts.OpenType.PlatformId : Enum {
    public int value__;
    public static PlatformId Apple;
    public static PlatformId Mac;
    public static PlatformId Iso;
    public static PlatformId Win;
}
internal class PdfSharpCore.Fonts.OpenType.PostScriptTable : OpenTypeFontTable {
    public static string Tag;
    public int formatType;
    public float italicAngle;
    public short underlinePosition;
    public short underlineThickness;
    public ulong isFixedPitch;
    public ulong minMemType42;
    public ulong maxMemType42;
    public ulong minMemType1;
    public ulong maxMemType1;
    public PostScriptTable(OpenTypeFontface fontData);
    public void Read();
}
internal class PdfSharpCore.Fonts.OpenType.TableDirectoryEntry : object {
    public string Tag;
    public UInt32 CheckSum;
    public int Offset;
    public int Length;
    public OpenTypeFontTable FontTable;
    public int PaddedLength { get; }
    public TableDirectoryEntry(string tag);
    public int get_PaddedLength();
    public static TableDirectoryEntry ReadFrom(OpenTypeFontface fontData);
    public void Read(OpenTypeFontface fontData);
    public void Write(OpenTypeFontWriter writer);
}
internal static class PdfSharpCore.Fonts.OpenType.TableTagNames : object {
    public static string CMap;
    public static string Head;
    public static string HHea;
    public static string HMtx;
    public static string MaxP;
    public static string Name;
    public static string OS2;
    public static string Post;
    public static string Cvt;
    public static string Fpgm;
    public static string Glyf;
    public static string Loca;
    public static string Prep;
    public static string Cff;
    public static string VOrg;
    public static string EBDT;
    public static string EBLC;
    public static string EBSC;
    public static string BASE;
    public static string GDEF;
    public static string GPOS;
    public static string GSUB;
    public static string JSTF;
    public static string DSIG;
    public static string Gasp;
    public static string Hdmx;
    public static string Kern;
    public static string LTSH;
    public static string PCLT;
    public static string VDMX;
    public static string VHea;
    public static string VMtx;
}
internal class PdfSharpCore.Fonts.OpenType.VerticalHeaderTable : OpenTypeFontTable {
    public static string Tag;
    public int Version;
    public short Ascender;
    public short Descender;
    public short LineGap;
    public ushort AdvanceWidthMax;
    public short MinLeftSideBearing;
    public short MinRightSideBearing;
    public short xMaxExtent;
    public short caretSlopeRise;
    public short caretSlopeRun;
    public short reserved1;
    public short reserved2;
    public short reserved3;
    public short reserved4;
    public short reserved5;
    public short metricDataFormat;
    public ushort numberOfHMetrics;
    public VerticalHeaderTable(OpenTypeFontface fontData);
    public void Read();
}
internal class PdfSharpCore.Fonts.OpenType.VerticalMetrics : OpenTypeFontTable {
    public static string Tag;
    public ushort advanceWidth;
    public short lsb;
    public VerticalMetrics(OpenTypeFontface fontData);
    public void Read();
}
internal class PdfSharpCore.Fonts.OpenType.VerticalMetricsTable : OpenTypeFontTable {
    public static string Tag;
    public HorizontalMetrics[] metrics;
    public Int16[] leftSideBearing;
    public VerticalMetricsTable(OpenTypeFontface fontData);
    public void Read();
}
internal enum PdfSharpCore.Fonts.OpenType.WinEncodingId : Enum {
    public int value__;
    public static WinEncodingId Symbol;
    public static WinEncodingId Unicode;
}
public static class PdfSharpCore.Fonts.PlatformFontResolver : object {
    public static FontResolverInfo ResolveTypeface(string familyName, bool isBold, bool isItalic);
    internal static FontResolverInfo ResolveTypeface(string familyName, FontResolvingOptions fontResolvingOptions, string typefaceKey);
}
internal class PdfSharpCore.Fonts.PlatformFontResolverInfo : FontResolverInfo {
    public PlatformFontResolverInfo(string faceName, bool mustSimulateBold, bool mustSimulateItalic);
}
internal static class PdfSharpCore.Internal.Calc : object {
    public static double Deg2Rad;
    public static XSize PageSizeToSize(PageSize value);
}
internal static class PdfSharpCore.Internal.ColorHelper : object {
    public static float sRgbToScRgb(byte bval);
    public static byte ScRgbTosRgb(float val);
}
internal static class PdfSharpCore.Internal.ContentReaderDiagnostics : object {
    public static void ThrowContentReaderException(string message);
    public static void ThrowContentReaderException(string message, Exception innerException);
    public static void ThrowNumberOutOfIntegerRange(long value);
    public static void HandleUnexpectedCharacter(char ch);
}
public static class PdfSharpCore.Internal.DebugBreak : object {
    public static void Break();
    public static void Break(bool always);
}
internal static class PdfSharpCore.Internal.Diagnostics : object {
    private static NotImplementedBehaviour _notImplementedBehaviour;
    public static NotImplementedBehaviour NotImplementedBehaviour { get; public set; }
    public static NotImplementedBehaviour get_NotImplementedBehaviour();
    public static void set_NotImplementedBehaviour(NotImplementedBehaviour value);
}
internal static class PdfSharpCore.Internal.DiagnosticsHelper : object {
    public static void HandleNotImplemented(string message);
    public static void ThrowNotImplementedException(string message);
}
internal static class PdfSharpCore.Internal.DoubleUtil : object {
    private static double Epsilon;
    private static double TenTimesEpsilon;
    private static float FloatMinimum;
    private static Double[] decs;
    private static DoubleUtil();
    public static bool AreClose(double value1, double value2);
    public static bool AreRoughlyEqual(double value1, double value2, int decimalPlace);
    public static bool AreClose(XPoint point1, XPoint point2);
    public static bool AreClose(XRect rect1, XRect rect2);
    public static bool AreClose(XSize size1, XSize size2);
    public static bool AreClose(XVector vector1, XVector vector2);
    public static bool GreaterThan(double value1, double value2);
    public static bool GreaterThanOrClose(double value1, double value2);
    public static bool LessThan(double value1, double value2);
    public static bool LessThanOrClose(double value1, double value2);
    public static bool IsBetweenZeroAndOne(double value);
    public static bool IsNaN(double value);
    public static bool RectHasNaN(XRect r);
    public static bool IsOne(double value);
    public static bool IsZero(double value);
    public static int DoubleToInt(double value);
}
public class PdfSharpCore.Internal.FontFamilyModel : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public Dictionary`2<XFontStyle, string> FontFiles;
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public bool IsStyleAvailable(XFontStyle fontStyle);
}
public static class PdfSharpCore.Internal.FontsDevHelper : object {
    public static XFont CreateSpecialFont(string familyName, double emSize, XFontStyle style, XPdfFontOptions pdfOptions, XStyleSimulations styleSimulations);
    public static string GetFontCachesState();
}
internal static class PdfSharpCore.Internal.Lock : object {
    private static object GdiPlus;
    private static int _gdiPlusLockCount;
    private static object FontFactory;
    [ThreadStaticAttribute]
private static int _fontFactoryLockCount;
    private static Lock();
    public static void EnterGdiPlus();
    public static void ExitGdiPlus();
    public static void EnterFontFactory();
    public static void ExitFontFactory();
}
internal static class PdfSharpCore.Internal.Logger : object {
    public static void Log(string format, Object[] args);
}
internal class PdfSharpCore.Internal.Logging : object {
}
internal enum PdfSharpCore.Internal.NotImplementedBehaviour : Enum {
    public int value__;
    public static NotImplementedBehaviour DoNothing;
    public static NotImplementedBehaviour Log;
    public static NotImplementedBehaviour Throw;
}
internal static class PdfSharpCore.Internal.ParserDiagnostics : object {
    public static void ThrowParserException(string message);
    public static void ThrowParserException(string message, Exception innerException);
    public static void HandleUnexpectedCharacter(char ch);
    public static void HandleUnexpectedToken(string token);
}
internal class PdfSharpCore.Internal.SCColor : ValueType {
    public float a;
    public float r;
    public float g;
    public float b;
}
internal class PdfSharpCore.Internal.SColor : ValueType {
    public byte a;
    public byte r;
    public byte g;
    public byte b;
}
internal class PdfSharpCore.Internal.TokenizerHelper : object {
    private bool _foundSeparator;
    private char _argSeparator;
    private int _charIndex;
    private int _currentTokenIndex;
    private int _currentTokenLength;
    private char _quoteChar;
    private string _str;
    private int _strLen;
    public bool FoundSeparator { get; }
    public TokenizerHelper(string str, IFormatProvider formatProvider);
    public TokenizerHelper(string str, char quoteChar, char separator);
    private void Initialize(string str, char quoteChar, char separator);
    public string NextTokenRequired();
    public string NextTokenRequired(bool allowQuotedToken);
    public string GetCurrentToken();
    public void LastTokenRequired();
    public bool NextToken();
    public bool NextToken(bool allowQuotedToken);
    public bool NextToken(bool allowQuotedToken, char separator);
    private void ScanToNextToken(char separator);
    public static char GetNumericListSeparator(IFormatProvider provider);
    public bool get_FoundSeparator();
}
internal class PdfSharpCore.Internal.Tracing : object {
    [ConditionalAttribute("DEBUG")]
public void Foo();
}
[CompilerGeneratedAttribute]
internal class PdfSharpCore.NamespaceDoc : object {
}
public enum PdfSharpCore.PageOrientation : Enum {
    public int value__;
    public static PageOrientation Portrait;
    public static PageOrientation Landscape;
}
public enum PdfSharpCore.PageSize : Enum {
    public int value__;
    public static PageSize Undefined;
    public static PageSize A0;
    public static PageSize A1;
    public static PageSize A2;
    public static PageSize A3;
    public static PageSize A4;
    public static PageSize A5;
    public static PageSize RA0;
    public static PageSize RA1;
    public static PageSize RA2;
    public static PageSize RA3;
    public static PageSize RA4;
    public static PageSize RA5;
    public static PageSize B0;
    public static PageSize B1;
    public static PageSize B2;
    public static PageSize B3;
    public static PageSize B4;
    public static PageSize B5;
    public static PageSize A6;
    public static PageSize Quarto;
    public static PageSize Foolscap;
    public static PageSize Executive;
    public static PageSize GovernmentLetter;
    public static PageSize Letter;
    public static PageSize Legal;
    public static PageSize Ledger;
    public static PageSize Tabloid;
    public static PageSize Post;
    public static PageSize Crown;
    public static PageSize LargePost;
    public static PageSize Demy;
    public static PageSize Medium;
    public static PageSize Royal;
    public static PageSize Elephant;
    public static PageSize DoubleDemy;
    public static PageSize QuadDemy;
    public static PageSize STMT;
    public static PageSize Folio;
    public static PageSize Statement;
    public static PageSize Size10x14;
}
public static class PdfSharpCore.PageSizeConverter : object {
    public static XSize ToSize(PageSize value);
}
[DefaultMemberAttribute("Item")]
public abstract class PdfSharpCore.Pdf.AcroForms.PdfAcroField : PdfDictionary {
    private PdfAcroFieldCollection _fields;
    public string Name { get; }
    public PdfAcroFieldFlags Flags { get; }
    internal PdfAcroFieldFlags SetFlags { get; internal set; }
    public PdfItem Value { get; public set; }
    public bool ReadOnly { get; public set; }
    public PdfAcroField Item { get; }
    public bool HasKids { get; }
    public PdfAcroFieldCollection Fields { get; }
    internal PdfAcroField(PdfDocument document);
    protected PdfAcroField(PdfDictionary dict);
    public string get_Name();
    public PdfAcroFieldFlags get_Flags();
    internal PdfAcroFieldFlags get_SetFlags();
    internal void set_SetFlags(PdfAcroFieldFlags value);
    public virtual PdfItem get_Value();
    public virtual void set_Value(PdfItem value);
    public bool get_ReadOnly();
    public void set_ReadOnly(bool value);
    public PdfAcroField get_Item(string name);
    protected virtual PdfAcroField GetValue(string name);
    public bool get_HasKids();
    public String[] GetDescendantNames();
    public String[] GetAppearanceNames();
    private static void AppDict(PdfDictionary dict, Dictionary`2<string, object> names);
    private static void AppDict2(PdfDictionary dict, Dictionary`2<string, object> names);
    internal virtual void GetDescendantNames(List`1& names, string partialName);
    public PdfAcroFieldCollection get_Fields();
}
[FlagsAttribute]
public enum PdfSharpCore.Pdf.AcroForms.PdfAcroFieldFlags : Enum {
    public int value__;
    public static PdfAcroFieldFlags ReadOnly;
    public static PdfAcroFieldFlags Required;
    public static PdfAcroFieldFlags NoExport;
    public static PdfAcroFieldFlags Pushbutton;
    public static PdfAcroFieldFlags Radio;
    public static PdfAcroFieldFlags NoToggleToOff;
    public static PdfAcroFieldFlags Multiline;
    public static PdfAcroFieldFlags Password;
    public static PdfAcroFieldFlags FileSelect;
    public static PdfAcroFieldFlags DoNotSpellCheckTextField;
    public static PdfAcroFieldFlags DoNotScroll;
    public static PdfAcroFieldFlags Combo;
    public static PdfAcroFieldFlags Edit;
    public static PdfAcroFieldFlags Sort;
    public static PdfAcroFieldFlags MultiSelect;
    public static PdfAcroFieldFlags DoNotSpellCheckChoiseField;
}
public class PdfSharpCore.Pdf.AcroForms.PdfAcroForm : PdfDictionary {
    private PdfAcroFieldCollection _fields;
    public PdfAcroFieldCollection Fields { get; }
    internal DictionaryMeta Meta { get; }
    internal PdfAcroForm(PdfDocument document);
    internal PdfAcroForm(PdfDictionary dictionary);
    public PdfAcroFieldCollection get_Fields();
    internal virtual DictionaryMeta get_Meta();
}
public abstract class PdfSharpCore.Pdf.AcroForms.PdfButtonField : PdfAcroField {
    protected PdfButtonField(PdfDocument document);
    protected PdfButtonField(PdfDictionary dict);
    protected string GetNonOffValue();
    internal virtual void GetDescendantNames(List`1& names, string partialName);
}
public class PdfSharpCore.Pdf.AcroForms.PdfCheckBoxField : PdfButtonField {
    private string _checkedName;
    private string _uncheckedName;
    public bool Checked { get; public set; }
    public string CheckedName { get; public set; }
    public string UncheckedName { get; public set; }
    internal DictionaryMeta Meta { get; }
    internal PdfCheckBoxField(PdfDocument document);
    internal PdfCheckBoxField(PdfDictionary dict);
    public bool get_Checked();
    public void set_Checked(bool value);
    public string get_CheckedName();
    public void set_CheckedName(string value);
    public string get_UncheckedName();
    public void set_UncheckedName(string value);
    internal virtual DictionaryMeta get_Meta();
}
public abstract class PdfSharpCore.Pdf.AcroForms.PdfChoiceField : PdfAcroField {
    internal DictionaryMeta Meta { get; }
    protected PdfChoiceField(PdfDocument document);
    protected PdfChoiceField(PdfDictionary dict);
    protected int IndexInOptArray(string value);
    protected string ValueInOptArray(int index);
    internal virtual DictionaryMeta get_Meta();
}
public class PdfSharpCore.Pdf.AcroForms.PdfComboBoxField : PdfChoiceField {
    public int SelectedIndex { get; public set; }
    public PdfItem Value { get; public set; }
    internal DictionaryMeta Meta { get; }
    internal PdfComboBoxField(PdfDocument document);
    internal PdfComboBoxField(PdfDictionary dict);
    public int get_SelectedIndex();
    public void set_SelectedIndex(int value);
    public virtual PdfItem get_Value();
    public virtual void set_Value(PdfItem value);
    internal virtual DictionaryMeta get_Meta();
}
public class PdfSharpCore.Pdf.AcroForms.PdfGenericField : PdfAcroField {
    internal DictionaryMeta Meta { get; }
    internal PdfGenericField(PdfDocument document);
    internal PdfGenericField(PdfDictionary dict);
    internal virtual DictionaryMeta get_Meta();
}
public class PdfSharpCore.Pdf.AcroForms.PdfListBoxField : PdfChoiceField {
    public int SelectedIndex { get; public set; }
    internal DictionaryMeta Meta { get; }
    internal PdfListBoxField(PdfDocument document);
    internal PdfListBoxField(PdfDictionary dict);
    public int get_SelectedIndex();
    public void set_SelectedIndex(int value);
    internal virtual DictionaryMeta get_Meta();
}
public class PdfSharpCore.Pdf.AcroForms.PdfPushButtonField : PdfButtonField {
    internal DictionaryMeta Meta { get; }
    internal PdfPushButtonField(PdfDocument document);
    internal PdfPushButtonField(PdfDictionary dict);
    internal virtual DictionaryMeta get_Meta();
}
public class PdfSharpCore.Pdf.AcroForms.PdfRadioButtonField : PdfButtonField {
    public int SelectedIndex { get; public set; }
    internal DictionaryMeta Meta { get; }
    internal PdfRadioButtonField(PdfDocument document);
    internal PdfRadioButtonField(PdfDictionary dict);
    public int get_SelectedIndex();
    public void set_SelectedIndex(int value);
    private int IndexInOptStrings(string value);
    internal virtual DictionaryMeta get_Meta();
}
public class PdfSharpCore.Pdf.AcroForms.PdfSignatureField : PdfAcroField {
    internal DictionaryMeta Meta { get; }
    internal PdfSignatureField(PdfDocument document);
    internal PdfSignatureField(PdfDictionary dict);
    internal virtual DictionaryMeta get_Meta();
}
public class PdfSharpCore.Pdf.AcroForms.PdfTextField : PdfAcroField {
    private XFont _font;
    private XColor _foreColor;
    private XColor _backColor;
    public string Text { get; public set; }
    public XFont Font { get; public set; }
    public XColor ForeColor { get; public set; }
    public XColor BackColor { get; public set; }
    public int MaxLength { get; public set; }
    public bool MultiLine { get; public set; }
    public bool Password { get; public set; }
    internal DictionaryMeta Meta { get; }
    internal PdfTextField(PdfDocument document);
    internal PdfTextField(PdfDictionary dict);
    public string get_Text();
    public void set_Text(string value);
    public XFont get_Font();
    public void set_Font(XFont value);
    public XColor get_ForeColor();
    public void set_ForeColor(XColor value);
    public XColor get_BackColor();
    public void set_BackColor(XColor value);
    public int get_MaxLength();
    public void set_MaxLength(int value);
    public bool get_MultiLine();
    public void set_MultiLine(bool value);
    public bool get_Password();
    public void set_Password(bool value);
    private void RenderAppearance();
    internal virtual void PrepareForSave();
    internal virtual DictionaryMeta get_Meta();
}
public abstract class PdfSharpCore.Pdf.Actions.PdfAction : PdfDictionary {
    protected PdfAction(PdfDocument document);
}
public class PdfSharpCore.Pdf.Actions.PdfGoToAction : PdfAction {
    public PdfGoToAction(PdfDocument document);
    private void Inititalize();
}
public enum PdfSharpCore.Pdf.Actions.PdfNamedActionNames : Enum {
    public int value__;
    public static PdfNamedActionNames NextPage;
    public static PdfNamedActionNames PrevPage;
    public static PdfNamedActionNames FirstPage;
    public static PdfNamedActionNames LastPage;
}
internal class PdfSharpCore.Pdf.Advanced.BitReader : object {
    private Byte[] _imageBits;
    private UInt32 _bytesOffsetRead;
    private UInt32 _bytesFileOffset;
    private byte _buffer;
    private UInt32 _bitsInBuffer;
    private UInt32 _bitsTotal;
    internal BitReader(Byte[] imageBits, UInt32 bytesFileOffset, UInt32 bits);
    internal void SetPosition(UInt32 position);
    internal bool GetBit(UInt32 position);
    internal byte PeekByte(UInt32& bits);
    internal void NextByte();
    internal void SkipBits(UInt32 bits);
}
internal class PdfSharpCore.Pdf.Advanced.BitWriter : object {
    private static UInt32[] masks;
    private int _bytesOffsetWrite;
    private Byte[] _imageData;
    private UInt32 _buffer;
    private UInt32 _bitsInBuffer;
    internal BitWriter(Byte[]& imageData);
    private static BitWriter();
    internal void FlushBuffer();
    internal void WriteBits(UInt32 value, UInt32 bits);
    internal void WriteTableLine(UInt32[] table, UInt32 line);
    [ObsoleteAttribute]
internal void WriteEOL();
    internal int BytesWritten();
}
internal enum PdfSharpCore.Pdf.Advanced.FontType : Enum {
    public int value__;
    public static FontType TrueType;
    public static FontType Type0;
}
internal interface PdfSharpCore.Pdf.Advanced.IContentStream {
    public PdfResources Resources { get; }
    public abstract virtual PdfResources get_Resources();
    public abstract virtual string GetFontName(XFont font, PdfFont& pdfFont);
    public abstract virtual string GetFontName(string idName, Byte[] fontData, PdfFont& pdfFont);
    public abstract virtual string GetImageName(XImage image);
    public abstract virtual string GetFormName(XForm form);
}
internal class PdfSharpCore.Pdf.Advanced.MonochromeMask : object {
    private Byte[] _maskData;
    private int _sizeX;
    private int _sizeY;
    private int _writeOffset;
    private int _byteBuffer;
    private int _bitsWritten;
    public Byte[] MaskData { get; }
    public MonochromeMask(int sizeX, int sizeY);
    public Byte[] get_MaskData();
    public void StartLine(int newCurrentLine);
    public void AddPel(bool isTransparent);
    public void AddPel(int shade);
}
public class PdfSharpCore.Pdf.Advanced.PdfCatalog : PdfDictionary {
    private string _version;
    private PdfPages _pages;
    private PdfViewerPreferences _viewerPreferences;
    private PdfOutline _outline;
    public string Version { get; public set; }
    public PdfPages Pages { get; }
    internal PdfPageLayout PageLayout { get; internal set; }
    internal PdfPageMode PageMode { get; internal set; }
    internal PdfViewerPreferences ViewerPreferences { get; }
    internal PdfOutlineCollection Outlines { get; }
    public PdfAcroForm AcroForm { get; public set; }
    public string Language { get; public set; }
    internal DictionaryMeta Meta { get; }
    public PdfCatalog(PdfDocument document);
    internal PdfCatalog(PdfDictionary dictionary);
    public string get_Version();
    public void set_Version(string value);
    public PdfPages get_Pages();
    internal PdfPageLayout get_PageLayout();
    internal void set_PageLayout(PdfPageLayout value);
    internal PdfPageMode get_PageMode();
    internal void set_PageMode(PdfPageMode value);
    internal PdfViewerPreferences get_ViewerPreferences();
    internal PdfOutlineCollection get_Outlines();
    public PdfAcroForm get_AcroForm();
    public void set_AcroForm(PdfAcroForm value);
    public string get_Language();
    public void set_Language(string value);
    internal virtual void PrepareForSave();
    internal virtual void WriteObject(PdfWriter writer);
    internal virtual DictionaryMeta get_Meta();
}
internal class PdfSharpCore.Pdf.Advanced.PdfCIDFont : PdfFont {
    public string BaseFont { get; public set; }
    internal DictionaryMeta Meta { get; }
    public PdfCIDFont(PdfDocument document);
    public PdfCIDFont(PdfDocument document, PdfFontDescriptor fontDescriptor, XFont font);
    public PdfCIDFont(PdfDocument document, PdfFontDescriptor fontDescriptor, Byte[] fontData);
    public string get_BaseFont();
    public void set_BaseFont(string value);
    internal virtual void PrepareForSave();
    internal virtual DictionaryMeta get_Meta();
}
public class PdfSharpCore.Pdf.Advanced.PdfContent : PdfDictionary {
    internal XGraphicsPdfRenderer _pdfRenderer;
    unknown bool Compressed {public set; }
    internal DictionaryMeta Meta { get; }
    public PdfContent(PdfDocument document);
    internal PdfContent(PdfPage page);
    public PdfContent(PdfDictionary dict);
    public void set_Compressed(bool value);
    private void Decode();
    internal void PreserveGraphicsState();
    internal virtual void WriteObject(PdfWriter writer);
    internal virtual DictionaryMeta get_Meta();
}
public class PdfSharpCore.Pdf.Advanced.PdfContents : PdfArray {
    private bool _modified;
    public PdfContents(PdfDocument document);
    internal PdfContents(PdfArray array);
    public PdfContent AppendContent();
    public PdfContent PrependContent();
    public PdfContent CreateSingleContent();
    public PdfContent ReplaceContent(CSequence cseq);
    private PdfContent ReplaceContent(Byte[] contentBytes);
    private void SetModified();
    internal virtual void WriteObject(PdfWriter writer);
    public IEnumerator`1<PdfContent> GetEnumerator();
}
internal class PdfSharpCore.Pdf.Advanced.PdfCrossReferenceStream : PdfTrailer {
    public List`1<CrossReferenceStreamEntry> Entries;
    internal DictionaryMeta Meta { get; }
    public PdfCrossReferenceStream(PdfDocument document);
    internal virtual DictionaryMeta get_Meta();
}
[DefaultMemberAttribute("Item")]
internal class PdfSharpCore.Pdf.Advanced.PdfCrossReferenceTable : object {
    private PdfDocument _document;
    public Dictionary`2<PdfObjectID, PdfReference> ObjectTable;
    private bool _isUnderConstruction;
    internal int _maxObjectNumber;
    private static int _nestingLevel;
    private Dictionary`2<PdfItem, object> _overflow;
    private PdfDictionary _deadObject;
    internal bool IsUnderConstruction { get; internal set; }
    public PdfReference Item { get; }
    internal PdfObjectID[] AllObjectIDs { get; }
    internal PdfReference[] AllReferences { get; }
    public PdfReference DeadObject { get; }
    public PdfCrossReferenceTable(PdfDocument document);
    internal bool get_IsUnderConstruction();
    internal void set_IsUnderConstruction(bool value);
    public void Add(PdfReference iref);
    public void Add(PdfObject value);
    public void Remove(PdfReference iref);
    public PdfReference get_Item(PdfObjectID objectID);
    public bool Contains(PdfObjectID objectID);
    public int GetNewObjectNumber();
    internal void WriteObject(PdfWriter writer);
    internal PdfObjectID[] get_AllObjectIDs();
    internal PdfReference[] get_AllReferences();
    internal void HandleOrphanedReferences();
    internal int Compact();
    internal void Renumber();
    [ConditionalAttribute("DEBUG_")]
public void CheckConsistence();
    public PdfReference[] TransitiveClosure(PdfObject pdfObject);
    public PdfReference[] TransitiveClosure(PdfObject pdfObject, int depth);
    private void TransitiveClosureImplementation(Dictionary`2<PdfItem, object> objects, PdfObject pdfObject);
    public PdfReference get_DeadObject();
}
public abstract class PdfSharpCore.Pdf.Advanced.PdfDictionaryWithContentStream : PdfDictionary {
    private PdfResources _resources;
    internal PdfResources Resources { get; }
    private PdfResources PdfSharpCore.Pdf.Advanced.IContentStream.Resources { get; }
    public PdfDictionaryWithContentStream(PdfDocument document);
    protected PdfDictionaryWithContentStream(PdfDictionary dict);
    internal PdfResources get_Resources();
    private sealed virtual override PdfResources PdfSharpCore.Pdf.Advanced.IContentStream.get_Resources();
    internal string GetFontName(XFont font, PdfFont& pdfFont);
    private sealed virtual override string PdfSharpCore.Pdf.Advanced.IContentStream.GetFontName(XFont font, PdfFont& pdfFont);
    internal string GetFontName(string idName, Byte[] fontData, PdfFont& pdfFont);
    private sealed virtual override string PdfSharpCore.Pdf.Advanced.IContentStream.GetFontName(string idName, Byte[] fontData, PdfFont& pdfFont);
    internal string GetImageName(XImage image);
    private sealed virtual override string PdfSharpCore.Pdf.Advanced.IContentStream.GetImageName(XImage image);
    internal string GetFormName(XForm form);
    private sealed virtual override string PdfSharpCore.Pdf.Advanced.IContentStream.GetFormName(XForm form);
}
public class PdfSharpCore.Pdf.Advanced.PdfEmbeddedFile : PdfDictionary {
    private PdfDictionary paramsDictionary;
    public string MimeType { get; public set; }
    internal DictionaryMeta Meta { get; }
    public PdfEmbeddedFile(PdfDocument document);
    public PdfEmbeddedFile(PdfDocument document, Byte[] bytes, string checksum);
    public void CreateStreamAndSetProperties(Byte[] bytes, string checksum);
    public string get_MimeType();
    public void set_MimeType(string value);
    internal virtual DictionaryMeta get_Meta();
}
public class PdfSharpCore.Pdf.Advanced.PdfExtGState : PdfDictionary {
    private double _strokeAlpha;
    private double _nonStrokeAlpha;
    private bool _strokeOverprint;
    private bool _nonStrokeOverprint;
    private string _key;
    unknown double StrokeAlpha {public set; }
    unknown double NonStrokeAlpha {public set; }
    unknown bool StrokeOverprint {public set; }
    unknown bool NonStrokeOverprint {public set; }
    unknown PdfSoftMask SoftMask {public set; }
    internal string Key { get; }
    internal DictionaryMeta Meta { get; }
    public PdfExtGState(PdfDocument document);
    internal void SetDefault1();
    internal void SetDefault2();
    public void set_StrokeAlpha(double value);
    public void set_NonStrokeAlpha(double value);
    public void set_StrokeOverprint(bool value);
    public void set_NonStrokeOverprint(bool value);
    public void set_SoftMask(PdfSoftMask value);
    internal string get_Key();
    private void UpdateKey();
    internal static string MakeKey(double alpha, bool overPaint);
    internal virtual DictionaryMeta get_Meta();
}
public class PdfSharpCore.Pdf.Advanced.PdfExtGStateTable : PdfResourceTable {
    private Dictionary`2<string, PdfExtGState> _strokeAlphaValues;
    private Dictionary`2<string, PdfExtGState> _nonStrokeStates;
    public PdfExtGStateTable(PdfDocument document);
    public PdfExtGState GetExtGStateStroke(double alpha, bool overprint);
    public PdfExtGState GetExtGStateNonStroke(double alpha, bool overprint);
}
public class PdfSharpCore.Pdf.Advanced.PdfFileSpecification : PdfDictionary {
    private PdfDictionary embeddedFileDictionary;
    public string FileName { get; public set; }
    public PdfEmbeddedFile EmbeddedFile { get; public set; }
    internal DictionaryMeta Meta { get; }
    public PdfFileSpecification(PdfDocument document);
    public PdfFileSpecification(PdfDocument document, string fileName, PdfEmbeddedFile embeddedFile);
    public string get_FileName();
    public void set_FileName(string value);
    public PdfEmbeddedFile get_EmbeddedFile();
    public void set_EmbeddedFile(PdfEmbeddedFile value);
    internal virtual DictionaryMeta get_Meta();
}
public class PdfSharpCore.Pdf.Advanced.PdfFont : PdfDictionary {
    private PdfFontDescriptor _fontDescriptor;
    internal PdfFontEncoding FontEncoding;
    internal CMapInfo _cmapInfo;
    internal PdfToUnicodeMap _toUnicode;
    internal PdfFontDescriptor FontDescriptor { get; internal set; }
    public bool IsSymbolFont { get; }
    internal CMapInfo CMapInfo { get; internal set; }
    internal PdfToUnicodeMap ToUnicodeMap { get; internal set; }
    public PdfFont(PdfDocument document);
    internal PdfFontDescriptor get_FontDescriptor();
    internal void set_FontDescriptor(PdfFontDescriptor value);
    public bool get_IsSymbolFont();
    internal void AddChars(string text);
    internal void AddGlyphIndices(string glyphIndices);
    internal CMapInfo get_CMapInfo();
    internal void set_CMapInfo(CMapInfo value);
    internal PdfToUnicodeMap get_ToUnicodeMap();
    internal void set_ToUnicodeMap(PdfToUnicodeMap value);
    internal static string CreateEmbeddedFontSubsetName(string name);
}
public class PdfSharpCore.Pdf.Advanced.PdfFontDescriptor : PdfDictionary {
    internal OpenTypeDescriptor _descriptor;
    private bool _isSymbolFont;
    public string FontName { get; public set; }
    public bool IsSymbolFont { get; }
    internal DictionaryMeta Meta { get; }
    internal PdfFontDescriptor(PdfDocument document, OpenTypeDescriptor descriptor);
    public string get_FontName();
    public void set_FontName(string value);
    public bool get_IsSymbolFont();
    private PdfFontDescriptorFlags FlagsFromDescriptor(OpenTypeDescriptor descriptor);
    internal virtual DictionaryMeta get_Meta();
}
[FlagsAttribute]
internal enum PdfSharpCore.Pdf.Advanced.PdfFontDescriptorFlags : Enum {
    public int value__;
    public static PdfFontDescriptorFlags FixedPitch;
    public static PdfFontDescriptorFlags Serif;
    public static PdfFontDescriptorFlags Symbolic;
    public static PdfFontDescriptorFlags Script;
    public static PdfFontDescriptorFlags Nonsymbolic;
    public static PdfFontDescriptorFlags Italic;
    public static PdfFontDescriptorFlags AllCap;
    public static PdfFontDescriptorFlags SmallCap;
    public static PdfFontDescriptorFlags ForceBold;
}
internal class PdfSharpCore.Pdf.Advanced.PdfFontTable : PdfResourceTable {
    private Dictionary`2<string, PdfFont> _fonts;
    public PdfFontTable(PdfDocument document);
    public PdfFont GetFont(XFont font);
    public PdfFont GetFont(string idName, Byte[] fontData);
    public PdfFont TryGetFont(string idName);
    internal static string ComputeKey(XFont font);
    public void PrepareForSave();
}
public class PdfSharpCore.Pdf.Advanced.PdfFormXObject : PdfXObject {
    private double _dpiX;
    private double _dpiY;
    private PdfResources _resources;
    internal double DpiX { get; internal set; }
    internal double DpiY { get; internal set; }
    public PdfResources Resources { get; }
    private PdfResources PdfSharpCore.Pdf.Advanced.IContentStream.Resources { get; }
    internal DictionaryMeta Meta { get; }
    internal PdfFormXObject(PdfDocument thisDocument);
    internal PdfFormXObject(PdfDocument thisDocument, XForm form);
    internal PdfFormXObject(PdfDocument thisDocument, PdfImportedObjectTable importedObjectTable, XPdfForm form);
    internal double get_DpiX();
    internal void set_DpiX(double value);
    internal double get_DpiY();
    internal void set_DpiY(double value);
    public PdfResources get_Resources();
    private sealed virtual override PdfResources PdfSharpCore.Pdf.Advanced.IContentStream.get_Resources();
    internal string GetFontName(XFont font, PdfFont& pdfFont);
    private sealed virtual override string PdfSharpCore.Pdf.Advanced.IContentStream.GetFontName(XFont font, PdfFont& pdfFont);
    internal string GetFontName(string idName, Byte[] fontData, PdfFont& pdfFont);
    private sealed virtual override string PdfSharpCore.Pdf.Advanced.IContentStream.GetFontName(string idName, Byte[] fontData, PdfFont& pdfFont);
    private sealed virtual override string PdfSharpCore.Pdf.Advanced.IContentStream.GetImageName(XImage image);
    private sealed virtual override string PdfSharpCore.Pdf.Advanced.IContentStream.GetFormName(XForm form);
    internal virtual DictionaryMeta get_Meta();
}
internal class PdfSharpCore.Pdf.Advanced.PdfFormXObjectTable : PdfResourceTable {
    private Dictionary`2<Selector, PdfImportedObjectTable> _forms;
    public PdfFormXObjectTable(PdfDocument document);
    public PdfFormXObject GetForm(XForm form);
    public PdfImportedObjectTable GetImportedObjectTable(PdfPage page);
    public PdfImportedObjectTable GetImportedObjectTable(PdfDocument document);
    public void DetachDocument(DocumentHandle handle);
}
public abstract class PdfSharpCore.Pdf.Advanced.PdfGroupAttributes : PdfDictionary {
    internal DictionaryMeta Meta { get; }
    internal PdfGroupAttributes(PdfDocument thisDocument);
    internal virtual DictionaryMeta get_Meta();
}
public class PdfSharpCore.Pdf.Advanced.PdfImage : PdfXObject {
    private XImage _image;
    internal static UInt32[] WhiteTerminatingCodes;
    internal static UInt32[] BlackTerminatingCodes;
    internal static UInt32[] WhiteMakeUpCodes;
    internal static UInt32[] BlackMakeUpCodes;
    internal static UInt32[] HorizontalCodes;
    internal static UInt32[] PassCodes;
    internal static UInt32[] VerticalCodes;
    private static UInt32[] _zeroRuns;
    private static UInt32[] _oneRuns;
    public XImage Image { get; }
    public PdfImage(PdfDocument document, XImage image);
    private static PdfImage();
    public XImage get_Image();
    public virtual string ToString();
    private void InitializeJpeg();
    private void InitializeNonJpeg();
    private static int ReadWord(Byte[] ab, int offset);
    private static int ReadDWord(Byte[] ab, int offset);
    private void ReadTrueColorMemoryBitmap(int components, int bits, bool hasAlpha);
    private void ReadIndexedMemoryBitmap(int bits);
    private static UInt32 CountOneBits(BitReader reader, UInt32 bitsLeft);
    private static UInt32 CountZeroBits(BitReader reader, UInt32 bitsLeft);
    private static UInt32 FindDifference(BitReader reader, UInt32 bitStart, UInt32 bitEnd, bool searchOne);
    private static UInt32 FindDifferenceWithCheck(BitReader reader, UInt32 bitStart, UInt32 bitEnd, bool searchOne);
    private static void FaxEncode2DRow(BitWriter writer, UInt32 bytesFileOffset, Byte[] imageBits, UInt32 currentRow, UInt32 referenceRow, UInt32 width, UInt32 height, UInt32 bytesPerLineBmp);
    private static int DoFaxEncoding(Byte[]& imageData, Byte[] imageBits, UInt32 bytesFileOffset, UInt32 width, UInt32 height);
    internal static int DoFaxEncodingGroup4(Byte[]& imageData, Byte[] imageBits, UInt32 bytesFileOffset, UInt32 width, UInt32 height);
    private static void WriteSample(BitWriter writer, UInt32 count, bool white);
}
internal class PdfSharpCore.Pdf.Advanced.PdfImageTable : PdfResourceTable {
    private Dictionary`2<ImageSelector, PdfImage> _images;
    public PdfImageTable(PdfDocument document);
    public PdfImage GetImage(XImage image);
}
[DefaultMemberAttribute("Item")]
internal class PdfSharpCore.Pdf.Advanced.PdfImportedObjectTable : object {
    private PdfFormXObject[] _xObjects;
    private PdfDocument _owner;
    private DocumentHandle _externalDocumentHandle;
    private Dictionary`2<string, PdfReference> _externalIDs;
    public PdfDocument Owner { get; }
    public PdfDocument ExternalDocument { get; }
    public PdfReference Item { get; }
    public PdfImportedObjectTable(PdfDocument owner, PdfDocument externalDocument);
    public PdfDocument get_Owner();
    public PdfDocument get_ExternalDocument();
    public PdfFormXObject GetXObject(int pageNumber);
    public void SetXObject(int pageNumber, PdfFormXObject xObject);
    public bool Contains(PdfObjectID externalID);
    public void Add(PdfObjectID externalID, PdfReference iref);
    public PdfReference get_Item(PdfObjectID externalID);
}
public class PdfSharpCore.Pdf.Advanced.PdfInternals : object {
    private PdfDocument _document;
    public string CustomValueKey;
    public string FirstDocumentID { get; public set; }
    public Guid FirstDocumentGuid { get; }
    public string SecondDocumentID { get; public set; }
    public Guid SecondDocumentGuid { get; }
    public PdfCatalog Catalog { get; }
    public PdfExtGStateTable ExtGStateTable { get; }
    internal PdfInternals(PdfDocument document);
    public string get_FirstDocumentID();
    public void set_FirstDocumentID(string value);
    public Guid get_FirstDocumentGuid();
    public string get_SecondDocumentID();
    public void set_SecondDocumentID(string value);
    public Guid get_SecondDocumentGuid();
    private Guid GuidFromString(string id);
    public PdfCatalog get_Catalog();
    public PdfExtGStateTable get_ExtGStateTable();
    public PdfObject GetObject(PdfObjectID objectID);
    public PdfObject MapExternalObject(PdfObject externalObject);
    public static PdfReference GetReference(PdfObject obj);
    public static PdfObjectID GetObjectID(PdfObject obj);
    public static int GetObjectNumber(PdfObject obj);
    public static int GenerationNumber(PdfObject obj);
    public PdfObject[] GetAllObjects();
    public T CreateIndirectObject();
    public void AddObject(PdfObject obj);
    public void RemoveObject(PdfObject obj);
    public PdfObject[] GetClosure(PdfObject obj);
    public PdfObject[] GetClosure(PdfObject obj, int depth);
    public void WriteObject(Stream stream, PdfItem item);
}
public class PdfSharpCore.Pdf.Advanced.PdfObjectInternals : object {
    private PdfObject _obj;
    public PdfObjectID ObjectID { get; }
    public int ObjectNumber { get; }
    public int GenerationNumber { get; }
    public string TypeID { get; }
    internal PdfObjectInternals(PdfObject obj);
    public PdfObjectID get_ObjectID();
    public int get_ObjectNumber();
    public int get_GenerationNumber();
    public string get_TypeID();
}
public class PdfSharpCore.Pdf.Advanced.PdfObjectStream : PdfDictionary {
    private Int32[][] _header;
    public PdfObjectStream(PdfDocument document);
    internal PdfObjectStream(PdfDictionary dict);
    internal void ReadReferences(PdfCrossReferenceTable xrefTable);
    internal PdfReference ReadCompressedObject(int index);
}
internal class PdfSharpCore.Pdf.Advanced.PdfPageInheritableObjects : PdfDictionary {
    private PdfRectangle _mediaBox;
    private PdfRectangle _cropBox;
    private int _rotate;
    public PdfRectangle MediaBox { get; public set; }
    public PdfRectangle CropBox { get; public set; }
    public int Rotate { get; public set; }
    public PdfRectangle get_MediaBox();
    public void set_MediaBox(PdfRectangle value);
    public PdfRectangle get_CropBox();
    public void set_CropBox(PdfRectangle value);
    public int get_Rotate();
    public void set_Rotate(int value);
}
[DebuggerDisplayAttribute("iref({ObjectNumber}, {GenerationNumber})")]
public class PdfSharpCore.Pdf.Advanced.PdfReference : PdfItem {
    private PdfObjectID _objectID;
    private long _position;
    private PdfObject _value;
    private PdfDocument _document;
    public PdfObjectID ObjectID { get; public set; }
    public int ObjectNumber { get; }
    public int GenerationNumber { get; }
    public long Position { get; public set; }
    public PdfObject Value { get; public set; }
    public PdfDocument Document { get; public set; }
    internal static PdfReferenceComparer Comparer { get; }
    public PdfReference(PdfObject pdfObject);
    public PdfReference(PdfObjectID objectID, long position);
    internal void WriteXRefEnty(PdfWriter writer);
    internal virtual void WriteObject(PdfWriter writer);
    public PdfObjectID get_ObjectID();
    public void set_ObjectID(PdfObjectID value);
    public int get_ObjectNumber();
    public int get_GenerationNumber();
    public long get_Position();
    public void set_Position(long value);
    public PdfObject get_Value();
    public void set_Value(PdfObject value);
    internal void SetObject(PdfObject value);
    public PdfDocument get_Document();
    public void set_Document(PdfDocument value);
    public virtual string ToString();
    internal static PdfReferenceComparer get_Comparer();
}
internal class PdfSharpCore.Pdf.Advanced.PdfResourceMap : PdfDictionary {
    public PdfResourceMap(PdfDocument document);
    protected PdfResourceMap(PdfDictionary dict);
    internal void CollectResourceNames(Dictionary`2<string, object> usedResourceNames);
}
public class PdfSharpCore.Pdf.Advanced.PdfResources : PdfDictionary {
    private PdfResourceMap _fonts;
    private PdfResourceMap _xObjects;
    private PdfResourceMap _extGStates;
    private PdfResourceMap _colorSpaces;
    private PdfResourceMap _patterns;
    private PdfResourceMap _shadings;
    private PdfResourceMap _properties;
    private int _fontNumber;
    private int _imageNumber;
    private int _formNumber;
    private int _extGStateNumber;
    private int _patternNumber;
    private int _shadingNumber;
    private Dictionary`2<string, object> _importedResourceNames;
    private Dictionary`2<PdfObject, string> _resources;
    internal PdfResourceMap Fonts { get; }
    internal PdfResourceMap XObjects { get; }
    internal PdfResourceMap ExtGStates { get; }
    internal PdfResourceMap ColorSpaces { get; }
    internal PdfResourceMap Patterns { get; }
    internal PdfResourceMap Shadings { get; }
    internal PdfResourceMap Properties { get; }
    private string NextFontName { get; }
    private string NextImageName { get; }
    private string NextFormName { get; }
    private string NextExtGStateName { get; }
    private string NextPatternName { get; }
    private string NextShadingName { get; }
    internal DictionaryMeta Meta { get; }
    public PdfResources(PdfDocument document);
    internal PdfResources(PdfDictionary dict);
    public string AddFont(PdfFont font);
    public string AddImage(PdfImage image);
    public string AddForm(PdfFormXObject form);
    public string AddExtGState(PdfExtGState extGState);
    public string AddPattern(PdfShadingPattern pattern);
    public string AddPattern(PdfTilingPattern pattern);
    public string AddShading(PdfShading shading);
    internal PdfResourceMap get_Fonts();
    internal PdfResourceMap get_XObjects();
    internal PdfResourceMap get_ExtGStates();
    internal PdfResourceMap get_ColorSpaces();
    internal PdfResourceMap get_Patterns();
    internal PdfResourceMap get_Shadings();
    internal PdfResourceMap get_Properties();
    private string get_NextFontName();
    private string get_NextImageName();
    private string get_NextFormName();
    private string get_NextExtGStateName();
    private string get_NextPatternName();
    private string get_NextShadingName();
    internal bool ExistsResourceNames(string name);
    internal virtual DictionaryMeta get_Meta();
}
public class PdfSharpCore.Pdf.Advanced.PdfResourceTable : object {
    private PdfDocument _owner;
    protected PdfDocument Owner { get; }
    public PdfResourceTable(PdfDocument owner);
    protected PdfDocument get_Owner();
}
public class PdfSharpCore.Pdf.Advanced.PdfShading : PdfDictionary {
    internal DictionaryMeta Meta { get; }
    public PdfShading(PdfDocument document);
    internal void SetupFromBrush(XBaseGradientBrush brush, XGraphicsPdfRenderer renderer);
    internal void SetupFromBrush(XRadialGradientBrush brush, XGraphicsPdfRenderer renderer);
    internal void SetupFromBrush(XLinearGradientBrush brush, XGraphicsPdfRenderer renderer);
    internal virtual DictionaryMeta get_Meta();
}
public class PdfSharpCore.Pdf.Advanced.PdfShadingPattern : PdfDictionaryWithContentStream {
    internal DictionaryMeta Meta { get; }
    public PdfShadingPattern(PdfDocument document);
    internal void SetupFromBrush(XBaseGradientBrush brush, XMatrix matrix, XGraphicsPdfRenderer renderer);
    internal void SetupFromBrush(XLinearGradientBrush brush, XMatrix matrix, XGraphicsPdfRenderer renderer);
    internal virtual DictionaryMeta get_Meta();
}
public class PdfSharpCore.Pdf.Advanced.PdfSoftMask : PdfDictionary {
    public PdfSoftMask(PdfDocument document);
}
public class PdfSharpCore.Pdf.Advanced.PdfTilingPattern : PdfDictionaryWithContentStream {
    internal DictionaryMeta Meta { get; }
    public PdfTilingPattern(PdfDocument document);
    internal virtual DictionaryMeta get_Meta();
}
internal class PdfSharpCore.Pdf.Advanced.PdfToUnicodeMap : PdfDictionary {
    private CMapInfo _cmapInfo;
    public CMapInfo CMapInfo { get; public set; }
    public PdfToUnicodeMap(PdfDocument document);
    public PdfToUnicodeMap(PdfDocument document, CMapInfo cmapInfo);
    public CMapInfo get_CMapInfo();
    public void set_CMapInfo(CMapInfo value);
    internal virtual void PrepareForSave();
}
internal class PdfSharpCore.Pdf.Advanced.PdfTrailer : PdfDictionary {
    internal PdfStandardSecurityHandler _securityHandler;
    public int Size { get; public set; }
    public PdfDocumentInformation Info { get; }
    public PdfCatalog Root { get; }
    public PdfStandardSecurityHandler SecurityHandler { get; }
    internal DictionaryMeta Meta { get; }
    public PdfTrailer(PdfDocument document);
    public PdfTrailer(PdfCrossReferenceStream trailer);
    public int get_Size();
    public void set_Size(int value);
    public PdfDocumentInformation get_Info();
    public PdfCatalog get_Root();
    public string GetDocumentID(int index);
    public void SetDocumentID(int index, string value);
    internal PdfArray CreateNewDocumentIDs();
    public PdfStandardSecurityHandler get_SecurityHandler();
    internal virtual void WriteObject(PdfWriter writer);
    internal void Finish();
    internal virtual DictionaryMeta get_Meta();
}
public class PdfSharpCore.Pdf.Advanced.PdfTransparencyGroupAttributes : PdfGroupAttributes {
    internal DictionaryMeta Meta { get; }
    internal PdfTransparencyGroupAttributes(PdfDocument thisDocument);
    internal virtual DictionaryMeta get_Meta();
}
internal class PdfSharpCore.Pdf.Advanced.PdfTrueTypeFont : PdfFont {
    private XPdfFontOptions _fontOptions;
    private XPdfFontOptions FontOptions { get; }
    public string BaseFont { get; public set; }
    public int FirstChar { get; public set; }
    public int LastChar { get; public set; }
    public PdfArray Widths { get; }
    public string Encoding { get; public set; }
    internal DictionaryMeta Meta { get; }
    public PdfTrueTypeFont(PdfDocument document);
    public PdfTrueTypeFont(PdfDocument document, XFont font);
    private XPdfFontOptions get_FontOptions();
    public string get_BaseFont();
    public void set_BaseFont(string value);
    public int get_FirstChar();
    public void set_FirstChar(int value);
    public int get_LastChar();
    public void set_LastChar(int value);
    public PdfArray get_Widths();
    public string get_Encoding();
    public void set_Encoding(string value);
    internal virtual void PrepareForSave();
    internal virtual DictionaryMeta get_Meta();
}
internal class PdfSharpCore.Pdf.Advanced.PdfType0Font : PdfFont {
    private XPdfFontOptions _fontOptions;
    private PdfCIDFont _descendantFont;
    private XPdfFontOptions FontOptions { get; }
    public string BaseFont { get; public set; }
    internal PdfCIDFont DescendantFont { get; }
    internal DictionaryMeta Meta { get; }
    public PdfType0Font(PdfDocument document);
    public PdfType0Font(PdfDocument document, XFont font, bool vertical);
    public PdfType0Font(PdfDocument document, string idName, Byte[] fontData, bool vertical);
    private XPdfFontOptions get_FontOptions();
    public string get_BaseFont();
    public void set_BaseFont(string value);
    internal PdfCIDFont get_DescendantFont();
    internal virtual void PrepareForSave();
    internal virtual DictionaryMeta get_Meta();
}
public abstract class PdfSharpCore.Pdf.Advanced.PdfXObject : PdfDictionary {
    protected PdfXObject(PdfDocument document);
}
public enum PdfSharpCore.Pdf.AnnotationCopyingType : Enum {
    public int value__;
    public static AnnotationCopyingType DoNotCopy;
    public static AnnotationCopyingType ShallowCopy;
    public static AnnotationCopyingType DeepCopy;
}
public abstract class PdfSharpCore.Pdf.Annotations.PdfAnnotation : PdfDictionary {
    private PdfAnnotations _parent;
    public PdfAnnotationFlags Flags { get; public set; }
    public PdfAnnotations Parent { get; public set; }
    public PdfRectangle Rectangle { get; public set; }
    public string Title { get; public set; }
    public string Subject { get; public set; }
    public string Contents { get; public set; }
    public XColor Color { get; public set; }
    public double Opacity { get; public set; }
    protected PdfAnnotation(PdfDocument document);
    internal PdfAnnotation(PdfDictionary dict);
    private void Initialize();
    public PdfAnnotationFlags get_Flags();
    public void set_Flags(PdfAnnotationFlags value);
    public PdfAnnotations get_Parent();
    public void set_Parent(PdfAnnotations value);
    public PdfRectangle get_Rectangle();
    public void set_Rectangle(PdfRectangle value);
    public string get_Title();
    public void set_Title(string value);
    public string get_Subject();
    public void set_Subject(string value);
    public string get_Contents();
    public void set_Contents(string value);
    public XColor get_Color();
    public void set_Color(XColor value);
    public double get_Opacity();
    public void set_Opacity(double value);
}
public enum PdfSharpCore.Pdf.Annotations.PdfAnnotationFlags : Enum {
    public int value__;
    public static PdfAnnotationFlags Invisible;
    public static PdfAnnotationFlags Hidden;
    public static PdfAnnotationFlags Print;
    public static PdfAnnotationFlags NoZoom;
    public static PdfAnnotationFlags NoRotate;
    public static PdfAnnotationFlags NoView;
    public static PdfAnnotationFlags ReadOnly;
    public static PdfAnnotationFlags Locked;
    public static PdfAnnotationFlags ToggleNoView;
}
[DefaultMemberAttribute("Item")]
public class PdfSharpCore.Pdf.Annotations.PdfAnnotations : PdfArray {
    private PdfPage _page;
    public int Count { get; }
    public PdfAnnotation Item { get; }
    internal PdfPage Page { get; internal set; }
    internal PdfAnnotations(PdfDocument document);
    internal PdfAnnotations(PdfArray array);
    public void Add(PdfAnnotation annotation);
    public void Remove(PdfAnnotation annotation);
    public void Clear();
    public int get_Count();
    public PdfAnnotation get_Item(int index);
    internal PdfPage get_Page();
    internal void set_Page(PdfPage value);
    internal static void FixImportedAnnotation(PdfPage page);
    public virtual IEnumerator`1<PdfItem> GetEnumerator();
}
public class PdfSharpCore.Pdf.Annotations.PdfFileAttachmentAnnotation : PdfAnnotation {
    public IconType Icon { get; public set; }
    public PdfFileSpecification File { get; public set; }
    internal DictionaryMeta Meta { get; }
    public PdfFileAttachmentAnnotation(PdfDocument document);
    public IconType get_Icon();
    public void set_Icon(IconType value);
    public PdfFileSpecification get_File();
    public void set_File(PdfFileSpecification value);
    internal virtual DictionaryMeta get_Meta();
}
internal class PdfSharpCore.Pdf.Annotations.PdfGenericAnnotation : PdfAnnotation {
    internal DictionaryMeta Meta { get; }
    public PdfGenericAnnotation(PdfDictionary dict);
    internal virtual DictionaryMeta get_Meta();
}
public class PdfSharpCore.Pdf.Annotations.PdfLinkAnnotation : PdfAnnotation {
    private int _destPage;
    private LinkType _linkType;
    private string _url;
    internal DictionaryMeta Meta { get; }
    public PdfLinkAnnotation(PdfDocument document);
    public static PdfLinkAnnotation CreateDocumentLink(PdfRectangle rect, int destinationPage);
    public static PdfLinkAnnotation CreateWebLink(PdfRectangle rect, string url);
    public static PdfLinkAnnotation CreateFileLink(PdfRectangle rect, string fileName);
    internal virtual void WriteObject(PdfWriter writer);
    internal virtual DictionaryMeta get_Meta();
}
public class PdfSharpCore.Pdf.Annotations.PdfRubberStampAnnotation : PdfAnnotation {
    public PdfRubberStampAnnotationIcon Icon { get; public set; }
    internal DictionaryMeta Meta { get; }
    public PdfRubberStampAnnotation(PdfDocument document);
    private void Initialize();
    public PdfRubberStampAnnotationIcon get_Icon();
    public void set_Icon(PdfRubberStampAnnotationIcon value);
    internal virtual DictionaryMeta get_Meta();
}
public enum PdfSharpCore.Pdf.Annotations.PdfRubberStampAnnotationIcon : Enum {
    public int value__;
    public static PdfRubberStampAnnotationIcon NoIcon;
    public static PdfRubberStampAnnotationIcon Approved;
    public static PdfRubberStampAnnotationIcon AsIs;
    public static PdfRubberStampAnnotationIcon Confidential;
    public static PdfRubberStampAnnotationIcon Departmental;
    public static PdfRubberStampAnnotationIcon Draft;
    public static PdfRubberStampAnnotationIcon Experimental;
    public static PdfRubberStampAnnotationIcon Expired;
    public static PdfRubberStampAnnotationIcon Final;
    public static PdfRubberStampAnnotationIcon ForComment;
    public static PdfRubberStampAnnotationIcon ForPublicRelease;
    public static PdfRubberStampAnnotationIcon NotApproved;
    public static PdfRubberStampAnnotationIcon NotForPublicRelease;
    public static PdfRubberStampAnnotationIcon Sold;
    public static PdfRubberStampAnnotationIcon TopSecret;
}
public class PdfSharpCore.Pdf.Annotations.PdfTextAnnotation : PdfAnnotation {
    public bool Open { get; public set; }
    public PdfTextAnnotationIcon Icon { get; public set; }
    internal DictionaryMeta Meta { get; }
    public PdfTextAnnotation(PdfDocument document);
    private void Initialize();
    public bool get_Open();
    public void set_Open(bool value);
    public PdfTextAnnotationIcon get_Icon();
    public void set_Icon(PdfTextAnnotationIcon value);
    internal virtual DictionaryMeta get_Meta();
}
public enum PdfSharpCore.Pdf.Annotations.PdfTextAnnotationIcon : Enum {
    public int value__;
    public static PdfTextAnnotationIcon NoIcon;
    public static PdfTextAnnotationIcon Comment;
    public static PdfTextAnnotationIcon Help;
    public static PdfTextAnnotationIcon Insert;
    public static PdfTextAnnotationIcon Key;
    public static PdfTextAnnotationIcon NewParagraph;
    public static PdfTextAnnotationIcon Note;
    public static PdfTextAnnotationIcon Paragraph;
}
internal class PdfSharpCore.Pdf.Annotations.PdfWidgetAnnotation : PdfAnnotation {
    internal DictionaryMeta Meta { get; }
    public PdfWidgetAnnotation(PdfDocument document);
    private void Initialize();
    internal virtual DictionaryMeta get_Meta();
}
internal static class PdfSharpCore.Pdf.Content.Chars : object {
    public static char EOF;
    public static char NUL;
    public static char CR;
    public static char LF;
    public static char BEL;
    public static char BS;
    public static char FF;
    public static char HT;
    public static char VT;
    public static char NonBreakableSpace;
    public static char SP;
    public static char QuoteDbl;
    public static char QuoteSingle;
    public static char ParenLeft;
    public static char ParenRight;
    public static char BraceLeft;
    public static char BraceRight;
    public static char BracketLeft;
    public static char BracketRight;
    public static char Less;
    public static char Greater;
    public static char Equal;
    public static char Period;
    public static char Semicolon;
    public static char Colon;
    public static char Slash;
    public static char Bar;
    public static char BackSlash;
    public static char Percent;
    public static char Dollar;
    public static char At;
    public static char NumberSign;
    public static char Asterisk;
    public static char Question;
    public static char Hyphen;
    public static char SoftHyphen;
    public static char Currency;
}
public class PdfSharpCore.Pdf.Content.CLexer : object {
    private static Double[] PowersOf10;
    private Byte[] _content;
    private int _charIndex;
    private char _currChar;
    private char _nextChar;
    private StringBuilder _token;
    private long _tokenAsLong;
    private double _tokenAsReal;
    private CSymbol _symbol;
    public CSymbol Symbol { get; public set; }
    public string Token { get; }
    internal int TokenToInteger { get; }
    internal double TokenToReal { get; }
    public int ContLength { get; }
    public int Position { get; public set; }
    public CLexer(Byte[] content);
    public CLexer(MemoryStream content);
    private static CLexer();
    public CSymbol ScanNextToken();
    public CSymbol ScanComment();
    public CSymbol ScanInlineImage();
    public CSymbol ScanName();
    protected CSymbol ScanDictionary();
    public CSymbol ScanNumber();
    public CSymbol ScanOperator();
    public CSymbol ScanLiteralString();
    public CSymbol ScanHexadecimalString();
    internal char ScanNextChar();
    private void ClearToken();
    internal char AppendAndScanNextChar();
    public char MoveToNonWhiteSpace();
    public CSymbol get_Symbol();
    public void set_Symbol(CSymbol value);
    public string get_Token();
    internal int get_TokenToInteger();
    internal double get_TokenToReal();
    internal static bool IsWhiteSpace(char ch);
    internal static bool IsOperatorChar(char ch);
    internal static bool IsDelimiter(char ch);
    public int get_ContLength();
    public int get_Position();
    public void set_Position(int value);
}
public static class PdfSharpCore.Pdf.Content.ContentReader : object {
    public static CSequence ReadContent(PdfPage page);
    public static CSequence ReadContent(Byte[] content);
    public static CSequence ReadContent(MemoryStream content);
}
public class PdfSharpCore.Pdf.Content.ContentReaderException : PdfSharpException {
    public ContentReaderException(string message);
    public ContentReaderException(string message, Exception innerException);
}
internal class PdfSharpCore.Pdf.Content.ContentWriter : object {
    protected int _indent;
    protected int _writeIndent;
    private CharCat _lastCat;
    private Stream _stream;
    public int Position { get; }
    internal int Indent { get; internal set; }
    private string IndentBlanks { get; }
    internal Stream Stream { get; }
    public ContentWriter(Stream contentStream);
    public void Close(bool closeUnderlyingStream);
    public void Close();
    public int get_Position();
    public void Write(bool value);
    public void WriteRaw(string rawString);
    public void WriteLineRaw(string rawString);
    public void WriteRaw(char ch);
    internal int get_Indent();
    internal void set_Indent(int value);
    private void IncreaseIndent();
    private void DecreaseIndent();
    private string get_IndentBlanks();
    private void WriteIndent();
    private void WriteSeparator(CharCat cat, char ch);
    private void WriteSeparator(CharCat cat);
    public void NewLine();
    private CharCat GetCategory(char ch);
    internal Stream get_Stream();
}
public class PdfSharpCore.Pdf.Content.CParser : object {
    private CSequence _operands;
    private PdfPage _page;
    private CLexer _lexer;
    public CSymbol Symbol { get; }
    public CParser(PdfPage page);
    public CParser(Byte[] content);
    public CParser(MemoryStream content);
    public CParser(CLexer lexer);
    public CSymbol get_Symbol();
    public CSequence ReadContent();
    private void ParseObject(CSequence sequence, CSymbol stop);
    private COperator CreateOperator();
    private COperator CreateOperator(OpCodeName nameop);
    private COperator CreateOperator(COperator op);
    private CSymbol ScanNextToken();
    private CSymbol ScanNextToken(String& token);
    private CSymbol ReadSymbol(CSymbol symbol);
}
public enum PdfSharpCore.Pdf.Content.CSymbol : Enum {
    public int value__;
    public static CSymbol None;
    public static CSymbol Comment;
    public static CSymbol Integer;
    public static CSymbol Real;
    public static CSymbol String;
    public static CSymbol HexString;
    public static CSymbol UnicodeString;
    public static CSymbol UnicodeHexString;
    public static CSymbol Name;
    public static CSymbol Operator;
    public static CSymbol BeginArray;
    public static CSymbol EndArray;
    public static CSymbol Dictionary;
    public static CSymbol Eof;
    public static CSymbol Error;
}
[DebuggerDisplayAttribute("(count={Count})")]
public class PdfSharpCore.Pdf.Content.Objects.CArray : CSequence {
    public CArray Clone();
    protected virtual CObject Copy();
    public virtual string ToString();
    internal virtual void WriteObject(ContentWriter writer);
}
[DebuggerDisplayAttribute("({Text})")]
public class PdfSharpCore.Pdf.Content.Objects.CComment : CObject {
    private string _text;
    public string Text { get; public set; }
    public CComment Clone();
    protected virtual CObject Copy();
    public string get_Text();
    public void set_Text(string value);
    public virtual string ToString();
    internal virtual void WriteObject(ContentWriter writer);
}
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharpCore.Pdf.Content.Objects.CInteger : CNumber {
    private int _value;
    public int Value { get; public set; }
    public CInteger Clone();
    protected virtual CObject Copy();
    public int get_Value();
    public void set_Value(int value);
    public virtual string ToString();
    internal virtual void WriteObject(ContentWriter writer);
}
[DebuggerDisplayAttribute("({Name})")]
public class PdfSharpCore.Pdf.Content.Objects.CName : CObject {
    private static string NamePrefix;
    private string _name;
    public string Name { get; public set; }
    public CName(string name);
    public CName Clone();
    protected virtual CObject Copy();
    public string get_Name();
    public void set_Name(string value);
    public virtual string ToString();
    internal virtual void WriteObject(ContentWriter writer);
}
public abstract class PdfSharpCore.Pdf.Content.Objects.CNumber : CObject {
    public CNumber Clone();
    protected virtual CObject Copy();
}
public abstract class PdfSharpCore.Pdf.Content.Objects.CObject : object {
    private sealed virtual override object System.ICloneable.Clone();
    public CObject Clone();
    protected virtual CObject Copy();
    internal abstract virtual void WriteObject(ContentWriter writer);
}
[DebuggerDisplayAttribute("({Name}, operands={Operands.Count})")]
public class PdfSharpCore.Pdf.Content.Objects.COperator : CObject {
    private CSequence _seqence;
    private OpCode _opcode;
    public string Name { get; }
    public CSequence Operands { get; }
    public OpCode OpCode { get; }
    internal COperator(OpCode opcode);
    public COperator Clone();
    protected virtual CObject Copy();
    public virtual string get_Name();
    public CSequence get_Operands();
    public OpCode get_OpCode();
    public virtual string ToString();
    internal virtual void WriteObject(ContentWriter writer);
}
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharpCore.Pdf.Content.Objects.CReal : CNumber {
    private double _value;
    public double Value { get; public set; }
    public CReal Clone();
    protected virtual CObject Copy();
    public double get_Value();
    public void set_Value(double value);
    public virtual string ToString();
    internal virtual void WriteObject(ContentWriter writer);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("(count={Count})")]
public class PdfSharpCore.Pdf.Content.Objects.CSequence : CObject {
    private List`1<CObject> _items;
    public CObject Item { get; public set; }
    public int Count { get; }
    private CObject System.Collections.Generic.IList<PdfSharpCore.Pdf.Content.Objects.CObject>.Item { get; private set; }
    private int System.Collections.Generic.ICollection<PdfSharpCore.Pdf.Content.Objects.CObject>.Count { get; }
    private bool System.Collections.Generic.ICollection<PdfSharpCore.Pdf.Content.Objects.CObject>.IsReadOnly { get; }
    public CSequence Clone();
    protected virtual CObject Copy();
    public void Add(CSequence sequence);
    public void Add(CObject value);
    public void Clear();
    public bool Contains(CObject value);
    public int IndexOf(CObject value);
    public void Insert(int index, CObject value);
    public bool Remove(CObject value);
    public void RemoveAt(int index);
    public CObject get_Item(int index);
    public void set_Item(int index, CObject value);
    public void CopyTo(CObject[] array, int index);
    public int get_Count();
    public IEnumerator`1<CObject> GetEnumerator();
    public Byte[] ToContent();
    public virtual string ToString();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal virtual void WriteObject(ContentWriter writer);
    private sealed virtual override int System.Collections.Generic.IList<PdfSharpCore.Pdf.Content.Objects.CObject>.IndexOf(CObject item);
    private sealed virtual override void System.Collections.Generic.IList<PdfSharpCore.Pdf.Content.Objects.CObject>.Insert(int index, CObject item);
    private sealed virtual override void System.Collections.Generic.IList<PdfSharpCore.Pdf.Content.Objects.CObject>.RemoveAt(int index);
    private sealed virtual override CObject System.Collections.Generic.IList<PdfSharpCore.Pdf.Content.Objects.CObject>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<PdfSharpCore.Pdf.Content.Objects.CObject>.set_Item(int index, CObject value);
    private sealed virtual override void System.Collections.Generic.ICollection<PdfSharpCore.Pdf.Content.Objects.CObject>.Add(CObject item);
    private sealed virtual override void System.Collections.Generic.ICollection<PdfSharpCore.Pdf.Content.Objects.CObject>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<PdfSharpCore.Pdf.Content.Objects.CObject>.Contains(CObject item);
    private sealed virtual override void System.Collections.Generic.ICollection<PdfSharpCore.Pdf.Content.Objects.CObject>.CopyTo(CObject[] array, int arrayIndex);
    private sealed virtual override int System.Collections.Generic.ICollection<PdfSharpCore.Pdf.Content.Objects.CObject>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<PdfSharpCore.Pdf.Content.Objects.CObject>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<PdfSharpCore.Pdf.Content.Objects.CObject>.Remove(CObject item);
    private sealed virtual override IEnumerator`1<CObject> System.Collections.Generic.IEnumerable<PdfSharpCore.Pdf.Content.Objects.CObject>.GetEnumerator();
}
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharpCore.Pdf.Content.Objects.CString : CObject {
    private string _value;
    private CStringType _cStringType;
    public string Value { get; public set; }
    public CStringType CStringType { get; public set; }
    public CString Clone();
    protected virtual CObject Copy();
    public string get_Value();
    public void set_Value(string value);
    public CStringType get_CStringType();
    public void set_CStringType(CStringType value);
    public virtual string ToString();
    internal virtual void WriteObject(ContentWriter writer);
}
public enum PdfSharpCore.Pdf.Content.Objects.CStringType : Enum {
    public int value__;
    public static CStringType String;
    public static CStringType HexString;
    public static CStringType UnicodeString;
    public static CStringType UnicodeHexString;
    public static CStringType Dictionary;
}
public class PdfSharpCore.Pdf.Content.Objects.OpCode : object {
    public string Name;
    public OpCodeName OpCodeName;
    public int Operands;
    public OpCodeFlags Flags;
    public string Postscript;
    public string Description;
    internal OpCode(string name, OpCodeName opcodeName, int operands, string postscript, OpCodeFlags flags, string description);
}
[FlagsAttribute]
public enum PdfSharpCore.Pdf.Content.Objects.OpCodeFlags : Enum {
    public int value__;
    public static OpCodeFlags None;
    public static OpCodeFlags TextOut;
}
public enum PdfSharpCore.Pdf.Content.Objects.OpCodeName : Enum {
    public int value__;
    public static OpCodeName Dictionary;
    public static OpCodeName b;
    public static OpCodeName B;
    public static OpCodeName bx;
    public static OpCodeName Bx;
    public static OpCodeName BDC;
    public static OpCodeName BI;
    public static OpCodeName BMC;
    public static OpCodeName BT;
    public static OpCodeName BX;
    public static OpCodeName c;
    public static OpCodeName cm;
    public static OpCodeName CS;
    public static OpCodeName cs;
    public static OpCodeName d;
    public static OpCodeName d0;
    public static OpCodeName d1;
    public static OpCodeName Do;
    public static OpCodeName DP;
    public static OpCodeName EI;
    public static OpCodeName EMC;
    public static OpCodeName ET;
    public static OpCodeName EX;
    public static OpCodeName f;
    public static OpCodeName F;
    public static OpCodeName fx;
    public static OpCodeName G;
    public static OpCodeName g;
    public static OpCodeName gs;
    public static OpCodeName h;
    public static OpCodeName i;
    public static OpCodeName ID;
    public static OpCodeName j;
    public static OpCodeName J;
    public static OpCodeName K;
    public static OpCodeName k;
    public static OpCodeName l;
    public static OpCodeName m;
    public static OpCodeName M;
    public static OpCodeName MP;
    public static OpCodeName n;
    public static OpCodeName q;
    public static OpCodeName Q;
    public static OpCodeName re;
    public static OpCodeName RG;
    public static OpCodeName rg;
    public static OpCodeName ri;
    public static OpCodeName s;
    public static OpCodeName S;
    public static OpCodeName SC;
    public static OpCodeName sc;
    public static OpCodeName SCN;
    public static OpCodeName scn;
    public static OpCodeName sh;
    public static OpCodeName Tx;
    public static OpCodeName Tc;
    public static OpCodeName Td;
    public static OpCodeName TD;
    public static OpCodeName Tf;
    public static OpCodeName Tj;
    public static OpCodeName TJ;
    public static OpCodeName TL;
    public static OpCodeName Tm;
    public static OpCodeName Tr;
    public static OpCodeName Ts;
    public static OpCodeName Tw;
    public static OpCodeName Tz;
    public static OpCodeName v;
    public static OpCodeName w;
    public static OpCodeName W;
    public static OpCodeName Wx;
    public static OpCodeName y;
    public static OpCodeName QuoteSingle;
    public static OpCodeName QuoteDbl;
}
public static class PdfSharpCore.Pdf.Content.Objects.OpCodes : object {
    private static Dictionary`2<string, OpCode> StringToOpCode;
    private static OpCode Dictionary;
    private static OpCode b;
    private static OpCode B;
    private static OpCode bx;
    private static OpCode Bx;
    private static OpCode BDC;
    private static OpCode BI;
    private static OpCode BMC;
    private static OpCode BT;
    private static OpCode BX;
    private static OpCode c;
    private static OpCode cm;
    private static OpCode CS;
    private static OpCode cs;
    private static OpCode d;
    private static OpCode d0;
    private static OpCode d1;
    private static OpCode Do;
    private static OpCode DP;
    private static OpCode EI;
    private static OpCode EMC;
    private static OpCode ET;
    private static OpCode EX;
    private static OpCode f;
    private static OpCode F;
    private static OpCode fx;
    private static OpCode G;
    private static OpCode g;
    private static OpCode gs;
    private static OpCode h;
    private static OpCode i;
    private static OpCode ID;
    private static OpCode j;
    private static OpCode J;
    private static OpCode K;
    private static OpCode k;
    private static OpCode l;
    private static OpCode m;
    private static OpCode M;
    private static OpCode MP;
    private static OpCode n;
    private static OpCode q;
    private static OpCode Q;
    private static OpCode re;
    private static OpCode RG;
    private static OpCode rg;
    private static OpCode ri;
    private static OpCode s;
    private static OpCode S;
    private static OpCode SC;
    private static OpCode sc;
    private static OpCode SCN;
    private static OpCode scn;
    private static OpCode sh;
    private static OpCode Tx;
    private static OpCode Tc;
    private static OpCode Td;
    private static OpCode TD;
    private static OpCode Tf;
    private static OpCode Tj;
    private static OpCode TJ;
    private static OpCode TL;
    private static OpCode Tm;
    private static OpCode Tr;
    private static OpCode Ts;
    private static OpCode Tw;
    private static OpCode Tz;
    private static OpCode v;
    private static OpCode w;
    private static OpCode W;
    private static OpCode Wx;
    private static OpCode y;
    private static OpCode QuoteSingle;
    private static OpCode QuoteDbl;
    private static OpCode[] ops;
    private static OpCodes();
    public static COperator OperatorFromName(string name);
}
[DefaultMemberAttribute("Item")]
internal class PdfSharpCore.Pdf.DictionaryMeta : object {
    private Dictionary`2<string, KeyDescriptor> _keyDescriptors;
    public KeyDescriptor Item { get; }
    public DictionaryMeta(Type type);
    private void CollectKeyDescriptors(Type type);
    public KeyDescriptor get_Item(string key);
}
[FlagsAttribute]
internal enum PdfSharpCore.Pdf.DocumentState : Enum {
    public int value__;
    public static DocumentState Created;
    public static DocumentState Imported;
    public static DocumentState Disposed;
}
public class PdfSharpCore.Pdf.Filters.Ascii85Decode : Filter {
    public virtual Byte[] Encode(Byte[] data);
    public virtual Byte[] Decode(Byte[] data, FilterParms parms);
}
public class PdfSharpCore.Pdf.Filters.AsciiHexDecode : Filter {
    public virtual Byte[] Encode(Byte[] data);
    public virtual Byte[] Decode(Byte[] data, FilterParms parms);
}
public abstract class PdfSharpCore.Pdf.Filters.Filter : object {
    public abstract virtual Byte[] Encode(Byte[] data);
    public virtual Byte[] Encode(string rawString);
    public abstract virtual Byte[] Decode(Byte[] data, FilterParms parms);
    public Byte[] Decode(Byte[] data, PdfDictionary decodeParms);
    public virtual string DecodeToString(Byte[] data, FilterParms parms);
    public string DecodeToString(Byte[] data);
    protected Byte[] RemoveWhiteSpace(Byte[] data);
}
public static class PdfSharpCore.Pdf.Filters.Filtering : object {
    private static AsciiHexDecode _asciiHexDecode;
    private static Ascii85Decode _ascii85Decode;
    private static LzwDecode _lzwDecode;
    private static FlateDecode _flateDecode;
    public static AsciiHexDecode ASCIIHexDecode { get; }
    public static Ascii85Decode ASCII85Decode { get; }
    public static LzwDecode LzwDecode { get; }
    public static FlateDecode FlateDecode { get; }
    public static Filter GetFilter(string filterName);
    public static AsciiHexDecode get_ASCIIHexDecode();
    public static Ascii85Decode get_ASCII85Decode();
    public static LzwDecode get_LzwDecode();
    public static FlateDecode get_FlateDecode();
    public static Byte[] Encode(Byte[] data, string filterName);
    public static Byte[] Encode(string rawString, string filterName);
    public static Byte[] Decode(Byte[] data, string filterName, FilterParms parms);
    public static Byte[] Decode(Byte[] data, string filterName);
    public static Byte[] Decode(Byte[] data, PdfItem filterItem, PdfItem decodeParms);
    public static string DecodeToString(Byte[] data, string filterName, FilterParms parms);
    public static string DecodeToString(Byte[] data, string filterName);
}
public class PdfSharpCore.Pdf.Filters.FilterParms : object {
    [CompilerGeneratedAttribute]
private PdfDictionary <DecodeParms>k__BackingField;
    public PdfDictionary DecodeParms { get; private set; }
    public FilterParms(PdfDictionary decodeParms);
    [CompilerGeneratedAttribute]
public PdfDictionary get_DecodeParms();
    [CompilerGeneratedAttribute]
private void set_DecodeParms(PdfDictionary value);
}
public class PdfSharpCore.Pdf.Filters.FlateDecode : Filter {
    public virtual Byte[] Encode(Byte[] data);
    public Byte[] Encode(Byte[] data, PdfFlateEncodeMode mode);
    public virtual Byte[] Decode(Byte[] data, FilterParms parms);
}
public class PdfSharpCore.Pdf.Filters.LzwDecode : Filter {
    private Int32[] _andTable;
    private Byte[][] _stringTable;
    private Byte[] _data;
    private int _tableIndex;
    private int _bitsToGet;
    private int _bytePointer;
    private int _nextData;
    private int _nextBits;
    private int NextCode { get; }
    public virtual Byte[] Encode(Byte[] data);
    public virtual Byte[] Decode(Byte[] data, FilterParms parms);
    private void InitializeDictionary();
    private void AddEntry(Byte[] oldstring, byte newstring);
    private int get_NextCode();
}
internal static class PdfSharpCore.Pdf.Filters.PngFilter : object {
    internal static void Unfilter(int stride, int bpp, Byte[] inData, Byte[] outData);
    private static byte PaethPredictor(byte a, byte b, byte c);
}
internal static class PdfSharpCore.Pdf.Filters.StreamDecoder : object {
    public static Byte[] Decode(Byte[] data, PdfDictionary decodeParms);
}
public class PdfSharpCore.Pdf.Internal.AnsiEncoding : Encoding {
    private static Char[] AnsiToUnicode;
    private static AnsiEncoding();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public static bool IsAnsi1252Char(char ch);
    public static char UnicodeToAnsi(char ch);
}
internal static class PdfSharpCore.Pdf.Internal.ColorSpaceHelper : object {
    public static XColor EnsureColorMode(PdfColorMode colorMode, XColor color);
    public static XColor EnsureColorMode(PdfDocument document, XColor color);
    public static bool IsEqualCmyk(XColor x, XColor y);
}
internal class PdfSharpCore.Pdf.Internal.DocEncoding : Encoding {
    private static Byte[] AnsiToDoc;
    private static Char[] PdfDocToUnicode;
    private static DocEncoding();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
}
internal class PdfSharpCore.Pdf.Internal.PdfDiagnostics : object {
    private static bool _traceCompressedObjects;
    private static bool _traceXrefStreams;
    private static bool _traceObjectStreams;
    public static bool TraceCompressedObjects { get; public set; }
    public static bool TraceXrefStreams { get; public set; }
    public static bool TraceObjectStreams { get; public set; }
    private static PdfDiagnostics();
    public static bool get_TraceCompressedObjects();
    public static void set_TraceCompressedObjects(bool value);
    public static bool get_TraceXrefStreams();
    public static void set_TraceXrefStreams(bool value);
    public static bool get_TraceObjectStreams();
    public static void set_TraceObjectStreams(bool value);
}
internal static class PdfSharpCore.Pdf.Internal.PdfEncoders : object {
    private static Encoding _rawEncoding;
    private static Encoding _rawUnicodeEncoding;
    private static Encoding _winAnsiEncoding;
    private static Encoding _docEncoding;
    private static Encoding _unicodeEncoding;
    private static Byte[] docencode_______;
    public static Encoding RawEncoding { get; }
    public static Encoding RawUnicodeEncoding { get; }
    public static Encoding WinAnsiEncoding { get; }
    public static Encoding DocEncoding { get; }
    public static Encoding UnicodeEncoding { get; }
    private static PdfEncoders();
    public static Encoding get_RawEncoding();
    public static Encoding get_RawUnicodeEncoding();
    public static Encoding get_WinAnsiEncoding();
    public static Encoding get_DocEncoding();
    public static Encoding get_UnicodeEncoding();
    public static string ToStringLiteral(string text, PdfStringEncoding encoding, PdfStandardSecurityHandler securityHandler);
    public static string ToStringLiteral(Byte[] bytes, bool unicode, PdfStandardSecurityHandler securityHandler);
    public static string ToHexStringLiteral(string text, PdfStringEncoding encoding, PdfStandardSecurityHandler securityHandler);
    public static string ToHexStringLiteral(Byte[] bytes, bool unicode, PdfStandardSecurityHandler securityHandler);
    public static Byte[] FormatStringLiteral(Byte[] bytes, bool unicode, bool prefix, bool hex, PdfStandardSecurityHandler securityHandler);
    public static string Format(string format, Object[] args);
    public static string ToString(double val);
    public static string ToString(XColor color, PdfColorMode colorMode, bool withAlpha);
    public static string ToString(XMatrix matrix);
}
public class PdfSharpCore.Pdf.Internal.RawEncoding : Encoding {
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
}
internal class PdfSharpCore.Pdf.Internal.RawUnicodeEncoding : Encoding {
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
}
internal class PdfSharpCore.Pdf.Internal.ThreadLocalStorage : object {
    private Dictionary`2<string, DocumentHandle> _importedDocuments;
    public PdfDocument[] Documents { get; }
    public void AddDocument(string path, PdfDocument document);
    public void RemoveDocument(string path);
    public PdfDocument GetDocument(string path, PdfReadAccuracy accuracy);
    public PdfDocument[] get_Documents();
    public void DetachDocument(DocumentHandle handle);
}
public class PdfSharpCore.Pdf.IO.Chars : object {
    public static char EOF;
    public static char NUL;
    public static char CR;
    public static char LF;
    public static char BEL;
    public static char BS;
    public static char FF;
    public static char HT;
    public static char VT;
    public static char NonBreakableSpace;
    public static char SP;
    public static char QuoteDbl;
    public static char QuoteSingle;
    public static char ParenLeft;
    public static char ParenRight;
    public static char BraceLeft;
    public static char BraceRight;
    public static char BracketLeft;
    public static char BracketRight;
    public static char Less;
    public static char Greater;
    public static char Equal;
    public static char Period;
    public static char Semicolon;
    public static char Colon;
    public static char Slash;
    public static char Bar;
    public static char BackSlash;
    public static char Percent;
    public static char Dollar;
    public static char At;
    public static char NumberSign;
    public static char Question;
    public static char Hyphen;
    public static char SoftHyphen;
    public static char Currency;
}
public enum PdfSharpCore.Pdf.IO.enums.PdfReadAccuracy : Enum {
    public int value__;
    public static PdfReadAccuracy Strict;
    public static PdfReadAccuracy Moderate;
}
public class PdfSharpCore.Pdf.IO.Lexer : object {
    private long _pdfLength;
    private long _idxChar;
    private char _currChar;
    private char _nextChar;
    private StringBuilder _token;
    private Symbol _symbol;
    private Stream _pdfSteam;
    public long Position { get; public set; }
    public Symbol Symbol { get; public set; }
    public string Token { get; }
    public bool TokenToBoolean { get; }
    public int TokenToInteger { get; }
    public UInt32 TokenToUInteger { get; }
    public long TokenToLong { get; }
    public double TokenToReal { get; }
    public PdfObjectID TokenToObjectID { get; }
    public long PdfLength { get; }
    public Lexer(Stream pdfInputStream);
    public long get_Position();
    public void set_Position(long value);
    public Symbol ScanNextToken();
    public Byte[] ReadStream(int length);
    internal long MoveToStartOfStream();
    internal Byte[] ScanUntilMarker(Byte[] marker, Boolean& markerFound);
    public string ReadRawString(long position, int length);
    public Symbol ScanComment();
    public Symbol ScanName();
    public Symbol ScanNumber();
    public Symbol ScanNumberOrReference();
    public Symbol ScanKeyword();
    public Symbol ScanLiteralString();
    public Symbol ScanHexadecimalString();
    internal static bool IsHexChar(char c);
    internal char ScanNextChar(bool handleCRLF);
    private bool PeekReference();
    internal char AppendAndScanNextChar();
    public char MoveToNonWhiteSpace();
    public Symbol get_Symbol();
    public void set_Symbol(Symbol value);
    public string get_Token();
    public bool get_TokenToBoolean();
    public int get_TokenToInteger();
    public UInt32 get_TokenToUInteger();
    public long get_TokenToLong();
    public double get_TokenToReal();
    public PdfObjectID get_TokenToObjectID();
    internal static bool IsWhiteSpace(char ch);
    internal static bool IsDelimiter(char ch);
    public long get_PdfLength();
}
internal class PdfSharpCore.Pdf.IO.Parser : object {
    private PdfDocument _document;
    private Lexer _lexer;
    private ShiftStack _stack;
    public Symbol Symbol { get; }
    public Parser(PdfDocument document, Stream pdf);
    public Parser(PdfDocument document);
    public long MoveToObject(PdfObjectID objectID);
    public Symbol get_Symbol();
    public PdfObjectID ReadObjectNumber(int position);
    public PdfObject ReadObject(PdfObject pdfObject, PdfObjectID objectID, bool includeReferences, bool fromObjecStream);
    private void ReadStream(PdfDictionary dict);
    private int GetStreamLength(PdfDictionary dict);
    public PdfArray ReadArray(PdfArray array, bool includeReferences);
    internal PdfDictionary ReadDictionary(PdfDictionary dict, bool includeReferences);
    private void ParseObject(Symbol stop);
    private Symbol ScanNextToken();
    private Symbol ScanNextToken(String& token);
    private Symbol SkipCharsUntil(Symbol stop);
    private Symbol SkipCharsUntil(string text, Symbol stop);
    private void ReadObjectID(PdfObject obj);
    private PdfItem ReadReference(PdfReference iref, bool includeReferences);
    private Symbol ReadSymbol(Symbol symbol);
    private Symbol ReadToken(string token);
    private string ReadName();
    private int ReadInteger(bool canBeIndirect);
    private int ReadInteger();
    private long ReadLong();
    private long ReadLong(bool canBeIndirect);
    public static PdfObject ReadObject(PdfDocument owner, PdfObjectID objectID);
    internal void ReadIRefsFromCompressedObject(PdfObjectID objectID);
    internal PdfReference ReadCompressedObject(PdfObjectID objectID, int index);
    internal PdfReference ReadCompressedObject(int objectNumber, int offset);
    internal Int32[][] ReadObjectStreamHeader(int n, int first);
    internal PdfTrailer ReadTrailer(PdfReadAccuracy accuracy);
    private PdfTrailer ReadXRefTableAndTrailer(PdfCrossReferenceTable xrefTable, PdfReadAccuracy accuracy);
    private bool CheckXRefTableEntry(long position, int id, int generation, Int32& idChecked, Int32& generationChecked);
    private PdfTrailer ReadXRefStream(PdfCrossReferenceTable xrefTable);
    internal static DateTime ParseDateTime(string date, DateTime errorValue);
    private ParserState SaveState();
    private void RestoreState(ParserState state);
}
public enum PdfSharpCore.Pdf.IO.PasswordValidity : Enum {
    public int value__;
    public static PasswordValidity Invalid;
    public static PasswordValidity UserPassword;
    public static PasswordValidity OwnerPassword;
}
public enum PdfSharpCore.Pdf.IO.PdfDocumentOpenMode : Enum {
    public int value__;
    public static PdfDocumentOpenMode Modify;
    public static PdfDocumentOpenMode Import;
    public static PdfDocumentOpenMode ReadOnly;
    public static PdfDocumentOpenMode InformationOnly;
}
public class PdfSharpCore.Pdf.IO.PdfPasswordProvider : MulticastDelegate {
    public PdfPasswordProvider(object object, IntPtr method);
    public virtual void Invoke(PdfPasswordProviderArgs args);
    public virtual IAsyncResult BeginInvoke(PdfPasswordProviderArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class PdfSharpCore.Pdf.IO.PdfPasswordProviderArgs : object {
    public string Password;
    public bool Abort;
}
public static class PdfSharpCore.Pdf.IO.PdfReader : object {
    public static int TestPdfFile(string path);
    public static int TestPdfFile(Stream stream);
    public static int TestPdfFile(Byte[] data);
    internal static int GetPdfFileVersion(Byte[] bytes);
    public static PdfDocument Open(string path, PdfDocumentOpenMode openmode);
    public static PdfDocument Open(string path, PdfDocumentOpenMode openmode, PdfReadAccuracy accuracy);
    public static PdfDocument Open(string path, PdfDocumentOpenMode openmode, PdfPasswordProvider provider);
    public static PdfDocument Open(string path, PdfDocumentOpenMode openmode, PdfPasswordProvider provider, PdfReadAccuracy accuracy);
    public static PdfDocument Open(string path, string password, PdfDocumentOpenMode openmode);
    public static PdfDocument Open(string path, string password, PdfDocumentOpenMode openmode, PdfReadAccuracy accuracy);
    public static PdfDocument Open(string path, string password, PdfDocumentOpenMode openmode, PdfPasswordProvider provider);
    public static PdfDocument Open(string path, string password, PdfDocumentOpenMode openmode, PdfPasswordProvider provider, PdfReadAccuracy accuracy);
    public static PdfDocument Open(string path);
    public static PdfDocument Open(string path, PdfReadAccuracy accuracy);
    public static PdfDocument Open(string path, string password);
    public static PdfDocument Open(string path, string password, PdfReadAccuracy accuracy);
    public static PdfDocument Open(Stream stream, PdfDocumentOpenMode openmode);
    public static PdfDocument Open(Stream stream, PdfDocumentOpenMode openmode, PdfReadAccuracy accuracy);
    public static PdfDocument Open(Stream stream, PdfDocumentOpenMode openmode, PdfPasswordProvider passwordProvider);
    public static PdfDocument Open(Stream stream, PdfDocumentOpenMode openmode, PdfPasswordProvider passwordProvider, PdfReadAccuracy accuracy);
    public static PdfDocument Open(Stream stream, string password, PdfDocumentOpenMode openmode);
    public static PdfDocument Open(Stream stream, string password, PdfDocumentOpenMode openmode, PdfReadAccuracy accuracy);
    public static PdfDocument Open(Stream stream, string password, PdfDocumentOpenMode openmode, PdfPasswordProvider passwordProvider);
    public static PdfDocument Open(Stream stream, string password, PdfDocumentOpenMode openmode, PdfPasswordProvider passwordProvider, PdfReadAccuracy accuracy);
    public static PdfDocument Open(Stream stream);
    public static PdfDocument Open(Stream stream, PdfReadAccuracy accuracy);
}
public class PdfSharpCore.Pdf.IO.PdfReaderException : PdfSharpException {
    public PdfReaderException(string message);
    public PdfReaderException(string message, Exception innerException);
}
internal class PdfSharpCore.Pdf.IO.PdfWriter : object {
    private PdfWriterLayout _layout;
    private PdfWriterOptions _options;
    private int _indent;
    private int _writeIndent;
    private CharCat _lastCat;
    private Stream _stream;
    private PdfStandardSecurityHandler _securityHandler;
    private List`1<StackItem> _stack;
    private int _commentPosition;
    public long Position { get; }
    public PdfWriterLayout Layout { get; public set; }
    public PdfWriterOptions Options { get; public set; }
    internal int Indent { get; internal set; }
    private string IndentBlanks { get; }
    internal Stream Stream { get; }
    internal PdfStandardSecurityHandler SecurityHandler { get; internal set; }
    public PdfWriter(Stream pdfStream, PdfStandardSecurityHandler securityHandler);
    public void Close(bool closeUnderlyingStream);
    public void Close();
    public long get_Position();
    public PdfWriterLayout get_Layout();
    public void set_Layout(PdfWriterLayout value);
    public PdfWriterOptions get_Options();
    public void set_Options(PdfWriterOptions value);
    public void Write(bool value);
    public void Write(PdfBoolean value);
    public void Write(int value);
    public void Write(long value);
    public void Write(UInt32 value);
    public void Write(PdfInteger value);
    public void Write(PdfLong value);
    public void Write(PdfUInteger value);
    public void Write(double value);
    public void Write(PdfReal value);
    public void Write(PdfString value);
    public void Write(PdfName value);
    public void Write(PdfLiteral value);
    public void Write(PdfRectangle rect);
    public void Write(PdfReference iref);
    public void WriteDocString(string text, bool unicode);
    public void WriteDocString(string text);
    public void WriteDocStringHex(string text);
    public void WriteBeginObject(PdfObject obj);
    public void WriteEndObject();
    public void WriteStream(PdfDictionary value, bool omitStream);
    public void WriteRaw(string rawString);
    public void WriteRaw(char ch);
    public void Write(Byte[] bytes);
    private void WriteObjectAddress(PdfObject value);
    public void WriteFileHeader(PdfDocument document);
    public void WriteEof(PdfDocument document, long startxref);
    internal int get_Indent();
    internal void set_Indent(int value);
    private void IncreaseIndent();
    private void DecreaseIndent();
    private string get_IndentBlanks();
    private void WriteIndent();
    private void WriteSeparator(CharCat cat, char ch);
    private void WriteSeparator(CharCat cat);
    public void NewLine();
    private CharCat GetCategory(char ch);
    internal Stream get_Stream();
    internal PdfStandardSecurityHandler get_SecurityHandler();
    internal void set_SecurityHandler(PdfStandardSecurityHandler value);
}
public enum PdfSharpCore.Pdf.IO.PdfWriterLayout : Enum {
    public int value__;
    public static PdfWriterLayout Compact;
    public static PdfWriterLayout Standard;
    public static PdfWriterLayout Indented;
    public static PdfWriterLayout Verbose;
}
[FlagsAttribute]
internal enum PdfSharpCore.Pdf.IO.PdfWriterOptions : Enum {
    public int value__;
    public static PdfWriterOptions Regular;
    public static PdfWriterOptions OmitStream;
    public static PdfWriterOptions OmitInflation;
}
[DefaultMemberAttribute("Item")]
internal class PdfSharpCore.Pdf.IO.ShiftStack : object {
    private int _sp;
    private List`1<PdfItem> _items;
    public int SP { get; }
    public PdfItem Item { get; }
    public PdfItem[] ToArray(int start, int length);
    public int get_SP();
    public PdfItem get_Item(int index);
    public PdfItem GetItem(int relativeIndex);
    public int GetInteger(int relativeIndex);
    public void Shift(PdfItem item);
    public void Reduce(int count);
    public void Reduce(PdfItem item, int count);
}
internal static class PdfSharpCore.Pdf.IO.StreamHelper : object {
    public static int WSize(Int32[] w);
    public static UInt32 ReadBytes(Byte[] bytes, int index, int byteCount);
}
public enum PdfSharpCore.Pdf.IO.Symbol : Enum {
    public int value__;
    public static Symbol None;
    public static Symbol Comment;
    public static Symbol Null;
    public static Symbol Integer;
    public static Symbol UInteger;
    public static Symbol Real;
    public static Symbol Boolean;
    public static Symbol String;
    public static Symbol HexString;
    public static Symbol UnicodeString;
    public static Symbol UnicodeHexString;
    public static Symbol Name;
    public static Symbol Keyword;
    public static Symbol BeginStream;
    public static Symbol EndStream;
    public static Symbol BeginArray;
    public static Symbol EndArray;
    public static Symbol BeginDictionary;
    public static Symbol EndDictionary;
    public static Symbol Obj;
    public static Symbol EndObj;
    public static Symbol R;
    public static Symbol XRef;
    public static Symbol Trailer;
    public static Symbol StartXRef;
    public static Symbol Eof;
    public static Symbol Long;
}
internal class PdfSharpCore.Pdf.KeyDescriptor : object {
    private string _version;
    private KeyType _keyType;
    private string _keyValue;
    private string _fixedValue;
    [DynamicallyAccessedMembersAttribute("7")]
private Type _objectType;
    public string Version { get; public set; }
    public KeyType KeyType { get; public set; }
    public string KeyValue { get; public set; }
    public string FixedValue { get; }
    [DynamicallyAccessedMembersAttribute("7")]
public Type ObjectType { get; public set; }
    public bool CanBeIndirect { get; }
    public KeyDescriptor(KeyInfoAttribute attribute);
    public string get_Version();
    public void set_Version(string value);
    public KeyType get_KeyType();
    public void set_KeyType(KeyType value);
    public string get_KeyValue();
    public void set_KeyValue(string value);
    public string get_FixedValue();
    public Type get_ObjectType();
    public void set_ObjectType(Type value);
    public bool get_CanBeIndirect();
    public Type GetValueType();
}
internal class PdfSharpCore.Pdf.KeyInfoAttribute : Attribute {
    private string _version;
    private KeyType _entryType;
    [DynamicallyAccessedMembersAttribute("7")]
private Type _objectType;
    private string _fixedValue;
    public string Version { get; public set; }
    public KeyType KeyType { get; public set; }
    [DynamicallyAccessedMembersAttribute("7")]
public Type ObjectType { get; public set; }
    public string FixedValue { get; public set; }
    public KeyInfoAttribute(KeyType keyType);
    public KeyInfoAttribute(string version, KeyType keyType);
    public KeyInfoAttribute(KeyType keyType, Type objectType);
    public KeyInfoAttribute(string version, KeyType keyType, Type objectType);
    public string get_Version();
    public void set_Version(string value);
    public KeyType get_KeyType();
    public void set_KeyType(KeyType value);
    public Type get_ObjectType();
    public void set_ObjectType(Type value);
    public string get_FixedValue();
    public void set_FixedValue(string value);
}
public class PdfSharpCore.Pdf.KeysBase : object {
    internal static DictionaryMeta CreateMeta(Type type);
}
[FlagsAttribute]
internal enum PdfSharpCore.Pdf.KeyType : Enum {
    public int value__;
    public static KeyType Name;
    public static KeyType String;
    public static KeyType Boolean;
    public static KeyType Integer;
    public static KeyType Real;
    public static KeyType Date;
    public static KeyType Rectangle;
    public static KeyType Array;
    public static KeyType Dictionary;
    public static KeyType Stream;
    public static KeyType NumberTree;
    public static KeyType Function;
    public static KeyType TextString;
    public static KeyType ByteString;
    public static KeyType NameOrArray;
    public static KeyType NameOrDictionary;
    public static KeyType ArrayOrDictionary;
    public static KeyType StreamOrArray;
    public static KeyType StreamOrName;
    public static KeyType ArrayOrNameOrString;
    public static KeyType FunctionOrName;
    public static KeyType Various;
    public static KeyType TypeMask;
    public static KeyType Optional;
    public static KeyType Required;
    public static KeyType Inheritable;
    public static KeyType MustBeIndirect;
    public static KeyType MustNotBeIndirect;
}
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharpCore.Pdf.PdfArray : PdfObject {
    private ArrayElements _elements;
    public ArrayElements Elements { get; }
    private string DebuggerDisplay { get; }
    public PdfArray(PdfDocument document);
    public PdfArray(PdfDocument document, PdfItem[] items);
    protected PdfArray(PdfArray array);
    public PdfArray Clone();
    protected virtual object Copy();
    public ArrayElements get_Elements();
    public virtual IEnumerator`1<PdfItem> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
    private string get_DebuggerDisplay();
}
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharpCore.Pdf.PdfBoolean : PdfItem {
    private bool _value;
    public static PdfBoolean True;
    public static PdfBoolean False;
    public bool Value { get; }
    public PdfBoolean(bool value);
    private static PdfBoolean();
    public bool get_Value();
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
}
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharpCore.Pdf.PdfBooleanObject : PdfObject {
    private bool _value;
    public bool Value { get; }
    public PdfBooleanObject(bool value);
    public PdfBooleanObject(PdfDocument document, bool value);
    public bool get_Value();
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
}
public enum PdfSharpCore.Pdf.PdfColorMode : Enum {
    public int value__;
    public static PdfColorMode Undefined;
    public static PdfColorMode Rgb;
    public static PdfColorMode Cmyk;
}
public class PdfSharpCore.Pdf.PdfCustomValue : PdfDictionary {
    public PdfCustomValueCompressionMode CompressionMode;
    public Byte[] Value { get; public set; }
    public PdfCustomValue(Byte[] bytes);
    internal PdfCustomValue(PdfDocument document);
    internal PdfCustomValue(PdfDictionary dict);
    public Byte[] get_Value();
    public void set_Value(Byte[] value);
}
public enum PdfSharpCore.Pdf.PdfCustomValueCompressionMode : Enum {
    public int value__;
    public static PdfCustomValueCompressionMode Default;
    public static PdfCustomValueCompressionMode Uncompressed;
    public static PdfCustomValueCompressionMode Compressed;
}
[DefaultMemberAttribute("Item")]
public class PdfSharpCore.Pdf.PdfCustomValues : PdfDictionary {
    unknown PdfCustomValueCompressionMode CompressionMode {public set; }
    public PdfCustomValue Item { get; public set; }
    internal PdfCustomValues(PdfDocument document);
    internal PdfCustomValues(PdfDictionary dict);
    public void set_CompressionMode(PdfCustomValueCompressionMode value);
    public bool Contains(string key);
    public PdfCustomValue get_Item(string key);
    public void set_Item(string key, PdfCustomValue value);
    public static void ClearAllCustomValues(PdfDocument document);
    internal static PdfCustomValues Get(DictionaryElements elem);
    internal static void Remove(DictionaryElements elem);
}
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharpCore.Pdf.PdfDate : PdfItem {
    private DateTime _value;
    public DateTime Value { get; }
    public PdfDate(string value);
    public PdfDate(DateTime value);
    public DateTime get_Value();
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
}
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharpCore.Pdf.PdfDictionary : PdfObject {
    internal DictionaryElements _elements;
    private PdfStream _stream;
    public DictionaryElements Elements { get; }
    public PdfStream Stream { get; public set; }
    internal DictionaryMeta Meta { get; }
    private string DebuggerDisplay { get; }
    public PdfDictionary(PdfDocument document);
    protected PdfDictionary(PdfDictionary dict);
    public PdfDictionary Clone();
    protected virtual object Copy();
    public DictionaryElements get_Elements();
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, PdfItem>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
    internal virtual void WriteDictionaryElement(PdfWriter writer, PdfName key);
    internal virtual void WriteDictionaryStream(PdfWriter writer);
    public PdfStream get_Stream();
    public void set_Stream(PdfStream value);
    public PdfStream CreateStream(Byte[] value);
    internal virtual DictionaryMeta get_Meta();
    private string get_DebuggerDisplay();
}
[DebuggerDisplayAttribute("(Name={Name})")]
public class PdfSharpCore.Pdf.PdfDocument : PdfObject {
    internal DocumentState _state;
    internal PdfDocumentOpenMode _openMode;
    private object _tag;
    private string _name;
    private static int _nameCount;
    private PdfDocumentOptions _options;
    private PdfDocumentSettings _settings;
    internal int _version;
    internal long _fileSize;
    internal string _fullPath;
    private Guid _guid;
    private DocumentHandle _handle;
    private PdfDocumentInformation _info;
    private PdfCustomValues _customValues;
    private PdfPages _pages;
    internal PdfSecuritySettings _securitySettings;
    private PdfFontTable _fontTable;
    private PdfImageTable _imageTable;
    private PdfFormXObjectTable _formTable;
    private PdfExtGStateTable _extGStateTable;
    private PdfCatalog _catalog;
    private PdfInternals _internals;
    internal PdfTrailer _trailer;
    internal PdfCrossReferenceTable _irefTable;
    internal Stream _outStream;
    internal Lexer _lexer;
    internal DateTime _creation;
    [ThreadStaticAttribute]
private static ThreadLocalStorage tls;
    public object Tag { get; public set; }
    private string Name { get; private set; }
    internal bool CanModify { get; }
    public PdfDocumentOptions Options { get; }
    public PdfDocumentSettings Settings { get; }
    internal bool EarlyWrite { get; }
    public int Version { get; public set; }
    public int PageCount { get; }
    public long FileSize { get; }
    public string FullPath { get; }
    public Guid Guid { get; }
    internal DocumentHandle Handle { get; }
    public bool IsImported { get; }
    public bool IsReadOnly { get; }
    public PdfDocumentInformation Info { get; }
    public PdfCustomValues CustomValues { get; public set; }
    public PdfPages Pages { get; }
    public PdfPageLayout PageLayout { get; public set; }
    public PdfPageMode PageMode { get; public set; }
    public PdfViewerPreferences ViewerPreferences { get; }
    public PdfOutlineCollection Outlines { get; }
    public PdfAcroForm AcroForm { get; }
    public string Language { get; public set; }
    public PdfSecuritySettings SecuritySettings { get; }
    internal PdfFontTable FontTable { get; }
    internal PdfImageTable ImageTable { get; }
    internal PdfFormXObjectTable FormTable { get; }
    internal PdfExtGStateTable ExtGStateTable { get; }
    internal PdfCatalog Catalog { get; }
    public PdfInternals Internals { get; }
    public PdfStandardSecurityHandler SecurityHandler { get; }
    internal static ThreadLocalStorage Tls { get; }
    public PdfDocument(string filename);
    public PdfDocument(Stream outputStream);
    internal PdfDocument(Lexer lexer);
    private void Initialize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public object get_Tag();
    public void set_Tag(object value);
    private string get_Name();
    private void set_Name(string value);
    private static string NewName();
    internal bool get_CanModify();
    public void Close();
    public void Save(string path);
    public void Save(Stream stream, bool closeStream);
    public void Save(Stream stream);
    private void DoSave(PdfWriter writer);
    internal virtual void PrepareForSave();
    public bool CanSave(String& message);
    internal bool HasVersion(string version);
    public PdfDocumentOptions get_Options();
    public PdfDocumentSettings get_Settings();
    internal bool get_EarlyWrite();
    public int get_Version();
    public void set_Version(int value);
    public int get_PageCount();
    public long get_FileSize();
    public string get_FullPath();
    public Guid get_Guid();
    internal DocumentHandle get_Handle();
    public bool get_IsImported();
    public bool get_IsReadOnly();
    internal Exception DocumentNotImported();
    public PdfDocumentInformation get_Info();
    public PdfCustomValues get_CustomValues();
    public void set_CustomValues(PdfCustomValues value);
    public PdfPages get_Pages();
    public PdfPageLayout get_PageLayout();
    public void set_PageLayout(PdfPageLayout value);
    public PdfPageMode get_PageMode();
    public void set_PageMode(PdfPageMode value);
    public PdfViewerPreferences get_ViewerPreferences();
    public PdfOutlineCollection get_Outlines();
    public PdfAcroForm get_AcroForm();
    public string get_Language();
    public void set_Language(string value);
    public PdfSecuritySettings get_SecuritySettings();
    internal PdfFontTable get_FontTable();
    internal PdfImageTable get_ImageTable();
    internal PdfFormXObjectTable get_FormTable();
    internal PdfExtGStateTable get_ExtGStateTable();
    internal PdfCatalog get_Catalog();
    public PdfInternals get_Internals();
    public PdfPage AddPage();
    public PdfPage AddPage(PdfPage page, AnnotationCopyingType annotationCopying);
    public PdfPage InsertPage(int index);
    public PdfPage InsertPage(int index, PdfPage page, AnnotationCopyingType annotationCopying);
    public void MakeAcroFormsReadOnly();
    public void ConsolidateImages();
    public PdfStandardSecurityHandler get_SecurityHandler();
    internal void OnExternalDocumentFinalized(DocumentHandle handle);
    internal static ThreadLocalStorage get_Tls();
}
public class PdfSharpCore.Pdf.PdfDocumentInformation : PdfDictionary {
    public string Title { get; public set; }
    public string Author { get; public set; }
    public string Subject { get; public set; }
    public string Keywords { get; public set; }
    public string Creator { get; public set; }
    public string Producer { get; }
    public DateTime CreationDate { get; public set; }
    public DateTime ModificationDate { get; public set; }
    internal DictionaryMeta Meta { get; }
    public PdfDocumentInformation(PdfDocument document);
    internal PdfDocumentInformation(PdfDictionary dict);
    public string get_Title();
    public void set_Title(string value);
    public string get_Author();
    public void set_Author(string value);
    public string get_Subject();
    public void set_Subject(string value);
    public string get_Keywords();
    public void set_Keywords(string value);
    public string get_Creator();
    public void set_Creator(string value);
    public string get_Producer();
    public DateTime get_CreationDate();
    public void set_CreationDate(DateTime value);
    public DateTime get_ModificationDate();
    public void set_ModificationDate(DateTime value);
    internal virtual DictionaryMeta get_Meta();
}
public class PdfSharpCore.Pdf.PdfDocumentOptions : object {
    private PdfColorMode _colorMode;
    private bool _compressContentStreams;
    private bool _noCompression;
    private PdfFlateEncodeMode _flateEncodeMode;
    private bool _enableCcittCompressionForBilevelImages;
    private PdfUseFlateDecoderForJpegImages _useFlateDecoderForJpegImages;
    public PdfColorMode ColorMode { get; public set; }
    public bool CompressContentStreams { get; public set; }
    public bool NoCompression { get; public set; }
    public PdfFlateEncodeMode FlateEncodeMode { get; public set; }
    public bool EnableCcittCompressionForBilevelImages { get; public set; }
    public PdfUseFlateDecoderForJpegImages UseFlateDecoderForJpegImages { get; public set; }
    internal PdfDocumentOptions(PdfDocument document);
    public PdfColorMode get_ColorMode();
    public void set_ColorMode(PdfColorMode value);
    public bool get_CompressContentStreams();
    public void set_CompressContentStreams(bool value);
    public bool get_NoCompression();
    public void set_NoCompression(bool value);
    public PdfFlateEncodeMode get_FlateEncodeMode();
    public void set_FlateEncodeMode(PdfFlateEncodeMode value);
    public bool get_EnableCcittCompressionForBilevelImages();
    public void set_EnableCcittCompressionForBilevelImages(bool value);
    public PdfUseFlateDecoderForJpegImages get_UseFlateDecoderForJpegImages();
    public void set_UseFlateDecoderForJpegImages(PdfUseFlateDecoderForJpegImages value);
}
public class PdfSharpCore.Pdf.PdfDocumentSettings : object {
    private TrimMargins _trimMargins;
    public TrimMargins TrimMargins { get; public set; }
    internal PdfDocumentSettings(PdfDocument document);
    public TrimMargins get_TrimMargins();
    public void set_TrimMargins(TrimMargins value);
}
public enum PdfSharpCore.Pdf.PdfFlateEncodeMode : Enum {
    public int value__;
    public static PdfFlateEncodeMode Default;
    public static PdfFlateEncodeMode BestSpeed;
    public static PdfFlateEncodeMode BestCompression;
}
public enum PdfSharpCore.Pdf.PdfFontEncoding : Enum {
    public int value__;
    public static PdfFontEncoding WinAnsi;
    public static PdfFontEncoding Unicode;
}
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharpCore.Pdf.PdfInteger : PdfNumber {
    private int _value;
    public int Value { get; }
    public PdfInteger(int value);
    public int get_Value();
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string _value, IFormatProvider provider);
}
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharpCore.Pdf.PdfIntegerObject : PdfNumberObject {
    private int _value;
    public int Value { get; }
    public PdfIntegerObject(int value);
    public PdfIntegerObject(PdfDocument document, int value);
    public int get_Value();
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
}
public abstract class PdfSharpCore.Pdf.PdfItem : object {
    private sealed virtual override object System.ICloneable.Clone();
    public PdfItem Clone();
    protected virtual object Copy();
    internal abstract virtual void WriteObject(PdfWriter writer);
}
public class PdfSharpCore.Pdf.PdfLiteral : PdfItem {
    private string _value;
    public string Value { get; }
    public PdfLiteral(string value);
    public PdfLiteral(string format, Object[] args);
    public static PdfLiteral FromMatrix(XMatrix matrix);
    public string get_Value();
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
}
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharpCore.Pdf.PdfLong : PdfNumber {
    private long _value;
    public long Value { get; }
    public PdfLong(long value);
    public long get_Value();
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
    public sealed virtual ulong ToUInt64(IFormatProvider provider);
    public sealed virtual sbyte ToSByte(IFormatProvider provider);
    public sealed virtual double ToDouble(IFormatProvider provider);
    public sealed virtual DateTime ToDateTime(IFormatProvider provider);
    public sealed virtual float ToSingle(IFormatProvider provider);
    public sealed virtual bool ToBoolean(IFormatProvider provider);
    public sealed virtual int ToInt32(IFormatProvider provider);
    public sealed virtual ushort ToUInt16(IFormatProvider provider);
    public sealed virtual short ToInt16(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    public sealed virtual byte ToByte(IFormatProvider provider);
    public sealed virtual char ToChar(IFormatProvider provider);
    public sealed virtual long ToInt64(IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    public sealed virtual decimal ToDecimal(IFormatProvider provider);
    public sealed virtual object ToType(Type conversionType, IFormatProvider provider);
    public sealed virtual UInt32 ToUInt32(IFormatProvider provider);
}
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharpCore.Pdf.PdfLongObject : PdfNumberObject {
    private long _value;
    public long Value { get; }
    public PdfLongObject(long value);
    public PdfLongObject(PdfDocument document, long value);
    public long get_Value();
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
}
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharpCore.Pdf.PdfName : PdfItem {
    private string _value;
    public static PdfName Empty;
    public string Value { get; }
    public static PdfXNameComparer Comparer { get; }
    public PdfName(string value);
    private static PdfName();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public string get_Value();
    public virtual string ToString();
    public static bool op_Equality(PdfName name, string str);
    public static bool op_Inequality(PdfName name, string str);
    internal virtual void WriteObject(PdfWriter writer);
    public static PdfXNameComparer get_Comparer();
}
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharpCore.Pdf.PdfNameObject : PdfObject {
    private string _value;
    public string Value { get; public set; }
    public PdfNameObject(PdfDocument document, string value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public string get_Value();
    public void set_Value(string value);
    public virtual string ToString();
    public static bool op_Equality(PdfNameObject name, string str);
    public static bool op_Inequality(PdfNameObject name, string str);
    internal virtual void WriteObject(PdfWriter writer);
}
public class PdfSharpCore.Pdf.PdfNull : PdfItem {
    public static PdfNull Value;
    private static PdfNull();
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
}
public class PdfSharpCore.Pdf.PdfNullObject : PdfObject {
    public PdfNullObject(PdfDocument document);
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
}
public abstract class PdfSharpCore.Pdf.PdfNumber : PdfItem {
}
public abstract class PdfSharpCore.Pdf.PdfNumberObject : PdfObject {
    protected PdfNumberObject(PdfDocument document);
}
public abstract class PdfSharpCore.Pdf.PdfObject : PdfItem {
    internal PdfDocument _document;
    private PdfObjectInternals _internals;
    private PdfReference _iref;
    public PdfDocument Owner { get; }
    unknown PdfDocument Document {internal set; }
    public bool IsIndirect { get; }
    public PdfObjectInternals Internals { get; }
    internal PdfObjectID ObjectID { get; }
    internal int ObjectNumber { get; }
    internal int GenerationNumber { get; }
    public PdfReference Reference { get; internal set; }
    protected PdfObject(PdfDocument document);
    protected PdfObject(PdfObject obj);
    public PdfObject Clone();
    protected virtual object Copy();
    internal void SetObjectID(int objectNumber, int generationNumber);
    public virtual PdfDocument get_Owner();
    internal virtual void set_Document(PdfDocument value);
    public bool get_IsIndirect();
    public PdfObjectInternals get_Internals();
    internal virtual void PrepareForSave();
    internal virtual void WriteObject(PdfWriter writer);
    internal PdfObjectID get_ObjectID();
    internal int get_ObjectNumber();
    internal int get_GenerationNumber();
    internal static PdfObject DeepCopyClosure(PdfDocument owner, PdfObject externalObject);
    internal static PdfObject ImportClosure(PdfImportedObjectTable importedObjectTable, PdfDocument owner, PdfObject externalObject);
    private static void FixUpObject(PdfImportedObjectTable iot, PdfDocument owner, PdfObject value);
    [ConditionalAttribute("DEBUG")]
private static void DebugCheckNonObjects(PdfItem item);
    public PdfReference get_Reference();
    internal void set_Reference(PdfReference value);
}
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharpCore.Pdf.PdfObjectID : ValueType {
    private int _objectNumber;
    private ushort _generationNumber;
    public int ObjectNumber { get; }
    public int GenerationNumber { get; }
    public bool IsEmpty { get; }
    public static PdfObjectID Empty { get; }
    internal string DebuggerDisplay { get; }
    public PdfObjectID(int objectNumber);
    public PdfObjectID(int objectNumber, int generationNumber);
    public int get_ObjectNumber();
    public int get_GenerationNumber();
    public bool get_IsEmpty();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(PdfObjectID left, PdfObjectID right);
    public static bool op_Inequality(PdfObjectID left, PdfObjectID right);
    public virtual string ToString();
    public static PdfObjectID get_Empty();
    public sealed virtual int CompareTo(object obj);
    internal string get_DebuggerDisplay();
}
public class PdfSharpCore.Pdf.PdfOutline : PdfDictionary {
    private int _count;
    internal int OpenCount;
    private PdfOutline _parent;
    private PdfPage _destinationPage;
    private double _left;
    private double _top;
    private double _right;
    private double _bottom;
    private double _zoom;
    private bool _opened;
    private PdfPageDestinationType _pageDestinationType;
    private XColor _textColor;
    private PdfOutlineCollection _outlines;
    internal int Count { get; internal set; }
    public PdfOutline Parent { get; internal set; }
    public string Title { get; public set; }
    public PdfPage DestinationPage { get; public set; }
    public double Left { get; public set; }
    public double Top { get; public set; }
    public double Right { get; public set; }
    public double Bottom { get; public set; }
    public double Zoom { get; public set; }
    public bool Opened { get; public set; }
    public PdfOutlineStyle Style { get; public set; }
    public PdfPageDestinationType PageDestinationType { get; public set; }
    public XColor TextColor { get; public set; }
    public bool HasChildren { get; }
    public PdfOutlineCollection Outlines { get; }
    internal DictionaryMeta Meta { get; }
    internal PdfOutline(PdfDocument document);
    public PdfOutline(PdfDictionary dict);
    public PdfOutline(string title, PdfPage destinationPage, bool opened, PdfOutlineStyle style, XColor textColor);
    public PdfOutline(string title, PdfPage destinationPage, bool opened, PdfOutlineStyle style);
    public PdfOutline(string title, PdfPage destinationPage, bool opened);
    public PdfOutline(string title, PdfPage destinationPage);
    internal int get_Count();
    internal void set_Count(int value);
    internal int CountOpen();
    public PdfOutline get_Parent();
    internal void set_Parent(PdfOutline value);
    public string get_Title();
    public void set_Title(string value);
    public PdfPage get_DestinationPage();
    public void set_DestinationPage(PdfPage value);
    public double get_Left();
    public void set_Left(double value);
    public double get_Top();
    public void set_Top(double value);
    public double get_Right();
    public void set_Right(double value);
    public double get_Bottom();
    public void set_Bottom(double value);
    public double get_Zoom();
    public void set_Zoom(double value);
    public bool get_Opened();
    public void set_Opened(bool value);
    public PdfOutlineStyle get_Style();
    public void set_Style(PdfOutlineStyle value);
    public PdfPageDestinationType get_PageDestinationType();
    public void set_PageDestinationType(PdfPageDestinationType value);
    public XColor get_TextColor();
    public void set_TextColor(XColor value);
    public bool get_HasChildren();
    public PdfOutlineCollection get_Outlines();
    private void Initialize();
    private void SplitDestinationPage(PdfArray destination);
    private void InitializeChildren();
    internal virtual void PrepareForSave();
    private PdfArray CreateDestArray();
    private string Fd(double value);
    internal virtual void WriteObject(PdfWriter writer);
    internal virtual DictionaryMeta get_Meta();
}
[DefaultMemberAttribute("Item")]
public class PdfSharpCore.Pdf.PdfOutlineCollection : PdfObject {
    private PdfOutline _parent;
    private List`1<PdfOutline> _outlines;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public PdfOutline Item { get; public set; }
    internal PdfOutlineCollection(PdfDocument document, PdfOutline parent);
    public sealed virtual bool Remove(PdfOutline item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(PdfOutline outline);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(PdfOutline item);
    public sealed virtual void CopyTo(PdfOutline[] array, int arrayIndex);
    public PdfOutline Add(string title, PdfPage destinationPage, bool opened, PdfOutlineStyle style, XColor textColor);
    public PdfOutline Add(string title, PdfPage destinationPage, bool opened, PdfOutlineStyle style);
    public PdfOutline Add(string title, PdfPage destinationPage, bool opened);
    public PdfOutline Add(string title, PdfPage destinationPage);
    public sealed virtual int IndexOf(PdfOutline item);
    public sealed virtual void Insert(int index, PdfOutline outline);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual PdfOutline get_Item(int index);
    public sealed virtual void set_Item(int index, PdfOutline value);
    public sealed virtual IEnumerator`1<PdfOutline> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal int CountOpen();
    private void AddToOutlinesTree(PdfOutline outline);
    private void RemoveFromOutlinesTree(PdfOutline outline);
}
[FlagsAttribute]
public enum PdfSharpCore.Pdf.PdfOutlineStyle : Enum {
    public int value__;
    public static PdfOutlineStyle Regular;
    public static PdfOutlineStyle Italic;
    public static PdfOutlineStyle Bold;
    public static PdfOutlineStyle BoldItalic;
}
public class PdfSharpCore.Pdf.PdfPage : PdfDictionary {
    private object _tag;
    private bool _closed;
    private PageOrientation _orientation;
    private PageSize _pageSize;
    private TrimMargins _trimMargins;
    internal PdfContent RenderContent;
    private PdfContents _contents;
    private PdfAnnotations _annotations;
    private PdfCustomValues _customValues;
    private PdfResources _resources;
    internal bool TransparencyUsed;
    public object Tag { get; public set; }
    internal bool IsClosed { get; }
    unknown PdfDocument Document {internal set; }
    public PageOrientation Orientation { get; public set; }
    public PageSize Size { get; public set; }
    public TrimMargins TrimMargins { get; public set; }
    public PdfRectangle MediaBox { get; public set; }
    public PdfRectangle CropBox { get; public set; }
    public PdfRectangle BleedBox { get; public set; }
    public PdfRectangle ArtBox { get; public set; }
    public PdfRectangle TrimBox { get; public set; }
    public XUnit Height { get; public set; }
    public XUnit Width { get; public set; }
    public int Rotate { get; public set; }
    public PdfContents Contents { get; }
    public bool HasAnnotations { get; }
    public PdfAnnotations Annotations { get; }
    public PdfCustomValues CustomValues { get; public set; }
    public PdfResources Resources { get; }
    private PdfResources PdfSharpCore.Pdf.Advanced.IContentStream.Resources { get; }
    internal DictionaryMeta Meta { get; }
    public PdfPage(PdfDocument document);
    internal PdfPage(PdfDictionary dict);
    private void Initialize();
    public object get_Tag();
    public void set_Tag(object value);
    public void Close();
    internal bool get_IsClosed();
    internal virtual void set_Document(PdfDocument value);
    public PageOrientation get_Orientation();
    public void set_Orientation(PageOrientation value);
    public PageSize get_Size();
    public void set_Size(PageSize value);
    public TrimMargins get_TrimMargins();
    public void set_TrimMargins(TrimMargins value);
    public PdfRectangle get_MediaBox();
    public void set_MediaBox(PdfRectangle value);
    public PdfRectangle get_CropBox();
    public void set_CropBox(PdfRectangle value);
    public PdfRectangle get_BleedBox();
    public void set_BleedBox(PdfRectangle value);
    public PdfRectangle get_ArtBox();
    public void set_ArtBox(PdfRectangle value);
    public PdfRectangle get_TrimBox();
    public void set_TrimBox(PdfRectangle value);
    public XUnit get_Height();
    public void set_Height(XUnit value);
    public XUnit get_Width();
    public void set_Width(XUnit value);
    public int get_Rotate();
    public void set_Rotate(int value);
    public PdfContents get_Contents();
    public bool get_HasAnnotations();
    public PdfAnnotations get_Annotations();
    public PdfLinkAnnotation AddDocumentLink(PdfRectangle rect, int destinationPage);
    public PdfLinkAnnotation AddWebLink(PdfRectangle rect, string url);
    public PdfLinkAnnotation AddFileLink(PdfRectangle rect, string fileName);
    public PdfCustomValues get_CustomValues();
    public void set_CustomValues(PdfCustomValues value);
    public PdfResources get_Resources();
    private sealed virtual override PdfResources PdfSharpCore.Pdf.Advanced.IContentStream.get_Resources();
    internal string GetFontName(XFont font, PdfFont& pdfFont);
    private sealed virtual override string PdfSharpCore.Pdf.Advanced.IContentStream.GetFontName(XFont font, PdfFont& pdfFont);
    internal string TryGetFontName(string idName, PdfFont& pdfFont);
    internal string GetFontName(string idName, Byte[] fontData, PdfFont& pdfFont);
    private sealed virtual override string PdfSharpCore.Pdf.Advanced.IContentStream.GetFontName(string idName, Byte[] fontData, PdfFont& pdfFont);
    internal string GetImageName(XImage image);
    private sealed virtual override string PdfSharpCore.Pdf.Advanced.IContentStream.GetImageName(XImage image);
    internal string GetFormName(XForm form);
    private sealed virtual override string PdfSharpCore.Pdf.Advanced.IContentStream.GetFormName(XForm form);
    internal virtual void WriteObject(PdfWriter writer);
    internal static void InheritValues(PdfDictionary page, InheritedValues values);
    internal static void InheritValues(PdfDictionary page, InheritedValues& values);
    internal virtual void PrepareForSave();
    internal virtual DictionaryMeta get_Meta();
}
public enum PdfSharpCore.Pdf.PdfPageDestinationType : Enum {
    public int value__;
    public static PdfPageDestinationType Xyz;
    public static PdfPageDestinationType Fit;
    public static PdfPageDestinationType FitH;
    public static PdfPageDestinationType FitV;
    public static PdfPageDestinationType FitR;
    public static PdfPageDestinationType FitB;
    public static PdfPageDestinationType FitBH;
    public static PdfPageDestinationType FitBV;
}
public enum PdfSharpCore.Pdf.PdfPageLayout : Enum {
    public int value__;
    public static PdfPageLayout SinglePage;
    public static PdfPageLayout OneColumn;
    public static PdfPageLayout TwoColumnLeft;
    public static PdfPageLayout TwoColumnRight;
    public static PdfPageLayout TwoPageLeft;
    public static PdfPageLayout TwoPageRight;
}
public enum PdfSharpCore.Pdf.PdfPageMode : Enum {
    public int value__;
    public static PdfPageMode UseNone;
    public static PdfPageMode UseOutlines;
    public static PdfPageMode UseThumbs;
    public static PdfPageMode FullScreen;
    public static PdfPageMode UseOC;
    public static PdfPageMode UseAttachments;
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("(PageCount={Count})")]
public class PdfSharpCore.Pdf.PdfPages : PdfDictionary {
    private PdfArray _pagesArray;
    public int Count { get; }
    public PdfPage Item { get; }
    public PdfArray PagesArray { get; }
    internal DictionaryMeta Meta { get; }
    internal PdfPages(PdfDocument document);
    internal PdfPages(PdfDictionary dictionary);
    public int get_Count();
    public PdfPage get_Item(int index);
    internal PdfPage FindPage(PdfObjectID id);
    public PdfPage Add();
    public PdfPage Add(PdfPage page, AnnotationCopyingType annotationCopying);
    public PdfPage Insert(int index);
    public PdfPage Insert(int index, PdfPage page, AnnotationCopyingType annotationCopying);
    public void InsertRange(int index, PdfDocument document, int startIndex, int pageCount, AnnotationCopyingType annotationCopying);
    public void InsertRange(int index, PdfDocument document, AnnotationCopyingType annotationCopying);
    public void InsertRange(int index, PdfDocument document, int startIndex, AnnotationCopyingType annotationCopying);
    public void Remove(PdfPage page);
    public void RemoveAt(int index);
    public void MovePage(int oldIndex, int newIndex);
    private PdfPage ImportExternalPage(PdfPage importPage, AnnotationCopyingType annotationCopying);
    private void CloneElement(PdfPage page, PdfPage importPage, string key, bool deepcopy);
    private static PdfReference RemapReference(PdfPage[] newPages, PdfPage[] impPages, PdfReference iref);
    public PdfArray get_PagesArray();
    internal void FlattenPageTree();
    private PdfDictionary[] GetKids(PdfReference iref, InheritedValues values, PdfDictionary parent);
    internal virtual void PrepareForSave();
    public sealed virtual IEnumerator`1<PdfPage> GetEnumerator();
    internal virtual DictionaryMeta get_Meta();
}
public enum PdfSharpCore.Pdf.PdfReadingDirection : Enum {
    public int value__;
    public static PdfReadingDirection LeftToRight;
    public static PdfReadingDirection RightToLeft;
}
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharpCore.Pdf.PdfReal : PdfNumber {
    private double _value;
    public double Value { get; }
    public PdfReal(double value);
    public double get_Value();
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
}
public class PdfSharpCore.Pdf.PdfRealObject : PdfNumberObject {
    private double _value;
    public double Value { get; public set; }
    public PdfRealObject(double value);
    public PdfRealObject(PdfDocument document, double value);
    public double get_Value();
    public void set_Value(double value);
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
}
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class PdfSharpCore.Pdf.PdfRectangle : PdfItem {
    private double _x1;
    private double _y1;
    private double _x2;
    private double _y2;
    public static PdfRectangle Empty;
    public bool IsEmpty { get; }
    public double X1 { get; }
    public double Y1 { get; }
    public double X2 { get; }
    public double Y2 { get; }
    public double Width { get; }
    public double Height { get; }
    public XPoint Location { get; }
    public XSize Size { get; }
    private string DebuggerDisplay { get; }
    internal PdfRectangle(double x1, double y1, double x2, double y2);
    public PdfRectangle(XPoint pt1, XPoint pt2);
    public PdfRectangle(XPoint pt, XSize size);
    public PdfRectangle(XRect rect);
    internal PdfRectangle(PdfItem item);
    private static PdfRectangle();
    public PdfRectangle Clone();
    protected virtual object Copy();
    public bool get_IsEmpty();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(PdfRectangle left, PdfRectangle right);
    public static bool op_Inequality(PdfRectangle left, PdfRectangle right);
    public double get_X1();
    public double get_Y1();
    public double get_X2();
    public double get_Y2();
    public double get_Width();
    public double get_Height();
    public XPoint get_Location();
    public XSize get_Size();
    public bool Contains(XPoint pt);
    public bool Contains(double x, double y);
    public bool Contains(XRect rect);
    public bool Contains(PdfRectangle rect);
    public XRect ToXRect();
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
    private string get_DebuggerDisplay();
}
[DefaultMemberAttribute("Item")]
internal class PdfSharpCore.Pdf.PdfReferenceTable_old : object {
    private PdfDocument _document;
    public Dictionary`2<PdfObjectID, PdfReference> ObjectTable;
    private bool _isUnderConstruction;
    internal int _maxObjectNumber;
    private static int _nestingLevel;
    private Dictionary`2<PdfItem, object> _overflow;
    private PdfDictionary _deadObject;
    internal bool IsUnderConstruction { get; internal set; }
    public PdfReference Item { get; }
    internal PdfObjectID[] AllObjectIDs { get; }
    internal PdfReference[] AllReferences { get; }
    public PdfReference DeadObject { get; }
    public PdfReferenceTable_old(PdfDocument document);
    internal bool get_IsUnderConstruction();
    internal void set_IsUnderConstruction(bool value);
    public void Add(PdfReference iref);
    public void Add(PdfObject value);
    public void Remove(PdfReference iref);
    public PdfReference get_Item(PdfObjectID objectID);
    public bool Contains(PdfObjectID objectID);
    public int GetNewObjectNumber();
    internal void WriteObject(PdfWriter writer);
    internal PdfObjectID[] get_AllObjectIDs();
    internal PdfReference[] get_AllReferences();
    internal void HandleOrphanedReferences();
    internal int Compact();
    internal void Renumber();
    [ConditionalAttribute("DEBUG_")]
public void CheckConsistence();
    public PdfReference[] TransitiveClosure(PdfObject pdfObject);
    public PdfReference[] TransitiveClosure(PdfObject pdfObject, int depth);
    private void TransitiveClosureImplementation(Dictionary`2<PdfItem, object> objects, PdfObject pdfObject);
    public PdfReference get_DeadObject();
}
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharpCore.Pdf.PdfString : PdfItem {
    private PdfStringFlags _flags;
    private string _value;
    private static Char[] Encode;
    public int Length { get; }
    public PdfStringEncoding Encoding { get; }
    public bool HexLiteral { get; }
    internal PdfStringFlags Flags { get; }
    public string Value { get; }
    internal Byte[] EncryptionValue { get; internal set; }
    public PdfString(string value);
    public PdfString(string value, PdfStringEncoding encoding);
    internal PdfString(string value, PdfStringFlags flags);
    private static PdfString();
    public int get_Length();
    public PdfStringEncoding get_Encoding();
    public bool get_HexLiteral();
    internal PdfStringFlags get_Flags();
    public string get_Value();
    internal Byte[] get_EncryptionValue();
    internal void set_EncryptionValue(Byte[] value);
    private Byte[] GetBytesFromEncoding();
    public virtual string ToString();
    public string ToStringFromPdfDocEncoded();
    private static void CheckRawEncoding(string s);
    internal virtual void WriteObject(PdfWriter writer);
}
[FlagsAttribute]
public enum PdfSharpCore.Pdf.PdfStringEncoding : Enum {
    public int value__;
    public static PdfStringEncoding RawEncoding;
    public static PdfStringEncoding StandardEncoding;
    public static PdfStringEncoding PDFDocEncoding;
    public static PdfStringEncoding WinAnsiEncoding;
    public static PdfStringEncoding MacRomanEncoding;
    public static PdfStringEncoding MacExpertEncoding;
    public static PdfStringEncoding Unicode;
}
[FlagsAttribute]
internal enum PdfSharpCore.Pdf.PdfStringFlags : Enum {
    public int value__;
    public static PdfStringFlags RawEncoding;
    public static PdfStringFlags StandardEncoding;
    public static PdfStringFlags PDFDocEncoding;
    public static PdfStringFlags WinAnsiEncoding;
    public static PdfStringFlags MacRomanEncoding;
    public static PdfStringFlags MacExpertEncoding;
    public static PdfStringFlags Unicode;
    public static PdfStringFlags EncodingMask;
    public static PdfStringFlags HexLiteral;
}
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharpCore.Pdf.PdfStringObject : PdfObject {
    private PdfStringFlags _flags;
    private string _value;
    public int Length { get; }
    public PdfStringEncoding Encoding { get; public set; }
    public bool HexLiteral { get; public set; }
    public string Value { get; public set; }
    internal Byte[] EncryptionValue { get; internal set; }
    public PdfStringObject(PdfDocument document, string value);
    public PdfStringObject(string value, PdfStringEncoding encoding);
    internal PdfStringObject(string value, PdfStringFlags flags);
    public int get_Length();
    public PdfStringEncoding get_Encoding();
    public void set_Encoding(PdfStringEncoding value);
    public bool get_HexLiteral();
    public void set_HexLiteral(bool value);
    public string get_Value();
    public void set_Value(string value);
    internal Byte[] get_EncryptionValue();
    internal void set_EncryptionValue(Byte[] value);
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
}
public enum PdfSharpCore.Pdf.PdfTextStringEncoding : Enum {
    public int value__;
    public static PdfTextStringEncoding PDFDocEncoding;
    public static PdfTextStringEncoding Unicode;
}
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharpCore.Pdf.PdfUInteger : PdfNumber {
    private UInt32 _value;
    public UInt32 Value { get; }
    public PdfUInteger(UInt32 value);
    public UInt32 get_Value();
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
    public sealed virtual ulong ToUInt64(IFormatProvider provider);
    public sealed virtual sbyte ToSByte(IFormatProvider provider);
    public sealed virtual double ToDouble(IFormatProvider provider);
    public sealed virtual DateTime ToDateTime(IFormatProvider provider);
    public sealed virtual float ToSingle(IFormatProvider provider);
    public sealed virtual bool ToBoolean(IFormatProvider provider);
    public sealed virtual int ToInt32(IFormatProvider provider);
    public sealed virtual ushort ToUInt16(IFormatProvider provider);
    public sealed virtual short ToInt16(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    public sealed virtual byte ToByte(IFormatProvider provider);
    public sealed virtual char ToChar(IFormatProvider provider);
    public sealed virtual long ToInt64(IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    public sealed virtual decimal ToDecimal(IFormatProvider provider);
    public sealed virtual object ToType(Type conversionType, IFormatProvider provider);
    public sealed virtual UInt32 ToUInt32(IFormatProvider provider);
}
[DebuggerDisplayAttribute("({Value})")]
public class PdfSharpCore.Pdf.PdfUIntegerObject : PdfNumberObject {
    private UInt32 _value;
    public UInt32 Value { get; }
    public PdfUIntegerObject(UInt32 value);
    public PdfUIntegerObject(PdfDocument document, UInt32 value);
    public UInt32 get_Value();
    public virtual string ToString();
    internal virtual void WriteObject(PdfWriter writer);
}
public enum PdfSharpCore.Pdf.PdfUseFlateDecoderForJpegImages : Enum {
    public int value__;
    public static PdfUseFlateDecoderForJpegImages Automatic;
    public static PdfUseFlateDecoderForJpegImages Never;
    public static PdfUseFlateDecoderForJpegImages Always;
}
public class PdfSharpCore.Pdf.PdfViewerPreferences : PdfDictionary {
    public bool HideToolbar { get; public set; }
    public bool HideMenubar { get; public set; }
    public bool HideWindowUI { get; public set; }
    public bool FitWindow { get; public set; }
    public bool CenterWindow { get; public set; }
    public bool DisplayDocTitle { get; public set; }
    public Nullable`1<PdfReadingDirection> Direction { get; public set; }
    internal DictionaryMeta Meta { get; }
    internal PdfViewerPreferences(PdfDocument document);
    private PdfViewerPreferences(PdfDictionary dict);
    public bool get_HideToolbar();
    public void set_HideToolbar(bool value);
    public bool get_HideMenubar();
    public void set_HideMenubar(bool value);
    public bool get_HideWindowUI();
    public void set_HideWindowUI(bool value);
    public bool get_FitWindow();
    public void set_FitWindow(bool value);
    public bool get_CenterWindow();
    public void set_CenterWindow(bool value);
    public bool get_DisplayDocTitle();
    public void set_DisplayDocTitle(bool value);
    public Nullable`1<PdfReadingDirection> get_Direction();
    public void set_Direction(Nullable`1<PdfReadingDirection> value);
    internal virtual DictionaryMeta get_Meta();
}
internal class PdfSharpCore.Pdf.Security.AESEncryptor : RC4Encryptor {
    public virtual void InitEncryptionKey(string password);
    protected void InitVersion5(string password);
    private void CreateEncryptionKeyR5(Byte[] encryptedValue, Byte[] password, Byte[] salt, Byte[] uservalue);
    private void InitVersion6(string password);
    private static void ValidateVersion6(string password, Byte[] salt, Byte[] ownerKey, Byte[] hash);
    private static bool PasswordMatchR5(Byte[] key, Byte[] comparand);
    public virtual void CreateHashKey(PdfObjectID id);
    public virtual Byte[] Encrypt(Byte[] bytes);
}
internal abstract class PdfSharpCore.Pdf.Security.EncryptorBase : object {
    protected MD5 md5;
    protected Byte[] ownerKey;
    protected Byte[] userKey;
    protected Byte[] key;
    protected Byte[] encryptionKey;
    protected Byte[] ownerValue;
    protected Byte[] userValue;
    protected Byte[] computedOwnerValue;
    protected Byte[] computedUserValue;
    protected Byte[] documentId;
    protected Byte[] oeValue;
    protected Byte[] ueValue;
    protected Byte[] permsValue;
    protected int pValue;
    protected int rValue;
    protected int vValue;
    protected bool encryptMetadata;
    protected PdfDictionary cf;
    protected string stmF;
    protected string strF;
    protected int keyLength;
    protected static Byte[] passwordPadding;
    protected int keySize;
    protected PdfDocument doc;
    protected PdfDictionary encryptionDict;
    [CompilerGeneratedAttribute]
private bool <PasswordValid>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HaveOwnerPermission>k__BackingField;
    public bool PasswordValid { get; protected set; }
    public bool HaveOwnerPermission { get; protected set; }
    private static EncryptorBase();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PasswordValid();
    [CompilerGeneratedAttribute]
protected void set_PasswordValid(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HaveOwnerPermission();
    [CompilerGeneratedAttribute]
protected void set_HaveOwnerPermission(bool value);
    public sealed virtual void Initialize(PdfDocument document, PdfDictionary encryptionDictionary);
    public sealed virtual void SetEncryptionKey(Byte[] encKey);
    protected static Byte[] PadPassword(string password);
    protected static bool CompareArrays(Byte[] left, Byte[] right, int length);
}
internal class PdfSharpCore.Pdf.Security.EncryptorFactory : object {
    public static void Create(PdfDocument doc, PdfDictionary dict, IEncryptor& stringEncryptor, IEncryptor& streamEncryptor);
}
internal interface PdfSharpCore.Pdf.Security.IEncryptor {
    public bool PasswordValid { get; }
    public bool HaveOwnerPermission { get; }
    public abstract virtual bool get_PasswordValid();
    public abstract virtual bool get_HaveOwnerPermission();
    public abstract virtual void Initialize(PdfDocument document, PdfDictionary encryptionDict);
    public abstract virtual void InitEncryptionKey(string password);
    public abstract virtual bool ValidatePassword(string password);
    public abstract virtual void SetEncryptionKey(Byte[] key);
    public abstract virtual void CreateHashKey(PdfObjectID objectId);
    public abstract virtual Byte[] Encrypt(Byte[] bytes);
}
public enum PdfSharpCore.Pdf.Security.PdfDocumentSecurityLevel : Enum {
    public int value__;
    public static PdfDocumentSecurityLevel None;
    public static PdfDocumentSecurityLevel Encrypted40Bit;
    public static PdfDocumentSecurityLevel Encrypted128Bit;
}
public abstract class PdfSharpCore.Pdf.Security.PdfSecurityHandler : PdfDictionary {
    internal PdfSecurityHandler(PdfDocument document);
    internal PdfSecurityHandler(PdfDictionary dict);
}
public class PdfSharpCore.Pdf.Security.PdfSecuritySettings : object {
    private PdfDocument _document;
    internal bool _hasOwnerPermissions;
    private PdfDocumentSecurityLevel _documentSecurityLevel;
    public bool HasOwnerPermissions { get; }
    public PdfDocumentSecurityLevel DocumentSecurityLevel { get; public set; }
    unknown string UserPassword {public set; }
    unknown string OwnerPassword {public set; }
    public bool PermitPrint { get; public set; }
    public bool PermitModifyDocument { get; public set; }
    public bool PermitExtractContent { get; public set; }
    public bool PermitAnnotations { get; public set; }
    public bool PermitFormsFill { get; public set; }
    public bool PermitAccessibilityExtractContent { get; public set; }
    public bool PermitAssembleDocument { get; public set; }
    public bool PermitFullQualityPrint { get; public set; }
    internal PdfStandardSecurityHandler SecurityHandler { get; }
    internal PdfSecuritySettings(PdfDocument document);
    public bool get_HasOwnerPermissions();
    public PdfDocumentSecurityLevel get_DocumentSecurityLevel();
    public void set_DocumentSecurityLevel(PdfDocumentSecurityLevel value);
    public void set_UserPassword(string value);
    public void set_OwnerPassword(string value);
    internal bool CanSave(String& message);
    public bool get_PermitPrint();
    public void set_PermitPrint(bool value);
    public bool get_PermitModifyDocument();
    public void set_PermitModifyDocument(bool value);
    public bool get_PermitExtractContent();
    public void set_PermitExtractContent(bool value);
    public bool get_PermitAnnotations();
    public void set_PermitAnnotations(bool value);
    public bool get_PermitFormsFill();
    public void set_PermitFormsFill(bool value);
    public bool get_PermitAccessibilityExtractContent();
    public void set_PermitAccessibilityExtractContent(bool value);
    public bool get_PermitAssembleDocument();
    public void set_PermitAssembleDocument(bool value);
    public bool get_PermitFullQualityPrint();
    public void set_PermitFullQualityPrint(bool value);
    internal PdfStandardSecurityHandler get_SecurityHandler();
}
public class PdfSharpCore.Pdf.Security.PdfStandardSecurityHandler : PdfSecurityHandler {
    internal string _userPassword;
    internal string _ownerPassword;
    private static Byte[] PasswordPadding;
    private Byte[] _encryptionKey;
    private MD5 _md5;
    private Byte[] _state;
    private Byte[] _ownerKey;
    private Byte[] _userKey;
    private Byte[] _key;
    private int _keySize;
    private IEncryptor stringEncryptor;
    private IEncryptor streamEncryptor;
    unknown string UserPassword {public set; }
    unknown string OwnerPassword {public set; }
    internal PdfUserAccessPermission Permission { get; internal set; }
    internal DictionaryMeta Meta { get; }
    internal PdfStandardSecurityHandler(PdfDocument document);
    internal PdfStandardSecurityHandler(PdfDictionary dict);
    private static PdfStandardSecurityHandler();
    public void set_UserPassword(string value);
    public void set_OwnerPassword(string value);
    internal PdfUserAccessPermission get_Permission();
    internal void set_Permission(PdfUserAccessPermission value);
    public void EncryptDocument();
    internal void EncryptObject(PdfObject value);
    private void EncryptDictionary(PdfDictionary dict);
    private void EncryptArray(PdfArray array);
    private void EncryptString(PdfString value);
    internal Byte[] EncryptBytes(Byte[] bytes);
    public PasswordValidity ValidatePassword(string inputPassword);
    [ConditionalAttribute("DEBUG")]
private static void DumpBytes(string tag, Byte[] bytes);
    private static Byte[] PadPassword(string password);
    private void InitWithUserPassword(Byte[] documentID, string userPassword, Byte[] ownerKey, int permissions, bool strongEncryption);
    private void InitWithOwnerPassword(Byte[] documentID, string ownerPassword, Byte[] ownerKey, int permissions, bool strongEncryption);
    private Byte[] ComputeOwnerKey(Byte[] userPad, Byte[] ownerPad, bool strongEncryption);
    private void InitEncryptionKey(Byte[] documentID, Byte[] userPad, Byte[] ownerKey, int permissions, bool strongEncryption);
    private void SetupUserKey(Byte[] documentID);
    private void PrepareKey();
    private void PrepareRC4Key(Byte[] key);
    private void PrepareRC4Key(Byte[] key, int offset, int length);
    private void EncryptRC4(Byte[] data);
    private void EncryptRC4(Byte[] data, int offset, int length);
    private void EncryptRC4(Byte[] inputData, Byte[] outputData);
    private void EncryptRC4(Byte[] inputData, int offset, int length, Byte[] outputData);
    private bool EqualsKey(Byte[] value, int length);
    internal void SetHashKey(PdfObjectID id);
    public void PrepareEncryption();
    internal virtual void WriteObject(PdfWriter writer);
    internal virtual DictionaryMeta get_Meta();
}
[FlagsAttribute]
internal enum PdfSharpCore.Pdf.Security.PdfUserAccessPermission : Enum {
    public int value__;
    public static PdfUserAccessPermission PermitAll;
    public static PdfUserAccessPermission PermitPrint;
    public static PdfUserAccessPermission PermitModifyDocument;
    public static PdfUserAccessPermission PermitExtractContent;
    public static PdfUserAccessPermission PermitAnnotations;
    public static PdfUserAccessPermission PermitFormsFill;
    public static PdfUserAccessPermission PermitAccessibilityExtractContent;
    public static PdfUserAccessPermission PermitAssembleDocument;
    public static PdfUserAccessPermission PermitFullQualityPrint;
}
internal class PdfSharpCore.Pdf.Security.RC4Encryptor : EncryptorBase {
    private Byte[] state;
    public virtual void InitEncryptionKey(string password);
    public sealed virtual bool ValidatePassword(string password);
    private void ValidateUserPassword(string password);
    private void ValidateOwnerPassword(string password);
    public void CreateOwnerKey(string password);
    public void CreateUserKey(string password);
    public virtual void CreateHashKey(PdfObjectID id);
    public virtual Byte[] Encrypt(Byte[] bytes);
    protected void PrepareRC4Key(Byte[] key);
    protected void PrepareRC4Key(Byte[] key, int offset, int length);
    protected void EncryptRC4(Byte[] data);
    protected void EncryptRC4(Byte[] data, int offset, int length);
    protected void EncryptRC4(Byte[] inputData, Byte[] outputData);
    protected void EncryptRC4(Byte[] inputData, int offset, int length, Byte[] outputData);
}
[DebuggerDisplayAttribute("(Left={left.Millimeter}mm, Right={right.Millimeter}mm, Top={top.Millimeter}mm, Bottom={bottom.Millimeter}mm)")]
public class PdfSharpCore.Pdf.TrimMargins : object {
    private XUnit _left;
    private XUnit _right;
    private XUnit _top;
    private XUnit _bottom;
    unknown XUnit All {public set; }
    public XUnit Left { get; public set; }
    public XUnit Right { get; public set; }
    public XUnit Top { get; public set; }
    public XUnit Bottom { get; public set; }
    public bool AreSet { get; }
    public void set_All(XUnit value);
    public XUnit get_Left();
    public void set_Left(XUnit value);
    public XUnit get_Right();
    public void set_Right(XUnit value);
    public XUnit get_Top();
    public void set_Top(XUnit value);
    public XUnit get_Bottom();
    public void set_Bottom(XUnit value);
    public bool get_AreSet();
}
public enum PdfSharpCore.Pdf.VCF : Enum {
    public int value__;
    public static VCF None;
    public static VCF Create;
    public static VCF CreateIndirect;
}
public class PdfSharpCore.PdfSharpException : Exception {
    public PdfSharpException(string message);
    public PdfSharpException(string message, Exception innerException);
}
public static class PdfSharpCore.ProductVersionInfo : object {
    public static string Title;
    public static string Description;
    public static string Producer;
    public static string Producer2;
    public static string Version;
    public static string Version2;
    public static string Url;
    public static string Configuration;
    public static string Company;
    public static string Product;
    public static string Copyright;
    public static string Trademark;
    public static string Culture;
    public static string VersionMajor;
    public static string VersionMinor;
    public static string VersionBuild;
    public static string VersionPatch;
    public static string VersionPrerelease;
    public static string VersionReferenceDate;
    public static string NuGetID;
    public static string NuGetTitle;
    public static string NuGetAuthors;
    public static string NuGetOwners;
    public static string NuGetDescription;
    public static string NuGetReleaseNotes;
    public static string NuGetSummary;
    public static string NuGetLanguage;
    public static string NuGetProjectUrl;
    public static string NuGetIconUrl;
    public static string NuGetLicenseUrl;
    public static bool NuGetRequireLicenseAcceptance;
    public static string NuGetTags;
    public static string Technology;
}
internal enum PdfSharpCore.PSMsgID : Enum {
    public int value__;
    public static PSMsgID SampleMessage1;
    public static PSMsgID SampleMessage2;
    public static PSMsgID NameMustStartWithSlash;
    public static PSMsgID UserOrOwnerPasswordRequired;
    public static PSMsgID UnexpectedToken;
    public static PSMsgID UnknownEncryption;
}
internal static class PdfSharpCore.PSSR : object {
    private static ResourceManager _resmngr;
    public static string IndexOutOfRange { get; }
    public static string ListEnumCurrentOutOfRange { get; }
    public static string PageIndexOutOfRange { get; }
    public static string OutlineIndexOutOfRange { get; }
    public static string SetValueMustNotBeNull { get; }
    public static string ObsoleteFunktionCalled { get; }
    public static string OwningDocumentRequired { get; }
    public static string FontDataReadOnly { get; }
    public static string ErrorReadingFontData { get; }
    public static string PointArrayEmpty { get; }
    public static string NeedPenOrBrush { get; }
    public static string InvalidPdf { get; }
    public static string InvalidVersionNumber { get; }
    public static string CannotHandleXRefStreams { get; }
    public static string PasswordRequired { get; }
    public static string InvalidPassword { get; }
    public static string OwnerPasswordRequired { get; }
    public static string UserOrOwnerPasswordRequired { get; }
    public static string CannotModify { get; }
    public static string NameMustStartWithSlash { get; }
    public static string MultiplePageInsert { get; }
    public static string UnexpectedTokenInPdfFile { get; }
    public static string UnknownEncryption { get; }
    public static ResourceManager ResMngr { get; }
    private static PSSR();
    public static string Format(PSMsgID id, Object[] args);
    public static string Format(string format, Object[] args);
    public static string GetString(PSMsgID id);
    public static string get_IndexOutOfRange();
    public static string get_ListEnumCurrentOutOfRange();
    public static string get_PageIndexOutOfRange();
    public static string get_OutlineIndexOutOfRange();
    public static string get_SetValueMustNotBeNull();
    public static string InvalidValue(int val, string name, int min, int max);
    public static string get_ObsoleteFunktionCalled();
    public static string get_OwningDocumentRequired();
    public static string FileNotFound(string path);
    public static string get_FontDataReadOnly();
    public static string get_ErrorReadingFontData();
    public static string get_PointArrayEmpty();
    public static string PointArrayAtLeast(int count);
    public static string get_NeedPenOrBrush();
    public static string CannotChangeImmutableObject(string typename);
    public static string FontAlreadyAdded(string fontname);
    public static string NotImplementedForFontsRetrievedWithFontResolver(string name);
    public static string get_InvalidPdf();
    public static string get_InvalidVersionNumber();
    public static string get_CannotHandleXRefStreams();
    public static string get_PasswordRequired();
    public static string get_InvalidPassword();
    public static string get_OwnerPasswordRequired();
    public static string get_UserOrOwnerPasswordRequired();
    public static string get_CannotModify();
    public static string get_NameMustStartWithSlash();
    public static string ImportPageNumberOutOfRange(int pageNumber, int maxPage, string path);
    public static string get_MultiplePageInsert();
    public static string get_UnexpectedTokenInPdfFile();
    public static string InappropriateColorSpace(PdfColorMode colorMode, XColorSpace colorSpace);
    public static string CannotGetGlyphTypeface(string fontName);
    public static string UnexpectedToken(string token);
    public static string get_UnknownEncryption();
    public static ResourceManager get_ResMngr();
    [ConditionalAttribute("DEBUG")]
public static void TestResourceMessages();
}
public class PdfSharpCore.Utils.FontResolver : object {
    private static Dictionary`2<string, FontFamilyModel> InstalledFonts;
    private static String[] SSupportedFonts;
    [CompilerGeneratedAttribute]
private bool <NullIfFontNotFound>k__BackingField;
    public string DefaultFontName { get; }
    public bool NullIfFontNotFound { get; public set; }
    private static FontResolver();
    public sealed virtual string get_DefaultFontName();
    public static void SetupFontsFiles(String[] sSupportedFonts);
    private static FontFamilyModel DeserializeFontFamily(string fontFamilyName, IEnumerable`1<FontFileInfo> fontList);
    public virtual Byte[] GetFont(string faceFileName);
    [CompilerGeneratedAttribute]
public bool get_NullIfFontNotFound();
    [CompilerGeneratedAttribute]
public void set_NullIfFontNotFound(bool value);
    public virtual FontResolverInfo ResolveTypeface(string familyName, bool isBold, bool isItalic);
}
public class PdfSharpCore.Utils.ImageSharpImageSource`1 : ImageSource {
    public static IImageSource FromImageSharpImage(Image`1<TPixel> image, IImageFormat imgFormat, Nullable`1<int> quality);
    protected virtual IImageSource FromBinaryImpl(string name, Func`1<Byte[]> imageSource, Nullable`1<int> quality);
    protected virtual IImageSource FromFileImpl(string path, Nullable`1<int> quality);
    protected virtual IImageSource FromStreamImpl(string name, Func`1<Stream> imageStream, Nullable`1<int> quality);
}
public static class PdfSharpCore.Utils.LinuxSystemFontResolver : object {
    private static string libfontconfig;
    private static Lazy`1<IntPtr> fcConfig;
    private static LinuxSystemFontResolver();
    private static IntPtr FcInitLoadConfigAndFonts();
    public static FcPatternHandle FcPatternCreate();
    public static int FcPatternGetString(IntPtr p, string obj, int n, IntPtr& s);
    public static void FcPatternDestroy(IntPtr pattern);
    public static FcObjectSetHandle FcObjectSetCreate();
    public static int FcObjectSetAdd(FcObjectSetHandle os, string obj);
    public static void FcObjectSetDestroy(IntPtr os);
    public static FcFontSetHandle FcFontList(IntPtr config, FcPatternHandle pattern, FcObjectSetHandle os);
    public static void FcFontSetDestroy(IntPtr fs);
    private static string GetString(IntPtr handle, string obj);
    [IteratorStateMachineAttribute("PdfSharpCore.Utils.LinuxSystemFontResolver/<ResolveFontConfig>d__16")]
private static IEnumerable`1<string> ResolveFontConfig();
    public static String[] Resolve();
    private static IEnumerable`1<string> ResolveFallback();
    private static IEnumerable`1<string> SearchPaths();
    [CompilerGeneratedAttribute]
internal static void <ResolveFallback>g__AddFontsToFontList|18_0(string path, <>c__DisplayClass18_0& );
}
internal static class PdfSharpCore.VersionInfo : object {
    public static string Title;
    public static string Description;
    public static string Producer;
    public static string Version;
    public static string Url;
    public static string Configuration;
    public static string Company;
    public static string Product;
    public static string Copyright;
    public static string Trademark;
    public static string Culture;
}
[AttributeUsageAttribute("28108")]
internal class System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes memberTypes);
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
}
[FlagsAttribute]
internal enum System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
    public int value__;
    public static DynamicallyAccessedMemberTypes None;
    public static DynamicallyAccessedMemberTypes PublicParameterlessConstructor;
    public static DynamicallyAccessedMemberTypes PublicConstructors;
    public static DynamicallyAccessedMemberTypes NonPublicConstructors;
    public static DynamicallyAccessedMemberTypes PublicMethods;
    public static DynamicallyAccessedMemberTypes NonPublicMethods;
    public static DynamicallyAccessedMemberTypes PublicFields;
    public static DynamicallyAccessedMemberTypes NonPublicFields;
    public static DynamicallyAccessedMemberTypes PublicNestedTypes;
    public static DynamicallyAccessedMemberTypes NonPublicNestedTypes;
    public static DynamicallyAccessedMemberTypes PublicProperties;
    public static DynamicallyAccessedMemberTypes NonPublicProperties;
    public static DynamicallyAccessedMemberTypes PublicEvents;
    public static DynamicallyAccessedMemberTypes NonPublicEvents;
    public static DynamicallyAccessedMemberTypes Interfaces;
    public static DynamicallyAccessedMemberTypes All;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
