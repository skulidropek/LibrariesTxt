[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public class PeanutButter.Utils.ActionRef`1 : MulticastDelegate {
    public ActionRef`1(object object, IntPtr method);
    public virtual void Invoke(T1& item);
    public virtual IAsyncResult BeginInvoke(T1& item, AsyncCallback callback, object object);
    public virtual void EndInvoke(T1& item, IAsyncResult result);
}
[ExtensionAttribute]
internal static class PeanutButter.Utils.ArrayExtensions : object {
    [ExtensionAttribute]
internal static PropertyOrField[] Encapsulate(PropertyInfo[] propertyInfos);
    [ExtensionAttribute]
internal static PropertyOrField[] Encapsulate(FieldInfo[] propertyInfos);
}
[ExtensionAttribute]
public static class PeanutButter.Utils.AssemblyExtensions : object {
    [ExtensionAttribute]
public static Type FindTypeByName(Assembly assembly, string typeName);
    [IteratorStateMachineAttribute("PeanutButter.Utils.AssemblyExtensions/<WalkDependencies>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<Assembly> WalkDependencies(Assembly asm);
}
public static class PeanutButter.Utils.Async : object {
    public static void RunSync(Func`1<Task> task);
    public static T RunSync(Func`1<Task`1<T>> task);
}
[ExtensionAttribute]
public static class PeanutButter.Utils.AsyncExtensionsForIEnumerables : object {
    [AsyncStateMachineAttribute("PeanutButter.Utils.AsyncExtensionsForIEnumerables/<ForEachAsync>d__0`1")]
[ExtensionAttribute]
public static Task ForEachAsync(IEnumerable`1<T> collection, Func`2<T, Task> toRun);
    [AsyncStateMachineAttribute("PeanutButter.Utils.AsyncExtensionsForIEnumerables/<ForEachAsync>d__1`1")]
[ExtensionAttribute]
public static Task ForEachAsync(IEnumerable`1<T> collection, Func`3<T, int, Task> toRunWithIndex);
    [AsyncStateMachineAttribute("PeanutButter.Utils.AsyncExtensionsForIEnumerables/<ToArrayAsync>d__2`1")]
[ExtensionAttribute]
public static Task`1<T[]> ToArrayAsync(Task`1<IEnumerable`1<T>> src);
    [AsyncStateMachineAttribute("PeanutButter.Utils.AsyncExtensionsForIEnumerables/<ToArrayAsync>d__3`1")]
[ExtensionAttribute]
public static Task`1<T[]> ToArrayAsync(Task`1<T[]> src);
    [AsyncStateMachineAttribute("PeanutButter.Utils.AsyncExtensionsForIEnumerables/<ToArrayAsync>d__4`1")]
[ExtensionAttribute]
public static Task`1<T[]> ToArrayAsync(Task`1<List`1<T>> src);
    [AsyncStateMachineAttribute("PeanutButter.Utils.AsyncExtensionsForIEnumerables/<AggregateAsync>d__5`2")]
[ExtensionAttribute]
public static Task`1<TAccumulator> AggregateAsync(IEnumerable`1<TItem> items, TAccumulator seed, Func`3<TAccumulator, TItem, Task`1<TAccumulator>> reducer);
    [AsyncStateMachineAttribute("PeanutButter.Utils.AsyncExtensionsForIEnumerables/<SelectAsync>d__6`2")]
[ExtensionAttribute]
public static Task`1<TOut[]> SelectAsync(IEnumerable`1<TIn> src, Func`2<TIn, Task`1<TOut>> transform);
    [AsyncStateMachineAttribute("PeanutButter.Utils.AsyncExtensionsForIEnumerables/<WhereAsync>d__7`1")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<T>> WhereAsync(IEnumerable`1<T> src, Func`2<T, Task`1<bool>> discriminator);
}
public class PeanutButter.Utils.AttributeWalkStep : object {
    [CompilerGeneratedAttribute]
private Type <InitialType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <CurrentType>k__BackingField;
    [CompilerGeneratedAttribute]
private Attribute[] <Attributes>k__BackingField;
    public Type InitialType { get; }
    public Type CurrentType { get; }
    public Attribute[] Attributes { get; }
    public AttributeWalkStep(Type initialType, Type currentType, Attribute[] attributes);
    [CompilerGeneratedAttribute]
public Type get_InitialType();
    [CompilerGeneratedAttribute]
public Type get_CurrentType();
    [CompilerGeneratedAttribute]
public Attribute[] get_Attributes();
}
public class PeanutButter.Utils.AutoBarrier : object {
    private Barrier _barrier;
    public AutoBarrier(Barrier barrier);
    public sealed virtual void Dispose();
}
public class PeanutButter.Utils.AutoDeleter : object {
    private List`1<string> _toDelete;
    public AutoDeleter(String[] paths);
    public void Add(String[] paths);
    public sealed virtual void Dispose();
    private void Delete(string path);
}
public class PeanutButter.Utils.AutoDisposer : object {
    private Action`1<IDisposable> _beforeDisposing;
    private List`1<IDisposable> _toDispose;
    [CompilerGeneratedAttribute]
private bool <ThreadedDisposal>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDegreeOfParallelism>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BackgroundDisposal>k__BackingField;
    public bool ThreadedDisposal { get; public set; }
    public int MaxDegreeOfParallelism { get; public set; }
    public bool BackgroundDisposal { get; public set; }
    public AutoDisposer(IDisposable[] toDispose);
    public AutoDisposer(Action`1<IDisposable> beforeDisposing);
    [CompilerGeneratedAttribute]
public bool get_ThreadedDisposal();
    [CompilerGeneratedAttribute]
public void set_ThreadedDisposal(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxDegreeOfParallelism();
    [CompilerGeneratedAttribute]
public void set_MaxDegreeOfParallelism(int value);
    [CompilerGeneratedAttribute]
public bool get_BackgroundDisposal();
    [CompilerGeneratedAttribute]
public void set_BackgroundDisposal(bool value);
    public void Add(IDisposable[] toDispose);
    public T Add(T toDispose);
    public sealed virtual void Dispose();
    private void CleanupInSerial(IDisposable[] toDispose);
    private void CleanupInParallel(IDisposable[] toDispose);
    private static void TryDo(Action action);
    private static void SafelyDispose(IDisposable disposable);
    public void DisposeNow(IDisposable disposable);
}
public class PeanutButter.Utils.AutoLocker : object {
    private object _disposeLock;
    private Semaphore _fatty;
    private Mutex _mutex;
    private SemaphoreSlim _slim;
    [CompilerGeneratedAttribute]
private EventHandler <OnDisposed>k__BackingField;
    public EventHandler OnDisposed { get; public set; }
    public AutoLocker(Semaphore semaphore);
    public AutoLocker(Semaphore semaphore, Action onDisposed);
    public AutoLocker(SemaphoreSlim semaphore);
    public AutoLocker(SemaphoreSlim semaphore, Action onDisposed);
    public AutoLocker(Mutex mutex);
    public AutoLocker(Mutex mutex, Action onDisposed);
    [CompilerGeneratedAttribute]
public EventHandler get_OnDisposed();
    [CompilerGeneratedAttribute]
public void set_OnDisposed(EventHandler value);
    private void SetOnDisposed(Action onDisposed);
    public sealed virtual void Dispose();
    private void TriggerOnDisposed();
}
public class PeanutButter.Utils.AutoResetter : object {
    private object _lock;
    private Action _disposalAction;
    public AutoResetter(Action constructionAction, Action disposalAction);
    public AutoResetter(Action disposalAction);
    public static AutoResetter Create(Action onStart, Action onDisposed);
    public static AutoResetter`1<T> Create(Func`1<T> onStart, Action`1<T> onDisposed);
    public sealed virtual void Dispose();
}
public class PeanutButter.Utils.AutoResetter`1 : object {
    private T _initialValue;
    private object _lock;
    private Action`1<T> _disposalAction;
    public AutoResetter`1(Func`1<T> start, Action`1<T> end);
    public sealed virtual void Dispose();
}
public class PeanutButter.Utils.AutoResettingFile : object {
    public static int MaxInMemoryFileSizeInBytes;
    private IDisposable _storage;
    private static Dictionary`2<StorageTypes, Func`2<string, IDisposable>> StorageFactories;
    public AutoResettingFile(string path);
    public AutoResettingFile(string path, StorageTypes storageType);
    private static AutoResettingFile();
    private IDisposable ResolveStorage(StorageTypes storageType, string path);
    public sealed virtual void Dispose();
}
public class PeanutButter.Utils.AutoTempEnvironmentVariable : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OriginalValue>k__BackingField;
    private bool _disposed;
    public string Name { get; }
    public string Value { get; }
    public string OriginalValue { get; public set; }
    public AutoTempEnvironmentVariable(string name, string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public string get_OriginalValue();
    [CompilerGeneratedAttribute]
public void set_OriginalValue(string value);
    public sealed virtual void Dispose();
}
public class PeanutButter.Utils.AutoTempFile : object {
    private int _retryOperations;
    private string _tempFile;
    private AutoDeleter _actual;
    private object _lock;
    private List`1<Func`3<string, string, string>> _fileNameStrategies;
    public int RetryOperations { get; public set; }
    public string Path { get; }
    public Byte[] BinaryData { get; public set; }
    public string StringData { get; public set; }
    public AutoTempFile(Byte[] data);
    public AutoTempFile(string data);
    public AutoTempFile(string baseFolder, string data);
    public AutoTempFile(string baseFolder, Byte[] data);
    public AutoTempFile(string baseFolder, string fileName, Byte[] data);
    public int get_RetryOperations();
    public void set_RetryOperations(int value);
    public string get_Path();
    public Byte[] get_BinaryData();
    public void set_BinaryData(Byte[] value);
    public string get_StringData();
    public void set_StringData(string value);
    private static string FileNameWhenFolderNotSpecifiedAndFileIsSpecified(string folder, string file);
    private static string FileNameWhenFolderSpecifiedAndFileNotSpecified(string folder, string file);
    private static string GetNewFileNameUnder(string folder);
    private static string GetFileNameOfNewTempFile();
    private static string FileNameWhenFolderAndFileNotSpecified(string folder, string file);
    private void SetTempFileNameWith(string baseFolder, string fileName);
    public void Delete();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private Byte[] <get_BinaryData>b__7_0();
    [CompilerGeneratedAttribute]
private string <get_StringData>b__10_0();
}
public class PeanutButter.Utils.AutoTempFolder : object {
    private int _retryOperations;
    public static FileAccess DEFAULT_FILE_ACCESS;
    public static FileShare DEFAULT_FILE_SHARE;
    public static int DEFAULT_BUFFER_SIZE;
    public static FileOptions DEFAULT_FILE_OPTIONS;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    private object _lock;
    private AutoDeleter _autoDeleter;
    private static string PathSeparator;
    private List`1<FileStream> _fileStreams;
    private static StringComparison PathComparison;
    public int RetryOperations { get; public set; }
    public string Path { get; private set; }
    public AutoTempFolder(string baseFolder);
    private static AutoTempFolder();
    public sealed virtual int get_RetryOperations();
    public sealed virtual void set_RetryOperations(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    public sealed virtual void Dispose();
    public sealed virtual string ResolvePath(string p1, String[] more);
    public sealed virtual IEnumerable`1<string> ResolvePaths(IEnumerable`1<string> relativePaths);
    public sealed virtual string CreateFolder(string dirname);
    public sealed virtual string WriteFile(string filename, string data);
    public sealed virtual string WriteFile(string filename, Byte[] data);
    public sealed virtual string WriteFile(string filename, Stream data);
    public sealed virtual string ReadTextFile(string filename);
    public sealed virtual Byte[] ReadFile(string filename);
    public sealed virtual FileStream OpenFile(string filename);
    public sealed virtual FileStream OpenFile(string filename, FileAccess access);
    public sealed virtual FileStream OpenFile(string filename, FileAccess access, FileShare share);
    public sealed virtual FileStream OpenFile(string filename, FileAccess access, FileShare share, int bufferSize);
    public sealed virtual FileStream OpenFile(string filename, FileAccess access, FileShare share, int bufferSize, FileOptions options);
    public sealed virtual bool FileExists(string relativePath);
    public sealed virtual bool FolderExists(string relativePath);
    public sealed virtual bool Exists(string relativePath);
    public sealed virtual bool Contains(string fullPath);
    private FileStream Store(FileStream stream);
    [CompilerGeneratedAttribute]
private DirectoryInfo <.ctor>b__15_0();
    [CompilerGeneratedAttribute]
private string <ResolvePaths>b__18_0(string s);
}
public class PeanutButter.Utils.AutoWorkFolder : object {
    private AutoTempFolder _tempFolder;
    private string _startDir;
    public AutoWorkFolder(AutoTempFolder tempFolder);
    public AutoWorkFolder(AutoTempFolder tempFolder, bool disposeTempFolderWhenDone);
    public AutoWorkFolder(string folder);
    public sealed virtual void Dispose();
}
public static class PeanutButter.Utils.Benchmark : object {
    public static void PrintTime(string label, Action toRun, int iterations);
    [AsyncStateMachineAttribute("PeanutButter.Utils.Benchmark/<PrintTimeAsync>d__1")]
public static Task PrintTimeAsync(string label, Func`1<Task> toRun, int iterations);
    public static TimeSpan Time(Action action);
    public static TimeSpan Time(Action action, int iterations);
    [AsyncStateMachineAttribute("PeanutButter.Utils.Benchmark/<TimeAsync>d__4")]
public static Task`1<TimeSpan> TimeAsync(Func`1<Task> action);
    [AsyncStateMachineAttribute("PeanutButter.Utils.Benchmark/<TimeAsync>d__5")]
public static Task`1<TimeSpan> TimeAsync(Func`1<Task> action, int iterations);
}
[ExtensionAttribute]
public static class PeanutButter.Utils.BooleanExtensions : object {
    [ExtensionAttribute]
public static bool Negate(Boolean& value);
}
public abstract class PeanutButter.Utils.Builder`2 : object {
    private static Type EntityType;
    private static bool IsInterfaceType;
    private static bool HasParameterlessConstructor;
    private List`1<ActionRef`1<TEntity>> _transforms;
    private static Builder`2();
    public static TBuilder Create();
    public static TEntity BuildDefault();
    protected virtual TEntity ConstructEntity();
    private TEntity ThrowUnconstructable(string info, Exception ex);
    public sealed virtual TBuilder WithProp(ActionRef`1<TEntity> transform);
    public sealed virtual TBuilder WithProp(Action`1<TEntity> transform);
    public virtual TEntity Build();
    private void RunTransforms(TEntity& entity, ActionRef`1[] transforms, int depth);
}
[ExtensionAttribute]
public static class PeanutButter.Utils.ByteArrayExtensions : object {
    private static Byte[] GZipHeader;
    private static ByteArrayExtensions();
    [ExtensionAttribute]
[ObsoleteAttribute("renamed to ToMd5String")]
public static string ToMD5String(Byte[] data);
    [ExtensionAttribute]
public static string ToMd5String(Byte[] data);
    [ExtensionAttribute]
[ObsoleteAttribute("renamed to ToUtf8String")]
public static string ToUTF8String(Byte[] data);
    [ExtensionAttribute]
public static string ToUtf8String(Byte[] data);
    [ExtensionAttribute]
public static string ToBase64(Byte[] data);
    [ExtensionAttribute]
public static MemoryStream ToMemoryStream(Byte[] bytes);
    [ExtensionAttribute]
public static ArraySegment`1<byte> ToArraySegment(Byte[] bytes);
    [ExtensionAttribute]
public static bool StartsWith(Byte[] data, Byte[] reference);
    [ExtensionAttribute]
public static Byte[] GZip(Byte[] data);
    [ExtensionAttribute]
public static Byte[] UnGZip(Byte[] data);
    [ExtensionAttribute]
public static bool IsGZipped(Byte[] data);
}
public class PeanutButter.Utils.CannotZipNullException : Exception {
}
[DefaultMemberAttribute("Item")]
public class PeanutButter.Utils.CircularList`1 : object {
    private List`1<T> _store;
    public int Count { get; }
    public IEnumerable`1<T> Items { get; }
    public int ItemCount { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public CircularList`1(IEnumerable`1<T> items);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    [IteratorStateMachineAttribute("PeanutButter.Utils.CircularList`1/<get_Items>d__13")]
public sealed virtual IEnumerable`1<T> get_Items();
    public sealed virtual int get_ItemCount();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private int Modulo(int index);
}
public class PeanutButter.Utils.Commandline : object {
    [CompilerGeneratedAttribute]
private string <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Args>k__BackingField;
    private static Regex WhiteSpace;
    private static char QUOTE;
    public string Command { get; }
    public String[] Args { get; }
    public Commandline(string command, String[] args);
    private static Commandline();
    [CompilerGeneratedAttribute]
public string get_Command();
    [CompilerGeneratedAttribute]
public String[] get_Args();
    public virtual string ToString();
    private string QuoteIfRequired(string arg);
    private static string DeQuote(string str);
    public static Commandline Parse(string commandline);
    public static string op_Implicit(Commandline o);
    public static Commandline op_Implicit(string s);
}
[ExtensionAttribute]
public static class PeanutButter.Utils.ConcurrentCollectionExtensions : object {
    [ExtensionAttribute]
public static void Clear(ConcurrentQueue`1<T> queue);
    [ExtensionAttribute]
public static void Clear(ConcurrentBag`1<T> bag);
}
public static class PeanutButter.Utils.ConsoleSteps : object {
    public static ITextStatusSteps Basic();
    public static ITextStatusSteps Basic(string prefix);
    public static ITextStatusSteps Basic(string prefix, string startLabel, string okLabel, string failLabel, TextWriter target);
    private static ErrorHandlerResult BasicExceptionHandler(Exception ex, TextWriter writer);
    public static ITextStatusSteps Basic(TextWriter writer);
    public static ITextStatusSteps Basic(string prefix, TextWriter writer);
    public static ITextStatusSteps ForTesting();
    public static ITextStatusSteps ForTesting(string prefix);
    public static ITextStatusSteps ForTesting(string prefix, string startLabel, string okLabel, string failLabel, TextWriter target);
    private static void WriteTestingStatusLine(string s, TextWriter target);
    private static ErrorHandlerResult BasicTestingExceptionHandler(Exception ex, TextWriter writer);
    public static ITextStatusSteps ForTesting(TextWriter writer);
    public static ITextStatusSteps ForTesting(string prefix, TextWriter writer);
}
public enum PeanutButter.Utils.ConstructFlags : Enum {
    public int value__;
    public static ConstructFlags None;
    public static ConstructFlags MatchTypesExactly;
    public static ConstructFlags ErrorWhenUnusedArguments;
    public static ConstructFlags ErrorWhenUnspecifiedParameters;
}
[ExtensionAttribute]
public static class PeanutButter.Utils.DateTimeExtensions : object {
    private static TimeSpan TwentyFourHours;
    private static TimeSpan OneMillisecond;
    private static DateTimeExtensions();
    [ExtensionAttribute]
public static bool IsWithinRange(DateTime value, DateTime start, DateTime end);
    [ExtensionAttribute]
public static string AsHoursAndMinutes(DateTime value);
    [ExtensionAttribute]
public static string AsTimeString(DateTime value);
    [ExtensionAttribute]
public static long MillisecondsSinceStartOfDay(DateTime value);
    [ExtensionAttribute]
public static DateTime StartOfDay(DateTime value);
    [ExtensionAttribute]
public static DateTimeOffset StartOfDay(DateTimeOffset value);
    [ExtensionAttribute]
public static DateTime EndOfDay(DateTime value);
    [ExtensionAttribute]
public static DateTime AsTimeOnly(DateTime value);
    [ExtensionAttribute]
public static DateTime WithTime(DateTime value, int hour, int minute, int second, int millisecond);
    [ExtensionAttribute]
public static DateTime WithTime(DateTime value, TimeSpan time);
    [ExtensionAttribute]
public static DateTime TruncateMicroseconds(DateTime value);
    [ExtensionAttribute]
public static DateTime TruncateMilliseconds(DateTime value);
    [ExtensionAttribute]
[ObsoleteAttribute("Please switch to .WithKind, which avoids the potential confusion of an expectation of 'conversion' of the DateTime from/to local time.")]
public static DateTime ToKind(DateTime value, DateTimeKind kind);
    [ExtensionAttribute]
public static DateTime WithKind(DateTime value, DateTimeKind kind);
    [ExtensionAttribute]
public static bool IsBetween(DateTime subject, DateTime before, DateTime after);
    [ExtensionAttribute]
public static DateTime TruncateSeconds(DateTime value);
    [ExtensionAttribute]
public static DateTime TruncateMinutes(DateTime value);
    [ExtensionAttribute]
public static DateTime TruncateHours(DateTime value);
    [ExtensionAttribute]
public static DateTime TruncateDays(DateTime value);
    [ExtensionAttribute]
public static DateTime TruncateMonths(DateTime value);
    [ExtensionAttribute]
public static int Microseconds(DateTime value);
    private static DateTime DateTimeFor(DateTimeKind kind, int years, int months, int days, int hours, int minutes, int seconds, int milliseconds);
}
public class PeanutButter.Utils.DecimalDecorator : object {
    [CompilerGeneratedAttribute]
private bool <IsValidDecimal>k__BackingField;
    private static object Lock;
    private static NumberFormatInfo _numberFormatInfoField;
    private string _stringValue;
    private decimal _decimalValue;
    public bool IsValidDecimal { get; }
    private static NumberFormatInfo NumberFormatInfo { get; }
    public DecimalDecorator(decimal value, string format);
    public DecimalDecorator(string value);
    private static DecimalDecorator();
    [CompilerGeneratedAttribute]
public bool get_IsValidDecimal();
    public static decimal Parse(string value);
    private static NumberFormatInfo get_NumberFormatInfo();
    private static NumberFormatInfo CreateNumberFormatInfo();
    public virtual string ToString();
    public decimal ToDecimal();
}
public class PeanutButter.Utils.DeepEqualityTester : object {
    private object _objSource;
    private object _objCompare;
    private String[] _ignorePropertiesByName;
    private Dictionary`2<object, object> _pendingComparisons;
    [CompilerGeneratedAttribute]
private bool <RecordErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FailOnMissingProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OnlyTestIntersectingProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeFields>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OnlyCompareShape>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <VerbosePropertyMismatchErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private EnumComparisonStrategies <EnumComparisonStrategy>k__BackingField;
    private List`1<string> _errors;
    private static MethodInfo TryCompareWithCustomComparerGenericMethod;
    private Nullable`1<bool> _ignoreDateTimeKind;
    private static String[] Positives;
    private static MethodInfo DeepCollectionCompareGenericMethod;
    private static Type EquatableGenericType;
    private static ConcurrentDictionary`2<Type, Type> EquatableInterfaces;
    private Func`4[] _comparableStrategies;
    private static Tuple`2[] LooselyComparableTypes;
    private static HashSet`1<Type> ComparableNumericTypes;
    private static string DUMP_DELIMITER;
    private List`1<object> _customComparers;
    public bool RecordErrors { get; public set; }
    public bool FailOnMissingProperties { get; public set; }
    public bool OnlyTestIntersectingProperties { get; public set; }
    public IEnumerable`1<string> Errors { get; }
    public bool IncludeFields { get; public set; }
    public bool OnlyCompareShape { get; public set; }
    public bool VerbosePropertyMismatchErrors { get; public set; }
    public EnumComparisonStrategies EnumComparisonStrategy { get; public set; }
    public DeepEqualityTester(object objSource, object objCompare, String[] ignorePropertiesByName);
    private static DeepEqualityTester();
    [CompilerGeneratedAttribute]
public bool get_RecordErrors();
    [CompilerGeneratedAttribute]
public void set_RecordErrors(bool value);
    [CompilerGeneratedAttribute]
public bool get_FailOnMissingProperties();
    [CompilerGeneratedAttribute]
public void set_FailOnMissingProperties(bool value);
    [CompilerGeneratedAttribute]
public bool get_OnlyTestIntersectingProperties();
    [CompilerGeneratedAttribute]
public void set_OnlyTestIntersectingProperties(bool value);
    public IEnumerable`1<string> get_Errors();
    [CompilerGeneratedAttribute]
public bool get_IncludeFields();
    [CompilerGeneratedAttribute]
public void set_IncludeFields(bool value);
    [CompilerGeneratedAttribute]
public bool get_OnlyCompareShape();
    [CompilerGeneratedAttribute]
public void set_OnlyCompareShape(bool value);
    [CompilerGeneratedAttribute]
public bool get_VerbosePropertyMismatchErrors();
    [CompilerGeneratedAttribute]
public void set_VerbosePropertyMismatchErrors(bool value);
    [CompilerGeneratedAttribute]
public EnumComparisonStrategies get_EnumComparisonStrategy();
    [CompilerGeneratedAttribute]
public void set_EnumComparisonStrategy(EnumComparisonStrategies value);
    private void ClearErrors();
    public bool AreDeepEqual();
    internal bool AreDeepEqual(Dictionary`2<object, object> pendingComparisons);
    private void RecordPrimitiveErrorIfRequiredFor(bool result);
    private void AddError(string message);
    private static bool CanBothBeComparedWithEquals(Type t1, Type t2);
    private bool AreDeepEqualInternal(object objSource, object objCompare);
    private bool CompareEnums(object objSource, object objCompare);
    private bool AreBothEnumTypes(Type sourceType, Type compareType);
    private bool AreSimpleEqual(Type sourceType, object objSource, Type compareType, object objCompare);
    private bool PerformDecimalEquals(decimal left, decimal right);
    private bool PerformSameTypeEquals(object left, object right);
    private Nullable`1<bool> TryCompareWithCustomComparer(object left, object right);
    private Nullable`1<bool> TryCompareWithCustomComparerGeneric(T left, T right);
    private bool IgnoreDateTimeKind();
    private Nullable`1<bool> CheckEnvironmentForIgnoreDateTimeKind();
    private Nullable`1<decimal> TryConvertToDecimal(object obj);
    private bool DeepCollectionCompare(Type sourceType, object objSource, Type compareType, object objCompare);
    private static Type GetItemTypeFor(Type collectionType);
    private bool DeepCollectionCompareGeneric(IEnumerable`1<T1> source, IEnumerable`1<T2> compare);
    private bool DeepCompareAtIndex(int index, object source, object target);
    private void ClearPendingOperations();
    private static bool CanBeComparedWithEquals(Type t);
    private static bool IsSimpleTypeOrNullableOfSimpleType(Type t);
    private static bool CanPerformSimpleTypeMatchFor(Type srcPropType);
    private PropertyOrField FindMatchingPropertyInfoFor(PropertyOrField srcPropInfo, IEnumerable`1<PropertyOrField> compareProperties);
    private void AddErrorForMismatch(PropertyOrField srcPropInfo, PropertyOrField compareInfo, bool eitherAreEnumerable);
    private bool TypesAreComparable(Type srcType, Type compareType);
    private static bool TypesAreAnonymousOrObject(DeepEqualityTester arg1, Type arg2, Type arg3);
    private static bool TypesAreBothEnums(DeepEqualityTester arg1, Type arg2, Type arg3);
    private static bool TypesHaveSimilarImmediateShape(DeepEqualityTester tester, Type srcType, Type compareType);
    private static bool TypesAreCloseEnough(DeepEqualityTester tester, Type srcType, Type compareType);
    private static bool TypesAreIdentical(DeepEqualityTester tester, Type srcType, Type compareType);
    private bool CanDetermineItemTypeForBoth(Type t1, Type t2);
    private bool DeepCompare(Type sourceType, object objSource, Type compareType, object objCompare);
    private PropertyOrField[] GetPropertiesAndFieldsOf(Type sourceType);
    private string DumpPropertyInfo(PropertyOrField[] propInfos);
    private PropertyOrField[] GetIntersectingPropertyInfos(IEnumerable`1<PropertyOrField> left, IEnumerable`1<PropertyOrField> right);
    private bool CompareWith(object objSource, object objCompare, PropertyOrField[] srcPropInfos, PropertyOrField[] comparePropInfos);
    private bool IsPending(object objSource, object objCompare);
    private bool PropertyValuesMatchFor(object objSource, object objCompare, PropertyOrField srcProp, PropertyOrField compareProp);
    private bool AreBothRuntimeTypeValues(object srcType, object targetType);
    private bool TryWrapEnumerable(object value, Object& wrapped, Type& wrappedType);
    private bool MatchPropertiesOrCollection(object srcValue, object compareValue, PropertyOrField srcProp, PropertyOrField compareProp);
    private void TryResolveEnumerable(Object& value, PropertyOrField prop, Type& resolvedType);
    private bool CollectionsMatch(object srcValue, Type srcEnumerableInterface, object compareValue, Type compareEnumerableInterface);
    private bool TestCollectionsMatch(IEnumerable`1<T1> collection1, IEnumerable`1<T2> collection2);
    private bool AllMembersOfFirstCollectionAreFoundInSecond(IEnumerable`1<T1> first, IEnumerable`1<T2> second);
    private bool ContainsOneLike(IEnumerable`1<T2> collection, T1 seek);
    private bool AreDeepEqualDetached(object left, object right);
    private void UseCustomComparers(List`1<object> customComparers);
    private static Type TryGetEnumerableInterfaceFor(PropertyOrField prop);
    public void AddCustomComparer(IEqualityComparer`1<T> comparer);
    public void AddCustomComparer(object comparer);
    [CompilerGeneratedAttribute]
internal static bool <TypesAreCloseEnough>g__IsComparableNumericType|77_0(Type test);
    [CompilerGeneratedAttribute]
private bool <GetPropertiesAndFieldsOf>b__81_1(PropertyOrField pi);
    [CompilerGeneratedAttribute]
private bool <GetPropertiesAndFieldsOf>b__81_4(PropertyOrField o);
}
public class PeanutButter.Utils.DefaultBackoffStrategy : object {
    public static int BACKOFF_MILLISECONDS;
    public sealed virtual void Backoff(int attempt);
}
[DefaultMemberAttribute("Item")]
public class PeanutButter.Utils.Dictionaries.CaseWarpingDictionaryWrapper`1 : object {
    private IDictionary`2<string, TValue> _actual;
    private Dictionary`2<string, string> _keyLookup;
    [CompilerGeneratedAttribute]
private StringComparer <Comparer>k__BackingField;
    public ICollection`1<string> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public StringComparer Comparer { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TValue Item { get; public set; }
    public CaseWarpingDictionaryWrapper`1(IDictionary`2<string, TValue> actual);
    public CaseWarpingDictionaryWrapper`1(IDictionary`2<string, TValue> actual, bool caseInsensitive);
    public CaseWarpingDictionaryWrapper`1(IDictionary`2<string, TValue> actual, StringComparer keyComparer);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    [CompilerGeneratedAttribute]
public StringComparer get_Comparer();
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<string, TValue> item);
    public sealed virtual void Add(string key, TValue value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<string, TValue> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, TValue& value);
    public sealed virtual TValue get_Item(string key);
    public sealed virtual void set_Item(string key, TValue value);
    private bool TryGetKey(string search, String& actual);
    private void SetValueAt(string key, TValue value);
    private TValue GetValueAt(string key);
    private void CacheKeys();
    [CompilerGeneratedAttribute]
private void <CacheKeys>b__33_0(KeyValuePair`2<string, TValue> kvp);
}
[DefaultMemberAttribute("Item")]
public class PeanutButter.Utils.Dictionaries.DefaultDictionary`2 : object {
    private Func`1<TValue> _defaultResolver;
    private bool _storeResolvedDefaults;
    private HashSet`1<TKey> _generatedKeys;
    private Func`2<TKey, TValue> _smartResolver;
    private Dictionary`2<TKey, TValue> _actual;
    private bool _reportMissingKeys;
    [CompilerGeneratedAttribute]
private IEqualityComparer`1<TKey> <Comparer>k__BackingField;
    [CompilerGeneratedAttribute]
private object <SyncRoot>k__BackingField;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public DefaultDictionary`2(DefaultDictionaryFlags flags);
    public DefaultDictionary`2(Func`1<TValue> defaultResolver);
    public DefaultDictionary`2(Func`1<TValue> defaultResolver, DefaultDictionaryFlags flags);
    public DefaultDictionary`2(Func`1<TValue> defaultResolver, IEqualityComparer`1<TKey> keyComparer);
    public DefaultDictionary`2(Func`1<TValue> defaultResolver, IEqualityComparer`1<TKey> keyComparer, DefaultDictionaryFlags flags);
    public DefaultDictionary`2(Func`2<TKey, TValue> smartResolver);
    private DefaultDictionary`2(Func`2<TKey, TValue> smartResolver, IEqualityComparer`1<TKey> keyComparer);
    [CompilerGeneratedAttribute]
public IEqualityComparer`1<TKey> get_Comparer();
    private IEqualityComparer`1<TKey> ResolveEqualityComparer(IEqualityComparer`1<TKey> provided);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    public sealed virtual void Remove(object key);
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    private void TrySetWithKey(object key, object value);
    private object TryGetWithKey(object key);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool Contains(object key);
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private bool ResolveDefaultOnto(TKey key, TValue& value);
    private TValue Resolve(TKey key);
    private TValue StoreIfNecessary(TKey key, TValue resolved);
    private TValue Store(TKey key, TValue resolved);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
}
[FlagsAttribute]
public enum PeanutButter.Utils.Dictionaries.DefaultDictionaryFlags : Enum {
    public int value__;
    public static DefaultDictionaryFlags None;
    public static DefaultDictionaryFlags CacheResolvedDefaults;
    public static DefaultDictionaryFlags ReportMissingKeys;
}
public class PeanutButter.Utils.Dictionaries.DictionaryWrappingNameValueCollection : DictionaryWrappingNameValueCollection`1<string> {
    public DictionaryWrappingNameValueCollection(NameValueCollection data, bool caseInsensitive);
    public DictionaryWrappingNameValueCollection(NameValueCollection data);
    public DictionaryWrappingNameValueCollection(NameValueCollection data, StringComparer comparer);
}
[DefaultMemberAttribute("Item")]
public class PeanutButter.Utils.Dictionaries.DictionaryWrappingNameValueCollection`1 : object {
    private NameValueCollection _data;
    [CompilerGeneratedAttribute]
private StringComparer <Comparer>k__BackingField;
    public StringComparer Comparer { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TValue Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public DictionaryWrappingNameValueCollection`1(NameValueCollection data, bool caseInsensitive);
    public DictionaryWrappingNameValueCollection`1(NameValueCollection data);
    public DictionaryWrappingNameValueCollection`1(NameValueCollection data, StringComparer comparer);
    [CompilerGeneratedAttribute]
public StringComparer get_Comparer();
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<string, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, TValue> item);
    private string GetKeyFor(string key);
    private bool KeysMatch(string one, string other);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<string, TValue> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual void Add(string key, TValue value);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, TValue& value);
    public sealed virtual TValue get_Item(string key);
    public sealed virtual void set_Item(string key, TValue value);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    [CompilerGeneratedAttribute]
private TValue <get_Values>b__30_0(string k);
}
internal class PeanutButter.Utils.Dictionaries.DictionaryWrappingNameValueCollectionEnumerator`1 : object {
    private DictionaryWrappingNameValueCollection`1<TValue> _data;
    private String[] _keys;
    private int _current;
    internal DictionaryWrappingNameValueCollection`1<TValue> Data { get; }
    public KeyValuePair`2<string, TValue> Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public DictionaryWrappingNameValueCollectionEnumerator`1(DictionaryWrappingNameValueCollection`1<TValue> data);
    internal DictionaryWrappingNameValueCollection`1<TValue> get_Data();
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual KeyValuePair`2<string, TValue> get_Current();
    private void RefreshKeys();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
[DefaultMemberAttribute("Item")]
public class PeanutButter.Utils.Dictionaries.DictionaryWrappingObject : object {
    private object _wrapped;
    private IPropertyOrField[] _props;
    private Dictionary`2<string, string> _keys;
    private Dictionary`2<string, object> _memberCache;
    private Dictionary`2<object, DictionaryWrappingObject> _wrapperCache;
    [CompilerGeneratedAttribute]
private StringComparer <Comparer>k__BackingField;
    private static Dictionary`2<Type, Func`2<object, IDictionary`2<string, string>>> SpecialCases;
    private static ConcurrentDictionary`2<Type, IPropertyOrField[]> PropertyCache;
    private static BindingFlags ProxyFlags;
    private Dictionary`2<string, object> _valueOverrides;
    private HashSet`1<string> _deletedKeys;
    private Object[] _values;
    private bool _forceWrappingDictionariesWithoutStringKeys;
    private Func`2<string, object> _propertyReader;
    private Type _wrappedType;
    private WrapOptions _options;
    private bool _copyOnWrite;
    public StringComparer Comparer { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<object> Values { get; }
    public DictionaryWrappingObject(object wrapped);
    public DictionaryWrappingObject(object wrapped, StringComparer keyComparer);
    public DictionaryWrappingObject(object wrapped, WrapOptions options);
    private DictionaryWrappingObject(object wrapped, StringComparer keyComparer, WrapOptions options, Dictionary`2<object, DictionaryWrappingObject> wrapperCache);
    public DictionaryWrappingObject(object wrapped, StringComparer keyComparer, WrapOptions options);
    private static DictionaryWrappingObject();
    public sealed virtual object Unwrap();
    public sealed virtual T Unwrap();
    public sealed virtual bool TryUnwrap(T& result);
    [CompilerGeneratedAttribute]
public StringComparer get_Comparer();
    private object WrapIfIsSpecialCase(object original);
    private void CachePropertyInfos();
    private IPropertyOrField[] EnumerateUniqueDataMembers();
    private bool IsDictionaryTypeWithStringKeys(Type type);
    private void CacheDictionaryPropertyInfos();
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<string, object> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, object> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<string, object> item);
    public sealed virtual int get_Count();
    private int GetCount();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual void Add(string key, object value);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, Object& value);
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    private void WriteProperty(string key, object value);
    private object ReadProperty(string key);
    private object ReadObjectProperty(string key);
    private object ReadWrappedProperty(string key);
    private object FindOrCreateWrapperFor(object rawValue);
    [IteratorStateMachineAttribute("PeanutButter.Utils.Dictionaries.DictionaryWrappingObject/<LazilyEnumerate>d__51")]
private IEnumerable`1<IDictionary`2<string, object>> LazilyEnumerate(IEnumerable`1<object> objects);
    private void VerifyHasKey(string key);
    private bool HasKey(string key);
    private bool HasName(IPropertyOrField prop, string key);
    private bool KeysMatch(string key1, string key2);
    public sealed virtual ICollection`1<string> get_Keys();
    private ICollection`1<string> GetKeys();
    public sealed virtual ICollection`1<object> get_Values();
    private ICollection`1<object> GetValues();
    private Object[] GetPropertyAndFieldValues();
    [CompilerGeneratedAttribute]
private IPropertyOrField[] <EnumerateUniqueDataMembers>b__20_0();
    [CompilerGeneratedAttribute]
private DictionaryWrappingObject <FindOrCreateWrapperFor>g__WrapAndCache|50_0(<>c__DisplayClass50_0& );
    [CompilerGeneratedAttribute]
private object <GetPropertyAndFieldValues>b__68_0(IPropertyOrField p);
}
internal class PeanutButter.Utils.Dictionaries.DictionaryWrappingObjectEnumerator : object {
    private DictionaryWrappingObject _dict;
    private int _index;
    private String[] _keys;
    public KeyValuePair`2<string, object> Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public DictionaryWrappingObjectEnumerator(DictionaryWrappingObject dict);
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual KeyValuePair`2<string, object> get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
internal class PeanutButter.Utils.Dictionaries.FakeProperty : object {
    private Func`2<object, object> _valueGetter;
    private Action`2<object, object> _valueSetter;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanRead>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <HostingType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AncestralDistance>k__BackingField;
    public string Name { get; }
    public Type Type { get; }
    public bool CanWrite { get; }
    public bool CanRead { get; }
    public Type DeclaringType { get; }
    public Type HostingType { get; }
    public int AncestralDistance { get; }
    public FakeProperty(string name, Type type, bool canWrite, bool canRead, Type declaringType, Func`2<object, object> valueGetter, Action`2<object, object> valueSetter);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanWrite();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanRead();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_DeclaringType();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_HostingType();
    [CompilerGeneratedAttribute]
public sealed virtual int get_AncestralDistance();
    public sealed virtual object GetValue(object host);
    public sealed virtual bool TryGetValue(object host, Object& value, Exception& exception);
    public sealed virtual void SetValue(object host, object value);
    public sealed virtual void SetValue(T& host, object value);
    public sealed virtual void SetValueAt(object host, object value, object index);
    public sealed virtual object GetValueAt(object host, object index);
}
internal class PeanutButter.Utils.Dictionaries.GenericDictionaryEnumerator`2 : object {
    private IDictionary`2[] _layers;
    private int _currentIndex;
    private IEnumerator`1<KeyValuePair`2<TKey, TValue>> _currentEnumerator;
    private HashSet`1<TKey> _seen;
    private object System.Collections.IEnumerator.Current { get; }
    public KeyValuePair`2<TKey, TValue> Current { get; }
    public GenericDictionaryEnumerator`2(IDictionary`2[] layers);
    public sealed virtual bool MoveNext();
    private bool SelectNext();
    private bool MoveCurrentNext();
    public sealed virtual void Reset();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private void Select(int index);
    public sealed virtual KeyValuePair`2<TKey, TValue> get_Current();
    public sealed virtual void Dispose();
}
internal interface PeanutButter.Utils.Dictionaries.IOrderedDictionary`2 {
}
public interface PeanutButter.Utils.Dictionaries.IWrapper {
    public abstract virtual object Unwrap();
    public abstract virtual T Unwrap();
    public abstract virtual bool TryUnwrap(T& result);
}
[DefaultMemberAttribute("Item")]
public class PeanutButter.Utils.Dictionaries.MergeDictionary`2 : object {
    private static InvalidOperationException ReadonlyException;
    private List`1<IDictionary`2<TKey, TValue>> _layers;
    private static Dictionary`2<IEqualityComparer`1<string>, int> StringComparerRankings;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public int LayerCount { get; }
    public MergeDictionary`2(IDictionary`2[] layers);
    private static MergeDictionary`2();
    public IEqualityComparer`1<TKey> get_Comparer();
    private IEqualityComparer`1<TKey> GetComparer();
    private IEqualityComparer`1<string> FindLeastRestrictiveStringComparer();
    private static object GetPropertyValue(object src, string propertyPath);
    private static object GetImmediatePropertyValue(object src, string propertyName);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public void AppendLayer(IDictionary`2<TKey, TValue> layer);
    public void InsertLayer(IDictionary`2<TKey, TValue> layer);
    public void InsertLayer(int idx, IDictionary`2<TKey, TValue> layer);
    public int get_LayerCount();
    [CompilerGeneratedAttribute]
private TValue <get_Values>b__31_0(TKey k);
}
public enum PeanutButter.Utils.Dictionaries.Mutation : Enum {
    public int value__;
    public static Mutation Create;
    public static Mutation Update;
    public static Mutation Remove;
    public static Mutation Clear;
}
[DefaultMemberAttribute("Item")]
[ObsoleteAttribute("OrderedDictionary is incomplete: there is no guarantee of key order yet")]
internal class PeanutButter.Utils.Dictionaries.OrderedDictionary`2 : object {
    private Dictionary`2<TKey, TValue> _actual;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    private bool AreEqual(TValue left, TValue right);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
}
[DefaultMemberAttribute("Item")]
public class PeanutButter.Utils.Dictionaries.RedirectingDictionary`1 : object {
    private IDictionary`2<string, TValue> _data;
    private Func`2<string, string> _toNativeTransform;
    private Func`2<string, string> _fromNativeTransform;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TValue Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public RedirectingDictionary`1(IDictionary`2<string, TValue> data, Func`2<string, string> toNativeTransform, Func`2<string, string> fromNativeTransform);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<string, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<string, TValue> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual void Add(string key, TValue value);
    public sealed virtual bool Remove(string key);
    private bool RemoveNative(string nativeKey);
    public sealed virtual bool TryGetValue(string key, TValue& value);
    public sealed virtual TValue get_Item(string key);
    public sealed virtual void set_Item(string key, TValue value);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    [CompilerGeneratedAttribute]
private string <get_Keys>b__24_0(string k);
}
internal class PeanutButter.Utils.Dictionaries.RedirectingDictionaryEnumerator`1 : object {
    private IDictionary`2<string, T> _data;
    private Func`2<string, string> _keyTransform;
    private String[] _nativeKeys;
    private int _currentIndex;
    public KeyValuePair`2<string, T> Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal RedirectingDictionaryEnumerator`1(IDictionary`2<string, T> data, Func`2<string, string> keyTransform);
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual KeyValuePair`2<string, T> get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
[DefaultMemberAttribute("Item")]
public class PeanutButter.Utils.Dictionaries.TransformingDictionary`2 : object {
    private Func`2<KeyValuePair`2<TKey, TValue>, TValue> _mutator;
    private IDictionary`2<TKey, TValue> _underlyingData;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TransformingDictionary`2(Func`2<KeyValuePair`2<TKey, TValue>, TValue> mutator, IDictionary`2<TKey, TValue> underlyingData);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
}
[DefaultMemberAttribute("Item")]
public class PeanutButter.Utils.Dictionaries.ValidatingDictionary`2 : object {
    private Dictionary`2<TKey, TValue> _actual;
    private Action`4<IDictionary`2<TKey, TValue>, TKey, TValue, Mutation> _validator;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public ValidatingDictionary`2(Action`4<IDictionary`2<TKey, TValue>, TKey, TValue, Mutation> validator);
    public ValidatingDictionary`2(Action`4<IDictionary`2<TKey, TValue>, TKey, TValue, Mutation> validator, IEqualityComparer`1<TKey> equalityComparer);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    private void IfValidThen(TKey key, TValue value, Mutation mutation, Action runIfValid);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    [CompilerGeneratedAttribute]
private void <Clear>b__7_0();
}
internal class PeanutButter.Utils.Dictionaries.ValueMutatingEnumerator`2 : object {
    private Func`2<KeyValuePair`2<TKey, TValue>, TValue> _mutator;
    private IEnumerator`1<KeyValuePair`2<TKey, TValue>> _underlyingDataEnumerator;
    public KeyValuePair`2<TKey, TValue> Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public ValueMutatingEnumerator`2(Func`2<KeyValuePair`2<TKey, TValue>, TValue> mutator, IDictionary`2<TKey, TValue> underlyingData);
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual KeyValuePair`2<TKey, TValue> get_Current();
    private KeyValuePair`2<TKey, TValue> GenerateMutationForCurrentValue();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
[FlagsAttribute]
public enum PeanutButter.Utils.Dictionaries.WrapOptions : Enum {
    public int value__;
    public static WrapOptions None;
    public static WrapOptions WrapRecursively;
    public static WrapOptions ForceWrappingDictionariesWithoutStringKeys;
    public static WrapOptions CopyOnWrite;
}
[ExtensionAttribute]
public static class PeanutButter.Utils.DictionaryExtensions : object {
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> ToDictionary(IDictionary dict, Func`2<DictionaryEntry, TKey> keyGenerator, Func`2<DictionaryEntry, TValue> valueGenerator);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> ToDictionary(IDictionary dict);
    [ExtensionAttribute]
public static IDictionary`2<string, string> ToDictionary(NameValueCollection nameValueCollection);
    [ExtensionAttribute]
public static IDictionary`2<string, string> ToDictionary(IEnumerable`1<KeyValuePair`2<T1, T2>> src);
    [ExtensionAttribute]
public static IDictionary`2<string, string> ToDictionary(IEnumerable`1<KeyValuePair`2<T1, T2>> src, Func`2<T1, string> keyConverter, Func`2<T2, string> valueConverter);
    [ExtensionAttribute]
public static IDictionary`2<string, string> ToDictionary(IDictionary dict);
    [ExtensionAttribute]
public static TValue FindOrAdd(IDictionary`2<TKey, TValue> dict, TKey key, TValue value);
    [ExtensionAttribute]
public static TValue FindOrAdd(IDictionary`2<TKey, TValue> dict, TKey key, Func`1<TValue> generator);
    [ExtensionAttribute]
public static TValue FindOrAdd(IDictionary`2<TKey, TValue> dict, TKey key, Func`1<TValue> generator, Func`2<TValue, bool> skipCaching);
    [ExtensionAttribute]
public static TValue FindOrAdd(IDictionary`2<TKey, TValue> dict, TKey key, Func`1<TValue> generator, bool alwaysLock);
    [ExtensionAttribute]
public static TValue FindOrAdd(IDictionary`2<TKey, TValue> dict, TKey key, Func`1<TValue> generator, Func`2<TValue, bool> skipCaching, bool alwaysLock);
    private static TValue FindOrAddLocked(IDictionary`2<TKey, TValue> dict, TKey key, Func`1<TValue> generator, Func`2<TValue, bool> skipCaching);
    private static TValue FindOrAddUnlocked(TKey key, Func`1<TValue> generator, Func`2<TValue, bool> skipCaching, ConcurrentDictionary`2<TKey, TValue> concurrentDictionary);
    private static void ValidateFindOrAddParameters(IDictionary`2<TKey, TValue> dict, TKey key, Func`1<TValue> generator);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> Clone(IDictionary`2<TKey, TValue> dict);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> MergedWith(IDictionary`2<TKey, TValue> first, IDictionary`2<TKey, TValue> second);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> MergedWith(IDictionary`2<TKey, TValue> first, IDictionary`2<TKey, TValue> second, MergeWithPrecedence withPrecedence);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> MergeInto(IDictionary`2<TKey, TValue> newData, IDictionary`2<TKey, TValue> target);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> MergeInto(IDictionary`2<TKey, TValue> newData, IDictionary`2<TKey, TValue> target, MergeIntoPrecedence mergePrecedence);
    private static IDictionary`2<TKey, TValue> MergeWithOriginalRetention(IDictionary`2<TKey, TValue> newData, IDictionary`2<TKey, TValue> target);
    private static IDictionary`2<TKey, TValue> MergeWithOverwrite(IDictionary`2<TKey, TValue> newData, IDictionary`2<TKey, TValue> target);
    [ExtensionAttribute]
public static IDictionary`2<string, string> ToDictionary(NameValueCollection collection, IEqualityComparer`1<string> keyComparer);
    [ExtensionAttribute]
public static NameValueCollection ToNameValueCollection(IDictionary`2<string, string> dict);
    [ExtensionAttribute]
public static bool TryAdd(IDictionary`2<TKey, TValue> subject, TKey key, TValue value);
}
public class PeanutButter.Utils.DisposableWrapper : object {
    private IDisposable _disposable;
    [CompilerGeneratedAttribute]
private DisposableWrapperEventHandler <BeforeDisposing>k__BackingField;
    [CompilerGeneratedAttribute]
private DisposableWrapperEventHandler <AfterDisposing>k__BackingField;
    [CompilerGeneratedAttribute]
private DisposableWrapperErrorEventHandler <OnDisposingError>k__BackingField;
    public DisposableWrapperEventHandler BeforeDisposing { get; public set; }
    public DisposableWrapperEventHandler AfterDisposing { get; public set; }
    public DisposableWrapperErrorEventHandler OnDisposingError { get; public set; }
    public DisposableWrapper(IDisposable disposable);
    [CompilerGeneratedAttribute]
public DisposableWrapperEventHandler get_BeforeDisposing();
    [CompilerGeneratedAttribute]
public void set_BeforeDisposing(DisposableWrapperEventHandler value);
    [CompilerGeneratedAttribute]
public DisposableWrapperEventHandler get_AfterDisposing();
    [CompilerGeneratedAttribute]
public void set_AfterDisposing(DisposableWrapperEventHandler value);
    [CompilerGeneratedAttribute]
public DisposableWrapperErrorEventHandler get_OnDisposingError();
    [CompilerGeneratedAttribute]
public void set_OnDisposingError(DisposableWrapperErrorEventHandler value);
    public sealed virtual void Dispose();
    private void TryRaiseExceptionHandlersFor(Exception exception);
    private void TryRaise(DisposableWrapperEventHandler handler, string eventName);
    private void TryRun(Action action);
}
public class PeanutButter.Utils.DisposableWrapperErrorEventArgs : DisposableWrapperEventArgs {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public Exception Exception { get; }
    internal DisposableWrapperErrorEventArgs(string eventName, IDisposable disposable, Exception exception);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
}
public class PeanutButter.Utils.DisposableWrapperErrorEventHandler : MulticastDelegate {
    public DisposableWrapperErrorEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DisposableWrapperErrorEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, DisposableWrapperErrorEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class PeanutButter.Utils.DisposableWrapperEventArgs : object {
    [CompilerGeneratedAttribute]
private string <EventName>k__BackingField;
    [CompilerGeneratedAttribute]
private IDisposable <Disposable>k__BackingField;
    public string EventName { get; }
    public IDisposable Disposable { get; }
    internal DisposableWrapperEventArgs(string eventName, IDisposable disposable);
    [CompilerGeneratedAttribute]
public string get_EventName();
    [CompilerGeneratedAttribute]
public IDisposable get_Disposable();
}
public class PeanutButter.Utils.DisposableWrapperEventHandler : MulticastDelegate {
    public DisposableWrapperEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DisposableWrapperEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, DisposableWrapperEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class PeanutButter.Utils.ElementNotFoundException : Exception {
    public ElementNotFoundException(IEnumerable source, int skip, Type seeking, object predicate);
}
internal class PeanutButter.Utils.EmptyEnumerator`1 : object {
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
}
public class PeanutButter.Utils.EnumerableWrapper : object {
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    private object _toWrap;
    private static BindingFlags PublicInstance;
    private static Type EnumeratorType;
    private static PropertyInfo[] EnumeratorProps;
    private static MethodInfo[] RequiredEnumeratorMethods;
    public bool IsValid { get; }
    public EnumerableWrapper(object toWrap);
    private static EnumerableWrapper();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsValid();
    public sealed virtual IEnumerator GetEnumerator();
    protected IEnumerator`1<T> MakeEnumerator();
    private bool IsEnumeratorType(Type returnType);
    private bool MethodsAreAtLeast(MethodInfo[] required, MethodInfo[] test);
    private bool MethodsMatch(MethodInfo left, MethodInfo right);
    private bool PropsAreAtLeast(PropertyInfo[] required, PropertyInfo[] test);
    private bool PropsMatch(PropertyInfo left, PropertyInfo right);
}
public class PeanutButter.Utils.EnumerableWrapper`1 : EnumerableWrapper {
    public EnumerableWrapper`1(object toWrap);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
}
public class PeanutButter.Utils.EnumeratorWrapper`1 : object {
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    private PropertyInfo _currentPropInfo;
    private MethodInfo _moveNextMethod;
    private MethodInfo _resetMethod;
    private object _wrapped;
    private MethodInfo _getEnumeratorMethod;
    private static Object[] NO_ARGS;
    private static BindingFlags PublicInstance;
    public bool IsValid { get; private set; }
    private object System.Collections.IEnumerator.Current { get; }
    public T Current { get; }
    public EnumeratorWrapper`1(object toWrap);
    private static EnumeratorWrapper`1();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsValid();
    [CompilerGeneratedAttribute]
private void set_IsValid(bool value);
    private void ValidateEnumeratorResult();
    private void GrabEnumeratorReturnMembers();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual T get_Current();
    private T TryConvert(object getValue);
    public sealed virtual void Dispose();
}
public static class PeanutButter.Utils.Env : object {
    private static HashSet`1<string> TruthyValues;
    private static HashSet`1<string> FalseyValues;
    private static Env();
    public static string String(string envVar, string fallback);
    public static int Integer(string envVar, int fallback, Nullable`1<int> min, Nullable`1<int> max);
    public static decimal Decimal(string envVar, decimal fallback, Nullable`1<decimal> min, Nullable`1<decimal> max);
    public static bool Flag(string envVar, bool fallback);
}
public enum PeanutButter.Utils.Eol : Enum {
    public int value__;
    public static Eol Lf;
    public static Eol CrLf;
}
public enum PeanutButter.Utils.ErrorHandlerResult : Enum {
    public int value__;
    public static ErrorHandlerResult NoError;
    public static ErrorHandlerResult Rethrow;
    public static ErrorHandlerResult Suppress;
}
public enum PeanutButter.Utils.ErrorStrategies : Enum {
    public int value__;
    public static ErrorStrategies Throw;
    public static ErrorStrategies Suppress;
}
public enum PeanutButter.Utils.ExceptionHandlingStrategies : Enum {
    public int value__;
    public static ExceptionHandlingStrategies Throw;
    public static ExceptionHandlingStrategies Suppress;
}
internal class PeanutButter.Utils.ExclusiveSynchronizationContext : SynchronizationContext {
    private bool _done;
    [CompilerGeneratedAttribute]
private Exception <InnerException>k__BackingField;
    private AutoResetEvent _workItemsWaiting;
    private Queue`1<Tuple`2<SendOrPostCallback, object>> _items;
    public Exception InnerException { get; public set; }
    [CompilerGeneratedAttribute]
public Exception get_InnerException();
    [CompilerGeneratedAttribute]
public void set_InnerException(Exception value);
    public virtual void Send(SendOrPostCallback d, object state);
    public virtual void Post(SendOrPostCallback d, object state);
    public void EndMessageLoop();
    public void BeginMessageLoop();
    public virtual SynchronizationContext CreateCopy();
    [CompilerGeneratedAttribute]
private void <EndMessageLoop>b__9_0(object _);
}
internal abstract class PeanutButter.Utils.Experimental.Message : object {
    public string Type { get; public set; }
    public object PayloadObject { get; }
    public abstract virtual string get_Type();
    public abstract virtual void set_Type(string value);
    public abstract virtual object get_PayloadObject();
    public static Message`1<T> For(T data);
}
internal class PeanutButter.Utils.Experimental.Message`1 : Message {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Payload>k__BackingField;
    public string Type { get; public set; }
    public T Payload { get; public set; }
    public object PayloadObject { get; }
    public Message`1(T payload);
    [CompilerGeneratedAttribute]
public virtual string get_Type();
    [CompilerGeneratedAttribute]
public virtual void set_Type(string value);
    [CompilerGeneratedAttribute]
public T get_Payload();
    [CompilerGeneratedAttribute]
public void set_Payload(T value);
    public virtual object get_PayloadObject();
}
[ObsoleteAttribute("This is not ready for prime-time yet")]
internal class PeanutButter.Utils.Experimental.UdpIpc : object {
    [CompilerGeneratedAttribute]
private Receiver <Receivers>k__BackingField;
    private int _startPort;
    private int _port;
    private UdpClient _client;
    private IAsyncResult _asyncReceivedResult;
    public Receiver Receivers { get; public set; }
    public UdpIpc(string identifier);
    [CompilerGeneratedAttribute]
public Receiver get_Receivers();
    [CompilerGeneratedAttribute]
public void set_Receivers(Receiver value);
    private void TryStart();
    private static int GeneratePortFor(string identifier);
    private void Stop();
    private void Receive(IAsyncResult ar);
    public void Send(string message);
    public sealed virtual void Dispose();
}
public static class PeanutButter.Utils.ExpressionUtil : object {
    public static string GetMemberPathFor(Expression`1<Func`2<TSource, object>> expression);
    public static Type GetPropertyTypeFor(Expression`1<Func`2<TSource, object>> expression);
    public static string GetFullPropertyPathNameFrom(MemberExpression expression);
}
[ExtensionAttribute]
public static class PeanutButter.Utils.ExtensionsForIEnumerables : object {
    private static string DEFAULT_LIST_ITEM_MARKER;
    private static string DEFAULT_EMPTY_LIST_TEXT;
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> collection, Action`1<T> toRun);
    [ExtensionAttribute]
public static void JoinAll(IEnumerable`1<Thread> threads);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> collection, Action`2<T, int> toRunWithIndex);
    [ExtensionAttribute]
public static T FindOrAdd(ICollection`1<T> collection, T seek);
    [ExtensionAttribute]
public static T FindOrAdd(ICollection`1<T> collection, Func`2<T, bool> matcher);
    [ExtensionAttribute]
public static T FindOrAdd(ICollection`1<T> collection, Func`2<T, bool> matcher, Func`1<T> generator);
    [ExtensionAttribute]
[ObsoleteAttribute("This redirects to IsEquivalentTo and will be removed at some point")]
public static bool IsSameAs(IEnumerable`1<T> collection, IEnumerable`1<T> otherCollection);
    [ExtensionAttribute]
public static string JoinWith(IEnumerable`1<T> collection, string joinWith);
    [ExtensionAttribute]
public static bool IsEmpty(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static IEnumerable`1<T> EmptyIfNull(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static T[] And(IEnumerable`1<T> source, T[] values);
    [ExtensionAttribute]
public static T[] And(IEnumerable`1<T> source, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static T[] And(T[] source, T[] values);
    [ExtensionAttribute]
public static T[] And(T[] source, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static List`1<T> And(List`1<T> source, T[] values);
    [ExtensionAttribute]
public static IList`1<T> And(IList`1<T> source, T[] values);
    [ExtensionAttribute]
public static T[] ButNot(IEnumerable`1<T> source, T[] toRemove);
    [ExtensionAttribute]
public static IEnumerable`1<T> Flatten(IEnumerable`1<IEnumerable`1<T>> collection);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> SelectNonNull(IEnumerable`1<TCollection> collection, Func`2<TCollection, Nullable`1<TResult>> grabber);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> SelectNonNull(IEnumerable`1<TCollection> collection, Func`2<TCollection, TResult> grabber);
    [ExtensionAttribute]
public static string AsText(IEnumerable`1<T> input, string delimiter);
    [ExtensionAttribute]
public static string AsTextList(IEnumerable`1<T> input);
    [ExtensionAttribute]
public static string AsTextList(IEnumerable`1<T> input, string itemMarker);
    [ExtensionAttribute]
public static string AsTextList(IEnumerable`1<T> input, string itemMarker, string whenEmpty);
    [ExtensionAttribute]
public static string AsTextListWithHeader(IEnumerable`1<T> input, string header);
    [ExtensionAttribute]
public static string AsTextListWithHeader(IEnumerable`1<T> input, string header, string itemMarker);
    [ExtensionAttribute]
public static string AsTextListWithHeader(IEnumerable`1<T> input, string header, string itemMarker, string whenEmpty);
    [ExtensionAttribute]
public static bool HasUnique(IEnumerable`1<T> input, Func`2<T, bool> matcher);
    [ExtensionAttribute]
public static void TimesDo(int howMany, Action toRun);
    [ExtensionAttribute]
public static void TimesDo(int howMany, Action`1<int> toRun);
    [ExtensionAttribute]
public static T Second(IEnumerable`1<T> src);
    [ExtensionAttribute]
public static T Third(IEnumerable`1<T> src);
    [ExtensionAttribute]
public static T Fourth(IEnumerable`1<T> src);
    [ExtensionAttribute]
public static T Nth(IEnumerable`1<T> src, int n);
    [ExtensionAttribute]
public static T At(IEnumerable`1<T> src, int n);
    [ExtensionAttribute]
public static T FirstAfter(IEnumerable`1<T> src, int toSkip);
    [ExtensionAttribute]
public static T FirstOrDefaultAfter(IEnumerable`1<T> src, int toSkip);
    [ExtensionAttribute]
public static IEnumerable`1<TItem> FindDuplicates(IEnumerable`1<TItem> src);
    [ExtensionAttribute]
public static IEnumerable`1<DuplicateResult`2<TKey, TItem>> FindDuplicates(IEnumerable`1<TItem> src, Func`2<TItem, TKey> discriminator);
    [ExtensionAttribute]
public static bool None(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static bool None(IEnumerable`1<T> collection, Func`2<T, bool> test);
    [ExtensionAttribute]
public static T[] AsArray(IEnumerable`1<T> collection);
    [IteratorStateMachineAttribute("PeanutButter.Utils.ExtensionsForIEnumerables/<ImplicitCast>d__45`1")]
[ExtensionAttribute]
public static IEnumerable`1<TOther> ImplicitCast(IEnumerable collection);
    [ExtensionAttribute]
public static IEnumerable`1<Tuple`2<TLeft, TRight>> StrictZip(IEnumerable`1<TLeft> left, IEnumerable`1<TRight> right);
    [IteratorStateMachineAttribute("PeanutButter.Utils.ExtensionsForIEnumerables/<StrictZip>d__47`3")]
[ExtensionAttribute]
public static IEnumerable`1<TResult> StrictZip(IEnumerable`1<TLeft> left, IEnumerable`1<TRight> right, Func`3<TLeft, TRight, TResult> generator);
    [ExtensionAttribute]
public static bool Matches(IEnumerable`1<T> left, IEnumerable`1<T> right);
    [ExtensionAttribute]
public static bool Matches(IEnumerable`1<T> left, IEnumerable`1<T> right, Func`3<T, T, bool> comparer);
    [ExtensionAttribute]
public static bool CrossMatches(IEnumerable`1<TLeft> left, IEnumerable`1<TRight> right, Func`3<TLeft, TRight, bool> comparer);
    [IteratorStateMachineAttribute("PeanutButter.Utils.ExtensionsForIEnumerables/<Trim>d__51")]
[ExtensionAttribute]
public static IEnumerable`1<string> Trim(IEnumerable`1<string> source);
    [IteratorStateMachineAttribute("PeanutButter.Utils.ExtensionsForIEnumerables/<TrimStart>d__52")]
[ExtensionAttribute]
public static IEnumerable`1<string> TrimStart(IEnumerable`1<string> source);
    [IteratorStateMachineAttribute("PeanutButter.Utils.ExtensionsForIEnumerables/<TrimEnd>d__53")]
[ExtensionAttribute]
public static IEnumerable`1<string> TrimEnd(IEnumerable`1<string> source);
    [ExtensionAttribute]
public static IEnumerable`1<string> PadLeft(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<string> PadLeft(IEnumerable`1<T> source, char padWith);
    [ExtensionAttribute]
public static IEnumerable`1<string> PadLeft(IEnumerable`1<T> source, int requiredLength);
    [IteratorStateMachineAttribute("PeanutButter.Utils.ExtensionsForIEnumerables/<PadLeft>d__57`1")]
[ExtensionAttribute]
public static IEnumerable`1<string> PadLeft(IEnumerable`1<T> source, int requiredLength, char padWith);
    [ExtensionAttribute]
public static IEnumerable`1<string> PadRight(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<string> PadRight(IEnumerable`1<T> source, char padWith);
    [ExtensionAttribute]
public static IEnumerable`1<string> PadRight(IEnumerable`1<T> source, int requiredLength);
    [IteratorStateMachineAttribute("PeanutButter.Utils.ExtensionsForIEnumerables/<PadRight>d__61`1")]
[ExtensionAttribute]
public static IEnumerable`1<string> PadRight(IEnumerable`1<T> source, int requiredLength, char padWith);
    [ExtensionAttribute]
public static bool IsEqualTo(IEnumerable`1<T> left, IEnumerable`1<T> right);
    [ExtensionAttribute]
public static bool IsEquivalentTo(IEnumerable`1<T> left, IEnumerable`1<T> right);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(IEnumerable`1<T> collection);
    [ExtensionAttribute]
[ObsoleteAttribute("Conflicts with latest System.Linq - use AsHashArray instead")]
public static HashSet`1<T> ToHashSet(IEnumerable`1<T> collection);
    private static void IncrementCount(Dictionary`2<T, int> counts, T value);
    private static bool Compare(T1 leftValue, T2 rightValue);
    [ExtensionAttribute]
public static TResult[] Map(IEnumerable`1<TSource> collection, Func`2<TSource, TResult> transform);
    [ExtensionAttribute]
public static IList`1<TResult> MapList(IEnumerable`1<TSource> collection, Func`2<TSource, TResult> transform);
    [ExtensionAttribute]
public static T[] Filter(IEnumerable`1<T> collection, Func`2<T, bool> filter);
    [ExtensionAttribute]
public static IList`1<T> FilterList(IEnumerable`1<T> collection, Func`2<T, bool> filter);
    [IteratorStateMachineAttribute("PeanutButter.Utils.ExtensionsForIEnumerables/<FindRepeatedValues>d__72`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> FindRepeatedValues(IEnumerable`1<T> collection);
    [IteratorStateMachineAttribute("PeanutButter.Utils.ExtensionsForIEnumerables/<FindAllRepeatedValues>d__73`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> FindAllRepeatedValues(IEnumerable`1<T> collection);
    [IteratorStateMachineAttribute("PeanutButter.Utils.ExtensionsForIEnumerables/<FindUniqueValues>d__74`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> FindUniqueValues(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static string JoinPath(IEnumerable`1<string> parts);
    [ExtensionAttribute]
public static string JoinPath(IEnumerable`1<string> parts, PathType pathType);
    [ExtensionAttribute]
public static T[] FilterNulls(Nullable`1[] collection);
    [IteratorStateMachineAttribute("PeanutButter.Utils.ExtensionsForIEnumerables/<FilterNulls>d__78`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> FilterNulls(IEnumerable`1<Nullable`1<T>> collection);
    [ExtensionAttribute]
public static T[] FilterNulls(T[] collection);
    [IteratorStateMachineAttribute("PeanutButter.Utils.ExtensionsForIEnumerables/<FilterNulls>d__80`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> FilterNulls(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static bool IsIn(T needle, T haystack, T[] moreHaystack);
    [ExtensionAttribute]
public static bool IsIn(T needle, IEnumerable`1<T> haystack);
    [ExtensionAttribute]
public static bool IsIn(T needle, IEnumerable`1<T> haystack, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
public static TCollection AddRange(TCollection collection, IEnumerable`1<TItem> toAdd);
    [ExtensionAttribute]
public static TCollection AddRange(TCollection collection, TItem[] items);
    private static void AddAllItems(TCollection collection, IEnumerable`1<TItem> items);
    [ExtensionAttribute]
public static T Seek(IEnumerable data);
    [ExtensionAttribute]
public static T Seek(IEnumerable data, int skip);
    [ExtensionAttribute]
public static T Seek(IEnumerable data, int skip, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T Seek(IEnumerable data, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T SeekOrDefault(IEnumerable data);
    [ExtensionAttribute]
public static T SeekOrDefault(IEnumerable data, int skip);
    [ExtensionAttribute]
public static T SeekOrDefault(IEnumerable data, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T SeekOrDefault(IEnumerable data, int skip, Func`2<T, bool> predicate);
    [CompilerGeneratedAttribute]
internal static MethodInfo <ImplicitCast>g__ResolveImplicitOperator|45_0(Type inputType, <>c__DisplayClass45_0`1& );
    [CompilerGeneratedAttribute]
internal static bool <IsIn>g__NeedleIsEqualToHaystackSingle|81_0(<>c__DisplayClass81_0`1& );
}
public class PeanutButter.Utils.FilePathResolver : object {
    [IteratorStateMachineAttribute("PeanutButter.Utils.FilePathResolver/<Resolve>d__0")]
public sealed virtual IEnumerable`1<string> Resolve(String[] patterns);
    [IteratorStateMachineAttribute("PeanutButter.Utils.FilePathResolver/<SearchWithFilter>d__1")]
private IEnumerable`1<string> SearchWithFilter(String[] pathParts);
    [IteratorStateMachineAttribute("PeanutButter.Utils.FilePathResolver/<ListDir>d__2")]
private IEnumerable`1<string> ListDir(string item, string searchPattern, bool recurse);
}
public static class PeanutButter.Utils.Find : object {
    private static string PathItemSeparator;
    private static string _environmentPath;
    private static String[] _cachedPathFolders;
    public static String[] FoldersInPath { get; }
    private static Find();
    public static String[] get_FoldersInPath();
    private static String[] FindFoldersInPath();
    public static string InPath(string search);
    private static string ValidateExecutable(string filePath);
    private static String[] GenerateWindowsExecutableExtensionsList();
    private static string SearchFor(string search, string inFolder, IEnumerable`1<string> withExecutableExtensions);
}
[ExtensionAttribute]
public static class PeanutButter.Utils.FlagExtensions : object {
    [ExtensionAttribute]
public static bool HasFlag(T enumValue, T flag);
    [ExtensionAttribute]
public static bool HasFlags(T value, T flag1, T flag2, T[] moreFlags);
    [ExtensionAttribute]
public static bool HasFlags(int value, int flag1, int flag2, Int32[] moreFlags);
    [ExtensionAttribute]
public static bool HasFlags(int value, IEnumerable`1<int> flags);
    [ExtensionAttribute]
public static T WithFlag(T enumValue, T flag);
    [ExtensionAttribute]
public static int WithFlag(int value, int flag);
    [ExtensionAttribute]
public static T WithoutFlag(T enumValue, T flag);
    [ExtensionAttribute]
public static int WithoutFlag(int value, int flag);
    private static bool ConvertToInt(T value, Int32& result);
    [ExtensionAttribute]
public static bool HasFlag(int value, int flag);
    private static bool IsEnum();
}
public class PeanutButter.Utils.FlexiConstructor : object {
    private static ConcurrentDictionary`2<Type, ConstructorInfo[]> ConstructorCache;
    private static FlexiConstructor();
    public static T Construct(Object[] args);
    public static T Construct(ConstructFlags flags, Object[] args);
    public static T Construct(Func`2<Type, object> fallbackFactory, Object[] args);
    public static T Construct(Func`2<Type, object> fallbackFactory, ConstructFlags flags, Object[] args);
    private static Object[] FindBestMatch(Func`2<Type, object> fallbackFactory, ConstructFlags flags, ConstructorInfo[] constructorInfos, Object[] args);
}
[ExtensionAttribute]
public static class PeanutButter.Utils.FluencyExtensions : object {
    [ExtensionAttribute]
public static T With(T subject, Action`1<T> mutator);
    [ExtensionAttribute]
public static IList`1<T> WithAll(IList`1<T> subject, Action`1<T> mutator);
    [ExtensionAttribute]
public static IEnumerable`1<T> WithAll(IEnumerable`1<T> subject, Action`1<T> mutator);
    [ExtensionAttribute]
public static T[] WithAll(T[] subject, Action`1<T> mutator);
    private static TCollection WithAllInternal(TCollection subject, Action`1<TItem> mutator);
}
internal static class PeanutButter.Utils.HttpEncoder : object {
    public static string UrlEncode(string str);
    public static string UrlEncode(string str, Encoding encoding);
    internal static Byte[] UrlEncode(Byte[] bytes, int offset, int count, bool alwaysCreateNewReturnValue);
    public static bool IsUrlSafeChar(char ch);
    private static Byte[] UrlEncode(Byte[] bytes, int offset, int count);
    public static char ToCharLower(int value);
    private static bool ValidateUrlEncodingParameters(Byte[] bytes, int offset, int count);
}
public interface PeanutButter.Utils.IAutoTempFolder {
    public string Path { get; }
    public int RetryOperations { get; public set; }
    public abstract virtual string get_Path();
    public abstract virtual int get_RetryOperations();
    public abstract virtual void set_RetryOperations(int value);
    public abstract virtual string ResolvePath(string p1, String[] more);
    public abstract virtual IEnumerable`1<string> ResolvePaths(IEnumerable`1<string> relativePaths);
    public abstract virtual string CreateFolder(string dirname);
    public abstract virtual string WriteFile(string filename, string data);
    public abstract virtual string WriteFile(string filename, Byte[] data);
    public abstract virtual string WriteFile(string filename, Stream data);
    public abstract virtual string ReadTextFile(string filename);
    public abstract virtual Byte[] ReadFile(string filename);
    public abstract virtual FileStream OpenFile(string filename);
    public abstract virtual FileStream OpenFile(string filename, FileAccess access);
    public abstract virtual FileStream OpenFile(string filename, FileAccess access, FileShare share);
    public abstract virtual FileStream OpenFile(string filename, FileAccess access, FileShare share, int bufferSize);
    public abstract virtual FileStream OpenFile(string filename, FileAccess access, FileShare share, int bufferSize, FileOptions options);
    public abstract virtual bool FileExists(string relativePath);
    public abstract virtual bool FolderExists(string relativePath);
    public abstract virtual bool Exists(string relativePath);
    public abstract virtual bool Contains(string fullPath);
}
public interface PeanutButter.Utils.IBackoffStrategy {
    public abstract virtual void Backoff(int attempt);
}
public interface PeanutButter.Utils.IBuilder`2 {
    public abstract virtual TEntity Build();
    public abstract virtual TBuilder WithProp(Action`1<TEntity> transform);
    public abstract virtual TBuilder WithProp(ActionRef`1<TEntity> transform);
}
public interface PeanutButter.Utils.ICircularList`1 {
    public int ItemCount { get; }
    public IEnumerable`1<T> Items { get; }
    public abstract virtual int get_ItemCount();
    public abstract virtual IEnumerable`1<T> get_Items();
}
public interface PeanutButter.Utils.IEnumerableWrapper {
    public bool IsValid { get; }
    public abstract virtual bool get_IsValid();
}
public interface PeanutButter.Utils.IFilePathResolver {
    public abstract virtual IEnumerable`1<string> Resolve(String[] patterns);
}
public interface PeanutButter.Utils.ILazyWithContext`1 {
    public TValue Value { get; }
    public abstract virtual TValue get_Value();
}
internal class PeanutButter.Utils.InfiniteEnumerator`1 : object {
    private IEnumerable`1<T> _collection;
    private IEnumerator`1<T> _currentEnumerator;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public InfiniteEnumerator`1(IEnumerable`1<T> collection);
    private void ResetCollectionEnumerator();
    public sealed virtual bool MoveNext();
    private bool ResetAndMoveNext();
    public sealed virtual void Reset();
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
}
public class PeanutButter.Utils.InvalidEnvironmentVariableValue : Exception {
    [CompilerGeneratedAttribute]
private string <EnvVar>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Why>k__BackingField;
    public string EnvVar { get; }
    public string Value { get; }
    public string Why { get; }
    public InvalidEnvironmentVariableValue(string envVar, string value, string why);
    [CompilerGeneratedAttribute]
public string get_EnvVar();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public string get_Why();
}
public interface PeanutButter.Utils.IParallelWorker {
    public abstract virtual void AddWorkers(IEnumerable`1<Action> workers);
    public abstract virtual void AddWorker(Action worker);
    public abstract virtual Exception[] RunAll();
    public abstract virtual Exception[] RunAll(int maxDegreeOfParallelism);
}
public interface PeanutButter.Utils.IParallelWorker`1 {
    public bool Busy { get; }
    public abstract virtual bool get_Busy();
    public abstract virtual void AddWorker(Func`1<T> worker);
    public abstract virtual void AddWorkers(IEnumerable`1<Func`1<T>> workers);
    public abstract virtual WorkResult`1[] RunAll();
    public abstract virtual WorkResult`1[] RunAll(int maxDegreeOfParallelism);
}
public interface PeanutButter.Utils.IPool`1 {
    public int MaxItems { get; }
    public int Count { get; }
    public abstract virtual int get_MaxItems();
    public abstract virtual int get_Count();
    [ObsoleteAttribute("This has been renamed to Borrow and will be removed in a future version")]
public abstract virtual IPoolItem`1<T> Take();
    [ObsoleteAttribute("This has been renamed to Borrow and will be removed in a future version")]
public abstract virtual IPoolItem`1<T> Take(int maxWaitMilliseconds);
    public abstract virtual IPoolItem`1<T> Borrow();
    public abstract virtual IPoolItem`1<T> Borrow(int maxWaitMilliseconds);
    public abstract virtual void Forget(IPoolItem`1<T> item);
    public abstract virtual void Dispose();
}
public interface PeanutButter.Utils.IPoolItem`1 {
    public T Instance { get; }
    public bool IsAvailable { get; }
    public abstract virtual T get_Instance();
    public abstract virtual bool get_IsAvailable();
    public abstract virtual bool TryLock(int maxWait);
}
public interface PeanutButter.Utils.IProcessIO {
    public int ProcessId { get; }
    public bool Started { get; }
    public Exception StartException { get; }
    public IEnumerable`1<string> StandardOutput { get; }
    public IEnumerable`1<string> StandardError { get; }
    public IEnumerable`1<string> StandardOutputAndErrorInterleaved { get; }
    public IEnumerable`1<string> StandardOutputSnapshot { get; }
    public IEnumerable`1<string> StandardErrorSnapshot { get; }
    public IEnumerable`1<string> StandardOutputAndErrorInterleavedSnapshot { get; }
    public int MaxBufferLines { get; public set; }
    public StreamWriter StandardInput { get; }
    public Process Process { get; }
    public int ExitCode { get; }
    public bool HasExited { get; }
    public string Filename { get; }
    public String[] Arguments { get; }
    public string WorkingDirectory { get; }
    public string Commandline { get; }
    public abstract virtual int get_ProcessId();
    public abstract virtual bool get_Started();
    public abstract virtual Exception get_StartException();
    public abstract virtual IEnumerable`1<string> get_StandardOutput();
    public abstract virtual IEnumerable`1<string> get_StandardError();
    public abstract virtual IEnumerable`1<string> get_StandardOutputAndErrorInterleaved();
    public abstract virtual IEnumerable`1<string> get_StandardOutputSnapshot();
    public abstract virtual IEnumerable`1<string> get_StandardErrorSnapshot();
    public abstract virtual IEnumerable`1<string> get_StandardOutputAndErrorInterleavedSnapshot();
    public abstract virtual int get_MaxBufferLines();
    public abstract virtual void set_MaxBufferLines(int value);
    public abstract virtual StreamWriter get_StandardInput();
    public abstract virtual Process get_Process();
    public abstract virtual int get_ExitCode();
    public abstract virtual bool get_HasExited();
    public abstract virtual string get_Filename();
    public abstract virtual String[] get_Arguments();
    public abstract virtual string get_WorkingDirectory();
    public abstract virtual string get_Commandline();
    public abstract virtual int WaitForExit();
    public abstract virtual Nullable`1<int> WaitForExit(int timeoutMilliseconds);
    public abstract virtual void Kill();
    public abstract virtual bool WaitForOutput(StandardIo io, Func`2<string, bool> matcher);
    public abstract virtual bool WaitForOutput(StandardIo io, Func`2<string, bool> matcher, int timeoutMilliseconds);
}
public interface PeanutButter.Utils.IPropertyOrField {
    public string Name { get; }
    public Type Type { get; }
    public bool CanWrite { get; }
    public bool CanRead { get; }
    public Type DeclaringType { get; }
    public Type HostingType { get; }
    public int AncestralDistance { get; }
    public abstract virtual string get_Name();
    public abstract virtual Type get_Type();
    public abstract virtual bool get_CanWrite();
    public abstract virtual bool get_CanRead();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual Type get_HostingType();
    public abstract virtual int get_AncestralDistance();
    public abstract virtual object GetValue(object host);
    public abstract virtual bool TryGetValue(object host, Object& value, Exception& exception);
    public abstract virtual void SetValue(object host, object value);
    public abstract virtual void SetValue(T& host, object value);
    public abstract virtual void SetValueAt(object host, object value, object index);
    public abstract virtual object GetValueAt(object host, object index);
}
[ObsoleteAttribute("Rather use ISlidingWindow - it has time and max-item limits")]
public interface PeanutButter.Utils.IRollingWindow`1 {
    public long MaxSize { get; public set; }
    public abstract virtual long get_MaxSize();
    public abstract virtual void set_MaxSize(long value);
    public abstract virtual void Add(T item);
}
public interface PeanutButter.Utils.ISingleItemCache`1 {
    public T Value { get; }
    public Func`1<T> Generator { get; }
    public TimeSpan TimeToLive { get; }
    public abstract virtual T get_Value();
    public abstract virtual Func`1<T> get_Generator();
    public abstract virtual TimeSpan get_TimeToLive();
    public abstract virtual void Invalidate();
}
public interface PeanutButter.Utils.ISlidingWindow`1 {
    public ISlidingWindowItem`1<T> First { get; }
    public ISlidingWindowItem`1<T> Last { get; }
    public TimeSpan MaxLifeSpan { get; }
    public abstract virtual ISlidingWindowItem`1<T> ItemAt(int index);
    public abstract virtual ISlidingWindowItem`1<T> get_First();
    public abstract virtual ISlidingWindowItem`1<T> get_Last();
    public abstract virtual TimeSpan get_MaxLifeSpan();
    public abstract virtual void Trim();
}
public interface PeanutButter.Utils.ISlidingWindowItem`1 {
    public T Value { get; }
    public DateTime Created { get; }
    public abstract virtual T get_Value();
    public abstract virtual DateTime get_Created();
}
public interface PeanutButter.Utils.ITextStatusSteps {
    public abstract virtual void Run(string label, Action activity);
    public abstract virtual Task RunAsync(string label, Func`1<Task> activity);
    public abstract virtual void Log(string str);
    public abstract virtual Task LogAsync(string str);
}
public interface PeanutButter.Utils.IUnstartedProcessIO {
    public abstract virtual IProcessIO Start(string filename, String[] arguments);
    public abstract virtual IUnstartedProcessIO WithEnvironmentVariable(string name, string value);
    public abstract virtual IUnstartedProcessIO In(string workingDirectory);
    public abstract virtual IUnstartedProcessIO WithEnvironment(IDictionary`2<string, string> env);
}
public interface PeanutButter.Utils.IWorker {
    public bool Busy { get; }
    public int DefaultMaxDegreeOfParallelism { get; public set; }
    public abstract virtual bool get_Busy();
    public abstract virtual int get_DefaultMaxDegreeOfParallelism();
    public abstract virtual void set_DefaultMaxDegreeOfParallelism(int value);
}
[ExtensionAttribute]
public static class PeanutButter.Utils.KeyValueCollectionExtensions : object {
    [ExtensionAttribute]
public static KeyValuePair`2<string, object> AsKeyValuePairOfStringObject(KeyValuePair`2<string, string> src);
}
public class PeanutButter.Utils.LazyWithContext`2 : object {
    private TContext _context;
    private TValue _cached;
    private bool _evaluated;
    private SemaphoreSlim _lock;
    private Func`2<TContext, TValue> _synchronousValueFactory;
    private Func`2<TContext, Task`1<TValue>> _asyncValueFactory;
    public TValue Value { get; }
    public LazyWithContext`2(TContext context, Func`2<TContext, TValue> valueFactory);
    public LazyWithContext`2(TContext context, Func`2<TContext, Task`1<TValue>> valueFactory);
    public sealed virtual TValue get_Value();
    private TValue ResolveValue();
    private TValue ResolveValueAsync();
    private TValue ResolveValueSync();
}
[ExtensionAttribute]
public static class PeanutButter.Utils.ListExtensions : object {
    [ExtensionAttribute]
public static T Shift(IList`1<T> list);
    [ExtensionAttribute]
public static T Pop(IList`1<T> list);
    [ExtensionAttribute]
public static bool TryPop(IList`1<T> list, T& result);
    [ExtensionAttribute]
public static bool TryShift(IList`1<T> list, T& result);
    [ExtensionAttribute]
public static void Unshift(IList`1<T> list, T value);
    [ExtensionAttribute]
public static void Push(IList`1<T> list, T value);
    [ExtensionAttribute]
public static void AddIf(IList`1<T> list, bool shouldAdd, T value);
    [ExtensionAttribute]
public static IList`1<T> AddAll(IList`1<T> list, T[] items);
    [ExtensionAttribute]
public static bool TryEjectFirst(IList`1<T> list, Func`2<T, bool> matcher, T& result);
    private static bool TryEject(IList`1<T> list, Func`2<T, bool> matcher, bool findFirst, T& result);
    [ExtensionAttribute]
public static T EjectFirst(IList`1<T> list, Func`2<T, bool> matcher);
    [ExtensionAttribute]
public static bool TryEjectLast(IList`1<T> list, Func`2<T, bool> matcher, T& result);
    [ExtensionAttribute]
public static T EjectLast(IList`1<T> list, Func`2<T, bool> matcher);
    private static Exception FailToEjectErrorFor(IList`1<T> list);
    private static void ValidateListContainsElements(IList`1<T> list);
    [ExtensionAttribute]
public static IList`1<T> Reversed(IList`1<T> list);
    [ExtensionAttribute]
public static List`1<T> ReversedInPlace(List`1<T> list);
    [ExtensionAttribute]
public static T[] ReversedInPlace(T[] array);
}
public class PeanutButter.Utils.MaxAttemptsRetryContext : object {
    [CompilerGeneratedAttribute]
private int <MaxAttempts>k__BackingField;
    private Func`1<IBackoffStrategy> _defaultBackoffStrategyFactory;
    public int MaxAttempts { get; }
    public MaxAttemptsRetryContext(int maxAttempts, Func`1<IBackoffStrategy> defaultBackoffStrategy);
    [CompilerGeneratedAttribute]
public int get_MaxAttempts();
    public void Times(Action toRun, string caller);
    public void Times(Action toRun, IBackoffStrategy backoffStrategy, string caller);
    public void Times(Action toRun, Func`2<Exception, ExceptionHandlingStrategies> exceptionHandler, string caller);
    [AsyncStateMachineAttribute("PeanutButter.Utils.MaxAttemptsRetryContext/<TimesAsync>d__8")]
public Task TimesAsync(Func`1<Task> toRun, string caller);
    [AsyncStateMachineAttribute("PeanutButter.Utils.MaxAttemptsRetryContext/<TimesAsync>d__9")]
public Task TimesAsync(Func`1<Task> toRun, Func`2<Exception, Task`1<ExceptionHandlingStrategies>> exceptionHandler, string caller);
    [AsyncStateMachineAttribute("PeanutButter.Utils.MaxAttemptsRetryContext/<TimesAsync>d__10")]
public Task TimesAsync(Func`2<int, Task> toRun, Func`2<Exception, Task`1<ExceptionHandlingStrategies>> exceptionHandler, string caller);
    [AsyncStateMachineAttribute("PeanutButter.Utils.MaxAttemptsRetryContext/<TimesAsync>d__11")]
public Task TimesAsync(Func`2<int, Task> toRun, IBackoffStrategy backoffStrategy, Func`2<Exception, Task`1<ExceptionHandlingStrategies>> exceptionHandler, string caller);
    public void Times(Action toRun, IBackoffStrategy backoffStrategy, Func`2<Exception, ExceptionHandlingStrategies> exceptionHandler, string caller);
    public void Times(Action`1<int> toRun, string caller);
    public void Times(Action`1<int> toRun, IBackoffStrategy backoffStrategy, string caller);
    public void Times(Action`1<int> toRun, Func`2<Exception, ExceptionHandlingStrategies> exceptionHandler, string caller);
    public void Times(Action`1<int> toRun, IBackoffStrategy backoffStrategy, Func`2<Exception, ExceptionHandlingStrategies> exceptionHandler, string caller);
    [AsyncStateMachineAttribute("PeanutButter.Utils.MaxAttemptsRetryContext/<Times>d__17`1")]
public Task`1<T> Times(Func`2<int, Task`1<T>> toRun, string caller);
    [AsyncStateMachineAttribute("PeanutButter.Utils.MaxAttemptsRetryContext/<Times>d__18`1")]
public Task`1<T> Times(Func`2<int, Task`1<T>> toRun, IBackoffStrategy backoffStrategy, string caller);
    [AsyncStateMachineAttribute("PeanutButter.Utils.MaxAttemptsRetryContext/<Times>d__19`1")]
public Task`1<T> Times(Func`2<int, Task`1<T>> toRun, IBackoffStrategy backoffStrategy, Func`2<Exception, ExceptionHandlingStrategies> exceptionHandler, string caller);
    public T Times(Func`1<T> toRun, string caller);
    public T Times(Func`1<T> toRun, IBackoffStrategy backoffStrategy, string caller);
    public T Times(Func`1<T> toRun, Func`2<Exception, ExceptionHandlingStrategies> exceptionHandler, string caller);
    public T Times(Func`2<int, T> toRun, string caller);
    public T Times(Func`2<int, T> toRun, IBackoffStrategy backoffStrategy, string caller);
    public T Times(Func`2<int, T> toRun, Func`2<Exception, ExceptionHandlingStrategies> exceptionHandler, string caller);
    public T Times(Func`2<int, T> toRun, IBackoffStrategy backoffStrategy, Func`2<Exception, ExceptionHandlingStrategies> exceptionHandler, string caller);
    [AsyncStateMachineAttribute("PeanutButter.Utils.MaxAttemptsRetryContext/<Times>d__27")]
public Task Times(Func`2<int, Task> toRun, string caller);
    [AsyncStateMachineAttribute("PeanutButter.Utils.MaxAttemptsRetryContext/<Times>d__28")]
public Task Times(Func`2<int, Task> toRun, IBackoffStrategy backoffStrategy, string caller);
    [AsyncStateMachineAttribute("PeanutButter.Utils.MaxAttemptsRetryContext/<Times>d__29")]
public Task Times(Func`2<int, Task> toRun, Func`2<Exception, ExceptionHandlingStrategies> exceptionHandler, string caller);
    [AsyncStateMachineAttribute("PeanutButter.Utils.MaxAttemptsRetryContext/<Times>d__30")]
public Task Times(Func`1<Task> toRun, string caller);
    [AsyncStateMachineAttribute("PeanutButter.Utils.MaxAttemptsRetryContext/<Times>d__31")]
public Task Times(Func`1<Task> toRun, IBackoffStrategy backoffStrategy, string caller);
    [AsyncStateMachineAttribute("PeanutButter.Utils.MaxAttemptsRetryContext/<Times>d__32")]
public Task Times(Func`1<Task> toRun, Func`2<Exception, ExceptionHandlingStrategies> exceptionHandler, string caller);
    [AsyncStateMachineAttribute("PeanutButter.Utils.MaxAttemptsRetryContext/<Times>d__33")]
public Task Times(Func`2<int, Task> toRun, IBackoffStrategy backoffStrategy, Func`2<Exception, ExceptionHandlingStrategies> exceptionHandler, string caller);
    private void WaitIfNecessary(IBackoffStrategy backoffStrategy, int attempt);
    private ExceptionHandlingStrategies AlwaysSuppress(Exception ex);
    private Task`1<ExceptionHandlingStrategies> AlwaysSuppressAsync(Exception ex);
}
[ExtensionAttribute]
public static class PeanutButter.Utils.MedianExtensions : object {
    [ExtensionAttribute]
public static decimal Median(IEnumerable`1<byte> collection);
    [ExtensionAttribute]
public static decimal Median(IEnumerable`1<int> collection);
    [ExtensionAttribute]
public static decimal Median(IEnumerable`1<UInt32> collection);
    [ExtensionAttribute]
public static decimal Median(IEnumerable`1<long> collection);
    [ExtensionAttribute]
public static decimal Median(IEnumerable`1<ulong> collection);
    [ExtensionAttribute]
public static decimal Median(IEnumerable`1<float> collection);
    [ExtensionAttribute]
public static decimal Median(IEnumerable`1<double> collection);
    [ExtensionAttribute]
public static decimal Median(IEnumerable`1<decimal> collection);
    private static decimal DetermineMedianFor(IEnumerable`1<T> collection, Func`2<T, decimal> caster, Func`3<decimal, decimal, decimal> whenCollectionHasEvenItems);
}
public class PeanutButter.Utils.MemberNotFoundException : Exception {
    public MemberNotFoundException(Type type, string propertyName);
}
public enum PeanutButter.Utils.MergeIntoPrecedence : Enum {
    public int value__;
    public static MergeIntoPrecedence PreferTargetData;
    public static MergeIntoPrecedence PreferNewData;
}
public enum PeanutButter.Utils.MergeWithPrecedence : Enum {
    public int value__;
    public static MergeWithPrecedence PreferFirstSeen;
    public static MergeWithPrecedence PreferLastSeen;
}
[ExtensionAttribute]
public static class PeanutButter.Utils.MetadataExtensions : object {
    private static ConditionalWeakTable`2<object, Dictionary`2<string, object>> Table;
    private static Object[] NoArgs;
    private static SemaphoreSlim MetadataLock;
    private static MetadataExtensions();
    internal static int TrackedObjectCount();
    [ExtensionAttribute]
public static void SetMetadata(object parent, string key, object value);
    [ExtensionAttribute]
public static T GetMetadata(object parent, string key);
    [ExtensionAttribute]
public static T GetMetadata(object parent, string key, T defaultValue);
    [ExtensionAttribute]
public static bool HasMetadata(object parent, string key);
    [ExtensionAttribute]
public static bool HasMetadata(object parent);
    [ExtensionAttribute]
public static bool HasMetadata(object parent, string key);
    [ExtensionAttribute]
public static void DeleteMetadata(object parent);
    [ExtensionAttribute]
public static void DeleteMetadata(object parent, string key);
    [ExtensionAttribute]
public static bool TryGetMetadata(object parent, string key, T& result);
    [ExtensionAttribute]
public static void CopyAllMetadataTo(object parent, object target);
    private static bool CanCast(object stored);
    private static Dictionary`2<string, object> GetMetadataFor(object parent);
    private static Dictionary`2<string, object> AddMetadataFor(object parent);
}
[ExtensionAttribute]
[ObsoleteAttribute("MIMEType has been renamed to MimeTypes and will be removed in a future release")]
public static class PeanutButter.Utils.MIMEType : object {
    public static String[] KnownFileExtensions { get; }
    public static String[] KnownMimeTypes { get; }
    public static String[] get_KnownFileExtensions();
    public static String[] get_KnownMimeTypes();
    public static string GuessForFileName(string fileNameOrExtension);
    public static bool TryGuessExtensionForMimeType(string mimeType, String& extension);
    [ExtensionAttribute]
public static bool IsTextMIMEType(string mimeType);
}
[ExtensionAttribute]
public static class PeanutButter.Utils.MimeTypes : object {
    private static string DEFAULT_MIME_TYPE;
    private static String[] _knownFileExtensions;
    private static String[] _knownMimeTypes;
    private static IDictionary`2<string, string> ExtensionToMimeTypeMappings;
    private static IDictionary`2<string, string> _mimeTypeToExtensionMappings;
    public static String[] KnownFileExtensions { get; }
    public static String[] KnownMimeTypes { get; }
    private static IDictionary`2<string, string> MimeTypeToExtensionMappings { get; }
    private static MimeTypes();
    public static String[] get_KnownFileExtensions();
    public static String[] get_KnownMimeTypes();
    public static string GuessForFileName(string fileNameOrExtension);
    public static bool TryGuessExtensionForMimeType(string mimeType, String& extension);
    [ExtensionAttribute]
public static bool IsTextMimeType(string mimeType);
    private static IDictionary`2<string, string> get_MimeTypeToExtensionMappings();
    private static IDictionary`2<string, string> GenerateMimeTypeToExtensionMappings();
}
[ExtensionAttribute]
public static class PeanutButter.Utils.MockStoreExtensions : object {
    private static string KEY_PREFIX;
    [ExtensionAttribute]
public static IDictionary`2<int, TEntity> FindOrAddMockStoreFor(object owner);
    [ExtensionAttribute]
public static TStore FindOrAddMockStore(object owner);
    [ExtensionAttribute]
public static TResult FindOrAddMockStore(object owner, Func`1<TResult> factory);
    [CompilerGeneratedAttribute]
internal static TResult <FindOrAddMockStore>g__CreateStore|2_0(<>c__DisplayClass2_0`1& );
}
internal class PeanutButter.Utils.MostRecentlyUsedEnumerator`1 : object {
    private IEnumerator`1<KeyValuePair`2<T, long>> _snapshotEnumerator;
    public T Current { get; public set; }
    private object System.Collections.IEnumerator.Current { get; }
    public MostRecentlyUsedEnumerator`1(MostRecentlyUsedList`1<T> list);
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual T get_Current();
    public void set_Current(T value);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
public class PeanutButter.Utils.MostRecentlyUsedList`1 : object {
    [CompilerGeneratedAttribute]
private int <Capacity>k__BackingField;
    private Dictionary`2<T, long> _items;
    public int Capacity { get; }
    internal Dictionary`2<T, long> Items { get; }
    public MostRecentlyUsedList`1(int capacity);
    [CompilerGeneratedAttribute]
public int get_Capacity();
    public void Add(T item);
    public bool Contains(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal Dictionary`2<T, long> get_Items();
}
public class PeanutButter.Utils.NoPooledItemAvailableException : Exception {
    public NoPooledItemAvailableException(Type type, int maxPoolSize, int maxWaitMs);
}
public class PeanutButter.Utils.NotFoundException : Exception {
    public NotFoundException(string message);
}
public enum PeanutButter.Utils.ObjectComparisons : Enum {
    public int value__;
    public static ObjectComparisons PropertiesAndFields;
    public static ObjectComparisons PropertiesOnly;
}
[ExtensionAttribute]
public static class PeanutButter.Utils.ObjectExtensions : object {
    private static ConcurrentDictionary`2<Type, PropertyInfo[]> PropertyCache;
    private static Func`6[] PropertySetterStrategies;
    private static BindingFlags PRIVATE_STATIC;
    private static MethodInfo GenericMakeArrayCopy;
    private static MethodInfo GenericMakeListCopy;
    private static MethodInfo GenericMakeDictionaryCopy;
    private static Func`3[] CloneStrategies;
    private static ConcurrentDictionary`2<Tuple`2<Type, Type>, MethodInfo> DictionaryCopyMethodCache;
    private static ConcurrentDictionary`2<Type, MethodInfo> ListCopyMethodCache;
    private static ConcurrentDictionary`2<Type, MethodInfo> ArrayCopyMethodCache;
    private static BindingFlags INSTANCE_PUBLIC_OR_PRIVATE;
    private static BindingFlags AllOnInstance;
    private static MethodInfo GenericDefaultOfT;
    private static BindingFlags PUBLIC_STATIC;
    private static MethodInfo GenericIsInstanceOf;
    private static ConcurrentDictionary`2<Type, MethodInfo> NewtonsoftSerializeMethodCache;
    private static ConcurrentDictionary`2<Type, MethodInfo> SystemSerializeMethodCache;
    private static string NEWTONSOFT_NAMESPACE;
    private static string SYSTEM_TEXT_JSON_NAMESPACE;
    private static Type _systemTextJsonSerializer;
    private static MethodInfo _genericSystemSerializer;
    private static MethodInfo _genericSystemDeserializer;
    private static Type _newtonsoftJsonSerializer;
    private static MethodInfo _newtonsoftSerializerMethod;
    private static MethodInfo _genericNewtonsoftDeserializer;
    private static ConcurrentDictionary`2<Type, JsonSerializers> SerializerCache;
    private static Type SystemTextJsonSerializer { get; }
    private static bool HaveSystemSerializer { get; }
    private static MethodInfo GenericSystemSerializer { get; }
    private static MethodInfo GenericSystemDeserializer { get; }
    private static Type NewtonsoftJsonSerializer { get; }
    private static bool HaveNewtonsoftSerializer { get; }
    private static MethodInfo NewtonsoftSerializerMethod { get; }
    private static MethodInfo GenericNewtonsoftDeserializer { get; }
    private static ObjectExtensions();
    [ExtensionAttribute]
public static bool DeepEquals(object objSource, object objCompare, String[] ignorePropertiesByName);
    [ExtensionAttribute]
public static bool ShapeEquals(object objSource, object objCompare, String[] ignorePropertiesByName);
    [ExtensionAttribute]
public static bool ShapeSubEquals(object objSource, object objCompare, String[] ignorePropertiesByName);
    private static bool PerformShapeEqualityTesting(object left, object right, bool allowMissingProperties, String[] ignorePropsByName);
    [ExtensionAttribute]
public static bool DeepEquals(object objSource, object objCompare, ObjectComparisons comparison, String[] ignorePropertiesByName);
    [ExtensionAttribute]
public static bool DeepEquals(object objSource, object objCompare, Action`1<string> failureLogAction, String[] ignorePropertiesByName);
    [ExtensionAttribute]
public static bool DeepSubEquals(object objSource, object objCompare, String[] ignorePropertiesByName);
    [ExtensionAttribute]
public static bool DeepIntersectionEquals(object objSource, object objCompare, String[] ignorePropertiesByName);
    [ExtensionAttribute]
public static bool ContainsAtLeastOneDeepEqualTo(IEnumerable`1<T1> collection, T2 item, String[] ignoreProperties);
    [ExtensionAttribute]
public static bool ContainsOneDeepEqualTo(IEnumerable`1<T1> collection, T2 item, String[] ignoreProperties);
    [ExtensionAttribute]
public static bool ContainsOneIntersectionEqualTo(IEnumerable`1<T1> collection, T2 item, String[] ignoreProperties);
    [ExtensionAttribute]
public static bool ContainsOnlyOneDeepEqualTo(IEnumerable`1<T1> collection, T2 item, String[] ignoreProperties);
    [ExtensionAttribute]
public static bool ContainsOnlyOneIntersectionEqualTo(IEnumerable`1<T1> collection, T2 item, String[] ignoreProperties);
    [ExtensionAttribute]
public static bool ContainsOnlyOneMatching(IEnumerable`1<T1> collection, T2 item, Func`3<T1, T2, bool> comparer);
    [ExtensionAttribute]
public static void CopyPropertiesTo(object src, object dst);
    [ExtensionAttribute]
public static void CopyPropertiesTo(object src, object dst, String[] ignoreProperties);
    [ExtensionAttribute]
public static void CopyPropertiesTo(object src, object dst, bool deep, String[] ignoreProperties);
    private static bool SetEnumValue(bool deep, PropertyInfo srcPropertyInfo, PropertyInfo dstPropertyInfo, object dst, object srcValue);
    private static bool DefaultSetValue(bool deep, PropertyInfo srcPropertyInfo, PropertyInfo dstPropertyInfo, object dst, object srcVal);
    private static bool SetGenericListValue(bool deep, PropertyInfo srcPropertyInfo, PropertyInfo dstPropertyInfo, object dst, object srcVal);
    private static bool SetArrayOrGenericIEnumerableValue(bool deep, PropertyInfo srcPropertyInfo, PropertyInfo dstPropertyInfo, object dst, object srcVal);
    private static bool SetSimpleOrNullableOfSimpleTypeValue(bool deep, PropertyInfo srcPropertyInfo, PropertyInfo dstPropertyInfo, object dst, object srcVal);
    private static T[] MakeArrayCopyOf(IEnumerable`1<T> src);
    private static List`1<T> MakeListCopyOf(IEnumerable`1<T> src);
    private static IDictionary`2<TKey, TValue> MakeDictionaryCopyOf(IDictionary`2<TKey, TValue> src, Type targetType);
    [ExtensionAttribute]
public static T DeepClone(T item);
    [ExtensionAttribute]
private static object DeepCloneInternal(object src, Type cloneType);
    private static object CloneDictionary(object src, Type cloneType);
    private static object CloneEnumerable(object src, Type cloneType);
    private static object CloneList(object src, Type cloneType);
    private static object CloneArray(object src, Type cloneType);
    private static MethodInfo FindGenericMethodFor(Type type, MethodInfo genericMethod, ConcurrentDictionary`2<Type, MethodInfo> cache);
    private static object CloneObject(object src, Type cloneType);
    private static bool IsSimpleTypeOrNullableOfSimpleType(Type t);
    [ExtensionAttribute]
public static T Get(object src, string propertyPath);
    [ExtensionAttribute]
public static object Get(object src, string propertyPath, Type type);
    [ExtensionAttribute]
public static T GetOrDefault(object src, string propertyPath);
    [ExtensionAttribute]
public static T GetOrDefault(object src, string propertyPath, T defaultValue);
    [ExtensionAttribute]
[ObsoleteAttribute("This method was poorly-named and will be removed at some point. Please rather use .InArray() to avoid confusion with the IEnumerable<T> extension AsArray")]
public static T[] AsArray(T input);
    [ExtensionAttribute]
public static T[] InArray(T input);
    [ExtensionAttribute]
public static List`1<T> InList(T input);
    private static T ResolvePropertyValueFor(object src, string propertyPath, Type type, Boolean& typeWasConverted);
    private static T RetrieveTypedValue(Type type, object valueAsObject, string propertyPath, Boolean& typeWasConverted);
    [ExtensionAttribute]
public static object GetPropertyValue(object src, string propertyPath);
    private static PropertyOrField[] AnyInstanceProperty(Type type);
    private static PropertyOrField[] AnyInstanceField(Type type);
    private static Dictionary`2<Type, int> CreateAncestryLookupFor(Type type);
    [ExtensionAttribute]
public static object InvokeMethodWithResult(object src, string methodName, Object[] args);
    [ExtensionAttribute]
public static void SetPropertyValue(object src, string propertyPath, object newValue);
    [ExtensionAttribute]
private static void SetPropertyOrFieldValue(object src, string propertyPath, object newValue);
    private static TrailingMember FindPropertyOrField(object src, string propertyPath, Func`2[] fetchers);
    private static TrailingMember FindPropertyOrField(object src, string propertyPath, bool throwIfNotFound, Func`2[] fetchers);
    private static bool ParseIndexes(string path, String& name, Object[]& indexes);
    [ExtensionAttribute]
public static void Set(object src, string propertyPath, T newValue);
    [ExtensionAttribute]
public static bool TrySet(object src, string propertyPath, T newValue);
    [ExtensionAttribute]
public static T GetPropertyValue(object src, string propertyPath);
    [ExtensionAttribute]
public static bool IsAssignableTo(Type type);
    [ExtensionAttribute]
public static decimal TruncateTo(decimal value, int places);
    [ExtensionAttribute]
public static double TruncateTo(double value, int places);
    [ExtensionAttribute]
public static decimal ToFixed(decimal value, int places);
    [ExtensionAttribute]
public static double ToFixed(double value, int places);
    [ExtensionAttribute]
public static IEnumerable`1<T> AsEnumerable(object src);
    [IteratorStateMachineAttribute("PeanutButter.Utils.ObjectExtensions/<Enumerate>d__75`1")]
private static IEnumerable`1<T> Enumerate(IEnumerator enumerator);
    [ExtensionAttribute]
public static bool TryChangeType(object input, T& output);
    [ExtensionAttribute]
public static bool TryChangeType(object input, Type requiredType, Object& output);
    private static T Default();
    [ExtensionAttribute]
public static bool IsInstanceOf(object obj);
    [ExtensionAttribute]
public static bool IsInstanceOf(object obj, Type type);
    [ExtensionAttribute]
public static bool IsRuntimeType(object obj);
    [ExtensionAttribute]
public static bool HasProperty(object obj, string prop);
    [ExtensionAttribute]
public static bool HasProperty(object obj, string prop);
    [ExtensionAttribute]
public static bool HasProperty(object obj, string prop, Type propertyType);
    private static TrailingMember FindPropertyOrFieldForHasProperty(object obj, string prop);
    [ExtensionAttribute]
public static bool TryGet(object obj, string propertyPath, T& result);
    [ExtensionAttribute]
public static bool Is(object original, object test);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> AsDictionary(object obj);
    private static IDictionary`2<TKey, TValue> TryMakeDictionaryOutOf(object obj);
    [ExtensionAttribute]
public static IDictionary`2<string, string> AsDictionary(T value, Func`2<T, IEnumerable`1<string>> keyFetcher, Func`3<T, string, string> valueFetcher);
    [ExtensionAttribute]
public static T DeserializeFromJson(string json);
    private static T DeserializeWithSystemTextJson(string json);
    private static T DeserializeWithNewtonSoft(string json);
    [ExtensionAttribute]
public static string SerializeToJson(T item);
    private static string SerializeWithSystem(T item);
    private static string SerializeWithNewtonsoft(T item);
    private static JsonSerializers DetermineSerializerFor(object item);
    private static JsonSerializers DetermineSerializerForType(Type type);
    private static Type TryFindType(string namespacedName);
    private static Type get_SystemTextJsonSerializer();
    private static bool get_HaveSystemSerializer();
    private static MethodInfo get_GenericSystemSerializer();
    private static MethodInfo get_GenericSystemDeserializer();
    private static bool HasRequiredAttributesForGenericSystemDeserializer(MethodInfo mi);
    private static Type get_NewtonsoftJsonSerializer();
    private static bool get_HaveNewtonsoftSerializer();
    private static MethodInfo get_NewtonsoftSerializerMethod();
    private static MethodInfo get_GenericNewtonsoftDeserializer();
    [CompilerGeneratedAttribute]
internal static TrailingMember <FindPropertyOrField>g__Fail|63_0(Type type, string name, <>c__DisplayClass63_0& );
}
public class PeanutButter.Utils.ParallelWorker : Worker {
    private ParallelWorker`1<int> _actual;
    public bool Busy { get; }
    public ParallelWorker(Action[] workers);
    public sealed virtual bool get_Busy();
    public sealed virtual void AddWorkers(IEnumerable`1<Action> workers);
    public sealed virtual Exception[] RunAll();
    public sealed virtual Exception[] RunAll(int maxDegreeOfParallelism);
    public sealed virtual void AddWorker(Action worker);
    [IteratorStateMachineAttribute("PeanutButter.Utils.ParallelWorker/<Wrap>d__8")]
private IEnumerable`1<Func`1<int>> Wrap(IEnumerable`1<Action> workers);
    private Func`1<int> Wrap(Action action);
}
public class PeanutButter.Utils.ParallelWorker`1 : Worker {
    [CompilerGeneratedAttribute]
private bool <Busy>k__BackingField;
    private List`1<Func`1<T>> _work;
    private ConcurrentBag`1<Func`1<T>> _deferredWork;
    private SemaphoreSlim _runLock;
    public bool Busy { get; private set; }
    public ParallelWorker`1(Func`1[] workers);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Busy();
    [CompilerGeneratedAttribute]
private void set_Busy(bool value);
    public sealed virtual void AddWorker(Func`1<T> worker);
    public sealed virtual void AddWorkers(IEnumerable`1<Func`1<T>> workers);
    private void ScheduleDeferred(IEnumerable`1<Func`1<T>> workers);
    public sealed virtual WorkResult`1[] RunAll();
    public sealed virtual WorkResult`1[] RunAll(int maxDegreeOfParallelism);
    private WorkResult`1[] RunAll(int maxDegreeOfParallelism, Func`1[] toRun);
}
public enum PeanutButter.Utils.PathType : Enum {
    public int value__;
    public static PathType Auto;
    public static PathType Unix;
    public static PathType Windows;
}
public static class PeanutButter.Utils.Platform : object {
    private static PlatformID[] UnixOperatingSystems;
    private static PlatformID[] WindowsOperatingSystems;
    private static Nullable`1<bool> _isUnixy;
    private static Nullable`1<bool> _isWindows;
    private static Nullable`1<bool> _isMacOSX;
    public static bool IsUnixy { get; }
    public static bool IsWindows { get; }
    public static bool IsMacOSX { get; }
    public static bool Is64Bit { get; }
    public static bool Is32Bit { get; }
    public static string PathDelimiter { get; }
    private static Platform();
    public static bool get_IsUnixy();
    public static bool get_IsWindows();
    public static bool get_IsMacOSX();
    public static bool get_Is64Bit();
    public static bool get_Is32Bit();
    public static string get_PathDelimiter();
}
public class PeanutButter.Utils.Pool`1 : object {
    [CompilerGeneratedAttribute]
private int <MaxItems>k__BackingField;
    private List`1<IPoolItem`1<T>> _items;
    private Func`1<T> _factory;
    private Action`1<T> _onRelease;
    private object _disposedLock;
    private bool _disposed;
    public int MaxItems { get; }
    public int Count { get; }
    public Pool`1(Func`1<T> factory);
    public Pool`1(Func`1<T> factory, int maxItems);
    public Pool`1(Func`1<T> factory, Action`1<T> onRelease);
    public Pool`1(Func`1<T> factory, Action`1<T> onRelease, int maxItems);
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxItems();
    public sealed virtual int get_Count();
    private TResult WithLockedItems(Func`2<List`1<IPoolItem`1<T>>, TResult> toRun);
    private void WithLockedItems(Action`1<List`1<IPoolItem`1<T>>> toRun);
    private void WithLockedItemsInternal(Action`1<List`1<IPoolItem`1<T>>> toRun);
    [ObsoleteAttribute("This has been renamed to Borrow and will be removed in a future version")]
public sealed virtual IPoolItem`1<T> Take();
    [ObsoleteAttribute("This has been renamed to Borrow and will be removed in a future version")]
public sealed virtual IPoolItem`1<T> Take(int maxWaitMilliseconds);
    public sealed virtual IPoolItem`1<T> Borrow();
    public sealed virtual IPoolItem`1<T> Borrow(int maxWaitMilliseconds);
    public sealed virtual void Forget(IPoolItem`1<T> item);
    private bool TryFindExistingAvailableInstance(int maxWaitMs, IPoolItem`1& result);
    public sealed virtual void Dispose();
    private void VerifyNotDisposed();
}
public class PeanutButter.Utils.PoolItem`1 : object {
    private Action`1<T> _onRelease;
    private IPool`1<T> _owner;
    [CompilerGeneratedAttribute]
private T <Instance>k__BackingField;
    private SemaphoreSlim _lock;
    public T Instance { get; }
    public bool IsAvailable { get; }
    public PoolItem`1(T instance, Action`1<T> onRelease, IPool`1<T> owner);
    [CompilerGeneratedAttribute]
public sealed virtual T get_Instance();
    public sealed virtual bool get_IsAvailable();
    public sealed virtual bool TryLock(int maxWaitMilliseconds);
    public sealed virtual void Dispose();
}
public static class PeanutButter.Utils.PortFinder : object {
    public static int MIN_PORT;
    public static int MAX_PORT;
    private static HashSet`1<int> Used;
    private static IPAddress WildcardIpAddress;
    private static PortFinder();
    public static int FindOpenPort();
    public static int FindOpenPort(IPAddress forAddress);
    public static int FindOpenPort(IPAddress forAddress, int min, int max);
    public static int FindOpenPort(IPAddress forAddress, int min, int max, Action`1<string> attemptLogger);
    public static void ResetUsedHistory();
    public static int FindOpenPort(IPAddress forAddress, int min, int max, Func`4<int, int, int, int> portAttemptGenerator);
    public static int FindOpenPortFrom(int start);
    public static int FindOpenPortFrom(IPAddress forAddress, int start);
    private static int SequentialPortLister(int min, int max, int current);
    public static int FindOpenPort(IPAddress forAddress, int min, int max, Func`4<int, int, int, int> portAttemptGenerator, Action`1<string> attemptLogger);
    private static void NullLogger(string obj);
    public static bool PortIsActivelyInUse(int port);
    public static bool PortIsActivelyInUse(IPAddress forAddress, int port);
    private static bool TcpPortIsActivelyInUse(IPAddress forAddress, int port);
    private static bool UdpPortIsActivelyInUse(IPAddress forAddress, int port);
    private static int Next(int min, int max, HashSet`1<int> tried);
}
public class PeanutButter.Utils.ProcessFailedToStartException : Exception {
    [CompilerGeneratedAttribute]
private string <Commandline>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Io>k__BackingField;
    public string Commandline { get; }
    public String[] Io { get; }
    internal ProcessFailedToStartException(string commandline, String[] io, Exception startException);
    [CompilerGeneratedAttribute]
public string get_Commandline();
    [CompilerGeneratedAttribute]
public String[] get_Io();
}
public class PeanutButter.Utils.ProcessIO : object {
    [CompilerGeneratedAttribute]
private string <Filename>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WorkingDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxBufferLines>k__BackingField;
    private string _commandline;
    [CompilerGeneratedAttribute]
private bool <Started>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <StartException>k__BackingField;
    private Process _process;
    private bool _disposed;
    private ManualResetEventSlim _stdOutDataAvailable;
    private ManualResetEventSlim _stdErrDataAvailable;
    private ManualResetEventSlim _interleavedDataAvailable;
    private ConcurrentQueue`1<string> _interleavedBuffer;
    private ConcurrentQueue`1<string> _stdOutBuffer;
    private ConcurrentQueue`1<string> _stdErrBuffer;
    private object _ioLock;
    private static Regex AnyWhitespace;
    public string Filename { get; private set; }
    public String[] Arguments { get; private set; }
    public string WorkingDirectory { get; private set; }
    public int MaxBufferLines { get; public set; }
    public string Commandline { get; }
    public int ProcessId { get; }
    public bool Started { get; private set; }
    public Exception StartException { get; private set; }
    public Process Process { get; }
    public int ExitCode { get; }
    public IEnumerable`1<string> StandardOutput { get; }
    public IEnumerable`1<string> StandardOutputSnapshot { get; }
    public IEnumerable`1<string> StandardError { get; }
    public IEnumerable`1<string> StandardErrorSnapshot { get; }
    public IEnumerable`1<string> StandardOutputAndErrorInterleaved { get; }
    public IEnumerable`1<string> StandardOutputAndErrorInterleavedSnapshot { get; }
    public StreamWriter StandardInput { get; }
    private Process SafeProcessAccess { get; }
    public bool HasExited { get; }
    [ObsoleteAttribute("Please use the static Process.Start or Process.In helpers; this constructor will be made internal in the future")]
public ProcessIO(string filename, String[] arguments);
    private static ProcessIO();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Filename();
    [CompilerGeneratedAttribute]
private void set_Filename(string value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_WorkingDirectory();
    [CompilerGeneratedAttribute]
private void set_WorkingDirectory(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxBufferLines();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MaxBufferLines(int value);
    public sealed virtual string get_Commandline();
    public sealed virtual int get_ProcessId();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Started();
    [CompilerGeneratedAttribute]
private void set_Started(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual Exception get_StartException();
    [CompilerGeneratedAttribute]
private void set_StartException(Exception value);
    public sealed virtual Process get_Process();
    private string RenderCommandline();
    public static UnstartedProcessIO In(string workingDirectory);
    public static IProcessIO Start(string filename, String[] args);
    private ProcessIO StartInFolder(string workingDirectory, string filename, String[] arguments, IDictionary`2<string, string> environment);
    private void OnErrReceived(object sender, DataReceivedEventArgs e);
    private void Trim(ConcurrentQueue`1<string> buffer);
    private void OnOutputReceived(object sender, DataReceivedEventArgs e);
    private void OnProcessExit(object sender, EventArgs e);
    private static IDictionary`2<string, string> GenerateProcessEnvironmentFor(IDictionary`2<string, string> environment);
    public sealed virtual int get_ExitCode();
    public sealed virtual int WaitForExit();
    public sealed virtual Nullable`1<int> WaitForExit(int timeoutMs);
    public sealed virtual void Kill();
    public sealed virtual bool WaitForOutput(StandardIo io, Func`2<string, bool> matcher);
    public sealed virtual bool WaitForOutput(StandardIo io, Func`2<string, bool> matcher, int timeoutMilliseconds);
    private bool WaitForOutput(IEnumerable`1<string> snapshotSource, ManualResetEventSlim ev, Func`2<string, bool> matcher, int timeoutMilliseconds);
    private bool HaveOutput(IEnumerable`1<string> snapshotSource, Func`2<string, bool> matcher, Int32& offset);
    public sealed virtual IEnumerable`1<string> get_StandardOutput();
    public sealed virtual IEnumerable`1<string> get_StandardOutputSnapshot();
    public sealed virtual IEnumerable`1<string> get_StandardError();
    public sealed virtual IEnumerable`1<string> get_StandardErrorSnapshot();
    public sealed virtual IEnumerable`1<string> get_StandardOutputAndErrorInterleaved();
    public sealed virtual IEnumerable`1<string> get_StandardOutputAndErrorInterleavedSnapshot();
    [IteratorStateMachineAttribute("PeanutButter.Utils.ProcessIO/<EnumerateSnapshot>d__73")]
private IEnumerable`1<string> EnumerateSnapshot(ConcurrentQueue`1<string> data);
    [IteratorStateMachineAttribute("PeanutButter.Utils.ProcessIO/<Enumerate>d__74")]
private IEnumerable`1<string> Enumerate(ConcurrentQueue`1<string> data, ManualResetEventSlim available);
    [IteratorStateMachineAttribute("PeanutButter.Utils.ProcessIO/<ReadFromOffset>d__75")]
private IEnumerable`1<string> ReadFromOffset(IEnumerable`1<string> source, int offset);
    public sealed virtual StreamWriter get_StandardInput();
    private Process get_SafeProcessAccess();
    public sealed virtual bool get_HasExited();
    private string MakeArgsFrom(String[] parameters);
    public static string QuoteIfNecessary(string str);
    public sealed virtual void Dispose();
    public static IUnstartedProcessIO WithEnvironmentVariable(string name, string value);
    public static IUnstartedProcessIO WithEnvironment(IDictionary`2<string, string> environment);
    [CompilerGeneratedAttribute]
private void <StartInFolder>b__42_0(KeyValuePair`2<string, string> kvp);
}
[DebuggerDisplayAttribute("{MemberType} {Type} {Name} read: {CanRead} write: {CanWrite}")]
public class PeanutButter.Utils.PropertyOrField : object {
    private static BindingFlags SearchBindingFlags;
    private static ConcurrentDictionary`2<Tuple`2<Type, string>, PropertyOrField> FindCache;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanRead>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyOrFieldTypes <MemberType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <HostingType>k__BackingField;
    private Nullable`1<int> _ancestralDistance;
    private Func`2<object, object> _getValue;
    private Action`2<object, object> _setValue;
    [CompilerGeneratedAttribute]
private PropertyInfo <PropertyInfo>k__BackingField;
    public string Name { get; }
    public Type Type { get; }
    public bool CanWrite { get; }
    public bool CanRead { get; }
    public PropertyOrFieldTypes MemberType { get; }
    public Type DeclaringType { get; }
    public Type HostingType { get; }
    public int AncestralDistance { get; }
    public PropertyInfo PropertyInfo { get; }
    public PropertyOrField(PropertyInfo prop);
    public PropertyOrField(PropertyInfo prop, Type hostingType);
    public PropertyOrField(FieldInfo field);
    public PropertyOrField(FieldInfo field, Type hostingType);
    private static PropertyOrField();
    public static PropertyOrField Create(PropertyInfo propertyInfo);
    public static PropertyOrField Create(FieldInfo fieldInfo);
    public static PropertyOrField Find(Type type, string name);
    public static PropertyOrField TryFind(Type type, string name);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanWrite();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanRead();
    [CompilerGeneratedAttribute]
public PropertyOrFieldTypes get_MemberType();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_DeclaringType();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_HostingType();
    public sealed virtual int get_AncestralDistance();
    [CompilerGeneratedAttribute]
public PropertyInfo get_PropertyInfo();
    public static PropertyOrField op_Implicit(PropertyInfo prop);
    public static PropertyOrField op_Implicit(FieldInfo field);
    public sealed virtual object GetValue(object host);
    public sealed virtual object GetValueAt(object host, object index);
    public sealed virtual bool TryGetValue(object host, Object& value, Exception& exception);
    public sealed virtual void SetValue(object host, object value);
    public sealed virtual void SetValueAt(object host, object value, object index);
    private int RequireIntegerIndex(object idx);
    public sealed virtual void SetValue(T& host, object value);
    private int CalculateAncestralDistance();
}
[ExtensionAttribute]
internal static class PeanutButter.Utils.PropertyOrFieldExtensions : object {
    private static Tuple`3[] AccessNames;
    private static PropertyOrFieldExtensions();
    [ExtensionAttribute]
public static bool IsAssignmentMatchFor(PropertyOrField master, PropertyOrField other);
    [ExtensionAttribute]
public static bool IsAssignmentMatchFor(PropertyOrField master, PropertyOrField other, bool mustMatchMemberType);
    [ExtensionAttribute]
public static bool IsMatchFor(PropertyOrField master, PropertyOrField other);
    [ExtensionAttribute]
public static bool IsMatchFor(PropertyOrField master, PropertyOrField other, bool mustMatchMemberType);
    [ExtensionAttribute]
private static bool AccessMatches(PropertyOrField master, PropertyOrField other);
    [ExtensionAttribute]
public static string PrettyPrint(PropertyOrField item);
    [ExtensionAttribute]
public static string PrintAccess(PropertyOrField item);
}
public enum PeanutButter.Utils.PropertyOrFieldTypes : Enum {
    public int value__;
    public static PropertyOrFieldTypes Property;
    public static PropertyOrFieldTypes Field;
}
public static class PeanutButter.Utils.PyLike : object {
    public static IEnumerable`1<int> Range(int stop);
    public static IEnumerable`1<int> Range(int start, int stop);
    [IteratorStateMachineAttribute("PeanutButter.Utils.PyLike/<Range>d__2")]
public static IEnumerable`1<int> Range(int start, int stop, int step);
    [IteratorStateMachineAttribute("PeanutButter.Utils.PyLike/<Zip>d__3`2")]
public static IEnumerable`1<Tuple`2<T1, T2>> Zip(IEnumerable`1<T1> left, IEnumerable`1<T2> right);
    [IteratorStateMachineAttribute("PeanutButter.Utils.PyLike/<Zip>d__4`3")]
public static IEnumerable`1<Tuple`3<T1, T2, T3>> Zip(IEnumerable`1<T1> left, IEnumerable`1<T2> middle, IEnumerable`1<T3> right);
    [IteratorStateMachineAttribute("PeanutButter.Utils.PyLike/<Zip>d__5`4")]
public static IEnumerable`1<Tuple`4<T1, T2, T3, T4>> Zip(IEnumerable`1<T1> first, IEnumerable`1<T2> second, IEnumerable`1<T3> third, IEnumerable`1<T4> fourth);
    private static bool AnyAreNull(Object[] objects);
    private static bool MoveAll(IEnumerator[] e);
}
[ExtensionAttribute]
public static class PeanutButter.Utils.QueueExtensions : object {
    [ExtensionAttribute]
public static bool TryDequeue(Queue`1<T> queue, T& result);
    [ExtensionAttribute]
public static T DequeueOrDefault(Queue`1<T> queue);
    [ExtensionAttribute]
public static T DequeueOrDefault(Queue`1<T> queue, T fallback);
}
public static class PeanutButter.Utils.RandomNumber : object {
    private static Random RandomSource;
    private static RandomNumber();
    public static int Next();
    public static int Next(int maxValue);
    public static int Next(int minValue, int maxValue);
    public static double NextDouble();
    public static void NextBytes(Byte[] buffer);
}
public class PeanutButter.Utils.RetriesExceededException : Exception {
    [CompilerGeneratedAttribute]
private string <Caller>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Attempts>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <LastException>k__BackingField;
    public string Caller { get; }
    public int Attempts { get; }
    public Exception LastException { get; }
    public RetriesExceededException(string caller, int attempts, Exception lastException);
    [CompilerGeneratedAttribute]
public string get_Caller();
    [CompilerGeneratedAttribute]
public int get_Attempts();
    [CompilerGeneratedAttribute]
public Exception get_LastException();
}
public static class PeanutButter.Utils.Retry : object {
    private static Func`1<IBackoffStrategy> _defaultBackoffStrategyFactory;
    private static IBackoffStrategy DefaultBackoffStrategyInstance;
    private static Retry();
    public static MaxAttemptsRetryContext Max(int maxAttempts);
    public static TimeBasedRetryContext Until(DateTime timeout);
    public static TimeBasedRetryContext Until(TimeSpan maxRunTime);
    public static void InstallDefaultBackoffStrategy(IBackoffStrategy backoffStrategy);
    public static void InstallDefaultBackoffStrategy(Func`1<IBackoffStrategy> factory);
    public static void ForgetDefaultBackoffStrategy();
}
[ExtensionAttribute]
public static class PeanutButter.Utils.RetryExtensions : object {
    [ExtensionAttribute]
public static void RunWithRetries(Action action, int retries, string callerFilePath, int callerLineNumber, string callerMemberName);
    [ExtensionAttribute]
public static void RunWithRetries(Action action, int retries, TimeSpan[] retryDelays, string callerFilePath, int callerLineNumber, string callerMemberName);
    [ExtensionAttribute]
public static T RunWithRetries(Func`1<T> func, int retries, string callerFilePath, int callerLineNumber, string callerMemberName);
    [ExtensionAttribute]
public static T RunWithRetries(Func`1<T> func, int retries, TimeSpan[] retryDelays, string callerFilePath, int callerLineNumber, string callerMemberName);
    [AsyncStateMachineAttribute("PeanutButter.Utils.RetryExtensions/<RunWithRetries>d__4")]
[ExtensionAttribute]
public static Task RunWithRetries(Func`1<Task> asyncFunc, int retries, TimeSpan[] retryDelays, string callerFilePath, int callerLineNumber, string callerMemberName);
    [AsyncStateMachineAttribute("PeanutButter.Utils.RetryExtensions/<RunWithRetries>d__5`1")]
[ExtensionAttribute]
public static Task`1<T> RunWithRetries(Func`1<Task`1<T>> func, int retries, string callerFilePath, int callerLineNumber, string callerMemberName);
    [AsyncStateMachineAttribute("PeanutButter.Utils.RetryExtensions/<RunWithRetries>d__6`1")]
[ExtensionAttribute]
public static Task`1<T> RunWithRetries(Func`1<Task`1<T>> func, int retries, TimeSpan[] retryDelays, string callerFilePath, int callerLineNumber, string callerMemberName);
}
[ObsoleteAttribute("Rather use SlidingWindow - it has time and max-item limits")]
public class PeanutButter.Utils.RollingWindow`1 : object {
    private long _maxSize;
    private Queue`1<T> _queue;
    public long MaxSize { get; public set; }
    private Queue`1<T> Queue { get; }
    public RollingWindow`1(long maxSize);
    public sealed virtual long get_MaxSize();
    public sealed virtual void set_MaxSize(long value);
    private Queue`1<T> get_Queue();
    public sealed virtual void Add(T item);
    private T[] Snapshot();
    public sealed virtual void Dispose();
    private TResult RunLocked(Func`1<TResult> toRun);
    private void TrimUnlocked(long toSize);
    private void RunLocked(Action toRun);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
private long <get_MaxSize>b__1_0();
    [CompilerGeneratedAttribute]
private T[] <Snapshot>b__9_0();
    [CompilerGeneratedAttribute]
private void <Dispose>b__10_0();
}
internal class PeanutButter.Utils.RollingWindowSnapshotEnumerator`1 : object {
    private T[] _snapshot;
    private int _idx;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public RollingWindowSnapshotEnumerator`1(T[] snapshot);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
}
public static class PeanutButter.Utils.Run : object {
    public static Exception[] InParallel(Action first, Action second, Action[] more);
    public static Exception[] InParallel(int maxDegreeOfParallelism, Action first, Action second, Action[] more);
    public static WorkResult`1[] InParallel(Func`1<T> first, Func`1<T> second, Func`1[] more);
    public static WorkResult`1[] InParallel(int maxDegreeOfParallelism, Func`1<T> first, Func`1<T> second, Func`1[] more);
    public static Exception[] InParallel(int maxDegreeOfParallelism, IEnumerable`1<Action> actions);
    private static ParallelWorker`1<T> CreateWorkerFor(Func`1<T> first, Func`1<T> second, Func`1[] more);
    private static ParallelWorker CreateWorkerFor(Action first, Action second, Action[] more);
    public static T Until(Func`2<T, bool> validator, Func`1<T> generator);
    public static T Until(Func`2<T, bool> validator, Func`2<T, T> generator);
    [AsyncStateMachineAttribute("PeanutButter.Utils.Run/<Until>d__9`1")]
public static Task`1<T> Until(Func`2<T, bool> validator, Func`2<T, Task`1<T>> generator);
    [AsyncStateMachineAttribute("PeanutButter.Utils.Run/<Until>d__10`1")]
public static Task`1<T> Until(Func`2<T, bool> validator, Func`1<Task`1<T>> generator);
    [AsyncStateMachineAttribute("PeanutButter.Utils.Run/<Until>d__11`1")]
public static Task`1<T> Until(Func`2<T, Task`1<bool>> validator, Func`2<T, T> generator);
    [AsyncStateMachineAttribute("PeanutButter.Utils.Run/<Until>d__12`1")]
public static Task`1<T> Until(Func`2<T, Task`1<bool>> validator, Func`2<T, Task`1<T>> generator);
    public static void WithTimeout(int timeoutMs, Action logic);
    public static void WithTimeout(TimeSpan timeout, Action logic);
    [AsyncStateMachineAttribute("PeanutButter.Utils.Run/<WithTimeoutAsync>d__15")]
public static Task WithTimeoutAsync(int timeoutMs, Func`1<Task> logic);
    [AsyncStateMachineAttribute("PeanutButter.Utils.Run/<WithTimeoutAsync>d__16")]
public static Task WithTimeoutAsync(TimeSpan timeout, Func`1<Task> logic);
    [AsyncStateMachineAttribute("PeanutButter.Utils.Run/<WithTimeoutAsync>d__17")]
public static Task WithTimeoutAsync(int timeoutMs, Func`2<CancellationToken, Task> logic);
    [AsyncStateMachineAttribute("PeanutButter.Utils.Run/<WithTimeoutAsync>d__18")]
public static Task WithTimeoutAsync(TimeSpan timeout, Func`2<CancellationToken, Task> logic);
    [AsyncStateMachineAttribute("PeanutButter.Utils.Run/<WithTimeoutAsync>d__19`1")]
public static Task`1<T> WithTimeoutAsync(int timeoutMs, Func`2<CancellationToken, Task`1<T>> logic);
    [AsyncStateMachineAttribute("PeanutButter.Utils.Run/<WithTimeoutAsync>d__20`1")]
public static Task`1<T> WithTimeoutAsync(TimeSpan timeout, Func`2<CancellationToken, Task`1<T>> logic);
    [AsyncStateMachineAttribute("PeanutButter.Utils.Run/<WithTimeoutAsync>d__21`1")]
public static Task`1<T> WithTimeoutAsync(TimeSpan timeout, Func`2<CancellationToken, Task`1<T>> logic, ErrorStrategies errorStrategy);
}
public static class PeanutButter.Utils.Runtime : object {
    private static Nullable`1<bool> _isMono;
    private static Nullable`1<bool> _isNetFx;
    private static Regex NetCoreMatcher;
    private static Nullable`1<bool> _isNetCore;
    private static Nullable`1<bool> _isNetNative;
    public static bool IsMono { get; }
    public static bool IsNetFx { get; }
    public static bool IsNetCore { get; }
    public static bool IsNetNative { get; }
    private static Runtime();
    public static bool get_IsMono();
    public static bool get_IsNetFx();
    public static bool get_IsNetCore();
    public static bool get_IsNetNative();
}
public static class PeanutButter.Utils.SafeWalk : object {
    public static IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOpt);
}
public class PeanutButter.Utils.SingleItemCache`1 : object {
    private Func`1<T> _generator;
    private Func`1<bool> _cacheInvalidator;
    private long _timeToLive;
    private T _cachedValue;
    private long _lastFetched;
    [CompilerGeneratedAttribute]
private TimeSpan <TimeToLive>k__BackingField;
    public T Value { get; }
    public Func`1<T> Generator { get; }
    public TimeSpan TimeToLive { get; }
    public Func`1<bool> CacheInvalidator { get; }
    public SingleItemCache`1(Func`1<T> generator, TimeSpan timeToLive);
    public SingleItemCache`1(Func`1<T> generator, Func`1<bool> cacheInvalidator);
    public sealed virtual T get_Value();
    public sealed virtual Func`1<T> get_Generator();
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_TimeToLive();
    public Func`1<bool> get_CacheInvalidator();
    private T RetrieveValue();
    private T RetrieveValueWithCacheInvalidator();
    private T RetrieveValueWithTimeToLive();
    public sealed virtual void Invalidate();
}
[DefaultMemberAttribute("Item")]
public class PeanutButter.Utils.SlidingWindow`1 : object {
    private TimeSpan _timeToLive;
    private List`1<SlidingWindowItem`1<T>> _items;
    private bool _livesForEver;
    [CompilerGeneratedAttribute]
private int <MaxItems>k__BackingField;
    public TimeSpan TimeToLive { get; public set; }
    public int MaxItems { get; public set; }
    public TimeSpan MaxLifeSpan { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ISlidingWindowItem`1<T> First { get; }
    public ISlidingWindowItem`1<T> Last { get; }
    public T Item { get; public set; }
    public SlidingWindow`1(int maxItems);
    public SlidingWindow`1(TimeSpan timeToLive);
    public SlidingWindow`1(int maxItems, TimeSpan timeToLive);
    public TimeSpan get_TimeToLive();
    public void set_TimeToLive(TimeSpan value);
    [CompilerGeneratedAttribute]
public int get_MaxItems();
    [CompilerGeneratedAttribute]
public void set_MaxItems(int value);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual TimeSpan get_MaxLifeSpan();
    private TimeSpan CalculateCurrentTimeSpan();
    public sealed virtual void Trim();
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual ISlidingWindowItem`1<T> ItemAt(int index);
    public sealed virtual ISlidingWindowItem`1<T> get_First();
    private ISlidingWindowItem`1<T> TrimThenRunLocked(Func`1<SlidingWindowItem`1<T>> func);
    private TOut TrimThenRunLocked(Func`1<TOut> func);
    public sealed virtual ISlidingWindowItem`1<T> get_Last();
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    [CompilerGeneratedAttribute]
private IEnumerator`1<T> <GetEnumerator>b__13_0();
    [CompilerGeneratedAttribute]
private SlidingWindowItem`1<T> <get_First>b__32_0();
    [CompilerGeneratedAttribute]
private SlidingWindowItem`1<T> <get_Last>b__36_0();
}
[ExtensionAttribute]
public static class PeanutButter.Utils.SlidingWindowEstimatedTimeRemainingExtensions : object {
    [ExtensionAttribute]
public static TimeSpan EstimatedTimeRemaining(ISlidingWindow`1<int> window, int remainingItems);
    [ExtensionAttribute]
public static TimeSpan EstimatedTimeRemaining(ISlidingWindow`1<long> window, long remainingItems);
    [ExtensionAttribute]
public static TimeSpan EstimatedTimeRemaining(ISlidingWindow`1<decimal> window, decimal remainingItems);
    [ExtensionAttribute]
public static TimeSpan EstimatedTimeRemaining(ISlidingWindow`1<double> window, double remainingItems);
}
internal class PeanutButter.Utils.SlidingWindowItem`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Created>k__BackingField;
    public T Value { get; internal set; }
    public DateTime Created { get; internal set; }
    internal SlidingWindowItem`1(T value);
    [CompilerGeneratedAttribute]
public sealed virtual T get_Value();
    [CompilerGeneratedAttribute]
internal void set_Value(T value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_Created();
    [CompilerGeneratedAttribute]
internal void set_Created(DateTime value);
    public bool HasValue(T other);
}
[ExtensionAttribute]
public static class PeanutButter.Utils.SlidingWindowRateExtensions : object {
    [ExtensionAttribute]
public static decimal CurrentRate(ISlidingWindow`1<int> window);
    [ExtensionAttribute]
public static decimal CurrentRate(ISlidingWindow`1<int> window, TimeSpan periodSize);
    [ExtensionAttribute]
public static decimal CurrentRate(ISlidingWindow`1<long> window);
    [ExtensionAttribute]
public static decimal CurrentRate(ISlidingWindow`1<long> window, TimeSpan periodSize);
    [ExtensionAttribute]
public static decimal CurrentRate(ISlidingWindow`1<decimal> window);
    [ExtensionAttribute]
public static decimal CurrentRate(ISlidingWindow`1<decimal> window, TimeSpan periodSize);
    [ExtensionAttribute]
public static decimal CurrentRate(ISlidingWindow`1<double> window);
    [ExtensionAttribute]
public static decimal CurrentRate(ISlidingWindow`1<double> window, TimeSpan periodSize);
    private static decimal CalculatePeriodCount(TimeSpan totalTime, TimeSpan periodSize);
}
public enum PeanutButter.Utils.StandardIo : Enum {
    public int value__;
    public static StandardIo StdOut;
    public static StandardIo StdErr;
    public static StandardIo StdOutOrStdErr;
}
public class PeanutButter.Utils.Steps : object {
    public void Run(Action before, Action activity, Action`1<Exception> after);
    public void Run(Action before, Action activity, Func`2<Exception, ErrorHandlerResult> after);
    [AsyncStateMachineAttribute("PeanutButter.Utils.Steps/<RunAsync>d__2")]
public Task RunAsync(Func`1<Task> before, Func`1<Task> activity, Func`2<Exception, Task> after);
    [AsyncStateMachineAttribute("PeanutButter.Utils.Steps/<RunAsync>d__3")]
public Task RunAsync(Func`1<Task> before, Func`1<Task> activity, Func`2<Exception, Task`1<ErrorHandlerResult>> after);
}
public enum PeanutButter.Utils.StorageTypes : Enum {
    public int value__;
    public static StorageTypes Auto;
    public static StorageTypes InMemory;
    public static StorageTypes OnDisk;
}
[ExtensionAttribute]
public static class PeanutButter.Utils.StreamExtensions : object {
    [ExtensionAttribute]
public static Byte[] ReadAllBytes(Stream src);
    [AsyncStateMachineAttribute("PeanutButter.Utils.StreamExtensions/<ReadAllBytesAsync>d__1")]
[ExtensionAttribute]
public static Task`1<Byte[]> ReadAllBytesAsync(Stream src);
    [ExtensionAttribute]
public static void WriteAllBytes(Stream source, Byte[] data);
    [AsyncStateMachineAttribute("PeanutButter.Utils.StreamExtensions/<WriteAllBytesAsync>d__3")]
[ExtensionAttribute]
public static Task WriteAllBytesAsync(Stream source, Byte[] data);
    [ExtensionAttribute]
public static void Rewind(Stream src);
    [ExtensionAttribute]
public static void Append(Stream target, Byte[] data);
    [AsyncStateMachineAttribute("PeanutButter.Utils.StreamExtensions/<AppendAsync>d__6")]
[ExtensionAttribute]
public static Task AppendAsync(Stream target, Byte[] data);
    [ExtensionAttribute]
public static string AsString(Stream src, Encoding encoding);
    [AsyncStateMachineAttribute("PeanutButter.Utils.StreamExtensions/<AsStringAsync>d__8")]
[ExtensionAttribute]
public static Task`1<string> AsStringAsync(Stream src, Encoding encoding);
    [ExtensionAttribute]
public static void WriteString(Stream stream, string data);
    [AsyncStateMachineAttribute("PeanutButter.Utils.StreamExtensions/<WriteStringAsync>d__10")]
[ExtensionAttribute]
public static Task WriteStringAsync(Stream stream, string data);
    [ExtensionAttribute]
public static void WriteString(Stream stream, string data, Encoding encoding);
    [AsyncStateMachineAttribute("PeanutButter.Utils.StreamExtensions/<WriteStringAsync>d__12")]
[ExtensionAttribute]
public static Task WriteStringAsync(Stream stream, string data, Encoding encoding);
    [ExtensionAttribute]
public static void Save(Stream stream, string filePath);
    [AsyncStateMachineAttribute("PeanutButter.Utils.StreamExtensions/<SaveAsync>d__14")]
[ExtensionAttribute]
public static Task SaveAsync(Stream stream, string filePath);
    private static void EnsureFolderExistsFor(string filePath);
    private static Byte[] ReadAllBytesFrom(Stream src);
    [AsyncStateMachineAttribute("PeanutButter.Utils.StreamExtensions/<ReadAllBytesAsyncFrom>d__17")]
private static Task`1<Byte[]> ReadAllBytesAsyncFrom(Stream src);
    [ExtensionAttribute]
public static void AppendString(Stream stream, string value);
    [ExtensionAttribute]
public static void AppendLine(Stream stream, string line);
    private static void NoOp(Eol obj);
    [ExtensionAttribute]
public static IEnumerable`1<string> ReadLines(Stream stream);
    [ExtensionAttribute]
public static IEnumerable`1<string> ReadLines(Stream stream, Action`1<Eol> onNewline);
    [ExtensionAttribute]
public static IEnumerable`1<string> ReadLines(Stream stream, Encoding encoding);
    [IteratorStateMachineAttribute("PeanutButter.Utils.StreamExtensions/<ReadLines>d__24")]
[ExtensionAttribute]
public static IEnumerable`1<string> ReadLines(Stream stream, Encoding encoding, Action`1<Eol> onNewLine);
    [ExtensionAttribute]
public static string ReadLine(Stream stream);
    [ExtensionAttribute]
public static string ReadLine(Stream stream, Encoding encoding);
    [ExtensionAttribute]
public static string ReadAllText(Stream stream);
    [ExtensionAttribute]
public static string ReadAllText(Stream stream, Encoding encoding);
    [AsyncStateMachineAttribute("PeanutButter.Utils.StreamExtensions/<ReadAllTextAsync>d__29")]
[ExtensionAttribute]
public static Task`1<string> ReadAllTextAsync(Stream stream);
    [AsyncStateMachineAttribute("PeanutButter.Utils.StreamExtensions/<ReadAllTextAsync>d__30")]
[ExtensionAttribute]
public static Task`1<string> ReadAllTextAsync(Stream stream, Encoding encoding);
}
internal class PeanutButter.Utils.StrictComparer`1 : object {
    public sealed virtual bool Equals(TKey x, TKey y);
    public sealed virtual int GetHashCode(TKey obj);
}
[ExtensionAttribute]
public static class PeanutButter.Utils.StringExtensions : object {
    private static String[] Truthy;
    private static string BASE64_CHARACTER_SET;
    private static HashSet`1<char> Base64Characters;
    private static Regex AlphaNumericMatch;
    private static string rsAstralRange;
    private static string rsComboMarksRange;
    private static string reComboHalfMarksRange;
    private static string rsComboSymbolsRange;
    private static string rsComboMarksExtendedRange;
    private static string rsComboMarksSupplementRange;
    private static string rsComboRange;
    private static string rsDingbatRange;
    private static string rsLowerRange;
    private static string rsMathOpRange;
    private static string rsNonCharRange;
    private static string rsPunctuationRange;
    private static string rsSpaceRange;
    private static string rsUpperRange;
    private static string rsVarRange;
    private static string rsBreakRange;
    private static string rsApos;
    private static string rsBreak;
    private static string rsCombo;
    private static string rsDigit;
    private static string rsDingbat;
    private static string rsLower;
    private static string rsMisc;
    private static string rsFitz;
    private static string rsModifier;
    private static string rsNonAstral;
    private static string rsRegional;
    private static string rsSurrPair;
    private static string rsUpper;
    private static string rsZWJ;
    private static string rsMiscLower;
    private static string rsMiscUpper;
    private static string rsOptContrLower;
    private static string rsOptContrUpper;
    private static string reOptMod;
    private static string rsOptVar;
    private static string rsOptJoin;
    private static string rsOrdLower;
    private static string rsOrdUpper;
    private static string rsSeq;
    private static string rsEmoji;
    private static string rsUUID;
    private static Regex UnicodeWords;
    private static Regex CommandlinePartsMatcher;
    private static Regex Whitespace;
    private static Dictionary`2<int, string> Base64PaddingSuffixes;
    private static Regex NewLines;
    private static String[] IndentationSearch;
    private static Regex _pathSplitRegex;
    private static Regex WindowsDriveMatch;
    private static string DirectorySeparator;
    private static Regex PathSplitRegex { get; }
    private static StringExtensions();
    [ExtensionAttribute]
public static string RegexReplace(string input, string pattern, string replaceWith);
    [ExtensionAttribute]
public static string RegexReplaceAll(string input, string replaceWith, String[] patterns);
    [ExtensionAttribute]
public static string RegexReplaceAll(string input, string replaceWith, Regex[] patterns);
    [ExtensionAttribute]
public static string Or(string input, string alternative);
    [ExtensionAttribute]
public static bool AsBoolean(string input);
    [ExtensionAttribute]
public static bool ContainsOneOf(string haystack, String[] needles);
    [ExtensionAttribute]
public static bool EqualsOneOf(string haystack, String[] needles);
    [ExtensionAttribute]
public static bool ContainsAllOf(string haystack, String[] needles);
    private static bool MultiMatch(string haystack, String[] needles, Func`2<string, bool> operation);
    [ExtensionAttribute]
public static bool StartsWithOneOf(string src, String[] search);
    [ExtensionAttribute]
public static Byte[] AsBytes(string src);
    [ExtensionAttribute]
public static Byte[] AsBytes(string src, Encoding encoding);
    [ExtensionAttribute]
public static Stream AsStream(string src);
    [ExtensionAttribute]
public static IEnumerable`1<string> ToLower(IEnumerable`1<string> src);
    [ExtensionAttribute]
public static IEnumerable`1<string> ToLower(IEnumerable`1<string> src, CultureInfo cultureInfo);
    [ExtensionAttribute]
public static IEnumerable`1<string> ToUpper(IEnumerable`1<string> src);
    [ExtensionAttribute]
public static IEnumerable`1<string> ToUpper(IEnumerable`1<string> src, CultureInfo cultureInfo);
    [ExtensionAttribute]
public static Stream AsStream(string src, Encoding encoding);
    [ExtensionAttribute]
public static string AsString(Byte[] data);
    [ExtensionAttribute]
public static string AsString(Byte[] data, Encoding encoding);
    [ExtensionAttribute]
public static Stream AsStream(Byte[] src);
    [ExtensionAttribute]
public static bool IsInteger(string src);
    [ExtensionAttribute]
public static int AsInteger(string value);
    [ExtensionAttribute]
public static bool IsNullOrWhiteSpace(string value);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(string value);
    [ExtensionAttribute]
public static bool IsEmptyOrWhiteSpace(string value);
    [ExtensionAttribute]
public static bool IsWhiteSpace(string value);
    [ExtensionAttribute]
public static string ToBase64(string value);
    [ExtensionAttribute]
public static bool LooksLikeBase64(string str);
    [ExtensionAttribute]
public static string ZeroIfEmptyOrNull(string input);
    [ExtensionAttribute]
public static string DefaultIfEmptyOrNull(string input, string fallback);
    [ExtensionAttribute]
public static string SafeTrim(string input, Char[] trimChars);
    [ExtensionAttribute]
public static string ToKebabCase(string input);
    [ExtensionAttribute]
public static string ReplaceAll(string haystack, IEnumerable`1<char> needles, char replaceWith);
    [ExtensionAttribute]
public static string ReplaceAll(string haystack, IEnumerable`1<string> needles, string replaceWith);
    [ExtensionAttribute]
public static string RemoveAll(string subject, Char[] toRemove);
    [ExtensionAttribute]
public static string ToSnakeCase(string input);
    [ExtensionAttribute]
public static string ToPascalCase(string input);
    [ExtensionAttribute]
public static string ToTitleCase(string input);
    [ExtensionAttribute]
public static string ToCamelCase(string input);
    [ExtensionAttribute]
public static string ToRandomCase(string input);
    private static string RandomizeCase(string input);
    [ExtensionAttribute]
public static string ToWords(string input);
    [ExtensionAttribute]
public static String[] ToWordsArray(string input);
    [ExtensionAttribute]
public static string ToLowerCasedFirstLetter(string input);
    [ExtensionAttribute]
public static string ToUpperCasedFirstLetter(string input);
    [ExtensionAttribute]
public static string ToLower(string input, CultureInfo _);
    private static string GetLeadingIntegerCharsFrom(string value);
    [ExtensionAttribute]
public static bool IsNumeric(string str);
    [ExtensionAttribute]
public static bool IsAlphanumeric(string str);
    [ExtensionAttribute]
public static bool IsAlpha(string str);
    [ExtensionAttribute]
public static bool IsNumeric(char c);
    [ExtensionAttribute]
public static bool IsAlpha(char c);
    [ExtensionAttribute]
public static MemoryStream ToMemoryStream(string str);
    [ExtensionAttribute]
public static string QuoteIfSpaced(string str);
    [ExtensionAttribute]
public static String[] SplitCommandline(string str);
    [ExtensionAttribute]
public static string DeQuote(string str);
    [ExtensionAttribute]
public static bool Matches(IEnumerable`1<string> left, IEnumerable`1<string> right, StringComparison comparison);
    [ExtensionAttribute]
public static string Substr(string str, int start);
    [ExtensionAttribute]
public static string Substr(string str, int start, int length);
    [ExtensionAttribute]
public static string Window(string str, int centeredOn, int maxCharsLeftOrRight);
    [ExtensionAttribute]
public static string Window(string str, int centeredOn, int maxCharsLeftOrRight, Int32& startedAt, Int32& endedAt);
    [ExtensionAttribute]
public static Byte[] UnBase64(string base64Data);
    [ExtensionAttribute]
public static string UnBase64(string base64Data, Encoding encoding);
    [ExtensionAttribute]
public static string UnBase64(string base64Data);
    [ExtensionAttribute]
public static string UnBase64(string base64Data, Encoding encoding);
    [ExtensionAttribute]
public static T UnBase64(string base64Data, Func`2<string, T> deserializer);
    [ExtensionAttribute]
public static T UnBase64(string base64Data, Func`2<Byte[], T> deserializer);
    [ExtensionAttribute]
public static T UnBase64(string base64Data, Func`2<string, T> deserializer, Encoding encoding);
    [ExtensionAttribute]
public static string Base64Padded(string unpadded);
    [ExtensionAttribute]
public static string Base64UnPadded(string base64Data);
    [ExtensionAttribute]
public static string Outdent(string str);
    [ExtensionAttribute]
public static string Outdent(string str, int depth);
    [ExtensionAttribute]
public static String[] SplitIntoLines(string str);
    [ExtensionAttribute]
public static String[] MultiSplit(string str, string delimiter, String[] moreDelimiters);
    [ExtensionAttribute]
public static String[] Outdent(String[] lines, int depth);
    private static string FindFirstIndentationSequence(String[] lines);
    [ExtensionAttribute]
public static String[] Outdent(String[] lines, string indentedWith, int depth, bool alsoTrimEnd);
    private static int FindMinimumIndent(String[] lines, string indentedWith);
    [ExtensionAttribute]
public static bool TryParseHex(string str, Int32& parsed);
    [ExtensionAttribute]
public static String[] SplitOnce(string str, string splitOn);
    [ExtensionAttribute]
public static String[] SplitPath(string str);
    private static Regex get_PathSplitRegex();
    [ExtensionAttribute]
public static String[] SplitByRegex(string str, string regex);
    [ExtensionAttribute]
public static String[] SplitByRegex(string str, string regex, RegexOptions options);
    [ExtensionAttribute]
public static String[] SplitByRegex(string str, Regex regex);
    [ExtensionAttribute]
public static string ResolvePath(string path, String[] others);
    [ExtensionAttribute]
public static bool IsAbsolutePath(string str);
    [ExtensionAttribute]
public static string RelativeTo(string path, string basePath);
    [ExtensionAttribute]
public static string RelativeTo(string path, string basePath, PathType pathType);
    [ExtensionAttribute]
public static string AsPlatformPath(string path);
    [ExtensionAttribute]
public static bool ContainsInOrder(string haystack, String[] needles);
    [ExtensionAttribute]
public static bool ContainsInOrder(string haystack, StringComparison comparison, String[] needles);
    [ExtensionAttribute]
public static Byte[] GZip(string str);
    [ExtensionAttribute]
public static Byte[] GZip(string str, Encoding encoding);
    [CompilerGeneratedAttribute]
internal static bool <ResolvePath>g__IsRootPathElement|140_0(string str);
}
[ExtensionAttribute]
public static class PeanutButter.Utils.Stringifier : object {
    public static string DEFAULT_NULL_PLACEHOLDER;
    public static string SEEN_OBJECT_PLACEHOLDER;
    private static int MAX_STRINGIFY_DEPTH;
    private static int INDENT_SIZE;
    private static Dictionary`2<Type, Func`2<object, string>> PrimitiveStringifiers;
    private static String[] IgnoreAssembliesByName;
    private static Tuple`2[] Strategies;
    private static Dictionary`2<Type, bool> CustomToStringCache;
    private static HashSet`1<Type> BaseTypes;
    private static string EMPTY_OBJECT;
    private static Stringifier();
    [ExtensionAttribute]
public static string Stringify(IEnumerable`1<T> objs);
    private static string StringifyCollectionInternal(IEnumerable`1<T> objs, string nullRepresentation, int level, HashSet`1<object> seenObjects);
    [ExtensionAttribute]
public static string Stringify(object obj);
    [ExtensionAttribute]
public static void Dump(object obj);
    public static string Stringify(object obj, string nullRepresentation);
    private static string Stringify(object obj, string nullRepresentation, int level, HashSet`1<object> seenObjects);
    private static string StringifyXElement(object arg1, int arg2, string arg3, HashSet`1<object> seen);
    private static bool IsXElement(object arg1, int arg2);
    private static string StringifyXDocument(object arg1, int arg2, string arg3, HashSet`1<object> seen);
    private static bool IsXDocument(object obj, int level);
    private static string StringifyType(object obj, int level, string nullRep, HashSet`1<object> seen);
    private static bool IsType(object obj, int level);
    private static string StringifyDateTime(object obj, int level, string nullRep, HashSet`1<object> seen);
    private static bool IsDateTime(object obj, int level);
    private static string StringifyCollection(object obj, int level, string nullRep, HashSet`1<object> seen);
    private static bool IsEnumerable(object obj, int level);
    private static string StringifyEnum(object obj, int level, string nullRepresentation, HashSet`1<object> seen);
    private static bool IsEnum(object obj, int level);
    private static string JustToStringIt(object obj, int level, string nullRepresentation, HashSet`1<object> seen);
    private static bool LastPass(object arg1, int arg2);
    private static string PrintNull(object obj, int level, string nullRepresentation, HashSet`1<object> seenObjects);
    private static bool IsNull(object obj, int level);
    private static Tuple`2<Func`3<object, int, bool>, Func`5<object, int, string, HashSet`1<object>, string>> MakeStrategy(Func`3<object, int, bool> matcher, Func`5<object, int, string, HashSet`1<object>, string> writer);
    private static bool IsPrimitive(object obj, int level);
    private static bool Default(object obj, int level);
    private static string SafeStringifier(object obj, int level, string nullRepresentation, HashSet`1<object> seen);
    private static bool HasCustomToString(object o);
    private static string ApplyStrategy(Func`3<object, int, bool> matcher, Func`5<object, int, string, HashSet`1<object>, string> strategy, object obj, int level, string nullRepresentation, HashSet`1<object> seen);
    private static string StringifyJsonLike(object obj, int level, string nullRepresentation, HashSet`1<object> seen);
    private static string StringifyPrimitive(object obj, int level, string nullRep, HashSet`1<object> seen);
}
[ExtensionAttribute]
internal static class PeanutButter.Utils.StringifierStringExtensions : object {
    [ExtensionAttribute]
internal static string Compact(string str);
    [ExtensionAttribute]
private static string SquashEmptyObjects(string str);
}
public class PeanutButter.Utils.SuppressedTextStatusSteps : TextStatusSteps {
}
[ExtensionAttribute]
public static class PeanutButter.Utils.TaskExtensions : object {
    [ExtensionAttribute]
public static T GetResultSync(Task`1<T> task);
    [ExtensionAttribute]
public static void WaitSync(Task task);
}
public class PeanutButter.Utils.TextStatusSteps : object {
    private Func`2<string, Task> _asyncWriter;
    private Func`1<Task> _asyncFlushAction;
    private Func`2<Exception, Task`1<ErrorHandlerResult>> _asyncExceptionHandler;
    private Func`1<string> _prefixAllStatusLines;
    private string _startMarker;
    private string _completedMarker;
    private string _failedMarker;
    private Action`1<string> _writer;
    private Action _flushAction;
    private Func`2<Exception, ErrorHandlerResult> _exceptionHandler;
    private int _lastWriteLength;
    private Steps _steps;
    public static string DEFAULT_OK_LABEL;
    public static string DEFAULT_FAIL_LABEL;
    public static string DEFAULT_START_LABEL;
    private SemaphoreSlim _ioLock;
    public TextStatusSteps(string prefixAllStatusLines, string startMarker, string completedMarker, string failedMarker);
    public TextStatusSteps(string prefixAllStatusLines, string startMarker, string completedMarker, string failedMarker, Action`1<string> writer);
    public TextStatusSteps(string prefixAllStatusLines, string startMarker, string completedMarker, string failedMarker, Action`1<string> writer, Action flushAction);
    public TextStatusSteps(string prefixAllStatusLines, string startMarker, string completedMarker, string failedMarker, Action`1<string> writer, Action flushAction, Func`2<Exception, ErrorHandlerResult> exceptionHandler);
    public TextStatusSteps(Func`1<string> prefixAllStatusLines, string startMarker, string completedMarker, string failedMarker, Action`1<string> writer, Action flushAction, Func`2<Exception, ErrorHandlerResult> exceptionHandler);
    private TextStatusSteps(Func`1<string> prefixAllStatusLines, string startMarker, string completedMarker, string failedMarker);
    public TextStatusSteps(Func`1<string> prefixAllStatusLines, string startMarker, string completedMarker, string failedMarker, Func`2<string, Task> asyncWriter, Func`1<Task> asyncFlushAction, Func`2<Exception, Task`1<ErrorHandlerResult>> asyncExceptionHandler);
    public sealed virtual void Run(string label, Action activity);
    [AsyncStateMachineAttribute("PeanutButter.Utils.TextStatusSteps/<RunAsync>d__25")]
public sealed virtual Task RunAsync(string label, Func`1<Task> activity);
    public sealed virtual void Log(string str);
    [AsyncStateMachineAttribute("PeanutButter.Utils.TextStatusSteps/<LogAsync>d__27")]
public sealed virtual Task LogAsync(string str);
    private void Start(string label);
    [AsyncStateMachineAttribute("PeanutButter.Utils.TextStatusSteps/<StartAsync>d__29")]
private Task StartAsync(string label);
    private void Ok(string label);
    [AsyncStateMachineAttribute("PeanutButter.Utils.TextStatusSteps/<OkAsync>d__31")]
private Task OkAsync(string label);
    private void Fail(string label);
    [AsyncStateMachineAttribute("PeanutButter.Utils.TextStatusSteps/<FailAsync>d__33")]
private Task FailAsync(string label);
    private ErrorHandlerResult InvokeExceptionHandlerOrFail(Exception ex);
    [AsyncStateMachineAttribute("PeanutButter.Utils.TextStatusSteps/<InvokeExceptionHandlerOrFailAsync>d__35")]
private Task`1<ErrorHandlerResult> InvokeExceptionHandlerOrFailAsync(Exception ex);
    private void InvokeWriter(string toWrite);
    [AsyncStateMachineAttribute("PeanutButter.Utils.TextStatusSteps/<InvokeWriterAsync>d__37")]
private Task InvokeWriterAsync(string toWrite);
    private bool Wrote(string str);
    private void InvokeFlush();
    [AsyncStateMachineAttribute("PeanutButter.Utils.TextStatusSteps/<InvokeFlushAsync>d__40")]
private Task InvokeFlushAsync();
    private bool Flushed();
    private void ClearLastLine();
    [AsyncStateMachineAttribute("PeanutButter.Utils.TextStatusSteps/<ClearLastLineAsync>d__43")]
private Task ClearLastLineAsync();
    private void RunWithIoLocking(Action activity);
    [AsyncStateMachineAttribute("PeanutButter.Utils.TextStatusSteps/<RunWithIoLockingAsync>d__45")]
private Task RunWithIoLockingAsync(Func`1<Task> activity);
    private T RunWithIoLocking(Func`1<T> activity);
    [AsyncStateMachineAttribute("PeanutButter.Utils.TextStatusSteps/<RunWithIoLockingAsync>d__47`1")]
private Task`1<T> RunWithIoLockingAsync(Func`1<Task`1<T>> activity);
    [CompilerGeneratedAttribute]
private Task <InvokeFlush>b__39_0();
}
public class PeanutButter.Utils.TimeBasedRetryContext : object {
    private TimeSpan _maxRunTime;
    private Func`1<IBackoffStrategy> _defaultBackoffStrategyFactory;
    public TimeBasedRetryContext(TimeSpan maxRunTime, Func`1<IBackoffStrategy> defaultBackoffStrategyFactory);
    public void Do(Action action);
    public void Do(Action action, IBackoffStrategy backoffStrategy);
    public T Do(Func`1<T> func);
    public T Do(Func`1<T> func, IBackoffStrategy backoffStrategy);
}
[ExtensionAttribute]
public static class PeanutButter.Utils.TimeSpanExtensions : object {
    [ExtensionAttribute]
public static TimeSpan AddDays(TimeSpan ts, double howMany);
    [ExtensionAttribute]
public static TimeSpan AddHours(TimeSpan ts, double howMany);
    [ExtensionAttribute]
public static TimeSpan AddMinutes(TimeSpan ts, double howMany);
    [ExtensionAttribute]
public static TimeSpan AddSeconds(TimeSpan ts, double howMany);
    [ExtensionAttribute]
public static TimeSpan AddMilliseconds(TimeSpan ts, double howMany);
    [ExtensionAttribute]
public static TimeSpan TruncateMilliseconds(TimeSpan timeSpan);
    [ExtensionAttribute]
public static TimeSpan TruncateSeconds(TimeSpan timeSpan);
    [ExtensionAttribute]
public static TimeSpan TruncateMinutes(TimeSpan timeSpan);
    [ExtensionAttribute]
public static TimeSpan TruncateHours(TimeSpan timeSpan);
}
public class PeanutButter.Utils.TypeEqualityTester : object {
    [CompilerGeneratedAttribute]
private bool <SubMatch>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAssignmentEquivalence>k__BackingField;
    private List`1<string> _errors;
    private Type _master;
    private Type _compare;
    public IEnumerable`1<string> Errors { get; }
    public bool SubMatch { get; public set; }
    public bool AllowAssignmentEquivalence { get; public set; }
    public TypeEqualityTester(Type master, Type compare);
    internal TypeEqualityTester(Type master, Type compare, List`1<string> errorCollection);
    public IEnumerable`1<string> get_Errors();
    [CompilerGeneratedAttribute]
public bool get_SubMatch();
    [CompilerGeneratedAttribute]
public void set_SubMatch(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowAssignmentEquivalence();
    [CompilerGeneratedAttribute]
public void set_AllowAssignmentEquivalence(bool value);
    public bool AreDeepEquivalent();
    private bool ExactCompare(PropertyOrField[] masterMembers, PropertyOrField[] compareMembers);
    private bool TryFindComplexMatchFor(PropertyOrField master, PropertyOrField[] compareMembers);
    private bool DeepCompare(Type masterType, Type compareType);
    private bool TryFindPrimitiveMatchFor(PropertyOrField cur, PropertyOrField[] compareMembers);
    private bool AddError(string s);
    private PropertyOrField[] GetMembers(Type t);
    [CompilerGeneratedAttribute]
private bool <TryFindPrimitiveMatchFor>b__19_0(PropertyOrField o1, PropertyOrField o2);
}
[ExtensionAttribute]
public static class PeanutButter.Utils.TypeExtensions : object {
    private static MethodInfo GenericIsAssignableFromArrayOf;
    private static ConcurrentDictionary`2<Type, Type> CollectionTypeCache;
    private static Type DisposableInterface;
    private static Type[] CollectionGenerics;
    private static ConcurrentDictionary`2<Type, object> DefaultTypeValues;
    private static Type ObjectType;
    private static HashSet`1<Type> NumericTypes;
    private static MethodInfo TryConvertGeneric;
    private static MethodInfo DefaultValueGeneric;
    private static HashSet`1<string> _objectMethods;
    private static BindingFlags PUBLIC_INSTANCE;
    private static MethodInfo GenericGetDefaultValueMethod;
    private static ConcurrentDictionary`2<Type, bool> NullableTypes;
    private static ConcurrentDictionary`2<Tuple`3<Type, Type, bool>, Attribute[]> TypeAttributeCache;
    private static ConcurrentDictionary`2<Tuple`3<MethodInfo, Type, bool>, Attribute[]> MethodAttributeCache;
    private static ConcurrentDictionary`2<Tuple`3<PropertyInfo, Type, bool>, Attribute[]> PropertyAttributeCache;
    private static HashSet`1<string> NonVirtualObjectMethods { get; }
    private static TypeExtensions();
    [ExtensionAttribute]
public static Type[] Ancestry(Type type);
    [ExtensionAttribute]
public static Type[] AncestryUntil(Type type, Type from);
    [IteratorStateMachineAttribute("PeanutButter.Utils.TypeExtensions/<WalkAncestry>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<Type> WalkAncestry(Type type, Type oldest);
    [ExtensionAttribute]
public static Dictionary`2<string, object> GetAllConstants(Type type);
    [ExtensionAttribute]
public static Dictionary`2<string, T> GetAllConstants(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<object> GetAllConstantValues(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAllConstantValues(Type type);
    [ExtensionAttribute]
public static bool HasDefaultConstructor(Type type);
    [ExtensionAttribute]
public static bool IsArrayOrAssignableFromArray(Type t);
    [ExtensionAttribute]
public static bool IsEnum(Type t);
    [ExtensionAttribute]
public static MethodInfo GetMethod(Type t, string name, BindingFlags flags);
    [ExtensionAttribute]
public static PropertyInfo[] GetProperties(Type t);
    [ExtensionAttribute]
public static PropertyInfo GetProperty(Type t, string name);
    [ExtensionAttribute]
public static PropertyInfo GetProperty(Type t, string name, BindingFlags flags);
    [ExtensionAttribute]
public static PropertyInfo[] GetProperties(Type t, BindingFlags flags);
    [ExtensionAttribute]
public static FieldInfo[] GetFields(Type t, BindingFlags flags);
    [ExtensionAttribute]
public static bool IsAssignableFrom(Type t, Type other);
    [ExtensionAttribute]
public static Type[] GetInterfaces(Type t);
    [ExtensionAttribute]
public static Type[] GetGenericArguments(Type t);
    [ExtensionAttribute]
public static Assembly GetAssembly(Type t);
    [ExtensionAttribute]
public static Type BaseType(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type t);
    [ExtensionAttribute]
public static bool IsGenericOf(Type t, Type genericTest);
    [ExtensionAttribute]
public static bool IsAssignableFromArrayOf(Type t);
    [ExtensionAttribute]
public static bool ImplementsEnumerableGenericType(Type t);
    [ExtensionAttribute]
public static bool ImplementsIDictionaryGenericType(Type type);
    [ExtensionAttribute]
public static bool IsIDictionary(Type type);
    [ExtensionAttribute]
public static bool TryGetDictionaryKeyAndValueTypes(Type type, Type& keyType, Type& valueType);
    [ExtensionAttribute]
public static Type TryGetEnumerableInterface(Type srcType);
    [ExtensionAttribute]
public static Type TryGetEnumerableItemType(Type srcType);
    [ExtensionAttribute]
public static bool IsGenericOfIEnumerable(Type arg);
    [ExtensionAttribute]
public static bool IsEnumerable(Type arg);
    [ExtensionAttribute]
public static bool HasMethod(Type t, string methodName);
    [ExtensionAttribute]
public static bool HasVoidMethod(Type t, string methodName, Type[] parameters);
    [ExtensionAttribute]
public static bool HasMethod(Type t, string name, Type returnType, Type[] parameterTypes);
    [ExtensionAttribute]
public static Type GetCollectionItemType(Type collectionType);
    [ExtensionAttribute]
public static Type[] GetAllImplementedInterfaces(Type inspectType);
    [ExtensionAttribute]
public static bool IsDisposable(Type t);
    [ExtensionAttribute]
public static string PrettyName(Type type);
    [ExtensionAttribute]
public static bool IsCollection(Type type);
    [ExtensionAttribute]
public static bool CanBeAssignedNull(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static bool IsAssignableOrUpCastableTo(Type src, Type target);
    [ExtensionAttribute]
public static bool CanImplicitlyCastTo(Type source, Type target);
    [ExtensionAttribute]
public static bool TryImplicitlyCastTo(object srcValue, Type targetType, Object& castValue);
    [ExtensionAttribute]
public static object DefaultValue(Type type);
    [ExtensionAttribute]
public static bool IsInterface(Type type);
    [ExtensionAttribute]
public static bool IsNumericType(Type type);
    [ExtensionAttribute]
public static bool IsAncestorOf(Type type, Type test);
    [ExtensionAttribute]
public static bool Inherits(Type type, Type test);
    private static bool TypesMatch(Type[] typeParams, Type[] testParams);
    [ExtensionAttribute]
public static bool Implements(Type type);
    [ExtensionAttribute]
public static bool Implements(Type type, Type interfaceType);
    private static T2 TryConvert(T2 value);
    private static T DefaultValue();
    [ExtensionAttribute]
public static bool AllPublicInstancePropertiesAndMethodsAreVirtualOrAbstractAndNonFinal(Type type);
    [ExtensionAttribute]
public static bool AllPublicInstancePropertiesAndMethodsAreNonFinal(Type type);
    [ExtensionAttribute]
public static bool AllPublicInstanceMethodsAreNonFinal(Type type);
    [ExtensionAttribute]
public static bool AllPublicInstancePropertiesAreNonFinal(Type type);
    [ExtensionAttribute]
public static bool AllPublicInstancePropertiesAndMethodsAreVirtualOrAbstract(Type type);
    [ExtensionAttribute]
public static bool AllPublicInstancePropertiesAreVirtualOrAbstract(Type type);
    [ExtensionAttribute]
public static bool AllPublicInstanceMethodsAreVirtualOrAbstract(Type type);
    private static HashSet`1<string> get_NonVirtualObjectMethods();
    [ExtensionAttribute]
public static T GetTopMostPropertyValue(object data, string propertyName);
    [ExtensionAttribute]
public static void SetTopMostProperty(object data, string propertyName, T value);
    [ExtensionAttribute]
internal static PropertyInfo FindTopMostProperty(object data, string propertyName);
    [ExtensionAttribute]
public static bool IsVirtualOrAbstract(MethodInfo methodInfo);
    [ExtensionAttribute]
public static bool IsConcrete(Type t);
    [ExtensionAttribute]
public static bool IsVirtualOrAbstract(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static bool IsFinal(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static bool Implements(T obj, Type expected);
    [ExtensionAttribute]
public static bool IsNullableType(Type arg);
    private static T GetDefaultValueFor();
    [ExtensionAttribute]
public static void SetStatic(Type t, string fieldOrPropertyName, T value);
    [ExtensionAttribute]
public static T GetStatic(Type t, string fieldOrPropertyName);
    [ExtensionAttribute]
public static bool IsPrimitiveOrImmutable(Type type);
    [ExtensionAttribute]
public static Type ResolveNullableUnderlyingType(Type type);
    [ExtensionAttribute]
public static bool HasAttribute(Type type);
    [ExtensionAttribute]
public static bool HasAttribute(Type type, Func`2<TAttribute, bool> matcher);
    [ExtensionAttribute]
public static bool HasAttribute(Type type, bool inherit, Func`2<TAttribute, bool> matcher);
    [ExtensionAttribute]
public static bool HasAttribute(Type type, bool inherit);
    [ExtensionAttribute]
public static bool HasAttribute(Type type, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static bool HasAttribute(Type type, Type attributeType, bool inherit, Func`2<Attribute, bool> matcher);
    [ExtensionAttribute]
public static bool HasAttribute(MethodInfo methodInfo);
    [ExtensionAttribute]
public static bool HasAttribute(MethodInfo methodInfo, Func`2<TAttribute, bool> matcher);
    [ExtensionAttribute]
public static bool HasAttribute(MethodInfo methodInfo, bool inherit);
    [ExtensionAttribute]
public static bool HasAttribute(MethodInfo methodInfo, bool inherit, Func`2<TAttribute, bool> matcher);
    [ExtensionAttribute]
public static bool HasAttribute(ParameterInfo parameterInfo);
    [ExtensionAttribute]
public static bool HasAttribute(ParameterInfo parameterInfo, Func`2<TAttribute, bool> matcher);
    [ExtensionAttribute]
public static bool HasAttribute(ParameterInfo parameterInfo, Type attributeType);
    [ExtensionAttribute]
public static bool HasAttribute(ParameterInfo parameterInfo, Type attributeType, Func`2<Attribute, bool> matcher);
    [ExtensionAttribute]
public static bool HasAttribute(MethodInfo methodInfo, Type attributeType, bool inherit);
    private static bool AcceptAll(T _);
    [ExtensionAttribute]
public static bool HasAttribute(MethodInfo methodInfo, Type attributeType, bool inherit, Func`2<Attribute, bool> matcher);
    [ExtensionAttribute]
public static bool HasAttribute(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static bool HasAttribute(PropertyInfo propertyInfo, bool inherit);
    [ExtensionAttribute]
public static bool HasAttribute(PropertyInfo propertyInfo, bool inherit, Func`2<TAttribute, bool> matcher);
    [ExtensionAttribute]
public static bool HasAttribute(PropertyInfo propertyInfo, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static bool HasAttribute(PropertyInfo propertyInfo, Type attributeType, bool inherit, Func`2<Attribute, bool> matcher);
    [ExtensionAttribute]
public static bool IsCompilerGenerated(Type type);
    [ExtensionAttribute]
public static bool LooksAnonymous(Type type);
    [ExtensionAttribute]
public static bool HasOnlyParameterlessConstructor(Type type);
    [ExtensionAttribute]
public static bool HasParameterlessConstructor(Type type);
    private static void DetermineConstructorInfoFor(Type type, Int32& constructorCount, Boolean& hasParameterlessConstructor);
    [IteratorStateMachineAttribute("PeanutButter.Utils.TypeExtensions/<WalkAttributes>d__121")]
[ExtensionAttribute]
public static IEnumerable`1<AttributeWalkStep> WalkAttributes(Type type);
    [CompilerGeneratedAttribute]
internal static Type <GetCollectionItemType>g__Cache|36_0(Type itemType, <>c__DisplayClass36_0& );
}
public static class PeanutButter.Utils.TypeFinder : object {
    private static ConcurrentDictionary`2<string, int> AssemblyMissCache;
    private static ConcurrentDictionary`2<string, Type> TypeLookup;
    private static ConcurrentDictionary`2<string, Type> CaseInsensitiveTypeLookup;
    private static ConcurrentDictionary`2<Assembly, Type[]> AssemblyTypes;
    private static TypeFinder();
    public static Type TryFind(string name);
    public static Type TryFind(string name, Assembly assembly, Assembly[] moreAssemblies);
    public static Type TryFind(string name, StringComparison stringComparison, Assembly[] assemblies);
    private static int GenerateHashOf(Assembly[] assemblies);
    private static Type FindBestNameMatch(Type[] types, string name, StringComparison stringComparison, bool testFullName);
    public static Type[] FindTypesIn(Assembly assembly);
}
internal static class PeanutButter.Utils.Types : object {
    public static HashSet`1<Type> PrimitivesAndImmutables;
    private static Types();
}
internal class PeanutButter.Utils.UnableToFindOpenPortException : Exception {
    [CompilerGeneratedAttribute]
private IPAddress <IPAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinPort>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxPort>k__BackingField;
    public IPAddress IPAddress { get; }
    public int MinPort { get; }
    public int MaxPort { get; }
    public UnableToFindOpenPortException(IPAddress forAddress, int min, int max);
    [CompilerGeneratedAttribute]
public IPAddress get_IPAddress();
    [CompilerGeneratedAttribute]
public int get_MinPort();
    [CompilerGeneratedAttribute]
public int get_MaxPort();
}
public class PeanutButter.Utils.UnevenZipException : Exception {
}
public class PeanutButter.Utils.UnevenZipException`2 : UnevenZipException {
    [CompilerGeneratedAttribute]
private IEnumerable`1<T1> <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<T2> <Right>k__BackingField;
    public IEnumerable`1<T1> Left { get; }
    public IEnumerable`1<T2> Right { get; }
    public UnevenZipException`2(IEnumerable`1<T1> left, IEnumerable`1<T2> right);
    [CompilerGeneratedAttribute]
public IEnumerable`1<T1> get_Left();
    [CompilerGeneratedAttribute]
public IEnumerable`1<T2> get_Right();
}
[ExtensionAttribute]
public static class PeanutButter.Utils.UriExtensions : object {
    [ExtensionAttribute]
public static Uri Root(Uri uri);
    [ExtensionAttribute]
public static string UriRoot(string str);
}
internal static class PeanutButter.Utils.Validate : object {
    public static Validator`1<T> That(T value);
    public static Validator`1<T> That(T value, string parameterName);
}
internal class PeanutButter.Utils.Validator`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public T Value { get; }
    public string ParameterName { get; }
    public Validator`1(T value, string parameterName);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public string get_ParameterName();
    public ValidatorAnd`1<T> IsNotNull();
}
internal class PeanutButter.Utils.ValidatorAnd`1 : Validator`1<T> {
    public ValidatorAnd`1<T> And { get; }
    public ValidatorAnd`1(T value);
    public ValidatorAnd`1<T> get_And();
    public Validator`1<TNext> That(TNext value);
    public Validator`1<TNext> That(TNext value, string parameterName);
}
[ExtensionAttribute]
public static class PeanutButter.Utils.WebObjectExtensions : object {
    [ExtensionAttribute]
public static string AsQueryString(object o);
    [ExtensionAttribute]
public static string AsQueryStringParameters(object o);
    [ExtensionAttribute]
public static IDictionary`2<string, object> AsDictionary(object obj);
}
public abstract class PeanutButter.Utils.Worker : object {
    [CompilerGeneratedAttribute]
private int <DefaultMaxDegreeOfParallelism>k__BackingField;
    public int DefaultMaxDegreeOfParallelism { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_DefaultMaxDegreeOfParallelism();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DefaultMaxDegreeOfParallelism(int value);
}
public class PeanutButter.Utils.WorkResult : object {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public Exception Exception { get; }
    internal WorkResult(Exception ex);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
}
public class PeanutButter.Utils.WorkResult`1 : WorkResult {
    [CompilerGeneratedAttribute]
private T <Result>k__BackingField;
    public T Result { get; }
    internal WorkResult`1(T result);
    internal WorkResult`1(Exception ex);
    [CompilerGeneratedAttribute]
public T get_Result();
}
[ExtensionAttribute]
public static class PeanutButter.Utils.WorkResultExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<T> Results(IEnumerable`1<WorkResult`1<T>> workResults);
    [ExtensionAttribute]
public static IEnumerable`1<T> Results(IEnumerable`1<WorkResult`1<T>> workResults, ErrorStrategies errorStrategy);
    [ExtensionAttribute]
public static Exception[] Errors(IEnumerable`1<WorkResult`1<T>> workResults);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
