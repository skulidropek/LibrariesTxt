internal static class PeterO.Numbers.BigNumberFlags : object {
    internal static int FlagNegative;
    internal static int FlagQuietNaN;
    internal static int FlagSignalingNaN;
    internal static int FlagInfinity;
    internal static int FlagSpecial;
    internal static int FlagNaN;
    internal static int LostDigitsFlags;
    internal static int FiniteOnly;
    internal static int FiniteAndNonFinite;
}
internal class PeterO.Numbers.BitShiftAccumulator : object {
    private static int SmallBitLength;
    private int bitLeftmost;
    private int bitsAfterLeftmost;
    private EInteger shiftedBigInt;
    private FastInteger knownBitLength;
    private int shiftedSmall;
    private bool isSmall;
    private FastInteger discardedBitCount;
    public int LastDiscardedDigit { get; }
    public int OlderDiscardedDigits { get; }
    public EInteger ShiftedInt { get; }
    public FastInteger ShiftedIntFast { get; }
    public FastInteger DiscardedDigitCount { get; }
    public BitShiftAccumulator(EInteger bigint, int lastDiscarded, int olderDiscarded);
    public BitShiftAccumulator(int smallint, int lastDiscarded, int olderDiscarded);
    public sealed virtual int get_LastDiscardedDigit();
    public sealed virtual int get_OlderDiscardedDigits();
    public sealed virtual FastInteger GetDigitLength();
    public sealed virtual FastInteger OverestimateDigitLength();
    private static void VerifyKnownLength();
    public sealed virtual void ShiftToDigits(FastInteger bits, FastInteger preShift, bool truncate);
    public sealed virtual EInteger get_ShiftedInt();
    public sealed virtual FastInteger get_ShiftedIntFast();
    public sealed virtual int ShiftedIntMod(int mod);
    public sealed virtual FastInteger get_DiscardedDigitCount();
    public static BitShiftAccumulator FromInt32(int smallNumber);
    public sealed virtual void TruncateOrShiftRight(FastInteger fastint, bool truncate);
    public void ShiftRight(FastInteger fastint);
    private void ShiftRightBig(int bits);
    private FastInteger CalcKnownBitLength();
    private void ShiftBigToBits(int bits);
    public sealed virtual void ShiftRightInt(int bits);
    private void ShiftRightSmall(int bits);
    public void ShiftToDigitsInt(int bits);
    private void ShiftSmallToBits(int bits);
}
internal class PeterO.Numbers.DigitShiftAccumulator : object {
    private static Int64[] TenPowersLong;
    private static EInteger ValueTen;
    private static Int32[] ValueTenPowers;
    private int bitLeftmost;
    private int bitsAfterLeftmost;
    private FastInteger discardedDigitCount;
    private bool isSmall;
    private FastInteger knownDigitLength;
    private EInteger shiftedBigInt;
    private int shiftedSmall;
    public FastInteger DiscardedDigitCount { get; }
    public int LastDiscardedDigit { get; }
    public int OlderDiscardedDigits { get; }
    public EInteger ShiftedInt { get; }
    public FastInteger ShiftedIntFast { get; }
    public DigitShiftAccumulator(EInteger bigint, int lastDiscarded, int olderDiscarded);
    public DigitShiftAccumulator(int smallint, int lastDiscarded, int olderDiscarded);
    private static DigitShiftAccumulator();
    public virtual string ToString();
    public sealed virtual FastInteger get_DiscardedDigitCount();
    public sealed virtual int get_LastDiscardedDigit();
    public sealed virtual int get_OlderDiscardedDigits();
    public sealed virtual EInteger get_ShiftedInt();
    public sealed virtual int ShiftedIntMod(int mod);
    public sealed virtual FastInteger get_ShiftedIntFast();
    public sealed virtual FastInteger GetDigitLength();
    public sealed virtual FastInteger OverestimateDigitLength();
    private FastInteger UnderestimateDigitLength();
    public void ShiftRight(FastInteger fastint);
    public sealed virtual void ShiftRightInt(int digits);
    public sealed virtual void ShiftToDigits(FastInteger bits, FastInteger preShift, bool truncate);
    public bool TruncateRightExact(FastInteger fastint);
    public void TruncateRightSimple(FastInteger fastint);
    public sealed virtual void TruncateOrShiftRight(FastInteger fastint, bool truncate);
    private static int FastParseLong(string str, int offset, int length);
    private static EInteger DivideByPowerOfTen(EInteger ei, int pow);
    private FastInteger CalcKnownDigitLength();
    private void UpdateKnownLengthInt(int digits);
    private void UpdateKnownLength(FastInteger digitsShiftedFast);
    private void ShiftRightBig(int digits, bool truncate, bool simple);
    private void ShiftRightLong(long shiftedLong, int digits);
    private void ShiftToDigitsBig(int digits, bool truncate);
    private void ShiftToDigitsSmall(int digits);
    private void TruncateRightLong(long shiftedLong, int digits);
    private void ShiftRightSmall(int digits);
    private void TruncateRightSmall(int digits);
}
public class PeterO.Numbers.EContext : object {
    public static int FlagClamped;
    public static int FlagDivideByZero;
    public static int FlagInexact;
    public static int FlagInvalid;
    public static int FlagLostDigits;
    public static int FlagOverflow;
    public static int FlagRounded;
    public static int FlagSubnormal;
    public static int FlagUnderflow;
    public static EContext Basic;
    public static EContext BigDecimalJava;
    public static EContext Binary128;
    public static EContext Binary16;
    public static EContext Binary32;
    public static EContext Binary64;
    public static EContext CliDecimal;
    public static EContext Decimal128;
    public static EContext Decimal32;
    public static EContext Decimal64;
    public static EContext Unlimited;
    public static EContext UnlimitedHalfEven;
    private bool adjustExponent;
    private EInteger bigintPrecision;
    private bool clampNormalExponents;
    private EInteger exponentMax;
    private EInteger exponentMin;
    private bool hasExponentRange;
    private bool hasFlags;
    private bool precisionInBits;
    private ERounding rounding;
    private bool simplified;
    private int traps;
    private int flags;
    private static EContext ForRoundingHalfEven;
    private static EContext ForRoundingDown;
    public bool AdjustExponent { get; }
    public bool ClampNormalExponents { get; }
    public EInteger EMax { get; }
    public EInteger EMin { get; }
    public int Flags { get; public set; }
    public bool HasExponentRange { get; }
    public bool HasFlags { get; }
    public bool HasMaxPrecision { get; }
    public bool IsPrecisionInBits { get; }
    public bool IsSimplified { get; }
    public EInteger Precision { get; }
    public ERounding Rounding { get; }
    public int Traps { get; }
    public bool HasFlagsOrTraps { get; }
    private EContext(bool adjustExponent, EInteger bigintPrecision, bool clampNormalExponents, EInteger exponentMax, EInteger exponentMin, int flags, bool hasExponentRange, bool hasFlags, bool precisionInBits, ERounding rounding, bool simplified, int traps);
    public EContext(int precision, ERounding rounding, int exponentMinSmall, int exponentMaxSmall, bool clampNormalExponents);
    public EContext(EInteger bigintPrecision, ERounding rounding, EInteger exponentMin, EInteger exponentMax, bool clampNormalExponents);
    private static EContext();
    public bool get_AdjustExponent();
    public bool get_ClampNormalExponents();
    public EInteger get_EMax();
    public EInteger get_EMin();
    public int get_Flags();
    public void set_Flags(int value);
    public bool get_HasExponentRange();
    public bool get_HasFlags();
    public bool get_HasMaxPrecision();
    public bool get_IsPrecisionInBits();
    public bool get_IsSimplified();
    public EInteger get_Precision();
    public ERounding get_Rounding();
    public int get_Traps();
    public static EContext ForPrecision(int precision);
    public static EContext ForPrecisionAndRounding(int precision, ERounding rounding);
    public static EContext ForRounding(ERounding rounding);
    public EContext Copy();
    public bool ExponentWithinRange(EInteger exponent);
    public virtual string ToString();
    public bool get_HasFlagsOrTraps();
    public EContext WithAdjustExponent(bool adjustExponent);
    public EContext WithBigExponentRange(EInteger exponentMin, EInteger exponentMax);
    public EContext WithNoFlagsOrTraps();
    public EContext WithBigPrecision(EInteger bigintPrecision);
    public EContext WithBlankFlags();
    public EContext WithExponentClamp(bool clamp);
    public EContext WithExponentRange(int exponentMinSmall, int exponentMaxSmall);
    public EContext WithNoFlags();
    public EContext WithPrecision(int precision);
    public EContext WithPrecisionInBits(bool isPrecisionBits);
    public EContext WithRounding(ERounding rounding);
    public EContext WithSimplified(bool simplified);
    public EContext WithTraps(int traps);
    public EContext WithUnlimitedExponents();
    public EContext GetNontrapping();
    public T TriggerTraps(T result, EContext trappableContext);
}
public class PeterO.Numbers.EDecimal : object {
    private static int RepeatDivideThreshold;
    internal static int MaxSafeInt;
    public static EDecimal NaN;
    public static EDecimal NegativeInfinity;
    public static EDecimal NegativeZero;
    public static EDecimal One;
    public static EDecimal PositiveInfinity;
    public static EDecimal SignalingNaN;
    public static EDecimal Ten;
    public static EDecimal Zero;
    private static int CacheFirst;
    private static int CacheLast;
    private static EDecimal[] Cache;
    private static DecimalMathHelper HelperValue;
    private static IRadixMath`1<EDecimal> ExtendedMathValue;
    private static IRadixMath`1<EDecimal> MathValue;
    private static Int32[] ValueTenPowers;
    private FastIntegerFixed unsignedMantissa;
    private FastIntegerFixed exponent;
    private byte flags;
    public EInteger Exponent { get; }
    public bool IsFinite { get; }
    public bool IsNegative { get; }
    public bool IsZero { get; }
    public EInteger Mantissa { get; }
    public int Sign { get; }
    public EInteger UnsignedMantissa { get; }
    internal EDecimal(FastIntegerFixed unsignedMantissa, FastIntegerFixed exponent, byte flags);
    private static EDecimal();
    internal static EDecimal FromCache(int v);
    private static EDecimal[] EDecimalCache(int first, int last);
    public EDecimal Copy();
    public EInteger get_Exponent();
    public bool get_IsFinite();
    public bool get_IsNegative();
    public bool get_IsZero();
    public bool IsInteger();
    public EInteger get_Mantissa();
    public int get_Sign();
    public EInteger get_UnsignedMantissa();
    internal static EDecimal ChangeExponent(EDecimal ret, EInteger exponent);
    public static EDecimal Create(int mantissaSmall, int exponentSmall);
    public static EDecimal Create(EInteger mantissa, int exponentSmall);
    public static EDecimal Create(EInteger mantissa, long exponentLong);
    public static EDecimal Create(EInteger mantissa, EInteger exponent);
    public static EDecimal Create(long mantissaLong, int exponentSmall);
    public static EDecimal Create(long mantissaLong, long exponentLong);
    public static EDecimal CreateNaN(EInteger diag);
    public static EDecimal CreateNaN(EInteger diag, bool signaling, bool negative, EContext ctx);
    public static EDecimal FromDouble(double dbl);
    public static EDecimal FromDoubleBits(long dblBits);
    public static EDecimal FromEInteger(EInteger bigint);
    [ObsoleteAttribute("Renamed to FromEFloat.")]
public static EDecimal FromExtendedFloat(EFloat ef);
    public static EDecimal FromEFloat(EFloat bigfloat);
    public static EDecimal FromBoolean(bool boolValue);
    public static EDecimal FromInt32(int valueSmaller);
    public static EDecimal FromInt64AsUnsigned(long longerValue);
    public static EDecimal FromInt64(long valueSmall);
    public static EDecimal FromSingle(float flt);
    public static EDecimal FromSingleBits(int value);
    public static EDecimal FromString(Char[] chars);
    public static EDecimal FromString(Char[] chars, EContext ctx);
    public static EDecimal FromString(Char[] chars, int offset, int length);
    public static EDecimal FromString(Char[] chars, int offset, int length, EContext ctx);
    public static EDecimal FromString(Byte[] bytes);
    public static EDecimal FromString(Byte[] bytes, EContext ctx);
    public static EDecimal FromString(Byte[] bytes, int offset, int length);
    public static EDecimal FromString(Byte[] bytes, int offset, int length, EContext ctx);
    public static EDecimal FromString(string str);
    public static EDecimal FromString(string str, EContext ctx);
    public static EDecimal FromString(string str, int offset, int length);
    public static EDecimal FromString(string str, int offset, int length, EContext ctx);
    internal static EDecimal SignalUnderflow(EContext ec, bool negative, bool zeroSignificand);
    internal static EDecimal SignalOverflow(EContext ec, bool negative, bool zeroSignificand);
    internal static int CheckOverflowUnderflow(EContext ec, int precisionInt, EInteger exponent);
    public static EDecimal Max(EDecimal first, EDecimal second, EContext ctx);
    public static EDecimal Max(EDecimal first, EDecimal second);
    public static EDecimal MaxMagnitude(EDecimal first, EDecimal second, EContext ctx);
    public static EDecimal MaxMagnitude(EDecimal first, EDecimal second);
    public static EDecimal Min(EDecimal first, EDecimal second, EContext ctx);
    public static EDecimal Min(EDecimal first, EDecimal second);
    public static EDecimal MinMagnitude(EDecimal first, EDecimal second, EContext ctx);
    public static EDecimal MinMagnitude(EDecimal first, EDecimal second);
    public static EDecimal PI(EContext ctx);
    public EDecimal Abs();
    public EDecimal CopySign(EDecimal other);
    public EDecimal Abs(EContext context);
    public EDecimal Add(EDecimal otherValue);
    public EDecimal Add(EDecimal otherValue, EContext ctx);
    public sealed virtual int CompareTo(EDecimal other);
    public int CompareTo(int intOther);
    public int CompareToValue(int intOther);
    public int CompareTo(long intOther);
    public int CompareToValue(long intOther);
    public int CompareToValue(EDecimal other);
    public int CompareToBinary(EFloat other);
    private static int CompareEDecimalToEFloat(EDecimal ed, EFloat ef);
    public EDecimal CompareToSignal(EDecimal other, EContext ctx);
    public int CompareToTotalMagnitude(EDecimal other);
    public int CompareToTotal(EDecimal other, EContext ctx);
    public int CompareToTotalMagnitude(EDecimal other, EContext ctx);
    public int CompareToTotal(EDecimal other);
    public EDecimal CompareToWithContext(EDecimal other, EContext ctx);
    public EDecimal Divide(EDecimal divisor);
    public EDecimal Divide(EDecimal divisor, EContext ctx);
    [ObsoleteAttribute("Renamed to DivRemNaturalScale.")]
public EDecimal[] DivideAndRemainderNaturalScale(EDecimal divisor);
    [ObsoleteAttribute("Renamed to DivRemNaturalScale.")]
public EDecimal[] DivideAndRemainderNaturalScale(EDecimal divisor, EContext ctx);
    public EDecimal[] DivRemNaturalScale(EDecimal divisor);
    public EDecimal[] DivRemNaturalScale(EDecimal divisor, EContext ctx);
    public EDecimal DivideToExponent(EDecimal divisor, long desiredExponentSmall, EContext ctx);
    public EDecimal DivideToExponent(EDecimal divisor, int desiredExponentInt, EContext ctx);
    public EDecimal DivideToExponent(EDecimal divisor, long desiredExponentSmall, ERounding rounding);
    public EDecimal DivideToExponent(EDecimal divisor, int desiredExponentInt, ERounding rounding);
    public EDecimal DivideToExponent(EDecimal divisor, EInteger exponent, EContext ctx);
    public EDecimal DivideToExponent(EDecimal divisor, EInteger exponent);
    public EDecimal DivideToExponent(EDecimal divisor, long desiredExponentSmall);
    public EDecimal DivideToExponent(EDecimal divisor, int desiredExponentInt);
    public EDecimal DivideToExponent(EDecimal divisor, EInteger desiredExponent, ERounding rounding);
    public EDecimal DivideToIntegerNaturalScale(EDecimal divisor);
    public EDecimal DivideToIntegerNaturalScale(EDecimal divisor, EContext ctx);
    public EDecimal DivideToIntegerZeroScale(EDecimal divisor, EContext ctx);
    public EDecimal DivideToSameExponent(EDecimal divisor, ERounding rounding);
    public sealed virtual bool Equals(EDecimal other);
    public virtual bool Equals(object obj);
    public EDecimal Exp(EContext ctx);
    public EDecimal ExpM1(EContext ctx);
    public virtual int GetHashCode();
    public bool IsInfinity();
    public bool IsNaN();
    public bool IsNegativeInfinity();
    public bool IsPositiveInfinity();
    public bool IsQuietNaN();
    public bool IsSignalingNaN();
    public EDecimal Log(EContext ctx);
    public EDecimal Log10(EContext ctx);
    public EDecimal Log1P(EContext ctx);
    public EDecimal LogN(EDecimal baseValue, EContext ctx);
    public EDecimal MovePointLeft(int places);
    public EDecimal MovePointLeft(int places, EContext ctx);
    public EDecimal MovePointLeft(EInteger bigPlaces);
    public EDecimal MovePointLeft(EInteger bigPlaces, EContext ctx);
    public EDecimal MovePointRight(int places);
    public EDecimal MovePointRight(int places, EContext ctx);
    public EDecimal MovePointRight(EInteger bigPlaces);
    public EDecimal MovePointRight(EInteger bigPlaces, EContext ctx);
    public EDecimal Multiply(EDecimal otherValue);
    public EDecimal Multiply(EDecimal op, EContext ctx);
    public EDecimal Add(long longValue);
    public EDecimal Subtract(long longValue);
    public EDecimal Multiply(long longValue);
    public EDecimal Divide(long longValue);
    public EDecimal Add(int intValue);
    public EDecimal Subtract(int intValue);
    public EDecimal Multiply(int intValue);
    public EDecimal Divide(int intValue);
    public EDecimal MultiplyAndAdd(EDecimal multiplicand, EDecimal augend);
    public EDecimal MultiplyAndAdd(EDecimal op, EDecimal augend, EContext ctx);
    public EDecimal MultiplyAndSubtract(EDecimal op, EDecimal subtrahend, EContext ctx);
    public EDecimal Negate();
    public EDecimal Negate(EContext context);
    public EDecimal NextMinus(EContext ctx);
    public EDecimal NextPlus(EContext ctx);
    public EDecimal NextToward(EDecimal otherValue, EContext ctx);
    public EDecimal Plus(EContext ctx);
    public EDecimal Pow(EDecimal exponent, EContext ctx);
    public EDecimal Pow(EDecimal exponent);
    public EDecimal Pow(int exponentSmall, EContext ctx);
    public EDecimal Pow(int exponentSmall);
    public EInteger Precision();
    public EDecimal Quantize(EInteger desiredExponent, EContext ctx);
    public EDecimal Quantize(int desiredExponentInt, ERounding rounding);
    public EDecimal Quantize(int desiredExponentInt, EContext ctx);
    public EDecimal Quantize(EDecimal otherValue, EContext ctx);
    public EDecimal Reduce(EContext ctx);
    public EDecimal Remainder(EDecimal divisor, EContext ctx);
    public EDecimal RemainderNoRoundAfterDivide(EDecimal divisor, EContext ctx);
    public EDecimal RemainderNaturalScale(EDecimal divisor);
    public EDecimal RemainderNaturalScale(EDecimal divisor, EContext ctx);
    public EDecimal RemainderNear(EDecimal divisor, EContext ctx);
    public EDecimal RoundToExponent(EInteger exponent, EContext ctx);
    public EDecimal RoundToExponent(EInteger exponent);
    public EDecimal RoundToExponent(EInteger exponent, ERounding rounding);
    public EDecimal RoundToExponent(int exponentSmall);
    public EDecimal RoundToExponent(int exponentSmall, EContext ctx);
    public EDecimal RoundToExponent(int exponentSmall, ERounding rounding);
    public EDecimal RoundToExponentExact(EInteger exponent, EContext ctx);
    public EDecimal RoundToExponentExact(int exponentSmall, EContext ctx);
    public EDecimal RoundToExponentExact(int exponentSmall, ERounding rounding);
    public EDecimal RoundToIntegerExact(EContext ctx);
    public EDecimal RoundToIntegerNoRoundedFlag(EContext ctx);
    [ObsoleteAttribute("Renamed to RoundToIntegerExact.")]
public EDecimal RoundToIntegralExact(EContext ctx);
    [ObsoleteAttribute("Renamed to RoundToIntegerNoRoundedFlag.")]
public EDecimal RoundToIntegralNoRoundedFlag(EContext ctx);
    public EDecimal RoundToPrecision(EContext ctx);
    public EDecimal PreRound(EContext ctx);
    public EDecimal ScaleByPowerOfTen(int places);
    public EDecimal ScaleByPowerOfTen(int places, EContext ctx);
    public EDecimal ScaleByPowerOfTen(EInteger bigPlaces);
    public EDecimal ScaleByPowerOfTen(EInteger bigPlaces, EContext ctx);
    public EDecimal Sqrt(EContext ctx);
    [ObsoleteAttribute("Renamed to Sqrt.")]
public EDecimal SquareRoot(EContext ctx);
    public EDecimal Subtract(EDecimal otherValue);
    public EDecimal Subtract(EDecimal otherValue, EContext ctx);
    private static long IntegerToDoubleBits(long v, int expshift, bool neg);
    private static int IntegerToSingleBits(int iv, int expshift, bool neg);
    public long ToDoubleBits();
    public double ToDouble();
    public EInteger ToEInteger();
    [ObsoleteAttribute("Renamed to ToEIntegerIfExact.")]
public EInteger ToEIntegerExact();
    public EInteger ToEIntegerIfExact();
    public string ToEngineeringString();
    [ObsoleteAttribute("Renamed to ToEFloat.")]
public EFloat ToExtendedFloat();
    public EFloat ToEFloat();
    public string ToPlainString();
    public int ToSingleBits();
    public float ToSingle();
    public virtual string ToString();
    public EDecimal Ulp();
    internal static EDecimal CreateWithFlags(FastIntegerFixed mantissa, FastIntegerFixed exponent, int flags);
    internal static EDecimal CreateWithFlags(EInteger mantissa, EInteger exponent, int flags);
    private static bool AppendString(StringBuilder builder, char c, FastInteger count);
    internal static IRadixMath`1<EDecimal> GetMathValue(EContext ctx);
    private bool EqualsInternal(EDecimal otherValue);
    private static EInteger[] GetAdjustedExponentDecimalBounds(EDecimal ed);
    private static EInteger GetAdjustedExponentBinary(EFloat ef);
    private EDecimal RoundToExponentFast(int exponentSmall, ERounding rounding);
    private bool IsIntegerPartZero();
    private EInteger ToEIntegerInternal(bool exact);
    private static EInteger PowerOfRadixBitsLowerBound(EInteger e);
    private static EInteger PowerOfRadixBitsUpperBound(EInteger e);
    public EInteger ToSizedEInteger(int maxBitLength);
    public EInteger ToSizedEIntegerIfExact(int maxBitLength);
    private EInteger ToSizedEInteger(int maxBitLength, bool exact);
    private static bool HasTerminatingBinaryExpansion(EInteger den);
    private EFloat WithThisSign(EFloat ef);
    public EFloat ToEFloat(EContext ec);
    private string ToStringInternal(int mode);
    public EDecimal Increment();
    public EDecimal Decrement();
    private void CheckTrivialOverflow(int maxDigits);
    public byte ToByteChecked();
    public byte ToByteUnchecked();
    public byte ToByteIfExact();
    public static EDecimal FromByte(byte inputByte);
    public short ToInt16Checked();
    public short ToInt16Unchecked();
    public short ToInt16IfExact();
    public static EDecimal FromInt16(short inputInt16);
    public int ToInt32Checked();
    public int ToInt32Unchecked();
    public int ToInt32IfExact();
    public long ToInt64Checked();
    public long ToInt64Unchecked();
    public long ToInt64IfExact();
    public decimal ToDecimal();
    public static EDecimal FromDecimal(decimal dec);
    public static EDecimal op_Explicit(bool boolValue);
    public static EDecimal op_Implicit(decimal dec);
    public static decimal op_Explicit(EDecimal bigValue);
    public static EDecimal op_Implicit(EInteger eint);
    public static EDecimal op_Addition(EDecimal bthis, EDecimal otherValue);
    public static EDecimal op_Subtraction(EDecimal bthis, EDecimal subtrahend);
    public static EDecimal op_Increment(EDecimal bthis);
    public static EDecimal op_Decrement(EDecimal bthis);
    public static EDecimal op_Multiply(EDecimal operand1, EDecimal operand2);
    public static EDecimal op_Division(EDecimal dividend, EDecimal divisor);
    public static EDecimal op_Modulus(EDecimal dividend, EDecimal divisor);
    public static EDecimal op_UnaryNegation(EDecimal bigValue);
    public static EInteger op_Explicit(EDecimal bigValue);
    public static double op_Explicit(EDecimal bigValue);
    public static float op_Explicit(EDecimal bigValue);
    public static byte op_Explicit(EDecimal input);
    public static EDecimal op_Implicit(byte inputByte);
    [CLSCompliantAttribute("False")]
public sbyte ToSByteChecked();
    [CLSCompliantAttribute("False")]
public sbyte ToSByteUnchecked();
    [CLSCompliantAttribute("False")]
public sbyte ToSByteIfExact();
    [CLSCompliantAttribute("False")]
public static EDecimal FromSByte(sbyte inputSByte);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(EDecimal input);
    [CLSCompliantAttribute("False")]
public static EDecimal op_Implicit(sbyte inputSByte);
    public static short op_Explicit(EDecimal input);
    public static EDecimal op_Implicit(short inputInt16);
    [CLSCompliantAttribute("False")]
public ushort ToUInt16Checked();
    [CLSCompliantAttribute("False")]
public ushort ToUInt16Unchecked();
    [CLSCompliantAttribute("False")]
public ushort ToUInt16IfExact();
    [CLSCompliantAttribute("False")]
public static EDecimal FromUInt16(ushort inputUInt16);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(EDecimal input);
    [CLSCompliantAttribute("False")]
public static EDecimal op_Implicit(ushort inputUInt16);
    public static int op_Explicit(EDecimal input);
    public static EDecimal op_Implicit(int inputInt32);
    [CLSCompliantAttribute("False")]
public UInt32 ToUInt32Checked();
    [CLSCompliantAttribute("False")]
public UInt32 ToUInt32Unchecked();
    [CLSCompliantAttribute("False")]
public UInt32 ToUInt32IfExact();
    [CLSCompliantAttribute("False")]
public static EDecimal FromUInt32(UInt32 inputUInt32);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(EDecimal input);
    [CLSCompliantAttribute("False")]
public static EDecimal op_Implicit(UInt32 inputUInt32);
    public static long op_Explicit(EDecimal input);
    public static EDecimal op_Implicit(long inputInt64);
    [CLSCompliantAttribute("False")]
public ulong ToUInt64Checked();
    [CLSCompliantAttribute("False")]
public ulong ToUInt64Unchecked();
    [CLSCompliantAttribute("False")]
public ulong ToUInt64IfExact();
    [CLSCompliantAttribute("False")]
public static EDecimal FromUInt64(ulong inputUInt64);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(EDecimal input);
    [CLSCompliantAttribute("False")]
public static EDecimal op_Implicit(ulong inputUInt64);
}
internal static class PeterO.Numbers.EDecimalByteArrayString : object {
    private static int MaxSafeInt;
    internal static EDecimal FromString(Byte[] chars, int offset, int length, EContext ctx, bool throwException);
    private static EDecimal ParseSpecialValue(Byte[] chars, int i, int endStr, bool negative, EContext ctx, bool throwException);
    private static EDecimal ParseOrdinaryNumberLimitedPrecision(Byte[] chars, int offset, int endStr, bool negative, EContext ctx, bool throwException);
    private static EDecimal ParseOrdinaryNumberNoContext(Byte[] chars, int i, int endStr, bool negative, bool throwException);
    private static EDecimal ParseOrdinaryNumber(Byte[] chars, int i, int endStr, bool negative, EContext ctx, bool throwException);
}
internal static class PeterO.Numbers.EDecimalCharArrayString : object {
    private static int MaxSafeInt;
    internal static EDecimal FromString(Char[] chars, int offset, int length, EContext ctx, bool throwException);
    private static EDecimal ParseSpecialValue(Char[] chars, int i, int endStr, bool negative, EContext ctx, bool throwException);
    private static EDecimal ParseOrdinaryNumberLimitedPrecision(Char[] chars, int offset, int endStr, bool negative, EContext ctx, bool throwException);
    private static EDecimal ParseOrdinaryNumberNoContext(Char[] chars, int i, int endStr, bool negative, bool throwException);
    private static EDecimal ParseOrdinaryNumber(Char[] chars, int i, int endStr, bool negative, EContext ctx, bool throwException);
}
public static class PeterO.Numbers.EDecimals : object {
    private static int DecimalRadix;
    private static String[] NumberClasses;
    private static EDecimals();
    public static EDecimal Radix(EContext ec);
    public static EDecimal Int32ToEDecimal(int i32, EContext ec);
    public static EDecimal BooleanToEDecimal(bool b, EContext ec);
    public static bool IsCanonical(EDecimal ed);
    public static bool IsFinite(EDecimal ed);
    public static bool IsInfinite(EDecimal ed);
    public static bool IsNaN(EDecimal ed);
    public static bool IsNormal(EDecimal ed, EContext ec);
    public static bool IsQuietNaN(EDecimal ed);
    public static bool IsSigned(EDecimal ed);
    public static bool IsSignalingNaN(EDecimal ed);
    public static string NumberClassString(int nc);
    public static int NumberClass(EDecimal ed, EContext ec);
    public static bool IsSubnormal(EDecimal ed, EContext ec);
    public static bool IsZero(EDecimal ed);
    public static EDecimal LogB(EDecimal ed, EContext ec);
    public static EDecimal ScaleB(EDecimal ed, EDecimal ed2, EContext ec);
    public static EDecimal Shift(EDecimal ed, EDecimal ed2, EContext ec);
    public static EDecimal Rotate(EDecimal ed, EDecimal ed2, EContext ec);
    public static int CompareTotal(EDecimal ed, EDecimal other, EContext ec);
    public static int CompareTotalMagnitude(EDecimal ed, EDecimal other, EContext ec);
    public static EDecimal Copy(EDecimal ed);
    public static EDecimal Canonical(EDecimal ed);
    public static EDecimal CopyAbs(EDecimal ed);
    public static EDecimal CopyNegate(EDecimal ed);
    public static EDecimal CopySign(EDecimal ed, EDecimal other);
    private static EDecimal InvalidOperation(EContext ec);
    public static bool SameQuantum(EDecimal ed1, EDecimal ed2);
    public static EDecimal Trim(EDecimal ed1, EContext ec);
    public static EDecimal Rescale(EDecimal ed, EDecimal scale, EContext ec);
    public static EDecimal And(EDecimal ed1, EDecimal ed2, EContext ec);
    public static EDecimal Invert(EDecimal ed1, EContext ec);
    public static EDecimal Xor(EDecimal ed1, EDecimal ed2, EContext ec);
    public static EDecimal Or(EDecimal ed1, EDecimal ed2, EContext ec);
    internal static EInteger ToLogical(Byte[] bytes, int iradix);
    internal static Byte[] FromLogical(EInteger um, EContext ec, int iradix);
    internal static Byte[] FromLogical(EDecimal ed, EContext ec, int iradix);
    internal static Byte[] FromLogical(EFloat ed, EContext ec, int iradix);
}
internal static class PeterO.Numbers.EDecimalTextString : object {
    private static int MaxSafeInt;
    internal static EDecimal FromString(string chars, int offset, int length, EContext ctx, bool throwException);
    private static EDecimal ParseSpecialValue(string chars, int i, int endStr, bool negative, EContext ctx, bool throwException);
    private static EDecimal ParseOrdinaryNumberLimitedPrecision(string chars, int offset, int endStr, bool negative, EContext ctx, bool throwException);
    private static EDecimal ParseOrdinaryNumberNoContext(string chars, int i, int endStr, bool negative, bool throwException);
    private static EDecimal ParseOrdinaryNumber(string chars, int i, int endStr, bool negative, EContext ctx, bool throwException);
}
public class PeterO.Numbers.EFloat : object {
    private static int CacheFirst;
    private static int CacheLast;
    public static EFloat NaN;
    public static EFloat NegativeInfinity;
    public static EFloat NegativeZero;
    public static EFloat One;
    public static EFloat PositiveInfinity;
    public static EFloat SignalingNaN;
    public static EFloat Ten;
    public static EFloat Zero;
    private static EFloat[] Cache;
    private static IRadixMath`1<EFloat> MathValue;
    private FastIntegerFixed exponent;
    private FastIntegerFixed unsignedMantissa;
    private byte flags;
    public EInteger Exponent { get; }
    public bool IsFinite { get; }
    public bool IsNegative { get; }
    public bool IsZero { get; }
    public EInteger Mantissa { get; }
    public int Sign { get; }
    public EInteger UnsignedMantissa { get; }
    private EFloat(FastIntegerFixed unsignedMantissa, FastIntegerFixed exponent, byte flags);
    private static EFloat();
    private static EFloat[] EFloatCache(int first, int last);
    internal static IRadixMath`1<EFloat> GetMathValue();
    public EInteger get_Exponent();
    public bool get_IsFinite();
    public bool get_IsNegative();
    public bool get_IsZero();
    public EInteger get_Mantissa();
    public int get_Sign();
    public EInteger get_UnsignedMantissa();
    public EFloat Copy();
    public static EFloat Create(int mantissaSmall, int exponentSmall);
    public static EFloat Create(EInteger mantissa, int exponentSmall);
    public static EFloat Create(EInteger mantissa, long exponentLong);
    public static EFloat Create(EInteger mantissa, EInteger exponent);
    public static EFloat Create(long mantissaLong, int exponentSmall);
    public static EFloat Create(long mantissaLong, long exponentLong);
    public static EFloat CreateNaN(EInteger diag);
    public static EFloat CreateNaN(EInteger diag, bool signaling, bool negative, EContext ctx);
    public static EFloat FromDoubleBits(long dblBits);
    public static EFloat FromSingle(float flt);
    public static EFloat FromDouble(double dbl);
    public static EFloat FromEInteger(EInteger bigint);
    public static EFloat FromSingleBits(int value);
    internal static EFloat SignalUnderflow(EContext ec, bool negative, bool zeroSignificand);
    internal static EFloat SignalOverflow(EContext ec, bool negative, bool zeroSignificand);
    public static EFloat FromString(string str, int offset, int length, EContext ctx);
    public static EFloat FromString(string str);
    public static EFloat FromString(string str, EContext ctx);
    public static EFloat FromString(string str, int offset, int length);
    public static EFloat FromString(Char[] chars, int offset, int length, EContext ctx);
    public static EFloat FromString(Char[] chars);
    public static EFloat FromString(Char[] chars, EContext ctx);
    public static EFloat FromString(Char[] chars, int offset, int length);
    public static EFloat FromString(Byte[] bytes, int offset, int length, EContext ctx);
    public static EFloat FromString(Byte[] bytes);
    public static EFloat FromString(Byte[] bytes, EContext ctx);
    public static EFloat FromString(Byte[] bytes, int offset, int length);
    public static EFloat Max(EFloat first, EFloat second, EContext ctx);
    public static EFloat Max(EFloat first, EFloat second);
    public static EFloat MaxMagnitude(EFloat first, EFloat second, EContext ctx);
    public static EFloat MaxMagnitude(EFloat first, EFloat second);
    public static EFloat Min(EFloat first, EFloat second, EContext ctx);
    public static EFloat Min(EFloat first, EFloat second);
    public static EFloat MinMagnitude(EFloat first, EFloat second, EContext ctx);
    public static EFloat MinMagnitude(EFloat first, EFloat second);
    public static EFloat PI(EContext ctx);
    public EFloat Abs();
    public EFloat Abs(EContext context);
    public EFloat Add(int intValue);
    public EFloat Subtract(int intValue);
    public EFloat Multiply(int intValue);
    public EFloat Divide(int intValue);
    public EFloat Add(long longValue);
    public EFloat Subtract(long longValue);
    public EFloat Multiply(long longValue);
    public EFloat Divide(long longValue);
    public EFloat Add(EFloat otherValue);
    public EFloat Add(EFloat otherValue, EContext ctx);
    public sealed virtual int CompareTo(EFloat other);
    public int CompareToValue(EFloat other);
    public int CompareTo(int intOther);
    public int CompareToValue(int intOther);
    public int CompareToValue(long intOther);
    public int CompareTo(long intOther);
    public EFloat CompareToSignal(EFloat other, EContext ctx);
    public int CompareToTotal(EFloat other, EContext ctx);
    public int CompareToTotalMagnitude(EFloat other, EContext ctx);
    public int CompareToTotal(EFloat other);
    public int CompareToTotalMagnitude(EFloat other);
    public EFloat CompareToWithContext(EFloat other, EContext ctx);
    public EFloat CopySign(EFloat other);
    public EFloat Divide(EFloat divisor);
    public EFloat Divide(EFloat divisor, EContext ctx);
    [ObsoleteAttribute("Renamed to DivRemNaturalScale.")]
public EFloat[] DivideAndRemainderNaturalScale(EFloat divisor);
    [ObsoleteAttribute("Renamed to DivRemNaturalScale.")]
public EFloat[] DivideAndRemainderNaturalScale(EFloat divisor, EContext ctx);
    public EFloat DivideToExponent(EFloat divisor, long desiredExponentSmall, EContext ctx);
    public EFloat DivideToExponent(EFloat divisor, long desiredExponentSmall, ERounding rounding);
    public EFloat DivideToExponent(EFloat divisor, EInteger exponent, EContext ctx);
    public EFloat DivideToExponent(EFloat divisor, EInteger desiredExponent, ERounding rounding);
    public EFloat DivideToIntegerNaturalScale(EFloat divisor);
    public EFloat DivideToIntegerNaturalScale(EFloat divisor, EContext ctx);
    public EFloat DivideToIntegerZeroScale(EFloat divisor, EContext ctx);
    public EFloat DivideToSameExponent(EFloat divisor, ERounding rounding);
    public EFloat[] DivRemNaturalScale(EFloat divisor);
    public EFloat[] DivRemNaturalScale(EFloat divisor, EContext ctx);
    public sealed virtual bool Equals(EFloat other);
    public virtual bool Equals(object obj);
    public bool EqualsInternal(EFloat otherValue);
    public EFloat Exp(EContext ctx);
    public EFloat ExpM1(EContext ctx);
    public virtual int GetHashCode();
    public bool IsInfinity();
    public bool IsNaN();
    public bool IsNegativeInfinity();
    public bool IsPositiveInfinity();
    public bool IsQuietNaN();
    public bool IsSignalingNaN();
    public EFloat Log(EContext ctx);
    public EFloat Log10(EContext ctx);
    public EFloat Log1P(EContext ctx);
    public EFloat LogN(EFloat baseValue, EContext ctx);
    public EFloat MovePointLeft(int places);
    public EFloat MovePointLeft(int places, EContext ctx);
    public EFloat MovePointLeft(EInteger bigPlaces);
    public EFloat MovePointLeft(EInteger bigPlaces, EContext ctx);
    public EFloat MovePointRight(int places);
    public EFloat MovePointRight(int places, EContext ctx);
    public EFloat MovePointRight(EInteger bigPlaces);
    public EFloat MovePointRight(EInteger bigPlaces, EContext ctx);
    public EFloat Multiply(EFloat otherValue);
    public EFloat Multiply(EFloat op, EContext ctx);
    public EFloat MultiplyAndAdd(EFloat multiplicand, EFloat augend);
    public EFloat MultiplyAndAdd(EFloat op, EFloat augend, EContext ctx);
    public EFloat MultiplyAndSubtract(EFloat op, EFloat subtrahend, EContext ctx);
    public EFloat Negate();
    public EFloat Negate(EContext context);
    public EFloat NextMinus(EContext ctx);
    public EFloat NextPlus(EContext ctx);
    public EFloat NextToward(EFloat otherValue, EContext ctx);
    public EFloat Plus(EContext ctx);
    public EFloat Pow(EFloat exponent);
    public EFloat Pow(EFloat exponent, EContext ctx);
    public EFloat Pow(int exponentSmall, EContext ctx);
    public EFloat Pow(int exponentSmall);
    public EInteger Precision();
    public bool IsInteger();
    public EFloat Quantize(EInteger desiredExponent, EContext ctx);
    public EFloat Quantize(int desiredExponentInt, EContext ctx);
    public EFloat Quantize(EFloat otherValue, EContext ctx);
    public EFloat Reduce(EContext ctx);
    public EFloat Remainder(EFloat divisor, EContext ctx);
    public EFloat RemainderNoRoundAfterDivide(EFloat divisor, EContext ctx);
    public EFloat RemainderNaturalScale(EFloat divisor);
    public EFloat RemainderNaturalScale(EFloat divisor, EContext ctx);
    public EFloat RemainderNear(EFloat divisor, EContext ctx);
    public EFloat RoundToExponent(EInteger exponent, EContext ctx);
    public EFloat RoundToExponent(int exponentSmall, EContext ctx);
    public EFloat RoundToExponentExact(EInteger exponent, EContext ctx);
    public EFloat RoundToExponentExact(EInteger exponent, ERounding rounding);
    public EFloat RoundToExponentExact(int exponentSmall, EContext ctx);
    public EFloat RoundToIntegerExact(EContext ctx);
    public EFloat RoundToIntegerNoRoundedFlag(EContext ctx);
    [ObsoleteAttribute("Renamed to RoundToIntegerExact.")]
public EFloat RoundToIntegralExact(EContext ctx);
    [ObsoleteAttribute("Renamed to RoundToIntegerNoRoundedFlag.")]
public EFloat RoundToIntegralNoRoundedFlag(EContext ctx);
    public EFloat RoundToPrecision(EContext ctx);
    public EFloat PreRound(EContext ctx);
    public EFloat ScaleByPowerOfTwo(int places);
    public EFloat ScaleByPowerOfTwo(int places, EContext ctx);
    public EFloat ScaleByPowerOfTwo(EInteger bigPlaces);
    public EFloat ScaleByPowerOfTwo(EInteger bigPlaces, EContext ctx);
    public EFloat Sqrt(EContext ctx);
    [ObsoleteAttribute("Renamed to Sqrt.")]
public EFloat SquareRoot(EContext ctx);
    public EFloat Subtract(EFloat otherValue);
    public EFloat Subtract(EFloat otherValue, EContext ctx);
    public double ToDouble();
    public int ToSingleBits();
    public long ToDoubleBits();
    public EDecimal ToEDecimal();
    public EInteger ToEInteger();
    [ObsoleteAttribute("Renamed to ToEIntegerIfExact.")]
public EInteger ToEIntegerExact();
    public EInteger ToEIntegerIfExact();
    public string ToEngineeringString();
    [ObsoleteAttribute("Renamed to ToEDecimal.")]
public EDecimal ToExtendedDecimal();
    public string ToPlainString();
    private string ToDebugString();
    public string ToShortestString(EContext ctx);
    public float ToSingle();
    public virtual string ToString();
    public EFloat Ulp();
    internal static EFloat CreateWithFlags(long mantissa, EInteger exponent, int flags);
    internal static EFloat CreateWithFlags(EInteger mantissa, EInteger exponent, int flags);
    private EInteger ToEIntegerInternal(bool exact);
    private static EInteger PowerOfRadixBitsLowerBound(EInteger e);
    private static EInteger PowerOfRadixBitsUpperBound(EInteger e);
    public EInteger ToSizedEInteger(int maxBitLength);
    public EInteger ToSizedEIntegerIfExact(int maxBitLength);
    private EInteger ToSizedEInteger(int maxBitLength, bool exact);
    public EFloat Increment();
    public EFloat Decrement();
    public byte ToByteChecked();
    public byte ToByteUnchecked();
    public byte ToByteIfExact();
    public static EFloat FromByte(byte inputByte);
    public short ToInt16Checked();
    public short ToInt16Unchecked();
    public short ToInt16IfExact();
    public static EFloat FromInt16(short inputInt16);
    public int ToInt32Checked();
    public int ToInt32Unchecked();
    public int ToInt32IfExact();
    public static EFloat FromBoolean(bool boolValue);
    public static EFloat FromInt32(int inputInt32);
    public long ToInt64Checked();
    public long ToInt64Unchecked();
    public long ToInt64IfExact();
    public static EFloat FromInt64AsUnsigned(long longerValue);
    public static EFloat FromInt64(long inputInt64);
    public static EFloat op_Explicit(bool boolValue);
    public static EFloat op_Implicit(float flt);
    public static EFloat op_Implicit(double dbl);
    public static EFloat op_Implicit(EInteger eint);
    public static EFloat op_Addition(EFloat bthis, EFloat otherValue);
    public static EFloat op_Subtraction(EFloat bthis, EFloat subtrahend);
    public static EFloat op_Increment(EFloat bthis);
    public static EFloat op_Decrement(EFloat bthis);
    public static EFloat op_Multiply(EFloat operand1, EFloat operand2);
    public static EFloat op_Division(EFloat dividend, EFloat divisor);
    public static EFloat op_Modulus(EFloat dividend, EFloat divisor);
    public static EFloat op_UnaryNegation(EFloat bigValue);
    public static EInteger op_Explicit(EFloat bigValue);
    public static double op_Explicit(EFloat bigValue);
    public static float op_Explicit(EFloat bigValue);
    public static byte op_Explicit(EFloat input);
    public static EFloat op_Implicit(byte inputByte);
    [CLSCompliantAttribute("False")]
public sbyte ToSByteChecked();
    [CLSCompliantAttribute("False")]
public sbyte ToSByteUnchecked();
    [CLSCompliantAttribute("False")]
public sbyte ToSByteIfExact();
    [CLSCompliantAttribute("False")]
public static EFloat FromSByte(sbyte inputSByte);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(EFloat input);
    [CLSCompliantAttribute("False")]
public static EFloat op_Implicit(sbyte inputSByte);
    public static short op_Explicit(EFloat input);
    public static EFloat op_Implicit(short inputInt16);
    [CLSCompliantAttribute("False")]
public ushort ToUInt16Checked();
    [CLSCompliantAttribute("False")]
public ushort ToUInt16Unchecked();
    [CLSCompliantAttribute("False")]
public ushort ToUInt16IfExact();
    [CLSCompliantAttribute("False")]
public static EFloat FromUInt16(ushort inputUInt16);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(EFloat input);
    [CLSCompliantAttribute("False")]
public static EFloat op_Implicit(ushort inputUInt16);
    public static int op_Explicit(EFloat input);
    public static EFloat op_Implicit(int inputInt32);
    [CLSCompliantAttribute("False")]
public UInt32 ToUInt32Checked();
    [CLSCompliantAttribute("False")]
public UInt32 ToUInt32Unchecked();
    [CLSCompliantAttribute("False")]
public UInt32 ToUInt32IfExact();
    [CLSCompliantAttribute("False")]
public static EFloat FromUInt32(UInt32 inputUInt32);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(EFloat input);
    [CLSCompliantAttribute("False")]
public static EFloat op_Implicit(UInt32 inputUInt32);
    public static long op_Explicit(EFloat input);
    public static EFloat op_Implicit(long inputInt64);
    [CLSCompliantAttribute("False")]
public ulong ToUInt64Checked();
    [CLSCompliantAttribute("False")]
public ulong ToUInt64Unchecked();
    [CLSCompliantAttribute("False")]
public ulong ToUInt64IfExact();
    [CLSCompliantAttribute("False")]
public static EFloat FromUInt64(ulong inputUInt64);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(EFloat input);
    [CLSCompliantAttribute("False")]
public static EFloat op_Implicit(ulong inputUInt64);
}
internal static class PeterO.Numbers.EFloatByteArrayString : object {
    internal static EFloat FromString(Byte[] chars, int offset, int length, EContext ctx, bool throwException);
    internal static EFloat DoubleEFloatFromString(Byte[] chars, int offset, int length, EContext ctx, bool throwException);
}
internal static class PeterO.Numbers.EFloatCharArrayString : object {
    internal static EFloat FromString(Char[] chars, int offset, int length, EContext ctx, bool throwException);
    internal static EFloat DoubleEFloatFromString(Char[] chars, int offset, int length, EContext ctx, bool throwException);
}
public static class PeterO.Numbers.EFloats : object {
    private static int BinaryRadix;
    public static EFloat Radix(EContext ec);
    public static EFloat Int32ToEFloat(int i32, EContext ec);
    public static EFloat BooleanToEFloat(bool b, EContext ec);
    public static bool IsCanonical(EFloat ed);
    public static bool IsFinite(EFloat ed);
    public static bool IsInfinite(EFloat ed);
    public static bool IsNaN(EFloat ed);
    public static bool IsNormal(EFloat ed, EContext ec);
    public static bool IsQuietNaN(EFloat ed);
    public static bool IsSigned(EFloat ed);
    public static bool IsSignalingNaN(EFloat ed);
    public static string NumberClassString(int nc);
    public static int NumberClass(EFloat ed, EContext ec);
    public static bool IsSubnormal(EFloat ed, EContext ec);
    public static bool IsZero(EFloat ed);
    public static EFloat LogB(EFloat ed, EContext ec);
    public static EFloat ScaleB(EFloat ed, EFloat ed2, EContext ec);
    public static EFloat Shift(EFloat ed, EFloat ed2, EContext ec);
    public static EFloat Rotate(EFloat ed, EFloat ed2, EContext ec);
    public static int CompareTotal(EFloat ed, EFloat other, EContext ec);
    public static int CompareTotalMagnitude(EFloat ed, EFloat other, EContext ec);
    public static EFloat Copy(EFloat ed);
    public static EFloat Canonical(EFloat ed);
    public static EFloat CopyAbs(EFloat ed);
    public static EFloat CopyNegate(EFloat ed);
    public static EFloat CopySign(EFloat ed, EFloat other);
    private static EFloat InvalidOperation(EContext ec);
    public static bool SameQuantum(EFloat ed1, EFloat ed2);
    public static EFloat Trim(EFloat ed1, EContext ec);
    public static EFloat Rescale(EFloat ed, EFloat scale, EContext ec);
    public static EFloat And(EFloat ed1, EFloat ed2, EContext ec);
    public static EFloat Invert(EFloat ed1, EContext ec);
    public static EFloat Xor(EFloat ed1, EFloat ed2, EContext ec);
    public static EFloat Or(EFloat ed1, EFloat ed2, EContext ec);
}
internal static class PeterO.Numbers.EFloatTextString : object {
    internal static EFloat FromString(string chars, int offset, int length, EContext ctx, bool throwException);
    internal static EFloat DoubleEFloatFromString(string chars, int offset, int length, EContext ctx, bool throwException);
}
public class PeterO.Numbers.EInteger : object {
    private static string Digits;
    private static int Toom3Threshold;
    private static int Toom4Threshold;
    private static int MultRecursionThreshold;
    private static int RecursiveDivisionLimit;
    private static int CacheFirst;
    private static int CacheLast;
    private static int ShortMask;
    internal static Int32[] CharToDigit;
    internal static Int32[] MaxSafeInts;
    private static EInteger ValueOne;
    private static EInteger ValueTen;
    private static EInteger ValueZero;
    private bool negative;
    private int wordCount;
    private Int16[] words;
    private static EInteger[] Cache;
    internal static Int32[] DigitsInWord;
    private static Int32[] estimatedHalfDigitCountPerWord;
    public static EInteger One { get; }
    public static EInteger Ten { get; }
    public static EInteger Zero { get; }
    public bool IsEven { get; }
    public bool IsPowerOfTwo { get; }
    public bool IsZero { get; }
    public int Sign { get; }
    internal EInteger(int wordCount, Int16[] reg, bool negative);
    private static EInteger();
    private static EInteger[] EIntegerCache(int first, int last);
    public static EInteger get_One();
    public static EInteger get_Ten();
    public static EInteger get_Zero();
    public bool get_IsEven();
    public bool get_IsPowerOfTwo();
    public bool get_IsZero();
    public int get_Sign();
    internal static EInteger FromInts(Int32[] intWords, int count);
    public static EInteger FromBytes(Byte[] bytes, bool littleEndian);
    public static EInteger FromBytes(Byte[] bytes, int offset, int length, bool littleEndian);
    public static EInteger FromBoolean(bool boolValue);
    public static EInteger FromInt32(int intValue);
    public static EInteger FromInt64AsUnsigned(long longerValue);
    public static EInteger FromInt64(long longerValue);
    public static EInteger FromRadixString(string str, int radix);
    public static EInteger FromRadixSubstring(string str, int radix, int index, int endIndex);
    public static EInteger FromSubstring(Char[] cs, int index, int endIndex);
    public static EInteger FromString(Char[] cs);
    public static EInteger FromRadixString(Char[] cs, int radix);
    public static EInteger FromRadixSubstring(Char[] cs, int radix, int index, int endIndex);
    public static EInteger FromSubstring(Byte[] bytes, int index, int endIndex);
    public static EInteger FromString(Byte[] bytes);
    public static EInteger FromRadixString(Byte[] bytes, int radix);
    public static EInteger FromRadixSubstring(Byte[] bytes, int radix, int index, int endIndex);
    public static EInteger FromString(string str);
    public static EInteger FromSubstring(string str, int index, int endIndex);
    public EInteger Abs();
    public EInteger Add(EInteger bigintAugend);
    [ObsoleteAttribute("Renamed to ToInt32Checked.")]
public int AsInt32Checked();
    [ObsoleteAttribute("Renamed to ToInt32Unchecked.")]
public int AsInt32Unchecked();
    [ObsoleteAttribute("Renamed to ToInt64Checked.")]
public long AsInt64Checked();
    [ObsoleteAttribute("Renamed to ToInt64Unchecked.")]
public long AsInt64Unchecked();
    public bool CanFitInInt32();
    public bool CanFitInInt64();
    public sealed virtual int CompareTo(EInteger other);
    public static EInteger Max(EInteger first, EInteger second);
    public static EInteger Min(EInteger first, EInteger second);
    public static EInteger MaxMagnitude(EInteger first, EInteger second);
    public static EInteger MinMagnitude(EInteger first, EInteger second);
    public EInteger Add(int intValue);
    public EInteger Subtract(int intValue);
    public EInteger Multiply(int intValue);
    public EInteger Divide(int intValue);
    public EInteger Remainder(int intValue);
    public int CompareTo(int intValue);
    public EInteger Divide(EInteger bigintDivisor);
    private static int LinearMultiplySubtractMinuend1Bigger(Int16[] resultArr, int resultStart, Int16[] minuendArr, int minuendArrStart, int factor1, Int16[] factor2, int factor2Start, int factor2Count);
    private static void DivideThreeBlocksByTwo(Int16[] valueALow, int posALow, Int16[] valueAMidHigh, int posAMidHigh, Int16[] b, int posB, int blockCount, Int16[] quot, int posQuot, Int16[] rem, int posRem, Int16[] tmp);
    private static void RecursiveDivideInner(Int16[] a, int posA, Int16[] b, int posB, Int16[] quot, int posQuot, Int16[] rem, int posRem, int blockSize);
    private static void RecursiveDivide(Int16[] a, int posA, int countA, Int16[] b, int posB, int countB, Int16[] quot, int posQuot, Int16[] rem, int posRem);
    private static string WordsToString(Int16[] a, int pos, int len);
    private static string WordsToStringHex(Int16[] a, int pos, int len);
    private static string WordsToString2(Int16[] a, int pos, int len, Int16[] b, int pos2, int len2);
    private static void GeneralDivide(Int16[] a, int posA, int countA, Int16[] b, int posB, int countB, Int16[] quot, int posQuot, Int16[] rem, int posRem);
    public EInteger[] DivRem(int intDivisor);
    public EInteger Add(long longValue);
    public EInteger Subtract(long longValue);
    public EInteger Multiply(long longValue);
    public EInteger Divide(long longValue);
    public EInteger Remainder(long longValue);
    public int CompareTo(long longValue);
    public EInteger[] DivRem(long intDivisor);
    public EInteger[] DivRem(EInteger divisor);
    public virtual bool Equals(object obj);
    private static EInteger LeftShiftBigIntVar(EInteger ei, EInteger bigShift);
    private static long GcdLong(long u, long v);
    public EInteger Gcd(EInteger bigintSecond);
    private static EInteger BaseGcd(EInteger thisValue, EInteger bigintSecond);
    private static EInteger MinBitLength(EInteger eia, EInteger eib);
    private static EInteger MaxBitLength(EInteger eia, EInteger eib);
    private static void SDivStep(EInteger[] eiam, EInteger eis);
    private static void LSDivStep(Int64[] longam, long ls);
    private static EInteger BL(EInteger eia);
    private static int LBL(long mantlong);
    private static Int64[] LHalfGCD(long longa, long longb);
    private static Int64[] SlowSgcd(long longa, long longb);
    private static EInteger[] SlowSgcd(EInteger eia, EInteger eib);
    private static EInteger[] HalfGCD(EInteger eia, EInteger eib);
    private static EInteger SubquadraticGCD(EInteger eia, EInteger eib);
    public EInteger GetDigitCountAsEInteger();
    [ObsoleteAttribute("This method may overflow. Use GetDigitCountAsEInteger instead.")]
public int GetDigitCount();
    public long GetDigitCountAsInt64();
    public virtual int GetHashCode();
    [ObsoleteAttribute("This method may overflow. Use GetLowBitAsEInteger instead.")]
public int GetLowBit();
    public long GetLowBitAsInt64();
    public EInteger GetLowBitAsEInteger();
    public bool GetSignedBit(EInteger bigIndex);
    public bool GetSignedBit(int index);
    public EInteger GetSignedBitLengthAsEInteger();
    public long GetSignedBitLengthAsInt64();
    [ObsoleteAttribute("This method may overflow. Use GetSignedBitLengthAsEInteger instead.")]
public int GetSignedBitLength();
    public bool GetUnsignedBit(EInteger bigIndex);
    public bool GetUnsignedBit(int index);
    public EInteger GetUnsignedBitLengthAsEInteger();
    public long GetUnsignedBitLengthAsInt64();
    [ObsoleteAttribute("This method may overflow. Use GetUnsignedBitLengthAsEInteger instead.")]
public int GetUnsignedBitLength();
    public EInteger Mod(EInteger divisor);
    public EInteger Mod(int smallDivisor);
    public EInteger ModPow(EInteger pow, EInteger mod);
    public EInteger Multiply(EInteger bigintMult);
    private static EInteger MakeEInteger(Int16[] words, int wordsEnd, int offset, int count);
    private static void Toom3(Int16[] resultArr, int resultStart, Int16[] wordsA, int wordsAStart, int countA, Int16[] wordsB, int wordsBStart, int countB);
    private static EInteger Interpolate(EInteger[] wts, Int32[] values, int divisor);
    private static void Toom4(Int16[] resultArr, int resultStart, Int16[] wordsA, int wordsAStart, int countA, Int16[] wordsB, int wordsBStart, int countB);
    public EInteger Negate();
    public EInteger Pow(long longPower);
    public EInteger Pow(EInteger bigPower);
    public EInteger Pow(int powerSmall);
    [ObsoleteAttribute("Use Pow instead.")]
public EInteger PowBigIntVar(EInteger power);
    public EInteger Remainder(EInteger divisor);
    public EInteger ShiftRight(EInteger eshift);
    public EInteger ShiftLeft(EInteger eshift);
    public EInteger ShiftLeft(int numberBits);
    private static void OrWords(Int16[] r, Int16[] a, Int16[] b, int n);
    private static void XorWords(Int16[] r, Int16[] a, Int16[] b, int n);
    private static void NotWords(Int16[] r, int n);
    private static void AndWords(Int16[] r, Int16[] a, Int16[] b, int n);
    public EInteger Not();
    public EInteger LowBits(long longBitCount);
    public EInteger LowBits(int bitCount);
    public EInteger LowBits(EInteger bigBitCount);
    public EInteger And(EInteger other);
    public EInteger Or(EInteger second);
    public EInteger AndNot(EInteger second);
    public EInteger OrNot(EInteger second);
    public EInteger Imp(EInteger second);
    public EInteger XorNot(EInteger second);
    public EInteger Eqv(EInteger second);
    public EInteger Xor(EInteger other);
    private Int16[] Copy();
    private static int WordsCompare(Int16[] words, int wordCount, Int16[] words2, int wordCount2);
    private static int WordsCompare(Int16[] words, int pos1, int wordCount, Int16[] words2, int pos2, int wordCount2);
    private static long WordsToLongUnchecked(Int16[] words, int wordCount);
    private static bool WordsEqual(Int16[] words, int wordCount, Int16[] words2, int wordCount2);
    private static bool WordsIsEven(Int16[] words, int wordCount);
    private static int WordsShiftRightTwo(Int16[] words, int wordCount);
    private static int WordsShiftRightEight(Int16[] words, int wordCount);
    private static int WordsShiftRightFour(Int16[] words, int wordCount);
    private static int WordsShiftRightOne(Int16[] words, int wordCount);
    private static int WordsSubtract(Int16[] words, int wordCount, Int16[] subtrahendWords, int subtrahendCount);
    public EInteger ShiftRight(int numberBits);
    public EInteger Sqrt();
    public EInteger[] SqrtRem();
    public EInteger Root(EInteger root);
    public EInteger[] RootRem(EInteger root);
    public EInteger Root(int root);
    public EInteger[] RootRem(int root);
    public EInteger Subtract(EInteger subtrahend);
    public Byte[] ToBytes(bool littleEndian);
    public int ToInt32Checked();
    public int ToInt32Unchecked();
    public long ToInt64Checked();
    public long ToInt64Unchecked();
    private void ToRadixStringGeneral(StringBuilder outputSB, int radix);
    public string ToRadixString(int radix);
    public virtual string ToString();
    private static int AddInternal(Int16[] c, int cstart, Int16[] words1, int astart, Int16[] words2, int bstart, int n);
    private static int AddUnevenSize(Int16[] c, int cstart, Int16[] wordsBigger, int astart, int acount, Int16[] wordsSmaller, int bstart, int bcount);
    private static void AsymmetricMultiply(Int16[] resultArr, int resultStart, Int16[] tempArr, int tempStart, Int16[] words1, int words1Start, int words1Count, Int16[] words2, int words2Start, int words2Count);
    private static void AtomicMultiplyAddOpt(Int16[] c, int valueCstart, int valueA0, int valueA1, Int16[] words2, int words2Start, int istart, int iend);
    private static void AtomicMultiplyOpt(Int16[] c, int valueCstart, int valueA0, int valueA1, Int16[] words2, int words2Start, int istart, int iend);
    private static void BaselineMultiply2(Int16[] result, int rstart, Int16[] words1, int astart, Int16[] words2, int bstart);
    private static void BaselineMultiply4(Int16[] result, int rstart, Int16[] words1, int astart, Int16[] words2, int bstart);
    private static void BaselineMultiply8(Int16[] result, int rstart, Int16[] words1, int astart, Int16[] words2, int bstart);
    private static void BaselineSquare2(Int16[] result, int rstart, Int16[] words1, int astart);
    private static void BaselineSquare4(Int16[] result, int rstart, Int16[] words1, int astart);
    private static void BaselineSquare8(Int16[] result, int rstart, Int16[] words1, int astart);
    private static int BitPrecision(short numberValue);
    private static int BitsToWords(int bitCount);
    private static void ChunkedLinearMultiply(Int16[] productArr, int cstart, Int16[] tempArr, int tempStart, Int16[] words1, int astart, int acount, Int16[] words2, int bstart, int bcount);
    internal static Int16[] CleanGrow(Int16[] a, int size);
    private static int Compare(Int16[] words1, int astart, Int16[] words2, int bstart, int n);
    private static int CompareWithWords1IsOneBigger(Int16[] words1, int astart, Int16[] words2, int bstart, int words1Count);
    internal static int CountWords(Int16[] array);
    internal static int CountWords(Int16[] array, int pos, int len);
    private static int DecrementWords(Int16[] words1, int words1Start, int n, short words2);
    private static short Divide32By16(int dividendLow, short divisorShort, bool returnRemainder);
    private static short DivideUnsigned(int x, short y);
    private static void FastDivide(Int16[] quotientReg, Int16[] dividendReg, int count, short divisorSmall);
    private static short FastDivideAndRemainderTwo(Int16[] quotientReg, int quotientStart, Int16[] dividendReg, int dividendStart, int count);
    private static short FastDivideAndRemainderTen(Int16[] quotientReg, int quotientStart, Int16[] dividendReg, int dividendStart, int count);
    private static short FastDivideAndRemainder(Int16[] quotientReg, int quotientStart, Int16[] dividendReg, int dividendStart, int count, short divisorSmall);
    private static short FastRemainder(Int16[] dividendReg, int count, short divisorSmall);
    private static short GetHighHalfAsBorrow(int val);
    private static int GetLowHalf(int val);
    private static int GetUnsignedBitLengthEx(int numberValue, int wordCount);
    internal static Int16[] GrowForCarry(Int16[] a, short carry);
    internal static int IncrementWords(Int16[] words1, int words1Start, int n, short words2);
    private static short LinearMultiply(Int16[] productArr, int cstart, Int16[] words1, int astart, short words2, int n);
    private static short LinearMultiplyAdd(Int16[] productArr, int cstart, Int16[] words1, int astart, short words2, int n);
    private static void RecursiveSquare(Int16[] resultArr, int resultStart, Int16[] tempArr, int tempStart, Int16[] words1, int words1Start, int count);
    private static short RemainderUnsigned(int x, short y);
    private static void ReverseChars(Char[] chars, int offset, int length);
    private static void SameSizeMultiply(Int16[] resultArr, int resultStart, Int16[] tempArr, int tempStart, Int16[] words1, int words1Start, Int16[] words2, int words2Start, int count);
    private static void SchoolbookMultiplySameLengthEven(Int16[] resultArr, int resultStart, Int16[] words1, int words1Start, Int16[] words2, int words2Start, int count);
    private static void SchoolbookMultiplySameLengthOdd(Int16[] resultArr, int resultStart, Int16[] words1, int words1Start, Int16[] words2, int words2Start, int count);
    private static void SchoolbookMultiply(Int16[] resultArr, int resultStart, Int16[] words1, int words1Start, int words1Count, Int16[] words2, int words2Start, int words2Count);
    private static void SchoolbookSquare(Int16[] resultArr, int resultStart, Int16[] words1, int words1Start, int words1Count);
    private static short ShiftWordsLeftByBits(Int16[] r, int rstart, int count, int shiftBits);
    private static void ShiftWordsLeftByWords(Int16[] r, int rstart, int n, int shiftWords);
    private static short ShiftWordsRightByBits(Int16[] r, int rstart, int n, int shiftBits);
    private static short ShiftWordsRightByBitsSignExtend(Int16[] r, int rstart, int n, int shiftBits);
    private static void ShiftWordsRightByWordsSignExtend(Int16[] r, int rstart, int n, int shiftWords);
    private static Int16[] ShortenArray(Int16[] reg, int wordCount);
    private static int SubtractWords1IsOneBigger(Int16[] c, int cstart, Int16[] words1, int astart, Int16[] words2, int bstart, int words1Count);
    private static int SubtractWords2IsOneBigger(Int16[] c, int cstart, Int16[] words1, int astart, Int16[] words2, int bstart, int words2Count);
    private static int SubtractInternal(Int16[] c, int cstart, Int16[] words1, int astart, Int16[] words2, int bstart, int n);
    private static void TwosComplement(Int16[] words1, int words1Start, int n);
    private int ByteCount();
    private int PositiveCompare(EInteger t);
    private EInteger[] RootRemInternal(EInteger root, bool useRem);
    private EInteger[] SqrtRemInternal(bool useRem);
    public EInteger Increment();
    public EInteger Decrement();
    public byte ToByteChecked();
    public byte ToByteUnchecked();
    public static EInteger FromByte(byte inputByte);
    public short ToInt16Checked();
    public short ToInt16Unchecked();
    public static EInteger FromInt16(short inputInt16);
    [CLSCompliantAttribute("False")]
public static EInteger FromUInt64(ulong ulongValue);
    public static EInteger op_Addition(EInteger bthis, EInteger augend);
    public static EInteger op_Subtraction(EInteger bthis, EInteger subtrahend);
    public static EInteger op_Increment(EInteger bthis);
    public static EInteger op_Decrement(EInteger bthis);
    public static EInteger op_Multiply(EInteger operand1, EInteger operand2);
    public static EInteger op_Division(EInteger dividend, EInteger divisor);
    public static EInteger op_Modulus(EInteger dividend, EInteger divisor);
    public static EInteger op_LeftShift(EInteger bthis, int bitCount);
    public static EInteger ModPow(EInteger bigintValue, EInteger pow, EInteger mod);
    public static EInteger op_RightShift(EInteger bthis, int smallValue);
    public static EInteger op_UnaryNegation(EInteger bigValue);
    [CLSCompliantAttribute("False")]
public ulong ToUInt64Checked();
    [CLSCompliantAttribute("False")]
public ulong ToUInt64Unchecked();
    public static bool op_LessThan(EInteger thisValue, EInteger otherValue);
    public static bool op_LessThanOrEqual(EInteger thisValue, EInteger otherValue);
    public static bool op_GreaterThan(EInteger thisValue, EInteger otherValue);
    public static bool op_GreaterThanOrEqual(EInteger thisValue, EInteger otherValue);
    public static EInteger op_OnesComplement(EInteger thisValue);
    public static EInteger op_BitwiseAnd(EInteger thisValue, EInteger otherValue);
    public static EInteger op_BitwiseOr(EInteger thisValue, EInteger otherValue);
    public static EInteger op_ExclusiveOr(EInteger a, EInteger b);
    public long GetBits(int index, int numberBits);
    [ObsoleteAttribute("Use the DivRem instance method instead.")]
public static EInteger DivRem(EInteger dividend, EInteger divisor, EInteger& remainder);
    public sealed virtual bool Equals(EInteger other);
    public static EInteger Not(EInteger valueA);
    public static EInteger And(EInteger a, EInteger b);
    public static EInteger Or(EInteger first, EInteger second);
    public static EInteger Xor(EInteger a, EInteger b);
    public static byte op_Explicit(EInteger input);
    public static EInteger op_Explicit(bool boolValue);
    public static EInteger op_Implicit(byte inputByte);
    [CLSCompliantAttribute("False")]
public sbyte ToSByteChecked();
    [CLSCompliantAttribute("False")]
public sbyte ToSByteUnchecked();
    [CLSCompliantAttribute("False")]
public static EInteger FromSByte(sbyte inputSByte);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(EInteger input);
    [CLSCompliantAttribute("False")]
public static EInteger op_Implicit(sbyte inputSByte);
    public static short op_Explicit(EInteger input);
    public static EInteger op_Implicit(short inputInt16);
    [CLSCompliantAttribute("False")]
public ushort ToUInt16Checked();
    [CLSCompliantAttribute("False")]
public ushort ToUInt16Unchecked();
    [CLSCompliantAttribute("False")]
public static EInteger FromUInt16(ushort inputUInt16);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(EInteger input);
    [CLSCompliantAttribute("False")]
public static EInteger op_Implicit(ushort inputUInt16);
    public static int op_Explicit(EInteger input);
    public static EInteger op_Implicit(int inputInt32);
    [CLSCompliantAttribute("False")]
public UInt32 ToUInt32Checked();
    [CLSCompliantAttribute("False")]
public UInt32 ToUInt32Unchecked();
    [CLSCompliantAttribute("False")]
public static EInteger FromUInt32(UInt32 inputUInt32);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(EInteger input);
    [CLSCompliantAttribute("False")]
public static EInteger op_Implicit(UInt32 inputUInt32);
    public static long op_Explicit(EInteger input);
    public static EInteger op_Implicit(long inputInt64);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(EInteger input);
    [CLSCompliantAttribute("False")]
public static EInteger op_Implicit(ulong inputUInt64);
}
internal static class PeterO.Numbers.EIntegerByteArrayString : object {
    private static int ShortMask;
    public static EInteger FromRadixSubstringImpl(Byte[] cs, int radix, int index, int endIndex, bool throwException);
    private static EInteger FromRadixSubstringGeneral(Byte[] cs, int radix, int index, int endIndex, bool negative, bool throwException);
    private static EInteger FromRadixSubstringInner(Byte[] cs, int radix, int index, int endIndex, bool negative, bool throwException);
}
internal static class PeterO.Numbers.EIntegerCharArrayString : object {
    private static int ShortMask;
    public static EInteger FromRadixSubstringImpl(Char[] cs, int radix, int index, int endIndex, bool throwException);
    private static EInteger FromRadixSubstringGeneral(Char[] cs, int radix, int index, int endIndex, bool negative, bool throwException);
    private static EInteger FromRadixSubstringInner(Char[] cs, int radix, int index, int endIndex, bool negative, bool throwException);
}
internal static class PeterO.Numbers.EIntegerTextString : object {
    private static int ShortMask;
    public static EInteger FromRadixSubstringImpl(string cs, int radix, int index, int endIndex, bool throwException);
    private static EInteger FromRadixSubstringGeneral(string cs, int radix, int index, int endIndex, bool negative, bool throwException);
    private static EInteger FromRadixSubstringInner(string cs, int radix, int index, int endIndex, bool negative, bool throwException);
}
public class PeterO.Numbers.ERational : object {
    public static ERational NaN;
    public static ERational NegativeInfinity;
    public static ERational NegativeZero;
    public static ERational One;
    public static ERational PositiveInfinity;
    public static ERational SignalingNaN;
    public static ERational Ten;
    public static ERational Zero;
    private FastIntegerFixed denominator;
    private byte flags;
    private FastIntegerFixed unsignedNumerator;
    public EInteger Denominator { get; }
    public bool IsFinite { get; }
    public bool IsNegative { get; }
    public bool IsZero { get; }
    public EInteger Numerator { get; }
    public int Sign { get; }
    public EInteger UnsignedNumerator { get; }
    private ERational(FastIntegerFixed numerator, FastIntegerFixed denominator, byte flags);
    [ObsoleteAttribute("Use the Create method instead.")]
public ERational(EInteger numerator, EInteger denominator);
    private static ERational();
    public ERational Copy();
    public EInteger get_Denominator();
    public bool get_IsFinite();
    public bool get_IsNegative();
    public bool get_IsZero();
    public bool IsInteger();
    public EInteger get_Numerator();
    public int get_Sign();
    public EInteger get_UnsignedNumerator();
    public static ERational Create(int numeratorSmall, int denominatorSmall);
    public static ERational Create(long numeratorLong, long denominatorLong);
    public static ERational Create(EInteger numerator, EInteger denominator);
    public static ERational CreateNaN(EInteger diag);
    public static ERational CreateNaN(EInteger diag, bool signaling, bool negative);
    public static ERational FromDouble(double flt);
    [ObsoleteAttribute("Renamed to FromEDecimal.")]
public static ERational FromExtendedDecimal(EDecimal ef);
    [ObsoleteAttribute("Renamed to FromEFloat.")]
public static ERational FromExtendedFloat(EFloat ef);
    public static ERational FromEDecimal(EDecimal ef);
    public static ERational FromEFloat(EFloat ef);
    public static ERational FromEInteger(EInteger bigint);
    public static ERational FromSingle(float flt);
    public static ERational FromSingleBits(int value);
    public static ERational FromDoubleBits(long value);
    public static ERational FromString(string str);
    public static ERational FromString(string str, int offset, int length);
    public static ERational FromString(Char[] chars);
    public static ERational FromString(Char[] chars, int offset, int length);
    public static ERational FromString(Byte[] bytes);
    public static ERational FromString(Byte[] bytes, int offset, int length);
    public int CompareToTotalMagnitude(ERational other);
    public int CompareToTotal(ERational other);
    public ERational Abs();
    public ERational Add(ERational otherValue);
    public sealed virtual int CompareTo(ERational other);
    public int CompareToValue(ERational other);
    public static ERational Max(ERational first, ERational second);
    public static ERational MaxMagnitude(ERational first, ERational second);
    public static ERational Min(ERational first, ERational second);
    public static ERational MinMagnitude(ERational first, ERational second);
    public int CompareTo(int intOther);
    public int CompareToValue(int intOther);
    public int CompareToValue(long intOther);
    public int CompareTo(long intOther);
    public int CompareToBinary(EFloat other);
    public int CompareToDecimal(EDecimal other);
    public ERational CopySign(ERational other);
    public ERational Divide(ERational otherValue);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ERational other);
    public virtual int GetHashCode();
    public bool IsInfinity();
    public bool IsNaN();
    public bool IsNegativeInfinity();
    public bool IsPositiveInfinity();
    public bool IsQuietNaN();
    public bool IsSignalingNaN();
    public ERational Multiply(ERational otherValue);
    public ERational Negate();
    public ERational Remainder(ERational otherValue);
    public ERational Subtract(ERational otherValue);
    public double ToDouble();
    public long ToDoubleBits();
    public int ToSingleBits();
    public ERational ToLowestTerms();
    public EInteger ToSizedEInteger(int maxBitLength);
    public EInteger ToSizedEIntegerIfExact(int maxBitLength);
    public EInteger ToEInteger();
    [ObsoleteAttribute("Renamed to ToEIntegerIfExact.")]
public EInteger ToEIntegerExact();
    public EInteger ToEIntegerIfExact();
    public EDecimal ToEDecimal();
    public EDecimal ToEDecimal(EContext ctx);
    public EDecimal ToEDecimalExactIfPossible(EContext ctx);
    [ObsoleteAttribute("Renamed to ToEDecimal.")]
public EDecimal ToExtendedDecimal();
    [ObsoleteAttribute("Renamed to ToEDecimal.")]
public EDecimal ToExtendedDecimal(EContext ctx);
    [ObsoleteAttribute("Renamed to ToEDecimalExactIfPossible.")]
public EDecimal ToExtendedDecimalExactIfPossible(EContext ctx);
    public EFloat ToEFloat();
    public EFloat ToEFloat(EContext ctx);
    public EFloat ToEFloatExactIfPossible(EContext ctx);
    [ObsoleteAttribute("Renamed to ToEFloat.")]
public EFloat ToExtendedFloat();
    [ObsoleteAttribute("Renamed to ToEFloat.")]
public EFloat ToExtendedFloat(EContext ctx);
    [ObsoleteAttribute("Renamed to ToEFloatExactIfPossible.")]
public EFloat ToExtendedFloatExactIfPossible(EContext ctx);
    public float ToSingle();
    public virtual string ToString();
    public ERational Increment();
    public ERational Decrement();
    public ERational Add(int v);
    public ERational Subtract(int v);
    public ERational Multiply(int v);
    public ERational Divide(int v);
    public ERational Remainder(int v);
    public ERational Add(long v);
    public ERational Subtract(long v);
    public ERational Multiply(long v);
    public ERational Divide(long v);
    public ERational Remainder(long v);
    private void CheckTrivialOverflow(int maxBits);
    public byte ToByteChecked();
    public byte ToByteUnchecked();
    public byte ToByteIfExact();
    public static ERational FromByte(byte inputByte);
    public short ToInt16Checked();
    public short ToInt16Unchecked();
    public short ToInt16IfExact();
    public static ERational FromInt16(short inputInt16);
    public int ToInt32Checked();
    public int ToInt32Unchecked();
    public int ToInt32IfExact();
    public static ERational FromBoolean(bool boolValue);
    public static ERational FromInt32(int inputInt32);
    public long ToInt64Checked();
    public long ToInt64Unchecked();
    public long ToInt64IfExact();
    public static ERational FromInt64AsUnsigned(long longerValue);
    public static ERational FromInt64(long inputInt64);
    public static ERational op_Explicit(bool boolValue);
    public static ERational op_Implicit(EInteger eint);
    public static ERational op_Implicit(EDecimal eint);
    public static ERational op_Implicit(EFloat eint);
    public static ERational FromDecimal(decimal eint);
    public static ERational op_Implicit(decimal eint);
    public static ERational op_Implicit(float eint);
    public static ERational op_Implicit(double eint);
    public static ERational op_Addition(ERational bthis, ERational augend);
    public static ERational op_Subtraction(ERational bthis, ERational subtrahend);
    public static ERational op_Increment(ERational bthis);
    public static ERational op_Decrement(ERational bthis);
    public static ERational op_Multiply(ERational operand1, ERational operand2);
    public static ERational op_Division(ERational dividend, ERational divisor);
    public static ERational op_Modulus(ERational dividend, ERational divisor);
    public static ERational op_UnaryNegation(ERational bigValue);
    public decimal ToDecimal();
    public static decimal op_Explicit(ERational extendedNumber);
    public static EInteger op_Explicit(ERational bigValue);
    public static double op_Explicit(ERational bigValue);
    public static float op_Explicit(ERational bigValue);
    public static byte op_Explicit(ERational input);
    public static ERational op_Implicit(byte inputByte);
    [CLSCompliantAttribute("False")]
public sbyte ToSByteChecked();
    [CLSCompliantAttribute("False")]
public sbyte ToSByteUnchecked();
    [CLSCompliantAttribute("False")]
public sbyte ToSByteIfExact();
    [CLSCompliantAttribute("False")]
public static ERational FromSByte(sbyte inputSByte);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(ERational input);
    [CLSCompliantAttribute("False")]
public static ERational op_Implicit(sbyte inputSByte);
    public static short op_Explicit(ERational input);
    public static ERational op_Implicit(short inputInt16);
    [CLSCompliantAttribute("False")]
public ushort ToUInt16Checked();
    [CLSCompliantAttribute("False")]
public ushort ToUInt16Unchecked();
    [CLSCompliantAttribute("False")]
public ushort ToUInt16IfExact();
    [CLSCompliantAttribute("False")]
public static ERational FromUInt16(ushort inputUInt16);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(ERational input);
    [CLSCompliantAttribute("False")]
public static ERational op_Implicit(ushort inputUInt16);
    public static int op_Explicit(ERational input);
    public static ERational op_Implicit(int inputInt32);
    [CLSCompliantAttribute("False")]
public UInt32 ToUInt32Checked();
    [CLSCompliantAttribute("False")]
public UInt32 ToUInt32Unchecked();
    [CLSCompliantAttribute("False")]
public UInt32 ToUInt32IfExact();
    [CLSCompliantAttribute("False")]
public static ERational FromUInt32(UInt32 inputUInt32);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(ERational input);
    [CLSCompliantAttribute("False")]
public static ERational op_Implicit(UInt32 inputUInt32);
    public static long op_Explicit(ERational input);
    public static ERational op_Implicit(long inputInt64);
    [CLSCompliantAttribute("False")]
public ulong ToUInt64Checked();
    [CLSCompliantAttribute("False")]
public ulong ToUInt64Unchecked();
    [CLSCompliantAttribute("False")]
public ulong ToUInt64IfExact();
    [CLSCompliantAttribute("False")]
public static ERational FromUInt64(ulong inputUInt64);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(ERational input);
    [CLSCompliantAttribute("False")]
public static ERational op_Implicit(ulong inputUInt64);
}
internal static class PeterO.Numbers.ERationalByteArrayString : object {
    private static int MaxSafeInt;
    public static ERational FromString(Byte[] chars, int offset, int length, bool throwException);
}
internal static class PeterO.Numbers.ERationalCharArrayString : object {
    private static int MaxSafeInt;
    public static ERational FromString(Char[] chars, int offset, int length, bool throwException);
}
internal static class PeterO.Numbers.ERationalTextString : object {
    private static int MaxSafeInt;
    public static ERational FromString(string chars, int offset, int length, bool throwException);
}
public enum PeterO.Numbers.ERounding : Enum {
    public int value__;
    public static ERounding None;
    public static ERounding Up;
    public static ERounding Down;
    public static ERounding HalfUp;
    public static ERounding HalfDown;
    public static ERounding HalfEven;
    public static ERounding Ceiling;
    public static ERounding Floor;
    [ObsoleteAttribute("Consider using ERounding.OddOrZeroFiveUp instead.")]
public static ERounding Odd;
    [ObsoleteAttribute("Use ERounding.OddOrZeroFiveUp instead.")]
public static ERounding ZeroFiveUp;
    public static ERounding OddOrZeroFiveUp;
}
public class PeterO.Numbers.ETrapException : ArithmeticException {
    private object result;
    private EContext ctx;
    private int error;
    private int errors;
    public EContext Context { get; }
    public object Result { get; }
    public int Error { get; }
    public int Errors { get; }
    public ETrapException(string message);
    public ETrapException(string message, Exception innerException);
    public ETrapException(int flag, EContext ctx, object result);
    public ETrapException(int flags, int flag, EContext ctx, object result);
    public EContext get_Context();
    public object get_Result();
    public int get_Error();
    public int get_Errors();
    public bool HasError(int flag);
    private static string FlagToMessage(int flags);
}
internal class PeterO.Numbers.ExtendedOrSimpleRadixMath`1 : object {
    private RadixMath`1<T> ext;
    private SimpleRadixMath`1<T> simp;
    public ExtendedOrSimpleRadixMath`1(IRadixMathHelper`1<T> helper);
    public sealed virtual IRadixMathHelper`1<T> GetHelper();
    public sealed virtual T DivideToIntegerNaturalScale(T thisValue, T divisor, EContext ctx);
    public sealed virtual T DivideToIntegerZeroScale(T thisValue, T divisor, EContext ctx);
    public sealed virtual T Abs(T value, EContext ctx);
    public sealed virtual T Negate(T value, EContext ctx);
    public sealed virtual T Remainder(T thisValue, T divisor, EContext ctx, bool roundAfterDivide);
    public sealed virtual T RemainderNear(T thisValue, T divisor, EContext ctx);
    public sealed virtual T Pi(EContext ctx);
    public sealed virtual T Power(T thisValue, T pow, EContext ctx);
    public sealed virtual T Ln(T thisValue, EContext ctx);
    public sealed virtual T Exp(T thisValue, EContext ctx);
    public sealed virtual T SquareRoot(T thisValue, EContext ctx);
    public sealed virtual T NextMinus(T thisValue, EContext ctx);
    public sealed virtual T NextToward(T thisValue, T otherValue, EContext ctx);
    public sealed virtual T NextPlus(T thisValue, EContext ctx);
    public sealed virtual T DivideToExponent(T thisValue, T divisor, EInteger desiredExponent, EContext ctx);
    public sealed virtual T Divide(T thisValue, T divisor, EContext ctx);
    public sealed virtual T MinMagnitude(T a, T b, EContext ctx);
    public sealed virtual T MaxMagnitude(T a, T b, EContext ctx);
    public sealed virtual T Max(T a, T b, EContext ctx);
    public sealed virtual T Min(T a, T b, EContext ctx);
    public sealed virtual T Multiply(T thisValue, T other, EContext ctx);
    public sealed virtual T MultiplyAndAdd(T thisValue, T multiplicand, T augend, EContext ctx);
    public sealed virtual T Plus(T thisValue, EContext ctx);
    public sealed virtual T RoundToPrecision(T thisValue, EContext ctx);
    public sealed virtual T RoundAfterConversion(T thisValue, EContext ctx);
    public sealed virtual T SignalOverflow(EContext ctx, bool neg);
    public sealed virtual T Quantize(T thisValue, T otherValue, EContext ctx);
    public sealed virtual T RoundToExponentExact(T thisValue, EInteger expOther, EContext ctx);
    public sealed virtual T RoundToExponentSimple(T thisValue, EInteger expOther, EContext ctx);
    public sealed virtual T RoundToExponentNoRoundedFlag(T thisValue, EInteger exponent, EContext ctx);
    public sealed virtual T Reduce(T thisValue, EContext ctx);
    public sealed virtual T Add(T thisValue, T other, EContext ctx);
    public sealed virtual T AddEx(T thisValue, T other, EContext ctx, bool roundToOperandPrecision);
    public sealed virtual T CompareToWithContext(T thisValue, T otherValue, bool treatQuietNansAsSignaling, EContext ctx);
    public sealed virtual int CompareTo(T thisValue, T otherValue);
}
internal static class PeterO.Numbers.Extras : object {
    public static Byte[] CharsConcat(Byte[] c1, int offset1, int length1, Byte[] c2, int offset2, int length2);
    public static string CharsConcat(string s1, int offset1, int length1, string s2, int offset2, int length2);
    public static Char[] CharsConcat(Char[] c1, int offset1, int length1, Char[] c2, int offset2, int length2);
    public static Int32[] DoubleToIntegers(double dbl);
    public static double IntegersToDouble(Int32[] integers);
    public static double IntegersToDouble(int lsw, int msw);
}
internal class PeterO.Numbers.FastInteger : object {
    private static string Digits;
    private int smallValue;
    private MutableNumber mnum;
    private EInteger largeValue;
    private int integerMode;
    private bool frozen;
    private static EInteger ValueInt32MinValue;
    private static EInteger ValueInt32MaxValue;
    private static EInteger ValueNegativeInt32MinValue;
    internal bool IsEvenNumber { get; }
    internal int Sign { get; }
    internal bool IsValueZero { get; }
    internal FastInteger(int value);
    private static FastInteger();
    internal FastInteger Copy();
    internal static FastInteger CopyFrozen(FastInteger value);
    internal static FastInteger FromInt64(long longVal);
    internal static FastInteger FromBig(EInteger bigintVal);
    internal int ToInt32();
    public int CompareTo(EInteger ei);
    public sealed virtual int CompareTo(FastInteger val);
    internal FastInteger Abs();
    internal static Int32[] GetLastWords(EInteger bigint, int numWords32Bit);
    internal FastInteger SetInt(int val);
    internal FastInteger Multiply(int val);
    internal FastInteger Negate();
    internal FastInteger Subtract(FastInteger val);
    internal FastInteger SubtractInt(int val);
    internal FastInteger AddBig(EInteger bigintVal);
    internal FastInteger SubtractBig(EInteger bigintVal);
    internal FastInteger Add(FastInteger val);
    internal FastInteger Remainder(int divisor);
    internal FastInteger Increment();
    internal FastInteger Decrement();
    internal FastInteger Divide(int divisor);
    internal EInteger ShiftEIntegerLeftByThis(EInteger ei);
    internal bool get_IsEvenNumber();
    internal FastInteger AddInt64(long longVal);
    internal FastInteger SubtractInt64(long longVal);
    internal FastInteger AddInt(int val);
    internal bool CanFitInInt32();
    internal bool CanFitInInt64();
    internal long ToInt64();
    public static string IntToString(int value);
    public static string LongToString(long longValue);
    public virtual string ToString();
    internal int get_Sign();
    internal bool get_IsValueZero();
    internal int CompareToInt(int val);
    internal EInteger ToEInteger();
}
internal class PeterO.Numbers.FastIntegerFixed : object {
    private static int CacheFirst;
    private static int CacheLast;
    private int smallValue;
    private EInteger largeValue;
    private IntegerMode integerMode;
    public static FastIntegerFixed Zero;
    public static FastIntegerFixed One;
    private static FastIntegerFixed[] Cache;
    internal bool IsEvenNumber { get; }
    internal int Sign { get; }
    internal bool IsValueZero { get; }
    private FastIntegerFixed(IntegerMode integerMode, int smallValue, EInteger largeValue);
    private static FastIntegerFixed();
    private static FastIntegerFixed[] FastIntegerFixedCache(int first, int last);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal static FastIntegerFixed FromInt32(int intVal);
    internal static FastIntegerFixed FromInt64(long longVal);
    internal static FastIntegerFixed FromBig(EInteger bigintVal);
    internal int ToInt32();
    public static FastIntegerFixed FromFastInteger(FastInteger fi);
    public FastInteger ToFastInteger();
    public FastIntegerFixed Increment();
    public int Mod(int value);
    public static FastIntegerFixed Add(FastIntegerFixed a, FastIntegerFixed b);
    public static FastIntegerFixed Subtract(FastIntegerFixed a, FastIntegerFixed b);
    public FastIntegerFixed Add(int ib);
    public FastIntegerFixed Subtract(int ib);
    public FastIntegerFixed Add(FastIntegerFixed b);
    public FastIntegerFixed Subtract(FastIntegerFixed b);
    public FastIntegerFixed Add(EInteger b);
    public FastIntegerFixed Subtract(EInteger b);
    public FastIntegerFixed Abs();
    public FastIntegerFixed Negate();
    public int CompareTo(EInteger evalue);
    public int CompareTo(FastInteger fint);
    public sealed virtual int CompareTo(FastIntegerFixed val);
    internal FastIntegerFixed Copy();
    internal bool get_IsEvenNumber();
    internal bool CanFitInInt32();
    public virtual string ToString();
    internal int get_Sign();
    internal bool get_IsValueZero();
    internal bool CanFitInInt64();
    internal long ToInt64();
    internal int CompareToInt64(long valLong);
    internal int CompareToInt(int val);
    internal EInteger ToEInteger();
}
internal interface PeterO.Numbers.IRadixMath`1 {
    public abstract virtual IRadixMathHelper`1<T> GetHelper();
    public abstract virtual T DivideToIntegerNaturalScale(T thisValue, T divisor, EContext ctx);
    public abstract virtual T DivideToIntegerZeroScale(T thisValue, T divisor, EContext ctx);
    public abstract virtual T Abs(T value, EContext ctx);
    public abstract virtual T Negate(T value, EContext ctx);
    public abstract virtual T Remainder(T thisValue, T divisor, EContext ctx, bool roundAfterDivide);
    public abstract virtual T RemainderNear(T thisValue, T divisor, EContext ctx);
    public abstract virtual T Pi(EContext ctx);
    public abstract virtual T Power(T thisValue, T pow, EContext ctx);
    public abstract virtual T Ln(T thisValue, EContext ctx);
    public abstract virtual T Exp(T thisValue, EContext ctx);
    public abstract virtual T SquareRoot(T thisValue, EContext ctx);
    public abstract virtual T NextMinus(T thisValue, EContext ctx);
    public abstract virtual T NextToward(T thisValue, T otherValue, EContext ctx);
    public abstract virtual T NextPlus(T thisValue, EContext ctx);
    public abstract virtual T DivideToExponent(T thisValue, T divisor, EInteger desiredExponent, EContext ctx);
    public abstract virtual T Divide(T thisValue, T divisor, EContext ctx);
    public abstract virtual T MinMagnitude(T a, T b, EContext ctx);
    public abstract virtual T MaxMagnitude(T a, T b, EContext ctx);
    public abstract virtual T Max(T a, T b, EContext ctx);
    public abstract virtual T Min(T a, T b, EContext ctx);
    public abstract virtual T Multiply(T thisValue, T other, EContext ctx);
    public abstract virtual T MultiplyAndAdd(T thisValue, T multiplicand, T augend, EContext ctx);
    public abstract virtual T Plus(T thisValue, EContext ctx);
    public abstract virtual T RoundToPrecision(T thisValue, EContext ctx);
    public abstract virtual T RoundAfterConversion(T thisValue, EContext ctx);
    public abstract virtual T SignalOverflow(EContext ctx, bool neg);
    public abstract virtual T Quantize(T thisValue, T otherValue, EContext ctx);
    public abstract virtual T RoundToExponentExact(T thisValue, EInteger expOther, EContext ctx);
    public abstract virtual T RoundToExponentSimple(T thisValue, EInteger expOther, EContext ctx);
    public abstract virtual T RoundToExponentNoRoundedFlag(T thisValue, EInteger exponent, EContext ctx);
    public abstract virtual T Reduce(T thisValue, EContext ctx);
    public abstract virtual T Add(T thisValue, T other, EContext ctx);
    public abstract virtual T AddEx(T thisValue, T other, EContext ctx, bool roundToOperandPrecision);
    public abstract virtual T CompareToWithContext(T thisValue, T otherValue, bool treatQuietNansAsSignaling, EContext ctx);
    public abstract virtual int CompareTo(T thisValue, T otherValue);
}
internal interface PeterO.Numbers.IRadixMathHelper`1 {
    public abstract virtual int GetRadix();
    public abstract virtual int GetArithmeticSupport();
    public abstract virtual int GetSign(T value);
    public abstract virtual int GetFlags(T value);
    public abstract virtual EInteger GetMantissa(T value);
    public abstract virtual EInteger GetExponent(T value);
    public abstract virtual FastIntegerFixed GetMantissaFastInt(T value);
    public abstract virtual FastIntegerFixed GetExponentFastInt(T value);
    public abstract virtual T ValueOf(int val);
    public abstract virtual T CreateNewWithFlags(EInteger mantissa, EInteger exponent, int flags);
    public abstract virtual T CreateNewWithFlagsFastInt(FastIntegerFixed mantissa, FastIntegerFixed exponent, int flags);
    public abstract virtual IShiftAccumulator CreateShiftAccumulatorWithDigits(EInteger value, int lastDigit, int olderDigits);
    public abstract virtual IShiftAccumulator CreateShiftAccumulatorWithDigitsFastInt(FastIntegerFixed value, int lastDigit, int olderDigits);
    public abstract virtual FastInteger DivisionShift(EInteger num, EInteger den);
    public abstract virtual FastInteger GetDigitLength(EInteger ei);
    public abstract virtual EInteger MultiplyByRadixPower(EInteger value, FastInteger power);
    public abstract virtual FastIntegerFixed MultiplyByRadixPowerFastInt(FastIntegerFixed value, FastIntegerFixed power);
}
internal interface PeterO.Numbers.IShiftAccumulator {
    public EInteger ShiftedInt { get; }
    public int OlderDiscardedDigits { get; }
    public int LastDiscardedDigit { get; }
    public FastInteger ShiftedIntFast { get; }
    public FastInteger DiscardedDigitCount { get; }
    public abstract virtual EInteger get_ShiftedInt();
    public abstract virtual FastInteger GetDigitLength();
    public abstract virtual FastInteger OverestimateDigitLength();
    public abstract virtual int get_OlderDiscardedDigits();
    public abstract virtual int get_LastDiscardedDigit();
    public abstract virtual FastInteger get_ShiftedIntFast();
    public abstract virtual FastInteger get_DiscardedDigitCount();
    public abstract virtual void TruncateOrShiftRight(FastInteger bits, bool truncate);
    public abstract virtual int ShiftedIntMod(int mod);
    public abstract virtual void ShiftRightInt(int bits);
    public abstract virtual void ShiftToDigits(FastInteger bits, FastInteger preShift, bool truncate);
}
internal static class PeterO.Numbers.NumberUtility : object {
    private static EInteger[] ValueBigIntPowersOfTen;
    private static EInteger[] ValueBigIntPowersOfFive;
    private static PowerCache ValuePowerOfFiveCache;
    private static PowerCache ValuePowerOfTenCache;
    private static EInteger ValueFivePower40;
    private static NumberUtility();
    internal static int ShiftLeftOne(Int32[] arr);
    private static int CountTrailingZeros(int numberValue);
    internal static int BitLength(int numberValue);
    internal static int ShiftAwayTrailingZerosTwoElements(Int32[] arr);
    internal static bool HasBitSet(Int32[] arr, int bit);
    public static EInteger FindPowerOfTen(long diffLong);
    internal static EInteger MultiplyByPowerOfTen(EInteger v, int precision);
    internal static EInteger MultiplyByPowerOfTen(EInteger v, EInteger eprecision);
    internal static EInteger MultiplyByPowerOfFive(EInteger v, int precision);
    internal static EInteger MultiplyByPowerOfFive(EInteger v, EInteger epower);
    internal static EInteger FindPowerOfFiveFromBig(EInteger diff);
    internal static EInteger FindPowerOfTenFromBig(EInteger bigintExponent);
    internal static EInteger FindPowerOfFive(int precision);
    internal static EInteger FindPowerOfTen(int precision);
    public static int BitLength(long mantlong);
    public static THelper PreRound(THelper val, EContext ctx, IRadixMath`1<THelper> wrapper);
    public static int DecimalDigitLength(int v2);
    public static int DecimalDigitLength(long value);
    public static EInteger[] DecimalDigitLengthBoundsAsEI(EInteger ei);
    public static FastInteger[] DecimalDigitLengthBounds(EInteger ei);
    public static FastInteger[] DigitLengthBounds(IRadixMathHelper`1<THelper> helper, EInteger ei);
    private static FastIntegerFixed FastPathDigitLength(FastIntegerFixed fei, int radix);
    public static FastIntegerFixed[] DigitLengthBoundsFixed(IRadixMathHelper`1<THelper> helper, FastIntegerFixed fei);
    public static EInteger IntegerDigitLengthUpperBound(IRadixMathHelper`1<THelper> helper, THelper val);
    public static FastIntegerFixed DigitLengthFixed(IRadixMathHelper`1<THelper> helper, FastIntegerFixed fei);
    public static FastInteger DigitLengthUpperBound(IRadixMathHelper`1<THelper> helper, EInteger ei);
    public static EInteger ReduceTrailingZeros(EInteger bigmant, FastInteger exponentMutable, int radix, FastInteger digits, FastInteger precision, FastInteger idealExp);
}
internal class PeterO.Numbers.RadixMath`1 : object {
    private static int IntegerModeFixedScale;
    private static int IntegerModeRegular;
    private static int SafeMin32;
    private static int SafeMax32;
    private static long SafeMin64;
    private static long SafeMax64;
    private static Int32[] BitMasks;
    private static Int64[] BitMasks64;
    private static Int32[] OverflowMaxes;
    private static EInteger ValueMinusOne;
    private static Int32[] ValueTenPowers;
    private static Int64[] OverflowMaxes64;
    private static Int64[] ValueTenPowers64;
    private IRadixMathHelper`1<T> helper;
    private int support;
    private int thisRadix;
    private static EInteger valueMaxDigits;
    private static Int32[] BitsPerDigit;
    private static EContext DefaultUnlimited;
    public RadixMath`1(IRadixMathHelper`1<T> helper);
    private static RadixMath`1();
    public sealed virtual T Add(T thisValue, T other, EContext ctx);
    private FastInteger DigitLengthUpperBoundForBitPrecision(FastInteger prec);
    private T AddEx32Bit(int expcmp, FastIntegerFixed op1Exponent, FastIntegerFixed op1Mantissa, FastIntegerFixed op2Exponent, FastIntegerFixed op2Mantissa, FastIntegerFixed resultExponent, int thisFlags, int otherFlags, EContext ctx);
    private T AddEx64Bit(long expcmp, FastIntegerFixed op1Exponent, FastIntegerFixed op1Mantissa, FastIntegerFixed op2Exponent, FastIntegerFixed op2Mantissa, FastIntegerFixed resultExponent, int thisFlags, int otherFlags, EContext ctx);
    public sealed virtual T AddEx(T thisValue, T other, EContext ctx, bool roundToOperandPrecision);
    public sealed virtual int CompareTo(T thisValue, T otherValue);
    public sealed virtual T CompareToWithContext(T thisValue, T otherValue, bool treatQuietNansAsSignaling, EContext ctx);
    public sealed virtual T Divide(T thisValue, T divisor, EContext ctx);
    public sealed virtual T DivideToExponent(T thisValue, T divisor, EInteger desiredExponent, EContext ctx);
    public sealed virtual T DivideToIntegerNaturalScale(T thisValue, T divisor, EContext ctx);
    private T SignalUnderflow(EContext ec, bool negative, bool zeroSignificand);
    public sealed virtual T DivideToIntegerZeroScale(T thisValue, T divisor, EContext ctx);
    private EInteger WorkingDigits(EInteger workingBits);
    public sealed virtual T Exp(T thisValue, EContext ctx);
    private T Exp(T thisValue, EContext ctx, EInteger workingPrecision);
    public sealed virtual IRadixMathHelper`1<T> GetHelper();
    public static EFloat FastLn(EFloat x, EContext ctx);
    public sealed virtual T Ln(T thisValue, EContext ctx);
    public sealed virtual T Max(T a, T b, EContext ctx);
    public sealed virtual T MaxMagnitude(T a, T b, EContext ctx);
    public sealed virtual T Min(T a, T b, EContext ctx);
    public sealed virtual T MinMagnitude(T a, T b, EContext ctx);
    public sealed virtual T Multiply(T thisValue, T other, EContext ctx);
    public sealed virtual T MultiplyAndAdd(T thisValue, T multiplicand, T augend, EContext ctx);
    public sealed virtual T Negate(T value, EContext ctx);
    public sealed virtual T NextMinus(T thisValue, EContext ctx);
    public sealed virtual T NextPlus(T thisValue, EContext ctx);
    public sealed virtual T NextToward(T thisValue, T otherValue, EContext ctx);
    public sealed virtual T Pi(EContext ctx);
    public sealed virtual T Plus(T thisValue, EContext context);
    public sealed virtual T Power(T thisValue, T pow, EContext ctx);
    private bool IsSubnormal(T value, EContext ctx);
    public sealed virtual T Quantize(T thisValue, T otherValue, EContext ctx);
    public sealed virtual T Reduce(T thisValue, EContext ctx);
    public sealed virtual T Remainder(T thisValue, T divisor, EContext ctx, bool roundAfterDivide);
    public sealed virtual T RemainderNear(T thisValue, T divisor, EContext ctx);
    public sealed virtual T RoundAfterConversion(T thisValue, EContext ctx);
    public sealed virtual T RoundToExponentExact(T thisValue, EInteger expOther, EContext ctx);
    public sealed virtual T RoundToExponentNoRoundedFlag(T thisValue, EInteger exponent, EContext ctx);
    public sealed virtual T RoundToExponentSimple(T thisValue, EInteger expOther, EContext ctx);
    public sealed virtual T RoundToPrecision(T thisValue, EContext context);
    private T Root(T thisValue, int root, EContext ctx);
    public sealed virtual T SquareRoot(T thisValue, EContext ctx);
    private static int CompareToFast(int e1int, int e2int, int expcmp, int signA, FastIntegerFixed op1Mantissa, FastIntegerFixed op2Mantissa, int radix);
    private static int CompareToFast64(int e1int, int e2int, int expcmp, int signA, FastIntegerFixed op1Mantissa, FastIntegerFixed op2Mantissa, int radix);
    private static int CompareToSlow(EInteger op1Exponent, EInteger op2Exponent, int expcmp, int signA, EInteger op1Mantissa, EInteger op2Mantissa, IRadixMathHelper`1<TMath> helper, bool reportOOM);
    private static bool IsNullOrSimpleContext(EContext ctx);
    private static bool IsSimpleContext(EContext ctx);
    private static EInteger PowerOfTwo(FastInteger fi);
    private static FastIntegerFixed RescaleByExponentDiff(FastIntegerFixed mantissa, FastIntegerFixed fe1, FastIntegerFixed fe2, IRadixMathHelper`1<TMath> helper);
    private static EInteger RescaleByExponentDiff(EInteger mantissa, EInteger e1, EInteger e2, IRadixMathHelper`1<TMath> helper);
    private static EContext SetPrecisionIfLimited(EContext ctx, EInteger bigPrecision);
    private static void TransferFlags(EContext ctxDst, EContext ctxSrc);
    public sealed virtual T Abs(T value, EContext ctx);
    private T AbsRaw(T value);
    private T AddCore2(FastIntegerFixed mant1, FastIntegerFixed mant2, FastIntegerFixed exponent, int flags1, int flags2, EContext ctx);
    private T AddCore(EInteger mant1, EInteger mant2, EInteger exponent, int flags1, int flags2, EContext ctx);
    private T AddCore(FastIntegerFixed fmant1, FastIntegerFixed fmant2, FastIntegerFixed exponent, int flags1, int flags2, EContext ctx);
    private static FastInteger ToFastInteger(FastIntegerFixed fif);
    private T AddExDiffExp(FastIntegerFixed op1Exponent, FastIntegerFixed op1Mantissa, FastIntegerFixed op2Exponent, FastIntegerFixed op2Mantissa, int thisFlags, int otherFlags, EContext ctx, int expcmp, bool roundToOperandPrecision);
    private T CompareToHandleSpecial(T thisValue, T other, bool treatQuietNansAsSignaling, EContext ctx);
    private static int CompareToHandleSpecial2(int thisFlags, int otherFlags);
    private static int CompareToInternal(TMath thisValue, TMath otherValue, bool reportOOM, IRadixMathHelper`1<TMath> helper);
    private static string Chop(string str);
    private T DivideInternal(T thisValue, T divisor, EContext ctx, int integerMode, EInteger desiredExponent);
    private T DivisionHandleSpecial(T thisValue, T other, EContext ctx);
    private T EnsureSign(T val, bool negative);
    private T ExpInternalVeryCloseToZero(T thisValue, EInteger workingPrecision, EContext ctx);
    private T ExpInternal(T thisValue, EInteger workingPrecision, EContext ctx);
    private T ExtendPrecision(T thisValue, EContext ctx);
    private T HandleNotANumber(T thisValue, T other, EContext ctx);
    private bool IsFinite(T val);
    private bool IsNegative(T val);
    private bool IsWithinExponentRangeForPow(T thisValue, EContext ctx);
    private T LnInternalCloseToOne2(T thisValue, EInteger workingPrecision, EContext ctx);
    private T LnInternal(T thisValue, EInteger workingPrecision, EContext ctx);
    private T MinMaxHandleSpecial(T thisValue, T otherValue, EContext ctx, bool isMinOp, bool compareAbs);
    private T MultiplyAddHandleSpecial(T op1, T op2, T op3, EContext ctx);
    private T NegateRaw(T val);
    private T PowerIntegral(T thisValue, EInteger powIntBig, EContext ctx);
    private T ReduceToPrecisionAndIdealExponent(T thisValue, EContext ctx, FastInteger precision, FastInteger idealExp);
    private T RemainderHandleSpecial(T thisValue, T other, EContext ctx);
    private T ReturnQuietNaN(T thisValue, EContext ctx);
    private bool IsNullOrInt32FriendlyContext(EContext ctx);
    private bool RoundGivenAccum(IShiftAccumulator accum, ERounding rounding, bool neg);
    private bool RoundGivenDigits(int lastDiscarded, int olderDiscarded, ERounding rounding, bool neg, FastInteger fastNumber);
    private bool RoundGivenDigits(int lastDiscarded, int olderDiscarded, ERounding rounding, bool neg, long longNumber);
    private T RoundToPrecisionInternal(T thisValue, int lastDiscarded, int olderDiscarded, FastInteger shift, bool adjustNegativeZero, EContext ctx);
    private static int CompareToHalf(EInteger bigLeft, EInteger toCompareWith);
    private T RoundToScale(EInteger mantissa, EInteger remainder, EInteger divisor, EInteger desiredExponent, FastInteger shift, bool neg, EContext ctx);
    private Int32[] RoundToScaleStatus(EInteger remainder, EInteger divisor, EContext ctx);
    private T SignalDivideByZero(EContext ctx, bool neg);
    private T SignalingNaNInvalid(T value, EContext ctx);
    private T SignalInvalid(EContext ctx);
    private T SignalInvalidWithMessage(EContext ctx, string str);
    public sealed virtual T SignalOverflow(EContext ctx, bool neg);
    private T SquareRootHandleSpecial(T thisValue, EContext ctx);
    private EInteger TryMultiplyByRadixPower(EInteger bi, int radixPowerInt);
    private EInteger TryMultiplyByRadixPower(EInteger bi, FastInteger radixPower);
    private FastIntegerFixed TryMultiplyByRadixPowerFastInt(FastIntegerFixed bi, FastIntegerFixed radixPower);
    private FastIntegerFixed TryMultiplyByRadixPowerFastInt(FastIntegerFixed bi, FastInteger radixPower);
    private T ValueOf(int value, EContext ctx);
}
internal class PeterO.Numbers.SimpleRadixMath`1 : object {
    private IRadixMath`1<T> wrapper;
    public SimpleRadixMath`1(IRadixMath`1<T> wrapper);
    private static EContext GetContextWithFlags(EContext ctx);
    private T SignalInvalid(EContext ctx);
    private T PostProcess(T thisValue, EContext ctxDest, EContext ctxSrc);
    private T PostProcessAfterDivision(T thisValue, EContext ctxDest, EContext ctxSrc);
    private T PostProcessAfterQuantize(T thisValue, EContext ctxDest, EContext ctxSrc);
    private T PostProcessEx(T thisValue, EContext ctxDest, EContext ctxSrc, bool afterDivision, bool afterQuantize);
    private T ReturnQuietNaN(T thisValue, EContext ctx);
    private T HandleNotANumber(T thisValue, T other, EContext ctx);
    private T CheckNotANumber3(T thisValue, T other, T other2, EContext ctx);
    private T SignalingNaNInvalid(T value, EContext ctx);
    private T CheckNotANumber1(T val, EContext ctx);
    private T CheckNotANumber2(T val, T val2, EContext ctx);
    private T PreRound(T val, EContext ctx);
    public sealed virtual T DivideToIntegerNaturalScale(T thisValue, T divisor, EContext ctx);
    public sealed virtual T DivideToIntegerZeroScale(T thisValue, T divisor, EContext ctx);
    public sealed virtual T Abs(T value, EContext ctx);
    public sealed virtual T Negate(T value, EContext ctx);
    public sealed virtual T Remainder(T thisValue, T divisor, EContext ctx, bool roundAfterDivide);
    public sealed virtual T RemainderNear(T thisValue, T divisor, EContext ctx);
    public sealed virtual T Pi(EContext ctx);
    public sealed virtual T Power(T thisValue, T pow, EContext ctx);
    public sealed virtual T Ln(T thisValue, EContext ctx);
    public sealed virtual IRadixMathHelper`1<T> GetHelper();
    public sealed virtual T Exp(T thisValue, EContext ctx);
    public sealed virtual T SquareRoot(T thisValue, EContext ctx);
    public sealed virtual T NextMinus(T thisValue, EContext ctx);
    public sealed virtual T NextToward(T thisValue, T otherValue, EContext ctx);
    public sealed virtual T NextPlus(T thisValue, EContext ctx);
    public sealed virtual T DivideToExponent(T thisValue, T divisor, EInteger desiredExponent, EContext ctx);
    public sealed virtual T Divide(T thisValue, T divisor, EContext ctx);
    public sealed virtual T MinMagnitude(T a, T b, EContext ctx);
    public sealed virtual T MaxMagnitude(T a, T b, EContext ctx);
    public sealed virtual T Max(T a, T b, EContext ctx);
    public sealed virtual T Min(T a, T b, EContext ctx);
    public sealed virtual T Multiply(T thisValue, T other, EContext ctx);
    public sealed virtual T MultiplyAndAdd(T thisValue, T multiplicand, T augend, EContext ctx);
    public sealed virtual T Plus(T thisValue, EContext ctx);
    public sealed virtual T RoundToPrecision(T thisValue, EContext ctx);
    public sealed virtual T Quantize(T thisValue, T otherValue, EContext ctx);
    public sealed virtual T RoundToExponentExact(T thisValue, EInteger expOther, EContext ctx);
    public sealed virtual T RoundToExponentSimple(T thisValue, EInteger expOther, EContext ctx);
    public sealed virtual T RoundToExponentNoRoundedFlag(T thisValue, EInteger exponent, EContext ctx);
    public sealed virtual T Reduce(T thisValue, EContext ctx);
    public sealed virtual T Add(T thisValue, T other, EContext ctx);
    public sealed virtual T AddEx(T thisValue, T other, EContext ctx, bool roundToOperandPrecision);
    public sealed virtual T CompareToWithContext(T thisValue, T otherValue, bool treatQuietNansAsSignaling, EContext ctx);
    public sealed virtual int CompareTo(T thisValue, T otherValue);
    public sealed virtual T SignalOverflow(EContext ctx, bool neg);
    public sealed virtual T RoundAfterConversion(T thisValue, EContext ctx);
}
internal class PeterO.Numbers.TrappableRadixMath`1 : object {
    private IRadixMath`1<T> math;
    public TrappableRadixMath`1(IRadixMath`1<T> math);
    public sealed virtual T DivideToIntegerNaturalScale(T thisValue, T divisor, EContext ctx);
    public sealed virtual T DivideToIntegerZeroScale(T thisValue, T divisor, EContext ctx);
    public sealed virtual T Abs(T value, EContext ctx);
    public sealed virtual T Negate(T value, EContext ctx);
    public sealed virtual T Remainder(T thisValue, T divisor, EContext ctx, bool roundAfterDivide);
    public sealed virtual IRadixMathHelper`1<T> GetHelper();
    public sealed virtual T RemainderNear(T thisValue, T divisor, EContext ctx);
    public sealed virtual T Pi(EContext ctx);
    public sealed virtual T Power(T thisValue, T pow, EContext ctx);
    public sealed virtual T Ln(T thisValue, EContext ctx);
    public sealed virtual T Exp(T thisValue, EContext ctx);
    public sealed virtual T SquareRoot(T thisValue, EContext ctx);
    public sealed virtual T NextMinus(T thisValue, EContext ctx);
    public sealed virtual T NextToward(T thisValue, T otherValue, EContext ctx);
    public sealed virtual T NextPlus(T thisValue, EContext ctx);
    public sealed virtual T DivideToExponent(T thisValue, T divisor, EInteger desiredExponent, EContext ctx);
    public sealed virtual T Divide(T thisValue, T divisor, EContext ctx);
    public sealed virtual T MinMagnitude(T a, T b, EContext ctx);
    public sealed virtual T MaxMagnitude(T a, T b, EContext ctx);
    public sealed virtual T Max(T a, T b, EContext ctx);
    public sealed virtual T Min(T a, T b, EContext ctx);
    public sealed virtual T Multiply(T thisValue, T other, EContext ctx);
    public sealed virtual T MultiplyAndAdd(T thisValue, T multiplicand, T augend, EContext ctx);
    public sealed virtual T Plus(T thisValue, EContext ctx);
    public sealed virtual T RoundToPrecision(T thisValue, EContext ctx);
    public sealed virtual T Quantize(T thisValue, T otherValue, EContext ctx);
    public sealed virtual T RoundToExponentExact(T thisValue, EInteger expOther, EContext ctx);
    public sealed virtual T RoundToExponentSimple(T thisValue, EInteger expOther, EContext ctx);
    public sealed virtual T RoundToExponentNoRoundedFlag(T thisValue, EInteger exponent, EContext ctx);
    public sealed virtual T Reduce(T thisValue, EContext ctx);
    public sealed virtual T Add(T thisValue, T other, EContext ctx);
    public sealed virtual T CompareToWithContext(T thisValue, T otherValue, bool treatQuietNansAsSignaling, EContext ctx);
    public sealed virtual int CompareTo(T thisValue, T otherValue);
    public sealed virtual T RoundAfterConversion(T thisValue, EContext ctx);
    public sealed virtual T SignalOverflow(EContext ctx, bool neg);
    public sealed virtual T AddEx(T thisValue, T other, EContext ctx, bool roundToOperandPrecision);
}
