[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal static class PeterO.Cbor.Base64 : object {
    private static string Base64URL;
    private static string Base64Classic;
    public static void WriteBase64(StringOutput writer, Byte[] data, int offset, int count, bool padding);
    public static void WriteBase64URL(StringOutput writer, Byte[] data, int offset, int count, bool padding);
    private static void WriteBase64(StringOutput writer, Byte[] data, int offset, int count, bool classic, bool padding);
}
internal static class PeterO.Cbor.CBORCanonical : object {
    internal static IComparer`1<CBORObject> Comparer;
    private static IComparer`1<KeyValuePair`2<Byte[], Byte[]>> ByteComparer;
    private static CBORCanonical();
    private static bool IsArrayOrMap(CBORObject a);
    public static Byte[] CtapCanonicalEncode(CBORObject a);
    private static bool ByteArraysEqual(Byte[] bytesA, Byte[] bytesB);
    private static void CheckDepth(CBORObject cbor, int depth);
    private static Byte[] CtapCanonicalEncode(CBORObject a, int depth);
}
public static class PeterO.Cbor.CBORDataUtilities : object {
    private static string HexAlphabet;
    private static long DoubleNegInfinity;
    private static long DoublePosInfinity;
    internal static JSONOptions DefaultOptions;
    private static JSONOptions PreserveNegZeroNo;
    private static JSONOptions PreserveNegZeroYes;
    private static CBORDataUtilities();
    internal static string ToStringHelper(CBORObject obj, int depth);
    public static CBORObject ParseJSONNumber(string str);
    public static CBORObject ParseJSONNumber(string str, JSONOptions options);
    public static CBORObject ParseJSONNumber(string str, int offset, int count);
    internal static CBORObject ParseSmallNumberAsNegative(int digit, JSONOptions options);
    internal static CBORObject ParseSmallNumber(int digit, JSONOptions options);
    public static CBORObject ParseJSONNumber(string str, int offset, int count, JSONOptions options);
    public static CBORObject ParseJSONNumber(Byte[] bytes, int offset, int count, JSONOptions options);
    public static CBORObject ParseJSONNumber(Byte[] bytes, JSONOptions options);
    public static CBORObject ParseJSONNumber(Byte[] bytes, int offset, int count);
    public static CBORObject ParseJSONNumber(Byte[] bytes);
    public static CBORObject ParseJSONNumber(Char[] chars, int offset, int count, JSONOptions options);
    public static CBORObject ParseJSONNumber(Char[] chars, JSONOptions options);
    public static CBORObject ParseJSONNumber(Char[] chars, int offset, int count);
    public static CBORObject ParseJSONNumber(Char[] chars);
}
internal static class PeterO.Cbor.CBORDataUtilitiesByteArrayString : object {
    private static long DoubleNegInfinity;
    private static long DoublePosInfinity;
    internal static CBORObject ParseJSONNumber(Byte[] chars, int offset, int count, JSONOptions options, Int32[] endOfNumber);
}
internal static class PeterO.Cbor.CBORDataUtilitiesCharArrayString : object {
    private static long DoubleNegInfinity;
    private static long DoublePosInfinity;
    internal static CBORObject ParseJSONNumber(Char[] chars, int offset, int count, JSONOptions options, Int32[] endOfNumber);
}
internal static class PeterO.Cbor.CBORDataUtilitiesTextString : object {
    private static long DoubleNegInfinity;
    private static long DoublePosInfinity;
    internal static CBORObject ParseJSONNumber(string chars, int offset, int count, JSONOptions options, Int32[] endOfNumber);
}
public class PeterO.Cbor.CBORDateConverter : object {
    public static CBORDateConverter TaggedString;
    public static CBORDateConverter TaggedNumber;
    public static CBORDateConverter UntaggedNumber;
    [CompilerGeneratedAttribute]
private ConversionType <Type>k__BackingField;
    public ConversionType Type { get; }
    public CBORDateConverter(ConversionType convType);
    private static CBORDateConverter();
    [CompilerGeneratedAttribute]
public ConversionType get_Type();
    public sealed virtual DateTime FromCBORObject(CBORObject obj);
    public bool TryGetDateTimeFields(CBORObject obj, EInteger[] year, Int32[] lesserFields);
    private string TryGetDateTimeFieldsInternal(CBORObject obj, EInteger[] year, Int32[] lesserFields);
    public CBORObject DateTimeFieldsToCBORObject(int smallYear, int month, int day);
    public CBORObject DateTimeFieldsToCBORObject(int smallYear, int month, int day, int hour, int minute, int second);
    public CBORObject DateTimeFieldsToCBORObject(int year, Int32[] lesserFields);
    public CBORObject DateTimeFieldsToCBORObject(EInteger bigYear, Int32[] lesserFields);
    public sealed virtual CBORObject ToCBORObject(DateTime obj);
    public bool TryGetDateTimeFields(CBORObject obj, EInteger& year, Int32[] lesserFields);
}
internal class PeterO.Cbor.CBORDoubleBits : object {
    public sealed virtual bool IsPositiveInfinity(object obj);
    public sealed virtual bool IsInfinity(object obj);
    public sealed virtual bool IsNegativeInfinity(object obj);
    public sealed virtual bool IsNaN(object obj);
    public sealed virtual double AsDouble(object obj);
    public sealed virtual EDecimal AsEDecimal(object obj);
    public sealed virtual EFloat AsEFloat(object obj);
    public sealed virtual float AsSingle(object obj);
    public sealed virtual EInteger AsEInteger(object obj);
    public sealed virtual long AsInt64(object obj);
    public sealed virtual bool CanFitInSingle(object obj);
    public sealed virtual bool CanFitInDouble(object obj);
    public sealed virtual bool CanFitInInt32(object obj);
    public sealed virtual bool CanFitInInt64(object obj);
    public sealed virtual bool CanFitInUInt64(object obj);
    private static long DoubleBitsRoundDown(long bits);
    public sealed virtual bool CanTruncatedIntFitInInt64(object obj);
    public sealed virtual bool CanTruncatedIntFitInUInt64(object obj);
    public sealed virtual bool CanTruncatedIntFitInInt32(object obj);
    public sealed virtual int AsInt32(object obj, int minValue, int maxValue);
    public sealed virtual bool IsNumberZero(object obj);
    public sealed virtual int Sign(object obj);
    public sealed virtual bool IsIntegral(object obj);
    public sealed virtual object Negate(object obj);
    public sealed virtual object Abs(object obj);
    public sealed virtual ERational AsERational(object obj);
    public sealed virtual bool IsNegative(object obj);
}
internal class PeterO.Cbor.CBOREInteger : object {
    public sealed virtual bool IsPositiveInfinity(object obj);
    public sealed virtual bool IsInfinity(object obj);
    public sealed virtual bool IsNegativeInfinity(object obj);
    public sealed virtual bool IsNaN(object obj);
    public sealed virtual double AsDouble(object obj);
    public sealed virtual EDecimal AsEDecimal(object obj);
    public sealed virtual EFloat AsEFloat(object obj);
    public sealed virtual float AsSingle(object obj);
    public sealed virtual EInteger AsEInteger(object obj);
    public sealed virtual long AsInt64(object obj);
    public sealed virtual bool CanFitInSingle(object obj);
    public sealed virtual bool CanFitInDouble(object obj);
    public sealed virtual bool CanFitInInt32(object obj);
    public sealed virtual bool CanFitInInt64(object obj);
    public sealed virtual bool CanFitInUInt64(object obj);
    public sealed virtual bool CanTruncatedIntFitInInt64(object obj);
    public sealed virtual bool CanTruncatedIntFitInUInt64(object obj);
    public sealed virtual bool CanTruncatedIntFitInInt32(object obj);
    public sealed virtual bool IsNumberZero(object obj);
    public sealed virtual int Sign(object obj);
    public sealed virtual bool IsIntegral(object obj);
    public sealed virtual int AsInt32(object obj, int minValue, int maxValue);
    public sealed virtual object Negate(object obj);
    public sealed virtual object Abs(object obj);
    public sealed virtual ERational AsERational(object obj);
    public sealed virtual bool IsNegative(object obj);
}
public class PeterO.Cbor.CBOREncodeOptions : object {
    public static CBOREncodeOptions Default;
    public static CBOREncodeOptions DefaultCtap2Canonical;
    [CompilerGeneratedAttribute]
private bool <ResolveReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseIndefLengthStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepKeyOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowDuplicateKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Float64>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ctap2Canonical>k__BackingField;
    public bool ResolveReferences { get; private set; }
    public bool UseIndefLengthStrings { get; private set; }
    public bool KeepKeyOrder { get; private set; }
    public bool AllowEmpty { get; private set; }
    public bool AllowDuplicateKeys { get; private set; }
    public bool Float64 { get; private set; }
    public bool Ctap2Canonical { get; private set; }
    [ObsoleteAttribute("Use the more readable string constructor instead.")]
public CBOREncodeOptions(bool useIndefLengthStrings, bool allowDuplicateKeys);
    [ObsoleteAttribute("Use the more readable string constructor instead.")]
public CBOREncodeOptions(bool useIndefLengthStrings, bool allowDuplicateKeys, bool ctap2Canonical);
    public CBOREncodeOptions(string paramString);
    private static CBOREncodeOptions();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public bool get_ResolveReferences();
    [CompilerGeneratedAttribute]
private void set_ResolveReferences(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseIndefLengthStrings();
    [CompilerGeneratedAttribute]
private void set_UseIndefLengthStrings(bool value);
    [CompilerGeneratedAttribute]
public bool get_KeepKeyOrder();
    [CompilerGeneratedAttribute]
private void set_KeepKeyOrder(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowEmpty();
    [CompilerGeneratedAttribute]
private void set_AllowEmpty(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowDuplicateKeys();
    [CompilerGeneratedAttribute]
private void set_AllowDuplicateKeys(bool value);
    [CompilerGeneratedAttribute]
public bool get_Float64();
    [CompilerGeneratedAttribute]
private void set_Float64(bool value);
    [CompilerGeneratedAttribute]
public bool get_Ctap2Canonical();
    [CompilerGeneratedAttribute]
private void set_Ctap2Canonical(bool value);
}
public class PeterO.Cbor.CBORException : Exception {
    public CBORException(string message);
    public CBORException(string message, Exception innerException);
}
internal class PeterO.Cbor.CBORExtendedDecimal : object {
    public sealed virtual bool IsPositiveInfinity(object obj);
    public sealed virtual bool IsInfinity(object obj);
    public sealed virtual bool IsNegativeInfinity(object obj);
    public sealed virtual bool IsNaN(object obj);
    public sealed virtual double AsDouble(object obj);
    public sealed virtual EDecimal AsEDecimal(object obj);
    public sealed virtual EFloat AsEFloat(object obj);
    public sealed virtual float AsSingle(object obj);
    public sealed virtual EInteger AsEInteger(object obj);
    public sealed virtual long AsInt64(object obj);
    public sealed virtual bool CanFitInSingle(object obj);
    public sealed virtual bool CanFitInDouble(object obj);
    public sealed virtual bool CanFitInInt32(object obj);
    public sealed virtual bool CanFitInInt64(object obj);
    public sealed virtual bool CanFitInUInt64(object obj);
    public sealed virtual bool CanTruncatedIntFitInInt64(object obj);
    public sealed virtual bool CanTruncatedIntFitInUInt64(object obj);
    public sealed virtual bool CanTruncatedIntFitInInt32(object obj);
    public sealed virtual bool IsNumberZero(object obj);
    public sealed virtual int Sign(object obj);
    public sealed virtual bool IsIntegral(object obj);
    public sealed virtual int AsInt32(object obj, int minValue, int maxValue);
    public sealed virtual object Negate(object obj);
    public sealed virtual object Abs(object obj);
    public sealed virtual ERational AsERational(object obj);
    public sealed virtual bool IsNegative(object obj);
}
internal class PeterO.Cbor.CBORExtendedFloat : object {
    public sealed virtual bool IsPositiveInfinity(object obj);
    public sealed virtual bool IsInfinity(object obj);
    public sealed virtual bool IsNegativeInfinity(object obj);
    public sealed virtual bool IsNaN(object obj);
    public sealed virtual double AsDouble(object obj);
    public sealed virtual EDecimal AsEDecimal(object obj);
    public sealed virtual EFloat AsEFloat(object obj);
    public sealed virtual float AsSingle(object obj);
    public sealed virtual EInteger AsEInteger(object obj);
    public sealed virtual long AsInt64(object obj);
    public sealed virtual bool CanFitInSingle(object obj);
    public sealed virtual bool CanFitInDouble(object obj);
    public sealed virtual bool CanFitInInt32(object obj);
    public sealed virtual bool CanFitInInt64(object obj);
    public sealed virtual bool CanFitInUInt64(object obj);
    public sealed virtual bool CanTruncatedIntFitInInt64(object obj);
    public sealed virtual bool CanTruncatedIntFitInUInt64(object obj);
    public sealed virtual bool CanTruncatedIntFitInInt32(object obj);
    public sealed virtual bool IsNumberZero(object obj);
    public sealed virtual int Sign(object obj);
    public sealed virtual bool IsIntegral(object obj);
    public sealed virtual int AsInt32(object obj, int minValue, int maxValue);
    public sealed virtual object Negate(object obj);
    public sealed virtual object Abs(object obj);
    public sealed virtual ERational AsERational(object obj);
    public sealed virtual bool IsNegative(object obj);
}
internal class PeterO.Cbor.CBORExtendedRational : object {
    public sealed virtual bool IsPositiveInfinity(object obj);
    public sealed virtual bool IsInfinity(object obj);
    public sealed virtual bool IsNegativeInfinity(object obj);
    public sealed virtual bool IsNaN(object obj);
    public sealed virtual double AsDouble(object obj);
    public sealed virtual EDecimal AsEDecimal(object obj);
    public sealed virtual EFloat AsEFloat(object obj);
    public sealed virtual float AsSingle(object obj);
    public sealed virtual EInteger AsEInteger(object obj);
    public sealed virtual long AsInt64(object obj);
    public sealed virtual bool CanFitInSingle(object obj);
    public sealed virtual bool CanFitInDouble(object obj);
    public sealed virtual bool CanFitInInt32(object obj);
    public sealed virtual bool CanFitInInt64(object obj);
    public sealed virtual bool CanFitInUInt64(object obj);
    public sealed virtual bool CanTruncatedIntFitInInt64(object obj);
    public sealed virtual bool CanTruncatedIntFitInInt32(object obj);
    public sealed virtual bool CanTruncatedIntFitInUInt64(object obj);
    public sealed virtual bool IsNumberZero(object obj);
    public sealed virtual int Sign(object obj);
    public sealed virtual bool IsIntegral(object obj);
    public sealed virtual int AsInt32(object obj, int minValue, int maxValue);
    public sealed virtual object Negate(object obj);
    public sealed virtual object Abs(object obj);
    public sealed virtual ERational AsERational(object obj);
    public sealed virtual bool IsNegative(object obj);
}
internal class PeterO.Cbor.CBORInteger : object {
    public sealed virtual object Abs(object obj);
    public sealed virtual EInteger AsEInteger(object obj);
    public sealed virtual double AsDouble(object obj);
    public sealed virtual EDecimal AsEDecimal(object obj);
    public sealed virtual EFloat AsEFloat(object obj);
    public sealed virtual ERational AsERational(object obj);
    public sealed virtual int AsInt32(object obj, int minValue, int maxValue);
    public sealed virtual long AsInt64(object obj);
    public sealed virtual float AsSingle(object obj);
    public sealed virtual bool CanFitInDouble(object obj);
    public sealed virtual bool CanFitInInt32(object obj);
    public sealed virtual bool CanFitInInt64(object obj);
    public sealed virtual bool CanFitInSingle(object obj);
    public sealed virtual bool CanTruncatedIntFitInInt32(object obj);
    public sealed virtual bool CanTruncatedIntFitInUInt64(object obj);
    public sealed virtual bool CanFitInUInt64(object obj);
    public sealed virtual bool CanTruncatedIntFitInInt64(object obj);
    public sealed virtual bool IsInfinity(object obj);
    public sealed virtual bool IsIntegral(object obj);
    public sealed virtual bool IsNaN(object obj);
    public sealed virtual bool IsNegative(object obj);
    public sealed virtual bool IsNegativeInfinity(object obj);
    public sealed virtual bool IsPositiveInfinity(object obj);
    public sealed virtual bool IsNumberZero(object obj);
    public sealed virtual object Negate(object obj);
    public sealed virtual int Sign(object obj);
}
internal class PeterO.Cbor.CBORJson : object {
    private JSONOptions options;
    private CharacterInputWithCount reader;
    private StringBuilder sb;
    private bool jsonSequenceMode;
    private bool recordSeparatorSeen;
    public CBORJson(CharacterInputWithCount reader, JSONOptions options);
    private int SkipWhitespaceJSON();
    private int SkipWhitespaceJSON(int lastChar);
    public void SkipToEnd();
    public int ReadChar();
    private void RaiseError(string str);
    private string NextJSONString();
    private CBORObject NextJSONNegativeNumber(Int32[] nextChar, int depth);
    private CBORObject NextJSONValue(int firstChar, Int32[] nextChar, int depth);
    public CBORObject ParseJSON(Int32[] nextChar);
    private void SetJSONSequenceMode();
    private void ResetJSONSequenceMode();
    internal static CBORObject ParseJSONValue(CharacterInputWithCount reader, JSONOptions options, Int32[] nextChar);
    internal bool SkipRecordSeparators(Int32[] nextChar, bool recordSeparatorSeen);
    internal static CBORObject[] ParseJSONSequence(CharacterInputWithCount reader, JSONOptions options, Int32[] nextChar);
    private CBORObject ParseJSONObject(int depth);
    internal CBORObject ParseJSONArray(int depth);
}
internal class PeterO.Cbor.CBORJson2 : object {
    private Byte[] bytes;
    private JSONOptions options;
    private int endPos;
    private static Byte[] ValueEmptyBytes;
    private int index;
    public CBORJson2(Byte[] bytes, int index, int endPos, JSONOptions options);
    private static CBORJson2();
    private int SkipWhitespaceJSON();
    internal void RaiseError(string str);
    private Byte[] NextJSONString();
    private CBORObject NextJSONNegativeNumber(Int32[] nextChar);
    private CBORObject NextJSONNonnegativeNumber(int c, Int32[] nextChar);
    private CBORObject NextJSONValue(int firstChar, Int32[] nextChar, int depth);
    public CBORObject ParseJSON(Int32[] nextchar);
    internal static CBORObject ParseJSONValue(Byte[] bytes, int index, int endPos, JSONOptions options);
    internal static CBORObject ParseJSONValue(Byte[] bytes, int index, int endPos, JSONOptions options, Int32[] nextchar);
    private CBORObject ParseJSONObject(int depth);
    internal CBORObject ParseJSONArray(int depth);
}
internal class PeterO.Cbor.CBORJson3 : object {
    private string jstring;
    private JSONOptions options;
    private int endPos;
    private StringBuilder sb;
    private int index;
    public CBORJson3(string jstring, int index, int endPos, JSONOptions options);
    private int SkipWhitespaceJSON();
    internal void RaiseError(string str);
    private string NextJSONString();
    private CBORObject NextJSONNegativeNumber(Int32[] nextChar);
    private CBORObject NextJSONNonnegativeNumber(int c, Int32[] nextChar);
    private CBORObject NextJSONValue(int firstChar, Int32[] nextChar, int depth);
    public CBORObject ParseJSON(Int32[] nextchar);
    internal static CBORObject ParseJSONValue(string jstring, int index, int endPos, JSONOptions options);
    internal static CBORObject ParseJSONValue(string jstring, int index, int endPos, JSONOptions options, Int32[] nextchar);
    private CBORObject ParseJSONObject(int depth);
    internal CBORObject ParseJSONArray(int depth);
}
internal static class PeterO.Cbor.CBORJsonWriter : object {
    private static string Hex16;
    internal static void WriteJSONStringUnquoted(string str, StringOutput sb, JSONOptions options);
    internal static void WriteJSONToInternal(CBORObject obj, StringOutput writer, JSONOptions options);
    private static void PopRefIfNeeded(IList`1<CBORObject> stack, bool pop);
    private static bool CheckCircularRef(IList`1<CBORObject> stack, CBORObject parent, CBORObject child);
    internal static void WriteJSONToInternal(CBORObject obj, StringOutput writer, JSONOptions options, IList`1<CBORObject> stack);
}
public class PeterO.Cbor.CBORNumber : object {
    private static ICBORNumber[] NumberInterfaces;
    private object value;
    [CompilerGeneratedAttribute]
private NumberKind <Kind>k__BackingField;
    public int Sign { get; }
    public NumberKind Kind { get; }
    private CBORNumber(NumberKind kind, object value);
    private static CBORNumber();
    internal ICBORNumber GetNumberInterface();
    internal static ICBORNumber GetNumberInterface(CBORObject obj);
    internal object GetValue();
    internal static ICBORNumber GetNumberInterface(NumberKind kind);
    public CBORObject ToCBORObject();
    public int get_Sign();
    internal static bool IsNumber(CBORObject o);
    public static CBORNumber FromCBORObject(CBORObject o);
    private static bool IsUntaggedInteger(CBORObject o);
    private static bool IsUntaggedIntegerOrBignum(CBORObject o);
    private static EInteger IntegerOrBignum(CBORObject o);
    private static CBORNumber RationalToNumber(CBORObject o, int tagName);
    private static bool CheckRationalToNumber(CBORObject o, int tagName);
    private static bool CheckBigFracToNumber(CBORObject o, int tagName);
    private static CBORNumber BigFracToNumber(CBORObject o, int tagName);
    [CompilerGeneratedAttribute]
public NumberKind get_Kind();
    public bool CanTruncatedIntFitInInt32();
    public bool CanTruncatedIntFitInInt64();
    public bool CanTruncatedIntFitInUInt64();
    public bool CanFitInSingle();
    public bool CanFitInDouble();
    public bool IsFinite();
    public bool IsInteger();
    public bool IsNegative();
    public bool IsZero();
    public EInteger ToEInteger();
    public EInteger ToEIntegerIfExact();
    public byte ToByteChecked();
    public byte ToByteUnchecked();
    public byte ToByteIfExact();
    public static CBORNumber FromByte(byte inputByte);
    public short ToInt16Checked();
    public short ToInt16Unchecked();
    public short ToInt16IfExact();
    public static CBORNumber FromInt16(short inputInt16);
    public int ToInt32Checked();
    public int ToInt32Unchecked();
    public int ToInt32IfExact();
    public long ToInt64Checked();
    public long ToInt64Unchecked();
    public long ToInt64IfExact();
    private static CBORNumber BignumToNumber(CBORObject o);
    public virtual string ToString();
    internal string ToJSONString();
    internal static CBORNumber FromInt(int intValue);
    internal static CBORNumber FromInt64(long longValue);
    internal static CBORNumber FromDoubleBits(long doubleBits);
    internal static CBORNumber FromEInteger(EInteger eivalue);
    internal static CBORNumber FromEFloat(EFloat value);
    internal static CBORNumber FromEDecimal(EDecimal value);
    internal static CBORNumber FromERational(ERational value);
    public bool CanFitInInt32();
    public bool CanFitInInt64();
    public bool CanFitInUInt64();
    public bool IsInfinity();
    public bool IsPositiveInfinity();
    public bool IsNegativeInfinity();
    public bool IsNaN();
    public EDecimal ToEDecimal();
    public EFloat ToEFloat();
    public ERational ToERational();
    public CBORNumber Abs();
    public CBORNumber Negate();
    private static ERational CheckOverflow(ERational e1, ERational e2, ERational eresult);
    private static EDecimal CheckOverflow(EDecimal e1, EDecimal e2, EDecimal eresult);
    private static EFloat CheckOverflow(EFloat e1, EFloat e2, EFloat eresult);
    private static NumberKind GetConvertKind(CBORNumber a, CBORNumber b);
    public CBORNumber Add(CBORNumber b);
    public CBORNumber Subtract(CBORNumber b);
    public CBORNumber Multiply(CBORNumber b);
    public CBORNumber Divide(CBORNumber b);
    public CBORNumber Remainder(CBORNumber b);
    public int CompareTo(int other);
    public int CompareTo(long other);
    public sealed virtual int CompareTo(CBORNumber other);
    public static bool op_LessThan(CBORNumber a, CBORNumber b);
    public static bool op_LessThanOrEqual(CBORNumber a, CBORNumber b);
    public static bool op_GreaterThan(CBORNumber a, CBORNumber b);
    public static bool op_GreaterThanOrEqual(CBORNumber a, CBORNumber b);
    [CLSCompliantAttribute("False")]
public sbyte ToSByteChecked();
    public decimal ToDecimal();
    [CLSCompliantAttribute("False")]
public sbyte ToSByteUnchecked();
    [CLSCompliantAttribute("False")]
public sbyte ToSByteIfExact();
    [CLSCompliantAttribute("False")]
public ushort ToUInt16Checked();
    [CLSCompliantAttribute("False")]
public ushort ToUInt16Unchecked();
    [CLSCompliantAttribute("False")]
public ushort ToUInt16IfExact();
    [CLSCompliantAttribute("False")]
public UInt32 ToUInt32Checked();
    [CLSCompliantAttribute("False")]
public UInt32 ToUInt32Unchecked();
    [CLSCompliantAttribute("False")]
public UInt32 ToUInt32IfExact();
    [CLSCompliantAttribute("False")]
public ulong ToUInt64Checked();
    [CLSCompliantAttribute("False")]
public ulong ToUInt64Unchecked();
    [CLSCompliantAttribute("False")]
public ulong ToUInt64IfExact();
}
[DefaultMemberAttribute("Item")]
public class PeterO.Cbor.CBORObject : object {
    public static CBORObject False;
    public static CBORObject NaN;
    public static CBORObject NegativeInfinity;
    public static CBORObject Null;
    public static CBORObject PositiveInfinity;
    public static CBORObject True;
    public static CBORObject Undefined;
    public static CBORObject Zero;
    private static int CBORObjectTypeInteger;
    private static int CBORObjectTypeEInteger;
    private static int CBORObjectTypeByteString;
    private static int CBORObjectTypeTextString;
    private static int CBORObjectTypeArray;
    private static int CBORObjectTypeMap;
    private static int CBORObjectTypeTagged;
    private static int CBORObjectTypeSimpleValue;
    private static int CBORObjectTypeDouble;
    private static int CBORObjectTypeTextStringUtf8;
    private static int CBORObjectTypeTextStringAscii;
    private static int StreamedStringBufferLength;
    private static EInteger UInt64MaxValue;
    private static EInteger[] ValueEmptyTags;
    private static Int32[] ValueExpectedLengths;
    private static Byte[] ValueFalseBytes;
    private static Byte[] ValueNullBytes;
    private static Byte[] ValueTrueBytes;
    private static CBORObject[] FixedObjects;
    private int itemtypeValue;
    private object itemValue;
    private int tagHigh;
    private int tagLow;
    private static CBOREncodeOptions AllowEmptyOptions;
    public int Count { get; }
    public EInteger MostInnerTag { get; }
    public bool IsFalse { get; }
    public bool IsNull { get; }
    public bool IsTagged { get; }
    public bool IsTrue { get; }
    public bool IsUndefined { get; }
    public ICollection`1<CBORObject> Keys { get; }
    public EInteger MostOuterTag { get; }
    public int SimpleValue { get; }
    public bool IsNumber { get; }
    public CBORType Type { get; }
    public ICollection`1<KeyValuePair`2<CBORObject, CBORObject>> Entries { get; }
    public ICollection`1<CBORObject> Values { get; }
    private int ItemType { get; }
    private object ThisItem { get; }
    public CBORObject Item { get; public set; }
    public CBORObject Item { get; public set; }
    public CBORObject Item { get; public set; }
    public int TagCount { get; }
    internal CBORObject(CBORObject obj, int tagLow, int tagHigh);
    internal CBORObject(int type, object item);
    private static CBORObject();
    private static CBORObject ConstructSimpleValue(int v);
    private static CBORObject ConstructIntegerValue(int v);
    public int get_Count();
    public EInteger get_MostInnerTag();
    public bool get_IsFalse();
    public bool get_IsNull();
    public bool get_IsTagged();
    public bool get_IsTrue();
    public bool get_IsUndefined();
    public ICollection`1<CBORObject> get_Keys();
    public EInteger get_MostOuterTag();
    public int get_SimpleValue();
    public bool get_IsNumber();
    public CBORType get_Type();
    public ICollection`1<KeyValuePair`2<CBORObject, CBORObject>> get_Entries();
    public ICollection`1<CBORObject> get_Values();
    private int get_ItemType();
    private object get_ThisItem();
    public CBORObject get_Item(int index);
    public void set_Item(int index, CBORObject value);
    public CBORObject GetOrDefault(CBORObject cborkey, CBORObject defaultValue);
    public CBORObject GetOrDefault(int key, CBORObject defaultValue);
    public CBORObject GetOrDefault(string key, CBORObject defaultValue);
    public CBORObject get_Item(CBORObject key);
    public void set_Item(CBORObject key, CBORObject value);
    public CBORObject get_Item(string key);
    public void set_Item(string key, CBORObject value);
    public static CBORObject DecodeFromBytes(Byte[] data);
    public static CBORObject[] DecodeSequenceFromBytes(Byte[] data);
    public static CBORObject[] DecodeSequenceFromBytes(Byte[] data, CBOREncodeOptions options);
    public static CBORObject[] FromJSONSequenceBytes(Byte[] bytes);
    public Byte[] ToJSONBytes();
    public Byte[] ToJSONBytes(JSONOptions jsonoptions);
    public static CBORObject[] FromJSONSequenceBytes(Byte[] data, JSONOptions options);
    public static CBORObject DecodeFromBytes(Byte[] data, CBOREncodeOptions options);
    public static CBORObject FromJSONString(string str, int offset, int count);
    public static CBORObject FromJSONString(string str, JSONOptions jsonoptions);
    public static CBORObject FromJSONString(string str);
    public static CBORObject FromJSONString(string str, int offset, int count, JSONOptions jsonoptions);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public object ToObject(Type t);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public object ToObject(Type t, CBORTypeMapper mapper);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public object ToObject(Type t, PODOptions options);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public object ToObject(Type t, CBORTypeMapper mapper, PODOptions options);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public static object DecodeObjectFromBytes(Byte[] data, CBOREncodeOptions enc, Type t, CBORTypeMapper mapper, PODOptions pod);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public static object DecodeObjectFromBytes(Byte[] data, CBOREncodeOptions enc, Type t);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public static object DecodeObjectFromBytes(Byte[] data, Type t, CBORTypeMapper mapper, PODOptions pod);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public static object DecodeObjectFromBytes(Byte[] data, Type t);
    internal EDecimal ToEDecimal();
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
internal object ToObject(Type t, CBORTypeMapper mapper, PODOptions options, int depth);
    public static CBORObject FromInt64(long value);
    [ObsoleteAttribute("Use FromInt64 instead.")]
public static CBORObject FromObject(long value);
    [ObsoleteAttribute("Don't use a function and use Nullable Reference Types to guard against nulls.")]
public static CBORObject FromObject(CBORObject value);
    private static int IntegerByteLength(int intValue);
    private static int IntegerByteLength(long longValue);
    public long CalcEncodedSize();
    private long CalcEncodedSize(int depth);
    public static CBORObject FromEInteger(EInteger bigintValue);
    [ObsoleteAttribute("Use FromEInteger instead.")]
public static CBORObject FromObject(EInteger bigintValue);
    public static CBORObject FromEFloat(EFloat bigValue);
    [ObsoleteAttribute("Use FromEFloat instead.")]
public static CBORObject FromObject(EFloat bigValue);
    public static CBORObject FromERational(ERational bigValue);
    [ObsoleteAttribute("Use FromERational instead.")]
public static CBORObject FromObject(ERational bigValue);
    public static CBORObject FromEDecimal(EDecimal bigValue);
    [ObsoleteAttribute("Use FromEDecimal instead.")]
public static CBORObject FromObject(EDecimal bigValue);
    public static CBORObject FromString(string strValue);
    [ObsoleteAttribute("Use FromString instead.")]
public static CBORObject FromObject(string strValue);
    public static CBORObject FromInt32(int value);
    public static CBORObject FromGuid(Guid value);
    [ObsoleteAttribute("Use FromInt instead.")]
public static CBORObject FromObject(int value);
    public static CBORObject FromInt16(short value);
    [ObsoleteAttribute("Use FromInt16 instead.")]
public static CBORObject FromObject(short value);
    public static CBORObject FromBool(bool value);
    [ObsoleteAttribute("Use FromBool instead.")]
public static CBORObject FromObject(bool value);
    public static CBORObject FromByte(byte value);
    [ObsoleteAttribute("Use FromByte instead.")]
public static CBORObject FromObject(byte value);
    public static CBORObject FromSingle(float value);
    [ObsoleteAttribute("Use FromFloat instead.")]
public static CBORObject FromObject(float value);
    public static CBORObject FromDouble(double value);
    [ObsoleteAttribute("Use FromDouble instead.")]
public static CBORObject FromObject(double value);
    public static CBORObject FromByteArray(Byte[] bytes);
    [ObsoleteAttribute("Use FromByteArray instead.")]
public static CBORObject FromObject(Byte[] bytes);
    public static CBORObject FromCBORArray(CBORObject[] array);
    [ObsoleteAttribute("Use FromCBORArray instead.")]
public static CBORObject FromObject(CBORObject[] array);
    internal static CBORObject FromArrayBackedObject(CBORObject[] array);
    public static CBORObject FromObject(Int32[] array);
    public static CBORObject FromObject(Int64[] array);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public static CBORObject FromObject(object obj);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public static CBORObject FromObject(object obj, PODOptions options);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public static CBORObject FromObject(object obj, CBORTypeMapper mapper);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public static CBORObject FromObject(object obj, CBORTypeMapper mapper, PODOptions options);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
internal static CBORObject FromObject(object obj, PODOptions options, CBORTypeMapper mapper, int depth);
    public CBORObject WithTag(EInteger bigintTag);
    public static CBORObject FromCBORObjectAndTag(CBORObject cborObj, EInteger bigintTag);
    [ObsoleteAttribute("Use FromCBORObjectAndTag instead.")]
[RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public static CBORObject FromObjectAndTag(object valueObValue, EInteger bigintTag);
    public CBORObject WithTag(int smallTag);
    public static CBORObject FromCBORObjectAndTag(CBORObject cborObj, int smallTag);
    [ObsoleteAttribute("Use FromCBORObjectAndTag instead.")]
[RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public static CBORObject FromObjectAndTag(object valueObValue, int smallTag);
    public static CBORObject FromSimpleValue(int simpleValue);
    public static CBORObject NewArray();
    internal static CBORObject NewArray(CBORObject o1, CBORObject o2);
    internal static CBORObject NewArray(CBORObject o1, CBORObject o2, CBORObject o3);
    public static CBORObject NewMap();
    public static CBORObject FromMap(IEnumerable`1<Tuple`2<CBORObject, CBORObject>> keysAndValues);
    public static CBORObject NewOrderedMap();
    public static CBORObject FromOrderedMap(IEnumerable`1<Tuple`2<CBORObject, CBORObject>> keysAndValues);
    public static CBORObject[] ReadSequence(Stream stream);
    public static CBORObject[] ReadSequence(Stream stream, CBOREncodeOptions options);
    public static CBORObject Read(Stream stream);
    public static CBORObject Read(Stream stream, CBOREncodeOptions options);
    public static CBORObject ReadJSON(Stream stream);
    public static CBORObject[] ReadJSONSequence(Stream stream);
    public static CBORObject[] ReadJSONSequence(Stream stream, JSONOptions jsonoptions);
    public static CBORObject ReadJSON(Stream stream, JSONOptions jsonoptions);
    public static CBORObject FromJSONBytes(Byte[] bytes);
    public static CBORObject FromJSONBytes(Byte[] bytes, JSONOptions jsonoptions);
    public static CBORObject FromJSONBytes(Byte[] bytes, int offset, int count);
    public static CBORObject FromJSONBytes(Byte[] bytes, int offset, int count, JSONOptions jsonoptions);
    public static void Write(string str, Stream stream);
    public static void Write(string str, Stream stream, CBOREncodeOptions options);
    public static void Write(EFloat bignum, Stream stream);
    public static void Write(ERational rational, Stream stream);
    public static void Write(EDecimal bignum, Stream stream);
    private static Byte[] EIntegerBytes(EInteger ei);
    public static void Write(EInteger bigint, Stream stream);
    public static void Write(long value, Stream stream);
    public static void Write(int value, Stream stream);
    public static void Write(short value, Stream stream);
    public static void Write(bool value, Stream stream);
    public static void Write(byte value, Stream stream);
    public static void Write(float value, Stream stream);
    public static void Write(double value, Stream stream);
    public static void Write(CBORObject value, Stream stream);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public static void Write(object objValue, Stream stream);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public static void Write(object objValue, Stream output, CBOREncodeOptions options);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public static void WriteJSON(object obj, Stream outputStream);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public CBORObject Add(object key, object valueOb);
    public CBORObject Add(CBORObject obj);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public CBORObject Add(object obj);
    public bool AsBoolean();
    public double AsDouble();
    public int AsInt32Value();
    public long AsInt64Value();
    public bool CanValueFitInInt64();
    public bool CanValueFitInInt32();
    public EInteger AsEIntegerValue();
    public long AsDoubleBits();
    public double AsDoubleValue();
    public CBORNumber AsNumber();
    public int AsInt32();
    public float AsSingle();
    public Guid AsGuid();
    public string AsString();
    private static string Chop(string str);
    public sealed virtual int CompareTo(CBORObject other);
    public int CompareToIgnoreTags(CBORObject other);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public bool ContainsKey(object objKey);
    public bool ContainsKey(CBORObject key);
    public bool ContainsKey(string key);
    private static Byte[] GetDoubleBytes64(long valueBits, int tagbyte);
    private static Byte[] GetDoubleBytes(long valueBits, int tagbyte);
    public Byte[] EncodeToBytes();
    public Byte[] EncodeToBytes(CBOREncodeOptions options);
    public CBORObject AtJSONPointer(string pointer);
    public CBORObject AtJSONPointer(string pointer, CBORObject defaultValue);
    public CBORObject ApplyJSONPatch(CBORObject patch);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CBORObject other);
    public Byte[] GetByteString();
    public virtual int GetHashCode();
    public EInteger[] GetAllTags();
    public bool HasOneTag();
    public bool HasOneTag(int tagValue);
    public bool HasOneTag(EInteger bigTagValue);
    public int get_TagCount();
    public bool HasMostInnerTag(int tagValue);
    public bool HasMostInnerTag(EInteger bigTagValue);
    public bool HasMostOuterTag(int tagValue);
    public bool HasMostOuterTag(EInteger bigTagValue);
    public bool HasTag(int tagValue);
    public bool HasTag(EInteger bigTagValue);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
[ObsoleteAttribute("Use the CBORObject overload instead.")]
public CBORObject Insert(int index, object valueOb);
    public CBORObject Insert(int index, CBORObject cborObj);
    public void Clear();
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public bool Remove(object obj);
    public bool RemoveAt(int index);
    public bool Remove(CBORObject obj);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
[ObsoleteAttribute("Use the CBORObject overload instead.")]
public CBORObject Set(object key, object valueOb);
    public CBORObject Set(CBORObject mapKey, CBORObject mapValue);
    public CBORObject Set(int key, CBORObject mapValue);
    public string ToJSONString();
    public string ToJSONString(JSONOptions options);
    public virtual string ToString();
    public CBORObject Untag();
    public CBORObject UntagOne();
    public void WriteJSONTo(Stream outputStream);
    public void WriteJSONTo(Stream outputStream, JSONOptions options);
    public static CBORObject FromFloatingPointBits(long floatingBits, int byteCount);
    public static int WriteFloatingPointBits(Stream outputStream, long floatingBits, int byteCount);
    public static int WriteFloatingPointBits(Stream outputStream, long floatingBits, int byteCount, bool shortestForm);
    public static int WriteFloatingPointValue(Stream outputStream, double doubleVal, int byteCount);
    public static int WriteFloatingPointValue(Stream outputStream, float singleVal, int byteCount);
    public static int WriteValue(Stream outputStream, int majorType, long value);
    public static int WriteValue(Stream outputStream, int majorType, int value);
    public static int WriteValue(Stream outputStream, int majorType, EInteger bigintValue);
    public void WriteTo(Stream stream);
    public void WriteTo(Stream stream, CBOREncodeOptions options);
    internal static CBORObject FromRaw(Byte[] bytes);
    internal static CBORObject FromRawUtf8(Byte[] bytes);
    internal static CBORObject FromRaw(string str);
    internal static CBORObject FromRaw(IList`1<CBORObject> list);
    internal static CBORObject FromRaw(IDictionary`2<CBORObject, CBORObject> map);
    internal static int GetExpectedLength(int value);
    internal static CBORObject GetFixedLengthObject(int firstbyte, Byte[] data);
    internal static CBORObject GetFixedObject(int value);
    private IList`1<CBORObject> AsList();
    private IDictionary`2<CBORObject, CBORObject> AsMap();
    private static bool CBORArrayEquals(IList`1<CBORObject> listA, IList`1<CBORObject> listB);
    private static int CBORArrayHashCode(IList`1<CBORObject> list);
    private static bool StringEquals(string str, string str2);
    private static bool CBORMapEquals(IDictionary`2<CBORObject, CBORObject> mapA, IDictionary`2<CBORObject, CBORObject> mapB);
    private static int CBORMapHashCode(IDictionary`2<CBORObject, CBORObject> a);
    private static void CheckCBORLength(long expectedLength, long actualLength);
    private static void CheckCBORLength(int expectedLength, int actualLength);
    private static string ExtendedToString(EFloat ef);
    private static Byte[] GetOptimizedBytesIfShortAscii(string str, int tagbyteInt);
    private static string GetOptimizedStringIfShortAscii(Byte[] data, int offset);
    private static Byte[] SerializeUtf8(Byte[] utf8);
    private static Byte[] GetPositiveInt64Bytes(int type, long value);
    private static Byte[] GetPositiveIntBytes(int type, int value);
    private static CBORObject[] InitializeFixedObjects();
    private static int ListCompare(IList`1<CBORObject> listA, IList`1<CBORObject> listB);
    private static EInteger LowHighToEInteger(int tagLow, int tagHigh);
    private static int MapCompare(IDictionary`2<CBORObject, CBORObject> mapA, IDictionary`2<CBORObject, CBORObject> mapB);
    private static IList`1<object> PushObject(IList`1<object> stack, object parent, object child);
    private static int TagsCompare(EInteger[] tagsA, EInteger[] tagsB);
    private static IList`1<object> WriteChildObject(object parentThisItem, CBORObject child, Stream outputStream, IList`1<object> stack, CBOREncodeOptions options);
    private static void WriteObjectArray(IList`1<CBORObject> list, Stream outputStream, CBOREncodeOptions options);
    private static void WriteObjectArray(IList`1<CBORObject> list, Stream outputStream, IList`1<object> stack, CBOREncodeOptions options);
    private static void WriteObjectMap(IDictionary`2<CBORObject, CBORObject> map, Stream outputStream, CBOREncodeOptions options);
    private static void WriteObjectMap(IDictionary`2<CBORObject, CBORObject> map, Stream outputStream, IList`1<object> stack, CBOREncodeOptions options);
    private static int WritePositiveInt(int type, int value, Stream s);
    private static int WritePositiveInt64(int type, long value, Stream s);
    private static void WriteStreamedString(string str, Stream stream);
    private int AsInt32(int minValue, int maxValue);
    private void WriteTags(Stream s);
    public static bool op_LessThan(CBORObject a, CBORObject b);
    public static bool op_LessThanOrEqual(CBORObject a, CBORObject b);
    public static bool op_GreaterThan(CBORObject a, CBORObject b);
    public static bool op_GreaterThanOrEqual(CBORObject a, CBORObject b);
    [CLSCompliantAttribute("False")]
public static int WriteValue(Stream outputStream, int majorType, UInt32 value);
    [CLSCompliantAttribute("False")]
public static int WriteValue(Stream outputStream, int majorType, ulong value);
    private static EInteger DecimalToEInteger(decimal dec);
    [CLSCompliantAttribute("False")]
public static void Write(sbyte value, Stream stream);
    [CLSCompliantAttribute("False")]
public static void Write(ulong value, Stream stream);
    public static CBORObject FromDecimal(decimal value);
    [ObsoleteAttribute("Use FromDecimal instead")]
public static CBORObject FromObject(decimal value);
    [CLSCompliantAttribute("False")]
public static void Write(UInt32 value, Stream stream);
    [CLSCompliantAttribute("False")]
public static void Write(ushort value, Stream stream);
    [CLSCompliantAttribute("False")]
public static CBORObject FromSbyte(sbyte value);
    [ObsoleteAttribute("Use FromSbyte instead")]
[CLSCompliantAttribute("False")]
public static CBORObject FromObject(sbyte value);
    private static EInteger UInt64ToEInteger(ulong value);
    [CLSCompliantAttribute("False")]
public static CBORObject FromUInt64(ulong value);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("Use FromUInt64 instead")]
public static CBORObject FromObject(ulong value);
    [CLSCompliantAttribute("False")]
public static CBORObject FromUInt(UInt32 value);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("Use FromUInt instead")]
public static CBORObject FromObject(UInt32 value);
    [CLSCompliantAttribute("False")]
public static CBORObject FromUShort(ushort value);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("Use FromUShort instead")]
public static CBORObject FromObject(ushort value);
    [CLSCompliantAttribute("False")]
public CBORObject WithTag(ulong tag);
    [CLSCompliantAttribute("False")]
[RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public static CBORObject FromCBORObjectAndTag(CBORObject o, ulong tag);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public T ToObject();
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public T ToObject(CBORTypeMapper mapper);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public T ToObject(PODOptions options);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public T ToObject(CBORTypeMapper mapper, PODOptions options);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public static T DecodeObjectFromBytes(Byte[] data, CBOREncodeOptions enc, CBORTypeMapper mapper, PODOptions pod);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public static T DecodeObjectFromBytes(Byte[] data, CBOREncodeOptions enc);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public static T DecodeObjectFromBytes(Byte[] data, CBORTypeMapper mapper, PODOptions pod);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public static T DecodeObjectFromBytes(Byte[] data);
}
internal class PeterO.Cbor.CBORReader : object {
    private Stream stream;
    private CBOREncodeOptions options;
    private int depth;
    private StringRefs stringRefs;
    private bool hasSharableObjects;
    private static Byte[] EmptyByteArray;
    public CBORReader(Stream inStream);
    public CBORReader(Stream inStream, CBOREncodeOptions options);
    private static CBORReader();
    private static EInteger ToUnsignedEInteger(long val);
    private void HandleItemTag(long uadditional);
    private CBORObject ObjectFromByteArray(Byte[] data, int lengthHint);
    private CBORObject ObjectFromUtf8Array(Byte[] data, int lengthHint);
    private static CBORObject ResolveSharedRefs(CBORObject obj, SharedRefs sharedRefs);
    public CBORObject Read();
    private CBORObject ReadInternalOrEOF();
    private CBORObject ReadInternal();
    private CBORObject ReadStringArrayMap(int type, long uadditional);
    private static void ReadHelper(Stream stream, Byte[] bytes, int offset, int count);
    public CBORObject ReadForFirstByte(int firstbyte);
    private static Byte[] ReadByteData(Stream stream, long uadditional, Stream outputStream);
    private static long ReadDataLength(Stream stream, int headByte, int expectedType);
    private static long ReadDataLength(Stream stream, int headByte, int expectedType, bool allowNonShortest);
}
public enum PeterO.Cbor.CBORType : Enum {
    public int value__;
    [ObsoleteAttribute("Since version 4.0, CBORObject.Type no longer returns this value for any CBOR object - this is a breaking change from earlier versions. Instead, use the IsNumber property of CBORObject to determine whether a CBOR object represents a number, or use the two new CBORType values instead. CBORType.Integer covers CBOR objects representing integers of major type 0 and 1. CBORType.FloatingPoint covers CBOR objects representing 16-, 32-, and 64-bit floating-point numbers. CBORType.Number may be removed in version 5.0 or later.")]
public static CBORType Number;
    public static CBORType Boolean;
    public static CBORType SimpleValue;
    public static CBORType ByteString;
    public static CBORType TextString;
    public static CBORType Array;
    public static CBORType Map;
    public static CBORType Integer;
    public static CBORType FloatingPoint;
}
public class PeterO.Cbor.CBORTypeMapper : object {
    private IList`1<string> typePrefixes;
    private IList`1<string> typeNames;
    private IDictionary`2<object, ConverterInfo> converters;
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public CBORTypeMapper AddConverter(Type type, ICBORConverter`1<T> converter);
    internal object ConvertBackWithConverter(CBORObject cbor, Type type);
    internal CBORObject ConvertWithConverter(object obj);
    public bool FilterTypeName(string typeName);
    public CBORTypeMapper AddTypePrefix(string prefix);
    public CBORTypeMapper AddTypeName(string name);
}
internal class PeterO.Cbor.CBORUriConverter : object {
    private static CBORObject ValidateObject(CBORObject obj);
    public sealed virtual Uri FromCBORObject(CBORObject obj);
    public sealed virtual CBORObject ToCBORObject(Uri uri);
}
internal static class PeterO.Cbor.CBORUtilities : object {
    private static long DoublePosInfinity;
    private static string HexAlphabet;
    public static int FractionalSeconds;
    private static EInteger EInteger1970;
    private static EInteger EInteger86400;
    private static Int32[] ValueNormalDays;
    private static Int32[] ValueLeapDays;
    private static Int32[] ValueNormalToMonth;
    private static Int32[] ValueLeapToMonth;
    private static CBORUtilities();
    public static int CompareStringsAsUtf8LengthFirst(string strA, string strB);
    public static int CompareUtf16Utf8LengthFirst(string utf16, Byte[] utf8);
    public static int Utf8CodePointAt(Byte[] utf8, int offset);
    public static int StringHashCode(string str);
    public static int Utf8HashCode(Byte[] utf8);
    public static bool CheckUtf16(string str);
    public static bool CheckUtf8(Byte[] utf8);
    public static bool StringEqualsUtf8(string str, Byte[] utf8);
    public static bool ByteArrayEquals(Byte[] a, Byte[] b);
    public static int ByteArrayHashCode(Byte[] a);
    public static int ByteArrayCompare(Byte[] a, Byte[] b);
    public static int ByteArrayCompareLengthFirst(Byte[] a, Byte[] b);
    public static string TrimDotZero(string str);
    public static long DoubleToInt64Bits(double dbl);
    public static int SingleToInt32Bits(float flt);
    public static double Int64BitsToDouble(long bits);
    public static float Int32BitsToSingle(int bits);
    [ObsoleteAttribute]
public static string DoubleToString(double dbl);
    public static string DoubleBitsToString(long dblbits);
    [ObsoleteAttribute]
public static string SingleToString(float sing);
    public static string LongToString(long longValue);
    private static EInteger FloorDiv(EInteger a, EInteger n);
    private static long FloorDiv(long longA, int longN);
    private static EInteger FloorMod(EInteger a, EInteger n);
    private static long FloorModLong(long longA, int longN);
    public static void GetNormalizedPartProlepticGregorian(EInteger year, int month, EInteger day, EInteger[] outYear, Int32[] outMonthDay);
    public static EInteger GetNumberOfDaysProlepticGregorian(EInteger year, int month, int mday);
    public static void BreakDownSecondsSinceEpoch(long seconds, EInteger[] year, Int32[] lesserFields);
    public static void BreakDownSecondsSinceEpoch(EDecimal edec, EInteger[] year, Int32[] lesserFields);
    public static bool NameStartsWithWord(string name, string word);
    public static string FirstCharLower(string name);
    public static string FirstCharUpper(string name);
    private static bool IsValidDateTime(Int32[] dateTime);
    private static bool IsLeapYear(int yr);
    public static void ParseAtomDateTimeString(string str, EInteger[] bigYearArray, Int32[] lf);
    private static Int32[] ParseAtomDateTimeString(string str);
    public static EFloat DateTimeToIntegerOrDouble(EInteger bigYear, Int32[] lesserFields, Int32[] status);
    public static void CheckYearAndLesserFields(int smallYear, Int32[] lesserFields);
    public static void CheckYearAndLesserFields(EInteger bigYear, Int32[] lesserFields);
    public static void CheckLesserFields(Int32[] lesserFields);
    public static string ToAtomDateTimeString(EInteger bigYear, Int32[] lesserFields);
    public static long IntegerToDoubleBits(int i);
    public static bool IsBeyondSafeRange(long bits);
    public static bool IsIntegerValue(long bits);
    public static long GetIntegerValue(long bits);
    [ObsoleteAttribute]
public static EInteger EIntegerFromDouble(double dbl);
    public static EInteger EIntegerFromDoubleBits(long lvalue);
    public static bool DoubleBitsNaN(long bits);
    public static bool DoubleBitsFinite(long bits);
    private static int RoundedShift(long mant, int shift);
    private static int RoundedShift(int mant, int shift);
    public static int DoubleToHalfPrecisionIfSameValue(long bits);
    public static bool DoubleRetainsSameValueInSingle(long bits);
    public static int SingleToRoundedHalfPrecision(int bits);
    public static int DoubleToRoundedHalfPrecision(long bits);
    public static int DoubleToRoundedSinglePrecision(long bits);
    public static int SingleToHalfPrecisionIfSameValue(int bits);
    public static long SingleToDoublePrecision(int bits);
    public static long HalfToDoublePrecision(int bits);
}
internal class PeterO.Cbor.CBORUuidConverter : object {
    private static CBORObject ValidateObject(CBORObject obj);
    public sealed virtual CBORObject ToCBORObject(Guid obj);
    public sealed virtual Guid FromCBORObject(CBORObject obj);
}
internal class PeterO.Cbor.CharacterInputWithCount : object {
    private ICharacterInput ci;
    private int offset;
    public CharacterInputWithCount(ICharacterInput ci);
    public int GetOffset();
    public void RaiseError(string str);
    public void RaiseError(Exception ex);
    public sealed virtual int Read(Int32[] chars, int index, int length);
    public sealed virtual int ReadChar();
    private string NewErrorString(string str);
}
internal class PeterO.Cbor.CharacterReader : object {
    private int mode;
    private bool errorThrow;
    private bool dontSkipUtf8Bom;
    private string str;
    private int strLength;
    private IByteReader stream;
    private int offset;
    private ICharacterInput reader;
    public CharacterReader(string str);
    public CharacterReader(string str, bool skipByteOrderMark);
    public CharacterReader(string str, bool skipByteOrderMark, bool errorThrow);
    public CharacterReader(string str, int offset, int length);
    public CharacterReader(string str, int offset, int length, bool skipByteOrderMark, bool errorThrow);
    public CharacterReader(Stream stream);
    public CharacterReader(Stream stream, int mode, bool errorThrow);
    public CharacterReader(Stream stream, int mode);
    public CharacterReader(Stream stream, int mode, bool errorThrow, bool dontSkipUtf8Bom);
    public sealed virtual int Read(Int32[] chars, int index, int length);
    public sealed virtual int ReadChar();
    private int DetectUtf8Or16Or32(int c1);
    private int DetectUtf8OrUtf16(int c1);
    private int DetectUnicodeEncoding();
}
public interface PeterO.Cbor.ICBORConverter`1 {
    public abstract virtual CBORObject ToCBORObject(T obj);
}
internal interface PeterO.Cbor.ICBORNumber {
    public abstract virtual bool IsPositiveInfinity(object obj);
    public abstract virtual bool IsInfinity(object obj);
    public abstract virtual bool IsNegativeInfinity(object obj);
    public abstract virtual bool IsNaN(object obj);
    public abstract virtual bool IsNegative(object obj);
    public abstract virtual double AsDouble(object obj);
    public abstract virtual object Negate(object obj);
    public abstract virtual object Abs(object obj);
    public abstract virtual EDecimal AsEDecimal(object obj);
    public abstract virtual EFloat AsEFloat(object obj);
    public abstract virtual ERational AsERational(object obj);
    public abstract virtual float AsSingle(object obj);
    public abstract virtual EInteger AsEInteger(object obj);
    public abstract virtual long AsInt64(object obj);
    public abstract virtual bool CanFitInSingle(object obj);
    public abstract virtual bool CanFitInDouble(object obj);
    public abstract virtual bool CanFitInInt32(object obj);
    public abstract virtual bool CanFitInInt64(object obj);
    public abstract virtual bool CanFitInUInt64(object obj);
    public abstract virtual bool CanTruncatedIntFitInInt64(object obj);
    public abstract virtual bool CanTruncatedIntFitInUInt64(object obj);
    public abstract virtual bool CanTruncatedIntFitInInt32(object obj);
    public abstract virtual int AsInt32(object obj, int minValue, int maxValue);
    public abstract virtual bool IsNumberZero(object obj);
    public abstract virtual int Sign(object obj);
    public abstract virtual bool IsIntegral(object obj);
}
public interface PeterO.Cbor.ICBORToFromConverter`1 {
    public abstract virtual T FromCBORObject(CBORObject obj);
}
internal interface PeterO.Cbor.ICharacterInput {
    public abstract virtual int ReadChar();
    public abstract virtual int Read(Int32[] chars, int index, int length);
}
public class PeterO.Cbor.JSONOptions : object {
    public static JSONOptions Default;
    [CompilerGeneratedAttribute]
private bool <PreserveNegativeZero>k__BackingField;
    [CompilerGeneratedAttribute]
private ConversionMode <NumberConversion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WriteBasic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepKeyOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowDuplicateKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReplaceSurrogates>k__BackingField;
    public bool PreserveNegativeZero { get; private set; }
    public ConversionMode NumberConversion { get; private set; }
    public bool WriteBasic { get; private set; }
    public bool KeepKeyOrder { get; private set; }
    public bool AllowDuplicateKeys { get; private set; }
    public bool ReplaceSurrogates { get; private set; }
    public JSONOptions(string paramString);
    private static JSONOptions();
    public virtual string ToString();
    private string FromNumberConversion();
    private static ConversionMode ToNumberConversion(string str);
    [CompilerGeneratedAttribute]
public bool get_PreserveNegativeZero();
    [CompilerGeneratedAttribute]
private void set_PreserveNegativeZero(bool value);
    [CompilerGeneratedAttribute]
public ConversionMode get_NumberConversion();
    [CompilerGeneratedAttribute]
private void set_NumberConversion(ConversionMode value);
    [CompilerGeneratedAttribute]
public bool get_WriteBasic();
    [CompilerGeneratedAttribute]
private void set_WriteBasic(bool value);
    [CompilerGeneratedAttribute]
public bool get_KeepKeyOrder();
    [CompilerGeneratedAttribute]
private void set_KeepKeyOrder(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowDuplicateKeys();
    [CompilerGeneratedAttribute]
private void set_AllowDuplicateKeys(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReplaceSurrogates();
    [CompilerGeneratedAttribute]
private void set_ReplaceSurrogates(bool value);
}
internal static class PeterO.Cbor.JSONPatch : object {
    private static CBORObject AddOperation(CBORObject o, string valueOpStr, string path, CBORObject value);
    private static CBORObject CloneCbor(CBORObject o);
    private static string GetString(CBORObject o, string str);
    public static CBORObject Patch(CBORObject o, CBORObject ptch);
    private static CBORObject RemoveOperation(CBORObject o, string valueOpStr, string path);
    private static CBORObject ReplaceOperation(CBORObject o, string valueOpStr, string path, CBORObject value);
}
internal class PeterO.Cbor.JSONPointer : object {
    private string refValue;
    private bool isRoot;
    private CBORObject jsonobj;
    private JSONPointer(CBORObject jsonobj, string refValue);
    private JSONPointer(CBORObject jsonobj, string refValue, bool isRoot);
    public static JSONPointer FromPointer(CBORObject obj, string pointer);
    public static CBORObject GetObject(CBORObject obj, string pointer, CBORObject defaultValue);
    private static int ReadPositiveInteger(string str, int index, Int32[] result);
    public bool Exists();
    public int GetIndex();
    public string GetKey();
    public CBORObject GetParent();
    public CBORObject GetValue();
    public static IDictionary`2<string, CBORObject> GetPointersWithKeyAndRemove(CBORObject root, string keyToFind);
    public static IDictionary`2<string, CBORObject> GetPointersWithKey(CBORObject root, string keyToFind);
    private static string Replace(string str, char c, string srep);
    private static void GetPointersWithKey(CBORObject root, string keyToFind, string currentPointer, IDictionary`2<string, CBORObject> pointerList, bool remove);
}
internal class PeterO.Cbor.OptionsParser : object {
    private IDictionary`2<string, string> dict;
    public OptionsParser(string options);
    private static String[] SplitAt(string str, string delimiter);
    public string GetLCString(string key, string defaultValue);
    public bool GetBoolean(string key, bool defaultValue);
}
public class PeterO.Cbor.PODOptions : object {
    public static PODOptions Default;
    [CompilerGeneratedAttribute]
private bool <UseCamelCase>k__BackingField;
    public bool UseCamelCase { get; private set; }
    [ObsoleteAttribute("Use the more readable string constructor instead.")]
public PODOptions(bool removeIsPrefix, bool useCamelCase);
    public PODOptions(string paramString);
    private static PODOptions();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public bool get_UseCamelCase();
    [CompilerGeneratedAttribute]
private void set_UseCamelCase(bool value);
}
internal static class PeterO.Cbor.PropertyMap : object {
    private static int TicksDivFracSeconds;
    [ThreadStaticAttribute]
private static IDictionary`2<Type, IList`1<PropertyData>> propertyLists;
    private static bool IsGenericType(Type type);
    private static bool IsClassOrValueType(Type type);
    private static Type FirstGenericArgument(Type type);
    private static bool IsAssignableFrom(Type superType, Type subType);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
private static IEnumerable`1<PropertyInfo> GetTypeProperties(Type t);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
private static IEnumerable`1<FieldInfo> GetTypeFields(Type t);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
private static IEnumerable`1<Type> GetTypeInterfaces(Type t);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
private static MethodInfo GetTypeMethod(Type t, string name, Type[] parameters);
    private static bool HasCustomAttribute(Type t, string name);
    private static string RemoveIsPrefix(string pn);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
private static IList`1<PropertyData> GetPropertyList(Type t);
    public static IList`1<CBORObject> ListFromArray(CBORObject[] array);
    public static bool ExceedsKnownLength(Stream inStream, long size);
    public static void SkipStreamToEnd(Stream inStream);
    public static bool FirstElement(Int32[] dimensions);
    public static bool NextElement(Int32[] index, Int32[] dimensions);
    public static CBORObject BuildCBORArray(Int32[] dimensions);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public static CBORObject FromArray(object arrObj, PODOptions options, CBORTypeMapper mapper, int depth);
    private static CBORObject GetCBORObject(CBORObject cbor, Int32[] index);
    private static void SetCBORObject(CBORObject cbor, Int32[] index, CBORObject obj);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public static Array FillArray(Array arr, Type elementType, CBORObject cbor, CBORTypeMapper mapper, PODOptions options, int depth);
    public static Int32[] GetDimensions(CBORObject obj);
    public static object ObjectToEnum(CBORObject obj, Type enumType);
    public static object EnumToObject(Enum value);
    public static object EnumToObjectAsInteger(Enum value);
    public static ICollection`1<TKey> GetSortedKeys(IDictionary`2<TKey, TValue> dict);
    public static ICollection`1<KeyValuePair`2<TKey, TValue>> GetEntries(IDictionary`2<TKey, TValue> dict);
    public static ICollection`1<TKey> ReadOnlyKeys(IDictionary`2<TKey, TValue> dict);
    public static bool DictRemove(IDictionary`2<TKey, TValue> dict, TKey key);
    public static ICollection`1<TValue> ReadOnlyValues(IDictionary`2<TKey, TValue> dict);
    public static IDictionary`2<CBORObject, CBORObject> NewOrderedDict();
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public static object FindOneArgumentMethod(Type ty, string name, Type argtype);
    public static object InvokeOneArgumentMethod(object methodInfo, object obj, object argument);
    public static Byte[] UUIDToBytes(Guid guid);
    private static bool StartsWith(string str, string pfx);
    private static object TypeToIntegerObject(CBORObject objThis, Type t);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public static object TypeToObject(CBORObject objThis, Type t, CBORTypeMapper mapper, PODOptions options, int depth);
    public static TValue GetOrDefault(IDictionary`2<TKey, TValue> map, TKey key, TValue defaultValue);
    public static CBORObject FromObjectOther(object obj);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public static object ObjectWithProperties(Type t, IEnumerable`1<KeyValuePair`2<string, CBORObject>> keysValues, CBORTypeMapper mapper, PODOptions options, int depth);
    public static CBORObject CallToObject(ConverterInfo convinfo, object obj);
    public static object CallFromObject(ConverterInfo convinfo, CBORObject obj);
    [RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public static IEnumerable`1<KeyValuePair`2<string, object>> GetProperties(object o);
    [IteratorStateMachineAttribute("PeterO.Cbor.PropertyMap/<GetPropertyNames>d__50")]
[RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public static IEnumerable`1<string> GetPropertyNames(Type t, bool useCamelCase);
    [IteratorStateMachineAttribute("PeterO.Cbor.PropertyMap/<GetProperties>d__51")]
[RequiresUnreferencedCodeAttribute("Do not use in AOT or reflection-free contexts.")]
public static IEnumerable`1<KeyValuePair`2<string, object>> GetProperties(object o, bool useCamelCase);
    public static void BreakDownDateTime(DateTime bi, EInteger[] year, Int32[] lf);
    public static DateTime BuildUpDateTime(EInteger year, Int32[] dt);
}
internal class PeterO.Cbor.SharedRefs : object {
    private IList`1<CBORObject> sharedObjects;
    public void AddObject(CBORObject obj);
    public CBORObject GetObject(long smallIndex);
    public CBORObject GetObject(EInteger bigIndex);
}
internal class PeterO.Cbor.StringOutput : object {
    private StringBuilder builder;
    private Stream outputStream;
    public StringOutput(StringBuilder builder);
    public StringOutput(Stream outputStream);
    public void WriteString(string str);
    public void WriteString(string str, int index, int length);
    public void WriteAscii(Byte[] bytes, int index, int length);
    public void WriteCodePoint(int codePoint);
}
internal class PeterO.Cbor.StringRefs : object {
    private List`1<List`1<CBORObject>> stack;
    public void Push();
    public void Pop();
    public void AddStringIfNeeded(CBORObject str, int lengthHint);
    public CBORObject GetString(long smallIndex);
    public CBORObject GetString(EInteger bigIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("100")]
[ExcludeFromCodeCoverageAttribute]
[ConditionalAttribute("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
internal class System.Diagnostics.CodeAnalysis.RequiresDynamicCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    [NullableAttribute("2")]
public string Url { get; public set; }
    public RequiresDynamicCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Url();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Url(string value);
}
[AttributeUsageAttribute("32")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.StringSyntaxAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Syntax>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Object[] <Arguments>k__BackingField;
    public static string CompositeFormat;
    public static string DateOnlyFormat;
    public static string DateTimeFormat;
    public static string EnumFormat;
    public static string GuidFormat;
    public static string Json;
    public static string NumericFormat;
    public static string Regex;
    public static string TimeOnlyFormat;
    public static string TimeSpanFormat;
    public static string Uri;
    public static string Xml;
    public string Syntax { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] Arguments { get; }
    public StringSyntaxAttribute(string syntax);
    public StringSyntaxAttribute(string syntax, Object[] arguments);
    [CompilerGeneratedAttribute]
public string get_Syntax();
    [CompilerGeneratedAttribute]
public Object[] get_Arguments();
}
[AttributeUsageAttribute("2240")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.UnscopedRefAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public void set_IsOptional(bool value);
}
[AttributeUsageAttribute("1")]
[ExcludeFromCodeCoverageAttribute]
[ConditionalAttribute("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
internal class System.Runtime.CompilerServices.DisableRuntimeMarshallingAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("396")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.RequiredMemberAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2047")]
[ExcludeFromCodeCoverageAttribute]
[ConditionalAttribute("MULTI_TARGETING_SUPPORT_ATTRIBUTES")]
internal class System.Runtime.Versioning.ObsoletedOSPlatformAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    public string Url { get; public set; }
    [NullableContextAttribute("1")]
public ObsoletedOSPlatformAttribute(string platformName);
    [NullableContextAttribute("1")]
public ObsoletedOSPlatformAttribute(string platformName, string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
