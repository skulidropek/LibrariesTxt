[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public static class PInvoke.Kernel32 : object {
    public static int MAX_MODULE_NAME32;
    public static int MAX_PATH;
    public static IntPtr INVALID_HANDLE_VALUE;
    private static string api_ms_win_core_localization_l1_2_0;
    private static string api_ms_win_core_processthreads_l1_1_1;
    private static string api_ms_win_core_io_l1_1_1;
    private static string api_ms_win_core_file_l1_2_0;
    private static string api_ms_win_core_synch_l1_2_0;
    private static string api_ms_win_core_handle_l1_1_0;
    private static string api_ms_win_core_console_l1_1_0;
    private static string api_ms_win_core_console_l2_1_0;
    private static string api_ms_win_core_psapi_l1_1_0;
    private static string api_ms_win_core_namedpipe_l1_2_0;
    private static string api_ms_win_core_libraryloader_l1_1_1;
    private static string api_ms_win_core_sysinfo_l1_2_1;
    private static string api_ms_win_core_sysinfo_l1_2_0;
    private static string api_ms_win_core_errorhandling_l1_1_1;
    public static Char* RT_CURSOR;
    public static Char* RT_BITMAP;
    public static Char* RT_ICON;
    public static Char* RT_MENU;
    public static Char* RT_DIALOG;
    public static Char* RT_STRING;
    public static Char* RT_FONTDIR;
    public static Char* RT_FONT;
    public static Char* RT_ACCELERATOR;
    public static Char* RT_RCDATA;
    public static Char* RT_MESSAGETABLE;
    public static Char* RT_GROUP_CURSOR;
    public static Char* RT_GROUP_ICON;
    public static Char* RT_VERSION;
    public static Char* RT_DLGINCLUDE;
    public static Char* RT_PLUGPLAY;
    public static Char* RT_VXD;
    public static Char* RT_ANICURSOR;
    public static Char* RT_ANIICON;
    public static Char* RT_HTML;
    public static int PIPE_UNLIMITED_INSTANCES;
    public static int DefaultShutdownLevel;
    public static int NMPWAIT_USE_DEFAULT_WAIT;
    public static int NMPWAIT_WAIT_FOREVER;
    public static int NMPWAIT_NOWAIT;
    private static Kernel32();
    public static SafeFindFilesHandle FindFirstFileEx(string lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, WIN32_FIND_DATA& lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, Void* lpSearchFilter, FindFirstFileExFlags dwAdditionalFlags);
    public static int FormatMessage(FormatMessageFlags dwFlags, Void* lpSource, int dwMessageId, int dwLanguageId, StringBuilder lpBuffer, int nSize, IntPtr[] Arguments);
    public static int GetCurrentThreadId();
    public static int GetCurrentProcessId();
    public static int GetProcessId(IntPtr Process);
    public static SafeObjectHandle GetCurrentProcess();
    public static bool CancelIoEx(SafeObjectHandle hFile, OVERLAPPED* lpOverlapped);
    public static bool ReadFile(SafeObjectHandle hFile, Void* lpBuffer, int nNumberOfBytesToRead, Int32* lpNumberOfBytesRead, OVERLAPPED* lpOverlapped);
    public static bool WriteFile(SafeObjectHandle hFile, Void* lpBuffer, int nNumberOfBytesToWrite, Int32* lpNumberOfBytesWritten, OVERLAPPED* lpOverlapped);
    public static bool SetFilePointerEx(SafeObjectHandle hFile, long liDistanceToMove, Int64& lpNewFilePointer, SeekOrigin dwMoveMethod);
    public static int SetFilePointer(SafeObjectHandle hFile, int lDistanceToMove, Int32* lpDistanceToMoveHigh, SeekOrigin dwMoveMethod);
    public static int SuspendThread(SafeObjectHandle hThread);
    public static int ResumeThread(SafeObjectHandle hThread);
    public static WaitForSingleObjectResult WaitForSingleObject(SafeHandle hHandle, int dwMilliseconds);
    [SuppressUnmanagedCodeSecurityAttribute]
[ReliabilityContractAttribute("3", "2")]
public static bool CloseHandle(IntPtr hObject);
    public static bool DeviceIoControl(SafeObjectHandle hDevice, int dwIoControlCode, Void* inBuffer, int nInBufferSize, Void* outBuffer, int nOutBufferSize, Int32& pBytesReturned, OVERLAPPED* lpOverlapped);
    public static bool FlushFileBuffers(SafeObjectHandle hFile);
    public static SafeObjectHandle CreateMutex(SECURITY_ATTRIBUTES* lpMutexAttributes, bool bInitialOwner, string lpName);
    public static IntPtr GetProcAddress(SafeLibraryHandle hModule, string procName);
    public static UInt32 GetTickCount();
    public static ulong GetTickCount64();
    public static void GetSystemTime(SYSTEMTIME* lpSystemTime);
    public static void SetLastError(UInt32 dwErrCode);
    public static long VerSetConditionMask(long ConditionMask, VER_MASK TypeMask, VER_CONDITION Condition);
    public static NTSTATUS VerifyVersionInfo(OSVERSIONINFOEX* lpVersionInformation, VER_MASK dwTypeMask, long dwlConditionMask);
    public static bool FileTimeToSystemTime(FILETIME* lpFileTime, SYSTEMTIME* lpSystemTime);
    public static bool SystemTimeToFileTime(SYSTEMTIME* lpSystemTime, FILETIME* lpFileTime);
    public static int CompareFileTime(FILETIME* lpFileTime1, FILETIME* lpFileTime2);
    public static ErrorModes SetErrorMode(ErrorModes uMode);
    public static bool GetVolumeInformation(string lpRootPathName, Char* lpVolumeNameBuffer, int nVolumeNameSize, UInt32& lpVolumeSerialNumber, Int32& lpMaximumComponentLength, FileSystemFlags& lpFileSystemFlags, Char* lpFileSystemNameBuffer, int nFileSystemNameSize);
    public static bool FlushInstructionCache(SafeObjectHandle hProcess, Void* lpcBaseAddress, UIntPtr dwSize);
    public static void FlushProcessWriteBuffers();
    public static UInt32 GetCurrentProcessorNumber();
    public static void GetCurrentProcessorNumberEx(PROCESSOR_NUMBER* ProcNumber);
    public static SafeObjectHandle GetCurrentThread();
    public static void GetCurrentThreadStackLimits(UIntPtr& LowLimit, UIntPtr& HighLimit);
    public static ProcessPriorityClass GetPriorityClass(SafeObjectHandle hProcess);
    public static void GetNativeSystemInfo(SYSTEM_INFO* lpSystemInfo);
    public static bool GetProcessInformation(SafeObjectHandle hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, Void* ProcessInformation, UInt32 ProcessInformationSize);
    public static bool SetProcessInformation(SafeObjectHandle hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, Void* ProcessInformation, UInt32 ProcessInformationSize);
    private static bool FindClose(IntPtr hFindFile);
    private static bool FreeLibrary(IntPtr hModule);
    public static string FormatMessage(FormatMessageFlags dwFlags, Void* lpSource, int dwMessageId, int dwLanguageId, IntPtr[] Arguments, int maxAllowedBufferSize);
    public static Win32ErrorCode GetLastError();
    public static int WriteFile(SafeObjectHandle hFile, Void* lpBuffer, int nNumberOfBytesToWrite);
    public static int WriteFile(SafeObjectHandle hFile, ArraySegment`1<byte> lpBuffer);
    public static int ReadFile(SafeObjectHandle hFile, Void* lpBuffer, int nNumberOfBytesToRead);
    public static int ReadFile(SafeObjectHandle hFile, ArraySegment`1<byte> lpBuffer);
    public static ArraySegment`1<byte> ReadFile(SafeObjectHandle hFile, int nNumberOfBytesToRead);
    public static bool CancelIoEx(SafeObjectHandle hFile, NativeOverlapped* lpOverlapped);
    public static bool ReadFile(SafeObjectHandle hFile, Void* lpBuffer, int nNumberOfBytesToRead, Int32* lpNumberOfBytesRead, NativeOverlapped* lpOverlapped);
    public static bool WriteFile(SafeObjectHandle hFile, Void* lpBuffer, int nNumberOfBytesToWrite, Int32* lpNumberOfBytesWritten, NativeOverlapped* lpOverlapped);
    public static bool DeviceIoControl(SafeObjectHandle hDevice, int dwIoControlCode, Void* inBuffer, int nInBufferSize, Void* outBuffer, int nOutBufferSize, Int32& pBytesReturned, NativeOverlapped* lpOverlapped);
    private static bool TryGetErrorMessage(FormatMessageFlags flags, Void* source, int messageId, int languageId, StringBuilder sb, IntPtr[] arguments, String& errorMsg);
    public static LANGID MAKELANGID(ushort usPrimaryLanguage, ushort usSubLanguage);
    public static LANGID MAKELANGID(PrimaryLanguage ePrimaryLanguage, SubLanguage eSubLanguage);
    public static bool Beep(int frequency, int duration);
    public static bool TerminateProcess(IntPtr hProcess, int uExitCode);
    public static bool TerminateThread(IntPtr hThread, int dwExitCode);
    public static void ExitProcess(int uExitCode);
    public static void ExitThread(int dwExitCode);
    public static bool GetExitCodeThread(IntPtr hThread, Int32& lpExitCode);
    public static bool GetExitCodeProcess(IntPtr hProcess, Int32& lpExitCode);
    public static bool SetProcessShutdownParameters(int dwLevel, ProcessShutdownFlags dwFlags);
    public static bool CreateProcess(string lpApplicationName, string lpCommandLine, SECURITY_ATTRIBUTES* lpProcessAttributes, SECURITY_ATTRIBUTES* lpThreadAttributes, bool bInheritHandles, CreateProcessFlags dwCreationFlags, Void* lpEnvironment, string lpCurrentDirectory, STARTUPINFO& lpStartupInfo, PROCESS_INFORMATION& lpProcessInformation);
    public static bool CreateProcessAsUser(IntPtr hToken, string lpApplicationName, string lpCommandLine, SECURITY_ATTRIBUTES* lpProcessAttributes, SECURITY_ATTRIBUTES* lpThreadAttributes, bool bInheritHandles, CreateProcessFlags dwCreationFlags, Void* lpEnvironment, string lpCurrentDirectory, STARTUPINFO& lpStartupInfo, PROCESS_INFORMATION& lpProcessInformation);
    public static void GetStartupInfo(STARTUPINFO* lpStartupInfo);
    public static bool InitializeProcThreadAttributeList(PROC_THREAD_ATTRIBUTE_LIST* lpAttributeList, int dwAttributeCount, UInt32 dwFlags, IntPtr& lpSize);
    public static bool UpdateProcThreadAttribute(PROC_THREAD_ATTRIBUTE_LIST* lpAttributeList, UInt32 dwFlags, UInt32& Attribute, Void* lpValue, IntPtr cbSize, IntPtr& lpPreviousValue, IntPtr& lpReturnSize);
    public static void DeleteProcThreadAttributeList(PROC_THREAD_ATTRIBUTE_LIST* lpAttributeList);
    public static bool AllocConsole();
    public static bool FreeConsole();
    public static bool AttachConsole(int dwProcessId);
    public static SafeObjectHandle CreateFile(Char* filename, ACCESS_MASK access, FileShare share, SECURITY_ATTRIBUTES* securityAttributes, CreationDisposition creationDisposition, CreateFileFlags flagsAndAttributes, SafeObjectHandle templateFile);
    public static SafeFindFilesHandle FindFirstFile(string lpFileName, WIN32_FIND_DATA& lpFindFileData);
    public static bool FindNextFile(SafeFindFilesHandle hFindFile, WIN32_FIND_DATA& lpFindFileData);
    public static SafeObjectHandle CreateToolhelp32Snapshot(CreateToolhelp32SnapshotFlags dwFlags, int th32ProcessID);
    public static bool Process32First(SafeObjectHandle hSnapshot, PROCESSENTRY32* lppe);
    public static bool Process32Next(SafeObjectHandle hSnapshot, PROCESSENTRY32* lppe);
    public static bool Module32First(SafeObjectHandle hSnapshot, MODULEENTRY32* lpme);
    public static bool Module32Next(SafeObjectHandle hSnapshot, MODULEENTRY32* lpme);
    public static bool GetProcessTimes(SafeObjectHandle handle, FILETIME& creation, FILETIME& exit, FILETIME& kernel, FILETIME& user);
    public static bool QueryFullProcessImageName(SafeObjectHandle hProcess, QueryFullProcessImageNameFlags dwFlags, Char* lpExeName, Int32& lpdwSize);
    public static bool QueryFullProcessImageName(SafeObjectHandle hProcess, QueryFullProcessImageNameFlags dwFlags, StringBuilder lpExeName, Int32& lpdwSize);
    public static SafeObjectHandle OpenProcess(ACCESS_MASK dwDesiredAccess, bool bInheritHandle, int dwProcessId);
    public static bool GetOverlappedResult(SafeObjectHandle hFile, OVERLAPPED* lpOverlapped, Int32& lpNumberOfBytesTransferred, bool bWait);
    public static bool CancelIo(SafeObjectHandle hFile);
    public static bool IsWow64Process(SafeObjectHandle hProcess, Boolean& Wow64Process);
    public static bool CreatePipe(SafeObjectHandle& hReadPipe, SafeObjectHandle& hWritePipe, SECURITY_ATTRIBUTES* lpPipeAttributes, int nSize);
    public static bool K32EmptyWorkingSet(SafeObjectHandle hProcess);
    public static IntPtr GetConsoleWindow();
    public static SafeLibraryHandle LoadLibrary(string lpFileName);
    public static SafeLibraryHandle LoadLibraryEx(string lpFileName, IntPtr hFile, LoadLibraryExFlags dwFlags);
    public static IntPtr AddDllDirectory(string NewDirectory);
    public static bool GetDllDirectory(int nBufferLength, Char* lpBuffer);
    public static bool SetDllDirectory(string lpPathName);
    public static IntPtr GetModuleHandle(string lpModuleName);
    public static bool GetModuleHandleEx(GetModuleHandleExFlags dwFlags, string lpModuleName, SafeLibraryHandle& phModule);
    public static SafeObjectHandle CreateNamedPipe(string lpName, PipeAccessMode dwOpenMode, PipeMode dwPipeMode, int nMaxInstances, int nOutBufferSize, int nInBufferSize, int nDefaultTimeOut, SECURITY_ATTRIBUTES* lpSecurityAttributes);
    public static bool WaitNamedPipe(string lpNamedPipeName, int nTimeOut);
    public static bool ConnectNamedPipe(SafeObjectHandle hNamedPipe, OVERLAPPED* lpOverlapped);
    public static bool CallNamedPipe(string lpNamedPipeName, Void* lpInBuffer, int nInBufferSize, Void* lpOutBuffer, int nOutBufferSize, Int32& lpBytesRead, int nTimeOut);
    public static bool GetNamedPipeClientComputerName(SafeObjectHandle Pipe, StringBuilder ClientComputerName, int ClientComputerNameLength);
    public static bool DisconnectNamedPipe(SafeObjectHandle hNamedPipe);
    public static bool GetNamedPipeClientComputerName(SafeObjectHandle Pipe, Char* ClientComputerName, int ClientComputerNameLength);
    public static bool GetNamedPipeClientProcessId(SafeObjectHandle Pipe, Int32& ClientProcessId);
    public static bool GetNamedPipeClientSessionId(SafeObjectHandle Pipe, Int32& ClientSessionId);
    public static bool GetNamedPipeHandleState(SafeObjectHandle hNamedPipe, PipeMode& lpState, Int32* lpCurInstances, Int32* lpMaxCollectionCount, Int32* lpCollectDataTimeout, StringBuilder lpUserName, int nMaxUserNameSize);
    public static bool GetNamedPipeHandleState(SafeObjectHandle hNamedPipe, PipeMode& lpState, Int32* lpCurInstances, Int32* lpMaxCollectionCount, Int32* lpCollectDataTimeout, Char* lpUserName, int nMaxUserNameSize);
    public static bool GetNamedPipeInfo(SafeObjectHandle hNamedPipe, NamedPipeInfoFlags& lpFlags, Int32& lpOutBufferSize, Int32& lpInBufferSize, Int32& lpMaxInstances);
    public static bool GetNamedPipeServerProcessId(SafeObjectHandle Pipe, Int32& ServerProcessId);
    public static bool GetNamedPipeServerSessionId(SafeObjectHandle Pipe, Int32& ServerSessionId);
    public static bool PeekNamedPipe(SafeObjectHandle hNamedPipe, Void* lpBuffer, int nBufferSize, Int32& lpBytesRead, Int32& lpTotalBytesAvail, Int32& lpBytesLeftThisMessage);
    public static bool SetNamedPipeHandleState(SafeObjectHandle hNamedPipe, PipeMode* lpMode, Int32* lpMaxCollectionCount, Int32* lpCollectDataTimeout);
    public static bool TransactNamedPipe(SafeObjectHandle hNamedPipe, Void* lpInBuffer, int nInBufferSize, Void* lpOutBuffer, int nOutBufferSize, Int32& lpBytesRead, OVERLAPPED* lpOverlapped);
    public static Void* LocalAlloc(LocalAllocFlags uFlags, IntPtr uBytes);
    public static Void* LocalReAlloc(Void* hMem, IntPtr uBytes, LocalReAllocFlags uFlags);
    public static Void* LocalFree(Void* hMem);
    public static Void* LocalLock(Void* hMem);
    public static bool LocalUnlock(Void* hMem);
    public static Void* GlobalAlloc(GlobalAllocFlags uFlags, IntPtr uBytes);
    public static Void* GlobalReAlloc(Void* hMem, IntPtr uBytes, GlobalReAllocFlags uFlags);
    public static Void* GlobalFree(Void* hMem);
    public static Void* GlobalLock(Void* hMem);
    public static bool GlobalUnlock(Void* hMem);
    public static Void* HeapAlloc(IntPtr hHeap, HeapAllocFlags uFlags, IntPtr uBytes);
    public static Void* HeapReAlloc(IntPtr hHeap, HeapReAllocFlags uFlags, Void* hMem, IntPtr uBytes);
    public static bool HeapFree(IntPtr hHeap, HeapFreeFlags dwFlags, Void* hMem);
    public static bool HeapLock(IntPtr hMem);
    public static bool HeapUnlock(IntPtr hHeap);
    public static void CopyMemory(Void* Destination, Void* Source, IntPtr Length);
    public static void MoveMemory(Void* Destination, Void* Source, IntPtr Length);
    public static bool EnumResourceNames(SafeLibraryHandle hModule, Char* lpszType, EnumResNameProc lpEnumFunc, IntPtr lParam);
    public static bool EnumResourceLanguages(SafeLibraryHandle hModule, Char* lpType, Char* lpName, EnumResLangProc lpEnumFunc, Void* lParam);
    public static bool IS_INTRESOURCE(Char* p);
    public static Char* MAKEINTRESOURCE(int wInteger);
    public static IntPtr FindResource(SafeLibraryHandle hModule, Char* lpName, Char* lpType);
    public static int SizeofResource(SafeLibraryHandle hModule, IntPtr hResInfo);
    public static int Wow64SuspendThread(SafeObjectHandle hThread);
    public static bool AssignProcessToJobObject(SafeObjectHandle hJob, SafeObjectHandle hProcess);
    public static SafeObjectHandle CreateJobObject(SECURITY_ATTRIBUTES* lpJobAttributes, string lpName);
    public static bool IsProcessInJob(SafeObjectHandle hProcess, SafeObjectHandle hJob, Boolean& result);
    public static bool SetInformationJobObject(SafeObjectHandle hJob, JOBOBJECTINFOCLASS jobObjectInfoClass, Void* lpJobObjectInfo, UInt32 cbJobObjectInfoLength);
    public static bool GenerateConsoleCtrlEvent(ControlType dwCtrlEvent, UInt32 dwProcessGroupId);
    public static bool AddConsoleAlias(string Source, string Target, string ExeName);
    public static IntPtr CreateConsoleScreenBuffer(ACCESS_MASK dwDesiredAccess, FileShare dwShareMode, SECURITY_ATTRIBUTES* lpSecurityAttributes, ConsoleScreenBufferFlag dwFlags, Void* lpScreenBufferData);
    public static bool FlushConsoleInputBuffer(IntPtr hConsoleInput);
    public static int GetConsoleAliases(Char* lpAliasBuffer, int AliasBufferLength, string lpExeName);
    public static int GetConsoleAliasesLength(string lpExeName);
    public static int GetConsoleAliasExes(Char* lpExeNameBuffer, int ExeNameBufferLength);
    public static int GetConsoleAliasExesLength();
    public static int GetConsoleAlias(string lpSource, Char* lpTargetBuffer, int TargetBufferLength, string lpExeName);
    public static UInt32 GetConsoleCP();
    public static bool GetConsoleDisplayMode(ConsoleDisplayMode& lpModeFlags);
    public static COORD GetConsoleFontSize(IntPtr hConsoleOutput, UInt32 nFont);
    public static bool GetConsoleMode(IntPtr hConsoleHandle, ConsoleBufferModes& lpMode);
    public static bool SetConsoleMode(IntPtr hConsoleHandle, ConsoleBufferModes dwMode);
    public static UInt32 GetConsoleOutputCP();
    public static bool SetConsoleOutputCP(UInt32 wCodePageID);
    public static bool SetConsoleCP(UInt32 wCodePageID);
    public static int GetConsoleProcessList(UInt32* lpdwProcessList, int dwProcessCount);
    public static bool GetConsoleScreenBufferInfo(IntPtr hConsoleOutput, CONSOLE_SCREEN_BUFFER_INFO* lpConsoleScreenBufferInfo);
    public static bool GetConsoleSelectionInfo(CONSOLE_SELECTION_INFO* lpConsoleSelectionInfo);
    public static int GetConsoleTitle(Char* lpConsoleTitle, int nSize);
    public static bool SetConsoleTitle(string lpConsoleTitle);
    public static COORD GetLargestConsoleWindowSize(IntPtr hConsoleOutput);
    public static bool GetNumberOfConsoleInputEvents(IntPtr hConsoleInput, Int32& lpNumberOfEvents);
    public static bool PeekConsoleInput(IntPtr hConsoleInput, INPUT_RECORD& lpBuffer, int nLength, Int32& lpNumberOfEventsRead);
    public static bool ReadConsoleOutput(IntPtr hConsoleOutput, CHAR_INFO* lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, SMALL_RECT& lpReadRegion);
    public static bool ReadConsole(IntPtr hConsoleInput, Char* lpBuffer, int nNumberOfCharsToRead, Int32& lpNumberOfCharsRead, CONSOLE_READCONSOLE_CONTROL* pInputControl);
    public static bool ReadConsoleInput(IntPtr hConsoleInput, INPUT_RECORD& lpBuffer, int nLength, Int32& lpNumberOfEventsRead);
    public static bool ScrollConsoleScreenBuffer(IntPtr hConsoleOutput, SMALL_RECT* lpScrollRectangle, SMALL_RECT* lpClipRectangle, COORD dwDestinationOrigin, CHAR_INFO* lpFill);
    public static bool SetConsoleActiveScreenBuffer(IntPtr hConsoleOutput);
    public static UInt32 WTSGetActiveConsoleSessionId();
    public static bool WriteConsole(IntPtr hConsoleOutput, Void* lpBuffer, int nNumberOfCharsToWrite, Int32* lpNumberOfCharsWritten, IntPtr lpReserved);
    public static bool WriteConsoleOutput(IntPtr hConsoleOutput, CHAR_INFO* lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, SMALL_RECT* lpWriteRegion);
    public static bool WriteConsoleInput(IntPtr hConsoleInput, INPUT_RECORD* lpBuffer, int nLength, Int32* lpNumberOfEventsWritten);
    public static bool SetConsoleTextAttribute(IntPtr hConsoleOutput, CharacterAttributesFlags wAttributes);
    public static bool SetConsoleCursorPosition(IntPtr hConsoleOutput, COORD dwCursorPosition);
    public static bool SetConsoleCtrlHandler(HandlerRoutine handlerRoutine, bool add);
    public static EXECUTION_STATE SetThreadExecutionState(EXECUTION_STATE esFlags);
    public static bool WriteProcessMemory(IntPtr hProcess, Void* lpBaseAddress, Void* lpBuffer, UIntPtr nSize, UIntPtr& lpNumberOfBytesWritten);
    [ObsoleteAttribute("Use ReadProcessMemory(SafeObjectHandle, ...) instead")]
public static bool ReadProcessMemory(IntPtr hProcess, Void* lpBaseAddress, Void* lpBuffer, UIntPtr nSize, UIntPtr& lpNumberOfBytesRead);
    public static bool ReadProcessMemory(SafeObjectHandle hProcess, Void* lpBaseAddress, Void* lpBuffer, UIntPtr nSize, UIntPtr& lpNumberOfBytesRead);
    public static IntPtr GetStdHandle(StdHandle nStdHandle);
    public static bool SetStdHandle(StdHandle nStdHandle, IntPtr nHandle);
    public static Void* LockResource(IntPtr hResData);
    public static IntPtr LoadResource(SafeLibraryHandle hModule, IntPtr hResInfo);
    public static bool SetSystemTime(SYSTEMTIME* lpSystemTime);
    public static bool SetHandleInformation(SafeHandle hObject, HandleFlags dwMask, HandleFlags dwFlags);
    public static bool GetHandleInformation(SafeHandle hObject, HandleFlags* lpdwFlags);
    public static SafeObjectHandle CreateThread(SECURITY_ATTRIBUTES* lpThreadAttributes, UIntPtr dwStackSize, THREAD_START_ROUTINE lpStartAddress, Void* lpParameter, CreateThreadFlags dwCreationFlags, UInt32* lpThreadId);
    public static SafeObjectHandle CreateRemoteThread(IntPtr hProcess, SECURITY_ATTRIBUTES* lpThreadAttributes, UIntPtr dwStackSize, THREAD_START_ROUTINE lpStartAddress, Void* lpParameter, CreateThreadFlags dwCreationFlags, UInt32* lpThreadId);
    public static SafeObjectHandle CreateRemoteThreadEx(IntPtr hProcess, SECURITY_ATTRIBUTES* lpThreadAttributes, UIntPtr dwStackSize, THREAD_START_ROUTINE lpStartAddress, Void* lpParameter, CreateThreadFlags dwCreationFlags, PROC_THREAD_ATTRIBUTE_LIST* lpAttributeList, UInt32* lpThreadId);
    public static HResult CreatePseudoConsole(COORD size, SafeObjectHandle hInput, SafeObjectHandle hOutput, CreatePseudoConsoleFlags dwFlags, SafePseudoConsoleHandle& phPC);
    public static HResult ResizePseudoConsole(SafePseudoConsoleHandle hPC, COORD size);
    public static bool DosDateTimeToFileTime(ushort wFatDate, ushort wFatTime, FILETIME* lpFileTime);
    public static SafeObjectHandle GetCurrentProcessToken();
    public static SafeObjectHandle GetCurrentThreadEffectiveToken();
    public static SafeObjectHandle GetCurrentThreadToken();
    public static bool GetProcessHandleCount(SafeObjectHandle hProcess, UInt32& pdwHandleCount);
    public static UInt32 GetProcessIdOfThread(SafeObjectHandle hThread);
    private static void ClosePseudoConsole(IntPtr hPC);
    public static SafeObjectHandle CreateFile(string filename, ACCESS_MASK access, FileShare share, SECURITY_ATTRIBUTES* securityAttributes, CreationDisposition creationDisposition, CreateFileFlags flagsAndAttributes, SafeObjectHandle templateFile);
    public static Nullable`1<PROCESSENTRY32> Process32First(SafeObjectHandle hSnapshot);
    public static Nullable`1<PROCESSENTRY32> Process32Next(SafeObjectHandle hSnapshot);
    [IteratorStateMachineAttribute("PInvoke.Kernel32/<Process32Enumerate>d__369")]
public static IEnumerable`1<PROCESSENTRY32> Process32Enumerate(SafeObjectHandle hSnapshot);
    public static Nullable`1<MODULEENTRY32> Module32First(SafeObjectHandle hSnapshot);
    public static Nullable`1<MODULEENTRY32> Module32Next(SafeObjectHandle hSnapshot);
    [IteratorStateMachineAttribute("PInvoke.Kernel32/<Module32Enumerate>d__372")]
public static IEnumerable`1<MODULEENTRY32> Module32Enumerate(SafeObjectHandle hSnapshot);
    public static string QueryFullProcessImageName(SafeObjectHandle hProcess, QueryFullProcessImageNameFlags dwFlags);
    public static bool IsWow64Process(SafeObjectHandle hProcess);
    public static Void* LocalAlloc(LocalAllocFlags uFlags, int uBytes);
    public static Void* LocalReAlloc(Void* hMem, int uBytes, LocalReAllocFlags uFlags);
    public static ValueTask`1<UInt32> DeviceIoControlAsync(SafeObjectHandle hDevice, UInt32 dwIoControlCode, Memory`1<TInput> inBuffer, Memory`1<TOutput> outBuffer, CancellationToken cancellationToken);
    public static bool GetOverlappedResult(SafeObjectHandle hFile, NativeOverlapped* lpOverlapped, Int32& lpNumberOfBytesTransferred, bool bWait);
    public static SafeFindFilesHandle FindFirstFileEx(string lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, WIN32_FIND_DATA& lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, IntPtr lpSearchFilter, FindFirstFileExFlags dwAdditionalFlags);
    public static int FormatMessage(FormatMessageFlags dwFlags, IntPtr lpSource, int dwMessageId, int dwLanguageId, StringBuilder lpBuffer, int nSize, IntPtr[] Arguments);
    public static bool CancelIoEx(SafeObjectHandle hFile, IntPtr lpOverlapped);
    public static bool ReadFile(SafeObjectHandle hFile, IntPtr lpBuffer, int nNumberOfBytesToRead, IntPtr lpNumberOfBytesRead, IntPtr lpOverlapped);
    public static bool ReadFile(SafeObjectHandle hFile, IntPtr lpBuffer, int nNumberOfBytesToRead, Nullable`1& lpNumberOfBytesRead, IntPtr lpOverlapped);
    public static bool ReadFile(SafeObjectHandle hFile, Void* lpBuffer, int nNumberOfBytesToRead, Nullable`1& lpNumberOfBytesRead, OVERLAPPED* lpOverlapped);
    public static bool WriteFile(SafeObjectHandle hFile, IntPtr lpBuffer, int nNumberOfBytesToWrite, IntPtr lpNumberOfBytesWritten, IntPtr lpOverlapped);
    public static bool WriteFile(SafeObjectHandle hFile, IntPtr lpBuffer, int nNumberOfBytesToWrite, Nullable`1& lpNumberOfBytesWritten, IntPtr lpOverlapped);
    public static bool WriteFile(SafeObjectHandle hFile, Void* lpBuffer, int nNumberOfBytesToWrite, Nullable`1& lpNumberOfBytesWritten, OVERLAPPED* lpOverlapped);
    public static int SetFilePointer(SafeObjectHandle hFile, int lDistanceToMove, IntPtr lpDistanceToMoveHigh, SeekOrigin dwMoveMethod);
    public static int SetFilePointer(SafeObjectHandle hFile, int lDistanceToMove, Nullable`1& lpDistanceToMoveHigh, SeekOrigin dwMoveMethod);
    public static bool DeviceIoControl(SafeObjectHandle hDevice, int dwIoControlCode, IntPtr inBuffer, int nInBufferSize, IntPtr outBuffer, int nOutBufferSize, Int32& pBytesReturned, IntPtr lpOverlapped);
    public static SafeObjectHandle CreateMutex(IntPtr lpMutexAttributes, bool bInitialOwner, string lpName);
    public static SafeObjectHandle CreateMutex(Nullable`1<SECURITY_ATTRIBUTES> lpMutexAttributes, bool bInitialOwner, string lpName);
    public static void GetSystemTime(IntPtr lpSystemTime);
    public static void GetSystemTime(SYSTEMTIME& lpSystemTime);
    public static NTSTATUS VerifyVersionInfo(IntPtr lpVersionInformation, VER_MASK dwTypeMask, long dwlConditionMask);
    public static NTSTATUS VerifyVersionInfo(OSVERSIONINFOEX& lpVersionInformation, VER_MASK dwTypeMask, long dwlConditionMask);
    public static bool FileTimeToSystemTime(IntPtr lpFileTime, IntPtr lpSystemTime);
    public static bool FileTimeToSystemTime(FILETIME lpFileTime, SYSTEMTIME& lpSystemTime);
    public static bool SystemTimeToFileTime(IntPtr lpSystemTime, IntPtr lpFileTime);
    public static bool SystemTimeToFileTime(SYSTEMTIME lpSystemTime, FILETIME& lpFileTime);
    public static int CompareFileTime(IntPtr lpFileTime1, IntPtr lpFileTime2);
    public static int CompareFileTime(FILETIME lpFileTime1, FILETIME lpFileTime2);
    public static bool GetVolumeInformation(string lpRootPathName, IntPtr lpVolumeNameBuffer, int nVolumeNameSize, UInt32& lpVolumeSerialNumber, Int32& lpMaximumComponentLength, FileSystemFlags& lpFileSystemFlags, IntPtr lpFileSystemNameBuffer, int nFileSystemNameSize);
    public static bool GetVolumeInformation(string lpRootPathName, Span`1<char> lpVolumeNameBuffer, UInt32& lpVolumeSerialNumber, Int32& lpMaximumComponentLength, FileSystemFlags& lpFileSystemFlags, Span`1<char> lpFileSystemNameBuffer);
    public static bool GetVolumeInformation(string lpRootPathName, Char[] lpVolumeNameBuffer, int nVolumeNameSize, UInt32& lpVolumeSerialNumber, Int32& lpMaximumComponentLength, FileSystemFlags& lpFileSystemFlags, Char[] lpFileSystemNameBuffer, int nFileSystemNameSize);
    public static bool FlushInstructionCache(SafeObjectHandle hProcess, IntPtr lpcBaseAddress, UIntPtr dwSize);
    public static void GetCurrentProcessorNumberEx(IntPtr ProcNumber);
    public static void GetCurrentProcessorNumberEx(PROCESSOR_NUMBER& ProcNumber);
    public static void GetNativeSystemInfo(IntPtr lpSystemInfo);
    public static void GetNativeSystemInfo(SYSTEM_INFO& lpSystemInfo);
    public static bool GetProcessInformation(SafeObjectHandle hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, IntPtr ProcessInformation, UInt32 ProcessInformationSize);
    public static bool SetProcessInformation(SafeObjectHandle hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, IntPtr ProcessInformation, UInt32 ProcessInformationSize);
    public static string FormatMessage(FormatMessageFlags dwFlags, IntPtr lpSource, int dwMessageId, int dwLanguageId, IntPtr[] Arguments, int maxAllowedBufferSize);
    public static int WriteFile(SafeObjectHandle hFile, IntPtr lpBuffer, int nNumberOfBytesToWrite);
    public static int ReadFile(SafeObjectHandle hFile, IntPtr lpBuffer, int nNumberOfBytesToRead);
    private static bool TryGetErrorMessage(FormatMessageFlags flags, IntPtr source, int messageId, int languageId, StringBuilder sb, IntPtr[] arguments, String& errorMsg);
    public static bool CreateProcess(string lpApplicationName, string lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, bool bInheritHandles, CreateProcessFlags dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, STARTUPINFO& lpStartupInfo, PROCESS_INFORMATION& lpProcessInformation);
    public static bool CreateProcess(string lpApplicationName, string lpCommandLine, Nullable`1<SECURITY_ATTRIBUTES> lpProcessAttributes, Nullable`1<SECURITY_ATTRIBUTES> lpThreadAttributes, bool bInheritHandles, CreateProcessFlags dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, STARTUPINFO& lpStartupInfo, PROCESS_INFORMATION& lpProcessInformation);
    public static bool CreateProcess(string lpApplicationName, string lpCommandLine, Nullable`1<SECURITY_ATTRIBUTES> lpProcessAttributes, Nullable`1<SECURITY_ATTRIBUTES> lpThreadAttributes, bool bInheritHandles, CreateProcessFlags dwCreationFlags, Void* lpEnvironment, string lpCurrentDirectory, STARTUPINFO& lpStartupInfo, PROCESS_INFORMATION& lpProcessInformation);
    public static bool CreateProcessAsUser(IntPtr hToken, string lpApplicationName, string lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, bool bInheritHandles, CreateProcessFlags dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, STARTUPINFO& lpStartupInfo, PROCESS_INFORMATION& lpProcessInformation);
    public static bool CreateProcessAsUser(IntPtr hToken, string lpApplicationName, string lpCommandLine, Nullable`1<SECURITY_ATTRIBUTES> lpProcessAttributes, Nullable`1<SECURITY_ATTRIBUTES> lpThreadAttributes, bool bInheritHandles, CreateProcessFlags dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, STARTUPINFO& lpStartupInfo, PROCESS_INFORMATION& lpProcessInformation);
    public static bool CreateProcessAsUser(IntPtr hToken, string lpApplicationName, string lpCommandLine, Nullable`1<SECURITY_ATTRIBUTES> lpProcessAttributes, Nullable`1<SECURITY_ATTRIBUTES> lpThreadAttributes, bool bInheritHandles, CreateProcessFlags dwCreationFlags, Void* lpEnvironment, string lpCurrentDirectory, STARTUPINFO& lpStartupInfo, PROCESS_INFORMATION& lpProcessInformation);
    public static void GetStartupInfo(IntPtr lpStartupInfo);
    public static void GetStartupInfo(STARTUPINFO& lpStartupInfo);
    public static bool InitializeProcThreadAttributeList(IntPtr lpAttributeList, int dwAttributeCount, UInt32 dwFlags, IntPtr& lpSize);
    public static bool UpdateProcThreadAttribute(IntPtr lpAttributeList, UInt32 dwFlags, UInt32& Attribute, IntPtr lpValue, IntPtr cbSize, IntPtr& lpPreviousValue, IntPtr& lpReturnSize);
    public static void DeleteProcThreadAttributeList(IntPtr lpAttributeList);
    public static SafeObjectHandle CreateFile(IntPtr filename, ACCESS_MASK access, FileShare share, IntPtr securityAttributes, CreationDisposition creationDisposition, CreateFileFlags flagsAndAttributes, SafeObjectHandle templateFile);
    public static SafeObjectHandle CreateFile(ReadOnlySpan`1<char> filename, ACCESS_MASK access, FileShare share, Nullable`1<SECURITY_ATTRIBUTES> securityAttributes, CreationDisposition creationDisposition, CreateFileFlags flagsAndAttributes, SafeObjectHandle templateFile);
    public static SafeObjectHandle CreateFile(Char[] filename, ACCESS_MASK access, FileShare share, Nullable`1<SECURITY_ATTRIBUTES> securityAttributes, CreationDisposition creationDisposition, CreateFileFlags flagsAndAttributes, SafeObjectHandle templateFile);
    public static bool Process32First(SafeObjectHandle hSnapshot, IntPtr lppe);
    public static bool Process32First(SafeObjectHandle hSnapshot, PROCESSENTRY32& lppe);
    public static bool Process32Next(SafeObjectHandle hSnapshot, IntPtr lppe);
    public static bool Process32Next(SafeObjectHandle hSnapshot, PROCESSENTRY32& lppe);
    public static bool Module32First(SafeObjectHandle hSnapshot, IntPtr lpme);
    public static bool Module32First(SafeObjectHandle hSnapshot, MODULEENTRY32& lpme);
    public static bool Module32Next(SafeObjectHandle hSnapshot, IntPtr lpme);
    public static bool Module32Next(SafeObjectHandle hSnapshot, MODULEENTRY32& lpme);
    public static bool QueryFullProcessImageName(SafeObjectHandle hProcess, QueryFullProcessImageNameFlags dwFlags, IntPtr lpExeName, Int32& lpdwSize);
    public static bool QueryFullProcessImageName(SafeObjectHandle hProcess, QueryFullProcessImageNameFlags dwFlags, Span`1<char> lpExeName, int lpdwSize);
    public static bool QueryFullProcessImageName(SafeObjectHandle hProcess, QueryFullProcessImageNameFlags dwFlags, Char[] lpExeName, Int32& lpdwSize);
    public static bool GetOverlappedResult(SafeObjectHandle hFile, IntPtr lpOverlapped, Int32& lpNumberOfBytesTransferred, bool bWait);
    public static bool CreatePipe(SafeObjectHandle& hReadPipe, SafeObjectHandle& hWritePipe, IntPtr lpPipeAttributes, int nSize);
    public static bool CreatePipe(SafeObjectHandle& hReadPipe, SafeObjectHandle& hWritePipe, Nullable`1<SECURITY_ATTRIBUTES> lpPipeAttributes, int nSize);
    public static bool GetDllDirectory(int nBufferLength, IntPtr lpBuffer);
    public static bool GetDllDirectory(Span`1<char> lpBuffer);
    public static bool GetDllDirectory(int nBufferLength, Char[] lpBuffer);
    public static SafeObjectHandle CreateNamedPipe(string lpName, PipeAccessMode dwOpenMode, PipeMode dwPipeMode, int nMaxInstances, int nOutBufferSize, int nInBufferSize, int nDefaultTimeOut, IntPtr lpSecurityAttributes);
    public static SafeObjectHandle CreateNamedPipe(string lpName, PipeAccessMode dwOpenMode, PipeMode dwPipeMode, int nMaxInstances, int nOutBufferSize, int nInBufferSize, int nDefaultTimeOut, Nullable`1<SECURITY_ATTRIBUTES> lpSecurityAttributes);
    public static bool ConnectNamedPipe(SafeObjectHandle hNamedPipe, IntPtr lpOverlapped);
    public static bool CallNamedPipe(string lpNamedPipeName, IntPtr lpInBuffer, int nInBufferSize, IntPtr lpOutBuffer, int nOutBufferSize, Int32& lpBytesRead, int nTimeOut);
    public static bool GetNamedPipeClientComputerName(SafeObjectHandle Pipe, IntPtr ClientComputerName, int ClientComputerNameLength);
    public static bool GetNamedPipeClientComputerName(SafeObjectHandle Pipe, Span`1<char> ClientComputerName);
    public static bool GetNamedPipeClientComputerName(SafeObjectHandle Pipe, Char[] ClientComputerName, int ClientComputerNameLength);
    public static bool GetNamedPipeHandleState(SafeObjectHandle hNamedPipe, PipeMode& lpState, IntPtr lpCurInstances, IntPtr lpMaxCollectionCount, IntPtr lpCollectDataTimeout, StringBuilder lpUserName, int nMaxUserNameSize);
    public static bool GetNamedPipeHandleState(SafeObjectHandle hNamedPipe, PipeMode& lpState, Nullable`1& lpCurInstances, Nullable`1& lpMaxCollectionCount, Nullable`1& lpCollectDataTimeout, StringBuilder lpUserName, int nMaxUserNameSize);
    public static bool GetNamedPipeHandleState(SafeObjectHandle hNamedPipe, PipeMode& lpState, IntPtr lpCurInstances, IntPtr lpMaxCollectionCount, IntPtr lpCollectDataTimeout, IntPtr lpUserName, int nMaxUserNameSize);
    public static bool GetNamedPipeHandleState(SafeObjectHandle hNamedPipe, PipeMode& lpState, Nullable`1& lpCurInstances, Nullable`1& lpMaxCollectionCount, Nullable`1& lpCollectDataTimeout, Span`1<char> lpUserName);
    public static bool GetNamedPipeHandleState(SafeObjectHandle hNamedPipe, PipeMode& lpState, Nullable`1& lpCurInstances, Nullable`1& lpMaxCollectionCount, Nullable`1& lpCollectDataTimeout, Char[] lpUserName, int nMaxUserNameSize);
    public static bool PeekNamedPipe(SafeObjectHandle hNamedPipe, IntPtr lpBuffer, int nBufferSize, Int32& lpBytesRead, Int32& lpTotalBytesAvail, Int32& lpBytesLeftThisMessage);
    public static bool SetNamedPipeHandleState(SafeObjectHandle hNamedPipe, IntPtr lpMode, IntPtr lpMaxCollectionCount, IntPtr lpCollectDataTimeout);
    public static bool SetNamedPipeHandleState(SafeObjectHandle hNamedPipe, Nullable`1<PipeMode> lpMode, Nullable`1<int> lpMaxCollectionCount, Nullable`1<int> lpCollectDataTimeout);
    public static bool TransactNamedPipe(SafeObjectHandle hNamedPipe, IntPtr lpInBuffer, int nInBufferSize, IntPtr lpOutBuffer, int nOutBufferSize, Int32& lpBytesRead, IntPtr lpOverlapped);
    public static IntPtr LocalAlloc_IntPtr(LocalAllocFlags uFlags, IntPtr uBytes);
    public static IntPtr LocalReAlloc(IntPtr hMem, IntPtr uBytes, LocalReAllocFlags uFlags);
    public static IntPtr LocalFree(IntPtr hMem);
    public static IntPtr LocalLock(IntPtr hMem);
    public static bool LocalUnlock(IntPtr hMem);
    public static IntPtr GlobalAlloc_IntPtr(GlobalAllocFlags uFlags, IntPtr uBytes);
    public static IntPtr GlobalReAlloc(IntPtr hMem, IntPtr uBytes, GlobalReAllocFlags uFlags);
    public static IntPtr GlobalFree(IntPtr hMem);
    public static IntPtr GlobalLock(IntPtr hMem);
    public static bool GlobalUnlock(IntPtr hMem);
    public static IntPtr HeapAlloc_IntPtr(IntPtr hHeap, HeapAllocFlags uFlags, IntPtr uBytes);
    public static IntPtr HeapReAlloc(IntPtr hHeap, HeapReAllocFlags uFlags, IntPtr hMem, IntPtr uBytes);
    public static bool HeapFree(IntPtr hHeap, HeapFreeFlags dwFlags, IntPtr hMem);
    public static void CopyMemory(IntPtr Destination, IntPtr Source, IntPtr Length);
    public static void MoveMemory(IntPtr Destination, IntPtr Source, IntPtr Length);
    public static bool EnumResourceNames(SafeLibraryHandle hModule, IntPtr lpszType, EnumResNameProc lpEnumFunc, IntPtr lParam);
    public static bool EnumResourceNames(SafeLibraryHandle hModule, ReadOnlySpan`1<char> lpszType, EnumResNameProc lpEnumFunc, IntPtr lParam);
    public static bool EnumResourceNames(SafeLibraryHandle hModule, Char[] lpszType, EnumResNameProc lpEnumFunc, IntPtr lParam);
    public static bool EnumResourceLanguages(SafeLibraryHandle hModule, IntPtr lpType, IntPtr lpName, EnumResLangProc lpEnumFunc, IntPtr lParam);
    public static bool EnumResourceLanguages(SafeLibraryHandle hModule, ReadOnlySpan`1<char> lpType, ReadOnlySpan`1<char> lpName, EnumResLangProc lpEnumFunc, IntPtr lParam);
    public static bool EnumResourceLanguages(SafeLibraryHandle hModule, Char[] lpType, Char[] lpName, EnumResLangProc lpEnumFunc, IntPtr lParam);
    public static bool EnumResourceLanguages(SafeLibraryHandle hModule, ReadOnlySpan`1<char> lpType, ReadOnlySpan`1<char> lpName, EnumResLangProc lpEnumFunc, Void* lParam);
    public static bool EnumResourceLanguages(SafeLibraryHandle hModule, Char[] lpType, Char[] lpName, EnumResLangProc lpEnumFunc, Void* lParam);
    public static bool IS_INTRESOURCE(IntPtr p);
    public static IntPtr MAKEINTRESOURCE_IntPtr(int wInteger);
    public static IntPtr FindResource(SafeLibraryHandle hModule, IntPtr lpName, IntPtr lpType);
    public static IntPtr FindResource(SafeLibraryHandle hModule, ReadOnlySpan`1<char> lpName, ReadOnlySpan`1<char> lpType);
    public static IntPtr FindResource(SafeLibraryHandle hModule, Char[] lpName, Char[] lpType);
    public static SafeObjectHandle CreateJobObject(IntPtr lpJobAttributes, string lpName);
    public static bool SetInformationJobObject(SafeObjectHandle hJob, JOBOBJECTINFOCLASS jobObjectInfoClass, IntPtr lpJobObjectInfo, UInt32 cbJobObjectInfoLength);
    public static IntPtr CreateConsoleScreenBuffer(ACCESS_MASK dwDesiredAccess, FileShare dwShareMode, IntPtr lpSecurityAttributes, ConsoleScreenBufferFlag dwFlags, IntPtr lpScreenBufferData);
    public static IntPtr CreateConsoleScreenBuffer(ACCESS_MASK dwDesiredAccess, FileShare dwShareMode, Nullable`1<SECURITY_ATTRIBUTES> lpSecurityAttributes, ConsoleScreenBufferFlag dwFlags, IntPtr lpScreenBufferData);
    public static IntPtr CreateConsoleScreenBuffer(ACCESS_MASK dwDesiredAccess, FileShare dwShareMode, Nullable`1<SECURITY_ATTRIBUTES> lpSecurityAttributes, ConsoleScreenBufferFlag dwFlags, Void* lpScreenBufferData);
    public static int GetConsoleAliases(IntPtr lpAliasBuffer, int AliasBufferLength, string lpExeName);
    public static int GetConsoleAliases(Span`1<char> lpAliasBuffer, string lpExeName);
    public static int GetConsoleAliases(Char[] lpAliasBuffer, int AliasBufferLength, string lpExeName);
    public static int GetConsoleAliasExes(IntPtr lpExeNameBuffer, int ExeNameBufferLength);
    public static int GetConsoleAliasExes(Span`1<char> lpExeNameBuffer);
    public static int GetConsoleAliasExes(Char[] lpExeNameBuffer, int ExeNameBufferLength);
    public static int GetConsoleAlias(string lpSource, IntPtr lpTargetBuffer, int TargetBufferLength, string lpExeName);
    public static int GetConsoleAlias(string lpSource, Span`1<char> lpTargetBuffer, string lpExeName);
    public static int GetConsoleAlias(string lpSource, Char[] lpTargetBuffer, int TargetBufferLength, string lpExeName);
    public static int GetConsoleProcessList(IntPtr lpdwProcessList, int dwProcessCount);
    public static int GetConsoleProcessList(Span`1<UInt32> lpdwProcessList, int dwProcessCount);
    public static int GetConsoleProcessList(UInt32[] lpdwProcessList, int dwProcessCount);
    public static bool GetConsoleScreenBufferInfo(IntPtr hConsoleOutput, IntPtr lpConsoleScreenBufferInfo);
    public static bool GetConsoleScreenBufferInfo(IntPtr hConsoleOutput, CONSOLE_SCREEN_BUFFER_INFO& lpConsoleScreenBufferInfo);
    public static bool GetConsoleSelectionInfo(IntPtr lpConsoleSelectionInfo);
    public static bool GetConsoleSelectionInfo(CONSOLE_SELECTION_INFO& lpConsoleSelectionInfo);
    public static int GetConsoleTitle(IntPtr lpConsoleTitle, int nSize);
    public static int GetConsoleTitle(Span`1<char> lpConsoleTitle);
    public static int GetConsoleTitle(Char[] lpConsoleTitle, int nSize);
    public static bool ReadConsoleOutput(IntPtr hConsoleOutput, IntPtr lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, SMALL_RECT& lpReadRegion);
    public static bool ReadConsoleOutput(IntPtr hConsoleOutput, Span`1<CHAR_INFO> lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, SMALL_RECT& lpReadRegion);
    public static bool ReadConsoleOutput(IntPtr hConsoleOutput, CHAR_INFO[] lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, SMALL_RECT& lpReadRegion);
    public static bool ReadConsole(IntPtr hConsoleInput, IntPtr lpBuffer, int nNumberOfCharsToRead, Int32& lpNumberOfCharsRead, IntPtr pInputControl);
    public static bool ReadConsole(IntPtr hConsoleInput, Span`1<char> lpBuffer, Int32& lpNumberOfCharsRead, Nullable`1<CONSOLE_READCONSOLE_CONTROL> pInputControl);
    public static bool ReadConsole(IntPtr hConsoleInput, Char[] lpBuffer, int nNumberOfCharsToRead, Int32& lpNumberOfCharsRead, Nullable`1<CONSOLE_READCONSOLE_CONTROL> pInputControl);
    public static bool ScrollConsoleScreenBuffer(IntPtr hConsoleOutput, IntPtr lpScrollRectangle, IntPtr lpClipRectangle, COORD dwDestinationOrigin, IntPtr lpFill);
    public static bool ScrollConsoleScreenBuffer(IntPtr hConsoleOutput, SMALL_RECT lpScrollRectangle, Nullable`1<SMALL_RECT> lpClipRectangle, COORD dwDestinationOrigin, CHAR_INFO lpFill);
    public static bool WriteConsole(IntPtr hConsoleOutput, IntPtr lpBuffer, int nNumberOfCharsToWrite, IntPtr lpNumberOfCharsWritten, IntPtr lpReserved);
    public static bool WriteConsole(IntPtr hConsoleOutput, IntPtr lpBuffer, int nNumberOfCharsToWrite, Int32& lpNumberOfCharsWritten, IntPtr lpReserved);
    public static bool WriteConsole(IntPtr hConsoleOutput, Void* lpBuffer, int nNumberOfCharsToWrite, Int32& lpNumberOfCharsWritten, IntPtr lpReserved);
    public static bool WriteConsoleOutput(IntPtr hConsoleOutput, IntPtr lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, IntPtr lpWriteRegion);
    public static bool WriteConsoleOutput(IntPtr hConsoleOutput, CHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, SMALL_RECT& lpWriteRegion);
    public static bool WriteConsoleInput(IntPtr hConsoleInput, IntPtr lpBuffer, int nLength, IntPtr lpNumberOfEventsWritten);
    public static bool WriteConsoleInput(IntPtr hConsoleInput, INPUT_RECORD lpBuffer, int nLength, Int32& lpNumberOfEventsWritten);
    public static bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, IntPtr lpBuffer, UIntPtr nSize, UIntPtr& lpNumberOfBytesWritten);
    [ObsoleteAttribute("Use ReadProcessMemory(SafeObjectHandle, ...) instead")]
public static bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, IntPtr lpBuffer, UIntPtr nSize, UIntPtr& lpNumberOfBytesRead);
    public static bool ReadProcessMemory(SafeObjectHandle hProcess, IntPtr lpBaseAddress, IntPtr lpBuffer, UIntPtr nSize, UIntPtr& lpNumberOfBytesRead);
    public static IntPtr LockResource_IntPtr(IntPtr hResData);
    public static bool SetSystemTime(IntPtr lpSystemTime);
    public static bool SetSystemTime(SYSTEMTIME lpSystemTime);
    public static bool GetHandleInformation(SafeHandle hObject, IntPtr lpdwFlags);
    public static bool GetHandleInformation(SafeHandle hObject, HandleFlags& lpdwFlags);
    public static SafeObjectHandle CreateThread(IntPtr lpThreadAttributes, UIntPtr dwStackSize, THREAD_START_ROUTINE lpStartAddress, IntPtr lpParameter, CreateThreadFlags dwCreationFlags, IntPtr lpThreadId);
    public static SafeObjectHandle CreateThread(Nullable`1<SECURITY_ATTRIBUTES> lpThreadAttributes, UIntPtr dwStackSize, THREAD_START_ROUTINE lpStartAddress, IntPtr lpParameter, CreateThreadFlags dwCreationFlags, Nullable`1& lpThreadId);
    public static SafeObjectHandle CreateThread(Nullable`1<SECURITY_ATTRIBUTES> lpThreadAttributes, UIntPtr dwStackSize, THREAD_START_ROUTINE lpStartAddress, Void* lpParameter, CreateThreadFlags dwCreationFlags, Nullable`1& lpThreadId);
    public static SafeObjectHandle CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, UIntPtr dwStackSize, THREAD_START_ROUTINE lpStartAddress, IntPtr lpParameter, CreateThreadFlags dwCreationFlags, IntPtr lpThreadId);
    public static SafeObjectHandle CreateRemoteThread(IntPtr hProcess, Nullable`1<SECURITY_ATTRIBUTES> lpThreadAttributes, UIntPtr dwStackSize, THREAD_START_ROUTINE lpStartAddress, IntPtr lpParameter, CreateThreadFlags dwCreationFlags, Nullable`1& lpThreadId);
    public static SafeObjectHandle CreateRemoteThread(IntPtr hProcess, Nullable`1<SECURITY_ATTRIBUTES> lpThreadAttributes, UIntPtr dwStackSize, THREAD_START_ROUTINE lpStartAddress, Void* lpParameter, CreateThreadFlags dwCreationFlags, Nullable`1& lpThreadId);
    public static SafeObjectHandle CreateRemoteThreadEx(IntPtr hProcess, IntPtr lpThreadAttributes, UIntPtr dwStackSize, THREAD_START_ROUTINE lpStartAddress, IntPtr lpParameter, CreateThreadFlags dwCreationFlags, IntPtr lpAttributeList, IntPtr lpThreadId);
    public static SafeObjectHandle CreateRemoteThreadEx(IntPtr hProcess, SECURITY_ATTRIBUTES lpThreadAttributes, UIntPtr dwStackSize, THREAD_START_ROUTINE lpStartAddress, IntPtr lpParameter, CreateThreadFlags dwCreationFlags, IntPtr lpAttributeList, Nullable`1& lpThreadId);
    public static SafeObjectHandle CreateRemoteThreadEx(IntPtr hProcess, SECURITY_ATTRIBUTES lpThreadAttributes, UIntPtr dwStackSize, THREAD_START_ROUTINE lpStartAddress, Void* lpParameter, CreateThreadFlags dwCreationFlags, PROC_THREAD_ATTRIBUTE_LIST* lpAttributeList, Nullable`1& lpThreadId);
    public static bool DosDateTimeToFileTime(ushort wFatDate, ushort wFatTime, IntPtr lpFileTime);
    public static bool DosDateTimeToFileTime(ushort wFatDate, ushort wFatTime, FILETIME& lpFileTime);
    public static SafeObjectHandle CreateFile(string filename, ACCESS_MASK access, FileShare share, IntPtr securityAttributes, CreationDisposition creationDisposition, CreateFileFlags flagsAndAttributes, SafeObjectHandle templateFile);
    public static SafeObjectHandle CreateFile(string filename, ACCESS_MASK access, FileShare share, Nullable`1<SECURITY_ATTRIBUTES> securityAttributes, CreationDisposition creationDisposition, CreateFileFlags flagsAndAttributes, SafeObjectHandle templateFile);
    public static IntPtr LocalAlloc_IntPtr(LocalAllocFlags uFlags, int uBytes);
    public static IntPtr LocalReAlloc(IntPtr hMem, int uBytes, LocalReAllocFlags uFlags);
}
[ExtensionAttribute]
public static class PInvoke.Kernel32Extensions : object {
    private static int MaxAllowedBufferSize;
    [ExtensionAttribute]
public static string GetMessage(Win32ErrorCode error);
    [ExtensionAttribute]
public static void ThrowOnError(Win32ErrorCode errorCode);
    [ExtensionAttribute]
public static void ThrowOnError(NTSTATUS status);
    [ExtensionAttribute]
public static string GetMessage(NTSTATUS status);
}
public class PInvoke.NTStatusException : Exception {
    [CompilerGeneratedAttribute]
private NTSTATUS <NativeErrorCode>k__BackingField;
    public NTSTATUS NativeErrorCode { get; }
    public NTStatusException(NTSTATUS statusCode);
    public NTStatusException(NTSTATUS statusCode, string message);
    public NTStatusException(NTSTATUS statusCode, string message, Exception inner);
    protected NTStatusException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public NTSTATUS get_NativeErrorCode();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private static string GetMessage(NTSTATUS status);
    private static string GetSeverityString(NTSTATUS status);
}
public class PInvoke.Win32Exception : Win32Exception {
    public Win32ErrorCode NativeErrorCode { get; }
    public Win32Exception(Win32ErrorCode error);
    public Win32Exception(int error);
    public Win32Exception(Win32ErrorCode error, string message);
    protected Win32Exception(SerializationInfo info, StreamingContext context);
    public Win32ErrorCode get_NativeErrorCode();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.5.54.9013")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
    private static ThisAssembly();
}
