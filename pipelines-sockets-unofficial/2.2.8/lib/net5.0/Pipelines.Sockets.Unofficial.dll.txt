[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public abstract class Pipelines.Sockets.Unofficial.Arenas.Allocator`1 : object {
    internal bool IsPinned { get; }
    internal bool IsUnmanaged { get; }
    public abstract virtual IMemoryOwner`1<T> Allocate(int length);
    public virtual void Clear(IMemoryOwner`1<T> allocation, int length);
    internal virtual bool get_IsPinned();
    internal virtual bool get_IsUnmanaged();
}
public class Pipelines.Sockets.Unofficial.Arenas.AllocatorFactory : object {
    [CompilerGeneratedAttribute]
private static AllocatorFactory <Default>k__BackingField;
    public static AllocatorFactory Default { get; }
    private static AllocatorFactory();
    [CompilerGeneratedAttribute]
public static AllocatorFactory get_Default();
    protected internal virtual Allocator`1<T> SuggestAllocator(ArenaOptions options);
    protected internal virtual Allocator`1<T> SuggestBlittableAllocator(ArenaOptions options);
    protected internal virtual int SuggestBlockSizeBytes(ArenaOptions options);
}
public class Pipelines.Sockets.Unofficial.Arenas.Arena : object {
    [CompilerGeneratedAttribute]
private ArenaOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private AllocatorFactory <Factory>k__BackingField;
    private IArena _lastArena;
    private Dictionary`2<int, IArena> _blittableBySize;
    private Dictionary`2<Type, IArena> _ownedArenas;
    internal ArenaOptions Options { get; }
    internal AllocatorFactory Factory { get; private set; }
    public Arena(ArenaOptions options, AllocatorFactory factory);
    [CompilerGeneratedAttribute]
internal ArenaOptions get_Options();
    [CompilerGeneratedAttribute]
internal AllocatorFactory get_Factory();
    [CompilerGeneratedAttribute]
private void set_Factory(AllocatorFactory value);
    public sealed virtual void Dispose();
    public void Reset();
    public Reference`1<T> Allocate();
    public Sequence`1<T> Allocate(int length);
    public Sequence`1<T> Allocate(IEnumerable`1<T> source);
    public OwnedArena`1<T> GetArena();
    private OwnedArena`1<T> CreateAndAddArena();
    internal object GetAllocator();
    internal static Sequence`1<T> Allocate(IArena`1<T> arena, IEnumerable`1<T> source);
    private static Sequence`1<T> SlowAllocate(IArena`1<T> arena, IEnumerable`1<T> source);
    internal long AllocatedBytes();
    [CompilerGeneratedAttribute]
private OwnedArena`1<T> <CreateAndAddArena>g__Create|17_0();
}
public class Pipelines.Sockets.Unofficial.Arenas.Arena`1 : object {
    private ArenaFlags _flags;
    private int _blockSize;
    private int _allocatedCurrentBlock;
    private Block`1<T> _first;
    private Block`1<T> __current;
    private object _currentStartObj;
    private int _currentArrayFlag;
    private Allocator`1<T> _allocator;
    private Func`3<long, long, long> _retentionPolicy;
    private long _lastRetentionBytes;
    private Type Pipelines.Sockets.Unofficial.Arenas.IArena.ElementType { get; }
    internal Block`1<T> CurrentBlock { get; private set; }
    internal int AllocatedCurrentBlock { get; }
    internal Block`1<T> FirstBlock { get; }
    internal int RemainingCurrentBlock { get; }
    private bool ClearAtReset { get; }
    private bool ClearAtDispose { get; }
    public Arena`1(ArenaOptions options, Allocator`1<T> allocator);
    internal Arena`1(ArenaOptions options, Allocator`1<T> allocator, int blockSizeBytes);
    private sealed virtual override Type Pipelines.Sockets.Unofficial.Arenas.IArena.get_ElementType();
    private sealed virtual override OwnedArena`1<TTo> Pipelines.Sockets.Unofficial.Arenas.IArena.CreateNonPadded(Arena parent);
    private sealed virtual override long Pipelines.Sockets.Unofficial.Arenas.IArena.AllocatedBytes();
    internal long AllocatedBytes();
    private void ThrowDisposed();
    internal long CapacityBytes();
    internal Block`1<T> get_CurrentBlock();
    private void set_CurrentBlock(Block`1<T> value);
    private Block`1<T> AllocateAndAttachBlock(Block`1<T> previous);
    public sealed virtual Sequence`1<T> Allocate(int length);
    public Sequence`1<T> Allocate(long length);
    public Sequence`1<T> Allocate(IEnumerable`1<T> source);
    private sealed virtual override SequencePosition Pipelines.Sockets.Unofficial.Arenas.IArena.GetPosition();
    internal SequencePosition GetPosition();
    private sealed virtual override Sequence`1<T> Pipelines.Sockets.Unofficial.Arenas.IArena<T>.AllocateRetainingSegmentData(int length);
    internal Sequence`1<T> AllocateRetainingSegmentData(int length);
    internal object GetAllocator();
    internal int get_AllocatedCurrentBlock();
    internal Block`1<T> get_FirstBlock();
    internal int get_RemainingCurrentBlock();
    internal void SkipToNextPage();
    public Reference`1<T> Allocate();
    private Sequence`1<T> SlowAllocate(long length);
    private bool get_ClearAtReset();
    private bool get_ClearAtDispose();
    public sealed virtual void Reset();
    private void ClearAllocatedSpace();
    private void Trim(long retain);
    private void ReleaseChain(Block`1<T> block, bool wipeBlocks);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <SlowAllocate>g__MoveNextBlock|39_0();
}
[FlagsAttribute]
public enum Pipelines.Sockets.Unofficial.Arenas.ArenaFlags : Enum {
    public int value__;
    public static ArenaFlags None;
    public static ArenaFlags ClearAtReset;
    public static ArenaFlags ClearAtDispose;
    public static ArenaFlags PreferUnmanaged;
    public static ArenaFlags PreferPinned;
    public static ArenaFlags BlittableNonPaddedSharing;
    public static ArenaFlags BlittablePaddedSharing;
}
public class Pipelines.Sockets.Unofficial.Arenas.ArenaOptions : object {
    [CompilerGeneratedAttribute]
private static ArenaOptions <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private ArenaFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BlockSizeBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<long, long, long> <RetentionPolicy>k__BackingField;
    private static ArenaFlags DefaultFlags;
    public static ArenaOptions Default { get; }
    public ArenaFlags Flags { get; }
    public int BlockSizeBytes { get; }
    public Func`3<long, long, long> RetentionPolicy { get; }
    public ArenaOptions(ArenaFlags flags, int blockSizeBytes, Func`3<long, long, long> retentionPolicy);
    private static ArenaOptions();
    [CompilerGeneratedAttribute]
public static ArenaOptions get_Default();
    [CompilerGeneratedAttribute]
public ArenaFlags get_Flags();
    internal bool HasFlag(ArenaFlags flag);
    [CompilerGeneratedAttribute]
public int get_BlockSizeBytes();
    [CompilerGeneratedAttribute]
public Func`3<long, long, long> get_RetentionPolicy();
}
public class Pipelines.Sockets.Unofficial.Arenas.ArrayPoolAllocator`1 : Allocator`1<T> {
    private ArrayPool`1<T> _pool;
    [CompilerGeneratedAttribute]
private static ArrayPoolAllocator`1<T> <Shared>k__BackingField;
    public static ArrayPoolAllocator`1<T> Shared { get; }
    public ArrayPoolAllocator`1(ArrayPool`1<T> pool);
    private static ArrayPoolAllocator`1();
    [CompilerGeneratedAttribute]
public static ArrayPoolAllocator`1<T> get_Shared();
    public virtual IMemoryOwner`1<T> Allocate(int length);
}
internal class Pipelines.Sockets.Unofficial.Arenas.Block`1 : SequenceSegment`1<T> {
    private Void* _origin;
    [CompilerGeneratedAttribute]
private int <SegmentIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<T> <Allocation>k__BackingField;
    private Void* Pipelines.Sockets.Unofficial.Arenas.IPinnedMemoryOwner<T>.Origin { get; }
    internal int SegmentIndex { get; }
    public IMemoryOwner`1<T> Allocation { get; private set; }
    public Block`1<T> Next { get; }
    public Block`1(IMemoryOwner`1<T> allocation, int segmentIndex, Block`1<T> previous);
    private sealed virtual override Void* Pipelines.Sockets.Unofficial.Arenas.IPinnedMemoryOwner<T>.get_Origin();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal int get_SegmentIndex();
    protected virtual int GetSegmentIndex();
    [CompilerGeneratedAttribute]
public IMemoryOwner`1<T> get_Allocation();
    [CompilerGeneratedAttribute]
private void set_Allocation(IMemoryOwner`1<T> value);
    public Block`1<T> get_Next();
    public sealed virtual void Dispose();
    internal Block`1<T> DetachNext();
}
internal interface Pipelines.Sockets.Unofficial.Arenas.IArena {
    public Type ElementType { get; }
    public abstract virtual void Reset();
    public abstract virtual Type get_ElementType();
    public abstract virtual SequencePosition GetPosition();
    public abstract virtual long AllocatedBytes();
    public abstract virtual OwnedArena`1<T> CreateNonPadded(Arena arena);
}
internal interface Pipelines.Sockets.Unofficial.Arenas.IArena`1 {
    public abstract virtual Sequence`1<T> Allocate(int length);
    public abstract virtual Sequence`1<T> AllocateRetainingSegmentData(int length);
}
[CLSCompliantAttribute("False")]
public interface Pipelines.Sockets.Unofficial.Arenas.IPinnedMemoryOwner`1 {
    public Void* Origin { get; }
    public int Length { get; }
    public abstract virtual Void* get_Origin();
    public abstract virtual int get_Length();
}
internal interface Pipelines.Sockets.Unofficial.Arenas.ISegment {
    public int ElementSize { get; }
    public int Index { get; }
    public Type ElementType { get; }
    public Type UnderlyingType { get; }
    public long RunningIndex { get; }
    public abstract virtual int get_ElementSize();
    public abstract virtual int get_Index();
    public abstract virtual Type get_ElementType();
    public abstract virtual Type get_UnderlyingType();
    public abstract virtual long get_RunningIndex();
}
internal abstract class Pipelines.Sockets.Unofficial.Arenas.MappedBlittableOwnedArena`2 : OwnedArena`1<TTo> {
    protected Arena`1<TFrom> _arena;
    private List`1<MappedSegment`2<TFrom, TTo>> _mappedSegments;
    protected MappedBlittableOwnedArena`2(Arena parent);
    internal virtual long AllocatedBytes();
    internal virtual void Reset();
    internal virtual void Dispose();
    internal virtual object GetAllocator();
    internal virtual SequencePosition GetPosition();
    internal virtual Sequence`1<TTo> AllocateRetainingSegmentData(int length);
    protected MappedSegment`2<TFrom, TTo> MapBlock(int index);
    private MappedSegment`2<TFrom, TTo> MapTo(int index);
}
internal class Pipelines.Sockets.Unofficial.Arenas.NonPaddedBlittableOwnedArena`2 : MappedBlittableOwnedArena`2<TFrom, TTo> {
    public NonPaddedBlittableOwnedArena`2(Arena parent);
    public virtual Sequence`1<TTo> Allocate(int length);
}
public abstract class Pipelines.Sockets.Unofficial.Arenas.OwnedArena`1 : object {
    private Type Pipelines.Sockets.Unofficial.Arenas.IArena.ElementType { get; }
    private sealed virtual override Type Pipelines.Sockets.Unofficial.Arenas.IArena.get_ElementType();
    private sealed virtual override OwnedArena`1<TTo> Pipelines.Sockets.Unofficial.Arenas.IArena.CreateNonPadded(Arena parent);
    public abstract virtual Sequence`1<T> Allocate(int length);
    public Reference`1<T> Allocate();
    public Sequence`1<T> Allocate(IEnumerable`1<T> source);
    private sealed virtual override SequencePosition Pipelines.Sockets.Unofficial.Arenas.IArena.GetPosition();
    internal abstract virtual SequencePosition GetPosition();
    private sealed virtual override long Pipelines.Sockets.Unofficial.Arenas.IArena.AllocatedBytes();
    internal abstract virtual long AllocatedBytes();
    private sealed virtual override Sequence`1<T> Pipelines.Sockets.Unofficial.Arenas.IArena<T>.AllocateRetainingSegmentData(int length);
    internal abstract virtual Sequence`1<T> AllocateRetainingSegmentData(int length);
    internal abstract virtual object GetAllocator();
    internal abstract virtual void Reset();
    internal abstract virtual void Dispose();
    private sealed virtual override void Pipelines.Sockets.Unofficial.Arenas.IArena.Reset();
    private sealed virtual override void System.IDisposable.Dispose();
}
internal class Pipelines.Sockets.Unofficial.Arenas.PaddedBlittableOwnedArena`1 : MappedBlittableOwnedArena`2<byte, T> {
    public PaddedBlittableOwnedArena`1(Arena parent);
    public virtual Sequence`1<T> Allocate(int length);
}
internal static class Pipelines.Sockets.Unofficial.Arenas.PerTypeHelpers : object {
    public static Span`1<TTo> Cast(Span`1<TFrom> span);
}
internal static class Pipelines.Sockets.Unofficial.Arenas.PerTypeHelpers`1 : object {
    private static Allocator`1<T> _preferUnmanaged;
    private static Allocator`1<T> _preferPinned;
    public static bool IsBlittable { get; }
    public static Allocator`1<T> PreferUnmanaged();
    public static Allocator`1<T> PreferPinned();
    public static bool get_IsBlittable();
    [CompilerGeneratedAttribute]
internal static Allocator`1<T> <PreferUnmanaged>g__Calculate|2_0();
    [CompilerGeneratedAttribute]
internal static Allocator`1<T> <PreferPinned>g__Calculate|3_0();
}
internal class Pipelines.Sockets.Unofficial.Arenas.PinnedArrayPoolAllocator`1 : Allocator`1<T> {
    private ArrayPool`1<T> _pool;
    [CompilerGeneratedAttribute]
private static PinnedArrayPoolAllocator`1<T> <Shared>k__BackingField;
    internal bool IsPinned { get; }
    public static PinnedArrayPoolAllocator`1<T> Shared { get; }
    public PinnedArrayPoolAllocator`1(ArrayPool`1<T> pool);
    private static PinnedArrayPoolAllocator`1();
    internal virtual bool get_IsPinned();
    [CompilerGeneratedAttribute]
public static PinnedArrayPoolAllocator`1<T> get_Shared();
    public virtual IMemoryOwner`1<T> Allocate(int length);
}
public class Pipelines.Sockets.Unofficial.Arenas.Projection`2 : MulticastDelegate {
    public Projection`2(object object, IntPtr method);
    public virtual TResult Invoke(T& modreq(System.Runtime.InteropServices.InAttribute) x);
    public virtual IAsyncResult BeginInvoke(T& modreq(System.Runtime.InteropServices.InAttribute) x, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(T& modreq(System.Runtime.InteropServices.InAttribute) x, IAsyncResult result);
}
public class Pipelines.Sockets.Unofficial.Arenas.Projection`3 : MulticastDelegate {
    public Projection`3(object object, IntPtr method);
    public virtual TResult Invoke(T1& modreq(System.Runtime.InteropServices.InAttribute) x1, T2& modreq(System.Runtime.InteropServices.InAttribute) x2);
    public virtual IAsyncResult BeginInvoke(T1& modreq(System.Runtime.InteropServices.InAttribute) x1, T2& modreq(System.Runtime.InteropServices.InAttribute) x2, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(T1& modreq(System.Runtime.InteropServices.InAttribute) x1, T2& modreq(System.Runtime.InteropServices.InAttribute) x2, IAsyncResult result);
}
[IsReadOnlyAttribute]
public class Pipelines.Sockets.Unofficial.Arenas.Reference`1 : ValueType {
    private object _obj;
    private int _offset;
    public T& Value { get; }
    public Reference`1(T[] array, int index);
    public Reference`1(Memory`1<T> memory, int index);
    internal Reference`1(int offset, object obj);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    [CLSCompliantAttribute("False")]
public bool Equals(Reference`1& other);
    private sealed virtual override bool System.IEquatable<Pipelines.Sockets.Unofficial.Arenas.Reference<T>>.Equals(Reference`1<T> other);
    public static bool op_Equality(Reference`1& x, Reference`1& y);
    public static bool op_Inequality(Reference`1& x, Reference`1& y);
    public virtual int GetHashCode();
    public T& get_Value();
    public static T op_Implicit(Reference`1& reference);
    [CompilerGeneratedAttribute]
internal static T& <get_Value>g__SlowValue|13_0(object obj, int offset);
}
public static class Pipelines.Sockets.Unofficial.Arenas.RetentionPolicy : object {
    private static float DefaultFactor;
    [CompilerGeneratedAttribute]
private static Func`3<long, long, long> <Default>k__BackingField;
    public static Func`3<long, long, long> Default { get; }
    public static Func`3<long, long, long> Recent { get; }
    public static Func`3<long, long, long> Nothing { get; }
    public static Func`3<long, long, long> Everything { get; }
    private static RetentionPolicy();
    [CompilerGeneratedAttribute]
public static Func`3<long, long, long> get_Default();
    public static Func`3<long, long, long> get_Recent();
    public static Func`3<long, long, long> get_Nothing();
    public static Func`3<long, long, long> get_Everything();
    public static Func`3<long, long, long> Decay(float factor);
}
[IsReadOnlyAttribute]
public class Pipelines.Sockets.Unofficial.Arenas.Sequence : ValueType {
    private object _startObj;
    private object _endObj;
    private int _startOffsetAndArrayFlag;
    private int _endOffsetOrLength;
    internal static int IsArrayFlag;
    public bool IsSingleSegment { get; }
    public long Length { get; }
    public bool IsEmpty { get; }
    public Type ElementType { get; }
    internal Sequence(object startObj, object endObj, int startOffsetAndArrayFlag, int endOffsetOrLength);
    public static Sequence Empty();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.IEquatable<Pipelines.Sockets.Unofficial.Arenas.Sequence>.Equals(Sequence other);
    [CLSCompliantAttribute("False")]
public bool Equals(Sequence& other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(Sequence& x, Sequence& y);
    public static bool op_Inequality(Sequence& x, Sequence& y);
    public bool get_IsSingleSegment();
    public long get_Length();
    private long MultiSegmentLength();
    public bool get_IsEmpty();
    public Type get_ElementType();
    public Sequence`1<T> Cast();
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class Pipelines.Sockets.Unofficial.Arenas.Sequence`1 : ValueType {
    private object _startObj;
    private object _endObj;
    private int __startOffsetAndArrayFlag;
    private int __endOffsetOrLength;
    public T& Item { get; }
    public T& Item { get; }
    public SequencePosition Start { get; }
    public SequencePosition End { get; }
    public T& Item { get; }
    public long Length { get; }
    private int SingleSegmentLength { get; }
    private int MultiSegmentEndOffset { get; }
    public bool IsSingleSegment { get; }
    internal bool IsArray { get; }
    internal bool IsPinned { get; }
    private int StartOffset { get; }
    public bool IsEmpty { get; }
    public Memory`1<T> FirstSegment { get; }
    public Span`1<T> FirstSpan { get; }
    public SpanEnumerable<T> Spans { get; }
    public MemoryEnumerable<T> Segments { get; }
    public Sequence`1(Memory`1<T> memory);
    public Sequence`1(T[] array);
    public Sequence`1(T[] array, int offset, int length);
    internal Sequence`1(SequenceSegment`1<T> startSegment, SequenceSegment`1<T> endSegment, int startOffset, int endOffset);
    internal Sequence`1(object startObj, object endObj, int startOffsetAndArrayFlag, int endOffsetOrLength);
    public static Sequence op_Implicit(Sequence`1& sequence);
    public static Sequence`1<T> op_Explicit(Sequence& sequence);
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.IEquatable<Pipelines.Sockets.Unofficial.Arenas.Sequence<T>>.Equals(Sequence`1<T> other);
    [CLSCompliantAttribute("False")]
public bool Equals(Sequence`1& other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(Sequence`1& x, Sequence`1& y);
    public static bool op_Inequality(Sequence`1& x, Sequence`1& y);
    public static ReadOnlySequence`1<T> op_Implicit(Sequence`1& sequence);
    public T& get_Item(int index);
    public T& get_Item(long index);
    public Reference`1<T> GetReference(long index);
    public static Sequence`1<T> op_Explicit(ReadOnlySequence`1& readOnlySequence);
    public Sequence Untyped();
    public ReadOnlySequence`1<T> AsReadOnly();
    private static SequencePosition NormalizePosition(object object, int integer);
    public SequencePosition get_Start();
    public SequencePosition get_End();
    public SequencePosition GetPosition(long offset);
    public bool TryGetArray(ArraySegment`1& segment);
    public Sequence`1<T> Slice(long start);
    public Sequence`1<T> Slice(long start, long length);
    public Sequence`1<T> Slice(Range range);
    public T& get_Item(Index index);
    private Sequence`1<T> SlowSlice(long start, long length, long seqLength);
    public static bool TryGetSequence(ReadOnlySequence`1& readOnlySequence, Sequence`1& sequence);
    public long get_Length();
    private int get_SingleSegmentLength();
    private int get_MultiSegmentEndOffset();
    public bool get_IsSingleSegment();
    internal bool get_IsArray();
    internal bool get_IsPinned();
    private int get_StartOffset();
    public bool get_IsEmpty();
    public Memory`1<T> get_FirstSegment();
    private Memory`1<T> SlowFirstSegment();
    public Span`1<T> get_FirstSpan();
    public void CopyTo(Span`1<T> destination);
    public bool TryCopyTo(Span`1<T> destination);
    private bool TrySlowCopy(Span`1<T> destination);
    private static int NormalizeForwards(SequenceSegment`1& segment, int offset);
    internal bool TryGetSegments(SequenceSegment`1& startSeq, SequenceSegment`1& endSeq, Int32& startOffset, Int32& endOffset);
    public SpanEnumerable<T> get_Spans();
    public MemoryEnumerable<T> get_Segments();
    public Enumerator<T> GetEnumerator();
    internal IEnumerator`1<T> GetObjectEnumerator();
    [IteratorStateMachineAttribute("Pipelines.Sockets.Unofficial.Arenas.Sequence`1/<GetArrayEnumerator>d__77")]
private static IEnumerator`1<T> GetArrayEnumerator(T[] array, int start, int end);
    [IteratorStateMachineAttribute("Pipelines.Sockets.Unofficial.Arenas.Sequence`1/<GetSingleSegmentEnumerator>d__78")]
private static IEnumerator`1<T> GetSingleSegmentEnumerator(Memory`1<T> memory);
    [IteratorStateMachineAttribute("Pipelines.Sockets.Unofficial.Arenas.Sequence`1/<GetMultiSegmentEnumerator>d__79")]
private IEnumerator`1<T> GetMultiSegmentEnumerator();
    [CompilerGeneratedAttribute]
internal static Reference`1<T> <GetReference>g__SlowGetReference|18_0(Sequence`1& sequence, long l_index);
    [CompilerGeneratedAttribute]
internal static ReadOnlySequence`1<T> <AsReadOnly>g__FromSegments|21_0(Sequence`1& sequence);
    [CompilerGeneratedAttribute]
internal static int <GetPosition>g__RemainingFirstSegmentLength|28_0(Sequence`1& sequence);
    [CompilerGeneratedAttribute]
internal static SequencePosition <GetPosition>g__SlowGetPosition|28_1(Sequence`1& sequence, long index);
    [CompilerGeneratedAttribute]
internal static long <get_Length>g__MultiSegmentLength|38_0(Sequence`1& sequence);
    [CompilerGeneratedAttribute]
internal static void <CopyTo>g__ThrowLengthError|58_0();
}
[ExtensionAttribute]
public static class Pipelines.Sockets.Unofficial.Arenas.SequenceExtensions : object {
    [ExtensionAttribute]
public static T[] ToArray(Sequence`1& source);
    [ExtensionAttribute]
public static Sequence`1<T> ToSequence(IEnumerable`1<T> source);
    private static Sequence`1<T> SlowToSequence(IEnumerable`1<T> source);
    [ExtensionAttribute]
internal static Span`1<T> GetSpan(IPinnedMemoryOwner`1<T> pinned);
    [ExtensionAttribute]
public static SequenceList`1<T> ToList(Sequence`1& source);
    [ExtensionAttribute]
public static TTo[] ToArray(Sequence`1& source, Projection`2<TFrom, TTo> projection);
    [ExtensionAttribute]
public static TTo[] ToArray(Sequence`1& source, Projection`3<TFrom, TState, TTo> projection, TState& state);
    [ExtensionAttribute]
public static void CopyTo(Sequence`1& source, Span`1<TTo> destination, Projection`2<TFrom, TTo> projection);
    [ExtensionAttribute]
public static void CopyTo(Sequence`1& source, Span`1<TTo> destination, Projection`3<TFrom, TState, TTo> projection, TState& state);
    [ExtensionAttribute]
public static void CopyTo(ReadOnlySpan`1<T> source, Sequence`1& destination);
    [ExtensionAttribute]
public static void CopyTo(Span`1<TFrom> source, Sequence`1& destination, Projection`2<TFrom, TTo> projection);
    [ExtensionAttribute]
public static void CopyTo(ReadOnlySpan`1<TFrom> source, Sequence`1& destination, Projection`3<TFrom, TState, TTo> projection, TState& state);
    [ExtensionAttribute]
public static void CopyTo(ReadOnlySpan`1<TFrom> source, Sequence`1& destination, Projection`2<TFrom, TTo> projection);
    [ExtensionAttribute]
public static void CopyTo(Span`1<TFrom> source, Sequence`1& destination, Projection`3<TFrom, TState, TTo> projection, TState& state);
    [ExtensionAttribute]
public static bool TryCopyTo(Sequence`1& source, Span`1<TTo> destination, Projection`2<TFrom, TTo> projection);
    [ExtensionAttribute]
public static bool TryCopyTo(Sequence`1& source, Span`1<TTo> destination, Projection`3<TFrom, TState, TTo> projection, TState& state);
    [ExtensionAttribute]
public static bool TryCopyTo(ReadOnlySpan`1<T> source, Sequence`1& destination);
    [ExtensionAttribute]
public static bool TryCopyTo(Span`1<TFrom> source, Sequence`1& destination, Projection`2<TFrom, TTo> projection);
    [ExtensionAttribute]
public static bool TryCopyTo(Span`1<TFrom> source, Sequence`1& destination, Projection`3<TFrom, TState, TTo> projection, TState& state);
    [ExtensionAttribute]
public static bool TryCopyTo(ReadOnlySpan`1<TFrom> source, Sequence`1& destination, Projection`2<TFrom, TTo> projection);
    [ExtensionAttribute]
public static bool TryCopyTo(ReadOnlySpan`1<TFrom> source, Sequence`1& destination, Projection`3<TFrom, TState, TTo> projection, TState& state);
    [ExtensionAttribute]
public static Sequence`1<TTo> Allocate(Arena`1<TTo> arena, Sequence`1& source, Projection`2<TFrom, TTo> projection);
    [ExtensionAttribute]
public static Sequence`1<TTo> Allocate(Arena`1<TTo> arena, Sequence`1& source, Projection`3<TFrom, TState, TTo> projection, TState& state);
    [ExtensionAttribute]
public static void CopyTo(Sequence`1& source, Sequence`1& destination);
    [ExtensionAttribute]
public static bool TryCopyTo(Sequence`1& source, Sequence`1& destination);
    private static void SlowCopyTo(Sequence`1& source, Sequence`1& destination);
    [ExtensionAttribute]
public static void CopyTo(ReadOnlySequence`1& source, Sequence`1& destination);
    [ExtensionAttribute]
public static bool TryCopyTo(ReadOnlySequence`1& source, Sequence`1& destination);
    private static void SlowCopyTo(ReadOnlySequence`1& source, Sequence`1& destination);
    [ExtensionAttribute]
public static void CopyTo(Sequence`1& source, Sequence`1& destination, Projection`2<TFrom, TTo> projection);
    [ExtensionAttribute]
public static bool TryCopyTo(Sequence`1& source, Sequence`1& destination, Projection`2<TFrom, TTo> projection);
    private static void SlowCopyTo(Sequence`1& source, Sequence`1& destination, Projection`2<TFrom, TTo> projection);
    [ExtensionAttribute]
public static void CopyTo(Sequence`1& source, Sequence`1& destination, Projection`3<TFrom, TState, TTo> projection, TState& state);
    [ExtensionAttribute]
public static bool TryCopyTo(Sequence`1& source, Sequence`1& destination, Projection`3<TFrom, TState, TTo> projection, TState& state);
    private static void SlowCopyTo(Sequence`1& source, Sequence`1& destination, Projection`3<TFrom, TState, TTo> projection, TState& state);
    [ExtensionAttribute]
internal static Nullable`1<long> TryGetOffset(SequencePosition& position);
    [ExtensionAttribute]
internal static string TryGetSummary(SequencePosition& position);
    [CompilerGeneratedAttribute]
internal static void <TryCopyTo>g__ThrowNoProjection|15_0();
    [CompilerGeneratedAttribute]
internal static void <TryCopyTo>g__ThrowNoProjection|16_0();
    [CompilerGeneratedAttribute]
internal static void <TryCopyTo>g__ThrowNoProjection|18_0();
    [CompilerGeneratedAttribute]
internal static void <TryCopyTo>g__ThrowNoProjection|19_0();
    [CompilerGeneratedAttribute]
internal static void <TryCopyTo>g__ThrowNoProjection|20_0();
    [CompilerGeneratedAttribute]
internal static void <TryCopyTo>g__ThrowNoProjection|21_0();
}
[DefaultMemberAttribute("Item")]
public class Pipelines.Sockets.Unofficial.Arenas.SequenceList`1 : object {
    private static SequenceList`1<T> s_empty;
    private Sequence`1<T> _sequence;
    public int Count { get; }
    public T& Item { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private int System.Collections.ICollection.Count { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.IList.Item { get; private set; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private T System.Collections.Generic.IReadOnlyList<T>.Item { get; }
    internal SequenceList`1(Sequence`1& sequence);
    private static SequenceList`1();
    internal static SequenceList`1<T> Create(Sequence`1& sequence);
    public sealed virtual int get_Count();
    public Enumerator<T> GetEnumerator();
    public T& get_Item(int index);
    public Sequence`1<T> ToSequence();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override T System.Collections.Generic.IReadOnlyList<T>.get_Item(int index);
    private int IndexOf(T item);
    private sealed virtual override int System.Collections.Generic.IList<T>.IndexOf(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T item);
    private void CopyTo(T[] array, int arrayIndex);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private IEnumerator`1<T> GetObjectEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
public abstract class Pipelines.Sockets.Unofficial.Arenas.SequenceSegment`1 : ReadOnlySequenceSegment`1<T> {
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    private int Pipelines.Sockets.Unofficial.Arenas.ISegment.ElementSize { get; }
    public int Length { get; private set; }
    public long RunningIndex { get; private set; }
    public SequenceSegment`1<T> Next { get; private set; }
    public Memory`1<T> Memory { get; private protected set; }
    private Type Pipelines.Sockets.Unofficial.Arenas.ISegment.ElementType { get; }
    private int Pipelines.Sockets.Unofficial.Arenas.ISegment.Index { get; }
    private Type Pipelines.Sockets.Unofficial.Arenas.ISegment.UnderlyingType { get; }
    protected SequenceSegment`1(Memory`1<T> memory, SequenceSegment`1<T> previous);
    private sealed virtual override int Pipelines.Sockets.Unofficial.Arenas.ISegment.get_ElementSize();
    private sealed virtual override void System.IDisposable.Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(int value);
    internal static int GetSegmentPosition(SequenceSegment`1& segment, long index);
    private static int SlowGetSegmentPosition(SequenceSegment`1& segment, long index);
    public sealed virtual long get_RunningIndex();
    private void set_RunningIndex(long value);
    internal void Trim(int length);
    public SequenceSegment`1<T> get_Next();
    private void set_Next(SequenceSegment`1<T> value);
    public sealed virtual Memory`1<T> get_Memory();
    private protected void set_Memory(Memory`1<T> value);
    private sealed virtual override Type Pipelines.Sockets.Unofficial.Arenas.ISegment.get_ElementType();
    private sealed virtual override int Pipelines.Sockets.Unofficial.Arenas.ISegment.get_Index();
    protected virtual int GetSegmentIndex();
    private sealed virtual override Type Pipelines.Sockets.Unofficial.Arenas.ISegment.get_UnderlyingType();
    protected virtual Type GetUnderlyingType();
    protected SequenceSegment`1<T> DetachNext();
}
internal class Pipelines.Sockets.Unofficial.Arenas.SimpleOwnedArena`1 : OwnedArena`1<T> {
    private Arena`1<T> _arena;
    internal Arena`1<T> Arena { get; }
    public SimpleOwnedArena`1(Arena parent, Allocator`1<T> suggestedAllocator);
    internal Arena`1<T> get_Arena();
    public virtual Sequence`1<T> Allocate(int length);
    internal virtual object GetAllocator();
    internal virtual void Reset();
    internal virtual void Dispose();
    internal virtual SequencePosition GetPosition();
    internal virtual long AllocatedBytes();
    internal virtual Sequence`1<T> AllocateRetainingSegmentData(int length);
}
public class Pipelines.Sockets.Unofficial.Arenas.UnmanagedAllocator`1 : Allocator`1<T> {
    [CompilerGeneratedAttribute]
private static UnmanagedAllocator`1<T> <Shared>k__BackingField;
    internal bool IsUnmanaged { get; }
    public static UnmanagedAllocator`1<T> Shared { get; }
    private static UnmanagedAllocator`1();
    internal virtual bool get_IsUnmanaged();
    [CompilerGeneratedAttribute]
public static UnmanagedAllocator`1<T> get_Shared();
    public virtual IMemoryOwner`1<T> Allocate(int length);
}
public abstract class Pipelines.Sockets.Unofficial.Buffers.BufferWriter`1 : object {
    [CompilerGeneratedAttribute]
private int <BlockSize>k__BackingField;
    private static int DefaultBlockSize;
    private RefCountedSegment<T> _head;
    private RefCountedSegment<T> _tail;
    private RefCountedSegment<T> _final;
    private int _headOffset;
    private int _tailOffset;
    private int _tailRemaining;
    private protected int BlockSize { get; }
    public IBufferWriter`1<T> Writer { get; }
    public long Length { get; }
    private protected BufferWriter`1(int blockSize);
    [CompilerGeneratedAttribute]
private protected int get_BlockSize();
    public static BufferWriter`1<T> Create(MemoryPool`1<T> memoryPool, Nullable`1<int> blockSize);
    public static BufferWriter`1<T> Create(ArrayPool`1<T> arrayPool, Nullable`1<int> blockSize);
    public static BufferWriter`1<T> Create(Nullable`1<int> blockSize);
    public IBufferWriter`1<T> get_Writer();
    public long get_Length();
    public virtual void Dispose();
    private void DiscardChain();
    public Sequence`1<T> GetBuffer();
    public Owned`1<ReadOnlySequence`1<T>> Flush(long count);
    public Owned`1<ReadOnlySequence`1<T>> Flush();
    private Owned`1<ReadOnlySequence`1<T>> FlushImpl(long count);
    public sealed virtual void Advance(int count);
    internal string GetState();
    private void SlowAdvance(int count);
    public sealed virtual Span`1<T> GetSpan(int sizeHint);
    public sealed virtual Memory`1<T> GetMemory(int sizeHint);
    public Sequence`1<T> GetSequence(int sizeHint);
    private Sequence`1<T> GetSequenceSlow(int extraSpaceNeeded);
    private Memory`1<T> GetMemorySlow(int sizeHint);
    private protected abstract virtual RefCountedSegment<T> CreateNewSegment(RefCountedSegment<T> previous, int size);
}
public class Pipelines.Sockets.Unofficial.Buffers.BufferWriterTextWriter : TextWriter {
    private IBufferWriter`1<byte> _output;
    private Encoding _encoding;
    public Encoding Encoding { get; }
    private BufferWriterTextWriter(IBufferWriter`1<byte> output, Encoding encoding);
    public static TextWriter Create(IBufferWriter`1<byte> output, Encoding encoding);
    public virtual Encoding get_Encoding();
    public virtual void Write(string value);
    public virtual void WriteLine(string value);
    public virtual void Write(Char[] buffer);
    public virtual void Write(char value);
    public virtual void WriteLine();
    public virtual void WriteLine(char value);
    public virtual Task WriteLineAsync();
    public virtual Task WriteLineAsync(char value);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual Task WriteLineAsync(string value);
    public virtual Task WriteAsync(string value);
    public virtual void WriteLine(Char[] buffer);
    public virtual void WriteLine(Char[] buffer, int index, int count);
    public virtual void Flush();
    public virtual Task FlushAsync();
    public virtual Task WriteAsync(char value);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    private void WriteCore(ReadOnlySpan`1<char> value);
    private void WriteFallback(ReadOnlySpan`1<char> value, int byteCount);
    public virtual void Write(ReadOnlySpan`1<char> buffer);
    public virtual Task WriteLineAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual void WriteLine(ReadOnlySpan`1<char> buffer);
    public virtual Task WriteAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
public class Pipelines.Sockets.Unofficial.Buffers.Owned`1 : ValueType {
    private Action`1<T> _onDispose;
    private T _value;
    public T Value { get; }
    public Owned`1(T value, Action`1<T> onDispose);
    public T get_Value();
    public sealed virtual void Dispose();
    public static T op_Implicit(Owned`1& value);
    public static Owned`1<T> op_Implicit(T& value);
}
public class Pipelines.Sockets.Unofficial.ConnectionAbortedException : OperationCanceledException {
    public ConnectionAbortedException(string message);
    public ConnectionAbortedException(string message, Exception inner);
    private ConnectionAbortedException(SerializationInfo info, StreamingContext context);
}
public class Pipelines.Sockets.Unofficial.ConnectionResetException : IOException {
    public ConnectionResetException(string message);
    public ConnectionResetException(string message, Exception inner);
    private ConnectionResetException(SerializationInfo info, StreamingContext context);
}
internal enum Pipelines.Sockets.Unofficial.Counter : Enum {
    public int value__;
    public static Counter SocketGetBufferList;
    public static Counter SocketSendAsyncSingleSync;
    public static Counter SocketSendAsyncSingleAsync;
    public static Counter SocketSendAsyncMultiSync;
    public static Counter SocketSendAsyncMultiAsync;
    public static Counter SocketPipeReadReadSync;
    public static Counter SocketPipeReadReadAsync;
    public static Counter SocketPipeFlushSync;
    public static Counter SocketPipeFlushAsync;
    public static Counter SocketReceiveSync;
    public static Counter SocketReceiveAsync;
    public static Counter SocketZeroLengthReceiveSync;
    public static Counter SocketZeroLengthReceiveAsync;
    public static Counter SocketSendAsyncSync;
    public static Counter SocketSendAsyncAsync;
    public static Counter SocketAwaitableCallbackNone;
    public static Counter SocketAwaitableCallbackDirect;
    public static Counter SocketAwaitableCallbackSchedule;
    public static Counter ThreadPoolWorkerStarted;
    public static Counter ThreadPoolPushedToMainThreadPool;
    public static Counter ThreadPoolScheduled;
    public static Counter ThreadPoolExecuted;
    public static Counter PipeStreamWrite;
    public static Counter PipeStreamWriteAsync;
    public static Counter PipeStreamWriteByte;
    public static Counter PipeStreamBeginWrite;
    public static Counter PipeStreamWriteSpan;
    public static Counter PipeStreamWriteAsyncMemory;
    public static Counter PipeStreamRead;
    public static Counter PipeStreamReadAsync;
    public static Counter PipeStreamReadByte;
    public static Counter PipeStreamBeginRead;
    public static Counter PipeStreamReadSpan;
    public static Counter PipeStreamReadAsyncMemory;
    public static Counter PipeStreamFlush;
    public static Counter PipeStreamFlushAsync;
    public static Counter OpenReceiveReadAsync;
    public static Counter OpenReceiveFlushAsync;
    public static Counter OpenSendReadAsync;
    public static Counter OpenSendWriteAsync;
    public static Counter SocketConnectionCollectedWithoutDispose;
}
public class Pipelines.Sockets.Unofficial.DedicatedThreadPoolPipeScheduler : PipeScheduler {
    [ThreadStaticAttribute]
private static int s_threadWorkerPoolId;
    private static int s_nextWorkerPoolId;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WorkerCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UseThreadPoolQueueLength>k__BackingField;
    [CompilerGeneratedAttribute]
private ThreadPriority <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private long _totalServicedByQueue;
    private long _totalServicedByPool;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _disposed;
    private Queue`1<WorkItem> _queue;
    private static ParameterizedThreadStart ThreadRunWorkLoop;
    private int _availableCount;
    public static DedicatedThreadPoolPipeScheduler Default { get; }
    private int Id { get; }
    public int WorkerCount { get; }
    private int UseThreadPoolQueueLength { get; }
    private ThreadPriority Priority { get; }
    private string Name { get; }
    public long TotalServicedByQueue { get; }
    public long TotalServicedByPool { get; }
    public int AvailableCount { get; }
    public DedicatedThreadPoolPipeScheduler(string name, int workerCount, int useThreadPoolQueueLength, ThreadPriority priority);
    private static DedicatedThreadPoolPipeScheduler();
    public static DedicatedThreadPoolPipeScheduler get_Default();
    public static bool IsWorker(DedicatedThreadPoolPipeScheduler pool);
    [CompilerGeneratedAttribute]
private int get_Id();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public int get_WorkerCount();
    [CompilerGeneratedAttribute]
private int get_UseThreadPoolQueueLength();
    [CompilerGeneratedAttribute]
private ThreadPriority get_Priority();
    [CompilerGeneratedAttribute]
private string get_Name();
    public long get_TotalServicedByQueue();
    public long get_TotalServicedByPool();
    private void StartWorker(int id);
    public virtual void Schedule(Action`1<object> action, object state);
    public int get_AvailableCount();
    private void Execute(Action`1<object> action, object state);
    private void RunWorkLoop();
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class Pipelines.Sockets.Unofficial.Delegates : object {
    private static Func`2<MulticastDelegate, object> s_getArr;
    private static Func`2<MulticastDelegate, IntPtr> s_getCount;
    private static bool s_isAvailable;
    public static bool IsSupported { get; }
    private static Delegates();
    [ExtensionAttribute]
public static DelegateEnumerator`1<T> GetEnumerator(T handler);
    [ExtensionAttribute]
public static DelegateEnumerable`1<T> AsEnumerable(T handler);
    [ExtensionAttribute]
public static bool IsSingle(MulticastDelegate handler);
    public static bool get_IsSupported();
    private static Func`2<MulticastDelegate, T> GetGetter(string fieldName);
    private static Func`2<MulticastDelegate, T> GetViaReflection(FieldInfo field);
}
[ExtensionAttribute]
internal static class Pipelines.Sockets.Unofficial.Helpers : object {
    private static string s_assemblyFailureMessssage;
    [ConditionalAttribute("DEBUG")]
internal static void Incr(Counter counter);
    [ConditionalAttribute("DEBUG")]
internal static void Decr(Counter counter);
    [ConditionalAttribute("DEBUG")]
internal static void Incr(MethodInfo method);
    private static string GetAssemblyFailureMessage();
    internal static void AssertDependencies();
    private static void CheckPipe();
    private static void CheckBuffers();
    private static void CheckUnsafe();
    private static void CheckNumerics();
    private static void ExecutePipe(String& assembly);
    [ExtensionAttribute]
internal static ArraySegment`1<byte> GetArray(Memory`1<byte> buffer);
    [ExtensionAttribute]
internal static ArraySegment`1<byte> GetArray(ReadOnlyMemory`1<byte> buffer);
    [ConditionalAttribute("VERBOSE")]
internal static void DebugLog(string name, string message, string caller);
    [ExtensionAttribute]
internal static void PipelinesFireAndForget(Task task);
    [CompilerGeneratedAttribute]
internal static string <GetAssemblyFailureMessage>g__ComputeAssemblyFailureMessage|4_0();
    [CompilerGeneratedAttribute]
internal static void <GetAssemblyFailureMessage>g__AddFailure|4_1(string assembly, <>c__DisplayClass4_0& );
}
public interface Pipelines.Sockets.Unofficial.IMeasuredDuplexPipe {
    public long TotalBytesSent { get; }
    public long TotalBytesReceived { get; }
    public abstract virtual long get_TotalBytesSent();
    public abstract virtual long get_TotalBytesReceived();
}
internal static class Pipelines.Sockets.Unofficial.Internal.Throw : object {
    internal static void ObjectDisposed(string objectName);
    internal static void InvalidOperation(string message);
    internal static void NotSupported(string message);
    internal static void ArgumentOutOfRange(string paramName);
    internal static void ArgumentNull(string paramName);
    internal static void Timeout(string message);
    internal static void InvalidCast();
    internal static void EnumeratorOutOfRange();
    internal static void MultipleContinuations();
    internal static void InvalidLockHolder();
    internal static void TaskCanceled();
    internal static void Argument(string message, string paramName);
    internal static void Socket(int errorCode);
    internal static void FileNotFound(string message, string path);
    internal static void IndexOutOfRange();
    internal static void SegmentDataUnavailable();
    internal static void AllocationDuringEnumeration();
}
public class Pipelines.Sockets.Unofficial.MemoryMappedPipeReader : PipeReader {
    private MemoryMappedFile _file;
    private int _pageSize;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private bool _loadMore;
    private long _remaining;
    private long _offset;
    private MappedPage _first;
    private MappedPage _last;
    private static FieldInfo s_safeBufferField;
    private static int DEFAULT_PAGE_SIZE;
    private string Name { get; }
    public static bool IsAvailable { get; }
    private static MemoryMappedPipeReader();
    private MemoryMappedPipeReader(MemoryMappedFile file, long length, int pageSize, string name);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private string get_Name();
    [ConditionalAttribute("VERBOSE")]
private void DebugLog(string message, string caller);
    public static bool get_IsAvailable();
    public static PipeReader Create(string path, int pageSize);
    public virtual void Complete(Exception exception);
    public sealed virtual void Dispose();
    public virtual void CancelPendingRead();
    public virtual void AdvanceTo(SequencePosition consumed);
    public virtual void AdvanceTo(SequencePosition consumed, SequencePosition examined);
    private static long CountAvailable(MappedPage page);
    public virtual ValueTask`1<ReadResult> ReadAsync(CancellationToken cancellationToken);
    public virtual bool TryRead(ReadResult& result);
    private ReadResult Read();
}
public enum Pipelines.Sockets.Unofficial.PipeShutdownKind : Enum {
    public int value__;
    public static PipeShutdownKind None;
    public static PipeShutdownKind PipeDisposed;
    public static PipeShutdownKind ReadEndOfStream;
    public static PipeShutdownKind ReadDisposed;
    public static PipeShutdownKind ReadIOException;
    public static PipeShutdownKind ReadException;
    public static PipeShutdownKind ReadSocketError;
    public static PipeShutdownKind ReadFlushCompleted;
    public static PipeShutdownKind ReadFlushCanceled;
    public static PipeShutdownKind WriteEndOfStream;
    public static PipeShutdownKind WriteDisposed;
    public static PipeShutdownKind WriteIOException;
    public static PipeShutdownKind WriteException;
    public static PipeShutdownKind WriteSocketError;
    public static PipeShutdownKind InputReaderCompleted;
    public static PipeShutdownKind InputWriterCompleted;
    public static PipeShutdownKind OutputReaderCompleted;
    public static PipeShutdownKind OutputWriterCompleted;
    public static PipeShutdownKind ProtocolExitClient;
    public static PipeShutdownKind ProtocolExitServer;
}
public class Pipelines.Sockets.Unofficial.SocketAwaitableEventArgs : SocketAsyncEventArgs {
    private SocketError modreq(System.Runtime.CompilerServices.IsVolatile) _forcedError;
    private static Action _callbackCompleted;
    private PipeScheduler _ioScheduler;
    private Action _callback;
    internal static Action`1<object> InvokeStateAsAction;
    public bool IsCompleted { get; }
    public SocketAwaitableEventArgs(PipeScheduler ioScheduler);
    private static SocketAwaitableEventArgs();
    public void Abort(SocketError error);
    public SocketAwaitableEventArgs GetAwaiter();
    public bool get_IsCompleted();
    public int GetResult();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
    public void Complete();
    protected virtual void OnCompleted(SocketAsyncEventArgs e);
    [CompilerGeneratedAttribute]
internal static void <GetResult>g__ThrowSocketException|10_0(SocketError e);
}
public class Pipelines.Sockets.Unofficial.SocketConnection : object {
    private int _socketShutdownKind;
    [CompilerGeneratedAttribute]
private SocketError <SocketError>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Socket <Socket>k__BackingField;
    private Pipe _sendToSocket;
    private Pipe _receiveFromSocket;
    private PipeReader _input;
    private PipeWriter _output;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _sendAborted;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _receiveAborted;
    private static Action`1<object> s_DoReceiveAsync;
    private static Action`1<object> s_DoSendAsync;
    private PipeOptions _receiveOptions;
    private PipeOptions _sendOptions;
    private static List`1<ArraySegment`1<byte>> _spareBuffer;
    [CompilerGeneratedAttribute]
private SocketConnectionOptions <SocketConnectionOptions>k__BackingField;
    private SocketAwaitableEventArgs _readerArgs;
    [CompilerGeneratedAttribute]
private int <LastReceived>k__BackingField;
    private long _totalBytesReceived;
    private long _totalBytesSent;
    private SocketAwaitableEventArgs _writerArgs;
    public PipeShutdownKind ShutdownKind { get; }
    public SocketError SocketError { get; private set; }
    public PipeReader Input { get; }
    public PipeWriter Output { get; }
    private string Name { get; }
    public Socket Socket { get; }
    private SocketConnectionOptions SocketConnectionOptions { get; }
    private bool ZeroLengthReads { get; }
    private bool InlineReads { get; }
    private bool InlineWrites { get; }
    public long BytesRead { get; }
    public int LastReceived { get; private set; }
    private long Pipelines.Sockets.Unofficial.IMeasuredDuplexPipe.TotalBytesReceived { get; }
    public long BytesSent { get; }
    private long Pipelines.Sockets.Unofficial.IMeasuredDuplexPipe.TotalBytesSent { get; }
    private SocketConnection(Socket socket, PipeOptions sendPipeOptions, PipeOptions receivePipeOptions, SocketConnectionOptions socketConnectionOptions, string name);
    private static SocketConnection();
    public static Task`1<SocketConnection> ConnectAsync(EndPoint endpoint, PipeOptions pipeOptions, SocketConnectionOptions connectionOptions, Func`2<SocketConnection, Task> onConnected, Socket socket, string name);
    [AsyncStateMachineAttribute("Pipelines.Sockets.Unofficial.SocketConnection/<ConnectAsync>d__1")]
public static Task`1<SocketConnection> ConnectAsync(EndPoint endpoint, PipeOptions sendPipeOptions, PipeOptions receivePipeOptions, SocketConnectionOptions connectionOptions, Func`2<SocketConnection, Task> onConnected, Socket socket, string name);
    public static void AssertDependencies();
    public PipeShutdownKind get_ShutdownKind();
    [CompilerGeneratedAttribute]
public SocketError get_SocketError();
    [CompilerGeneratedAttribute]
private void set_SocketError(SocketError value);
    private bool TrySetShutdown(PipeShutdownKind kind);
    public bool TrySetProtocolShutdown(PipeShutdownKind kind);
    private bool TrySetShutdown(PipeShutdownKind kind, SocketError socketError);
    public static void SetRecommendedClientOptions(Socket socket);
    public static void SetRecommendedServerOptions(Socket socket);
    [ConditionalAttribute("VERBOSE")]
private void DebugLog(string message, string caller, int lineNumber);
    public sealed virtual void Dispose();
    public sealed virtual PipeReader get_Input();
    public sealed virtual PipeWriter get_Output();
    [CompilerGeneratedAttribute]
private string get_Name();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public Socket get_Socket();
    [EditorBrowsableAttribute("1")]
[BrowsableAttribute("False")]
public Counters GetCounters();
    public static SocketConnection Create(Socket socket, PipeOptions pipeOptions, SocketConnectionOptions socketConnectionOptions, string name);
    public static SocketConnection Create(Socket socket, PipeOptions sendPipeOptions, PipeOptions receivePipeOptions, SocketConnectionOptions socketConnectionOptions, string name);
    private void InputReaderCompleted(Exception ex);
    private void OutputWriterCompleted(Exception ex);
    private static bool TrySetShutdown(Exception ex, SocketConnection connection, PipeShutdownKind kind);
    private static void DoReceiveAsync(object s);
    private static void DoSendAsync(object s);
    private static List`1<ArraySegment`1<byte>> GetSpareBuffer();
    private static void RecycleSpareBuffer(SocketAwaitableEventArgs args);
    [CompilerGeneratedAttribute]
private SocketConnectionOptions get_SocketConnectionOptions();
    private bool HasFlag(SocketConnectionOptions option);
    private bool get_ZeroLengthReads();
    private bool get_InlineReads();
    private bool get_InlineWrites();
    public long get_BytesRead();
    [CompilerGeneratedAttribute]
public int get_LastReceived();
    [CompilerGeneratedAttribute]
private void set_LastReceived(int value);
    private sealed virtual override long Pipelines.Sockets.Unofficial.IMeasuredDuplexPipe.get_TotalBytesReceived();
    [AsyncStateMachineAttribute("Pipelines.Sockets.Unofficial.SocketConnection/<DoReceiveAsync>d__73")]
private Task DoReceiveAsync();
    private static void DoReceive(Socket socket, SocketAwaitableEventArgs args, Memory`1<byte> buffer, string name);
    public long get_BytesSent();
    private sealed virtual override long Pipelines.Sockets.Unofficial.IMeasuredDuplexPipe.get_TotalBytesSent();
    [AsyncStateMachineAttribute("Pipelines.Sockets.Unofficial.SocketConnection/<DoSendAsync>d__81")]
private Task DoSendAsync();
    private static void DoSend(Socket socket, SocketAwaitableEventArgs args, ReadOnlySequence`1& buffer, string name);
    private static void DoSend(Socket socket, SocketAwaitableEventArgs args, ReadOnlyMemory`1<byte> memory, string name);
    private static List`1<ArraySegment`1<byte>> GetBufferList(SocketAsyncEventArgs args, ReadOnlySequence`1& buffer);
}
[FlagsAttribute]
public enum Pipelines.Sockets.Unofficial.SocketConnectionOptions : Enum {
    public int value__;
    public static SocketConnectionOptions None;
    public static SocketConnectionOptions ZeroLengthReads;
    public static SocketConnectionOptions InlineReads;
    public static SocketConnectionOptions InlineWrites;
    public static SocketConnectionOptions InlineConnect;
}
public abstract class Pipelines.Sockets.Unofficial.SocketServer : object {
    private Socket _listener;
    private Action`1<object> RunClientAsync;
    public void Listen(EndPoint endPoint, AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType, int listenBacklog, PipeOptions sendOptions, PipeOptions receiveOptions);
    public void Listen(EndPoint endPoint, AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType, PipeOptions sendOptions, PipeOptions receiveOptions);
    public void Stop();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private static void FireAndForget(Task task);
    private static void StartOnScheduler(PipeScheduler scheduler, Action`1<object> callback, object state);
    [AsyncStateMachineAttribute("Pipelines.Sockets.Unofficial.SocketServer/<ListenForConnectionsAsync>d__10")]
private Task ListenForConnectionsAsync(PipeOptions sendOptions, PipeOptions receiveOptions);
    protected virtual void OnServerFaulted(Exception exception);
    protected virtual void OnClientFaulted(ClientConnection& modreq(System.Runtime.InteropServices.InAttribute) client, Exception exception);
    protected virtual void OnStarted(EndPoint endPoint);
    protected abstract virtual Task OnClientConnectedAsync(ClientConnection& modreq(System.Runtime.InteropServices.InAttribute) client);
    [AsyncStateMachineAttribute("Pipelines.Sockets.Unofficial.SocketServer/<<-ctor>b__7_0>d")]
[CompilerGeneratedAttribute]
private void <.ctor>b__7_0(object boxed);
}
public static class Pipelines.Sockets.Unofficial.StreamConnection : object {
    public static IDuplexPipe GetDuplex(Stream stream, PipeOptions pipeOptions, string name);
    public static IDuplexPipe GetDuplex(Stream stream, PipeOptions sendPipeOptions, PipeOptions receivePipeOptions, string name);
    public static PipeReader GetReader(Stream stream, PipeOptions pipeOptions, string name);
    public static PipeWriter GetWriter(Stream stream, PipeOptions pipeOptions, string name);
    public static AsyncPipeStream GetDuplex(PipeReader reader, PipeWriter writer, string name);
    public static AsyncPipeStream GetDuplex(IDuplexPipe pipe, string name);
    public static Stream GetWriter(PipeWriter writer, string name);
    public static Stream GetReader(PipeReader reader, string name);
}
public class Pipelines.Sockets.Unofficial.Threading.MutexSlim : object {
    private PipeScheduler _scheduler;
    private Queue`1<PendingLockItem> _queue;
    private int _token;
    private int _pendingAsyncOperations;
    private UInt32 _timeoutStart;
    private CancellationTokenSource _timeoutCancel;
    [CompilerGeneratedAttribute]
private int <TimeoutMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsThreadPool>k__BackingField;
    private AsyncDirectPendingLockSlab _directSlab;
    private static Action`1[] _slabCallbacks;
    private static Task`1<LockToken> s_canceledTask;
    public int TimeoutMilliseconds { get; }
    internal bool IsThreadPool { get; }
    public bool IsAvailable { get; }
    public MutexSlim(int timeoutMilliseconds, PipeScheduler scheduler);
    private static MutexSlim();
    [ConditionalAttribute("DEBUG")]
private void Log(string message);
    [CompilerGeneratedAttribute]
public int get_TimeoutMilliseconds();
    [CompilerGeneratedAttribute]
internal bool get_IsThreadPool();
    private int BacklogCount();
    public virtual string ToString();
    private PendingLockItem DequeueInsideLock();
    private void Release(int token, bool demandMatch);
    private void ActivateNextQueueItemWithValidatedToken(int token);
    private void DequeueExpired();
    private void SetNextAsyncTimeoutInsideLock();
    public bool get_IsAvailable();
    private int TryTakeOnceOnly();
    private static UInt32 GetTime();
    private static int UpdateTimeOut(UInt32 startTime, int originalWaitMillisecondsTimeout);
    private static bool HasFlag(WaitOptions options, WaitOptions flag);
    private LockToken TakeWithTimeout(WaitOptions options);
    private ValueTask`1<LockToken> TakeWithTimeoutAsync(CancellationToken cancellationToken, WaitOptions options);
    private ValueTask`1<LockToken> FromTokenAsync(int token);
    private static Action`1<object> GetCancelationCallback(short key);
    private IAsyncPendingLockToken GetSlabTokenInsideLock(Int16& key);
    public ValueTask`1<LockToken> TryWaitAsync(CancellationToken cancellationToken, WaitOptions options);
    internal static ValueTask`1<LockToken> GetCanceled();
    private static Task`1<LockToken> CreateCanceledLockTokenTask();
    public LockToken TryWait(WaitOptions options);
    [CompilerGeneratedAttribute]
internal static void <.ctor>g__ThrowInvalidTimeout|17_0();
    [CompilerGeneratedAttribute]
private void <SetNextAsyncTimeoutInsideLock>g__CancelExistingTimeout|22_0();
    [CompilerGeneratedAttribute]
internal static Action`1<object> <GetCancelationCallback>g__CreateCancelationCallback|34_1(short lkey);
}
public class Pipelines.Sockets.Unofficial.UnmanagedMemoryManager`1 : MemoryManager`1<T> {
    private Void* _pointer;
    private int _length;
    public UnmanagedMemoryManager`1(Span`1<T> span);
    [CLSCompliantAttribute("False")]
public UnmanagedMemoryManager`1(T* pointer, int length);
    public UnmanagedMemoryManager`1(IntPtr pointer, int length);
    private UnmanagedMemoryManager`1(Void* pointer, int length);
    public virtual Span`1<T> GetSpan();
    public virtual MemoryHandle Pin(int elementIndex);
    public virtual void Unpin();
    protected virtual void Dispose(bool disposing);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2048")]
internal class System.Runtime.CompilerServices.ScopedRefAttribute : Attribute {
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.6.128.36433")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
    private static ThisAssembly();
}
