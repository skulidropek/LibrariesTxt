internal class AssemblyInfo : object {
    private static string version;
    public static string Version { get; }
    public static string get_Version();
}
public class crypto.Security : object {
    public static string ComputeHash(string text, string salt);
    public static string Decrypt(string cipherText, string key, string iv);
    public static string Encrypt(string plainText, string key, string iv);
    public static string GenerateText(int size);
    private static IBufferedCipher CreateCipher(bool isEncryption, string key, string iv);
}
public class Org.BouncyCastle.Apache.Bzip2.BZip2Constants : object {
    public static int baseBlockSize;
    public static int MAX_ALPHA_SIZE;
    public static int MAX_CODE_LEN;
    public static int RUNA;
    public static int RUNB;
    public static int N_GROUPS;
    public static int G_SIZE;
    public static int N_ITERS;
    public static int MAX_SELECTORS;
    public static int NUM_OVERSHOOT_BYTES;
    public static Int32[] rNums;
    private static BZip2Constants();
}
public class Org.BouncyCastle.Apache.Bzip2.CBZip2InputStream : Stream {
    private int last;
    private int origPtr;
    private int blockSize100k;
    private bool blockRandomised;
    private int bsBuff;
    private int bsLive;
    private CRC mCrc;
    private Boolean[] inUse;
    private int nInUse;
    private Char[] seqToUnseq;
    private Char[] unseqToSeq;
    private Char[] selector;
    private Char[] selectorMtf;
    private Int32[] tt;
    private Char[] ll8;
    private Int32[] unzftab;
    private Int32[][] limit;
    private Int32[][] basev;
    private Int32[][] perm;
    private Int32[] minLens;
    private Stream bsStream;
    private bool streamEnd;
    private int currentChar;
    private static int START_BLOCK_STATE;
    private static int RAND_PART_A_STATE;
    private static int RAND_PART_B_STATE;
    private static int RAND_PART_C_STATE;
    private static int NO_RAND_PART_A_STATE;
    private static int NO_RAND_PART_B_STATE;
    private static int NO_RAND_PART_C_STATE;
    private int currentState;
    private int storedBlockCRC;
    private int storedCombinedCRC;
    private int computedBlockCRC;
    private int computedCombinedCRC;
    private int i2;
    private int count;
    private int chPrev;
    private int ch2;
    private int i;
    private int tPos;
    private int rNToGo;
    private int rTPos;
    private int j2;
    private char z;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CBZip2InputStream(Stream zStream);
    private static void Cadvise();
    private static void CompressedStreamEOF();
    private void MakeMaps();
    internal static Int32[][] InitIntArray(int n1, int n2);
    internal static Byte[][] InitByteArray(int n1, int n2);
    public virtual int ReadByte();
    private void Initialize();
    private void InitBlock();
    private void EndBlock();
    private void Complete();
    private static void BlockOverrun();
    private static void BadBlockHeader();
    private static void CrcError();
    private void BsFinishedWithStream();
    private void BsSetStream(Stream f);
    private int BsR(int n);
    private char BsGetUChar();
    private int BsGetint();
    private int BsGetIntVS(int numBits);
    private int BsGetInt32();
    private void HbCreateDecodeTables(Int32[] limit, Int32[] basev, Int32[] perm, Byte[] length, int minLen, int maxLen, int alphaSize);
    private void RecvDecodingTables();
    private void GetAndMoveToFrontDecode();
    private void SetupBlock();
    private void SetupRandPartA();
    private void SetupNoRandPartA();
    private void SetupRandPartB();
    private void SetupRandPartC();
    private void SetupNoRandPartB();
    private void SetupNoRandPartC();
    private void SetDecompressStructureSizes(int newSize100k);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
public class Org.BouncyCastle.Apache.Bzip2.CBZip2OutputStream : Stream {
    protected static int SETMASK;
    protected static int CLEARMASK;
    protected static int GREATER_ICOST;
    protected static int LESSER_ICOST;
    protected static int SMALL_THRESH;
    protected static int DEPTH_THRESH;
    private bool finished;
    private int count;
    private int origPtr;
    private int blockSize100k;
    private int allowableBlockSize;
    private bool blockRandomised;
    private int bsBuff;
    private int bsLive;
    private CRC mCrc;
    private Boolean[] inUse;
    private int nInUse;
    private Char[] seqToUnseq;
    private Char[] unseqToSeq;
    private Char[] selector;
    private Char[] selectorMtf;
    private Byte[] blockBytes;
    private UInt16[] quadrantShorts;
    private Int32[] zptr;
    private Int32[] szptr;
    private Int32[] ftab;
    private int nMTF;
    private Int32[] mtfFreq;
    private int workFactor;
    private int workDone;
    private int workLimit;
    private bool firstAttempt;
    private int currentByte;
    private int runLength;
    private bool closed;
    private int blockCRC;
    private int combinedCRC;
    private Stream bsStream;
    private static Int32[] incs;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CBZip2OutputStream(Stream outStream);
    public CBZip2OutputStream(Stream outStream, int blockSize);
    private static CBZip2OutputStream();
    private static void Panic();
    private void MakeMaps();
    protected static void HbMakeCodeLengths(Byte[] len, Int32[] freq, int alphaSize, int maxLen);
    public virtual void WriteByte(byte b);
    private void WriteRun();
    public virtual void Close();
    public void Finish();
    public virtual void Flush();
    private void Initialize();
    private void InitBlock();
    private void EndBlock();
    private void EndCompression();
    private void HbAssignCodes(Int32[] code, Byte[] length, int minLen, int maxLen, int alphaSize);
    private void BsSetStream(Stream f);
    private void BsFinishedWithStream();
    private void BsW(int n, int v);
    private void BsPutUChar(int c);
    private void BsPutint(int u);
    private void BsPutIntVS(int numBits, int c);
    private void SendMTFValues();
    private void MoveToFrontCodeAndSend();
    private void SimpleSort(int lo, int hi, int d);
    private void Vswap(int p1, int p2, int n);
    private int Med3(int a, int b, int c);
    private static void PushStackElem(IList stack, int stackCount, int ll, int hh, int dd);
    private void QSort3(int loSt, int hiSt, int dSt);
    private void MainSort();
    private void RandomiseBlock();
    private void DoReversibleTransformation();
    private bool FullGtU(int i1, int i2);
    private void AllocateCompressStructures();
    private void GenerateMTFValues();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
internal class Org.BouncyCastle.Apache.Bzip2.CRC : object {
    public static Int32[] crc32Table;
    internal int globalCrc;
    private static CRC();
    internal void InitialiseCRC();
    internal int GetFinalCRC();
    internal int GetGlobalCRC();
    internal void SetGlobalCRC(int newCrc);
    internal void UpdateCRC(int inCh);
}
public class Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves : object {
    private static IDictionary objIds;
    private static IDictionary curves;
    private static IDictionary names;
    public static IEnumerable Names { get; }
    private static AnssiNamedCurves();
    private static X9ECPoint ConfigureBasepoint(ECCurve curve, string encoding);
    private static ECCurve ConfigureCurve(ECCurve curve);
    private static BigInteger FromHex(string hex);
    private static void DefineCurve(string name, DerObjectIdentifier oid, X9ECParametersHolder holder);
    public static X9ECParameters GetByName(string name);
    public static X9ECParameters GetByOid(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static string GetName(DerObjectIdentifier oid);
    public static IEnumerable get_Names();
}
public class Org.BouncyCastle.Asn1.Anssi.AnssiObjectIdentifiers : object {
    public static DerObjectIdentifier FRP256v1;
    private static AnssiObjectIdentifiers();
}
public abstract class Org.BouncyCastle.Asn1.Asn1Encodable : object {
    public static string Der;
    public static string Ber;
    public virtual void EncodeTo(Stream output);
    public virtual void EncodeTo(Stream output, string encoding);
    public Byte[] GetEncoded();
    public Byte[] GetEncoded(string encoding);
    public Byte[] GetDerEncoded();
    public sealed virtual int GetHashCode();
    public sealed virtual bool Equals(object obj);
    public abstract virtual Asn1Object ToAsn1Object();
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Asn1.Asn1EncodableVector : object {
    internal static Asn1Encodable[] EmptyElements;
    private static int DefaultCapacity;
    private Asn1Encodable[] elements;
    private int elementCount;
    private bool copyOnWrite;
    public Asn1Encodable Item { get; }
    public int Count { get; }
    public Asn1EncodableVector(int initialCapacity);
    public Asn1EncodableVector(Asn1Encodable[] v);
    private static Asn1EncodableVector();
    public static Asn1EncodableVector FromEnumerable(IEnumerable e);
    public void Add(Asn1Encodable element);
    public void Add(Asn1Encodable[] objs);
    public void AddOptional(Asn1Encodable[] objs);
    public void AddOptionalTagged(bool isExplicit, int tagNo, Asn1Encodable obj);
    public void AddAll(Asn1EncodableVector other);
    public Asn1Encodable get_Item(int index);
    public int get_Count();
    public sealed virtual IEnumerator GetEnumerator();
    internal Asn1Encodable[] CopyElements();
    internal Asn1Encodable[] TakeElements();
    private void Reallocate(int minCapacity);
    internal static Asn1Encodable[] CloneElements(Asn1Encodable[] elements);
}
public class Org.BouncyCastle.Asn1.Asn1Exception : IOException {
    public Asn1Exception(string message);
    public Asn1Exception(string message, Exception exception);
}
public abstract class Org.BouncyCastle.Asn1.Asn1Generator : object {
    private Stream _out;
    protected Stream Out { get; }
    protected Asn1Generator(Stream outStream);
    protected Stream get_Out();
    public abstract virtual void AddObject(Asn1Encodable obj);
    public abstract virtual void AddObject(Asn1Object obj);
    public abstract virtual Stream GetRawOutputStream();
    public abstract virtual void Close();
}
public class Org.BouncyCastle.Asn1.Asn1InputStream : FilterStream {
    private int limit;
    internal Byte[][] tmpBuffers;
    internal int Limit { get; }
    public Asn1InputStream(Stream input);
    public Asn1InputStream(Byte[] input);
    public Asn1InputStream(Stream input, int limit);
    internal Asn1InputStream(Stream input, int limit, Byte[][] tmpBuffers);
    internal static int FindLimit(Stream input);
    private Asn1Object BuildObject(int tag, int tagNo, int length);
    internal virtual Asn1EncodableVector ReadVector();
    internal virtual Asn1EncodableVector ReadVector(DefiniteLengthInputStream defIn);
    internal virtual DerSequence CreateDerSequence(DefiniteLengthInputStream dIn);
    internal virtual DerSet CreateDerSet(DefiniteLengthInputStream dIn);
    public Asn1Object ReadObject();
    internal virtual DerBitString BuildConstructedBitString(Asn1EncodableVector contentsElements);
    internal virtual Asn1OctetString BuildConstructedOctetString(Asn1EncodableVector contentsElements);
    internal virtual int get_Limit();
    internal static int ReadTagNumber(Stream s, int tag);
    internal static int ReadLength(Stream s, int limit, bool isParsing);
    private static Byte[] GetBuffer(DefiniteLengthInputStream defIn, Byte[][] tmpBuffers);
    private static Char[] GetBmpCharBuffer(DefiniteLengthInputStream defIn);
    internal static Asn1Object CreatePrimitiveDerObject(int tagNo, DefiniteLengthInputStream defIn, Byte[][] tmpBuffers);
}
public abstract class Org.BouncyCastle.Asn1.Asn1Null : Asn1Object {
    public virtual string ToString();
}
public abstract class Org.BouncyCastle.Asn1.Asn1Object : Asn1Encodable {
    public virtual void EncodeTo(Stream output);
    public virtual void EncodeTo(Stream output, string encoding);
    public static Asn1Object FromByteArray(Byte[] data);
    public static Asn1Object FromStream(Stream inStr);
    public sealed virtual Asn1Object ToAsn1Object();
    internal abstract virtual int EncodedLength(bool withID);
    internal abstract virtual void Encode(Asn1OutputStream asn1Out, bool withID);
    protected abstract virtual bool Asn1Equals(Asn1Object asn1Object);
    protected abstract virtual int Asn1GetHashCode();
    internal bool CallAsn1Equals(Asn1Object obj);
    internal int CallAsn1GetHashCode();
}
public abstract class Org.BouncyCastle.Asn1.Asn1OctetString : Asn1Object {
    internal static Byte[] EmptyOctets;
    internal Byte[] str;
    public Asn1OctetStringParser Parser { get; }
    internal Asn1OctetString(Byte[] str);
    private static Asn1OctetString();
    public static Asn1OctetString GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static Asn1OctetString GetInstance(object obj);
    public sealed virtual Stream GetOctetStream();
    public Asn1OctetStringParser get_Parser();
    public virtual Byte[] GetOctets();
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public virtual string ToString();
}
public interface Org.BouncyCastle.Asn1.Asn1OctetStringParser {
    public abstract virtual Stream GetOctetStream();
}
public class Org.BouncyCastle.Asn1.Asn1OutputStream : DerOutputStream {
    internal bool IsBer { get; }
    [ObsoleteAttribute("Use static Create method(s)")]
public Asn1OutputStream(Stream os);
    public static Asn1OutputStream Create(Stream output);
    public static Asn1OutputStream Create(Stream output, string encoding);
    public virtual void WriteObject(Asn1Encodable encodable);
    public virtual void WriteObject(Asn1Object primitive);
    internal void FlushInternal();
    internal virtual bool get_IsBer();
    internal void WriteDL(int length);
    internal virtual void WriteElements(Asn1Encodable[] elements);
    internal void WriteEncodingDL(bool withID, int identifier, byte contents);
    internal void WriteEncodingDL(bool withID, int identifier, Byte[] contents);
    internal void WriteEncodingDL(bool withID, int identifier, Byte[] contents, int contentsOff, int contentsLen);
    internal void WriteEncodingDL(bool withID, int identifier, byte contentsPrefix, Byte[] contents, int contentsOff, int contentsLen);
    internal void WriteEncodingDL(bool withID, int identifier, Byte[] contents, int contentsOff, int contentsLen, byte contentsSuffix);
    internal void WriteEncodingDL(bool withID, int flags, int tag, Byte[] contents);
    internal void WriteEncodingIL(bool withID, int identifier, Asn1Encodable[] elements);
    internal void WriteIdentifier(bool withID, int identifier);
    internal void WriteIdentifier(bool withID, int flags, int tag);
    internal virtual void WritePrimitive(Asn1Object primitive, bool withID);
    internal virtual void WritePrimitives(Asn1Object[] primitives);
    internal static int GetLengthOfDL(int dl);
    internal static int GetLengthOfEncodingDL(bool withID, int contentsLength);
    internal static int GetLengthOfEncodingDL(bool withID, int tag, int contentsLength);
    internal static int GetLengthOfIdentifier(int tag);
}
public class Org.BouncyCastle.Asn1.Asn1ParsingException : InvalidOperationException {
    public Asn1ParsingException(string message);
    public Asn1ParsingException(string message, Exception exception);
}
[DefaultMemberAttribute("Item")]
public abstract class Org.BouncyCastle.Asn1.Asn1Sequence : Asn1Object {
    internal Asn1Encodable[] elements;
    public Asn1SequenceParser Parser { get; }
    public Asn1Encodable Item { get; }
    public int Count { get; }
    protected internal Asn1Sequence(Asn1Encodable element);
    protected internal Asn1Sequence(Asn1Encodable[] elements);
    protected internal Asn1Sequence(Asn1EncodableVector elementVector);
    public static Asn1Sequence GetInstance(object obj);
    public static Asn1Sequence GetInstance(Asn1TaggedObject obj, bool explicitly);
    public virtual IEnumerator GetEnumerator();
    public virtual Asn1SequenceParser get_Parser();
    public virtual Asn1Encodable get_Item(int index);
    public virtual int get_Count();
    public virtual Asn1Encodable[] ToArray();
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public virtual string ToString();
}
public interface Org.BouncyCastle.Asn1.Asn1SequenceParser {
    public abstract virtual IAsn1Convertible ReadObject();
}
[DefaultMemberAttribute("Item")]
public abstract class Org.BouncyCastle.Asn1.Asn1Set : Asn1Object {
    internal Asn1Encodable[] elements;
    public Asn1Encodable Item { get; }
    public int Count { get; }
    public Asn1SetParser Parser { get; }
    protected internal Asn1Set(Asn1Encodable element);
    protected internal Asn1Set(Asn1Encodable[] elements);
    protected internal Asn1Set(Asn1EncodableVector elementVector);
    public static Asn1Set GetInstance(object obj);
    public static Asn1Set GetInstance(Asn1TaggedObject obj, bool explicitly);
    public virtual IEnumerator GetEnumerator();
    public virtual Asn1Encodable get_Item(int index);
    public virtual int get_Count();
    public virtual Asn1Encodable[] ToArray();
    public Asn1SetParser get_Parser();
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected internal void Sort();
    public virtual string ToString();
}
public interface Org.BouncyCastle.Asn1.Asn1SetParser {
    public abstract virtual IAsn1Convertible ReadObject();
}
public class Org.BouncyCastle.Asn1.Asn1StreamParser : object {
    private Stream _in;
    private int _limit;
    private Byte[][] tmpBuffers;
    public Asn1StreamParser(Stream input);
    public Asn1StreamParser(Byte[] encoding);
    public Asn1StreamParser(Stream input, int limit);
    internal Asn1StreamParser(Stream input, int limit, Byte[][] tmpBuffers);
    internal IAsn1Convertible ReadIndef(int tagValue);
    internal IAsn1Convertible ReadImplicit(bool constructed, int tag);
    internal Asn1Object ReadTaggedObject(bool constructed, int tag);
    public virtual IAsn1Convertible ReadObject();
    private void Set00Check(bool enabled);
    internal Asn1EncodableVector ReadVector();
}
public abstract class Org.BouncyCastle.Asn1.Asn1TaggedObject : Asn1Object {
    internal int tagNo;
    internal bool explicitly;
    internal Asn1Encodable obj;
    public int TagNo { get; }
    protected Asn1TaggedObject(int tagNo, Asn1Encodable obj);
    protected Asn1TaggedObject(bool explicitly, int tagNo, Asn1Encodable obj);
    internal static bool IsConstructed(bool isExplicit, Asn1Object obj);
    public static Asn1TaggedObject GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Asn1TaggedObject GetInstance(object obj);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    public sealed virtual int get_TagNo();
    public bool IsExplicit();
    public bool IsEmpty();
    public Asn1Object GetObject();
    public sealed virtual IAsn1Convertible GetObjectParser(int tag, bool isExplicit);
    public virtual string ToString();
}
public interface Org.BouncyCastle.Asn1.Asn1TaggedObjectParser {
    public int TagNo { get; }
    public abstract virtual int get_TagNo();
    public abstract virtual IAsn1Convertible GetObjectParser(int tag, bool isExplicit);
}
public class Org.BouncyCastle.Asn1.Asn1Tags : object {
    public static int Boolean;
    public static int Integer;
    public static int BitString;
    public static int OctetString;
    public static int Null;
    public static int ObjectIdentifier;
    public static int ObjectDescriptor;
    public static int External;
    public static int Real;
    public static int Enumerated;
    public static int EmbeddedPdv;
    public static int Utf8String;
    public static int RelativeOid;
    public static int Sequence;
    public static int SequenceOf;
    public static int Set;
    public static int SetOf;
    public static int NumericString;
    public static int PrintableString;
    public static int T61String;
    public static int VideotexString;
    public static int IA5String;
    public static int UtcTime;
    public static int GeneralizedTime;
    public static int GraphicString;
    public static int VisibleString;
    public static int GeneralString;
    public static int UniversalString;
    public static int UnrestrictedString;
    public static int BmpString;
    public static int Constructed;
    public static int Universal;
    public static int Application;
    [ObsoleteAttribute("Use 'ContextSpecific' instead")]
public static int Tagged;
    public static int ContextSpecific;
    public static int Private;
}
public abstract class Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers : object {
    public static DerObjectIdentifier bc;
    public static DerObjectIdentifier bc_pbe;
    public static DerObjectIdentifier bc_pbe_sha1;
    public static DerObjectIdentifier bc_pbe_sha256;
    public static DerObjectIdentifier bc_pbe_sha384;
    public static DerObjectIdentifier bc_pbe_sha512;
    public static DerObjectIdentifier bc_pbe_sha224;
    public static DerObjectIdentifier bc_pbe_sha1_pkcs5;
    public static DerObjectIdentifier bc_pbe_sha1_pkcs12;
    public static DerObjectIdentifier bc_pbe_sha256_pkcs5;
    public static DerObjectIdentifier bc_pbe_sha256_pkcs12;
    public static DerObjectIdentifier bc_pbe_sha1_pkcs12_aes128_cbc;
    public static DerObjectIdentifier bc_pbe_sha1_pkcs12_aes192_cbc;
    public static DerObjectIdentifier bc_pbe_sha1_pkcs12_aes256_cbc;
    public static DerObjectIdentifier bc_pbe_sha256_pkcs12_aes128_cbc;
    public static DerObjectIdentifier bc_pbe_sha256_pkcs12_aes192_cbc;
    public static DerObjectIdentifier bc_pbe_sha256_pkcs12_aes256_cbc;
    public static DerObjectIdentifier bc_sig;
    public static DerObjectIdentifier sphincs256;
    public static DerObjectIdentifier sphincs256_with_BLAKE512;
    public static DerObjectIdentifier sphincs256_with_SHA512;
    public static DerObjectIdentifier sphincs256_with_SHA3_512;
    public static DerObjectIdentifier xmss;
    public static DerObjectIdentifier xmss_with_SHA256;
    public static DerObjectIdentifier xmss_with_SHA512;
    public static DerObjectIdentifier xmss_with_SHAKE128;
    public static DerObjectIdentifier xmss_with_SHAKE256;
    public static DerObjectIdentifier xmss_mt;
    public static DerObjectIdentifier xmss_mt_with_SHA256;
    public static DerObjectIdentifier xmss_mt_with_SHA512;
    public static DerObjectIdentifier xmss_mt_with_SHAKE128;
    public static DerObjectIdentifier xmss_mt_with_SHAKE256;
    public static DerObjectIdentifier bc_exch;
    public static DerObjectIdentifier newHope;
    public static DerObjectIdentifier bc_ext;
    public static DerObjectIdentifier linkedCertificate;
    private static BCObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.BC.LinkedCertificate : Asn1Encodable {
    private DigestInfo mDigest;
    private GeneralName mCertLocation;
    private X509Name mCertIssuer;
    private GeneralNames mCACerts;
    public DigestInfo Digest { get; }
    public GeneralName CertLocation { get; }
    public X509Name CertIssuer { get; }
    public GeneralNames CACerts { get; }
    public LinkedCertificate(DigestInfo digest, GeneralName certLocation);
    public LinkedCertificate(DigestInfo digest, GeneralName certLocation, X509Name certIssuer, GeneralNames caCerts);
    private LinkedCertificate(Asn1Sequence seq);
    public static LinkedCertificate GetInstance(object obj);
    public virtual DigestInfo get_Digest();
    public virtual GeneralName get_CertLocation();
    public virtual X509Name get_CertIssuer();
    public virtual GeneralNames get_CACerts();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.BerApplicationSpecific : DerApplicationSpecific {
    public BerApplicationSpecific(int tagNo, Asn1EncodableVector vec);
}
public class Org.BouncyCastle.Asn1.BerApplicationSpecificParser : object {
    private int tag;
    private Asn1StreamParser parser;
    internal BerApplicationSpecificParser(int tag, Asn1StreamParser parser);
    public sealed virtual IAsn1Convertible ReadObject();
    public sealed virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.BerBitString : DerBitString {
    private static int DefaultSegmentLimit;
    private int segmentLimit;
    private DerBitString[] elements;
    private bool IsConstructed { get; }
    public BerBitString(byte data, int padBits);
    public BerBitString(Byte[] data);
    public BerBitString(Byte[] data, int padBits);
    public BerBitString(Byte[] data, int padBits, int segmentLimit);
    public BerBitString(int namedBits);
    public BerBitString(Asn1Encodable obj);
    public BerBitString(DerBitString[] elements);
    public BerBitString(DerBitString[] elements, int segmentLimit);
    internal BerBitString(Byte[] contents, bool check);
    internal static Byte[] FlattenBitStrings(DerBitString[] bitStrings);
    private bool get_IsConstructed();
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
}
public abstract class Org.BouncyCastle.Asn1.BerGenerator : Asn1Generator {
    private bool _tagged;
    private bool _isExplicit;
    private int _tagNo;
    protected BerGenerator(Stream outStream);
    protected BerGenerator(Stream outStream, int tagNo, bool isExplicit);
    public virtual void AddObject(Asn1Encodable obj);
    public virtual void AddObject(Asn1Object obj);
    public virtual Stream GetRawOutputStream();
    public virtual void Close();
    private void WriteHdr(int tag);
    protected void WriteBerHeader(int tag);
    protected void WriteBerBody(Stream contentStream);
    protected void WriteBerEnd();
}
[ObsoleteAttribute("Use 'DerNull' instead")]
public class Org.BouncyCastle.Asn1.BerNull : DerNull {
    [ObsoleteAttribute("Use 'DerNull.Instance' instead")]
public static BerNull Instance;
    private static BerNull();
}
public class Org.BouncyCastle.Asn1.BerOctetString : DerOctetString {
    private static int DefaultSegmentLimit;
    private int segmentLimit;
    private Asn1OctetString[] elements;
    private bool IsConstructed { get; }
    [ObsoleteAttribute("Will be removed")]
public BerOctetString(IEnumerable e);
    public BerOctetString(Byte[] str);
    public BerOctetString(Asn1OctetString[] elements);
    public BerOctetString(Byte[] str, int segmentLimit);
    public BerOctetString(Asn1OctetString[] elements, int segmentLimit);
    private BerOctetString(Byte[] octets, Asn1OctetString[] elements, int segmentLimit);
    public static BerOctetString FromSequence(Asn1Sequence seq);
    internal static Byte[] FlattenOctetStrings(Asn1OctetString[] octetStrings);
    private static Asn1OctetString[] ToOctetStringArray(IEnumerable e);
    public sealed virtual IEnumerator GetEnumerator();
    [ObsoleteAttribute("Use GetEnumerator() instead")]
public IEnumerator GetObjects();
    private bool get_IsConstructed();
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
}
public class Org.BouncyCastle.Asn1.BerOctetStringGenerator : BerGenerator {
    public BerOctetStringGenerator(Stream outStream);
    public BerOctetStringGenerator(Stream outStream, int tagNo, bool isExplicit);
    public Stream GetOctetOutputStream();
    public Stream GetOctetOutputStream(int bufSize);
    public Stream GetOctetOutputStream(Byte[] buf);
}
public class Org.BouncyCastle.Asn1.BerOctetStringParser : object {
    private Asn1StreamParser _parser;
    internal BerOctetStringParser(Asn1StreamParser parser);
    public sealed virtual Stream GetOctetStream();
    public sealed virtual Asn1Object ToAsn1Object();
    internal static BerOctetString Parse(Asn1StreamParser sp);
}
[ObsoleteAttribute("Use 'Asn1OutputStream' instead")]
public class Org.BouncyCastle.Asn1.BerOutputStream : DerOutputStream {
    [ObsoleteAttribute("Use 'Asn1OutputStream.Create' instead")]
public BerOutputStream(Stream os);
    public virtual void WriteObject(Asn1Encodable encodable);
    public virtual void WriteObject(Asn1Object primitive);
}
public class Org.BouncyCastle.Asn1.BerSequence : DerSequence {
    public static BerSequence Empty;
    public BerSequence(Asn1Encodable element);
    public BerSequence(Asn1Encodable[] elements);
    public BerSequence(Asn1EncodableVector elementVector);
    private static BerSequence();
    public static BerSequence FromVector(Asn1EncodableVector elementVector);
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
}
public class Org.BouncyCastle.Asn1.BerSequenceGenerator : BerGenerator {
    public BerSequenceGenerator(Stream outStream);
    public BerSequenceGenerator(Stream outStream, int tagNo, bool isExplicit);
}
public class Org.BouncyCastle.Asn1.BerSequenceParser : object {
    private Asn1StreamParser _parser;
    internal BerSequenceParser(Asn1StreamParser parser);
    public sealed virtual IAsn1Convertible ReadObject();
    public sealed virtual Asn1Object ToAsn1Object();
    internal static BerSequence Parse(Asn1StreamParser sp);
}
public class Org.BouncyCastle.Asn1.BerSet : DerSet {
    public static BerSet Empty;
    public BerSet(Asn1Encodable element);
    public BerSet(Asn1EncodableVector elementVector);
    internal BerSet(Asn1EncodableVector elementVector, bool needsSorting);
    private static BerSet();
    public static BerSet FromVector(Asn1EncodableVector elementVector);
    internal static BerSet FromVector(Asn1EncodableVector elementVector, bool needsSorting);
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
}
public class Org.BouncyCastle.Asn1.BerSetGenerator : BerGenerator {
    public BerSetGenerator(Stream outStream);
    public BerSetGenerator(Stream outStream, int tagNo, bool isExplicit);
}
public class Org.BouncyCastle.Asn1.BerSetParser : object {
    private Asn1StreamParser _parser;
    internal BerSetParser(Asn1StreamParser parser);
    public sealed virtual IAsn1Convertible ReadObject();
    public sealed virtual Asn1Object ToAsn1Object();
    internal static BerSet Parse(Asn1StreamParser sp);
}
public class Org.BouncyCastle.Asn1.BerTaggedObject : DerTaggedObject {
    public BerTaggedObject(int tagNo, Asn1Encodable obj);
    public BerTaggedObject(bool explicitly, int tagNo, Asn1Encodable obj);
    public BerTaggedObject(int tagNo);
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
}
public class Org.BouncyCastle.Asn1.BerTaggedObjectParser : object {
    private bool _constructed;
    private int _tagNumber;
    private Asn1StreamParser _parser;
    public bool IsConstructed { get; }
    public int TagNo { get; }
    [ObsoleteAttribute]
internal BerTaggedObjectParser(int baseTag, int tagNumber, Stream contentStream);
    internal BerTaggedObjectParser(bool constructed, int tagNumber, Asn1StreamParser parser);
    public bool get_IsConstructed();
    public sealed virtual int get_TagNo();
    public sealed virtual IAsn1Convertible GetObjectParser(int tag, bool isExplicit);
    public sealed virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Bsi.BsiObjectIdentifiers : object {
    public static DerObjectIdentifier bsi_de;
    public static DerObjectIdentifier id_ecc;
    public static DerObjectIdentifier ecdsa_plain_signatures;
    public static DerObjectIdentifier ecdsa_plain_SHA1;
    public static DerObjectIdentifier ecdsa_plain_SHA224;
    public static DerObjectIdentifier ecdsa_plain_SHA256;
    public static DerObjectIdentifier ecdsa_plain_SHA384;
    public static DerObjectIdentifier ecdsa_plain_SHA512;
    public static DerObjectIdentifier ecdsa_plain_RIPEMD160;
    public static DerObjectIdentifier algorithm;
    public static DerObjectIdentifier ecka_eg;
    public static DerObjectIdentifier ecka_eg_X963kdf;
    public static DerObjectIdentifier ecka_eg_X963kdf_SHA1;
    public static DerObjectIdentifier ecka_eg_X963kdf_SHA224;
    public static DerObjectIdentifier ecka_eg_X963kdf_SHA256;
    public static DerObjectIdentifier ecka_eg_X963kdf_SHA384;
    public static DerObjectIdentifier ecka_eg_X963kdf_SHA512;
    public static DerObjectIdentifier ecka_eg_X963kdf_RIPEMD160;
    public static DerObjectIdentifier ecka_eg_SessionKDF;
    public static DerObjectIdentifier ecka_eg_SessionKDF_3DES;
    public static DerObjectIdentifier ecka_eg_SessionKDF_AES128;
    public static DerObjectIdentifier ecka_eg_SessionKDF_AES192;
    public static DerObjectIdentifier ecka_eg_SessionKDF_AES256;
    private static BsiObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Cmp.CAKeyUpdAnnContent : Asn1Encodable {
    private CmpCertificate oldWithNew;
    private CmpCertificate newWithOld;
    private CmpCertificate newWithNew;
    public CmpCertificate OldWithNew { get; }
    public CmpCertificate NewWithOld { get; }
    public CmpCertificate NewWithNew { get; }
    private CAKeyUpdAnnContent(Asn1Sequence seq);
    public static CAKeyUpdAnnContent GetInstance(object obj);
    public virtual CmpCertificate get_OldWithNew();
    public virtual CmpCertificate get_NewWithOld();
    public virtual CmpCertificate get_NewWithNew();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.CertConfirmContent : Asn1Encodable {
    private Asn1Sequence content;
    private CertConfirmContent(Asn1Sequence seq);
    public static CertConfirmContent GetInstance(object obj);
    public virtual CertStatus[] ToCertStatusArray();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.CertifiedKeyPair : Asn1Encodable {
    private CertOrEncCert certOrEncCert;
    private EncryptedValue privateKey;
    private PkiPublicationInfo publicationInfo;
    public CertOrEncCert CertOrEncCert { get; }
    public EncryptedValue PrivateKey { get; }
    public PkiPublicationInfo PublicationInfo { get; }
    private CertifiedKeyPair(Asn1Sequence seq);
    public CertifiedKeyPair(CertOrEncCert certOrEncCert);
    public CertifiedKeyPair(CertOrEncCert certOrEncCert, EncryptedValue privateKey, PkiPublicationInfo publicationInfo);
    public static CertifiedKeyPair GetInstance(object obj);
    public virtual CertOrEncCert get_CertOrEncCert();
    public virtual EncryptedValue get_PrivateKey();
    public virtual PkiPublicationInfo get_PublicationInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.CertOrEncCert : Asn1Encodable {
    private CmpCertificate certificate;
    private EncryptedValue encryptedCert;
    public CmpCertificate Certificate { get; }
    public EncryptedValue EncryptedCert { get; }
    private CertOrEncCert(Asn1TaggedObject tagged);
    public CertOrEncCert(CmpCertificate certificate);
    public CertOrEncCert(EncryptedValue encryptedCert);
    public static CertOrEncCert GetInstance(object obj);
    public virtual CmpCertificate get_Certificate();
    public virtual EncryptedValue get_EncryptedCert();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.CertRepMessage : Asn1Encodable {
    private Asn1Sequence caPubs;
    private Asn1Sequence response;
    private CertRepMessage(Asn1Sequence seq);
    public CertRepMessage(CmpCertificate[] caPubs, CertResponse[] response);
    public static CertRepMessage GetInstance(object obj);
    public virtual CmpCertificate[] GetCAPubs();
    public virtual CertResponse[] GetResponse();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.CertResponse : Asn1Encodable {
    private DerInteger certReqId;
    private PkiStatusInfo status;
    private CertifiedKeyPair certifiedKeyPair;
    private Asn1OctetString rspInfo;
    public DerInteger CertReqID { get; }
    public PkiStatusInfo Status { get; }
    public CertifiedKeyPair CertifiedKeyPair { get; }
    private CertResponse(Asn1Sequence seq);
    public CertResponse(DerInteger certReqId, PkiStatusInfo status);
    public CertResponse(DerInteger certReqId, PkiStatusInfo status, CertifiedKeyPair certifiedKeyPair, Asn1OctetString rspInfo);
    public static CertResponse GetInstance(object obj);
    public virtual DerInteger get_CertReqID();
    public virtual PkiStatusInfo get_Status();
    public virtual CertifiedKeyPair get_CertifiedKeyPair();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.CertStatus : Asn1Encodable {
    private Asn1OctetString certHash;
    private DerInteger certReqId;
    private PkiStatusInfo statusInfo;
    public Asn1OctetString CertHash { get; }
    public DerInteger CertReqID { get; }
    public PkiStatusInfo StatusInfo { get; }
    private CertStatus(Asn1Sequence seq);
    public CertStatus(Byte[] certHash, BigInteger certReqId);
    public CertStatus(Byte[] certHash, BigInteger certReqId, PkiStatusInfo statusInfo);
    public static CertStatus GetInstance(object obj);
    public virtual Asn1OctetString get_CertHash();
    public virtual DerInteger get_CertReqID();
    public virtual PkiStatusInfo get_StatusInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.Challenge : Asn1Encodable {
    private AlgorithmIdentifier owf;
    private Asn1OctetString witness;
    private Asn1OctetString challenge;
    public AlgorithmIdentifier Owf { get; }
    private Challenge(Asn1Sequence seq);
    public static Challenge GetInstance(object obj);
    public virtual AlgorithmIdentifier get_Owf();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.CmpCertificate : Asn1Encodable {
    private X509CertificateStructure x509v3PKCert;
    private AttributeCertificate x509v2AttrCert;
    public bool IsX509v3PKCert { get; }
    public X509CertificateStructure X509v3PKCert { get; }
    public AttributeCertificate X509v2AttrCert { get; }
    public CmpCertificate(AttributeCertificate x509v2AttrCert);
    public CmpCertificate(X509CertificateStructure x509v3PKCert);
    public static CmpCertificate GetInstance(object obj);
    public virtual bool get_IsX509v3PKCert();
    public virtual X509CertificateStructure get_X509v3PKCert();
    public virtual AttributeCertificate get_X509v2AttrCert();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers : object {
    public static DerObjectIdentifier passwordBasedMac;
    public static DerObjectIdentifier dhBasedMac;
    public static DerObjectIdentifier it_caProtEncCert;
    public static DerObjectIdentifier it_signKeyPairTypes;
    public static DerObjectIdentifier it_encKeyPairTypes;
    public static DerObjectIdentifier it_preferredSymAlg;
    public static DerObjectIdentifier it_caKeyUpdateInfo;
    public static DerObjectIdentifier it_currentCRL;
    public static DerObjectIdentifier it_unsupportedOIDs;
    public static DerObjectIdentifier it_keyPairParamReq;
    public static DerObjectIdentifier it_keyPairParamRep;
    public static DerObjectIdentifier it_revPassphrase;
    public static DerObjectIdentifier it_implicitConfirm;
    public static DerObjectIdentifier it_confirmWaitTime;
    public static DerObjectIdentifier it_origPKIMessage;
    public static DerObjectIdentifier it_suppLangTags;
    public static DerObjectIdentifier regCtrl_regToken;
    public static DerObjectIdentifier regCtrl_authenticator;
    public static DerObjectIdentifier regCtrl_pkiPublicationInfo;
    public static DerObjectIdentifier regCtrl_pkiArchiveOptions;
    public static DerObjectIdentifier regCtrl_oldCertID;
    public static DerObjectIdentifier regCtrl_protocolEncrKey;
    public static DerObjectIdentifier regCtrl_altCertTemplate;
    public static DerObjectIdentifier regInfo_utf8Pairs;
    public static DerObjectIdentifier regInfo_certReq;
    public static DerObjectIdentifier ct_encKeyWithID;
    private static CmpObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Cmp.CrlAnnContent : Asn1Encodable {
    private Asn1Sequence content;
    private CrlAnnContent(Asn1Sequence seq);
    public static CrlAnnContent GetInstance(object obj);
    public virtual CertificateList[] ToCertificateListArray();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.ErrorMsgContent : Asn1Encodable {
    private PkiStatusInfo pkiStatusInfo;
    private DerInteger errorCode;
    private PkiFreeText errorDetails;
    public PkiStatusInfo PkiStatusInfo { get; }
    public DerInteger ErrorCode { get; }
    public PkiFreeText ErrorDetails { get; }
    private ErrorMsgContent(Asn1Sequence seq);
    public ErrorMsgContent(PkiStatusInfo pkiStatusInfo);
    public ErrorMsgContent(PkiStatusInfo pkiStatusInfo, DerInteger errorCode, PkiFreeText errorDetails);
    public static ErrorMsgContent GetInstance(object obj);
    public virtual PkiStatusInfo get_PkiStatusInfo();
    public virtual DerInteger get_ErrorCode();
    public virtual PkiFreeText get_ErrorDetails();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.GenMsgContent : Asn1Encodable {
    private Asn1Sequence content;
    private GenMsgContent(Asn1Sequence seq);
    public GenMsgContent(InfoTypeAndValue[] itv);
    public static GenMsgContent GetInstance(object obj);
    public virtual InfoTypeAndValue[] ToInfoTypeAndValueArray();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.GenRepContent : Asn1Encodable {
    private Asn1Sequence content;
    private GenRepContent(Asn1Sequence seq);
    public GenRepContent(InfoTypeAndValue[] itv);
    public static GenRepContent GetInstance(object obj);
    public virtual InfoTypeAndValue[] ToInfoTypeAndValueArray();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.InfoTypeAndValue : Asn1Encodable {
    private DerObjectIdentifier infoType;
    private Asn1Encodable infoValue;
    public DerObjectIdentifier InfoType { get; }
    public Asn1Encodable InfoValue { get; }
    private InfoTypeAndValue(Asn1Sequence seq);
    public InfoTypeAndValue(DerObjectIdentifier infoType);
    public InfoTypeAndValue(DerObjectIdentifier infoType, Asn1Encodable optionalValue);
    public static InfoTypeAndValue GetInstance(object obj);
    public virtual DerObjectIdentifier get_InfoType();
    public virtual Asn1Encodable get_InfoValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.KeyRecRepContent : Asn1Encodable {
    private PkiStatusInfo status;
    private CmpCertificate newSigCert;
    private Asn1Sequence caCerts;
    private Asn1Sequence keyPairHist;
    public PkiStatusInfo Status { get; }
    public CmpCertificate NewSigCert { get; }
    private KeyRecRepContent(Asn1Sequence seq);
    public static KeyRecRepContent GetInstance(object obj);
    public virtual PkiStatusInfo get_Status();
    public virtual CmpCertificate get_NewSigCert();
    public virtual CmpCertificate[] GetCACerts();
    public virtual CertifiedKeyPair[] GetKeyPairHist();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.OobCertHash : Asn1Encodable {
    private AlgorithmIdentifier hashAlg;
    private CertId certId;
    private DerBitString hashVal;
    public AlgorithmIdentifier HashAlg { get; }
    public CertId CertID { get; }
    private OobCertHash(Asn1Sequence seq);
    public static OobCertHash GetInstance(object obj);
    public virtual AlgorithmIdentifier get_HashAlg();
    public virtual CertId get_CertID();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PbmParameter : Asn1Encodable {
    private Asn1OctetString salt;
    private AlgorithmIdentifier owf;
    private DerInteger iterationCount;
    private AlgorithmIdentifier mac;
    public Asn1OctetString Salt { get; }
    public AlgorithmIdentifier Owf { get; }
    public DerInteger IterationCount { get; }
    public AlgorithmIdentifier Mac { get; }
    private PbmParameter(Asn1Sequence seq);
    public PbmParameter(Byte[] salt, AlgorithmIdentifier owf, int iterationCount, AlgorithmIdentifier mac);
    public PbmParameter(Asn1OctetString salt, AlgorithmIdentifier owf, DerInteger iterationCount, AlgorithmIdentifier mac);
    public static PbmParameter GetInstance(object obj);
    public virtual Asn1OctetString get_Salt();
    public virtual AlgorithmIdentifier get_Owf();
    public virtual DerInteger get_IterationCount();
    public virtual AlgorithmIdentifier get_Mac();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PkiBody : Asn1Encodable {
    public static int TYPE_INIT_REQ;
    public static int TYPE_INIT_REP;
    public static int TYPE_CERT_REQ;
    public static int TYPE_CERT_REP;
    public static int TYPE_P10_CERT_REQ;
    public static int TYPE_POPO_CHALL;
    public static int TYPE_POPO_REP;
    public static int TYPE_KEY_UPDATE_REQ;
    public static int TYPE_KEY_UPDATE_REP;
    public static int TYPE_KEY_RECOVERY_REQ;
    public static int TYPE_KEY_RECOVERY_REP;
    public static int TYPE_REVOCATION_REQ;
    public static int TYPE_REVOCATION_REP;
    public static int TYPE_CROSS_CERT_REQ;
    public static int TYPE_CROSS_CERT_REP;
    public static int TYPE_CA_KEY_UPDATE_ANN;
    public static int TYPE_CERT_ANN;
    public static int TYPE_REVOCATION_ANN;
    public static int TYPE_CRL_ANN;
    public static int TYPE_CONFIRM;
    public static int TYPE_NESTED;
    public static int TYPE_GEN_MSG;
    public static int TYPE_GEN_REP;
    public static int TYPE_ERROR;
    public static int TYPE_CERT_CONFIRM;
    public static int TYPE_POLL_REQ;
    public static int TYPE_POLL_REP;
    private int tagNo;
    private Asn1Encodable body;
    public int Type { get; }
    public Asn1Encodable Content { get; }
    private PkiBody(Asn1TaggedObject tagged);
    public PkiBody(int type, Asn1Encodable content);
    public static PkiBody GetInstance(object obj);
    private static Asn1Encodable GetBodyForType(int type, Asn1Encodable o);
    public virtual int get_Type();
    public virtual Asn1Encodable get_Content();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PkiConfirmContent : Asn1Encodable {
    public static PkiConfirmContent GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PkiFailureInfo : DerBitString {
    public static int BadAlg;
    public static int BadMessageCheck;
    public static int BadRequest;
    public static int BadTime;
    public static int BadCertId;
    public static int BadDataFormat;
    public static int WrongAuthority;
    public static int IncorrectData;
    public static int MissingTimeStamp;
    public static int BadPop;
    public static int CertRevoked;
    public static int CertConfirmed;
    public static int WrongIntegrity;
    public static int BadRecipientNonce;
    public static int TimeNotAvailable;
    public static int UnacceptedPolicy;
    public static int UnacceptedExtension;
    public static int AddInfoNotAvailable;
    public static int BadSenderNonce;
    public static int BadCertTemplate;
    public static int SignerNotTrusted;
    public static int TransactionIdInUse;
    public static int UnsupportedVersion;
    public static int NotAuthorized;
    public static int SystemUnavail;
    public static int SystemFailure;
    public static int DuplicateCertReq;
    public PkiFailureInfo(int info);
    public PkiFailureInfo(DerBitString info);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Asn1.Cmp.PkiFreeText : Asn1Encodable {
    internal Asn1Sequence strings;
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    public DerUtf8String Item { get; }
    public PkiFreeText(Asn1Sequence seq);
    public PkiFreeText(DerUtf8String p);
    public static PkiFreeText GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static PkiFreeText GetInstance(object obj);
    public int get_Size();
    public int get_Count();
    public DerUtf8String get_Item(int index);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public DerUtf8String GetStringAt(int index);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PkiHeader : Asn1Encodable {
    public static GeneralName NULL_NAME;
    public static int CMP_1999;
    public static int CMP_2000;
    private DerInteger pvno;
    private GeneralName sender;
    private GeneralName recipient;
    private DerGeneralizedTime messageTime;
    private AlgorithmIdentifier protectionAlg;
    private Asn1OctetString senderKID;
    private Asn1OctetString recipKID;
    private Asn1OctetString transactionID;
    private Asn1OctetString senderNonce;
    private Asn1OctetString recipNonce;
    private PkiFreeText freeText;
    private Asn1Sequence generalInfo;
    public DerInteger Pvno { get; }
    public GeneralName Sender { get; }
    public GeneralName Recipient { get; }
    public DerGeneralizedTime MessageTime { get; }
    public AlgorithmIdentifier ProtectionAlg { get; }
    public Asn1OctetString SenderKID { get; }
    public Asn1OctetString RecipKID { get; }
    public Asn1OctetString TransactionID { get; }
    public Asn1OctetString SenderNonce { get; }
    public Asn1OctetString RecipNonce { get; }
    public PkiFreeText FreeText { get; }
    private PkiHeader(Asn1Sequence seq);
    public PkiHeader(int pvno, GeneralName sender, GeneralName recipient);
    private PkiHeader(DerInteger pvno, GeneralName sender, GeneralName recipient);
    private static PkiHeader();
    public static PkiHeader GetInstance(object obj);
    public virtual DerInteger get_Pvno();
    public virtual GeneralName get_Sender();
    public virtual GeneralName get_Recipient();
    public virtual DerGeneralizedTime get_MessageTime();
    public virtual AlgorithmIdentifier get_ProtectionAlg();
    public virtual Asn1OctetString get_SenderKID();
    public virtual Asn1OctetString get_RecipKID();
    public virtual Asn1OctetString get_TransactionID();
    public virtual Asn1OctetString get_SenderNonce();
    public virtual Asn1OctetString get_RecipNonce();
    public virtual PkiFreeText get_FreeText();
    public virtual InfoTypeAndValue[] GetGeneralInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PkiHeaderBuilder : object {
    private DerInteger pvno;
    private GeneralName sender;
    private GeneralName recipient;
    private DerGeneralizedTime messageTime;
    private AlgorithmIdentifier protectionAlg;
    private Asn1OctetString senderKID;
    private Asn1OctetString recipKID;
    private Asn1OctetString transactionID;
    private Asn1OctetString senderNonce;
    private Asn1OctetString recipNonce;
    private PkiFreeText freeText;
    private Asn1Sequence generalInfo;
    public PkiHeaderBuilder(int pvno, GeneralName sender, GeneralName recipient);
    private PkiHeaderBuilder(DerInteger pvno, GeneralName sender, GeneralName recipient);
    public virtual PkiHeaderBuilder SetMessageTime(DerGeneralizedTime time);
    public virtual PkiHeaderBuilder SetProtectionAlg(AlgorithmIdentifier aid);
    public virtual PkiHeaderBuilder SetSenderKID(Byte[] kid);
    public virtual PkiHeaderBuilder SetSenderKID(Asn1OctetString kid);
    public virtual PkiHeaderBuilder SetRecipKID(Byte[] kid);
    public virtual PkiHeaderBuilder SetRecipKID(Asn1OctetString kid);
    public virtual PkiHeaderBuilder SetTransactionID(Byte[] tid);
    public virtual PkiHeaderBuilder SetTransactionID(Asn1OctetString tid);
    public virtual PkiHeaderBuilder SetSenderNonce(Byte[] nonce);
    public virtual PkiHeaderBuilder SetSenderNonce(Asn1OctetString nonce);
    public virtual PkiHeaderBuilder SetRecipNonce(Byte[] nonce);
    public virtual PkiHeaderBuilder SetRecipNonce(Asn1OctetString nonce);
    public virtual PkiHeaderBuilder SetFreeText(PkiFreeText text);
    public virtual PkiHeaderBuilder SetGeneralInfo(InfoTypeAndValue genInfo);
    public virtual PkiHeaderBuilder SetGeneralInfo(InfoTypeAndValue[] genInfos);
    public virtual PkiHeaderBuilder SetGeneralInfo(Asn1Sequence seqOfInfoTypeAndValue);
    private static Asn1Sequence MakeGeneralInfoSeq(InfoTypeAndValue generalInfo);
    private static Asn1Sequence MakeGeneralInfoSeq(InfoTypeAndValue[] generalInfos);
    public virtual PkiHeader Build();
    private void AddOptional(Asn1EncodableVector v, int tagNo, Asn1Encodable obj);
}
public class Org.BouncyCastle.Asn1.Cmp.PkiMessage : Asn1Encodable {
    private PkiHeader header;
    private PkiBody body;
    private DerBitString protection;
    private Asn1Sequence extraCerts;
    public PkiHeader Header { get; }
    public PkiBody Body { get; }
    public DerBitString Protection { get; }
    private PkiMessage(Asn1Sequence seq);
    public PkiMessage(PkiHeader header, PkiBody body, DerBitString protection, CmpCertificate[] extraCerts);
    public PkiMessage(PkiHeader header, PkiBody body, DerBitString protection);
    public PkiMessage(PkiHeader header, PkiBody body);
    public static PkiMessage GetInstance(object obj);
    public virtual PkiHeader get_Header();
    public virtual PkiBody get_Body();
    public virtual DerBitString get_Protection();
    public virtual CmpCertificate[] GetExtraCerts();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PkiMessages : Asn1Encodable {
    private Asn1Sequence content;
    private PkiMessages(Asn1Sequence seq);
    public PkiMessages(PkiMessage[] msgs);
    public static PkiMessages GetInstance(object obj);
    public virtual PkiMessage[] ToPkiMessageArray();
    public virtual Asn1Object ToAsn1Object();
}
public enum Org.BouncyCastle.Asn1.Cmp.PkiStatus : Enum {
    public int value__;
    public static PkiStatus Granted;
    public static PkiStatus GrantedWithMods;
    public static PkiStatus Rejection;
    public static PkiStatus Waiting;
    public static PkiStatus RevocationWarning;
    public static PkiStatus RevocationNotification;
    public static PkiStatus KeyUpdateWarning;
}
public class Org.BouncyCastle.Asn1.Cmp.PkiStatusEncodable : Asn1Encodable {
    public static PkiStatusEncodable granted;
    public static PkiStatusEncodable grantedWithMods;
    public static PkiStatusEncodable rejection;
    public static PkiStatusEncodable waiting;
    public static PkiStatusEncodable revocationWarning;
    public static PkiStatusEncodable revocationNotification;
    public static PkiStatusEncodable keyUpdateWaiting;
    private DerInteger status;
    public BigInteger Value { get; }
    private PkiStatusEncodable(PkiStatus status);
    private PkiStatusEncodable(DerInteger status);
    private static PkiStatusEncodable();
    public static PkiStatusEncodable GetInstance(object obj);
    public virtual BigInteger get_Value();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PkiStatusInfo : Asn1Encodable {
    private DerInteger status;
    private PkiFreeText statusString;
    private DerBitString failInfo;
    public BigInteger Status { get; }
    public PkiFreeText StatusString { get; }
    public DerBitString FailInfo { get; }
    public PkiStatusInfo(Asn1Sequence seq);
    public PkiStatusInfo(int status);
    public PkiStatusInfo(int status, PkiFreeText statusString);
    public PkiStatusInfo(int status, PkiFreeText statusString, PkiFailureInfo failInfo);
    public static PkiStatusInfo GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static PkiStatusInfo GetInstance(object obj);
    public BigInteger get_Status();
    public PkiFreeText get_StatusString();
    public DerBitString get_FailInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PollRepContent : Asn1Encodable {
    private DerInteger certReqId;
    private DerInteger checkAfter;
    private PkiFreeText reason;
    public DerInteger CertReqID { get; }
    public DerInteger CheckAfter { get; }
    public PkiFreeText Reason { get; }
    private PollRepContent(Asn1Sequence seq);
    public PollRepContent(DerInteger certReqId, DerInteger checkAfter);
    public PollRepContent(DerInteger certReqId, DerInteger checkAfter, PkiFreeText reason);
    public static PollRepContent GetInstance(object obj);
    public virtual DerInteger get_CertReqID();
    public virtual DerInteger get_CheckAfter();
    public virtual PkiFreeText get_Reason();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PollReqContent : Asn1Encodable {
    private Asn1Sequence content;
    private PollReqContent(Asn1Sequence seq);
    public static PollReqContent GetInstance(object obj);
    public virtual DerInteger[][] GetCertReqIDs();
    private static DerInteger[] SequenceToDerIntegerArray(Asn1Sequence seq);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PopoDecKeyChallContent : Asn1Encodable {
    private Asn1Sequence content;
    private PopoDecKeyChallContent(Asn1Sequence seq);
    public static PopoDecKeyChallContent GetInstance(object obj);
    public virtual Challenge[] ToChallengeArray();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PopoDecKeyRespContent : Asn1Encodable {
    private Asn1Sequence content;
    private PopoDecKeyRespContent(Asn1Sequence seq);
    public static PopoDecKeyRespContent GetInstance(object obj);
    public virtual DerInteger[] ToDerIntegerArray();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.ProtectedPart : Asn1Encodable {
    private PkiHeader header;
    private PkiBody body;
    public PkiHeader Header { get; }
    public PkiBody Body { get; }
    private ProtectedPart(Asn1Sequence seq);
    public ProtectedPart(PkiHeader header, PkiBody body);
    public static ProtectedPart GetInstance(object obj);
    public virtual PkiHeader get_Header();
    public virtual PkiBody get_Body();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.RevAnnContent : Asn1Encodable {
    private PkiStatusEncodable status;
    private CertId certId;
    private DerGeneralizedTime willBeRevokedAt;
    private DerGeneralizedTime badSinceDate;
    private X509Extensions crlDetails;
    public PkiStatusEncodable Status { get; }
    public CertId CertID { get; }
    public DerGeneralizedTime WillBeRevokedAt { get; }
    public DerGeneralizedTime BadSinceDate { get; }
    public X509Extensions CrlDetails { get; }
    private RevAnnContent(Asn1Sequence seq);
    public static RevAnnContent GetInstance(object obj);
    public virtual PkiStatusEncodable get_Status();
    public virtual CertId get_CertID();
    public virtual DerGeneralizedTime get_WillBeRevokedAt();
    public virtual DerGeneralizedTime get_BadSinceDate();
    public virtual X509Extensions get_CrlDetails();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.RevDetails : Asn1Encodable {
    private CertTemplate certDetails;
    private X509Extensions crlEntryDetails;
    public CertTemplate CertDetails { get; }
    public X509Extensions CrlEntryDetails { get; }
    private RevDetails(Asn1Sequence seq);
    public RevDetails(CertTemplate certDetails);
    public RevDetails(CertTemplate certDetails, X509Extensions crlEntryDetails);
    public static RevDetails GetInstance(object obj);
    public virtual CertTemplate get_CertDetails();
    public virtual X509Extensions get_CrlEntryDetails();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.RevRepContent : Asn1Encodable {
    private Asn1Sequence status;
    private Asn1Sequence revCerts;
    private Asn1Sequence crls;
    private RevRepContent(Asn1Sequence seq);
    public static RevRepContent GetInstance(object obj);
    public virtual PkiStatusInfo[] GetStatus();
    public virtual CertId[] GetRevCerts();
    public virtual CertificateList[] GetCrls();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.RevRepContentBuilder : object {
    private Asn1EncodableVector status;
    private Asn1EncodableVector revCerts;
    private Asn1EncodableVector crls;
    public virtual RevRepContentBuilder Add(PkiStatusInfo status);
    public virtual RevRepContentBuilder Add(PkiStatusInfo status, CertId certId);
    public virtual RevRepContentBuilder AddCrl(CertificateList crl);
    public virtual RevRepContent Build();
}
public class Org.BouncyCastle.Asn1.Cmp.RevReqContent : Asn1Encodable {
    private Asn1Sequence content;
    private RevReqContent(Asn1Sequence seq);
    public RevReqContent(RevDetails[] revDetails);
    public static RevReqContent GetInstance(object obj);
    public virtual RevDetails[] ToRevDetailsArray();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.Attribute : Asn1Encodable {
    private DerObjectIdentifier attrType;
    private Asn1Set attrValues;
    public DerObjectIdentifier AttrType { get; }
    public Asn1Set AttrValues { get; }
    public Attribute(Asn1Sequence seq);
    public Attribute(DerObjectIdentifier attrType, Asn1Set attrValues);
    public static Attribute GetInstance(object obj);
    public DerObjectIdentifier get_AttrType();
    public Asn1Set get_AttrValues();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.Attributes : Asn1Encodable {
    private Asn1Set attributes;
    private Attributes(Asn1Set attributes);
    public Attributes(Asn1EncodableVector v);
    public static Attributes GetInstance(object obj);
    public virtual Attribute[] GetAttributes();
    public virtual Asn1Object ToAsn1Object();
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Asn1.Cms.AttributeTable : object {
    private IDictionary attributes;
    public Attribute Item { get; }
    public int Count { get; }
    [ObsoleteAttribute]
public AttributeTable(Hashtable attrs);
    public AttributeTable(IDictionary attrs);
    public AttributeTable(Asn1EncodableVector v);
    public AttributeTable(Asn1Set s);
    public AttributeTable(Attributes attrs);
    private void AddAttribute(Attribute a);
    public Attribute get_Item(DerObjectIdentifier oid);
    [ObsoleteAttribute("Use 'object[oid]' syntax instead")]
public Attribute Get(DerObjectIdentifier oid);
    public Asn1EncodableVector GetAll(DerObjectIdentifier oid);
    public int get_Count();
    public IDictionary ToDictionary();
    [ObsoleteAttribute("Use 'ToDictionary' instead")]
public Hashtable ToHashtable();
    public Asn1EncodableVector ToAsn1EncodableVector();
    public Attributes ToAttributes();
    public AttributeTable Add(DerObjectIdentifier attrType, Asn1Encodable attrValue);
    public AttributeTable Remove(DerObjectIdentifier attrType);
}
public class Org.BouncyCastle.Asn1.Cms.AuthenticatedData : Asn1Encodable {
    private DerInteger version;
    private OriginatorInfo originatorInfo;
    private Asn1Set recipientInfos;
    private AlgorithmIdentifier macAlgorithm;
    private AlgorithmIdentifier digestAlgorithm;
    private ContentInfo encapsulatedContentInfo;
    private Asn1Set authAttrs;
    private Asn1OctetString mac;
    private Asn1Set unauthAttrs;
    public DerInteger Version { get; }
    public OriginatorInfo OriginatorInfo { get; }
    public Asn1Set RecipientInfos { get; }
    public AlgorithmIdentifier MacAlgorithm { get; }
    public AlgorithmIdentifier DigestAlgorithm { get; }
    public ContentInfo EncapsulatedContentInfo { get; }
    public Asn1Set AuthAttrs { get; }
    public Asn1OctetString Mac { get; }
    public Asn1Set UnauthAttrs { get; }
    public AuthenticatedData(OriginatorInfo originatorInfo, Asn1Set recipientInfos, AlgorithmIdentifier macAlgorithm, AlgorithmIdentifier digestAlgorithm, ContentInfo encapsulatedContent, Asn1Set authAttrs, Asn1OctetString mac, Asn1Set unauthAttrs);
    private AuthenticatedData(Asn1Sequence seq);
    public static AuthenticatedData GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static AuthenticatedData GetInstance(object obj);
    public DerInteger get_Version();
    public OriginatorInfo get_OriginatorInfo();
    public Asn1Set get_RecipientInfos();
    public AlgorithmIdentifier get_MacAlgorithm();
    public AlgorithmIdentifier get_DigestAlgorithm();
    public ContentInfo get_EncapsulatedContentInfo();
    public Asn1Set get_AuthAttrs();
    public Asn1OctetString get_Mac();
    public Asn1Set get_UnauthAttrs();
    public virtual Asn1Object ToAsn1Object();
    public static int CalculateVersion(OriginatorInfo origInfo);
}
public class Org.BouncyCastle.Asn1.Cms.AuthenticatedDataParser : object {
    private Asn1SequenceParser seq;
    private DerInteger version;
    private IAsn1Convertible nextObject;
    private bool originatorInfoCalled;
    public DerInteger Version { get; }
    public AuthenticatedDataParser(Asn1SequenceParser seq);
    public DerInteger get_Version();
    public OriginatorInfo GetOriginatorInfo();
    public Asn1SetParser GetRecipientInfos();
    public AlgorithmIdentifier GetMacAlgorithm();
    public AlgorithmIdentifier GetDigestAlgorithm();
    public ContentInfoParser GetEnapsulatedContentInfo();
    public Asn1SetParser GetAuthAttrs();
    public Asn1OctetString GetMac();
    public Asn1SetParser GetUnauthAttrs();
}
public class Org.BouncyCastle.Asn1.Cms.AuthEnvelopedData : Asn1Encodable {
    private DerInteger version;
    private OriginatorInfo originatorInfo;
    private Asn1Set recipientInfos;
    private EncryptedContentInfo authEncryptedContentInfo;
    private Asn1Set authAttrs;
    private Asn1OctetString mac;
    private Asn1Set unauthAttrs;
    public DerInteger Version { get; }
    public OriginatorInfo OriginatorInfo { get; }
    public Asn1Set RecipientInfos { get; }
    public EncryptedContentInfo AuthEncryptedContentInfo { get; }
    public Asn1Set AuthAttrs { get; }
    public Asn1OctetString Mac { get; }
    public Asn1Set UnauthAttrs { get; }
    public AuthEnvelopedData(OriginatorInfo originatorInfo, Asn1Set recipientInfos, EncryptedContentInfo authEncryptedContentInfo, Asn1Set authAttrs, Asn1OctetString mac, Asn1Set unauthAttrs);
    private AuthEnvelopedData(Asn1Sequence seq);
    public static AuthEnvelopedData GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static AuthEnvelopedData GetInstance(object obj);
    public DerInteger get_Version();
    public OriginatorInfo get_OriginatorInfo();
    public Asn1Set get_RecipientInfos();
    public EncryptedContentInfo get_AuthEncryptedContentInfo();
    public Asn1Set get_AuthAttrs();
    public Asn1OctetString get_Mac();
    public Asn1Set get_UnauthAttrs();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.AuthEnvelopedDataParser : object {
    private Asn1SequenceParser seq;
    private DerInteger version;
    private IAsn1Convertible nextObject;
    private bool originatorInfoCalled;
    private bool isData;
    public DerInteger Version { get; }
    public AuthEnvelopedDataParser(Asn1SequenceParser seq);
    public DerInteger get_Version();
    public OriginatorInfo GetOriginatorInfo();
    public Asn1SetParser GetRecipientInfos();
    public EncryptedContentInfoParser GetAuthEncryptedContentInfo();
    public Asn1SetParser GetAuthAttrs();
    public Asn1OctetString GetMac();
    public Asn1SetParser GetUnauthAttrs();
}
public abstract class Org.BouncyCastle.Asn1.Cms.CmsAttributes : object {
    public static DerObjectIdentifier ContentType;
    public static DerObjectIdentifier MessageDigest;
    public static DerObjectIdentifier SigningTime;
    public static DerObjectIdentifier CounterSignature;
    public static DerObjectIdentifier ContentHint;
    private static CmsAttributes();
}
public abstract class Org.BouncyCastle.Asn1.Cms.CmsObjectIdentifiers : object {
    public static DerObjectIdentifier Data;
    public static DerObjectIdentifier SignedData;
    public static DerObjectIdentifier EnvelopedData;
    public static DerObjectIdentifier SignedAndEnvelopedData;
    public static DerObjectIdentifier DigestedData;
    public static DerObjectIdentifier EncryptedData;
    public static DerObjectIdentifier AuthenticatedData;
    public static DerObjectIdentifier CompressedData;
    public static DerObjectIdentifier AuthEnvelopedData;
    public static DerObjectIdentifier timestampedData;
    public static DerObjectIdentifier id_ri;
    public static DerObjectIdentifier id_ri_ocsp_response;
    public static DerObjectIdentifier id_ri_scvp;
    private static CmsObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Cms.CompressedData : Asn1Encodable {
    private DerInteger version;
    private AlgorithmIdentifier compressionAlgorithm;
    private ContentInfo encapContentInfo;
    public DerInteger Version { get; }
    public AlgorithmIdentifier CompressionAlgorithmIdentifier { get; }
    public ContentInfo EncapContentInfo { get; }
    public CompressedData(AlgorithmIdentifier compressionAlgorithm, ContentInfo encapContentInfo);
    public CompressedData(Asn1Sequence seq);
    public static CompressedData GetInstance(Asn1TaggedObject ato, bool explicitly);
    public static CompressedData GetInstance(object obj);
    public DerInteger get_Version();
    public AlgorithmIdentifier get_CompressionAlgorithmIdentifier();
    public ContentInfo get_EncapContentInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.CompressedDataParser : object {
    private DerInteger _version;
    private AlgorithmIdentifier _compressionAlgorithm;
    private ContentInfoParser _encapContentInfo;
    public DerInteger Version { get; }
    public AlgorithmIdentifier CompressionAlgorithmIdentifier { get; }
    public CompressedDataParser(Asn1SequenceParser seq);
    public DerInteger get_Version();
    public AlgorithmIdentifier get_CompressionAlgorithmIdentifier();
    public ContentInfoParser GetEncapContentInfo();
}
public class Org.BouncyCastle.Asn1.Cms.ContentInfo : Asn1Encodable {
    private DerObjectIdentifier contentType;
    private Asn1Encodable content;
    public DerObjectIdentifier ContentType { get; }
    public Asn1Encodable Content { get; }
    private ContentInfo(Asn1Sequence seq);
    public ContentInfo(DerObjectIdentifier contentType, Asn1Encodable content);
    public static ContentInfo GetInstance(object obj);
    public static ContentInfo GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public DerObjectIdentifier get_ContentType();
    public Asn1Encodable get_Content();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.ContentInfoParser : object {
    private DerObjectIdentifier contentType;
    private Asn1TaggedObjectParser content;
    public DerObjectIdentifier ContentType { get; }
    public ContentInfoParser(Asn1SequenceParser seq);
    public DerObjectIdentifier get_ContentType();
    public IAsn1Convertible GetContent(int tag);
}
public class Org.BouncyCastle.Asn1.Cms.Ecc.MQVuserKeyingMaterial : Asn1Encodable {
    private OriginatorPublicKey ephemeralPublicKey;
    private Asn1OctetString addedukm;
    public OriginatorPublicKey EphemeralPublicKey { get; }
    public Asn1OctetString AddedUkm { get; }
    public MQVuserKeyingMaterial(OriginatorPublicKey ephemeralPublicKey, Asn1OctetString addedukm);
    private MQVuserKeyingMaterial(Asn1Sequence seq);
    public static MQVuserKeyingMaterial GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static MQVuserKeyingMaterial GetInstance(object obj);
    public OriginatorPublicKey get_EphemeralPublicKey();
    public Asn1OctetString get_AddedUkm();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.EncryptedContentInfo : Asn1Encodable {
    private DerObjectIdentifier contentType;
    private AlgorithmIdentifier contentEncryptionAlgorithm;
    private Asn1OctetString encryptedContent;
    public DerObjectIdentifier ContentType { get; }
    public AlgorithmIdentifier ContentEncryptionAlgorithm { get; }
    public Asn1OctetString EncryptedContent { get; }
    public EncryptedContentInfo(DerObjectIdentifier contentType, AlgorithmIdentifier contentEncryptionAlgorithm, Asn1OctetString encryptedContent);
    public EncryptedContentInfo(Asn1Sequence seq);
    public static EncryptedContentInfo GetInstance(object obj);
    public DerObjectIdentifier get_ContentType();
    public AlgorithmIdentifier get_ContentEncryptionAlgorithm();
    public Asn1OctetString get_EncryptedContent();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.EncryptedContentInfoParser : object {
    private DerObjectIdentifier _contentType;
    private AlgorithmIdentifier _contentEncryptionAlgorithm;
    private Asn1TaggedObjectParser _encryptedContent;
    public DerObjectIdentifier ContentType { get; }
    public AlgorithmIdentifier ContentEncryptionAlgorithm { get; }
    public EncryptedContentInfoParser(Asn1SequenceParser seq);
    public DerObjectIdentifier get_ContentType();
    public AlgorithmIdentifier get_ContentEncryptionAlgorithm();
    public IAsn1Convertible GetEncryptedContent(int tag);
}
public class Org.BouncyCastle.Asn1.Cms.EncryptedData : Asn1Encodable {
    private DerInteger version;
    private EncryptedContentInfo encryptedContentInfo;
    private Asn1Set unprotectedAttrs;
    public DerInteger Version { get; }
    public EncryptedContentInfo EncryptedContentInfo { get; }
    public Asn1Set UnprotectedAttrs { get; }
    public EncryptedData(EncryptedContentInfo encInfo);
    public EncryptedData(EncryptedContentInfo encInfo, Asn1Set unprotectedAttrs);
    private EncryptedData(Asn1Sequence seq);
    public static EncryptedData GetInstance(object obj);
    public virtual DerInteger get_Version();
    public virtual EncryptedContentInfo get_EncryptedContentInfo();
    public virtual Asn1Set get_UnprotectedAttrs();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.EnvelopedData : Asn1Encodable {
    private DerInteger version;
    private OriginatorInfo originatorInfo;
    private Asn1Set recipientInfos;
    private EncryptedContentInfo encryptedContentInfo;
    private Asn1Set unprotectedAttrs;
    public DerInteger Version { get; }
    public OriginatorInfo OriginatorInfo { get; }
    public Asn1Set RecipientInfos { get; }
    public EncryptedContentInfo EncryptedContentInfo { get; }
    public Asn1Set UnprotectedAttrs { get; }
    public EnvelopedData(OriginatorInfo originatorInfo, Asn1Set recipientInfos, EncryptedContentInfo encryptedContentInfo, Asn1Set unprotectedAttrs);
    public EnvelopedData(OriginatorInfo originatorInfo, Asn1Set recipientInfos, EncryptedContentInfo encryptedContentInfo, Attributes unprotectedAttrs);
    [ObsoleteAttribute("Use 'GetInstance' instead")]
public EnvelopedData(Asn1Sequence seq);
    public static EnvelopedData GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static EnvelopedData GetInstance(object obj);
    public DerInteger get_Version();
    public OriginatorInfo get_OriginatorInfo();
    public Asn1Set get_RecipientInfos();
    public EncryptedContentInfo get_EncryptedContentInfo();
    public Asn1Set get_UnprotectedAttrs();
    public virtual Asn1Object ToAsn1Object();
    public static int CalculateVersion(OriginatorInfo originatorInfo, Asn1Set recipientInfos, Asn1Set unprotectedAttrs);
}
public class Org.BouncyCastle.Asn1.Cms.EnvelopedDataParser : object {
    private Asn1SequenceParser _seq;
    private DerInteger _version;
    private IAsn1Convertible _nextObject;
    private bool _originatorInfoCalled;
    public DerInteger Version { get; }
    public EnvelopedDataParser(Asn1SequenceParser seq);
    public DerInteger get_Version();
    public OriginatorInfo GetOriginatorInfo();
    public Asn1SetParser GetRecipientInfos();
    public EncryptedContentInfoParser GetEncryptedContentInfo();
    public Asn1SetParser GetUnprotectedAttrs();
}
public class Org.BouncyCastle.Asn1.Cms.Evidence : Asn1Encodable {
    private TimeStampTokenEvidence tstEvidence;
    private Asn1Sequence otherEvidence;
    public TimeStampTokenEvidence TstEvidence { get; }
    public Evidence(TimeStampTokenEvidence tstEvidence);
    private Evidence(Asn1TaggedObject tagged);
    public static Evidence GetInstance(object obj);
    public static Evidence GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual TimeStampTokenEvidence get_TstEvidence();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.IssuerAndSerialNumber : Asn1Encodable {
    private X509Name name;
    private DerInteger serialNumber;
    public X509Name Name { get; }
    public DerInteger SerialNumber { get; }
    [ObsoleteAttribute("Use GetInstance() instead")]
public IssuerAndSerialNumber(Asn1Sequence seq);
    public IssuerAndSerialNumber(X509Name name, BigInteger serialNumber);
    public IssuerAndSerialNumber(X509Name name, DerInteger serialNumber);
    public static IssuerAndSerialNumber GetInstance(object obj);
    public X509Name get_Name();
    public DerInteger get_SerialNumber();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.KekIdentifier : Asn1Encodable {
    private Asn1OctetString keyIdentifier;
    private DerGeneralizedTime date;
    private OtherKeyAttribute other;
    public Asn1OctetString KeyIdentifier { get; }
    public DerGeneralizedTime Date { get; }
    public OtherKeyAttribute Other { get; }
    public KekIdentifier(Byte[] keyIdentifier, DerGeneralizedTime date, OtherKeyAttribute other);
    public KekIdentifier(Asn1Sequence seq);
    public static KekIdentifier GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static KekIdentifier GetInstance(object obj);
    public Asn1OctetString get_KeyIdentifier();
    public DerGeneralizedTime get_Date();
    public OtherKeyAttribute get_Other();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.KekRecipientInfo : Asn1Encodable {
    private DerInteger version;
    private KekIdentifier kekID;
    private AlgorithmIdentifier keyEncryptionAlgorithm;
    private Asn1OctetString encryptedKey;
    public DerInteger Version { get; }
    public KekIdentifier KekID { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Asn1OctetString EncryptedKey { get; }
    public KekRecipientInfo(KekIdentifier kekID, AlgorithmIdentifier keyEncryptionAlgorithm, Asn1OctetString encryptedKey);
    public KekRecipientInfo(Asn1Sequence seq);
    public static KekRecipientInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static KekRecipientInfo GetInstance(object obj);
    public DerInteger get_Version();
    public KekIdentifier get_KekID();
    public AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public Asn1OctetString get_EncryptedKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientIdentifier : Asn1Encodable {
    private IssuerAndSerialNumber issuerSerial;
    private RecipientKeyIdentifier rKeyID;
    public IssuerAndSerialNumber IssuerAndSerialNumber { get; }
    public RecipientKeyIdentifier RKeyID { get; }
    public KeyAgreeRecipientIdentifier(IssuerAndSerialNumber issuerSerial);
    public KeyAgreeRecipientIdentifier(RecipientKeyIdentifier rKeyID);
    public static KeyAgreeRecipientIdentifier GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static KeyAgreeRecipientIdentifier GetInstance(object obj);
    public IssuerAndSerialNumber get_IssuerAndSerialNumber();
    public RecipientKeyIdentifier get_RKeyID();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientInfo : Asn1Encodable {
    private DerInteger version;
    private OriginatorIdentifierOrKey originator;
    private Asn1OctetString ukm;
    private AlgorithmIdentifier keyEncryptionAlgorithm;
    private Asn1Sequence recipientEncryptedKeys;
    public DerInteger Version { get; }
    public OriginatorIdentifierOrKey Originator { get; }
    public Asn1OctetString UserKeyingMaterial { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Asn1Sequence RecipientEncryptedKeys { get; }
    public KeyAgreeRecipientInfo(OriginatorIdentifierOrKey originator, Asn1OctetString ukm, AlgorithmIdentifier keyEncryptionAlgorithm, Asn1Sequence recipientEncryptedKeys);
    public KeyAgreeRecipientInfo(Asn1Sequence seq);
    public static KeyAgreeRecipientInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static KeyAgreeRecipientInfo GetInstance(object obj);
    public DerInteger get_Version();
    public OriginatorIdentifierOrKey get_Originator();
    public Asn1OctetString get_UserKeyingMaterial();
    public AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public Asn1Sequence get_RecipientEncryptedKeys();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.KeyTransRecipientInfo : Asn1Encodable {
    private DerInteger version;
    private RecipientIdentifier rid;
    private AlgorithmIdentifier keyEncryptionAlgorithm;
    private Asn1OctetString encryptedKey;
    public DerInteger Version { get; }
    public RecipientIdentifier RecipientIdentifier { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Asn1OctetString EncryptedKey { get; }
    public KeyTransRecipientInfo(RecipientIdentifier rid, AlgorithmIdentifier keyEncryptionAlgorithm, Asn1OctetString encryptedKey);
    public KeyTransRecipientInfo(Asn1Sequence seq);
    public static KeyTransRecipientInfo GetInstance(object obj);
    public DerInteger get_Version();
    public RecipientIdentifier get_RecipientIdentifier();
    public AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public Asn1OctetString get_EncryptedKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.MetaData : Asn1Encodable {
    private DerBoolean hashProtected;
    private DerUtf8String fileName;
    private DerIA5String mediaType;
    private Attributes otherMetaData;
    public bool IsHashProtected { get; }
    public DerUtf8String FileName { get; }
    public DerIA5String MediaType { get; }
    public Attributes OtherMetaData { get; }
    public MetaData(DerBoolean hashProtected, DerUtf8String fileName, DerIA5String mediaType, Attributes otherMetaData);
    private MetaData(Asn1Sequence seq);
    public static MetaData GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public virtual bool get_IsHashProtected();
    public virtual DerUtf8String get_FileName();
    public virtual DerIA5String get_MediaType();
    public virtual Attributes get_OtherMetaData();
}
public class Org.BouncyCastle.Asn1.Cms.OriginatorIdentifierOrKey : Asn1Encodable {
    private Asn1Encodable id;
    public Asn1Encodable ID { get; }
    public IssuerAndSerialNumber IssuerAndSerialNumber { get; }
    public SubjectKeyIdentifier SubjectKeyIdentifier { get; }
    [ObsoleteAttribute("Use 'OriginatorPublicKey' property")]
public OriginatorPublicKey OriginatorKey { get; }
    public OriginatorPublicKey OriginatorPublicKey { get; }
    public OriginatorIdentifierOrKey(IssuerAndSerialNumber id);
    [ObsoleteAttribute("Use version taking a 'SubjectKeyIdentifier'")]
public OriginatorIdentifierOrKey(Asn1OctetString id);
    public OriginatorIdentifierOrKey(SubjectKeyIdentifier id);
    public OriginatorIdentifierOrKey(OriginatorPublicKey id);
    [ObsoleteAttribute("Use more specific version")]
public OriginatorIdentifierOrKey(Asn1Object id);
    private OriginatorIdentifierOrKey(Asn1TaggedObject id);
    public static OriginatorIdentifierOrKey GetInstance(Asn1TaggedObject o, bool explicitly);
    public static OriginatorIdentifierOrKey GetInstance(object o);
    public Asn1Encodable get_ID();
    public IssuerAndSerialNumber get_IssuerAndSerialNumber();
    public SubjectKeyIdentifier get_SubjectKeyIdentifier();
    public OriginatorPublicKey get_OriginatorKey();
    public OriginatorPublicKey get_OriginatorPublicKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.OriginatorInfo : Asn1Encodable {
    private Asn1Set certs;
    private Asn1Set crls;
    public Asn1Set Certificates { get; }
    public Asn1Set Crls { get; }
    public OriginatorInfo(Asn1Set certs, Asn1Set crls);
    public OriginatorInfo(Asn1Sequence seq);
    public static OriginatorInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static OriginatorInfo GetInstance(object obj);
    public Asn1Set get_Certificates();
    public Asn1Set get_Crls();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.OriginatorPublicKey : Asn1Encodable {
    private AlgorithmIdentifier mAlgorithm;
    private DerBitString mPublicKey;
    public AlgorithmIdentifier Algorithm { get; }
    public DerBitString PublicKey { get; }
    public OriginatorPublicKey(AlgorithmIdentifier algorithm, Byte[] publicKey);
    [ObsoleteAttribute("Use 'GetInstance' instead")]
public OriginatorPublicKey(Asn1Sequence seq);
    public static OriginatorPublicKey GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static OriginatorPublicKey GetInstance(object obj);
    public AlgorithmIdentifier get_Algorithm();
    public DerBitString get_PublicKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.OtherKeyAttribute : Asn1Encodable {
    private DerObjectIdentifier keyAttrId;
    private Asn1Encodable keyAttr;
    public DerObjectIdentifier KeyAttrId { get; }
    public Asn1Encodable KeyAttr { get; }
    public OtherKeyAttribute(Asn1Sequence seq);
    public OtherKeyAttribute(DerObjectIdentifier keyAttrId, Asn1Encodable keyAttr);
    public static OtherKeyAttribute GetInstance(object obj);
    public DerObjectIdentifier get_KeyAttrId();
    public Asn1Encodable get_KeyAttr();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.OtherRecipientInfo : Asn1Encodable {
    private DerObjectIdentifier oriType;
    private Asn1Encodable oriValue;
    public DerObjectIdentifier OriType { get; }
    public Asn1Encodable OriValue { get; }
    public OtherRecipientInfo(DerObjectIdentifier oriType, Asn1Encodable oriValue);
    [ObsoleteAttribute("Use GetInstance() instead")]
public OtherRecipientInfo(Asn1Sequence seq);
    public static OtherRecipientInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static OtherRecipientInfo GetInstance(object obj);
    public virtual DerObjectIdentifier get_OriType();
    public virtual Asn1Encodable get_OriValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.OtherRevocationInfoFormat : Asn1Encodable {
    private DerObjectIdentifier otherRevInfoFormat;
    private Asn1Encodable otherRevInfo;
    public DerObjectIdentifier InfoFormat { get; }
    public Asn1Encodable Info { get; }
    public OtherRevocationInfoFormat(DerObjectIdentifier otherRevInfoFormat, Asn1Encodable otherRevInfo);
    private OtherRevocationInfoFormat(Asn1Sequence seq);
    public static OtherRevocationInfoFormat GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static OtherRevocationInfoFormat GetInstance(object obj);
    public virtual DerObjectIdentifier get_InfoFormat();
    public virtual Asn1Encodable get_Info();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.PasswordRecipientInfo : Asn1Encodable {
    private DerInteger version;
    private AlgorithmIdentifier keyDerivationAlgorithm;
    private AlgorithmIdentifier keyEncryptionAlgorithm;
    private Asn1OctetString encryptedKey;
    public DerInteger Version { get; }
    public AlgorithmIdentifier KeyDerivationAlgorithm { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Asn1OctetString EncryptedKey { get; }
    public PasswordRecipientInfo(AlgorithmIdentifier keyEncryptionAlgorithm, Asn1OctetString encryptedKey);
    public PasswordRecipientInfo(AlgorithmIdentifier keyDerivationAlgorithm, AlgorithmIdentifier keyEncryptionAlgorithm, Asn1OctetString encryptedKey);
    public PasswordRecipientInfo(Asn1Sequence seq);
    public static PasswordRecipientInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static PasswordRecipientInfo GetInstance(object obj);
    public DerInteger get_Version();
    public AlgorithmIdentifier get_KeyDerivationAlgorithm();
    public AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public Asn1OctetString get_EncryptedKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.RecipientEncryptedKey : Asn1Encodable {
    private KeyAgreeRecipientIdentifier identifier;
    private Asn1OctetString encryptedKey;
    public KeyAgreeRecipientIdentifier Identifier { get; }
    public Asn1OctetString EncryptedKey { get; }
    private RecipientEncryptedKey(Asn1Sequence seq);
    public RecipientEncryptedKey(KeyAgreeRecipientIdentifier id, Asn1OctetString encryptedKey);
    public static RecipientEncryptedKey GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static RecipientEncryptedKey GetInstance(object obj);
    public KeyAgreeRecipientIdentifier get_Identifier();
    public Asn1OctetString get_EncryptedKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.RecipientIdentifier : Asn1Encodable {
    private Asn1Encodable id;
    public bool IsTagged { get; }
    public Asn1Encodable ID { get; }
    public RecipientIdentifier(IssuerAndSerialNumber id);
    public RecipientIdentifier(Asn1OctetString id);
    public RecipientIdentifier(Asn1Object id);
    public static RecipientIdentifier GetInstance(object o);
    public bool get_IsTagged();
    public Asn1Encodable get_ID();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.RecipientInfo : Asn1Encodable {
    internal Asn1Encodable info;
    public DerInteger Version { get; }
    public bool IsTagged { get; }
    public Asn1Encodable Info { get; }
    public RecipientInfo(KeyTransRecipientInfo info);
    public RecipientInfo(KeyAgreeRecipientInfo info);
    public RecipientInfo(KekRecipientInfo info);
    public RecipientInfo(PasswordRecipientInfo info);
    public RecipientInfo(OtherRecipientInfo info);
    public RecipientInfo(Asn1Object info);
    public static RecipientInfo GetInstance(object o);
    public DerInteger get_Version();
    public bool get_IsTagged();
    public Asn1Encodable get_Info();
    private KekRecipientInfo GetKekInfo(Asn1TaggedObject o);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.RecipientKeyIdentifier : Asn1Encodable {
    private Asn1OctetString subjectKeyIdentifier;
    private DerGeneralizedTime date;
    private OtherKeyAttribute other;
    public Asn1OctetString SubjectKeyIdentifier { get; }
    public DerGeneralizedTime Date { get; }
    public OtherKeyAttribute OtherKeyAttribute { get; }
    public RecipientKeyIdentifier(Asn1OctetString subjectKeyIdentifier, DerGeneralizedTime date, OtherKeyAttribute other);
    public RecipientKeyIdentifier(Byte[] subjectKeyIdentifier);
    public RecipientKeyIdentifier(Byte[] subjectKeyIdentifier, DerGeneralizedTime date, OtherKeyAttribute other);
    public RecipientKeyIdentifier(Asn1Sequence seq);
    public static RecipientKeyIdentifier GetInstance(Asn1TaggedObject ato, bool explicitly);
    public static RecipientKeyIdentifier GetInstance(object obj);
    public Asn1OctetString get_SubjectKeyIdentifier();
    public DerGeneralizedTime get_Date();
    public OtherKeyAttribute get_OtherKeyAttribute();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.ScvpReqRes : Asn1Encodable {
    private ContentInfo request;
    private ContentInfo response;
    public ContentInfo Request { get; }
    public ContentInfo Response { get; }
    private ScvpReqRes(Asn1Sequence seq);
    public ScvpReqRes(ContentInfo response);
    public ScvpReqRes(ContentInfo request, ContentInfo response);
    public static ScvpReqRes GetInstance(object obj);
    public virtual ContentInfo get_Request();
    public virtual ContentInfo get_Response();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.SignedData : Asn1Encodable {
    private static DerInteger Version1;
    private static DerInteger Version3;
    private static DerInteger Version4;
    private static DerInteger Version5;
    private DerInteger version;
    private Asn1Set digestAlgorithms;
    private ContentInfo contentInfo;
    private Asn1Set certificates;
    private Asn1Set crls;
    private Asn1Set signerInfos;
    private bool certsBer;
    private bool crlsBer;
    public DerInteger Version { get; }
    public Asn1Set DigestAlgorithms { get; }
    public ContentInfo EncapContentInfo { get; }
    public Asn1Set Certificates { get; }
    public Asn1Set CRLs { get; }
    public Asn1Set SignerInfos { get; }
    public SignedData(Asn1Set digestAlgorithms, ContentInfo contentInfo, Asn1Set certificates, Asn1Set crls, Asn1Set signerInfos);
    private SignedData(Asn1Sequence seq);
    private static SignedData();
    public static SignedData GetInstance(object obj);
    private DerInteger CalculateVersion(DerObjectIdentifier contentOid, Asn1Set certs, Asn1Set crls, Asn1Set signerInfs);
    private bool CheckForVersion3(Asn1Set signerInfs);
    public DerInteger get_Version();
    public Asn1Set get_DigestAlgorithms();
    public ContentInfo get_EncapContentInfo();
    public Asn1Set get_Certificates();
    public Asn1Set get_CRLs();
    public Asn1Set get_SignerInfos();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.SignedDataParser : object {
    private Asn1SequenceParser _seq;
    private DerInteger _version;
    private object _nextObject;
    private bool _certsCalled;
    private bool _crlsCalled;
    public DerInteger Version { get; }
    public SignedDataParser(Asn1SequenceParser seq);
    public static SignedDataParser GetInstance(object o);
    public DerInteger get_Version();
    public Asn1SetParser GetDigestAlgorithms();
    public ContentInfoParser GetEncapContentInfo();
    public Asn1SetParser GetCertificates();
    public Asn1SetParser GetCrls();
    public Asn1SetParser GetSignerInfos();
}
public class Org.BouncyCastle.Asn1.Cms.SignerIdentifier : Asn1Encodable {
    private Asn1Encodable id;
    public bool IsTagged { get; }
    public Asn1Encodable ID { get; }
    public SignerIdentifier(IssuerAndSerialNumber id);
    public SignerIdentifier(Asn1OctetString id);
    public SignerIdentifier(Asn1Object id);
    public static SignerIdentifier GetInstance(object o);
    public bool get_IsTagged();
    public Asn1Encodable get_ID();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.SignerInfo : Asn1Encodable {
    private DerInteger version;
    private SignerIdentifier sid;
    private AlgorithmIdentifier digAlgorithm;
    private Asn1Set authenticatedAttributes;
    private AlgorithmIdentifier digEncryptionAlgorithm;
    private Asn1OctetString encryptedDigest;
    private Asn1Set unauthenticatedAttributes;
    public DerInteger Version { get; }
    public SignerIdentifier SignerID { get; }
    public Asn1Set AuthenticatedAttributes { get; }
    public AlgorithmIdentifier DigestAlgorithm { get; }
    public Asn1OctetString EncryptedDigest { get; }
    public AlgorithmIdentifier DigestEncryptionAlgorithm { get; }
    public Asn1Set UnauthenticatedAttributes { get; }
    public SignerInfo(SignerIdentifier sid, AlgorithmIdentifier digAlgorithm, Asn1Set authenticatedAttributes, AlgorithmIdentifier digEncryptionAlgorithm, Asn1OctetString encryptedDigest, Asn1Set unauthenticatedAttributes);
    public SignerInfo(SignerIdentifier sid, AlgorithmIdentifier digAlgorithm, Attributes authenticatedAttributes, AlgorithmIdentifier digEncryptionAlgorithm, Asn1OctetString encryptedDigest, Attributes unauthenticatedAttributes);
    [ObsoleteAttribute("Use 'GetInstance' instead")]
public SignerInfo(Asn1Sequence seq);
    public static SignerInfo GetInstance(object obj);
    public DerInteger get_Version();
    public SignerIdentifier get_SignerID();
    public Asn1Set get_AuthenticatedAttributes();
    public AlgorithmIdentifier get_DigestAlgorithm();
    public Asn1OctetString get_EncryptedDigest();
    public AlgorithmIdentifier get_DigestEncryptionAlgorithm();
    public Asn1Set get_UnauthenticatedAttributes();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.Time : Asn1Encodable {
    private Asn1Object time;
    public string TimeString { get; }
    public DateTime Date { get; }
    public Time(Asn1Object time);
    public Time(DateTime date);
    public static Time GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Time GetInstance(object obj);
    public string get_TimeString();
    public DateTime get_Date();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.TimeStampAndCrl : Asn1Encodable {
    private ContentInfo timeStamp;
    private CertificateList crl;
    public ContentInfo TimeStampToken { get; }
    public CertificateList Crl { get; }
    public TimeStampAndCrl(ContentInfo timeStamp);
    private TimeStampAndCrl(Asn1Sequence seq);
    public static TimeStampAndCrl GetInstance(object obj);
    public virtual ContentInfo get_TimeStampToken();
    public virtual CertificateList get_Crl();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.TimeStampedData : Asn1Encodable {
    private DerInteger version;
    private DerIA5String dataUri;
    private MetaData metaData;
    private Asn1OctetString content;
    private Evidence temporalEvidence;
    public DerIA5String DataUri { get; }
    public MetaData MetaData { get; }
    public Asn1OctetString Content { get; }
    public Evidence TemporalEvidence { get; }
    public TimeStampedData(DerIA5String dataUri, MetaData metaData, Asn1OctetString content, Evidence temporalEvidence);
    private TimeStampedData(Asn1Sequence seq);
    public static TimeStampedData GetInstance(object obj);
    public virtual DerIA5String get_DataUri();
    public MetaData get_MetaData();
    public Asn1OctetString get_Content();
    public Evidence get_TemporalEvidence();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.TimeStampedDataParser : object {
    private DerInteger version;
    private DerIA5String dataUri;
    private MetaData metaData;
    private Asn1OctetStringParser content;
    private Evidence temporalEvidence;
    private Asn1SequenceParser parser;
    public DerIA5String DataUri { get; }
    public MetaData MetaData { get; }
    public Asn1OctetStringParser Content { get; }
    private TimeStampedDataParser(Asn1SequenceParser parser);
    public static TimeStampedDataParser GetInstance(object obj);
    public virtual DerIA5String get_DataUri();
    public virtual MetaData get_MetaData();
    public virtual Asn1OctetStringParser get_Content();
    public virtual Evidence GetTemporalEvidence();
}
public class Org.BouncyCastle.Asn1.Cms.TimeStampTokenEvidence : Asn1Encodable {
    private TimeStampAndCrl[] timeStampAndCrls;
    public TimeStampTokenEvidence(TimeStampAndCrl[] timeStampAndCrls);
    public TimeStampTokenEvidence(TimeStampAndCrl timeStampAndCrl);
    private TimeStampTokenEvidence(Asn1Sequence seq);
    public static TimeStampTokenEvidence GetInstance(Asn1TaggedObject tagged, bool isExplicit);
    public static TimeStampTokenEvidence GetInstance(object obj);
    public virtual TimeStampAndCrl[] ToTimeStampAndCrlArray();
    public virtual Asn1Object ToAsn1Object();
}
internal class Org.BouncyCastle.Asn1.ConstructedOctetStream : BaseInputStream {
    private Asn1StreamParser _parser;
    private bool _first;
    private Stream _currentStream;
    internal ConstructedOctetStream(Asn1StreamParser parser);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    private Asn1OctetStringParser GetNextParser();
}
public class Org.BouncyCastle.Asn1.Crmf.AttributeTypeAndValue : Asn1Encodable {
    private DerObjectIdentifier type;
    private Asn1Encodable value;
    public DerObjectIdentifier Type { get; }
    public Asn1Encodable Value { get; }
    private AttributeTypeAndValue(Asn1Sequence seq);
    public AttributeTypeAndValue(string oid, Asn1Encodable value);
    public AttributeTypeAndValue(DerObjectIdentifier type, Asn1Encodable value);
    public static AttributeTypeAndValue GetInstance(object obj);
    public virtual DerObjectIdentifier get_Type();
    public virtual Asn1Encodable get_Value();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.CertId : Asn1Encodable {
    private GeneralName issuer;
    private DerInteger serialNumber;
    public GeneralName Issuer { get; }
    public DerInteger SerialNumber { get; }
    private CertId(Asn1Sequence seq);
    public static CertId GetInstance(object obj);
    public static CertId GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual GeneralName get_Issuer();
    public virtual DerInteger get_SerialNumber();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.CertReqMessages : Asn1Encodable {
    private Asn1Sequence content;
    private CertReqMessages(Asn1Sequence seq);
    public CertReqMessages(CertReqMsg[] msgs);
    public static CertReqMessages GetInstance(object obj);
    public virtual CertReqMsg[] ToCertReqMsgArray();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.CertReqMsg : Asn1Encodable {
    private CertRequest certReq;
    private ProofOfPossession popo;
    private Asn1Sequence regInfo;
    public CertRequest CertReq { get; }
    public ProofOfPossession Popo { get; }
    private CertReqMsg(Asn1Sequence seq);
    public CertReqMsg(CertRequest certReq, ProofOfPossession popo, AttributeTypeAndValue[] regInfo);
    public static CertReqMsg GetInstance(object obj);
    public static CertReqMsg GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual CertRequest get_CertReq();
    public virtual ProofOfPossession get_Popo();
    public virtual AttributeTypeAndValue[] GetRegInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.CertRequest : Asn1Encodable {
    private DerInteger certReqId;
    private CertTemplate certTemplate;
    private Controls controls;
    public DerInteger CertReqID { get; }
    public CertTemplate CertTemplate { get; }
    public Controls Controls { get; }
    private CertRequest(Asn1Sequence seq);
    public CertRequest(int certReqId, CertTemplate certTemplate, Controls controls);
    public CertRequest(DerInteger certReqId, CertTemplate certTemplate, Controls controls);
    public static CertRequest GetInstance(object obj);
    public virtual DerInteger get_CertReqID();
    public virtual CertTemplate get_CertTemplate();
    public virtual Controls get_Controls();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.CertTemplate : Asn1Encodable {
    private Asn1Sequence seq;
    private DerInteger version;
    private DerInteger serialNumber;
    private AlgorithmIdentifier signingAlg;
    private X509Name issuer;
    private OptionalValidity validity;
    private X509Name subject;
    private SubjectPublicKeyInfo publicKey;
    private DerBitString issuerUID;
    private DerBitString subjectUID;
    private X509Extensions extensions;
    public int Version { get; }
    public DerInteger SerialNumber { get; }
    public AlgorithmIdentifier SigningAlg { get; }
    public X509Name Issuer { get; }
    public OptionalValidity Validity { get; }
    public X509Name Subject { get; }
    public SubjectPublicKeyInfo PublicKey { get; }
    public DerBitString IssuerUID { get; }
    public DerBitString SubjectUID { get; }
    public X509Extensions Extensions { get; }
    private CertTemplate(Asn1Sequence seq);
    public static CertTemplate GetInstance(object obj);
    public virtual int get_Version();
    public virtual DerInteger get_SerialNumber();
    public virtual AlgorithmIdentifier get_SigningAlg();
    public virtual X509Name get_Issuer();
    public virtual OptionalValidity get_Validity();
    public virtual X509Name get_Subject();
    public virtual SubjectPublicKeyInfo get_PublicKey();
    public virtual DerBitString get_IssuerUID();
    public virtual DerBitString get_SubjectUID();
    public virtual X509Extensions get_Extensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.CertTemplateBuilder : object {
    private DerInteger version;
    private DerInteger serialNumber;
    private AlgorithmIdentifier signingAlg;
    private X509Name issuer;
    private OptionalValidity validity;
    private X509Name subject;
    private SubjectPublicKeyInfo publicKey;
    private DerBitString issuerUID;
    private DerBitString subjectUID;
    private X509Extensions extensions;
    public virtual CertTemplateBuilder SetVersion(int ver);
    public virtual CertTemplateBuilder SetSerialNumber(DerInteger ser);
    public virtual CertTemplateBuilder SetSigningAlg(AlgorithmIdentifier aid);
    public virtual CertTemplateBuilder SetIssuer(X509Name name);
    public virtual CertTemplateBuilder SetValidity(OptionalValidity v);
    public virtual CertTemplateBuilder SetSubject(X509Name name);
    public virtual CertTemplateBuilder SetPublicKey(SubjectPublicKeyInfo spki);
    public virtual CertTemplateBuilder SetIssuerUID(DerBitString uid);
    public virtual CertTemplateBuilder SetSubjectUID(DerBitString uid);
    public virtual CertTemplateBuilder SetExtensions(X509Extensions extens);
    public virtual CertTemplate Build();
    private void AddOptional(Asn1EncodableVector v, int tagNo, bool isExplicit, Asn1Encodable obj);
}
public class Org.BouncyCastle.Asn1.Crmf.Controls : Asn1Encodable {
    private Asn1Sequence content;
    private Controls(Asn1Sequence seq);
    public Controls(AttributeTypeAndValue[] atvs);
    public static Controls GetInstance(object obj);
    public virtual AttributeTypeAndValue[] ToAttributeTypeAndValueArray();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Crmf.CrmfObjectIdentifiers : object {
    public static DerObjectIdentifier id_pkix;
    public static DerObjectIdentifier id_pkip;
    public static DerObjectIdentifier id_regCtrl;
    public static DerObjectIdentifier id_regCtrl_regToken;
    public static DerObjectIdentifier id_regCtrl_authenticator;
    public static DerObjectIdentifier id_regCtrl_pkiPublicationInfo;
    public static DerObjectIdentifier id_regCtrl_pkiArchiveOptions;
    public static DerObjectIdentifier id_ct_encKeyWithID;
    private static CrmfObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Crmf.EncKeyWithID : Asn1Encodable {
    private PrivateKeyInfo privKeyInfo;
    private Asn1Encodable identifier;
    public PrivateKeyInfo PrivateKey { get; }
    public bool HasIdentifier { get; }
    public bool IsIdentifierUtf8String { get; }
    public Asn1Encodable Identifier { get; }
    private EncKeyWithID(Asn1Sequence seq);
    public EncKeyWithID(PrivateKeyInfo privKeyInfo);
    public EncKeyWithID(PrivateKeyInfo privKeyInfo, DerUtf8String str);
    public EncKeyWithID(PrivateKeyInfo privKeyInfo, GeneralName generalName);
    public static EncKeyWithID GetInstance(object obj);
    public virtual PrivateKeyInfo get_PrivateKey();
    public virtual bool get_HasIdentifier();
    public virtual bool get_IsIdentifierUtf8String();
    public virtual Asn1Encodable get_Identifier();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.EncryptedKey : Asn1Encodable {
    private EnvelopedData envelopedData;
    private EncryptedValue encryptedValue;
    public bool IsEncryptedValue { get; }
    public Asn1Encodable Value { get; }
    public EncryptedKey(EnvelopedData envelopedData);
    public EncryptedKey(EncryptedValue encryptedValue);
    public static EncryptedKey GetInstance(object o);
    public virtual bool get_IsEncryptedValue();
    public virtual Asn1Encodable get_Value();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.EncryptedValue : Asn1Encodable {
    private AlgorithmIdentifier intendedAlg;
    private AlgorithmIdentifier symmAlg;
    private DerBitString encSymmKey;
    private AlgorithmIdentifier keyAlg;
    private Asn1OctetString valueHint;
    private DerBitString encValue;
    public AlgorithmIdentifier IntendedAlg { get; }
    public AlgorithmIdentifier SymmAlg { get; }
    public DerBitString EncSymmKey { get; }
    public AlgorithmIdentifier KeyAlg { get; }
    public Asn1OctetString ValueHint { get; }
    public DerBitString EncValue { get; }
    private EncryptedValue(Asn1Sequence seq);
    public EncryptedValue(AlgorithmIdentifier intendedAlg, AlgorithmIdentifier symmAlg, DerBitString encSymmKey, AlgorithmIdentifier keyAlg, Asn1OctetString valueHint, DerBitString encValue);
    public static EncryptedValue GetInstance(object obj);
    public virtual AlgorithmIdentifier get_IntendedAlg();
    public virtual AlgorithmIdentifier get_SymmAlg();
    public virtual DerBitString get_EncSymmKey();
    public virtual AlgorithmIdentifier get_KeyAlg();
    public virtual Asn1OctetString get_ValueHint();
    public virtual DerBitString get_EncValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.OptionalValidity : Asn1Encodable {
    private Time notBefore;
    private Time notAfter;
    public Time NotBefore { get; }
    public Time NotAfter { get; }
    private OptionalValidity(Asn1Sequence seq);
    public OptionalValidity(Time notBefore, Time notAfter);
    public static OptionalValidity GetInstance(object obj);
    public virtual Time get_NotBefore();
    public virtual Time get_NotAfter();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.PkiArchiveOptions : Asn1Encodable {
    public static int encryptedPrivKey;
    public static int keyGenParameters;
    public static int archiveRemGenPrivKey;
    private Asn1Encodable value;
    public int Type { get; }
    public Asn1Encodable Value { get; }
    private PkiArchiveOptions(Asn1TaggedObject tagged);
    public PkiArchiveOptions(EncryptedKey encKey);
    public PkiArchiveOptions(Asn1OctetString keyGenParameters);
    public PkiArchiveOptions(bool archiveRemGenPrivKey);
    public static PkiArchiveOptions GetInstance(object obj);
    public virtual int get_Type();
    public virtual Asn1Encodable get_Value();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.PkiPublicationInfo : Asn1Encodable {
    private DerInteger action;
    private Asn1Sequence pubInfos;
    public DerInteger Action { get; }
    private PkiPublicationInfo(Asn1Sequence seq);
    public static PkiPublicationInfo GetInstance(object obj);
    public virtual DerInteger get_Action();
    public virtual SinglePubInfo[] GetPubInfos();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.PKMacValue : Asn1Encodable {
    private AlgorithmIdentifier algID;
    private DerBitString macValue;
    public AlgorithmIdentifier AlgID { get; }
    public DerBitString MacValue { get; }
    private PKMacValue(Asn1Sequence seq);
    public PKMacValue(PbmParameter pbmParams, DerBitString macValue);
    public PKMacValue(AlgorithmIdentifier algID, DerBitString macValue);
    public static PKMacValue GetInstance(object obj);
    public static PKMacValue GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual AlgorithmIdentifier get_AlgID();
    public virtual DerBitString get_MacValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.PopoPrivKey : Asn1Encodable {
    public static int thisMessage;
    public static int subsequentMessage;
    public static int dhMAC;
    public static int agreeMAC;
    public static int encryptedKey;
    private int tagNo;
    private Asn1Encodable obj;
    public int Type { get; }
    public Asn1Encodable Value { get; }
    private PopoPrivKey(Asn1TaggedObject obj);
    public PopoPrivKey(SubsequentMessage msg);
    public static PopoPrivKey GetInstance(Asn1TaggedObject tagged, bool isExplicit);
    public virtual int get_Type();
    public virtual Asn1Encodable get_Value();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.PopoSigningKey : Asn1Encodable {
    private PopoSigningKeyInput poposkInput;
    private AlgorithmIdentifier algorithmIdentifier;
    private DerBitString signature;
    public PopoSigningKeyInput PoposkInput { get; }
    public AlgorithmIdentifier AlgorithmIdentifier { get; }
    public DerBitString Signature { get; }
    private PopoSigningKey(Asn1Sequence seq);
    public PopoSigningKey(PopoSigningKeyInput poposkIn, AlgorithmIdentifier aid, DerBitString signature);
    public static PopoSigningKey GetInstance(object obj);
    public static PopoSigningKey GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual PopoSigningKeyInput get_PoposkInput();
    public virtual AlgorithmIdentifier get_AlgorithmIdentifier();
    public virtual DerBitString get_Signature();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.PopoSigningKeyInput : Asn1Encodable {
    private GeneralName sender;
    private PKMacValue publicKeyMac;
    private SubjectPublicKeyInfo publicKey;
    public GeneralName Sender { get; }
    public PKMacValue PublicKeyMac { get; }
    public SubjectPublicKeyInfo PublicKey { get; }
    private PopoSigningKeyInput(Asn1Sequence seq);
    public PopoSigningKeyInput(GeneralName sender, SubjectPublicKeyInfo spki);
    public PopoSigningKeyInput(PKMacValue pkmac, SubjectPublicKeyInfo spki);
    public static PopoSigningKeyInput GetInstance(object obj);
    public virtual GeneralName get_Sender();
    public virtual PKMacValue get_PublicKeyMac();
    public virtual SubjectPublicKeyInfo get_PublicKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.ProofOfPossession : Asn1Encodable {
    public static int TYPE_RA_VERIFIED;
    public static int TYPE_SIGNING_KEY;
    public static int TYPE_KEY_ENCIPHERMENT;
    public static int TYPE_KEY_AGREEMENT;
    private int tagNo;
    private Asn1Encodable obj;
    public int Type { get; }
    public Asn1Encodable Object { get; }
    private ProofOfPossession(Asn1TaggedObject tagged);
    public ProofOfPossession(PopoSigningKey Poposk);
    public ProofOfPossession(int type, PopoPrivKey privkey);
    public static ProofOfPossession GetInstance(object obj);
    public virtual int get_Type();
    public virtual Asn1Encodable get_Object();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.SinglePubInfo : Asn1Encodable {
    private DerInteger pubMethod;
    private GeneralName pubLocation;
    public GeneralName PubLocation { get; }
    private SinglePubInfo(Asn1Sequence seq);
    public static SinglePubInfo GetInstance(object obj);
    public virtual GeneralName get_PubLocation();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.SubsequentMessage : DerInteger {
    public static SubsequentMessage encrCert;
    public static SubsequentMessage challengeResp;
    private SubsequentMessage(int value);
    private static SubsequentMessage();
    public static SubsequentMessage ValueOf(int value);
}
public abstract class Org.BouncyCastle.Asn1.CryptoPro.CryptoProObjectIdentifiers : object {
    public static string GostID;
    public static DerObjectIdentifier GostR3411;
    public static DerObjectIdentifier GostR3411Hmac;
    public static DerObjectIdentifier GostR28147Cbc;
    public static DerObjectIdentifier ID_Gost28147_89_CryptoPro_A_ParamSet;
    public static DerObjectIdentifier GostR3410x94;
    public static DerObjectIdentifier GostR3410x2001;
    public static DerObjectIdentifier GostR3411x94WithGostR3410x94;
    public static DerObjectIdentifier GostR3411x94WithGostR3410x2001;
    public static DerObjectIdentifier GostR3411x94CryptoProParamSet;
    public static DerObjectIdentifier GostR3410x94CryptoProA;
    public static DerObjectIdentifier GostR3410x94CryptoProB;
    public static DerObjectIdentifier GostR3410x94CryptoProC;
    public static DerObjectIdentifier GostR3410x94CryptoProD;
    public static DerObjectIdentifier GostR3410x94CryptoProXchA;
    public static DerObjectIdentifier GostR3410x94CryptoProXchB;
    public static DerObjectIdentifier GostR3410x94CryptoProXchC;
    public static DerObjectIdentifier GostR3410x2001CryptoProA;
    public static DerObjectIdentifier GostR3410x2001CryptoProB;
    public static DerObjectIdentifier GostR3410x2001CryptoProC;
    public static DerObjectIdentifier GostR3410x2001CryptoProXchA;
    public static DerObjectIdentifier GostR3410x2001CryptoProXchB;
    public static DerObjectIdentifier GostElSgDH3410Default;
    public static DerObjectIdentifier GostElSgDH3410x1;
    private static CryptoProObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves : object {
    internal static IDictionary objIds;
    internal static IDictionary parameters;
    internal static IDictionary names;
    public static IEnumerable Names { get; }
    private static ECGost3410NamedCurves();
    private static ECPoint ConfigureBasepoint(ECCurve curve, BigInteger x, BigInteger y);
    private static ECCurve ConfigureCurve(ECCurve curve);
    [ObsoleteAttribute("Use 'GetByOidX9' instead")]
public static ECDomainParameters GetByOid(DerObjectIdentifier oid);
    public static X9ECParameters GetByOidX9(DerObjectIdentifier oid);
    public static IEnumerable get_Names();
    [ObsoleteAttribute("Use 'GetByNameX9' instead")]
public static ECDomainParameters GetByName(string name);
    public static X9ECParameters GetByNameX9(string name);
    public static string GetName(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
}
public class Org.BouncyCastle.Asn1.CryptoPro.ECGost3410ParamSetParameters : Asn1Encodable {
    internal DerInteger p;
    internal DerInteger q;
    internal DerInteger a;
    internal DerInteger b;
    internal DerInteger x;
    internal DerInteger y;
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger A { get; }
    public ECGost3410ParamSetParameters(BigInteger a, BigInteger b, BigInteger p, BigInteger q, int x, BigInteger y);
    public ECGost3410ParamSetParameters(Asn1Sequence seq);
    public static ECGost3410ParamSetParameters GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static ECGost3410ParamSetParameters GetInstance(object obj);
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_A();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.CryptoPro.Gost28147Parameters : Asn1Encodable {
    private Asn1OctetString iv;
    private DerObjectIdentifier paramSet;
    private Gost28147Parameters(Asn1Sequence seq);
    public static Gost28147Parameters GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Gost28147Parameters GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.CryptoPro.Gost3410NamedParameters : object {
    private static IDictionary objIds;
    private static IDictionary parameters;
    private static Gost3410ParamSetParameters cryptoProA;
    private static Gost3410ParamSetParameters cryptoProB;
    private static Gost3410ParamSetParameters cryptoProXchA;
    public static IEnumerable Names { get; }
    private static Gost3410NamedParameters();
    public static Gost3410ParamSetParameters GetByOid(DerObjectIdentifier oid);
    public static IEnumerable get_Names();
    public static Gost3410ParamSetParameters GetByName(string name);
    public static DerObjectIdentifier GetOid(string name);
}
public class Org.BouncyCastle.Asn1.CryptoPro.Gost3410ParamSetParameters : Asn1Encodable {
    private int keySize;
    private DerInteger p;
    private DerInteger q;
    private DerInteger a;
    public int KeySize { get; }
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger A { get; }
    public Gost3410ParamSetParameters(int keySize, BigInteger p, BigInteger q, BigInteger a);
    private Gost3410ParamSetParameters(Asn1Sequence seq);
    public static Gost3410ParamSetParameters GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Gost3410ParamSetParameters GetInstance(object obj);
    public int get_KeySize();
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_A();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.CryptoPro.Gost3410PublicKeyAlgParameters : Asn1Encodable {
    private DerObjectIdentifier publicKeyParamSet;
    private DerObjectIdentifier digestParamSet;
    private DerObjectIdentifier encryptionParamSet;
    public DerObjectIdentifier PublicKeyParamSet { get; }
    public DerObjectIdentifier DigestParamSet { get; }
    public DerObjectIdentifier EncryptionParamSet { get; }
    public Gost3410PublicKeyAlgParameters(DerObjectIdentifier publicKeyParamSet, DerObjectIdentifier digestParamSet);
    public Gost3410PublicKeyAlgParameters(DerObjectIdentifier publicKeyParamSet, DerObjectIdentifier digestParamSet, DerObjectIdentifier encryptionParamSet);
    [ObsoleteAttribute("Use 'GetInstance' instead")]
public Gost3410PublicKeyAlgParameters(Asn1Sequence seq);
    public static Gost3410PublicKeyAlgParameters GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Gost3410PublicKeyAlgParameters GetInstance(object obj);
    public DerObjectIdentifier get_PublicKeyParamSet();
    public DerObjectIdentifier get_DigestParamSet();
    public DerObjectIdentifier get_EncryptionParamSet();
    public virtual Asn1Object ToAsn1Object();
}
internal class Org.BouncyCastle.Asn1.DefiniteLengthInputStream : LimitedInputStream {
    private static Byte[] EmptyBytes;
    private int _originalLength;
    private int _remaining;
    internal int Remaining { get; }
    internal DefiniteLengthInputStream(Stream inStream, int length, int limit);
    private static DefiniteLengthInputStream();
    internal int get_Remaining();
    public virtual int ReadByte();
    public virtual int Read(Byte[] buf, int off, int len);
    internal void ReadAllIntoByteArray(Byte[] buf);
    internal Byte[] ToArray();
}
public class Org.BouncyCastle.Asn1.DerApplicationSpecific : Asn1Object {
    private bool isConstructed;
    private int tag;
    private Byte[] octets;
    public int ApplicationTag { get; }
    internal DerApplicationSpecific(bool isConstructed, int tag, Byte[] octets);
    public DerApplicationSpecific(int tag, Byte[] octets);
    public DerApplicationSpecific(int tag, Asn1Encodable obj);
    public DerApplicationSpecific(bool isExplicit, int tag, Asn1Encodable obj);
    public DerApplicationSpecific(int tagNo, Asn1EncodableVector vec);
    private int GetLengthOfHeader(Byte[] data);
    public bool IsConstructed();
    public Byte[] GetContents();
    public int get_ApplicationTag();
    public Asn1Object GetObject();
    public Asn1Object GetObject(int derTagNo);
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    private Byte[] ReplaceTagNumber(int newTag, Byte[] input);
}
public class Org.BouncyCastle.Asn1.DerBitString : DerStringBase {
    private static Char[] table;
    internal Byte[] contents;
    public int PadBits { get; }
    public int IntValue { get; }
    public DerBitString(byte data, int padBits);
    public DerBitString(Byte[] data);
    public DerBitString(Byte[] data, int padBits);
    public DerBitString(int namedBits);
    public DerBitString(Asn1Encodable obj);
    internal DerBitString(Byte[] contents, bool check);
    private static DerBitString();
    public static DerBitString GetInstance(object obj);
    public static DerBitString GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual Byte[] GetOctets();
    public virtual Byte[] GetBytes();
    public virtual int get_PadBits();
    public virtual int get_IntValue();
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public virtual string GetString();
    internal static int EncodedLength(bool withID, int contentsLength);
    internal static void Encode(Asn1OutputStream asn1Out, bool withID, Byte[] buf, int off, int len);
    internal static void Encode(Asn1OutputStream asn1Out, bool withID, byte pad, Byte[] buf, int off, int len);
    internal static DerBitString CreatePrimitive(Byte[] contents);
}
public class Org.BouncyCastle.Asn1.DerBmpString : DerStringBase {
    private string str;
    [ObsoleteAttribute("Will become internal")]
public DerBmpString(Byte[] str);
    internal DerBmpString(Char[] str);
    public DerBmpString(string str);
    public static DerBmpString GetInstance(object obj);
    public static DerBmpString GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual string GetString();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
}
public class Org.BouncyCastle.Asn1.DerBoolean : Asn1Object {
    private byte value;
    public static DerBoolean False;
    public static DerBoolean True;
    public bool IsTrue { get; }
    public DerBoolean(Byte[] val);
    private DerBoolean(bool value);
    private static DerBoolean();
    public static DerBoolean GetInstance(object obj);
    public static DerBoolean GetInstance(bool value);
    public static DerBoolean GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public bool get_IsTrue();
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    public virtual string ToString();
    internal static DerBoolean FromOctetString(Byte[] value);
}
public class Org.BouncyCastle.Asn1.DerEnumerated : Asn1Object {
    private Byte[] bytes;
    private int start;
    private static DerEnumerated[] cache;
    public BigInteger Value { get; }
    public int IntValueExact { get; }
    public DerEnumerated(int val);
    public DerEnumerated(long val);
    public DerEnumerated(BigInteger val);
    public DerEnumerated(Byte[] bytes);
    private static DerEnumerated();
    public static DerEnumerated GetInstance(object obj);
    public static DerEnumerated GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public BigInteger get_Value();
    public bool HasValue(int x);
    public bool HasValue(BigInteger x);
    public int get_IntValueExact();
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    internal static DerEnumerated FromOctetString(Byte[] enc);
}
public class Org.BouncyCastle.Asn1.DerExternal : Asn1Object {
    private DerObjectIdentifier directReference;
    private DerInteger indirectReference;
    private Asn1Object dataValueDescriptor;
    private int encoding;
    private Asn1Object externalContent;
    public Asn1Object DataValueDescriptor { get; public set; }
    public DerObjectIdentifier DirectReference { get; public set; }
    public int Encoding { get; public set; }
    public Asn1Object ExternalContent { get; public set; }
    public DerInteger IndirectReference { get; public set; }
    public DerExternal(Asn1EncodableVector vector);
    public DerExternal(DerObjectIdentifier directReference, DerInteger indirectReference, Asn1Object dataValueDescriptor, DerTaggedObject externalData);
    public DerExternal(DerObjectIdentifier directReference, DerInteger indirectReference, Asn1Object dataValueDescriptor, int encoding, Asn1Object externalData);
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public Asn1Object get_DataValueDescriptor();
    public void set_DataValueDescriptor(Asn1Object value);
    public DerObjectIdentifier get_DirectReference();
    public void set_DirectReference(DerObjectIdentifier value);
    public int get_Encoding();
    public void set_Encoding(int value);
    public Asn1Object get_ExternalContent();
    public void set_ExternalContent(Asn1Object value);
    public DerInteger get_IndirectReference();
    public void set_IndirectReference(DerInteger value);
    private static Asn1Object GetObjFromVector(Asn1EncodableVector v, int index);
    private static void WriteEncodable(MemoryStream ms, Asn1Encodable e);
}
public class Org.BouncyCastle.Asn1.DerExternalParser : Asn1Encodable {
    private Asn1StreamParser _parser;
    [ObsoleteAttribute("Will be removed")]
public DerExternalParser(Asn1StreamParser parser);
    public IAsn1Convertible ReadObject();
    public virtual Asn1Object ToAsn1Object();
    internal static DerExternal Parse(Asn1StreamParser sp);
}
public class Org.BouncyCastle.Asn1.DerGeneralizedTime : Asn1Object {
    private string time;
    public string TimeString { get; }
    private bool HasFractionalSeconds { get; }
    public DerGeneralizedTime(string time);
    public DerGeneralizedTime(DateTime time);
    internal DerGeneralizedTime(Byte[] bytes);
    public static DerGeneralizedTime GetInstance(object obj);
    public static DerGeneralizedTime GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public string get_TimeString();
    public string GetTime();
    private string CalculateGmtOffset();
    private static string Convert(int time);
    public DateTime ToDateTime();
    private string FString(int count);
    private DateTime ParseDateString(string s, string format, bool makeUniversal);
    private bool get_HasFractionalSeconds();
    private Byte[] GetOctets();
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
}
public class Org.BouncyCastle.Asn1.DerGeneralString : DerStringBase {
    private string str;
    public DerGeneralString(Byte[] str);
    public DerGeneralString(string str);
    public static DerGeneralString GetInstance(object obj);
    public static DerGeneralString GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
}
public abstract class Org.BouncyCastle.Asn1.DerGenerator : Asn1Generator {
    private bool _tagged;
    private bool _isExplicit;
    private int _tagNo;
    protected DerGenerator(Stream outStream);
    protected DerGenerator(Stream outStream, int tagNo, bool isExplicit);
    private static void WriteLength(Stream outStr, int length);
    internal static void WriteDerEncoded(Stream outStream, int tag, Byte[] bytes);
    internal void WriteDerEncoded(int tag, Byte[] bytes);
    internal static void WriteDerEncoded(Stream outStr, int tag, Stream inStr);
}
public class Org.BouncyCastle.Asn1.DerGraphicString : DerStringBase {
    private Byte[] mString;
    public DerGraphicString(Byte[] encoding);
    public static DerGraphicString GetInstance(object obj);
    public static DerGraphicString GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
}
public class Org.BouncyCastle.Asn1.DerIA5String : DerStringBase {
    private string str;
    public DerIA5String(Byte[] str);
    public DerIA5String(string str);
    public DerIA5String(string str, bool validate);
    public static DerIA5String GetInstance(object obj);
    public static DerIA5String GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public static bool IsIA5String(string str);
}
public class Org.BouncyCastle.Asn1.DerInteger : Asn1Object {
    public static string AllowUnsafeProperty;
    internal static int SignExtSigned;
    internal static int SignExtUnsigned;
    private Byte[] bytes;
    private int start;
    public BigInteger PositiveValue { get; }
    public BigInteger Value { get; }
    public int IntPositiveValueExact { get; }
    public int IntValueExact { get; }
    public long LongValueExact { get; }
    public DerInteger(int value);
    public DerInteger(long value);
    public DerInteger(BigInteger value);
    public DerInteger(Byte[] bytes);
    internal DerInteger(Byte[] bytes, bool clone);
    internal static bool AllowUnsafe();
    public static DerInteger GetInstance(object obj);
    public static DerInteger GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public BigInteger get_PositiveValue();
    public BigInteger get_Value();
    public bool HasValue(int x);
    public bool HasValue(long x);
    public bool HasValue(BigInteger x);
    public int get_IntPositiveValueExact();
    public int get_IntValueExact();
    public long get_LongValueExact();
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public virtual string ToString();
    internal static int IntValue(Byte[] bytes, int start, int signExt);
    internal static long LongValue(Byte[] bytes, int start, int signExt);
    internal static bool IsMalformed(Byte[] bytes);
    internal static int SignBytesToSkip(Byte[] bytes);
}
public class Org.BouncyCastle.Asn1.DerNull : Asn1Null {
    public static DerNull Instance;
    private static Byte[] ZeroBytes;
    private static DerNull();
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
}
public class Org.BouncyCastle.Asn1.DerNumericString : DerStringBase {
    private string str;
    public DerNumericString(Byte[] str);
    public DerNumericString(string str);
    public DerNumericString(string str, bool validate);
    public static DerNumericString GetInstance(object obj);
    public static DerNumericString GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public static bool IsNumericString(string str);
}
public class Org.BouncyCastle.Asn1.DerObjectIdentifier : Asn1Object {
    private string identifier;
    private Byte[] contents;
    private static long LONG_LIMIT;
    private static DerObjectIdentifier[] cache;
    public string Id { get; }
    public DerObjectIdentifier(string identifier);
    internal DerObjectIdentifier(DerObjectIdentifier oid, string branchID);
    internal DerObjectIdentifier(Byte[] contents, bool clone);
    private static DerObjectIdentifier();
    public static DerObjectIdentifier FromContents(Byte[] contents);
    public static DerObjectIdentifier GetInstance(object obj);
    public static DerObjectIdentifier GetInstance(Asn1TaggedObject obj, bool explicitly);
    public string get_Id();
    public virtual DerObjectIdentifier Branch(string branchID);
    public virtual bool On(DerObjectIdentifier stem);
    private void WriteField(Stream outputStream, long fieldValue);
    private void WriteField(Stream outputStream, BigInteger fieldValue);
    private void DoOutput(MemoryStream bOut);
    private Byte[] GetContents();
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public virtual string ToString();
    private static bool IsValidBranchID(string branchID, int start);
    private static bool IsValidIdentifier(string identifier);
    private static string MakeOidStringFromBytes(Byte[] bytes);
    internal static DerObjectIdentifier CreatePrimitive(Byte[] contents, bool clone);
}
public class Org.BouncyCastle.Asn1.DerOctetString : Asn1OctetString {
    public DerOctetString(Byte[] str);
    public DerOctetString(IAsn1Convertible obj);
    public DerOctetString(Asn1Encodable obj);
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
    internal static void Encode(Asn1OutputStream asn1Out, bool withID, Byte[] buf, int off, int len);
    internal static int EncodedLength(bool withID, int contentsLength);
}
public class Org.BouncyCastle.Asn1.DerOctetStringParser : object {
    private DefiniteLengthInputStream stream;
    internal DerOctetStringParser(DefiniteLengthInputStream stream);
    public sealed virtual Stream GetOctetStream();
    public sealed virtual Asn1Object ToAsn1Object();
}
[ObsoleteAttribute("Use 'Asn1OutputStream' instead")]
public class Org.BouncyCastle.Asn1.DerOutputStream : FilterStream {
    [ObsoleteAttribute("Use 'Asn1OutputStream.Create' instead")]
public DerOutputStream(Stream os);
    public virtual void WriteObject(Asn1Encodable encodable);
    public virtual void WriteObject(Asn1Object primitive);
}
internal class Org.BouncyCastle.Asn1.DerOutputStreamNew : Asn1OutputStream {
    internal bool IsBer { get; }
    internal DerOutputStreamNew(Stream os);
    internal virtual bool get_IsBer();
    internal virtual void WritePrimitive(Asn1Object primitive, bool withID);
}
public class Org.BouncyCastle.Asn1.DerPrintableString : DerStringBase {
    private string str;
    public DerPrintableString(Byte[] str);
    public DerPrintableString(string str);
    public DerPrintableString(string str, bool validate);
    public static DerPrintableString GetInstance(object obj);
    public static DerPrintableString GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public static bool IsPrintableString(string str);
}
public class Org.BouncyCastle.Asn1.DerSequence : Asn1Sequence {
    public static DerSequence Empty;
    public DerSequence(Asn1Encodable element);
    public DerSequence(Asn1Encodable[] elements);
    public DerSequence(Asn1EncodableVector elementVector);
    private static DerSequence();
    public static DerSequence FromVector(Asn1EncodableVector elementVector);
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
}
public class Org.BouncyCastle.Asn1.DerSequenceGenerator : DerGenerator {
    private MemoryStream _bOut;
    public DerSequenceGenerator(Stream outStream);
    public DerSequenceGenerator(Stream outStream, int tagNo, bool isExplicit);
    public virtual void AddObject(Asn1Encodable obj);
    public virtual void AddObject(Asn1Object obj);
    public virtual Stream GetRawOutputStream();
    public virtual void Close();
}
public class Org.BouncyCastle.Asn1.DerSequenceParser : object {
    private Asn1StreamParser _parser;
    internal DerSequenceParser(Asn1StreamParser parser);
    public sealed virtual IAsn1Convertible ReadObject();
    public sealed virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.DerSet : Asn1Set {
    public static DerSet Empty;
    public DerSet(Asn1Encodable element);
    public DerSet(Asn1Encodable[] elements);
    public DerSet(Asn1EncodableVector elementVector);
    internal DerSet(Asn1EncodableVector elementVector, bool needsSorting);
    private static DerSet();
    public static DerSet FromVector(Asn1EncodableVector elementVector);
    internal static DerSet FromVector(Asn1EncodableVector elementVector, bool needsSorting);
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
}
public class Org.BouncyCastle.Asn1.DerSetGenerator : DerGenerator {
    private MemoryStream _bOut;
    public DerSetGenerator(Stream outStream);
    public DerSetGenerator(Stream outStream, int tagNo, bool isExplicit);
    public virtual void AddObject(Asn1Encodable obj);
    public virtual void AddObject(Asn1Object obj);
    public virtual Stream GetRawOutputStream();
    public virtual void Close();
}
public class Org.BouncyCastle.Asn1.DerSetParser : object {
    private Asn1StreamParser _parser;
    internal DerSetParser(Asn1StreamParser parser);
    public sealed virtual IAsn1Convertible ReadObject();
    public sealed virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.DerStringBase : Asn1Object {
    public abstract virtual string GetString();
    public virtual string ToString();
    protected virtual int Asn1GetHashCode();
}
public class Org.BouncyCastle.Asn1.DerT61String : DerStringBase {
    private string str;
    public DerT61String(Byte[] str);
    public DerT61String(string str);
    public static DerT61String GetInstance(object obj);
    public static DerT61String GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual string GetString();
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
    public Byte[] GetOctets();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
}
public class Org.BouncyCastle.Asn1.DerTaggedObject : Asn1TaggedObject {
    public DerTaggedObject(int tagNo, Asn1Encodable obj);
    public DerTaggedObject(bool explicitly, int tagNo, Asn1Encodable obj);
    public DerTaggedObject(int tagNo);
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
}
public class Org.BouncyCastle.Asn1.DerUniversalString : DerStringBase {
    private static Char[] table;
    private Byte[] str;
    public DerUniversalString(Byte[] str);
    private static DerUniversalString();
    public static DerUniversalString GetInstance(object obj);
    public static DerUniversalString GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
}
public class Org.BouncyCastle.Asn1.DerUtcTime : Asn1Object {
    private string time;
    public string TimeString { get; }
    [ObsoleteAttribute("Use 'AdjustedTimeString' property instead")]
public string AdjustedTime { get; }
    public string AdjustedTimeString { get; }
    public DerUtcTime(string time);
    public DerUtcTime(DateTime time);
    internal DerUtcTime(Byte[] bytes);
    public static DerUtcTime GetInstance(object obj);
    public static DerUtcTime GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public DateTime ToDateTime();
    public DateTime ToAdjustedDateTime();
    private DateTime ParseDateString(string dateStr, string formatStr);
    public string get_TimeString();
    public string get_AdjustedTime();
    public string get_AdjustedTimeString();
    private Byte[] GetOctets();
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.DerUtf8String : DerStringBase {
    private string str;
    public DerUtf8String(Byte[] str);
    public DerUtf8String(string str);
    public static DerUtf8String GetInstance(object obj);
    public static DerUtf8String GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual string GetString();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
}
public class Org.BouncyCastle.Asn1.DerVideotexString : DerStringBase {
    private Byte[] mString;
    public DerVideotexString(Byte[] encoding);
    public static DerVideotexString GetInstance(object obj);
    public static DerVideotexString GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
}
public class Org.BouncyCastle.Asn1.DerVisibleString : DerStringBase {
    private string str;
    public DerVisibleString(Byte[] str);
    public DerVisibleString(string str);
    public static DerVisibleString GetInstance(object obj);
    public static DerVisibleString GetInstance(Asn1TaggedObject obj, bool explicitly);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
}
public abstract class Org.BouncyCastle.Asn1.Eac.EacObjectIdentifiers : object {
    public static DerObjectIdentifier bsi_de;
    public static DerObjectIdentifier id_PK;
    public static DerObjectIdentifier id_PK_DH;
    public static DerObjectIdentifier id_PK_ECDH;
    public static DerObjectIdentifier id_CA;
    public static DerObjectIdentifier id_CA_DH;
    public static DerObjectIdentifier id_CA_DH_3DES_CBC_CBC;
    public static DerObjectIdentifier id_CA_ECDH;
    public static DerObjectIdentifier id_CA_ECDH_3DES_CBC_CBC;
    public static DerObjectIdentifier id_TA;
    public static DerObjectIdentifier id_TA_RSA;
    public static DerObjectIdentifier id_TA_RSA_v1_5_SHA_1;
    public static DerObjectIdentifier id_TA_RSA_v1_5_SHA_256;
    public static DerObjectIdentifier id_TA_RSA_PSS_SHA_1;
    public static DerObjectIdentifier id_TA_RSA_PSS_SHA_256;
    public static DerObjectIdentifier id_TA_ECDSA;
    public static DerObjectIdentifier id_TA_ECDSA_SHA_1;
    public static DerObjectIdentifier id_TA_ECDSA_SHA_224;
    public static DerObjectIdentifier id_TA_ECDSA_SHA_256;
    public static DerObjectIdentifier id_TA_ECDSA_SHA_384;
    public static DerObjectIdentifier id_TA_ECDSA_SHA_512;
    private static EacObjectIdentifiers();
}
public abstract class Org.BouncyCastle.Asn1.EdEC.EdECObjectIdentifiers : object {
    public static DerObjectIdentifier id_edwards_curve_algs;
    public static DerObjectIdentifier id_X25519;
    public static DerObjectIdentifier id_X448;
    public static DerObjectIdentifier id_Ed25519;
    public static DerObjectIdentifier id_Ed448;
    private static EdECObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Esf.CertificateValues : Asn1Encodable {
    private Asn1Sequence certificates;
    private CertificateValues(Asn1Sequence seq);
    public CertificateValues(X509CertificateStructure[] certificates);
    public CertificateValues(IEnumerable certificates);
    public static CertificateValues GetInstance(object obj);
    public X509CertificateStructure[] GetCertificates();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Esf.CommitmentTypeIdentifier : object {
    public static DerObjectIdentifier ProofOfOrigin;
    public static DerObjectIdentifier ProofOfReceipt;
    public static DerObjectIdentifier ProofOfDelivery;
    public static DerObjectIdentifier ProofOfSender;
    public static DerObjectIdentifier ProofOfApproval;
    public static DerObjectIdentifier ProofOfCreation;
    private static CommitmentTypeIdentifier();
}
public class Org.BouncyCastle.Asn1.Esf.CommitmentTypeIndication : Asn1Encodable {
    private DerObjectIdentifier commitmentTypeId;
    private Asn1Sequence commitmentTypeQualifier;
    public DerObjectIdentifier CommitmentTypeID { get; }
    public Asn1Sequence CommitmentTypeQualifier { get; }
    public CommitmentTypeIndication(Asn1Sequence seq);
    public CommitmentTypeIndication(DerObjectIdentifier commitmentTypeId);
    public CommitmentTypeIndication(DerObjectIdentifier commitmentTypeId, Asn1Sequence commitmentTypeQualifier);
    public static CommitmentTypeIndication GetInstance(object obj);
    public DerObjectIdentifier get_CommitmentTypeID();
    public Asn1Sequence get_CommitmentTypeQualifier();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CommitmentTypeQualifier : Asn1Encodable {
    private DerObjectIdentifier commitmentTypeIdentifier;
    private Asn1Object qualifier;
    public DerObjectIdentifier CommitmentTypeIdentifier { get; }
    public Asn1Object Qualifier { get; }
    public CommitmentTypeQualifier(DerObjectIdentifier commitmentTypeIdentifier);
    public CommitmentTypeQualifier(DerObjectIdentifier commitmentTypeIdentifier, Asn1Encodable qualifier);
    public CommitmentTypeQualifier(Asn1Sequence seq);
    public static CommitmentTypeQualifier GetInstance(object obj);
    public DerObjectIdentifier get_CommitmentTypeIdentifier();
    public Asn1Object get_Qualifier();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CompleteCertificateRefs : Asn1Encodable {
    private Asn1Sequence otherCertIDs;
    private CompleteCertificateRefs(Asn1Sequence seq);
    public CompleteCertificateRefs(OtherCertID[] otherCertIDs);
    public CompleteCertificateRefs(IEnumerable otherCertIDs);
    public static CompleteCertificateRefs GetInstance(object obj);
    public OtherCertID[] GetOtherCertIDs();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CompleteRevocationRefs : Asn1Encodable {
    private Asn1Sequence crlOcspRefs;
    private CompleteRevocationRefs(Asn1Sequence seq);
    public CompleteRevocationRefs(CrlOcspRef[] crlOcspRefs);
    public CompleteRevocationRefs(IEnumerable crlOcspRefs);
    public static CompleteRevocationRefs GetInstance(object obj);
    public CrlOcspRef[] GetCrlOcspRefs();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CrlIdentifier : Asn1Encodable {
    private X509Name crlIssuer;
    private DerUtcTime crlIssuedTime;
    private DerInteger crlNumber;
    public X509Name CrlIssuer { get; }
    public DateTime CrlIssuedTime { get; }
    public BigInteger CrlNumber { get; }
    private CrlIdentifier(Asn1Sequence seq);
    public CrlIdentifier(X509Name crlIssuer, DateTime crlIssuedTime);
    public CrlIdentifier(X509Name crlIssuer, DateTime crlIssuedTime, BigInteger crlNumber);
    public static CrlIdentifier GetInstance(object obj);
    public X509Name get_CrlIssuer();
    public DateTime get_CrlIssuedTime();
    public BigInteger get_CrlNumber();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CrlListID : Asn1Encodable {
    private Asn1Sequence crls;
    private CrlListID(Asn1Sequence seq);
    public CrlListID(CrlValidatedID[] crls);
    public CrlListID(IEnumerable crls);
    public static CrlListID GetInstance(object obj);
    public CrlValidatedID[] GetCrls();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CrlOcspRef : Asn1Encodable {
    private CrlListID crlids;
    private OcspListID ocspids;
    private OtherRevRefs otherRev;
    public CrlListID CrlIDs { get; }
    public OcspListID OcspIDs { get; }
    public OtherRevRefs OtherRev { get; }
    private CrlOcspRef(Asn1Sequence seq);
    public CrlOcspRef(CrlListID crlids, OcspListID ocspids, OtherRevRefs otherRev);
    public static CrlOcspRef GetInstance(object obj);
    public CrlListID get_CrlIDs();
    public OcspListID get_OcspIDs();
    public OtherRevRefs get_OtherRev();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CrlValidatedID : Asn1Encodable {
    private OtherHash crlHash;
    private CrlIdentifier crlIdentifier;
    public OtherHash CrlHash { get; }
    public CrlIdentifier CrlIdentifier { get; }
    private CrlValidatedID(Asn1Sequence seq);
    public CrlValidatedID(OtherHash crlHash);
    public CrlValidatedID(OtherHash crlHash, CrlIdentifier crlIdentifier);
    public static CrlValidatedID GetInstance(object obj);
    public OtherHash get_CrlHash();
    public CrlIdentifier get_CrlIdentifier();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Esf.EsfAttributes : object {
    public static DerObjectIdentifier SigPolicyId;
    public static DerObjectIdentifier CommitmentType;
    public static DerObjectIdentifier SignerLocation;
    public static DerObjectIdentifier SignerAttr;
    public static DerObjectIdentifier OtherSigCert;
    public static DerObjectIdentifier ContentTimestamp;
    public static DerObjectIdentifier CertificateRefs;
    public static DerObjectIdentifier RevocationRefs;
    public static DerObjectIdentifier CertValues;
    public static DerObjectIdentifier RevocationValues;
    public static DerObjectIdentifier EscTimeStamp;
    public static DerObjectIdentifier CertCrlTimestamp;
    public static DerObjectIdentifier ArchiveTimestamp;
    public static DerObjectIdentifier ArchiveTimestampV2;
    private static EsfAttributes();
}
public class Org.BouncyCastle.Asn1.Esf.OcspIdentifier : Asn1Encodable {
    private ResponderID ocspResponderID;
    private DerGeneralizedTime producedAt;
    public ResponderID OcspResponderID { get; }
    public DateTime ProducedAt { get; }
    private OcspIdentifier(Asn1Sequence seq);
    public OcspIdentifier(ResponderID ocspResponderID, DateTime producedAt);
    public static OcspIdentifier GetInstance(object obj);
    public ResponderID get_OcspResponderID();
    public DateTime get_ProducedAt();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OcspListID : Asn1Encodable {
    private Asn1Sequence ocspResponses;
    private OcspListID(Asn1Sequence seq);
    public OcspListID(OcspResponsesID[] ocspResponses);
    public OcspListID(IEnumerable ocspResponses);
    public static OcspListID GetInstance(object obj);
    public OcspResponsesID[] GetOcspResponses();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OcspResponsesID : Asn1Encodable {
    private OcspIdentifier ocspIdentifier;
    private OtherHash ocspRepHash;
    public OcspIdentifier OcspIdentifier { get; }
    public OtherHash OcspRepHash { get; }
    private OcspResponsesID(Asn1Sequence seq);
    public OcspResponsesID(OcspIdentifier ocspIdentifier);
    public OcspResponsesID(OcspIdentifier ocspIdentifier, OtherHash ocspRepHash);
    public static OcspResponsesID GetInstance(object obj);
    public OcspIdentifier get_OcspIdentifier();
    public OtherHash get_OcspRepHash();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OtherCertID : Asn1Encodable {
    private OtherHash otherCertHash;
    private IssuerSerial issuerSerial;
    public OtherHash OtherCertHash { get; }
    public IssuerSerial IssuerSerial { get; }
    private OtherCertID(Asn1Sequence seq);
    public OtherCertID(OtherHash otherCertHash);
    public OtherCertID(OtherHash otherCertHash, IssuerSerial issuerSerial);
    public static OtherCertID GetInstance(object obj);
    public OtherHash get_OtherCertHash();
    public IssuerSerial get_IssuerSerial();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OtherHash : Asn1Encodable {
    private Asn1OctetString sha1Hash;
    private OtherHashAlgAndValue otherHash;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public OtherHash(Byte[] sha1Hash);
    public OtherHash(Asn1OctetString sha1Hash);
    public OtherHash(OtherHashAlgAndValue otherHash);
    public static OtherHash GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public Byte[] GetHashValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OtherHashAlgAndValue : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private Asn1OctetString hashValue;
    public AlgorithmIdentifier HashAlgorithm { get; }
    private OtherHashAlgAndValue(Asn1Sequence seq);
    public OtherHashAlgAndValue(AlgorithmIdentifier hashAlgorithm, Byte[] hashValue);
    public OtherHashAlgAndValue(AlgorithmIdentifier hashAlgorithm, Asn1OctetString hashValue);
    public static OtherHashAlgAndValue GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public Byte[] GetHashValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OtherRevRefs : Asn1Encodable {
    private DerObjectIdentifier otherRevRefType;
    private Asn1Object otherRevRefs;
    public DerObjectIdentifier OtherRevRefType { get; }
    public Asn1Object OtherRevRefsObject { get; }
    private OtherRevRefs(Asn1Sequence seq);
    public OtherRevRefs(DerObjectIdentifier otherRevRefType, Asn1Encodable otherRevRefs);
    public static OtherRevRefs GetInstance(object obj);
    public DerObjectIdentifier get_OtherRevRefType();
    public Asn1Object get_OtherRevRefsObject();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OtherRevVals : Asn1Encodable {
    private DerObjectIdentifier otherRevValType;
    private Asn1Object otherRevVals;
    public DerObjectIdentifier OtherRevValType { get; }
    public Asn1Object OtherRevValsObject { get; }
    private OtherRevVals(Asn1Sequence seq);
    public OtherRevVals(DerObjectIdentifier otherRevValType, Asn1Encodable otherRevVals);
    public static OtherRevVals GetInstance(object obj);
    public DerObjectIdentifier get_OtherRevValType();
    public Asn1Object get_OtherRevValsObject();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OtherSigningCertificate : Asn1Encodable {
    private Asn1Sequence certs;
    private Asn1Sequence policies;
    private OtherSigningCertificate(Asn1Sequence seq);
    public OtherSigningCertificate(OtherCertID[] certs);
    public OtherSigningCertificate(OtherCertID[] certs, PolicyInformation[] policies);
    public OtherSigningCertificate(IEnumerable certs);
    public OtherSigningCertificate(IEnumerable certs, IEnumerable policies);
    public static OtherSigningCertificate GetInstance(object obj);
    public OtherCertID[] GetCerts();
    public PolicyInformation[] GetPolicies();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.RevocationValues : Asn1Encodable {
    private Asn1Sequence crlVals;
    private Asn1Sequence ocspVals;
    private OtherRevVals otherRevVals;
    public OtherRevVals OtherRevVals { get; }
    private RevocationValues(Asn1Sequence seq);
    public RevocationValues(CertificateList[] crlVals, BasicOcspResponse[] ocspVals, OtherRevVals otherRevVals);
    public RevocationValues(IEnumerable crlVals, IEnumerable ocspVals, OtherRevVals otherRevVals);
    public static RevocationValues GetInstance(object obj);
    public CertificateList[] GetCrlVals();
    public BasicOcspResponse[] GetOcspVals();
    public OtherRevVals get_OtherRevVals();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.SignaturePolicyId : Asn1Encodable {
    private DerObjectIdentifier sigPolicyIdentifier;
    private OtherHashAlgAndValue sigPolicyHash;
    private Asn1Sequence sigPolicyQualifiers;
    public DerObjectIdentifier SigPolicyIdentifier { get; }
    public OtherHashAlgAndValue SigPolicyHash { get; }
    private SignaturePolicyId(Asn1Sequence seq);
    public SignaturePolicyId(DerObjectIdentifier sigPolicyIdentifier, OtherHashAlgAndValue sigPolicyHash);
    public SignaturePolicyId(DerObjectIdentifier sigPolicyIdentifier, OtherHashAlgAndValue sigPolicyHash, SigPolicyQualifierInfo[] sigPolicyQualifiers);
    public SignaturePolicyId(DerObjectIdentifier sigPolicyIdentifier, OtherHashAlgAndValue sigPolicyHash, IEnumerable sigPolicyQualifiers);
    public static SignaturePolicyId GetInstance(object obj);
    public DerObjectIdentifier get_SigPolicyIdentifier();
    public OtherHashAlgAndValue get_SigPolicyHash();
    public SigPolicyQualifierInfo[] GetSigPolicyQualifiers();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.SignaturePolicyIdentifier : Asn1Encodable {
    private SignaturePolicyId sigPolicy;
    public SignaturePolicyId SignaturePolicyId { get; }
    public SignaturePolicyIdentifier(SignaturePolicyId signaturePolicyId);
    public static SignaturePolicyIdentifier GetInstance(object obj);
    public SignaturePolicyId get_SignaturePolicyId();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.SignerAttribute : Asn1Encodable {
    private Asn1Sequence claimedAttributes;
    private AttributeCertificate certifiedAttributes;
    public Asn1Sequence ClaimedAttributes { get; }
    public AttributeCertificate CertifiedAttributes { get; }
    private SignerAttribute(object obj);
    public SignerAttribute(Asn1Sequence claimedAttributes);
    public SignerAttribute(AttributeCertificate certifiedAttributes);
    public static SignerAttribute GetInstance(object obj);
    public virtual Asn1Sequence get_ClaimedAttributes();
    public virtual AttributeCertificate get_CertifiedAttributes();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.SignerLocation : Asn1Encodable {
    private DirectoryString countryName;
    private DirectoryString localityName;
    private Asn1Sequence postalAddress;
    public DirectoryString Country { get; }
    public DirectoryString Locality { get; }
    [ObsoleteAttribute("Use 'Country' property instead")]
public DerUtf8String CountryName { get; }
    [ObsoleteAttribute("Use 'Locality' property instead")]
public DerUtf8String LocalityName { get; }
    public Asn1Sequence PostalAddress { get; }
    public SignerLocation(Asn1Sequence seq);
    private SignerLocation(DirectoryString countryName, DirectoryString localityName, Asn1Sequence postalAddress);
    public SignerLocation(DirectoryString countryName, DirectoryString localityName, DirectoryString[] postalAddress);
    public SignerLocation(DerUtf8String countryName, DerUtf8String localityName, Asn1Sequence postalAddress);
    public static SignerLocation GetInstance(object obj);
    public DirectoryString get_Country();
    public DirectoryString get_Locality();
    public DirectoryString[] GetPostal();
    public DerUtf8String get_CountryName();
    public DerUtf8String get_LocalityName();
    public Asn1Sequence get_PostalAddress();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.SigPolicyQualifierInfo : Asn1Encodable {
    private DerObjectIdentifier sigPolicyQualifierId;
    private Asn1Object sigQualifier;
    public DerObjectIdentifier SigPolicyQualifierId { get; }
    public Asn1Object SigQualifier { get; }
    private SigPolicyQualifierInfo(Asn1Sequence seq);
    public SigPolicyQualifierInfo(DerObjectIdentifier sigPolicyQualifierId, Asn1Encodable sigQualifier);
    public static SigPolicyQualifierInfo GetInstance(object obj);
    public DerObjectIdentifier get_SigPolicyQualifierId();
    public Asn1Object get_SigQualifier();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ess.ContentHints : Asn1Encodable {
    private DerUtf8String contentDescription;
    private DerObjectIdentifier contentType;
    public DerObjectIdentifier ContentType { get; }
    public DerUtf8String ContentDescription { get; }
    private ContentHints(Asn1Sequence seq);
    public ContentHints(DerObjectIdentifier contentType);
    public ContentHints(DerObjectIdentifier contentType, DerUtf8String contentDescription);
    public static ContentHints GetInstance(object o);
    public DerObjectIdentifier get_ContentType();
    public DerUtf8String get_ContentDescription();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ess.ContentIdentifier : Asn1Encodable {
    private Asn1OctetString value;
    public Asn1OctetString Value { get; }
    public ContentIdentifier(Asn1OctetString value);
    public ContentIdentifier(Byte[] value);
    public static ContentIdentifier GetInstance(object o);
    public Asn1OctetString get_Value();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ess.EssCertID : Asn1Encodable {
    private Asn1OctetString certHash;
    private IssuerSerial issuerSerial;
    public IssuerSerial IssuerSerial { get; }
    public EssCertID(Asn1Sequence seq);
    public EssCertID(Byte[] hash);
    public EssCertID(Byte[] hash, IssuerSerial issuerSerial);
    public static EssCertID GetInstance(object o);
    public Byte[] GetCertHash();
    public IssuerSerial get_IssuerSerial();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ess.EssCertIDv2 : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private Byte[] certHash;
    private IssuerSerial issuerSerial;
    private static AlgorithmIdentifier DefaultAlgID;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public IssuerSerial IssuerSerial { get; }
    private EssCertIDv2(Asn1Sequence seq);
    public EssCertIDv2(Byte[] certHash);
    public EssCertIDv2(AlgorithmIdentifier algId, Byte[] certHash);
    public EssCertIDv2(Byte[] certHash, IssuerSerial issuerSerial);
    public EssCertIDv2(AlgorithmIdentifier algId, Byte[] certHash, IssuerSerial issuerSerial);
    private static EssCertIDv2();
    public static EssCertIDv2 GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public Byte[] GetCertHash();
    public IssuerSerial get_IssuerSerial();
    public virtual Asn1Object ToAsn1Object();
}
[ObsoleteAttribute("Use version in Asn1.Esf instead")]
public class Org.BouncyCastle.Asn1.Ess.OtherCertID : Asn1Encodable {
    private Asn1Encodable otherCertHash;
    private IssuerSerial issuerSerial;
    public AlgorithmIdentifier AlgorithmHash { get; }
    public IssuerSerial IssuerSerial { get; }
    public OtherCertID(Asn1Sequence seq);
    public OtherCertID(AlgorithmIdentifier algId, Byte[] digest);
    public OtherCertID(AlgorithmIdentifier algId, Byte[] digest, IssuerSerial issuerSerial);
    public static OtherCertID GetInstance(object o);
    public AlgorithmIdentifier get_AlgorithmHash();
    public Byte[] GetCertHash();
    public IssuerSerial get_IssuerSerial();
    public virtual Asn1Object ToAsn1Object();
}
[ObsoleteAttribute("Use version in Asn1.Esf instead")]
public class Org.BouncyCastle.Asn1.Ess.OtherSigningCertificate : Asn1Encodable {
    private Asn1Sequence certs;
    private Asn1Sequence policies;
    public OtherSigningCertificate(Asn1Sequence seq);
    public OtherSigningCertificate(OtherCertID otherCertID);
    public static OtherSigningCertificate GetInstance(object o);
    public OtherCertID[] GetCerts();
    public PolicyInformation[] GetPolicies();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ess.SigningCertificate : Asn1Encodable {
    private Asn1Sequence certs;
    private Asn1Sequence policies;
    public SigningCertificate(Asn1Sequence seq);
    public SigningCertificate(EssCertID essCertID);
    public static SigningCertificate GetInstance(object o);
    public EssCertID[] GetCerts();
    public PolicyInformation[] GetPolicies();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ess.SigningCertificateV2 : Asn1Encodable {
    private Asn1Sequence certs;
    private Asn1Sequence policies;
    private SigningCertificateV2(Asn1Sequence seq);
    public SigningCertificateV2(EssCertIDv2 cert);
    public SigningCertificateV2(EssCertIDv2[] certs);
    public SigningCertificateV2(EssCertIDv2[] certs, PolicyInformation[] policies);
    public static SigningCertificateV2 GetInstance(object o);
    public EssCertIDv2[] GetCerts();
    public PolicyInformation[] GetPolicies();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.GM.GMNamedCurves : object {
    private static IDictionary objIds;
    private static IDictionary curves;
    private static IDictionary names;
    public static IEnumerable Names { get; }
    private static GMNamedCurves();
    private static X9ECPoint ConfigureBasepoint(ECCurve curve, string encoding);
    private static ECCurve ConfigureCurve(ECCurve curve);
    private static BigInteger FromHex(string hex);
    private static void DefineCurve(string name, DerObjectIdentifier oid, X9ECParametersHolder holder);
    public static X9ECParameters GetByName(string name);
    public static X9ECParameters GetByOid(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static string GetName(DerObjectIdentifier oid);
    public static IEnumerable get_Names();
}
public abstract class Org.BouncyCastle.Asn1.GM.GMObjectIdentifiers : object {
    public static DerObjectIdentifier sm_scheme;
    public static DerObjectIdentifier sm6_ecb;
    public static DerObjectIdentifier sm6_cbc;
    public static DerObjectIdentifier sm6_ofb128;
    public static DerObjectIdentifier sm6_cfb128;
    public static DerObjectIdentifier sm1_ecb;
    public static DerObjectIdentifier sm1_cbc;
    public static DerObjectIdentifier sm1_ofb128;
    public static DerObjectIdentifier sm1_cfb128;
    public static DerObjectIdentifier sm1_cfb1;
    public static DerObjectIdentifier sm1_cfb8;
    public static DerObjectIdentifier ssf33_ecb;
    public static DerObjectIdentifier ssf33_cbc;
    public static DerObjectIdentifier ssf33_ofb128;
    public static DerObjectIdentifier ssf33_cfb128;
    public static DerObjectIdentifier ssf33_cfb1;
    public static DerObjectIdentifier ssf33_cfb8;
    public static DerObjectIdentifier sms4_ecb;
    public static DerObjectIdentifier sms4_cbc;
    public static DerObjectIdentifier sms4_ofb128;
    public static DerObjectIdentifier sms4_cfb128;
    public static DerObjectIdentifier sms4_cfb1;
    public static DerObjectIdentifier sms4_cfb8;
    public static DerObjectIdentifier sms4_ctr;
    public static DerObjectIdentifier sms4_gcm;
    public static DerObjectIdentifier sms4_ccm;
    public static DerObjectIdentifier sms4_xts;
    public static DerObjectIdentifier sms4_wrap;
    public static DerObjectIdentifier sms4_wrap_pad;
    public static DerObjectIdentifier sms4_ocb;
    public static DerObjectIdentifier sm5;
    public static DerObjectIdentifier sm2p256v1;
    public static DerObjectIdentifier sm2sign;
    public static DerObjectIdentifier sm2exchange;
    public static DerObjectIdentifier sm2encrypt;
    public static DerObjectIdentifier wapip192v1;
    public static DerObjectIdentifier sm2encrypt_recommendedParameters;
    public static DerObjectIdentifier sm2encrypt_specifiedParameters;
    public static DerObjectIdentifier sm2encrypt_with_sm3;
    public static DerObjectIdentifier sm2encrypt_with_sha1;
    public static DerObjectIdentifier sm2encrypt_with_sha224;
    public static DerObjectIdentifier sm2encrypt_with_sha256;
    public static DerObjectIdentifier sm2encrypt_with_sha384;
    public static DerObjectIdentifier sm2encrypt_with_sha512;
    public static DerObjectIdentifier sm2encrypt_with_rmd160;
    public static DerObjectIdentifier sm2encrypt_with_whirlpool;
    public static DerObjectIdentifier sm2encrypt_with_blake2b512;
    public static DerObjectIdentifier sm2encrypt_with_blake2s256;
    public static DerObjectIdentifier sm2encrypt_with_md5;
    public static DerObjectIdentifier id_sm9PublicKey;
    public static DerObjectIdentifier sm9sign;
    public static DerObjectIdentifier sm9keyagreement;
    public static DerObjectIdentifier sm9encrypt;
    public static DerObjectIdentifier sm3;
    public static DerObjectIdentifier hmac_sm3;
    public static DerObjectIdentifier sm2sign_with_sm3;
    public static DerObjectIdentifier sm2sign_with_sha1;
    public static DerObjectIdentifier sm2sign_with_sha256;
    public static DerObjectIdentifier sm2sign_with_sha512;
    public static DerObjectIdentifier sm2sign_with_sha224;
    public static DerObjectIdentifier sm2sign_with_sha384;
    public static DerObjectIdentifier sm2sign_with_rmd160;
    public static DerObjectIdentifier sm2sign_with_whirlpool;
    public static DerObjectIdentifier sm2sign_with_blake2b512;
    public static DerObjectIdentifier sm2sign_with_blake2s256;
    private static GMObjectIdentifiers();
}
public abstract class Org.BouncyCastle.Asn1.Gnu.GnuObjectIdentifiers : object {
    public static DerObjectIdentifier Gnu;
    public static DerObjectIdentifier GnuPG;
    public static DerObjectIdentifier Notation;
    public static DerObjectIdentifier PkaAddress;
    public static DerObjectIdentifier GnuRadar;
    public static DerObjectIdentifier DigestAlgorithm;
    public static DerObjectIdentifier Tiger192;
    public static DerObjectIdentifier EncryptionAlgorithm;
    public static DerObjectIdentifier Serpent;
    public static DerObjectIdentifier Serpent128Ecb;
    public static DerObjectIdentifier Serpent128Cbc;
    public static DerObjectIdentifier Serpent128Ofb;
    public static DerObjectIdentifier Serpent128Cfb;
    public static DerObjectIdentifier Serpent192Ecb;
    public static DerObjectIdentifier Serpent192Cbc;
    public static DerObjectIdentifier Serpent192Ofb;
    public static DerObjectIdentifier Serpent192Cfb;
    public static DerObjectIdentifier Serpent256Ecb;
    public static DerObjectIdentifier Serpent256Cbc;
    public static DerObjectIdentifier Serpent256Ofb;
    public static DerObjectIdentifier Serpent256Cfb;
    public static DerObjectIdentifier Crc;
    public static DerObjectIdentifier Crc32;
    public static DerObjectIdentifier EllipticCurve;
    public static DerObjectIdentifier Ed25519;
    private static GnuObjectIdentifiers();
}
public abstract class Org.BouncyCastle.Asn1.Iana.IanaObjectIdentifiers : object {
    public static DerObjectIdentifier IsakmpOakley;
    public static DerObjectIdentifier HmacMD5;
    public static DerObjectIdentifier HmacSha1;
    public static DerObjectIdentifier HmacTiger;
    public static DerObjectIdentifier HmacRipeMD160;
    private static IanaObjectIdentifiers();
}
public interface Org.BouncyCastle.Asn1.IAsn1ApplicationSpecificParser {
    public abstract virtual IAsn1Convertible ReadObject();
}
public interface Org.BouncyCastle.Asn1.IAsn1Choice {
}
public interface Org.BouncyCastle.Asn1.IAsn1Convertible {
    public abstract virtual Asn1Object ToAsn1Object();
}
public interface Org.BouncyCastle.Asn1.IAsn1String {
    public abstract virtual string GetString();
}
public class Org.BouncyCastle.Asn1.Icao.CscaMasterList : Asn1Encodable {
    private DerInteger version;
    private X509CertificateStructure[] certList;
    public int Version { get; }
    private CscaMasterList(Asn1Sequence seq);
    public CscaMasterList(X509CertificateStructure[] certStructs);
    public static CscaMasterList GetInstance(object obj);
    public virtual int get_Version();
    public X509CertificateStructure[] GetCertStructs();
    private static X509CertificateStructure[] CopyCertList(X509CertificateStructure[] orig);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Icao.DataGroupHash : Asn1Encodable {
    private DerInteger dataGroupNumber;
    private Asn1OctetString dataGroupHashValue;
    public int DataGroupNumber { get; }
    public Asn1OctetString DataGroupHashValue { get; }
    private DataGroupHash(Asn1Sequence seq);
    public DataGroupHash(int dataGroupNumber, Asn1OctetString dataGroupHashValue);
    public static DataGroupHash GetInstance(object obj);
    public int get_DataGroupNumber();
    public Asn1OctetString get_DataGroupHashValue();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Icao.IcaoObjectIdentifiers : object {
    public static DerObjectIdentifier IdIcao;
    public static DerObjectIdentifier IdIcaoMrtd;
    public static DerObjectIdentifier IdIcaoMrtdSecurity;
    public static DerObjectIdentifier IdIcaoLdsSecurityObject;
    public static DerObjectIdentifier IdIcaoCscaMasterList;
    public static DerObjectIdentifier IdIcaoCscaMasterListSigningKey;
    public static DerObjectIdentifier IdIcaoDocumentTypeList;
    public static DerObjectIdentifier IdIcaoAAProtocolObject;
    public static DerObjectIdentifier IdIcaoExtensions;
    public static DerObjectIdentifier IdIcaoExtensionsNamechangekeyrollover;
    private static IcaoObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Icao.LdsSecurityObject : Asn1Encodable {
    public static int UBDataGroups;
    private DerInteger version;
    private AlgorithmIdentifier digestAlgorithmIdentifier;
    private DataGroupHash[] datagroupHash;
    private LdsVersionInfo versionInfo;
    public BigInteger Version { get; }
    public AlgorithmIdentifier DigestAlgorithmIdentifier { get; }
    public LdsVersionInfo VersionInfo { get; }
    private LdsSecurityObject(Asn1Sequence seq);
    public LdsSecurityObject(AlgorithmIdentifier digestAlgorithmIdentifier, DataGroupHash[] datagroupHash);
    public LdsSecurityObject(AlgorithmIdentifier digestAlgorithmIdentifier, DataGroupHash[] datagroupHash, LdsVersionInfo versionInfo);
    public static LdsSecurityObject GetInstance(object obj);
    private void CheckDatagroupHashSeqSize(int size);
    public BigInteger get_Version();
    public AlgorithmIdentifier get_DigestAlgorithmIdentifier();
    public DataGroupHash[] GetDatagroupHash();
    public LdsVersionInfo get_VersionInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Icao.LdsVersionInfo : Asn1Encodable {
    private DerPrintableString ldsVersion;
    private DerPrintableString unicodeVersion;
    public LdsVersionInfo(string ldsVersion, string unicodeVersion);
    private LdsVersionInfo(Asn1Sequence seq);
    public static LdsVersionInfo GetInstance(object obj);
    public virtual string GetLdsVersion();
    public virtual string GetUnicodeVersion();
    public virtual Asn1Object ToAsn1Object();
}
internal class Org.BouncyCastle.Asn1.IndefiniteLengthInputStream : LimitedInputStream {
    private int _lookAhead;
    private bool _eofOn00;
    internal IndefiniteLengthInputStream(Stream inStream, int limit);
    internal void SetEofOn00(bool eofOn00);
    private bool CheckForEof();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    private int RequireByte();
}
public abstract class Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers : object {
    public static DerObjectIdentifier IdIsisMtt;
    public static DerObjectIdentifier IdIsisMttCP;
    public static DerObjectIdentifier IdIsisMttCPAccredited;
    public static DerObjectIdentifier IdIsisMttAT;
    public static DerObjectIdentifier IdIsisMttATDateOfCertGen;
    public static DerObjectIdentifier IdIsisMttATProcuration;
    public static DerObjectIdentifier IdIsisMttATAdmission;
    public static DerObjectIdentifier IdIsisMttATMonetaryLimit;
    public static DerObjectIdentifier IdIsisMttATDeclarationOfMajority;
    public static DerObjectIdentifier IdIsisMttATIccsn;
    public static DerObjectIdentifier IdIsisMttATPKReference;
    public static DerObjectIdentifier IdIsisMttATRestriction;
    public static DerObjectIdentifier IdIsisMttATRetrieveIfAllowed;
    public static DerObjectIdentifier IdIsisMttATRequestedCertificate;
    public static DerObjectIdentifier IdIsisMttATNamingAuthorities;
    public static DerObjectIdentifier IdIsisMttATCertInDirSince;
    public static DerObjectIdentifier IdIsisMttATCertHash;
    public static DerObjectIdentifier IdIsisMttATNameAtBirth;
    public static DerObjectIdentifier IdIsisMttATAdditionalInformation;
    public static DerObjectIdentifier IdIsisMttATLiabilityLimitationFlag;
    private static IsisMttObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.IsisMtt.Ocsp.CertHash : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private Byte[] certificateHash;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public Byte[] CertificateHash { get; }
    private CertHash(Asn1Sequence seq);
    public CertHash(AlgorithmIdentifier hashAlgorithm, Byte[] certificateHash);
    public static CertHash GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public Byte[] get_CertificateHash();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.Ocsp.RequestedCertificate : Asn1Encodable {
    private X509CertificateStructure cert;
    private Byte[] publicKeyCert;
    private Byte[] attributeCert;
    public Choice Type { get; }
    private RequestedCertificate(Asn1TaggedObject tagged);
    public RequestedCertificate(X509CertificateStructure certificate);
    public RequestedCertificate(Choice type, Byte[] certificateOctets);
    public static RequestedCertificate GetInstance(object obj);
    public static RequestedCertificate GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public Choice get_Type();
    public Byte[] GetCertificateBytes();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.AdditionalInformationSyntax : Asn1Encodable {
    private DirectoryString information;
    public DirectoryString Information { get; }
    private AdditionalInformationSyntax(DirectoryString information);
    public AdditionalInformationSyntax(string information);
    public static AdditionalInformationSyntax GetInstance(object obj);
    public virtual DirectoryString get_Information();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.Admissions : Asn1Encodable {
    private GeneralName admissionAuthority;
    private NamingAuthority namingAuthority;
    private Asn1Sequence professionInfos;
    public GeneralName AdmissionAuthority { get; }
    public NamingAuthority NamingAuthority { get; }
    private Admissions(Asn1Sequence seq);
    public Admissions(GeneralName admissionAuthority, NamingAuthority namingAuthority, ProfessionInfo[] professionInfos);
    public static Admissions GetInstance(object obj);
    public virtual GeneralName get_AdmissionAuthority();
    public virtual NamingAuthority get_NamingAuthority();
    public ProfessionInfo[] GetProfessionInfos();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax : Asn1Encodable {
    private GeneralName admissionAuthority;
    private Asn1Sequence contentsOfAdmissions;
    public GeneralName AdmissionAuthority { get; }
    private AdmissionSyntax(Asn1Sequence seq);
    public AdmissionSyntax(GeneralName admissionAuthority, Asn1Sequence contentsOfAdmissions);
    public static AdmissionSyntax GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public virtual GeneralName get_AdmissionAuthority();
    public virtual Admissions[] GetContentsOfAdmissions();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.DeclarationOfMajority : Asn1Encodable {
    private Asn1TaggedObject declaration;
    public Choice Type { get; }
    public int NotYoungerThan { get; }
    public Asn1Sequence FullAgeAtCountry { get; }
    public DerGeneralizedTime DateOfBirth { get; }
    public DeclarationOfMajority(int notYoungerThan);
    public DeclarationOfMajority(bool fullAge, string country);
    public DeclarationOfMajority(DerGeneralizedTime dateOfBirth);
    private DeclarationOfMajority(Asn1TaggedObject o);
    public static DeclarationOfMajority GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public Choice get_Type();
    public virtual int get_NotYoungerThan();
    public virtual Asn1Sequence get_FullAgeAtCountry();
    public virtual DerGeneralizedTime get_DateOfBirth();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.MonetaryLimit : Asn1Encodable {
    private DerPrintableString currency;
    private DerInteger amount;
    private DerInteger exponent;
    public string Currency { get; }
    public BigInteger Amount { get; }
    public BigInteger Exponent { get; }
    private MonetaryLimit(Asn1Sequence seq);
    public MonetaryLimit(string currency, int amount, int exponent);
    public static MonetaryLimit GetInstance(object obj);
    public virtual string get_Currency();
    public virtual BigInteger get_Amount();
    public virtual BigInteger get_Exponent();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority : Asn1Encodable {
    public static DerObjectIdentifier IdIsisMttATNamingAuthoritiesRechtWirtschaftSteuern;
    private DerObjectIdentifier namingAuthorityID;
    private string namingAuthorityUrl;
    private DirectoryString namingAuthorityText;
    public DerObjectIdentifier NamingAuthorityID { get; }
    public DirectoryString NamingAuthorityText { get; }
    public string NamingAuthorityUrl { get; }
    private NamingAuthority(Asn1Sequence seq);
    public NamingAuthority(DerObjectIdentifier namingAuthorityID, string namingAuthorityUrl, DirectoryString namingAuthorityText);
    private static NamingAuthority();
    public static NamingAuthority GetInstance(object obj);
    public static NamingAuthority GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual DerObjectIdentifier get_NamingAuthorityID();
    public virtual DirectoryString get_NamingAuthorityText();
    public virtual string get_NamingAuthorityUrl();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.ProcurationSyntax : Asn1Encodable {
    private string country;
    private DirectoryString typeOfSubstitution;
    private GeneralName thirdPerson;
    private IssuerSerial certRef;
    public string Country { get; }
    public DirectoryString TypeOfSubstitution { get; }
    public GeneralName ThirdPerson { get; }
    public IssuerSerial CertRef { get; }
    private ProcurationSyntax(Asn1Sequence seq);
    public ProcurationSyntax(string country, DirectoryString typeOfSubstitution, IssuerSerial certRef);
    public ProcurationSyntax(string country, DirectoryString typeOfSubstitution, GeneralName thirdPerson);
    public static ProcurationSyntax GetInstance(object obj);
    public virtual string get_Country();
    public virtual DirectoryString get_TypeOfSubstitution();
    public virtual GeneralName get_ThirdPerson();
    public virtual IssuerSerial get_CertRef();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo : Asn1Encodable {
    public static DerObjectIdentifier Rechtsanwltin;
    public static DerObjectIdentifier Rechtsanwalt;
    public static DerObjectIdentifier Rechtsbeistand;
    public static DerObjectIdentifier Steuerberaterin;
    public static DerObjectIdentifier Steuerberater;
    public static DerObjectIdentifier Steuerbevollmchtigte;
    public static DerObjectIdentifier Steuerbevollmchtigter;
    public static DerObjectIdentifier Notarin;
    public static DerObjectIdentifier Notar;
    public static DerObjectIdentifier Notarvertreterin;
    public static DerObjectIdentifier Notarvertreter;
    public static DerObjectIdentifier Notariatsverwalterin;
    public static DerObjectIdentifier Notariatsverwalter;
    public static DerObjectIdentifier Wirtschaftsprferin;
    public static DerObjectIdentifier Wirtschaftsprfer;
    public static DerObjectIdentifier VereidigteBuchprferin;
    public static DerObjectIdentifier VereidigterBuchprfer;
    public static DerObjectIdentifier Patentanwltin;
    public static DerObjectIdentifier Patentanwalt;
    private NamingAuthority namingAuthority;
    private Asn1Sequence professionItems;
    private Asn1Sequence professionOids;
    private string registrationNumber;
    private Asn1OctetString addProfessionInfo;
    public Asn1OctetString AddProfessionInfo { get; }
    public NamingAuthority NamingAuthority { get; }
    public string RegistrationNumber { get; }
    private ProfessionInfo(Asn1Sequence seq);
    public ProfessionInfo(NamingAuthority namingAuthority, DirectoryString[] professionItems, DerObjectIdentifier[] professionOids, string registrationNumber, Asn1OctetString addProfessionInfo);
    private static ProfessionInfo();
    public static ProfessionInfo GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public virtual Asn1OctetString get_AddProfessionInfo();
    public virtual NamingAuthority get_NamingAuthority();
    public virtual DirectoryString[] GetProfessionItems();
    public virtual DerObjectIdentifier[] GetProfessionOids();
    public virtual string get_RegistrationNumber();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.Restriction : Asn1Encodable {
    private DirectoryString restriction;
    public DirectoryString RestrictionString { get; }
    private Restriction(DirectoryString restriction);
    public Restriction(string restriction);
    public static Restriction GetInstance(object obj);
    public virtual DirectoryString get_RestrictionString();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Kisa.KisaObjectIdentifiers : object {
    public static DerObjectIdentifier IdSeedCbc;
    public static DerObjectIdentifier IdNpkiAppCmsSeedWrap;
    private static KisaObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.LazyAsn1InputStream : Asn1InputStream {
    public LazyAsn1InputStream(Byte[] input);
    public LazyAsn1InputStream(Stream inputStream);
    internal LazyAsn1InputStream(Stream input, int limit, Byte[][] tmpBuffers);
    internal virtual DerSequence CreateDerSequence(DefiniteLengthInputStream dIn);
    internal virtual DerSet CreateDerSet(DefiniteLengthInputStream dIn);
    internal virtual Asn1EncodableVector ReadVector(DefiniteLengthInputStream defIn);
}
[DefaultMemberAttribute("Item")]
internal class Org.BouncyCastle.Asn1.LazyDerSequence : DerSequence {
    private Byte[] encoded;
    public Asn1Encodable Item { get; }
    public int Count { get; }
    internal LazyDerSequence(Byte[] encoded);
    private void Parse();
    public virtual Asn1Encodable get_Item(int index);
    public virtual IEnumerator GetEnumerator();
    public virtual int get_Count();
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
}
[DefaultMemberAttribute("Item")]
internal class Org.BouncyCastle.Asn1.LazyDerSet : DerSet {
    private Byte[] encoded;
    public Asn1Encodable Item { get; }
    public int Count { get; }
    internal LazyDerSet(Byte[] encoded);
    private void Parse();
    public virtual Asn1Encodable get_Item(int index);
    public virtual IEnumerator GetEnumerator();
    public virtual int get_Count();
    internal virtual int EncodedLength(bool withID);
    internal virtual void Encode(Asn1OutputStream asn1Out, bool withID);
}
internal abstract class Org.BouncyCastle.Asn1.LimitedInputStream : BaseInputStream {
    protected Stream _in;
    private int _limit;
    internal int Limit { get; }
    internal LimitedInputStream(Stream inStream, int limit);
    internal virtual int get_Limit();
    protected virtual void SetParentEofDetect(bool on);
}
public abstract class Org.BouncyCastle.Asn1.Microsoft.MicrosoftObjectIdentifiers : object {
    public static DerObjectIdentifier Microsoft;
    public static DerObjectIdentifier MicrosoftCertTemplateV1;
    public static DerObjectIdentifier MicrosoftCAVersion;
    public static DerObjectIdentifier MicrosoftPrevCACertHash;
    public static DerObjectIdentifier MicrosoftCrlNextPublish;
    public static DerObjectIdentifier MicrosoftCertTemplateV2;
    public static DerObjectIdentifier MicrosoftAppPolicies;
    private static MicrosoftObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Misc.Cast5CbcParameters : Asn1Encodable {
    private DerInteger keyLength;
    private Asn1OctetString iv;
    public int KeyLength { get; }
    public Cast5CbcParameters(Byte[] iv, int keyLength);
    private Cast5CbcParameters(Asn1Sequence seq);
    public static Cast5CbcParameters GetInstance(object o);
    public Byte[] GetIV();
    public int get_KeyLength();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Misc.IdeaCbcPar : Asn1Encodable {
    internal Asn1OctetString iv;
    public IdeaCbcPar(Byte[] iv);
    private IdeaCbcPar(Asn1Sequence seq);
    public static IdeaCbcPar GetInstance(object o);
    public Byte[] GetIV();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Misc.MiscObjectIdentifiers : object {
    public static DerObjectIdentifier Netscape;
    public static DerObjectIdentifier NetscapeCertType;
    public static DerObjectIdentifier NetscapeBaseUrl;
    public static DerObjectIdentifier NetscapeRevocationUrl;
    public static DerObjectIdentifier NetscapeCARevocationUrl;
    public static DerObjectIdentifier NetscapeRenewalUrl;
    public static DerObjectIdentifier NetscapeCAPolicyUrl;
    public static DerObjectIdentifier NetscapeSslServerName;
    public static DerObjectIdentifier NetscapeCertComment;
    public static DerObjectIdentifier Verisign;
    public static DerObjectIdentifier VerisignCzagExtension;
    public static DerObjectIdentifier VerisignPrivate_6_9;
    public static DerObjectIdentifier VerisignOnSiteJurisdictionHash;
    public static DerObjectIdentifier VerisignBitString_6_13;
    public static DerObjectIdentifier VerisignDnbDunsNumber;
    public static DerObjectIdentifier VerisignIssStrongCrypto;
    public static string Novell;
    public static DerObjectIdentifier NovellSecurityAttribs;
    public static string Entrust;
    public static DerObjectIdentifier EntrustVersionExtension;
    public static DerObjectIdentifier cast5CBC;
    public static DerObjectIdentifier HMAC_SHA1;
    public static DerObjectIdentifier as_sys_sec_alg_ideaCBC;
    public static DerObjectIdentifier cryptlib;
    public static DerObjectIdentifier cryptlib_algorithm;
    public static DerObjectIdentifier cryptlib_algorithm_blowfish_ECB;
    public static DerObjectIdentifier cryptlib_algorithm_blowfish_CBC;
    public static DerObjectIdentifier cryptlib_algorithm_blowfish_CFB;
    public static DerObjectIdentifier cryptlib_algorithm_blowfish_OFB;
    public static DerObjectIdentifier blake2;
    public static DerObjectIdentifier id_blake2b160;
    public static DerObjectIdentifier id_blake2b256;
    public static DerObjectIdentifier id_blake2b384;
    public static DerObjectIdentifier id_blake2b512;
    public static DerObjectIdentifier id_blake2s128;
    public static DerObjectIdentifier id_blake2s160;
    public static DerObjectIdentifier id_blake2s224;
    public static DerObjectIdentifier id_blake2s256;
    public static DerObjectIdentifier id_scrypt;
    private static MiscObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Misc.NetscapeCertType : DerBitString {
    public static int SslClient;
    public static int SslServer;
    public static int Smime;
    public static int ObjectSigning;
    public static int Reserved;
    public static int SslCA;
    public static int SmimeCA;
    public static int ObjectSigningCA;
    public NetscapeCertType(int usage);
    public NetscapeCertType(DerBitString usage);
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.Misc.NetscapeRevocationUrl : DerIA5String {
    public NetscapeRevocationUrl(DerIA5String str);
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.Misc.VerisignCzagExtension : DerIA5String {
    public VerisignCzagExtension(DerIA5String str);
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.Mozilla.PublicKeyAndChallenge : Asn1Encodable {
    private Asn1Sequence pkacSeq;
    private SubjectPublicKeyInfo spki;
    private DerIA5String challenge;
    public SubjectPublicKeyInfo SubjectPublicKeyInfo { get; }
    public DerIA5String Challenge { get; }
    public PublicKeyAndChallenge(Asn1Sequence seq);
    public static PublicKeyAndChallenge GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public SubjectPublicKeyInfo get_SubjectPublicKeyInfo();
    public DerIA5String get_Challenge();
}
public class Org.BouncyCastle.Asn1.Nist.KMacWithShake128Params : Asn1Encodable {
    private static Byte[] EMPTY_STRING;
    private static int DEF_LENGTH;
    private int outputLength;
    private Byte[] customizationString;
    public int OutputLength { get; }
    public Byte[] CustomizationString { get; }
    public KMacWithShake128Params(int outputLength);
    public KMacWithShake128Params(int outputLength, Byte[] customizationString);
    private KMacWithShake128Params(Asn1Sequence seq);
    private static KMacWithShake128Params();
    public static KMacWithShake128Params GetInstance(object o);
    public int get_OutputLength();
    public Byte[] get_CustomizationString();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Nist.KMacWithShake256Params : Asn1Encodable {
    private static Byte[] EMPTY_STRING;
    private static int DEF_LENGTH;
    private int outputLength;
    private Byte[] customizationString;
    public int OutputLength { get; }
    public Byte[] CustomizationString { get; }
    public KMacWithShake256Params(int outputLength);
    public KMacWithShake256Params(int outputLength, Byte[] customizationString);
    private KMacWithShake256Params(Asn1Sequence seq);
    private static KMacWithShake256Params();
    public static KMacWithShake256Params GetInstance(object o);
    public int get_OutputLength();
    public Byte[] get_CustomizationString();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Nist.NistNamedCurves : object {
    private static IDictionary objIds;
    private static IDictionary names;
    public static IEnumerable Names { get; }
    private static NistNamedCurves();
    private static void DefineCurveAlias(string name, DerObjectIdentifier oid);
    public static X9ECParameters GetByName(string name);
    public static X9ECParameters GetByOid(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static string GetName(DerObjectIdentifier oid);
    public static IEnumerable get_Names();
}
public class Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers : object {
    public static DerObjectIdentifier NistAlgorithm;
    public static DerObjectIdentifier HashAlgs;
    public static DerObjectIdentifier IdSha256;
    public static DerObjectIdentifier IdSha384;
    public static DerObjectIdentifier IdSha512;
    public static DerObjectIdentifier IdSha224;
    public static DerObjectIdentifier IdSha512_224;
    public static DerObjectIdentifier IdSha512_256;
    public static DerObjectIdentifier IdSha3_224;
    public static DerObjectIdentifier IdSha3_256;
    public static DerObjectIdentifier IdSha3_384;
    public static DerObjectIdentifier IdSha3_512;
    public static DerObjectIdentifier IdShake128;
    public static DerObjectIdentifier IdShake256;
    public static DerObjectIdentifier IdHMacWithSha3_224;
    public static DerObjectIdentifier IdHMacWithSha3_256;
    public static DerObjectIdentifier IdHMacWithSha3_384;
    public static DerObjectIdentifier IdHMacWithSha3_512;
    public static DerObjectIdentifier IdShake128Len;
    public static DerObjectIdentifier IdShake256Len;
    public static DerObjectIdentifier IdKmacWithShake128;
    public static DerObjectIdentifier IdKmacWithShake256;
    public static DerObjectIdentifier Aes;
    public static DerObjectIdentifier IdAes128Ecb;
    public static DerObjectIdentifier IdAes128Cbc;
    public static DerObjectIdentifier IdAes128Ofb;
    public static DerObjectIdentifier IdAes128Cfb;
    public static DerObjectIdentifier IdAes128Wrap;
    public static DerObjectIdentifier IdAes128Gcm;
    public static DerObjectIdentifier IdAes128Ccm;
    public static DerObjectIdentifier IdAes192Ecb;
    public static DerObjectIdentifier IdAes192Cbc;
    public static DerObjectIdentifier IdAes192Ofb;
    public static DerObjectIdentifier IdAes192Cfb;
    public static DerObjectIdentifier IdAes192Wrap;
    public static DerObjectIdentifier IdAes192Gcm;
    public static DerObjectIdentifier IdAes192Ccm;
    public static DerObjectIdentifier IdAes256Ecb;
    public static DerObjectIdentifier IdAes256Cbc;
    public static DerObjectIdentifier IdAes256Ofb;
    public static DerObjectIdentifier IdAes256Cfb;
    public static DerObjectIdentifier IdAes256Wrap;
    public static DerObjectIdentifier IdAes256Gcm;
    public static DerObjectIdentifier IdAes256Ccm;
    public static DerObjectIdentifier IdDsaWithSha2;
    public static DerObjectIdentifier DsaWithSha224;
    public static DerObjectIdentifier DsaWithSha256;
    public static DerObjectIdentifier DsaWithSha384;
    public static DerObjectIdentifier DsaWithSha512;
    public static DerObjectIdentifier IdDsaWithSha3_224;
    public static DerObjectIdentifier IdDsaWithSha3_256;
    public static DerObjectIdentifier IdDsaWithSha3_384;
    public static DerObjectIdentifier IdDsaWithSha3_512;
    public static DerObjectIdentifier IdEcdsaWithSha3_224;
    public static DerObjectIdentifier IdEcdsaWithSha3_256;
    public static DerObjectIdentifier IdEcdsaWithSha3_384;
    public static DerObjectIdentifier IdEcdsaWithSha3_512;
    public static DerObjectIdentifier IdRsassaPkcs1V15WithSha3_224;
    public static DerObjectIdentifier IdRsassaPkcs1V15WithSha3_256;
    public static DerObjectIdentifier IdRsassaPkcs1V15WithSha3_384;
    public static DerObjectIdentifier IdRsassaPkcs1V15WithSha3_512;
    private static NistObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Nsri.NsriObjectIdentifiers : object {
    public static DerObjectIdentifier nsri;
    public static DerObjectIdentifier id_algorithm;
    public static DerObjectIdentifier id_sea;
    public static DerObjectIdentifier id_pad;
    public static DerObjectIdentifier id_pad_null;
    public static DerObjectIdentifier id_pad_1;
    public static DerObjectIdentifier id_aria128_ecb;
    public static DerObjectIdentifier id_aria128_cbc;
    public static DerObjectIdentifier id_aria128_cfb;
    public static DerObjectIdentifier id_aria128_ofb;
    public static DerObjectIdentifier id_aria128_ctr;
    public static DerObjectIdentifier id_aria192_ecb;
    public static DerObjectIdentifier id_aria192_cbc;
    public static DerObjectIdentifier id_aria192_cfb;
    public static DerObjectIdentifier id_aria192_ofb;
    public static DerObjectIdentifier id_aria192_ctr;
    public static DerObjectIdentifier id_aria256_ecb;
    public static DerObjectIdentifier id_aria256_cbc;
    public static DerObjectIdentifier id_aria256_cfb;
    public static DerObjectIdentifier id_aria256_ofb;
    public static DerObjectIdentifier id_aria256_ctr;
    public static DerObjectIdentifier id_aria128_cmac;
    public static DerObjectIdentifier id_aria192_cmac;
    public static DerObjectIdentifier id_aria256_cmac;
    public static DerObjectIdentifier id_aria128_ocb2;
    public static DerObjectIdentifier id_aria192_ocb2;
    public static DerObjectIdentifier id_aria256_ocb2;
    public static DerObjectIdentifier id_aria128_gcm;
    public static DerObjectIdentifier id_aria192_gcm;
    public static DerObjectIdentifier id_aria256_gcm;
    public static DerObjectIdentifier id_aria128_ccm;
    public static DerObjectIdentifier id_aria192_ccm;
    public static DerObjectIdentifier id_aria256_ccm;
    public static DerObjectIdentifier id_aria128_kw;
    public static DerObjectIdentifier id_aria192_kw;
    public static DerObjectIdentifier id_aria256_kw;
    public static DerObjectIdentifier id_aria128_kwp;
    public static DerObjectIdentifier id_aria192_kwp;
    public static DerObjectIdentifier id_aria256_kwp;
    private static NsriObjectIdentifiers();
}
public abstract class Org.BouncyCastle.Asn1.Ntt.NttObjectIdentifiers : object {
    public static DerObjectIdentifier IdCamellia128Cbc;
    public static DerObjectIdentifier IdCamellia192Cbc;
    public static DerObjectIdentifier IdCamellia256Cbc;
    public static DerObjectIdentifier IdCamellia128Wrap;
    public static DerObjectIdentifier IdCamellia192Wrap;
    public static DerObjectIdentifier IdCamellia256Wrap;
    private static NttObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Ocsp.BasicOcspResponse : Asn1Encodable {
    private ResponseData tbsResponseData;
    private AlgorithmIdentifier signatureAlgorithm;
    private DerBitString signature;
    private Asn1Sequence certs;
    public ResponseData TbsResponseData { get; }
    public AlgorithmIdentifier SignatureAlgorithm { get; }
    public DerBitString Signature { get; }
    public Asn1Sequence Certs { get; }
    public BasicOcspResponse(ResponseData tbsResponseData, AlgorithmIdentifier signatureAlgorithm, DerBitString signature, Asn1Sequence certs);
    private BasicOcspResponse(Asn1Sequence seq);
    public static BasicOcspResponse GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static BasicOcspResponse GetInstance(object obj);
    [ObsoleteAttribute("Use TbsResponseData property instead")]
public ResponseData GetTbsResponseData();
    public ResponseData get_TbsResponseData();
    [ObsoleteAttribute("Use SignatureAlgorithm property instead")]
public AlgorithmIdentifier GetSignatureAlgorithm();
    public AlgorithmIdentifier get_SignatureAlgorithm();
    [ObsoleteAttribute("Use Signature property instead")]
public DerBitString GetSignature();
    public DerBitString get_Signature();
    public Byte[] GetSignatureOctets();
    [ObsoleteAttribute("Use Certs property instead")]
public Asn1Sequence GetCerts();
    public Asn1Sequence get_Certs();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.CertID : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private Asn1OctetString issuerNameHash;
    private Asn1OctetString issuerKeyHash;
    private DerInteger serialNumber;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public Asn1OctetString IssuerNameHash { get; }
    public Asn1OctetString IssuerKeyHash { get; }
    public DerInteger SerialNumber { get; }
    public CertID(AlgorithmIdentifier hashAlgorithm, Asn1OctetString issuerNameHash, Asn1OctetString issuerKeyHash, DerInteger serialNumber);
    private CertID(Asn1Sequence seq);
    public static CertID GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static CertID GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public Asn1OctetString get_IssuerNameHash();
    public Asn1OctetString get_IssuerKeyHash();
    public DerInteger get_SerialNumber();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.CertStatus : Asn1Encodable {
    private int tagNo;
    private Asn1Encodable value;
    public int TagNo { get; }
    public Asn1Encodable Status { get; }
    public CertStatus(RevokedInfo info);
    public CertStatus(int tagNo, Asn1Encodable value);
    public CertStatus(Asn1TaggedObject choice);
    public static CertStatus GetInstance(object obj);
    public int get_TagNo();
    public Asn1Encodable get_Status();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.CrlID : Asn1Encodable {
    private DerIA5String crlUrl;
    private DerInteger crlNum;
    private DerGeneralizedTime crlTime;
    public DerIA5String CrlUrl { get; }
    public DerInteger CrlNum { get; }
    public DerGeneralizedTime CrlTime { get; }
    public CrlID(Asn1Sequence seq);
    public DerIA5String get_CrlUrl();
    public DerInteger get_CrlNum();
    public DerGeneralizedTime get_CrlTime();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Ocsp.OcspObjectIdentifiers : object {
    internal static string PkixOcspId;
    public static DerObjectIdentifier PkixOcsp;
    public static DerObjectIdentifier PkixOcspBasic;
    public static DerObjectIdentifier PkixOcspNonce;
    public static DerObjectIdentifier PkixOcspCrl;
    public static DerObjectIdentifier PkixOcspResponse;
    public static DerObjectIdentifier PkixOcspNocheck;
    public static DerObjectIdentifier PkixOcspArchiveCutoff;
    public static DerObjectIdentifier PkixOcspServiceLocator;
    private static OcspObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Ocsp.OcspRequest : Asn1Encodable {
    private TbsRequest tbsRequest;
    private Signature optionalSignature;
    public TbsRequest TbsRequest { get; }
    public Signature OptionalSignature { get; }
    public OcspRequest(TbsRequest tbsRequest, Signature optionalSignature);
    private OcspRequest(Asn1Sequence seq);
    public static OcspRequest GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static OcspRequest GetInstance(object obj);
    public TbsRequest get_TbsRequest();
    public Signature get_OptionalSignature();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.OcspResponse : Asn1Encodable {
    private OcspResponseStatus responseStatus;
    private ResponseBytes responseBytes;
    public OcspResponseStatus ResponseStatus { get; }
    public ResponseBytes ResponseBytes { get; }
    public OcspResponse(OcspResponseStatus responseStatus, ResponseBytes responseBytes);
    private OcspResponse(Asn1Sequence seq);
    public static OcspResponse GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static OcspResponse GetInstance(object obj);
    public OcspResponseStatus get_ResponseStatus();
    public ResponseBytes get_ResponseBytes();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.OcspResponseStatus : DerEnumerated {
    public static int Successful;
    public static int MalformedRequest;
    public static int InternalError;
    public static int TryLater;
    public static int SignatureRequired;
    public static int Unauthorized;
    public OcspResponseStatus(int value);
    public OcspResponseStatus(DerEnumerated value);
}
public class Org.BouncyCastle.Asn1.Ocsp.Request : Asn1Encodable {
    private CertID reqCert;
    private X509Extensions singleRequestExtensions;
    public CertID ReqCert { get; }
    public X509Extensions SingleRequestExtensions { get; }
    public Request(CertID reqCert, X509Extensions singleRequestExtensions);
    private Request(Asn1Sequence seq);
    public static Request GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Request GetInstance(object obj);
    public CertID get_ReqCert();
    public X509Extensions get_SingleRequestExtensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.ResponderID : Asn1Encodable {
    private Asn1Encodable id;
    public X509Name Name { get; }
    public ResponderID(Asn1OctetString id);
    public ResponderID(X509Name id);
    public static ResponderID GetInstance(object obj);
    public static ResponderID GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual Byte[] GetKeyHash();
    public virtual X509Name get_Name();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.ResponseBytes : Asn1Encodable {
    private DerObjectIdentifier responseType;
    private Asn1OctetString response;
    public DerObjectIdentifier ResponseType { get; }
    public Asn1OctetString Response { get; }
    public ResponseBytes(DerObjectIdentifier responseType, Asn1OctetString response);
    private ResponseBytes(Asn1Sequence seq);
    public static ResponseBytes GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static ResponseBytes GetInstance(object obj);
    public DerObjectIdentifier get_ResponseType();
    public Asn1OctetString get_Response();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.ResponseData : Asn1Encodable {
    private static DerInteger V1;
    private bool versionPresent;
    private DerInteger version;
    private ResponderID responderID;
    private DerGeneralizedTime producedAt;
    private Asn1Sequence responses;
    private X509Extensions responseExtensions;
    public DerInteger Version { get; }
    public ResponderID ResponderID { get; }
    public DerGeneralizedTime ProducedAt { get; }
    public Asn1Sequence Responses { get; }
    public X509Extensions ResponseExtensions { get; }
    public ResponseData(DerInteger version, ResponderID responderID, DerGeneralizedTime producedAt, Asn1Sequence responses, X509Extensions responseExtensions);
    public ResponseData(ResponderID responderID, DerGeneralizedTime producedAt, Asn1Sequence responses, X509Extensions responseExtensions);
    private ResponseData(Asn1Sequence seq);
    private static ResponseData();
    public static ResponseData GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static ResponseData GetInstance(object obj);
    public DerInteger get_Version();
    public ResponderID get_ResponderID();
    public DerGeneralizedTime get_ProducedAt();
    public Asn1Sequence get_Responses();
    public X509Extensions get_ResponseExtensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.RevokedInfo : Asn1Encodable {
    private DerGeneralizedTime revocationTime;
    private CrlReason revocationReason;
    public DerGeneralizedTime RevocationTime { get; }
    public CrlReason RevocationReason { get; }
    public RevokedInfo(DerGeneralizedTime revocationTime);
    public RevokedInfo(DerGeneralizedTime revocationTime, CrlReason revocationReason);
    private RevokedInfo(Asn1Sequence seq);
    public static RevokedInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static RevokedInfo GetInstance(object obj);
    public DerGeneralizedTime get_RevocationTime();
    public CrlReason get_RevocationReason();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.ServiceLocator : Asn1Encodable {
    private X509Name issuer;
    private Asn1Object locator;
    public X509Name Issuer { get; }
    public Asn1Object Locator { get; }
    public ServiceLocator(X509Name issuer);
    public ServiceLocator(X509Name issuer, Asn1Object locator);
    private ServiceLocator(Asn1Sequence seq);
    public static ServiceLocator GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static ServiceLocator GetInstance(object obj);
    public X509Name get_Issuer();
    public Asn1Object get_Locator();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.Signature : Asn1Encodable {
    internal AlgorithmIdentifier signatureAlgorithm;
    internal DerBitString signatureValue;
    internal Asn1Sequence certs;
    public AlgorithmIdentifier SignatureAlgorithm { get; }
    public DerBitString SignatureValue { get; }
    public Asn1Sequence Certs { get; }
    public Signature(AlgorithmIdentifier signatureAlgorithm, DerBitString signatureValue);
    public Signature(AlgorithmIdentifier signatureAlgorithm, DerBitString signatureValue, Asn1Sequence certs);
    private Signature(Asn1Sequence seq);
    public static Signature GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Signature GetInstance(object obj);
    public AlgorithmIdentifier get_SignatureAlgorithm();
    public DerBitString get_SignatureValue();
    public Byte[] GetSignatureOctets();
    public Asn1Sequence get_Certs();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.SingleResponse : Asn1Encodable {
    private CertID certID;
    private CertStatus certStatus;
    private DerGeneralizedTime thisUpdate;
    private DerGeneralizedTime nextUpdate;
    private X509Extensions singleExtensions;
    public CertID CertId { get; }
    public CertStatus CertStatus { get; }
    public DerGeneralizedTime ThisUpdate { get; }
    public DerGeneralizedTime NextUpdate { get; }
    public X509Extensions SingleExtensions { get; }
    public SingleResponse(CertID certID, CertStatus certStatus, DerGeneralizedTime thisUpdate, DerGeneralizedTime nextUpdate, X509Extensions singleExtensions);
    public SingleResponse(Asn1Sequence seq);
    public static SingleResponse GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static SingleResponse GetInstance(object obj);
    public CertID get_CertId();
    public CertStatus get_CertStatus();
    public DerGeneralizedTime get_ThisUpdate();
    public DerGeneralizedTime get_NextUpdate();
    public X509Extensions get_SingleExtensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.TbsRequest : Asn1Encodable {
    private static DerInteger V1;
    private DerInteger version;
    private GeneralName requestorName;
    private Asn1Sequence requestList;
    private X509Extensions requestExtensions;
    private bool versionSet;
    public DerInteger Version { get; }
    public GeneralName RequestorName { get; }
    public Asn1Sequence RequestList { get; }
    public X509Extensions RequestExtensions { get; }
    public TbsRequest(GeneralName requestorName, Asn1Sequence requestList, X509Extensions requestExtensions);
    private TbsRequest(Asn1Sequence seq);
    private static TbsRequest();
    public static TbsRequest GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static TbsRequest GetInstance(object obj);
    public DerInteger get_Version();
    public GeneralName get_RequestorName();
    public Asn1Sequence get_RequestList();
    public X509Extensions get_RequestExtensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.OidTokenizer : object {
    private string oid;
    private int index;
    public bool HasMoreTokens { get; }
    public OidTokenizer(string oid);
    public bool get_HasMoreTokens();
    public string NextToken();
}
public class Org.BouncyCastle.Asn1.Oiw.ElGamalParameter : Asn1Encodable {
    internal DerInteger p;
    internal DerInteger g;
    public BigInteger P { get; }
    public BigInteger G { get; }
    public ElGamalParameter(BigInteger p, BigInteger g);
    public ElGamalParameter(Asn1Sequence seq);
    public BigInteger get_P();
    public BigInteger get_G();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Oiw.OiwObjectIdentifiers : object {
    public static DerObjectIdentifier MD4WithRsa;
    public static DerObjectIdentifier MD5WithRsa;
    public static DerObjectIdentifier MD4WithRsaEncryption;
    public static DerObjectIdentifier DesEcb;
    public static DerObjectIdentifier DesCbc;
    public static DerObjectIdentifier DesOfb;
    public static DerObjectIdentifier DesCfb;
    public static DerObjectIdentifier DesEde;
    public static DerObjectIdentifier IdSha1;
    public static DerObjectIdentifier DsaWithSha1;
    public static DerObjectIdentifier Sha1WithRsa;
    public static DerObjectIdentifier ElGamalAlgorithm;
    private static OiwObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Pkcs.AttributePkcs : Asn1Encodable {
    private DerObjectIdentifier attrType;
    private Asn1Set attrValues;
    public DerObjectIdentifier AttrType { get; }
    public Asn1Set AttrValues { get; }
    private AttributePkcs(Asn1Sequence seq);
    public AttributePkcs(DerObjectIdentifier attrType, Asn1Set attrValues);
    public static AttributePkcs GetInstance(object obj);
    public DerObjectIdentifier get_AttrType();
    public Asn1Set get_AttrValues();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.AuthenticatedSafe : Asn1Encodable {
    private ContentInfo[] info;
    private bool isBer;
    private AuthenticatedSafe(Asn1Sequence seq);
    public AuthenticatedSafe(ContentInfo[] info);
    private static ContentInfo[] Copy(ContentInfo[] info);
    public static AuthenticatedSafe GetInstance(object obj);
    public ContentInfo[] GetContentInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.CertBag : Asn1Encodable {
    private DerObjectIdentifier certID;
    private Asn1Object certValue;
    public DerObjectIdentifier CertID { get; }
    public Asn1Object CertValue { get; }
    private CertBag(Asn1Sequence seq);
    public CertBag(DerObjectIdentifier certID, Asn1Object certValue);
    public static CertBag GetInstance(object obj);
    public virtual DerObjectIdentifier get_CertID();
    public virtual Asn1Object get_CertValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.CertificationRequest : Asn1Encodable {
    protected CertificationRequestInfo reqInfo;
    protected AlgorithmIdentifier sigAlgId;
    protected DerBitString sigBits;
    public AlgorithmIdentifier SignatureAlgorithm { get; }
    public DerBitString Signature { get; }
    public CertificationRequest(CertificationRequestInfo requestInfo, AlgorithmIdentifier algorithm, DerBitString signature);
    [ObsoleteAttribute("Use 'GetInstance' instead")]
public CertificationRequest(Asn1Sequence seq);
    public static CertificationRequest GetInstance(object obj);
    public CertificationRequestInfo GetCertificationRequestInfo();
    public AlgorithmIdentifier get_SignatureAlgorithm();
    public DerBitString get_Signature();
    public Byte[] GetSignatureOctets();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.CertificationRequestInfo : Asn1Encodable {
    internal DerInteger version;
    internal X509Name subject;
    internal SubjectPublicKeyInfo subjectPKInfo;
    internal Asn1Set attributes;
    public DerInteger Version { get; }
    public X509Name Subject { get; }
    public SubjectPublicKeyInfo SubjectPublicKeyInfo { get; }
    public Asn1Set Attributes { get; }
    public CertificationRequestInfo(X509Name subject, SubjectPublicKeyInfo pkInfo, Asn1Set attributes);
    private CertificationRequestInfo(Asn1Sequence seq);
    public static CertificationRequestInfo GetInstance(object obj);
    public DerInteger get_Version();
    public X509Name get_Subject();
    public SubjectPublicKeyInfo get_SubjectPublicKeyInfo();
    public Asn1Set get_Attributes();
    public virtual Asn1Object ToAsn1Object();
    private static void ValidateAttributes(Asn1Set attributes);
}
public class Org.BouncyCastle.Asn1.Pkcs.ContentInfo : Asn1Encodable {
    private DerObjectIdentifier contentType;
    private Asn1Encodable content;
    public DerObjectIdentifier ContentType { get; }
    public Asn1Encodable Content { get; }
    private ContentInfo(Asn1Sequence seq);
    public ContentInfo(DerObjectIdentifier contentType, Asn1Encodable content);
    public static ContentInfo GetInstance(object obj);
    public DerObjectIdentifier get_ContentType();
    public Asn1Encodable get_Content();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.DHParameter : Asn1Encodable {
    internal DerInteger p;
    internal DerInteger g;
    internal DerInteger l;
    public BigInteger P { get; }
    public BigInteger G { get; }
    public BigInteger L { get; }
    public DHParameter(BigInteger p, BigInteger g, int l);
    public DHParameter(Asn1Sequence seq);
    public BigInteger get_P();
    public BigInteger get_G();
    public BigInteger get_L();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.EncryptedData : Asn1Encodable {
    private Asn1Sequence data;
    public DerObjectIdentifier ContentType { get; }
    public AlgorithmIdentifier EncryptionAlgorithm { get; }
    public Asn1OctetString Content { get; }
    private EncryptedData(Asn1Sequence seq);
    public EncryptedData(DerObjectIdentifier contentType, AlgorithmIdentifier encryptionAlgorithm, Asn1Encodable content);
    public static EncryptedData GetInstance(object obj);
    public DerObjectIdentifier get_ContentType();
    public AlgorithmIdentifier get_EncryptionAlgorithm();
    public Asn1OctetString get_Content();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.EncryptedPrivateKeyInfo : Asn1Encodable {
    private AlgorithmIdentifier algId;
    private Asn1OctetString data;
    public AlgorithmIdentifier EncryptionAlgorithm { get; }
    private EncryptedPrivateKeyInfo(Asn1Sequence seq);
    public EncryptedPrivateKeyInfo(AlgorithmIdentifier algId, Byte[] encoding);
    public static EncryptedPrivateKeyInfo GetInstance(object obj);
    public AlgorithmIdentifier get_EncryptionAlgorithm();
    public Byte[] GetEncryptedData();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.EncryptionScheme : AlgorithmIdentifier {
    public Asn1Object Asn1Object { get; }
    public EncryptionScheme(DerObjectIdentifier objectID);
    public EncryptionScheme(DerObjectIdentifier objectID, Asn1Encodable parameters);
    internal EncryptionScheme(Asn1Sequence seq);
    public static EncryptionScheme GetInstance(object obj);
    public Asn1Object get_Asn1Object();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.IssuerAndSerialNumber : Asn1Encodable {
    private X509Name name;
    private DerInteger certSerialNumber;
    public X509Name Name { get; }
    public DerInteger CertificateSerialNumber { get; }
    private IssuerAndSerialNumber(Asn1Sequence seq);
    public IssuerAndSerialNumber(X509Name name, BigInteger certSerialNumber);
    public IssuerAndSerialNumber(X509Name name, DerInteger certSerialNumber);
    public static IssuerAndSerialNumber GetInstance(object obj);
    public X509Name get_Name();
    public DerInteger get_CertificateSerialNumber();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.KeyDerivationFunc : AlgorithmIdentifier {
    internal KeyDerivationFunc(Asn1Sequence seq);
    public KeyDerivationFunc(DerObjectIdentifier id, Asn1Encodable parameters);
}
public class Org.BouncyCastle.Asn1.Pkcs.MacData : Asn1Encodable {
    internal DigestInfo digInfo;
    internal Byte[] salt;
    internal BigInteger iterationCount;
    public DigestInfo Mac { get; }
    public BigInteger IterationCount { get; }
    private MacData(Asn1Sequence seq);
    public MacData(DigestInfo digInfo, Byte[] salt, int iterationCount);
    public static MacData GetInstance(object obj);
    public DigestInfo get_Mac();
    public Byte[] GetSalt();
    public BigInteger get_IterationCount();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.PbeParameter : Asn1Encodable {
    private Asn1OctetString salt;
    private DerInteger iterationCount;
    public BigInteger IterationCount { get; }
    private PbeParameter(Asn1Sequence seq);
    public PbeParameter(Byte[] salt, int iterationCount);
    public static PbeParameter GetInstance(object obj);
    public Byte[] GetSalt();
    public BigInteger get_IterationCount();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.PbeS2Parameters : Asn1Encodable {
    private KeyDerivationFunc func;
    private EncryptionScheme scheme;
    public KeyDerivationFunc KeyDerivationFunc { get; }
    public EncryptionScheme EncryptionScheme { get; }
    public PbeS2Parameters(KeyDerivationFunc keyDevFunc, EncryptionScheme encScheme);
    [ObsoleteAttribute("Use GetInstance() instead")]
public PbeS2Parameters(Asn1Sequence seq);
    public static PbeS2Parameters GetInstance(object obj);
    public KeyDerivationFunc get_KeyDerivationFunc();
    public EncryptionScheme get_EncryptionScheme();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.Pbkdf2Params : Asn1Encodable {
    private static AlgorithmIdentifier algid_hmacWithSHA1;
    private Asn1OctetString octStr;
    private DerInteger iterationCount;
    private DerInteger keyLength;
    private AlgorithmIdentifier prf;
    public BigInteger IterationCount { get; }
    public BigInteger KeyLength { get; }
    public bool IsDefaultPrf { get; }
    public AlgorithmIdentifier Prf { get; }
    public Pbkdf2Params(Asn1Sequence seq);
    public Pbkdf2Params(Byte[] salt, int iterationCount);
    public Pbkdf2Params(Byte[] salt, int iterationCount, int keyLength);
    public Pbkdf2Params(Byte[] salt, int iterationCount, int keyLength, AlgorithmIdentifier prf);
    public Pbkdf2Params(Byte[] salt, int iterationCount, AlgorithmIdentifier prf);
    private static Pbkdf2Params();
    public static Pbkdf2Params GetInstance(object obj);
    public Byte[] GetSalt();
    public BigInteger get_IterationCount();
    public BigInteger get_KeyLength();
    public bool get_IsDefaultPrf();
    public AlgorithmIdentifier get_Prf();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.Pfx : Asn1Encodable {
    private ContentInfo contentInfo;
    private MacData macData;
    public ContentInfo AuthSafe { get; }
    public MacData MacData { get; }
    private Pfx(Asn1Sequence seq);
    public Pfx(ContentInfo contentInfo, MacData macData);
    public static Pfx GetInstance(object obj);
    public ContentInfo get_AuthSafe();
    public MacData get_MacData();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.Pkcs12PbeParams : Asn1Encodable {
    private DerInteger iterations;
    private Asn1OctetString iv;
    public BigInteger Iterations { get; }
    public Pkcs12PbeParams(Byte[] salt, int iterations);
    private Pkcs12PbeParams(Asn1Sequence seq);
    public static Pkcs12PbeParams GetInstance(object obj);
    public BigInteger get_Iterations();
    public Byte[] GetIV();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Pkcs.PkcsObjectIdentifiers : object {
    public static string Pkcs1;
    internal static DerObjectIdentifier Pkcs1Oid;
    public static DerObjectIdentifier RsaEncryption;
    public static DerObjectIdentifier MD2WithRsaEncryption;
    public static DerObjectIdentifier MD4WithRsaEncryption;
    public static DerObjectIdentifier MD5WithRsaEncryption;
    public static DerObjectIdentifier Sha1WithRsaEncryption;
    public static DerObjectIdentifier SrsaOaepEncryptionSet;
    public static DerObjectIdentifier IdRsaesOaep;
    public static DerObjectIdentifier IdMgf1;
    public static DerObjectIdentifier IdPSpecified;
    public static DerObjectIdentifier IdRsassaPss;
    public static DerObjectIdentifier Sha256WithRsaEncryption;
    public static DerObjectIdentifier Sha384WithRsaEncryption;
    public static DerObjectIdentifier Sha512WithRsaEncryption;
    public static DerObjectIdentifier Sha224WithRsaEncryption;
    public static DerObjectIdentifier Sha512_224WithRSAEncryption;
    public static DerObjectIdentifier Sha512_256WithRSAEncryption;
    public static string Pkcs3;
    public static DerObjectIdentifier DhKeyAgreement;
    public static string Pkcs5;
    public static DerObjectIdentifier PbeWithMD2AndDesCbc;
    public static DerObjectIdentifier PbeWithMD2AndRC2Cbc;
    public static DerObjectIdentifier PbeWithMD5AndDesCbc;
    public static DerObjectIdentifier PbeWithMD5AndRC2Cbc;
    public static DerObjectIdentifier PbeWithSha1AndDesCbc;
    public static DerObjectIdentifier PbeWithSha1AndRC2Cbc;
    public static DerObjectIdentifier IdPbeS2;
    public static DerObjectIdentifier IdPbkdf2;
    public static string EncryptionAlgorithm;
    public static DerObjectIdentifier DesEde3Cbc;
    public static DerObjectIdentifier RC2Cbc;
    public static DerObjectIdentifier rc4;
    public static string DigestAlgorithm;
    public static DerObjectIdentifier MD2;
    public static DerObjectIdentifier MD4;
    public static DerObjectIdentifier MD5;
    public static DerObjectIdentifier IdHmacWithSha1;
    public static DerObjectIdentifier IdHmacWithSha224;
    public static DerObjectIdentifier IdHmacWithSha256;
    public static DerObjectIdentifier IdHmacWithSha384;
    public static DerObjectIdentifier IdHmacWithSha512;
    public static string Pkcs7;
    public static DerObjectIdentifier Data;
    public static DerObjectIdentifier SignedData;
    public static DerObjectIdentifier EnvelopedData;
    public static DerObjectIdentifier SignedAndEnvelopedData;
    public static DerObjectIdentifier DigestedData;
    public static DerObjectIdentifier EncryptedData;
    public static string Pkcs9;
    public static DerObjectIdentifier Pkcs9AtEmailAddress;
    public static DerObjectIdentifier Pkcs9AtUnstructuredName;
    public static DerObjectIdentifier Pkcs9AtContentType;
    public static DerObjectIdentifier Pkcs9AtMessageDigest;
    public static DerObjectIdentifier Pkcs9AtSigningTime;
    public static DerObjectIdentifier Pkcs9AtCounterSignature;
    public static DerObjectIdentifier Pkcs9AtChallengePassword;
    public static DerObjectIdentifier Pkcs9AtUnstructuredAddress;
    public static DerObjectIdentifier Pkcs9AtExtendedCertificateAttributes;
    public static DerObjectIdentifier Pkcs9AtSigningDescription;
    public static DerObjectIdentifier Pkcs9AtExtensionRequest;
    public static DerObjectIdentifier Pkcs9AtSmimeCapabilities;
    public static DerObjectIdentifier IdSmime;
    public static DerObjectIdentifier Pkcs9AtFriendlyName;
    public static DerObjectIdentifier Pkcs9AtLocalKeyID;
    [ObsoleteAttribute("Use X509Certificate instead")]
public static DerObjectIdentifier X509CertType;
    public static string CertTypes;
    public static DerObjectIdentifier X509Certificate;
    public static DerObjectIdentifier SdsiCertificate;
    public static string CrlTypes;
    public static DerObjectIdentifier X509Crl;
    public static DerObjectIdentifier IdAlg;
    public static DerObjectIdentifier IdAlgEsdh;
    public static DerObjectIdentifier IdAlgCms3DesWrap;
    public static DerObjectIdentifier IdAlgCmsRC2Wrap;
    public static DerObjectIdentifier IdAlgPwriKek;
    public static DerObjectIdentifier IdAlgSsdh;
    public static DerObjectIdentifier IdRsaKem;
    public static DerObjectIdentifier IdAlgAeadChaCha20Poly1305;
    public static DerObjectIdentifier PreferSignedData;
    public static DerObjectIdentifier CannotDecryptAny;
    public static DerObjectIdentifier SmimeCapabilitiesVersions;
    public static DerObjectIdentifier IdAAReceiptRequest;
    public static string IdCT;
    public static DerObjectIdentifier IdCTAuthData;
    public static DerObjectIdentifier IdCTTstInfo;
    public static DerObjectIdentifier IdCTCompressedData;
    public static DerObjectIdentifier IdCTAuthEnvelopedData;
    public static DerObjectIdentifier IdCTTimestampedData;
    public static string IdCti;
    public static DerObjectIdentifier IdCtiEtsProofOfOrigin;
    public static DerObjectIdentifier IdCtiEtsProofOfReceipt;
    public static DerObjectIdentifier IdCtiEtsProofOfDelivery;
    public static DerObjectIdentifier IdCtiEtsProofOfSender;
    public static DerObjectIdentifier IdCtiEtsProofOfApproval;
    public static DerObjectIdentifier IdCtiEtsProofOfCreation;
    public static string IdAA;
    public static DerObjectIdentifier IdAAOid;
    public static DerObjectIdentifier IdAAContentHint;
    public static DerObjectIdentifier IdAAMsgSigDigest;
    public static DerObjectIdentifier IdAAContentReference;
    public static DerObjectIdentifier IdAAEncrypKeyPref;
    public static DerObjectIdentifier IdAASigningCertificate;
    public static DerObjectIdentifier IdAASigningCertificateV2;
    public static DerObjectIdentifier IdAAContentIdentifier;
    public static DerObjectIdentifier IdAASignatureTimeStampToken;
    public static DerObjectIdentifier IdAAEtsSigPolicyID;
    public static DerObjectIdentifier IdAAEtsCommitmentType;
    public static DerObjectIdentifier IdAAEtsSignerLocation;
    public static DerObjectIdentifier IdAAEtsSignerAttr;
    public static DerObjectIdentifier IdAAEtsOtherSigCert;
    public static DerObjectIdentifier IdAAEtsContentTimestamp;
    public static DerObjectIdentifier IdAAEtsCertificateRefs;
    public static DerObjectIdentifier IdAAEtsRevocationRefs;
    public static DerObjectIdentifier IdAAEtsCertValues;
    public static DerObjectIdentifier IdAAEtsRevocationValues;
    public static DerObjectIdentifier IdAAEtsEscTimeStamp;
    public static DerObjectIdentifier IdAAEtsCertCrlTimestamp;
    public static DerObjectIdentifier IdAAEtsArchiveTimestamp;
    public static DerObjectIdentifier IdAADecryptKeyID;
    public static DerObjectIdentifier IdAAImplCryptoAlgs;
    public static DerObjectIdentifier IdAAAsymmDecryptKeyID;
    public static DerObjectIdentifier IdAAImplCompressAlgs;
    public static DerObjectIdentifier IdAACommunityIdentifiers;
    [ObsoleteAttribute("Use 'IdAAEtsSigPolicyID' instead")]
public static DerObjectIdentifier IdAASigPolicyID;
    [ObsoleteAttribute("Use 'IdAAEtsCommitmentType' instead")]
public static DerObjectIdentifier IdAACommitmentType;
    [ObsoleteAttribute("Use 'IdAAEtsSignerLocation' instead")]
public static DerObjectIdentifier IdAASignerLocation;
    [ObsoleteAttribute("Use 'IdAAEtsOtherSigCert' instead")]
public static DerObjectIdentifier IdAAOtherSigCert;
    public static string IdSpq;
    public static DerObjectIdentifier IdSpqEtsUri;
    public static DerObjectIdentifier IdSpqEtsUNotice;
    public static string Pkcs12;
    public static string BagTypes;
    public static DerObjectIdentifier KeyBag;
    public static DerObjectIdentifier Pkcs8ShroudedKeyBag;
    public static DerObjectIdentifier CertBag;
    public static DerObjectIdentifier CrlBag;
    public static DerObjectIdentifier SecretBag;
    public static DerObjectIdentifier SafeContentsBag;
    public static string Pkcs12PbeIds;
    public static DerObjectIdentifier PbeWithShaAnd128BitRC4;
    public static DerObjectIdentifier PbeWithShaAnd40BitRC4;
    public static DerObjectIdentifier PbeWithShaAnd3KeyTripleDesCbc;
    public static DerObjectIdentifier PbeWithShaAnd2KeyTripleDesCbc;
    public static DerObjectIdentifier PbeWithShaAnd128BitRC2Cbc;
    public static DerObjectIdentifier PbewithShaAnd40BitRC2Cbc;
    private static PkcsObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Pkcs.PrivateKeyInfo : Asn1Encodable {
    private DerInteger version;
    private AlgorithmIdentifier privateKeyAlgorithm;
    private Asn1OctetString privateKey;
    private Asn1Set attributes;
    private DerBitString publicKey;
    public DerInteger Version { get; }
    public Asn1Set Attributes { get; }
    public bool HasPublicKey { get; }
    public AlgorithmIdentifier PrivateKeyAlgorithm { get; }
    public Asn1OctetString PrivateKeyData { get; }
    public DerBitString PublicKeyData { get; }
    public PrivateKeyInfo(AlgorithmIdentifier privateKeyAlgorithm, Asn1Encodable privateKey);
    public PrivateKeyInfo(AlgorithmIdentifier privateKeyAlgorithm, Asn1Encodable privateKey, Asn1Set attributes);
    public PrivateKeyInfo(AlgorithmIdentifier privateKeyAlgorithm, Asn1Encodable privateKey, Asn1Set attributes, Byte[] publicKey);
    private PrivateKeyInfo(Asn1Sequence seq);
    public static PrivateKeyInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static PrivateKeyInfo GetInstance(object obj);
    private static int GetVersionValue(DerInteger version);
    public virtual DerInteger get_Version();
    public virtual Asn1Set get_Attributes();
    public virtual bool get_HasPublicKey();
    public virtual AlgorithmIdentifier get_PrivateKeyAlgorithm();
    public virtual Asn1OctetString get_PrivateKeyData();
    public virtual Asn1Object ParsePrivateKey();
    public virtual Asn1Object ParsePublicKey();
    public virtual DerBitString get_PublicKeyData();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.RC2CbcParameter : Asn1Encodable {
    internal DerInteger version;
    internal Asn1OctetString iv;
    public BigInteger RC2ParameterVersion { get; }
    public RC2CbcParameter(Byte[] iv);
    public RC2CbcParameter(int parameterVersion, Byte[] iv);
    private RC2CbcParameter(Asn1Sequence seq);
    public static RC2CbcParameter GetInstance(object obj);
    public BigInteger get_RC2ParameterVersion();
    public Byte[] GetIV();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.RsaesOaepParameters : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private AlgorithmIdentifier maskGenAlgorithm;
    private AlgorithmIdentifier pSourceAlgorithm;
    public static AlgorithmIdentifier DefaultHashAlgorithm;
    public static AlgorithmIdentifier DefaultMaskGenFunction;
    public static AlgorithmIdentifier DefaultPSourceAlgorithm;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public AlgorithmIdentifier MaskGenAlgorithm { get; }
    public AlgorithmIdentifier PSourceAlgorithm { get; }
    public RsaesOaepParameters(AlgorithmIdentifier hashAlgorithm, AlgorithmIdentifier maskGenAlgorithm);
    public RsaesOaepParameters(AlgorithmIdentifier hashAlgorithm, AlgorithmIdentifier maskGenAlgorithm, AlgorithmIdentifier pSourceAlgorithm);
    public RsaesOaepParameters(Asn1Sequence seq);
    private static RsaesOaepParameters();
    public static RsaesOaepParameters GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public AlgorithmIdentifier get_MaskGenAlgorithm();
    public AlgorithmIdentifier get_PSourceAlgorithm();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.RsaPrivateKeyStructure : Asn1Encodable {
    private BigInteger modulus;
    private BigInteger publicExponent;
    private BigInteger privateExponent;
    private BigInteger prime1;
    private BigInteger prime2;
    private BigInteger exponent1;
    private BigInteger exponent2;
    private BigInteger coefficient;
    public BigInteger Modulus { get; }
    public BigInteger PublicExponent { get; }
    public BigInteger PrivateExponent { get; }
    public BigInteger Prime1 { get; }
    public BigInteger Prime2 { get; }
    public BigInteger Exponent1 { get; }
    public BigInteger Exponent2 { get; }
    public BigInteger Coefficient { get; }
    public RsaPrivateKeyStructure(BigInteger modulus, BigInteger publicExponent, BigInteger privateExponent, BigInteger prime1, BigInteger prime2, BigInteger exponent1, BigInteger exponent2, BigInteger coefficient);
    [ObsoleteAttribute("Use 'GetInstance' method(s) instead")]
public RsaPrivateKeyStructure(Asn1Sequence seq);
    public static RsaPrivateKeyStructure GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static RsaPrivateKeyStructure GetInstance(object obj);
    public BigInteger get_Modulus();
    public BigInteger get_PublicExponent();
    public BigInteger get_PrivateExponent();
    public BigInteger get_Prime1();
    public BigInteger get_Prime2();
    public BigInteger get_Exponent1();
    public BigInteger get_Exponent2();
    public BigInteger get_Coefficient();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.RsassaPssParameters : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private AlgorithmIdentifier maskGenAlgorithm;
    private DerInteger saltLength;
    private DerInteger trailerField;
    public static AlgorithmIdentifier DefaultHashAlgorithm;
    public static AlgorithmIdentifier DefaultMaskGenFunction;
    public static DerInteger DefaultSaltLength;
    public static DerInteger DefaultTrailerField;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public AlgorithmIdentifier MaskGenAlgorithm { get; }
    public DerInteger SaltLength { get; }
    public DerInteger TrailerField { get; }
    public RsassaPssParameters(AlgorithmIdentifier hashAlgorithm, AlgorithmIdentifier maskGenAlgorithm, DerInteger saltLength, DerInteger trailerField);
    public RsassaPssParameters(Asn1Sequence seq);
    private static RsassaPssParameters();
    public static RsassaPssParameters GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public AlgorithmIdentifier get_MaskGenAlgorithm();
    public DerInteger get_SaltLength();
    public DerInteger get_TrailerField();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.SafeBag : Asn1Encodable {
    private DerObjectIdentifier bagID;
    private Asn1Object bagValue;
    private Asn1Set bagAttributes;
    public DerObjectIdentifier BagID { get; }
    public Asn1Object BagValue { get; }
    public Asn1Set BagAttributes { get; }
    public SafeBag(DerObjectIdentifier oid, Asn1Object obj);
    public SafeBag(DerObjectIdentifier oid, Asn1Object obj, Asn1Set bagAttributes);
    private SafeBag(Asn1Sequence seq);
    public static SafeBag GetInstance(object obj);
    public DerObjectIdentifier get_BagID();
    public Asn1Object get_BagValue();
    public Asn1Set get_BagAttributes();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.SignedData : Asn1Encodable {
    private DerInteger version;
    private Asn1Set digestAlgorithms;
    private ContentInfo contentInfo;
    private Asn1Set certificates;
    private Asn1Set crls;
    private Asn1Set signerInfos;
    public DerInteger Version { get; }
    public Asn1Set DigestAlgorithms { get; }
    public ContentInfo ContentInfo { get; }
    public Asn1Set Certificates { get; }
    public Asn1Set Crls { get; }
    public Asn1Set SignerInfos { get; }
    public SignedData(DerInteger _version, Asn1Set _digestAlgorithms, ContentInfo _contentInfo, Asn1Set _certificates, Asn1Set _crls, Asn1Set _signerInfos);
    private SignedData(Asn1Sequence seq);
    public static SignedData GetInstance(object obj);
    public DerInteger get_Version();
    public Asn1Set get_DigestAlgorithms();
    public ContentInfo get_ContentInfo();
    public Asn1Set get_Certificates();
    public Asn1Set get_Crls();
    public Asn1Set get_SignerInfos();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.SignerInfo : Asn1Encodable {
    private DerInteger version;
    private IssuerAndSerialNumber issuerAndSerialNumber;
    private AlgorithmIdentifier digAlgorithm;
    private Asn1Set authenticatedAttributes;
    private AlgorithmIdentifier digEncryptionAlgorithm;
    private Asn1OctetString encryptedDigest;
    private Asn1Set unauthenticatedAttributes;
    public DerInteger Version { get; }
    public IssuerAndSerialNumber IssuerAndSerialNumber { get; }
    public Asn1Set AuthenticatedAttributes { get; }
    public AlgorithmIdentifier DigestAlgorithm { get; }
    public Asn1OctetString EncryptedDigest { get; }
    public AlgorithmIdentifier DigestEncryptionAlgorithm { get; }
    public Asn1Set UnauthenticatedAttributes { get; }
    public SignerInfo(DerInteger version, IssuerAndSerialNumber issuerAndSerialNumber, AlgorithmIdentifier digAlgorithm, Asn1Set authenticatedAttributes, AlgorithmIdentifier digEncryptionAlgorithm, Asn1OctetString encryptedDigest, Asn1Set unauthenticatedAttributes);
    public SignerInfo(Asn1Sequence seq);
    public static SignerInfo GetInstance(object obj);
    public DerInteger get_Version();
    public IssuerAndSerialNumber get_IssuerAndSerialNumber();
    public Asn1Set get_AuthenticatedAttributes();
    public AlgorithmIdentifier get_DigestAlgorithm();
    public Asn1OctetString get_EncryptedDigest();
    public AlgorithmIdentifier get_DigestEncryptionAlgorithm();
    public Asn1Set get_UnauthenticatedAttributes();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Rosstandart.RosstandartObjectIdentifiers : object {
    public static DerObjectIdentifier rosstandart;
    public static DerObjectIdentifier id_tc26;
    public static DerObjectIdentifier id_tc26_gost_3411_12_256;
    public static DerObjectIdentifier id_tc26_gost_3411_12_512;
    public static DerObjectIdentifier id_tc26_hmac_gost_3411_12_256;
    public static DerObjectIdentifier id_tc26_hmac_gost_3411_12_512;
    public static DerObjectIdentifier id_tc26_gost_3410_12_256;
    public static DerObjectIdentifier id_tc26_gost_3410_12_512;
    public static DerObjectIdentifier id_tc26_signwithdigest_gost_3410_12_256;
    public static DerObjectIdentifier id_tc26_signwithdigest_gost_3410_12_512;
    public static DerObjectIdentifier id_tc26_agreement;
    public static DerObjectIdentifier id_tc26_agreement_gost_3410_12_256;
    public static DerObjectIdentifier id_tc26_agreement_gost_3410_12_512;
    public static DerObjectIdentifier id_tc26_gost_3410_12_256_paramSet;
    public static DerObjectIdentifier id_tc26_gost_3410_12_256_paramSetA;
    public static DerObjectIdentifier id_tc26_gost_3410_12_512_paramSet;
    public static DerObjectIdentifier id_tc26_gost_3410_12_512_paramSetA;
    public static DerObjectIdentifier id_tc26_gost_3410_12_512_paramSetB;
    public static DerObjectIdentifier id_tc26_gost_3410_12_512_paramSetC;
    public static DerObjectIdentifier id_tc26_gost_28147_param_Z;
    private static RosstandartObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Sec.ECPrivateKeyStructure : Asn1Encodable {
    private Asn1Sequence seq;
    [ObsoleteAttribute("Use 'GetInstance' instead")]
public ECPrivateKeyStructure(Asn1Sequence seq);
    [ObsoleteAttribute("Use constructor which takes 'orderBitLength' instead, to guarantee correct encoding")]
public ECPrivateKeyStructure(BigInteger key);
    public ECPrivateKeyStructure(int orderBitLength, BigInteger key);
    [ObsoleteAttribute("Use constructor which takes 'orderBitLength' instead, to guarantee correct encoding")]
public ECPrivateKeyStructure(BigInteger key, Asn1Encodable parameters);
    [ObsoleteAttribute("Use constructor which takes 'orderBitLength' instead, to guarantee correct encoding")]
public ECPrivateKeyStructure(BigInteger key, DerBitString publicKey, Asn1Encodable parameters);
    public ECPrivateKeyStructure(int orderBitLength, BigInteger key, Asn1Encodable parameters);
    public ECPrivateKeyStructure(int orderBitLength, BigInteger key, DerBitString publicKey, Asn1Encodable parameters);
    public static ECPrivateKeyStructure GetInstance(object obj);
    public virtual BigInteger GetKey();
    public virtual DerBitString GetPublicKey();
    public virtual Asn1Object GetParameters();
    private Asn1Object GetObjectInTag(int tagNo);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Sec.SecNamedCurves : object {
    private static IDictionary objIds;
    private static IDictionary curves;
    private static IDictionary names;
    public static IEnumerable Names { get; }
    private static SecNamedCurves();
    private static X9ECPoint ConfigureBasepoint(ECCurve curve, string encoding);
    private static ECCurve ConfigureCurve(ECCurve curve);
    private static ECCurve ConfigureCurveGlv(ECCurve c, GlvTypeBParameters p);
    private static BigInteger FromHex(string hex);
    private static void DefineCurve(string name, DerObjectIdentifier oid, X9ECParametersHolder holder);
    public static X9ECParameters GetByName(string name);
    public static X9ECParameters GetByOid(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static string GetName(DerObjectIdentifier oid);
    public static IEnumerable get_Names();
}
public abstract class Org.BouncyCastle.Asn1.Sec.SecObjectIdentifiers : object {
    public static DerObjectIdentifier EllipticCurve;
    public static DerObjectIdentifier SecT163k1;
    public static DerObjectIdentifier SecT163r1;
    public static DerObjectIdentifier SecT239k1;
    public static DerObjectIdentifier SecT113r1;
    public static DerObjectIdentifier SecT113r2;
    public static DerObjectIdentifier SecP112r1;
    public static DerObjectIdentifier SecP112r2;
    public static DerObjectIdentifier SecP160r1;
    public static DerObjectIdentifier SecP160k1;
    public static DerObjectIdentifier SecP256k1;
    public static DerObjectIdentifier SecT163r2;
    public static DerObjectIdentifier SecT283k1;
    public static DerObjectIdentifier SecT283r1;
    public static DerObjectIdentifier SecT131r1;
    public static DerObjectIdentifier SecT131r2;
    public static DerObjectIdentifier SecT193r1;
    public static DerObjectIdentifier SecT193r2;
    public static DerObjectIdentifier SecT233k1;
    public static DerObjectIdentifier SecT233r1;
    public static DerObjectIdentifier SecP128r1;
    public static DerObjectIdentifier SecP128r2;
    public static DerObjectIdentifier SecP160r2;
    public static DerObjectIdentifier SecP192k1;
    public static DerObjectIdentifier SecP224k1;
    public static DerObjectIdentifier SecP224r1;
    public static DerObjectIdentifier SecP384r1;
    public static DerObjectIdentifier SecP521r1;
    public static DerObjectIdentifier SecT409k1;
    public static DerObjectIdentifier SecT409r1;
    public static DerObjectIdentifier SecT571k1;
    public static DerObjectIdentifier SecT571r1;
    public static DerObjectIdentifier SecP192r1;
    public static DerObjectIdentifier SecP256r1;
    private static SecObjectIdentifiers();
}
public abstract class Org.BouncyCastle.Asn1.Smime.SmimeAttributes : object {
    public static DerObjectIdentifier SmimeCapabilities;
    public static DerObjectIdentifier EncrypKeyPref;
    private static SmimeAttributes();
}
public class Org.BouncyCastle.Asn1.Smime.SmimeCapabilities : Asn1Encodable {
    public static DerObjectIdentifier PreferSignedData;
    public static DerObjectIdentifier CannotDecryptAny;
    public static DerObjectIdentifier SmimeCapabilitesVersions;
    public static DerObjectIdentifier Aes256Cbc;
    public static DerObjectIdentifier Aes192Cbc;
    public static DerObjectIdentifier Aes128Cbc;
    public static DerObjectIdentifier IdeaCbc;
    public static DerObjectIdentifier Cast5Cbc;
    public static DerObjectIdentifier DesCbc;
    public static DerObjectIdentifier DesEde3Cbc;
    public static DerObjectIdentifier RC2Cbc;
    private Asn1Sequence capabilities;
    public SmimeCapabilities(Asn1Sequence seq);
    private static SmimeCapabilities();
    public static SmimeCapabilities GetInstance(object obj);
    [ObsoleteAttribute("Use 'GetCapabilitiesForOid' instead")]
public ArrayList GetCapabilities(DerObjectIdentifier capability);
    public IList GetCapabilitiesForOid(DerObjectIdentifier capability);
    private void DoGetCapabilitiesForOid(DerObjectIdentifier capability, IList list);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Smime.SmimeCapabilitiesAttribute : AttributeX509 {
    public SmimeCapabilitiesAttribute(SmimeCapabilityVector capabilities);
}
public class Org.BouncyCastle.Asn1.Smime.SmimeCapability : Asn1Encodable {
    public static DerObjectIdentifier PreferSignedData;
    public static DerObjectIdentifier CannotDecryptAny;
    public static DerObjectIdentifier SmimeCapabilitiesVersions;
    public static DerObjectIdentifier DesCbc;
    public static DerObjectIdentifier DesEde3Cbc;
    public static DerObjectIdentifier RC2Cbc;
    private DerObjectIdentifier capabilityID;
    private Asn1Object parameters;
    public DerObjectIdentifier CapabilityID { get; }
    public Asn1Object Parameters { get; }
    public SmimeCapability(Asn1Sequence seq);
    public SmimeCapability(DerObjectIdentifier capabilityID, Asn1Encodable parameters);
    private static SmimeCapability();
    public static SmimeCapability GetInstance(object obj);
    public DerObjectIdentifier get_CapabilityID();
    public Asn1Object get_Parameters();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Smime.SmimeCapabilityVector : object {
    private Asn1EncodableVector capabilities;
    public void AddCapability(DerObjectIdentifier capability);
    public void AddCapability(DerObjectIdentifier capability, int value);
    public void AddCapability(DerObjectIdentifier capability, Asn1Encodable parameters);
    public Asn1EncodableVector ToAsn1EncodableVector();
}
public class Org.BouncyCastle.Asn1.Smime.SmimeEncryptionKeyPreferenceAttribute : AttributeX509 {
    public SmimeEncryptionKeyPreferenceAttribute(IssuerAndSerialNumber issAndSer);
    public SmimeEncryptionKeyPreferenceAttribute(RecipientKeyIdentifier rKeyID);
    public SmimeEncryptionKeyPreferenceAttribute(Asn1OctetString sKeyID);
}
public class Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves : object {
    private static IDictionary objIds;
    private static IDictionary curves;
    private static IDictionary names;
    public static IEnumerable Names { get; }
    private static TeleTrusTNamedCurves();
    private static X9ECPoint ConfigureBasepoint(ECCurve curve, string encoding);
    private static ECCurve ConfigureCurve(ECCurve curve);
    private static BigInteger FromHex(string hex);
    private static void DefineCurve(string name, DerObjectIdentifier oid, X9ECParametersHolder holder);
    public static X9ECParameters GetByName(string name);
    public static X9ECParameters GetByOid(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static string GetName(DerObjectIdentifier oid);
    public static IEnumerable get_Names();
    public static DerObjectIdentifier GetOid(short curvesize, bool twisted);
}
public class Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTObjectIdentifiers : object {
    public static DerObjectIdentifier TeleTrusTAlgorithm;
    public static DerObjectIdentifier RipeMD160;
    public static DerObjectIdentifier RipeMD128;
    public static DerObjectIdentifier RipeMD256;
    public static DerObjectIdentifier TeleTrusTRsaSignatureAlgorithm;
    public static DerObjectIdentifier RsaSignatureWithRipeMD160;
    public static DerObjectIdentifier RsaSignatureWithRipeMD128;
    public static DerObjectIdentifier RsaSignatureWithRipeMD256;
    public static DerObjectIdentifier ECSign;
    public static DerObjectIdentifier ECSignWithSha1;
    public static DerObjectIdentifier ECSignWithRipeMD160;
    public static DerObjectIdentifier EccBrainpool;
    public static DerObjectIdentifier EllipticCurve;
    public static DerObjectIdentifier VersionOne;
    public static DerObjectIdentifier BrainpoolP160R1;
    public static DerObjectIdentifier BrainpoolP160T1;
    public static DerObjectIdentifier BrainpoolP192R1;
    public static DerObjectIdentifier BrainpoolP192T1;
    public static DerObjectIdentifier BrainpoolP224R1;
    public static DerObjectIdentifier BrainpoolP224T1;
    public static DerObjectIdentifier BrainpoolP256R1;
    public static DerObjectIdentifier BrainpoolP256T1;
    public static DerObjectIdentifier BrainpoolP320R1;
    public static DerObjectIdentifier BrainpoolP320T1;
    public static DerObjectIdentifier BrainpoolP384R1;
    public static DerObjectIdentifier BrainpoolP384T1;
    public static DerObjectIdentifier BrainpoolP512R1;
    public static DerObjectIdentifier BrainpoolP512T1;
    private static TeleTrusTObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Tsp.Accuracy : Asn1Encodable {
    private DerInteger seconds;
    private DerInteger millis;
    private DerInteger micros;
    protected static int MinMillis;
    protected static int MaxMillis;
    protected static int MinMicros;
    protected static int MaxMicros;
    public DerInteger Seconds { get; }
    public DerInteger Millis { get; }
    public DerInteger Micros { get; }
    public Accuracy(DerInteger seconds, DerInteger millis, DerInteger micros);
    private Accuracy(Asn1Sequence seq);
    public static Accuracy GetInstance(object obj);
    public DerInteger get_Seconds();
    public DerInteger get_Millis();
    public DerInteger get_Micros();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Tsp.MessageImprint : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private Byte[] hashedMessage;
    public AlgorithmIdentifier HashAlgorithm { get; }
    private MessageImprint(Asn1Sequence seq);
    public MessageImprint(AlgorithmIdentifier hashAlgorithm, Byte[] hashedMessage);
    public static MessageImprint GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public Byte[] GetHashedMessage();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Tsp.TimeStampReq : Asn1Encodable {
    private DerInteger version;
    private MessageImprint messageImprint;
    private DerObjectIdentifier tsaPolicy;
    private DerInteger nonce;
    private DerBoolean certReq;
    private X509Extensions extensions;
    public DerInteger Version { get; }
    public MessageImprint MessageImprint { get; }
    public DerObjectIdentifier ReqPolicy { get; }
    public DerInteger Nonce { get; }
    public DerBoolean CertReq { get; }
    public X509Extensions Extensions { get; }
    private TimeStampReq(Asn1Sequence seq);
    public TimeStampReq(MessageImprint messageImprint, DerObjectIdentifier tsaPolicy, DerInteger nonce, DerBoolean certReq, X509Extensions extensions);
    public static TimeStampReq GetInstance(object obj);
    public DerInteger get_Version();
    public MessageImprint get_MessageImprint();
    public DerObjectIdentifier get_ReqPolicy();
    public DerInteger get_Nonce();
    public DerBoolean get_CertReq();
    public X509Extensions get_Extensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Tsp.TimeStampResp : Asn1Encodable {
    private PkiStatusInfo pkiStatusInfo;
    private ContentInfo timeStampToken;
    public PkiStatusInfo Status { get; }
    public ContentInfo TimeStampToken { get; }
    private TimeStampResp(Asn1Sequence seq);
    public TimeStampResp(PkiStatusInfo pkiStatusInfo, ContentInfo timeStampToken);
    public static TimeStampResp GetInstance(object obj);
    public PkiStatusInfo get_Status();
    public ContentInfo get_TimeStampToken();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Tsp.TstInfo : Asn1Encodable {
    private DerInteger version;
    private DerObjectIdentifier tsaPolicyId;
    private MessageImprint messageImprint;
    private DerInteger serialNumber;
    private DerGeneralizedTime genTime;
    private Accuracy accuracy;
    private DerBoolean ordering;
    private DerInteger nonce;
    private GeneralName tsa;
    private X509Extensions extensions;
    public DerInteger Version { get; }
    public MessageImprint MessageImprint { get; }
    public DerObjectIdentifier Policy { get; }
    public DerInteger SerialNumber { get; }
    public Accuracy Accuracy { get; }
    public DerGeneralizedTime GenTime { get; }
    public DerBoolean Ordering { get; }
    public DerInteger Nonce { get; }
    public GeneralName Tsa { get; }
    public X509Extensions Extensions { get; }
    private TstInfo(Asn1Sequence seq);
    public TstInfo(DerObjectIdentifier tsaPolicyId, MessageImprint messageImprint, DerInteger serialNumber, DerGeneralizedTime genTime, Accuracy accuracy, DerBoolean ordering, DerInteger nonce, GeneralName tsa, X509Extensions extensions);
    public static TstInfo GetInstance(object obj);
    public DerInteger get_Version();
    public MessageImprint get_MessageImprint();
    public DerObjectIdentifier get_Policy();
    public DerInteger get_SerialNumber();
    public Accuracy get_Accuracy();
    public DerGeneralizedTime get_GenTime();
    public DerBoolean get_Ordering();
    public DerInteger get_Nonce();
    public GeneralName get_Tsa();
    public X509Extensions get_Extensions();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers : object {
    public static DerObjectIdentifier UaOid;
    public static DerObjectIdentifier dstu4145le;
    public static DerObjectIdentifier dstu4145be;
    public static DerObjectIdentifier dstu7564digest_256;
    public static DerObjectIdentifier dstu7564digest_384;
    public static DerObjectIdentifier dstu7564digest_512;
    public static DerObjectIdentifier dstu7564mac_256;
    public static DerObjectIdentifier dstu7564mac_384;
    public static DerObjectIdentifier dstu7564mac_512;
    public static DerObjectIdentifier dstu7624ecb_128;
    public static DerObjectIdentifier dstu7624ecb_256;
    public static DerObjectIdentifier dstu7624ecb_512;
    public static DerObjectIdentifier dstu7624ctr_128;
    public static DerObjectIdentifier dstu7624ctr_256;
    public static DerObjectIdentifier dstu7624ctr_512;
    public static DerObjectIdentifier dstu7624cfb_128;
    public static DerObjectIdentifier dstu7624cfb_256;
    public static DerObjectIdentifier dstu7624cfb_512;
    public static DerObjectIdentifier dstu7624cmac_128;
    public static DerObjectIdentifier dstu7624cmac_256;
    public static DerObjectIdentifier dstu7624cmac_512;
    public static DerObjectIdentifier dstu7624cbc_128;
    public static DerObjectIdentifier dstu7624cbc_256;
    public static DerObjectIdentifier dstu7624cbc_512;
    public static DerObjectIdentifier dstu7624ofb_128;
    public static DerObjectIdentifier dstu7624ofb_256;
    public static DerObjectIdentifier dstu7624ofb_512;
    public static DerObjectIdentifier dstu7624gmac_128;
    public static DerObjectIdentifier dstu7624gmac_256;
    public static DerObjectIdentifier dstu7624gmac_512;
    public static DerObjectIdentifier dstu7624ccm_128;
    public static DerObjectIdentifier dstu7624ccm_256;
    public static DerObjectIdentifier dstu7624ccm_512;
    public static DerObjectIdentifier dstu7624xts_128;
    public static DerObjectIdentifier dstu7624xts_256;
    public static DerObjectIdentifier dstu7624xts_512;
    public static DerObjectIdentifier dstu7624kw_128;
    public static DerObjectIdentifier dstu7624kw_256;
    public static DerObjectIdentifier dstu7624kw_512;
    private static UAObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Utilities.Asn1Dump : object {
    private static string NewLine;
    private static string Tab;
    private static int SampleSize;
    private static Asn1Dump();
    private static void AsString(string indent, bool verbose, Asn1Object obj, StringBuilder buf);
    private static string outputApplicationSpecific(string type, string indent, bool verbose, DerApplicationSpecific app);
    public static string DumpAsString(Asn1Encodable obj);
    public static string DumpAsString(Asn1Encodable obj, bool verbose);
    private static string dumpBinaryDataAsString(string indent, Byte[] bytes);
    private static string calculateAscString(Byte[] bytes, int off, int len);
}
public class Org.BouncyCastle.Asn1.Utilities.Dump : object {
    public static void Main(String[] args);
}
[ObsoleteAttribute("Use Org.BouncyCastle.Utilities.IO.FilterStream")]
public class Org.BouncyCastle.Asn1.Utilities.FilterStream : Stream {
    protected Stream s;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    [ObsoleteAttribute("Use Org.BouncyCastle.Utilities.IO.FilterStream")]
public FilterStream(Stream s);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public class Org.BouncyCastle.Asn1.X500.AttributeTypeAndValue : Asn1Encodable {
    private DerObjectIdentifier type;
    private Asn1Encodable value;
    public DerObjectIdentifier Type { get; }
    public Asn1Encodable Value { get; }
    private AttributeTypeAndValue(Asn1Sequence seq);
    public AttributeTypeAndValue(DerObjectIdentifier type, Asn1Encodable value);
    public static AttributeTypeAndValue GetInstance(object obj);
    public virtual DerObjectIdentifier get_Type();
    public virtual Asn1Encodable get_Value();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X500.DirectoryString : Asn1Encodable {
    private DerStringBase str;
    private DirectoryString(DerStringBase str);
    public DirectoryString(string str);
    public static DirectoryString GetInstance(object obj);
    public static DirectoryString GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public sealed virtual string GetString();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X500.Rdn : Asn1Encodable {
    private Asn1Set values;
    public bool IsMultiValued { get; }
    public int Count { get; }
    private Rdn(Asn1Set values);
    public Rdn(DerObjectIdentifier oid, Asn1Encodable value);
    public Rdn(AttributeTypeAndValue attrTAndV);
    public Rdn(AttributeTypeAndValue[] aAndVs);
    public static Rdn GetInstance(object obj);
    public virtual bool get_IsMultiValued();
    public virtual int get_Count();
    public virtual AttributeTypeAndValue GetFirst();
    public virtual AttributeTypeAndValue[] GetTypesAndValues();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.X500.Style.IetfUtilities : object {
    public static string ValueToString(Asn1Encodable value);
    public static string Canonicalize(string s);
    public static string CanonicalString(Asn1Encodable value);
    private static Asn1Object DecodeObject(string oValue);
    public static string StripInternalSpaces(string str);
    public static bool RdnAreEqual(Rdn rdn1, Rdn rdn2);
    private static bool AtvAreEqual(AttributeTypeAndValue atv1, AttributeTypeAndValue atv2);
}
public class Org.BouncyCastle.Asn1.X509.AccessDescription : Asn1Encodable {
    public static DerObjectIdentifier IdADCAIssuers;
    public static DerObjectIdentifier IdADOcsp;
    private DerObjectIdentifier accessMethod;
    private GeneralName accessLocation;
    public DerObjectIdentifier AccessMethod { get; }
    public GeneralName AccessLocation { get; }
    private AccessDescription(Asn1Sequence seq);
    public AccessDescription(DerObjectIdentifier oid, GeneralName location);
    private static AccessDescription();
    public static AccessDescription GetInstance(object obj);
    public DerObjectIdentifier get_AccessMethod();
    public GeneralName get_AccessLocation();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier : Asn1Encodable {
    private DerObjectIdentifier algorithm;
    private Asn1Encodable parameters;
    public DerObjectIdentifier Algorithm { get; }
    [ObsoleteAttribute("Use 'Algorithm' property instead")]
public DerObjectIdentifier ObjectID { get; }
    public Asn1Encodable Parameters { get; }
    public AlgorithmIdentifier(DerObjectIdentifier algorithm);
    [ObsoleteAttribute("Use version taking a DerObjectIdentifier")]
public AlgorithmIdentifier(string algorithm);
    public AlgorithmIdentifier(DerObjectIdentifier algorithm, Asn1Encodable parameters);
    internal AlgorithmIdentifier(Asn1Sequence seq);
    public static AlgorithmIdentifier GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static AlgorithmIdentifier GetInstance(object obj);
    public virtual DerObjectIdentifier get_Algorithm();
    public virtual DerObjectIdentifier get_ObjectID();
    public virtual Asn1Encodable get_Parameters();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AttCertIssuer : Asn1Encodable {
    internal Asn1Encodable obj;
    internal Asn1Object choiceObj;
    public Asn1Encodable Issuer { get; }
    public AttCertIssuer(GeneralNames names);
    public AttCertIssuer(V2Form v2Form);
    public static AttCertIssuer GetInstance(object obj);
    public static AttCertIssuer GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public Asn1Encodable get_Issuer();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AttCertValidityPeriod : Asn1Encodable {
    private DerGeneralizedTime notBeforeTime;
    private DerGeneralizedTime notAfterTime;
    public DerGeneralizedTime NotBeforeTime { get; }
    public DerGeneralizedTime NotAfterTime { get; }
    private AttCertValidityPeriod(Asn1Sequence seq);
    public AttCertValidityPeriod(DerGeneralizedTime notBeforeTime, DerGeneralizedTime notAfterTime);
    public static AttCertValidityPeriod GetInstance(object obj);
    public static AttCertValidityPeriod GetInstance(Asn1TaggedObject obj, bool explicitly);
    public DerGeneralizedTime get_NotBeforeTime();
    public DerGeneralizedTime get_NotAfterTime();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AttributeCertificate : Asn1Encodable {
    private AttributeCertificateInfo acinfo;
    private AlgorithmIdentifier signatureAlgorithm;
    private DerBitString signatureValue;
    public AttributeCertificateInfo ACInfo { get; }
    public AlgorithmIdentifier SignatureAlgorithm { get; }
    public DerBitString SignatureValue { get; }
    public AttributeCertificate(AttributeCertificateInfo acinfo, AlgorithmIdentifier signatureAlgorithm, DerBitString signatureValue);
    private AttributeCertificate(Asn1Sequence seq);
    public static AttributeCertificate GetInstance(object obj);
    public AttributeCertificateInfo get_ACInfo();
    public AlgorithmIdentifier get_SignatureAlgorithm();
    public DerBitString get_SignatureValue();
    public Byte[] GetSignatureOctets();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AttributeCertificateInfo : Asn1Encodable {
    internal DerInteger version;
    internal Holder holder;
    internal AttCertIssuer issuer;
    internal AlgorithmIdentifier signature;
    internal DerInteger serialNumber;
    internal AttCertValidityPeriod attrCertValidityPeriod;
    internal Asn1Sequence attributes;
    internal DerBitString issuerUniqueID;
    internal X509Extensions extensions;
    public DerInteger Version { get; }
    public Holder Holder { get; }
    public AttCertIssuer Issuer { get; }
    public AlgorithmIdentifier Signature { get; }
    public DerInteger SerialNumber { get; }
    public AttCertValidityPeriod AttrCertValidityPeriod { get; }
    public Asn1Sequence Attributes { get; }
    public DerBitString IssuerUniqueID { get; }
    public X509Extensions Extensions { get; }
    private AttributeCertificateInfo(Asn1Sequence seq);
    public static AttributeCertificateInfo GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static AttributeCertificateInfo GetInstance(object obj);
    public DerInteger get_Version();
    public Holder get_Holder();
    public AttCertIssuer get_Issuer();
    public AlgorithmIdentifier get_Signature();
    public DerInteger get_SerialNumber();
    public AttCertValidityPeriod get_AttrCertValidityPeriod();
    public Asn1Sequence get_Attributes();
    public DerBitString get_IssuerUniqueID();
    public X509Extensions get_Extensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AttributeTable : object {
    private IDictionary attributes;
    public AttributeTable(IDictionary attrs);
    [ObsoleteAttribute]
public AttributeTable(Hashtable attrs);
    public AttributeTable(Asn1EncodableVector v);
    public AttributeTable(Asn1Set s);
    public AttributeX509 Get(DerObjectIdentifier oid);
    [ObsoleteAttribute("Use 'ToDictionary' instead")]
public Hashtable ToHashtable();
    public IDictionary ToDictionary();
}
public class Org.BouncyCastle.Asn1.X509.AttributeX509 : Asn1Encodable {
    private DerObjectIdentifier attrType;
    private Asn1Set attrValues;
    public DerObjectIdentifier AttrType { get; }
    public Asn1Set AttrValues { get; }
    private AttributeX509(Asn1Sequence seq);
    public AttributeX509(DerObjectIdentifier attrType, Asn1Set attrValues);
    public static AttributeX509 GetInstance(object obj);
    public DerObjectIdentifier get_AttrType();
    public Asn1Encodable[] GetAttributeValues();
    public Asn1Set get_AttrValues();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AuthorityInformationAccess : Asn1Encodable {
    private AccessDescription[] descriptions;
    private AuthorityInformationAccess(Asn1Sequence seq);
    public AuthorityInformationAccess(AccessDescription description);
    public AuthorityInformationAccess(AccessDescription[] descriptions);
    public AuthorityInformationAccess(DerObjectIdentifier oid, GeneralName location);
    private static AccessDescription[] Copy(AccessDescription[] descriptions);
    public static AuthorityInformationAccess GetInstance(object obj);
    public static AuthorityInformationAccess FromExtensions(X509Extensions extensions);
    public AccessDescription[] GetAccessDescriptions();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier : Asn1Encodable {
    private Asn1OctetString keyidentifier;
    private GeneralNames certissuer;
    private DerInteger certserno;
    public GeneralNames AuthorityCertIssuer { get; }
    public BigInteger AuthorityCertSerialNumber { get; }
    protected internal AuthorityKeyIdentifier(Asn1Sequence seq);
    public AuthorityKeyIdentifier(SubjectPublicKeyInfo spki);
    public AuthorityKeyIdentifier(SubjectPublicKeyInfo spki, GeneralNames name, BigInteger serialNumber);
    public AuthorityKeyIdentifier(GeneralNames name, BigInteger serialNumber);
    public AuthorityKeyIdentifier(Byte[] keyIdentifier);
    public AuthorityKeyIdentifier(Byte[] keyIdentifier, GeneralNames name, BigInteger serialNumber);
    public static AuthorityKeyIdentifier GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static AuthorityKeyIdentifier GetInstance(object obj);
    public static AuthorityKeyIdentifier FromExtensions(X509Extensions extensions);
    public Byte[] GetKeyIdentifier();
    public GeneralNames get_AuthorityCertIssuer();
    public BigInteger get_AuthorityCertSerialNumber();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.BasicConstraints : Asn1Encodable {
    private DerBoolean cA;
    private DerInteger pathLenConstraint;
    public BigInteger PathLenConstraint { get; }
    private BasicConstraints(Asn1Sequence seq);
    public BasicConstraints(bool cA);
    public BasicConstraints(int pathLenConstraint);
    public static BasicConstraints GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static BasicConstraints GetInstance(object obj);
    public static BasicConstraints FromExtensions(X509Extensions extensions);
    public bool IsCA();
    public BigInteger get_PathLenConstraint();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.CertificateList : Asn1Encodable {
    private TbsCertificateList tbsCertList;
    private AlgorithmIdentifier sigAlgID;
    private DerBitString sig;
    public TbsCertificateList TbsCertList { get; }
    public AlgorithmIdentifier SignatureAlgorithm { get; }
    public DerBitString Signature { get; }
    public int Version { get; }
    public X509Name Issuer { get; }
    public Time ThisUpdate { get; }
    public Time NextUpdate { get; }
    private CertificateList(Asn1Sequence seq);
    public static CertificateList GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static CertificateList GetInstance(object obj);
    public TbsCertificateList get_TbsCertList();
    public CrlEntry[] GetRevokedCertificates();
    public IEnumerable GetRevokedCertificateEnumeration();
    public AlgorithmIdentifier get_SignatureAlgorithm();
    public DerBitString get_Signature();
    public Byte[] GetSignatureOctets();
    public int get_Version();
    public X509Name get_Issuer();
    public Time get_ThisUpdate();
    public Time get_NextUpdate();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.CertificatePair : Asn1Encodable {
    private X509CertificateStructure forward;
    private X509CertificateStructure reverse;
    public X509CertificateStructure Forward { get; }
    public X509CertificateStructure Reverse { get; }
    private CertificatePair(Asn1Sequence seq);
    public CertificatePair(X509CertificateStructure forward, X509CertificateStructure reverse);
    public static CertificatePair GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public X509CertificateStructure get_Forward();
    public X509CertificateStructure get_Reverse();
}
public class Org.BouncyCastle.Asn1.X509.CertificatePolicies : Asn1Encodable {
    private PolicyInformation[] policyInformation;
    public CertificatePolicies(PolicyInformation name);
    public CertificatePolicies(PolicyInformation[] policyInformation);
    private CertificatePolicies(Asn1Sequence seq);
    private static PolicyInformation[] Copy(PolicyInformation[] policyInfo);
    public static CertificatePolicies GetInstance(object obj);
    public static CertificatePolicies GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static CertificatePolicies FromExtensions(X509Extensions extensions);
    public virtual PolicyInformation[] GetPolicyInformation();
    public virtual PolicyInformation GetPolicyInformation(DerObjectIdentifier policyIdentifier);
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.CertPolicyID : DerObjectIdentifier {
    public CertPolicyID(string id);
}
public class Org.BouncyCastle.Asn1.X509.CrlDistPoint : Asn1Encodable {
    internal Asn1Sequence seq;
    private CrlDistPoint(Asn1Sequence seq);
    public CrlDistPoint(DistributionPoint[] points);
    public static CrlDistPoint GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static CrlDistPoint GetInstance(object obj);
    public static CrlDistPoint FromExtensions(X509Extensions extensions);
    public DistributionPoint[] GetDistributionPoints();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.CrlEntry : Asn1Encodable {
    internal Asn1Sequence seq;
    internal DerInteger userCertificate;
    internal Time revocationDate;
    internal X509Extensions crlEntryExtensions;
    public DerInteger UserCertificate { get; }
    public Time RevocationDate { get; }
    public X509Extensions Extensions { get; }
    public CrlEntry(Asn1Sequence seq);
    public DerInteger get_UserCertificate();
    public Time get_RevocationDate();
    public X509Extensions get_Extensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.CrlNumber : DerInteger {
    public BigInteger Number { get; }
    public CrlNumber(BigInteger number);
    public BigInteger get_Number();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.CrlReason : DerEnumerated {
    public static int Unspecified;
    public static int KeyCompromise;
    public static int CACompromise;
    public static int AffiliationChanged;
    public static int Superseded;
    public static int CessationOfOperation;
    public static int CertificateHold;
    public static int RemoveFromCrl;
    public static int PrivilegeWithdrawn;
    public static int AACompromise;
    private static String[] ReasonString;
    public CrlReason(int reason);
    public CrlReason(DerEnumerated reason);
    private static CrlReason();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.DigestInfo : Asn1Encodable {
    private Byte[] digest;
    private AlgorithmIdentifier algID;
    public AlgorithmIdentifier AlgorithmID { get; }
    public DigestInfo(AlgorithmIdentifier algID, Byte[] digest);
    private DigestInfo(Asn1Sequence seq);
    public static DigestInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static DigestInfo GetInstance(object obj);
    public AlgorithmIdentifier get_AlgorithmID();
    public Byte[] GetDigest();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.DisplayText : Asn1Encodable {
    public static int ContentTypeIA5String;
    public static int ContentTypeBmpString;
    public static int ContentTypeUtf8String;
    public static int ContentTypeVisibleString;
    public static int DisplayTextMaximumSize;
    internal int contentType;
    internal IAsn1String contents;
    public DisplayText(int type, string text);
    public DisplayText(string text);
    public DisplayText(IAsn1String contents);
    public static DisplayText GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public string GetString();
}
public class Org.BouncyCastle.Asn1.X509.DistributionPoint : Asn1Encodable {
    internal DistributionPointName distributionPoint;
    internal ReasonFlags reasons;
    internal GeneralNames cRLIssuer;
    public DistributionPointName DistributionPointName { get; }
    public ReasonFlags Reasons { get; }
    public GeneralNames CrlIssuer { get; }
    private DistributionPoint(Asn1Sequence seq);
    public DistributionPoint(DistributionPointName distributionPointName, ReasonFlags reasons, GeneralNames crlIssuer);
    public static DistributionPoint GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static DistributionPoint GetInstance(object obj);
    public DistributionPointName get_DistributionPointName();
    public ReasonFlags get_Reasons();
    public GeneralNames get_CrlIssuer();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
    private void appendObject(StringBuilder buf, string sep, string name, string val);
}
public class Org.BouncyCastle.Asn1.X509.DistributionPointName : Asn1Encodable {
    internal Asn1Encodable name;
    internal int type;
    public static int FullName;
    public static int NameRelativeToCrlIssuer;
    public int PointType { get; }
    public Asn1Encodable Name { get; }
    public DistributionPointName(int type, Asn1Encodable name);
    public DistributionPointName(GeneralNames name);
    public DistributionPointName(Asn1TaggedObject obj);
    public static DistributionPointName GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static DistributionPointName GetInstance(object obj);
    public int get_PointType();
    public Asn1Encodable get_Name();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
    private void appendObject(StringBuilder buf, string sep, string name, string val);
}
public class Org.BouncyCastle.Asn1.X509.DsaParameter : Asn1Encodable {
    internal DerInteger p;
    internal DerInteger q;
    internal DerInteger g;
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger G { get; }
    public DsaParameter(BigInteger p, BigInteger q, BigInteger g);
    private DsaParameter(Asn1Sequence seq);
    public static DsaParameter GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static DsaParameter GetInstance(object obj);
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_G();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.ExtendedKeyUsage : Asn1Encodable {
    internal IDictionary usageTable;
    internal Asn1Sequence seq;
    public int Count { get; }
    private ExtendedKeyUsage(Asn1Sequence seq);
    public ExtendedKeyUsage(KeyPurposeID[] usages);
    [ObsoleteAttribute]
public ExtendedKeyUsage(ArrayList usages);
    public ExtendedKeyUsage(IEnumerable usages);
    public static ExtendedKeyUsage GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static ExtendedKeyUsage GetInstance(object obj);
    public static ExtendedKeyUsage FromExtensions(X509Extensions extensions);
    public bool HasKeyPurposeId(KeyPurposeID keyPurposeId);
    [ObsoleteAttribute("Use 'GetAllUsages'")]
public ArrayList GetUsages();
    public IList GetAllUsages();
    public int get_Count();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.GeneralName : Asn1Encodable {
    public static int OtherName;
    public static int Rfc822Name;
    public static int DnsName;
    public static int X400Address;
    public static int DirectoryName;
    public static int EdiPartyName;
    public static int UniformResourceIdentifier;
    public static int IPAddress;
    public static int RegisteredID;
    internal Asn1Encodable obj;
    internal int tag;
    public int TagNo { get; }
    public Asn1Encodable Name { get; }
    public GeneralName(X509Name directoryName);
    public GeneralName(Asn1Object name, int tag);
    public GeneralName(int tag, Asn1Encodable name);
    public GeneralName(int tag, string name);
    public static GeneralName GetInstance(object obj);
    public static GeneralName GetInstance(Asn1TaggedObject tagObj, bool explicitly);
    public int get_TagNo();
    public Asn1Encodable get_Name();
    public virtual string ToString();
    private Byte[] toGeneralNameEncoding(string ip);
    private void parseIPv4Mask(string mask, Byte[] addr, int offset);
    private void parseIPv4(string ip, Byte[] addr, int offset);
    private Int32[] parseMask(string mask);
    private void copyInts(Int32[] parsedIp, Byte[] addr, int offSet);
    private Int32[] parseIPv6(string ip);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.GeneralNames : Asn1Encodable {
    private GeneralName[] names;
    public GeneralNames(GeneralName name);
    public GeneralNames(GeneralName[] names);
    private GeneralNames(Asn1Sequence seq);
    private static GeneralName[] Copy(GeneralName[] names);
    public static GeneralNames GetInstance(object obj);
    public static GeneralNames GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static GeneralNames FromExtensions(X509Extensions extensions, DerObjectIdentifier extOid);
    public GeneralName[] GetNames();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.GeneralSubtree : Asn1Encodable {
    private GeneralName baseName;
    private DerInteger minimum;
    private DerInteger maximum;
    public GeneralName Base { get; }
    public BigInteger Minimum { get; }
    public BigInteger Maximum { get; }
    private GeneralSubtree(Asn1Sequence seq);
    public GeneralSubtree(GeneralName baseName, BigInteger minimum, BigInteger maximum);
    public GeneralSubtree(GeneralName baseName);
    public static GeneralSubtree GetInstance(Asn1TaggedObject o, bool isExplicit);
    public static GeneralSubtree GetInstance(object obj);
    public GeneralName get_Base();
    public BigInteger get_Minimum();
    public BigInteger get_Maximum();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Holder : Asn1Encodable {
    internal IssuerSerial baseCertificateID;
    internal GeneralNames entityName;
    internal ObjectDigestInfo objectDigestInfo;
    private int version;
    public int Version { get; }
    public IssuerSerial BaseCertificateID { get; }
    public GeneralNames EntityName { get; }
    public ObjectDigestInfo ObjectDigestInfo { get; }
    public Holder(Asn1TaggedObject tagObj);
    private Holder(Asn1Sequence seq);
    public Holder(IssuerSerial baseCertificateID);
    public Holder(IssuerSerial baseCertificateID, int version);
    public Holder(GeneralNames entityName);
    public Holder(GeneralNames entityName, int version);
    public Holder(ObjectDigestInfo objectDigestInfo);
    public static Holder GetInstance(object obj);
    public int get_Version();
    public IssuerSerial get_BaseCertificateID();
    public GeneralNames get_EntityName();
    public ObjectDigestInfo get_ObjectDigestInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.IetfAttrSyntax : Asn1Encodable {
    public static int ValueOctets;
    public static int ValueOid;
    public static int ValueUtf8;
    internal GeneralNames policyAuthority;
    internal Asn1EncodableVector values;
    internal int valueChoice;
    public GeneralNames PolicyAuthority { get; }
    public int ValueType { get; }
    public IetfAttrSyntax(Asn1Sequence seq);
    public GeneralNames get_PolicyAuthority();
    public int get_ValueType();
    public Object[] GetValues();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.IssuerSerial : Asn1Encodable {
    internal GeneralNames issuer;
    internal DerInteger serial;
    internal DerBitString issuerUid;
    public GeneralNames Issuer { get; }
    public DerInteger Serial { get; }
    public DerBitString IssuerUid { get; }
    private IssuerSerial(Asn1Sequence seq);
    public IssuerSerial(GeneralNames issuer, DerInteger serial);
    public static IssuerSerial GetInstance(object obj);
    public static IssuerSerial GetInstance(Asn1TaggedObject obj, bool explicitly);
    public GeneralNames get_Issuer();
    public DerInteger get_Serial();
    public DerBitString get_IssuerUid();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint : Asn1Encodable {
    private DistributionPointName _distributionPoint;
    private bool _onlyContainsUserCerts;
    private bool _onlyContainsCACerts;
    private ReasonFlags _onlySomeReasons;
    private bool _indirectCRL;
    private bool _onlyContainsAttributeCerts;
    private Asn1Sequence seq;
    public bool OnlyContainsUserCerts { get; }
    public bool OnlyContainsCACerts { get; }
    public bool IsIndirectCrl { get; }
    public bool OnlyContainsAttributeCerts { get; }
    public DistributionPointName DistributionPoint { get; }
    public ReasonFlags OnlySomeReasons { get; }
    public IssuingDistributionPoint(DistributionPointName distributionPoint, bool onlyContainsUserCerts, bool onlyContainsCACerts, ReasonFlags onlySomeReasons, bool indirectCRL, bool onlyContainsAttributeCerts);
    private IssuingDistributionPoint(Asn1Sequence seq);
    public static IssuingDistributionPoint GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static IssuingDistributionPoint GetInstance(object obj);
    public bool get_OnlyContainsUserCerts();
    public bool get_OnlyContainsCACerts();
    public bool get_IsIndirectCrl();
    public bool get_OnlyContainsAttributeCerts();
    public DistributionPointName get_DistributionPoint();
    public ReasonFlags get_OnlySomeReasons();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
    private void appendObject(StringBuilder buf, string sep, string name, string val);
}
public class Org.BouncyCastle.Asn1.X509.KeyPurposeID : DerObjectIdentifier {
    private static string IdKP;
    public static KeyPurposeID AnyExtendedKeyUsage;
    public static KeyPurposeID IdKPServerAuth;
    public static KeyPurposeID IdKPClientAuth;
    public static KeyPurposeID IdKPCodeSigning;
    public static KeyPurposeID IdKPEmailProtection;
    public static KeyPurposeID IdKPIpsecEndSystem;
    public static KeyPurposeID IdKPIpsecTunnel;
    public static KeyPurposeID IdKPIpsecUser;
    public static KeyPurposeID IdKPTimeStamping;
    public static KeyPurposeID IdKPOcspSigning;
    public static KeyPurposeID IdKPSmartCardLogon;
    public static KeyPurposeID IdKPMacAddress;
    private KeyPurposeID(string id);
    private static KeyPurposeID();
}
public class Org.BouncyCastle.Asn1.X509.KeyUsage : DerBitString {
    public static int DigitalSignature;
    public static int NonRepudiation;
    public static int KeyEncipherment;
    public static int DataEncipherment;
    public static int KeyAgreement;
    public static int KeyCertSign;
    public static int CrlSign;
    public static int EncipherOnly;
    public static int DecipherOnly;
    public KeyUsage(int usage);
    private KeyUsage(DerBitString usage);
    public static KeyUsage GetInstance(object obj);
    public static KeyUsage FromExtensions(X509Extensions extensions);
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.NameConstraints : Asn1Encodable {
    private Asn1Sequence permitted;
    private Asn1Sequence excluded;
    public Asn1Sequence PermittedSubtrees { get; }
    public Asn1Sequence ExcludedSubtrees { get; }
    public NameConstraints(Asn1Sequence seq);
    public NameConstraints(ArrayList permitted, ArrayList excluded);
    public NameConstraints(IList permitted, IList excluded);
    public static NameConstraints GetInstance(object obj);
    private DerSequence CreateSequence(IList subtrees);
    public Asn1Sequence get_PermittedSubtrees();
    public Asn1Sequence get_ExcludedSubtrees();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.NoticeReference : Asn1Encodable {
    private DisplayText organization;
    private Asn1Sequence noticeNumbers;
    public DisplayText Organization { get; }
    public NoticeReference(string organization, IList numbers);
    public NoticeReference(string organization, Asn1EncodableVector noticeNumbers);
    public NoticeReference(DisplayText organization, Asn1EncodableVector noticeNumbers);
    private NoticeReference(Asn1Sequence seq);
    private static Asn1EncodableVector ConvertVector(IList numbers);
    public static NoticeReference GetInstance(object obj);
    public virtual DisplayText get_Organization();
    public virtual DerInteger[] GetNoticeNumbers();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.ObjectDigestInfo : Asn1Encodable {
    public static int PublicKey;
    public static int PublicKeyCert;
    public static int OtherObjectDigest;
    internal DerEnumerated digestedObjectType;
    internal DerObjectIdentifier otherObjectTypeID;
    internal AlgorithmIdentifier digestAlgorithm;
    internal DerBitString objectDigest;
    public DerEnumerated DigestedObjectType { get; }
    public DerObjectIdentifier OtherObjectTypeID { get; }
    public AlgorithmIdentifier DigestAlgorithm { get; }
    public DerBitString ObjectDigest { get; }
    public ObjectDigestInfo(int digestedObjectType, string otherObjectTypeID, AlgorithmIdentifier digestAlgorithm, Byte[] objectDigest);
    private ObjectDigestInfo(Asn1Sequence seq);
    public static ObjectDigestInfo GetInstance(object obj);
    public static ObjectDigestInfo GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public DerEnumerated get_DigestedObjectType();
    public DerObjectIdentifier get_OtherObjectTypeID();
    public AlgorithmIdentifier get_DigestAlgorithm();
    public DerBitString get_ObjectDigest();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.OtherName : Asn1Encodable {
    private DerObjectIdentifier typeID;
    private Asn1Encodable value;
    public DerObjectIdentifier TypeID { get; }
    public Asn1Encodable Value { get; }
    public OtherName(DerObjectIdentifier typeID, Asn1Encodable value);
    private OtherName(Asn1Sequence seq);
    public static OtherName GetInstance(object obj);
    public virtual DerObjectIdentifier get_TypeID();
    public Asn1Encodable get_Value();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.PolicyInformation : Asn1Encodable {
    private DerObjectIdentifier policyIdentifier;
    private Asn1Sequence policyQualifiers;
    public DerObjectIdentifier PolicyIdentifier { get; }
    public Asn1Sequence PolicyQualifiers { get; }
    private PolicyInformation(Asn1Sequence seq);
    public PolicyInformation(DerObjectIdentifier policyIdentifier);
    public PolicyInformation(DerObjectIdentifier policyIdentifier, Asn1Sequence policyQualifiers);
    public static PolicyInformation GetInstance(object obj);
    public DerObjectIdentifier get_PolicyIdentifier();
    public Asn1Sequence get_PolicyQualifiers();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.PolicyMappings : Asn1Encodable {
    private Asn1Sequence seq;
    public PolicyMappings(Asn1Sequence seq);
    public PolicyMappings(Hashtable mappings);
    public PolicyMappings(IDictionary mappings);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.PolicyQualifierID : DerObjectIdentifier {
    private static string IdQt;
    public static PolicyQualifierID IdQtCps;
    public static PolicyQualifierID IdQtUnotice;
    private PolicyQualifierID(string id);
    private static PolicyQualifierID();
}
public class Org.BouncyCastle.Asn1.X509.PolicyQualifierInfo : Asn1Encodable {
    private DerObjectIdentifier policyQualifierId;
    private Asn1Encodable qualifier;
    public DerObjectIdentifier PolicyQualifierId { get; }
    public Asn1Encodable Qualifier { get; }
    public PolicyQualifierInfo(DerObjectIdentifier policyQualifierId, Asn1Encodable qualifier);
    public PolicyQualifierInfo(string cps);
    private PolicyQualifierInfo(Asn1Sequence seq);
    public static PolicyQualifierInfo GetInstance(object obj);
    public virtual DerObjectIdentifier get_PolicyQualifierId();
    public virtual Asn1Encodable get_Qualifier();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.PrivateKeyUsagePeriod : Asn1Encodable {
    private DerGeneralizedTime _notBefore;
    private DerGeneralizedTime _notAfter;
    public DerGeneralizedTime NotBefore { get; }
    public DerGeneralizedTime NotAfter { get; }
    private PrivateKeyUsagePeriod(Asn1Sequence seq);
    public static PrivateKeyUsagePeriod GetInstance(object obj);
    public DerGeneralizedTime get_NotBefore();
    public DerGeneralizedTime get_NotAfter();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.BiometricData : Asn1Encodable {
    private TypeOfBiometricData typeOfBiometricData;
    private AlgorithmIdentifier hashAlgorithm;
    private Asn1OctetString biometricDataHash;
    private DerIA5String sourceDataUri;
    public TypeOfBiometricData TypeOfBiometricData { get; }
    public AlgorithmIdentifier HashAlgorithm { get; }
    public Asn1OctetString BiometricDataHash { get; }
    public DerIA5String SourceDataUri { get; }
    private BiometricData(Asn1Sequence seq);
    public BiometricData(TypeOfBiometricData typeOfBiometricData, AlgorithmIdentifier hashAlgorithm, Asn1OctetString biometricDataHash, DerIA5String sourceDataUri);
    public BiometricData(TypeOfBiometricData typeOfBiometricData, AlgorithmIdentifier hashAlgorithm, Asn1OctetString biometricDataHash);
    public static BiometricData GetInstance(object obj);
    public TypeOfBiometricData get_TypeOfBiometricData();
    public AlgorithmIdentifier get_HashAlgorithm();
    public Asn1OctetString get_BiometricDataHash();
    public DerIA5String get_SourceDataUri();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.X509.Qualified.EtsiQCObjectIdentifiers : object {
    public static DerObjectIdentifier IdEtsiQcs;
    public static DerObjectIdentifier IdEtsiQcsQcCompliance;
    public static DerObjectIdentifier IdEtsiQcsLimitValue;
    public static DerObjectIdentifier IdEtsiQcsRetentionPeriod;
    public static DerObjectIdentifier IdEtsiQcsQcSscd;
    private static EtsiQCObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.Iso4217CurrencyCode : Asn1Encodable {
    internal static int AlphabeticMaxSize;
    internal static int NumericMinSize;
    internal static int NumericMaxSize;
    internal Asn1Encodable obj;
    public bool IsAlphabetic { get; }
    public string Alphabetic { get; }
    public int Numeric { get; }
    public Iso4217CurrencyCode(int numeric);
    public Iso4217CurrencyCode(string alphabetic);
    public static Iso4217CurrencyCode GetInstance(object obj);
    public bool get_IsAlphabetic();
    public string get_Alphabetic();
    public int get_Numeric();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.MonetaryValue : Asn1Encodable {
    internal Iso4217CurrencyCode currency;
    internal DerInteger amount;
    internal DerInteger exponent;
    public Iso4217CurrencyCode Currency { get; }
    public BigInteger Amount { get; }
    public BigInteger Exponent { get; }
    private MonetaryValue(Asn1Sequence seq);
    public MonetaryValue(Iso4217CurrencyCode currency, int amount, int exponent);
    public static MonetaryValue GetInstance(object obj);
    public Iso4217CurrencyCode get_Currency();
    public BigInteger get_Amount();
    public BigInteger get_Exponent();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.QCStatement : Asn1Encodable {
    private DerObjectIdentifier qcStatementId;
    private Asn1Encodable qcStatementInfo;
    public DerObjectIdentifier StatementId { get; }
    public Asn1Encodable StatementInfo { get; }
    private QCStatement(Asn1Sequence seq);
    public QCStatement(DerObjectIdentifier qcStatementId);
    public QCStatement(DerObjectIdentifier qcStatementId, Asn1Encodable qcStatementInfo);
    public static QCStatement GetInstance(object obj);
    public DerObjectIdentifier get_StatementId();
    public Asn1Encodable get_StatementInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.Rfc3739QCObjectIdentifiers : object {
    public static DerObjectIdentifier IdQcs;
    public static DerObjectIdentifier IdQcsPkixQCSyntaxV1;
    public static DerObjectIdentifier IdQcsPkixQCSyntaxV2;
    private static Rfc3739QCObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.SemanticsInformation : Asn1Encodable {
    private DerObjectIdentifier semanticsIdentifier;
    private GeneralName[] nameRegistrationAuthorities;
    public DerObjectIdentifier SemanticsIdentifier { get; }
    public SemanticsInformation(Asn1Sequence seq);
    public SemanticsInformation(DerObjectIdentifier semanticsIdentifier, GeneralName[] generalNames);
    public SemanticsInformation(DerObjectIdentifier semanticsIdentifier);
    public SemanticsInformation(GeneralName[] generalNames);
    public static SemanticsInformation GetInstance(object obj);
    public DerObjectIdentifier get_SemanticsIdentifier();
    public GeneralName[] GetNameRegistrationAuthorities();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.TypeOfBiometricData : Asn1Encodable {
    public static int Picture;
    public static int HandwrittenSignature;
    internal Asn1Encodable obj;
    public bool IsPredefined { get; }
    public int PredefinedBiometricType { get; }
    public DerObjectIdentifier BiometricDataOid { get; }
    public TypeOfBiometricData(int predefinedBiometricType);
    public TypeOfBiometricData(DerObjectIdentifier biometricDataOid);
    public static TypeOfBiometricData GetInstance(object obj);
    public bool get_IsPredefined();
    public int get_PredefinedBiometricType();
    public DerObjectIdentifier get_BiometricDataOid();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.ReasonFlags : DerBitString {
    public static int Unused;
    public static int KeyCompromise;
    public static int CACompromise;
    public static int AffiliationChanged;
    public static int Superseded;
    public static int CessationOfOperation;
    public static int CertificateHold;
    public static int PrivilegeWithdrawn;
    public static int AACompromise;
    public ReasonFlags(int reasons);
    public ReasonFlags(DerBitString reasons);
}
public class Org.BouncyCastle.Asn1.X509.RoleSyntax : Asn1Encodable {
    private GeneralNames roleAuthority;
    private GeneralName roleName;
    public GeneralNames RoleAuthority { get; }
    public GeneralName RoleName { get; }
    public RoleSyntax(GeneralNames roleAuthority, GeneralName roleName);
    public RoleSyntax(GeneralName roleName);
    public RoleSyntax(string roleName);
    private RoleSyntax(Asn1Sequence seq);
    public static RoleSyntax GetInstance(object obj);
    public GeneralNames get_RoleAuthority();
    public GeneralName get_RoleName();
    public string GetRoleNameAsString();
    public String[] GetRoleAuthorityAsString();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.RsaPublicKeyStructure : Asn1Encodable {
    private BigInteger modulus;
    private BigInteger publicExponent;
    public BigInteger Modulus { get; }
    public BigInteger PublicExponent { get; }
    public RsaPublicKeyStructure(BigInteger modulus, BigInteger publicExponent);
    private RsaPublicKeyStructure(Asn1Sequence seq);
    public static RsaPublicKeyStructure GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static RsaPublicKeyStructure GetInstance(object obj);
    public BigInteger get_Modulus();
    public BigInteger get_PublicExponent();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym : Asn1Encodable {
    private DirectoryString pseudonym;
    private DirectoryString surname;
    private Asn1Sequence givenName;
    public DirectoryString Pseudonym { get; }
    public DirectoryString Surname { get; }
    public NameOrPseudonym(DirectoryString pseudonym);
    private NameOrPseudonym(Asn1Sequence seq);
    public NameOrPseudonym(string pseudonym);
    public NameOrPseudonym(DirectoryString surname, Asn1Sequence givenName);
    public static NameOrPseudonym GetInstance(object obj);
    public DirectoryString get_Pseudonym();
    public DirectoryString get_Surname();
    public DirectoryString[] GetGivenName();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.SigI.PersonalData : Asn1Encodable {
    private NameOrPseudonym nameOrPseudonym;
    private BigInteger nameDistinguisher;
    private DerGeneralizedTime dateOfBirth;
    private DirectoryString placeOfBirth;
    private string gender;
    private DirectoryString postalAddress;
    public NameOrPseudonym NameOrPseudonym { get; }
    public BigInteger NameDistinguisher { get; }
    public DerGeneralizedTime DateOfBirth { get; }
    public DirectoryString PlaceOfBirth { get; }
    public string Gender { get; }
    public DirectoryString PostalAddress { get; }
    private PersonalData(Asn1Sequence seq);
    public PersonalData(NameOrPseudonym nameOrPseudonym, BigInteger nameDistinguisher, DerGeneralizedTime dateOfBirth, DirectoryString placeOfBirth, string gender, DirectoryString postalAddress);
    public static PersonalData GetInstance(object obj);
    public NameOrPseudonym get_NameOrPseudonym();
    public BigInteger get_NameDistinguisher();
    public DerGeneralizedTime get_DateOfBirth();
    public DirectoryString get_PlaceOfBirth();
    public string get_Gender();
    public DirectoryString get_PostalAddress();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers : object {
    public static DerObjectIdentifier IdSigI;
    public static DerObjectIdentifier IdSigIKP;
    public static DerObjectIdentifier IdSigICP;
    public static DerObjectIdentifier IdSigION;
    public static DerObjectIdentifier IdSigIKPDirectoryService;
    public static DerObjectIdentifier IdSigIONPersonalData;
    public static DerObjectIdentifier IdSigICPSigConform;
    private static SigIObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes : Asn1Encodable {
    private IList attributes;
    public IEnumerable Attributes { get; }
    private SubjectDirectoryAttributes(Asn1Sequence seq);
    [ObsoleteAttribute]
public SubjectDirectoryAttributes(ArrayList attributes);
    public SubjectDirectoryAttributes(IList attributes);
    public static SubjectDirectoryAttributes GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public IEnumerable get_Attributes();
}
public class Org.BouncyCastle.Asn1.X509.SubjectKeyIdentifier : Asn1Encodable {
    private Byte[] keyIdentifier;
    public SubjectKeyIdentifier(Byte[] keyID);
    public SubjectKeyIdentifier(Asn1OctetString keyID);
    public SubjectKeyIdentifier(SubjectPublicKeyInfo spki);
    public static SubjectKeyIdentifier GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static SubjectKeyIdentifier GetInstance(object obj);
    public static SubjectKeyIdentifier FromExtensions(X509Extensions extensions);
    public Byte[] GetKeyIdentifier();
    public virtual Asn1Object ToAsn1Object();
    public static SubjectKeyIdentifier CreateSha1KeyIdentifier(SubjectPublicKeyInfo keyInfo);
    public static SubjectKeyIdentifier CreateTruncatedSha1KeyIdentifier(SubjectPublicKeyInfo keyInfo);
    private static Byte[] GetDigest(SubjectPublicKeyInfo spki);
}
public class Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo : Asn1Encodable {
    private AlgorithmIdentifier algID;
    private DerBitString keyData;
    public AlgorithmIdentifier AlgorithmID { get; }
    public DerBitString PublicKeyData { get; }
    public SubjectPublicKeyInfo(AlgorithmIdentifier algID, Asn1Encodable publicKey);
    public SubjectPublicKeyInfo(AlgorithmIdentifier algID, Byte[] publicKey);
    private SubjectPublicKeyInfo(Asn1Sequence seq);
    public static SubjectPublicKeyInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static SubjectPublicKeyInfo GetInstance(object obj);
    public AlgorithmIdentifier get_AlgorithmID();
    public Asn1Object ParsePublicKey();
    [ObsoleteAttribute("Use 'ParsePublicKey' instead")]
public Asn1Object GetPublicKey();
    public DerBitString get_PublicKeyData();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Target : Asn1Encodable {
    private GeneralName targetName;
    private GeneralName targetGroup;
    public GeneralName TargetGroup { get; }
    public GeneralName TargetName { get; }
    private Target(Asn1TaggedObject tagObj);
    public Target(Choice type, GeneralName name);
    public static Target GetInstance(object obj);
    public virtual GeneralName get_TargetGroup();
    public virtual GeneralName get_TargetName();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.TargetInformation : Asn1Encodable {
    private Asn1Sequence targets;
    private TargetInformation(Asn1Sequence targets);
    public TargetInformation(Targets targets);
    public TargetInformation(Target[] targets);
    public static TargetInformation GetInstance(object obj);
    public virtual Targets[] GetTargetsObjects();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Targets : Asn1Encodable {
    private Asn1Sequence targets;
    private Targets(Asn1Sequence targets);
    public Targets(Target[] targets);
    public static Targets GetInstance(object obj);
    public virtual Target[] GetTargets();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.TbsCertificateList : Asn1Encodable {
    internal Asn1Sequence seq;
    internal DerInteger version;
    internal AlgorithmIdentifier signature;
    internal X509Name issuer;
    internal Time thisUpdate;
    internal Time nextUpdate;
    internal Asn1Sequence revokedCertificates;
    internal X509Extensions crlExtensions;
    public int Version { get; }
    public DerInteger VersionNumber { get; }
    public AlgorithmIdentifier Signature { get; }
    public X509Name Issuer { get; }
    public Time ThisUpdate { get; }
    public Time NextUpdate { get; }
    public X509Extensions Extensions { get; }
    internal TbsCertificateList(Asn1Sequence seq);
    public static TbsCertificateList GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static TbsCertificateList GetInstance(object obj);
    public int get_Version();
    public DerInteger get_VersionNumber();
    public AlgorithmIdentifier get_Signature();
    public X509Name get_Issuer();
    public Time get_ThisUpdate();
    public Time get_NextUpdate();
    public CrlEntry[] GetRevokedCertificates();
    public IEnumerable GetRevokedCertificateEnumeration();
    public X509Extensions get_Extensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.TbsCertificateStructure : Asn1Encodable {
    internal Asn1Sequence seq;
    internal DerInteger version;
    internal DerInteger serialNumber;
    internal AlgorithmIdentifier signature;
    internal X509Name issuer;
    internal Time startDate;
    internal Time endDate;
    internal X509Name subject;
    internal SubjectPublicKeyInfo subjectPublicKeyInfo;
    internal DerBitString issuerUniqueID;
    internal DerBitString subjectUniqueID;
    internal X509Extensions extensions;
    public int Version { get; }
    public DerInteger VersionNumber { get; }
    public DerInteger SerialNumber { get; }
    public AlgorithmIdentifier Signature { get; }
    public X509Name Issuer { get; }
    public Time StartDate { get; }
    public Time EndDate { get; }
    public X509Name Subject { get; }
    public SubjectPublicKeyInfo SubjectPublicKeyInfo { get; }
    public DerBitString IssuerUniqueID { get; }
    public DerBitString SubjectUniqueID { get; }
    public X509Extensions Extensions { get; }
    internal TbsCertificateStructure(Asn1Sequence seq);
    public static TbsCertificateStructure GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static TbsCertificateStructure GetInstance(object obj);
    public int get_Version();
    public DerInteger get_VersionNumber();
    public DerInteger get_SerialNumber();
    public AlgorithmIdentifier get_Signature();
    public X509Name get_Issuer();
    public Time get_StartDate();
    public Time get_EndDate();
    public X509Name get_Subject();
    public SubjectPublicKeyInfo get_SubjectPublicKeyInfo();
    public DerBitString get_IssuerUniqueID();
    public DerBitString get_SubjectUniqueID();
    public X509Extensions get_Extensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Time : Asn1Encodable {
    private Asn1Object time;
    public Time(Asn1Object time);
    public Time(DateTime date);
    public static Time GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Time GetInstance(object obj);
    public string GetTime();
    public DateTime ToDateTime();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.UserNotice : Asn1Encodable {
    private NoticeReference noticeRef;
    private DisplayText explicitText;
    public NoticeReference NoticeRef { get; }
    public DisplayText ExplicitText { get; }
    public UserNotice(NoticeReference noticeRef, DisplayText explicitText);
    public UserNotice(NoticeReference noticeRef, string str);
    [ObsoleteAttribute("Use GetInstance() instead")]
public UserNotice(Asn1Sequence seq);
    public static UserNotice GetInstance(object obj);
    public virtual NoticeReference get_NoticeRef();
    public virtual DisplayText get_ExplicitText();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.V1TbsCertificateGenerator : object {
    internal DerTaggedObject version;
    internal DerInteger serialNumber;
    internal AlgorithmIdentifier signature;
    internal X509Name issuer;
    internal Time startDate;
    internal Time endDate;
    internal X509Name subject;
    internal SubjectPublicKeyInfo subjectPublicKeyInfo;
    public void SetSerialNumber(DerInteger serialNumber);
    public void SetSignature(AlgorithmIdentifier signature);
    public void SetIssuer(X509Name issuer);
    public void SetStartDate(Time startDate);
    public void SetStartDate(DerUtcTime startDate);
    public void SetEndDate(Time endDate);
    public void SetEndDate(DerUtcTime endDate);
    public void SetSubject(X509Name subject);
    public void SetSubjectPublicKeyInfo(SubjectPublicKeyInfo pubKeyInfo);
    public TbsCertificateStructure GenerateTbsCertificate();
}
public class Org.BouncyCastle.Asn1.X509.V2AttributeCertificateInfoGenerator : object {
    internal DerInteger version;
    internal Holder holder;
    internal AttCertIssuer issuer;
    internal AlgorithmIdentifier signature;
    internal DerInteger serialNumber;
    internal Asn1EncodableVector attributes;
    internal DerBitString issuerUniqueID;
    internal X509Extensions extensions;
    internal DerGeneralizedTime startDate;
    internal DerGeneralizedTime endDate;
    public void SetHolder(Holder holder);
    public void AddAttribute(string oid, Asn1Encodable value);
    public void AddAttribute(AttributeX509 attribute);
    public void SetSerialNumber(DerInteger serialNumber);
    public void SetSignature(AlgorithmIdentifier signature);
    public void SetIssuer(AttCertIssuer issuer);
    public void SetStartDate(DerGeneralizedTime startDate);
    public void SetEndDate(DerGeneralizedTime endDate);
    public void SetIssuerUniqueID(DerBitString issuerUniqueID);
    public void SetExtensions(X509Extensions extensions);
    public AttributeCertificateInfo GenerateAttributeCertificateInfo();
}
public class Org.BouncyCastle.Asn1.X509.V2Form : Asn1Encodable {
    internal GeneralNames issuerName;
    internal IssuerSerial baseCertificateID;
    internal ObjectDigestInfo objectDigestInfo;
    public GeneralNames IssuerName { get; }
    public IssuerSerial BaseCertificateID { get; }
    public ObjectDigestInfo ObjectDigestInfo { get; }
    public V2Form(GeneralNames issuerName);
    public V2Form(GeneralNames issuerName, IssuerSerial baseCertificateID);
    public V2Form(GeneralNames issuerName, ObjectDigestInfo objectDigestInfo);
    public V2Form(GeneralNames issuerName, IssuerSerial baseCertificateID, ObjectDigestInfo objectDigestInfo);
    private V2Form(Asn1Sequence seq);
    public static V2Form GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static V2Form GetInstance(object obj);
    public GeneralNames get_IssuerName();
    public IssuerSerial get_BaseCertificateID();
    public ObjectDigestInfo get_ObjectDigestInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.V2TbsCertListGenerator : object {
    private DerInteger version;
    private AlgorithmIdentifier signature;
    private X509Name issuer;
    private Time thisUpdate;
    private Time nextUpdate;
    private X509Extensions extensions;
    private IList crlEntries;
    public void SetSignature(AlgorithmIdentifier signature);
    public void SetIssuer(X509Name issuer);
    public void SetThisUpdate(DerUtcTime thisUpdate);
    public void SetNextUpdate(DerUtcTime nextUpdate);
    public void SetThisUpdate(Time thisUpdate);
    public void SetNextUpdate(Time nextUpdate);
    public void AddCrlEntry(Asn1Sequence crlEntry);
    public void AddCrlEntry(DerInteger userCertificate, DerUtcTime revocationDate, int reason);
    public void AddCrlEntry(DerInteger userCertificate, Time revocationDate, int reason);
    public void AddCrlEntry(DerInteger userCertificate, Time revocationDate, int reason, DerGeneralizedTime invalidityDate);
    public void AddCrlEntry(DerInteger userCertificate, Time revocationDate, X509Extensions extensions);
    public void SetExtensions(X509Extensions extensions);
    public TbsCertificateList GenerateTbsCertList();
}
public class Org.BouncyCastle.Asn1.X509.V3TbsCertificateGenerator : object {
    internal DerTaggedObject version;
    internal DerInteger serialNumber;
    internal AlgorithmIdentifier signature;
    internal X509Name issuer;
    internal Time startDate;
    internal Time endDate;
    internal X509Name subject;
    internal SubjectPublicKeyInfo subjectPublicKeyInfo;
    internal X509Extensions extensions;
    private bool altNamePresentAndCritical;
    private DerBitString issuerUniqueID;
    private DerBitString subjectUniqueID;
    public void SetSerialNumber(DerInteger serialNumber);
    public void SetSignature(AlgorithmIdentifier signature);
    public void SetIssuer(X509Name issuer);
    public void SetStartDate(DerUtcTime startDate);
    public void SetStartDate(Time startDate);
    public void SetEndDate(DerUtcTime endDate);
    public void SetEndDate(Time endDate);
    public void SetSubject(X509Name subject);
    public void SetIssuerUniqueID(DerBitString uniqueID);
    public void SetSubjectUniqueID(DerBitString uniqueID);
    public void SetSubjectPublicKeyInfo(SubjectPublicKeyInfo pubKeyInfo);
    public void SetExtensions(X509Extensions extensions);
    public TbsCertificateStructure GenerateTbsCertificate();
}
public class Org.BouncyCastle.Asn1.X509.X509Attributes : object {
    public static DerObjectIdentifier RoleSyntax;
    private static X509Attributes();
}
public class Org.BouncyCastle.Asn1.X509.X509CertificateStructure : Asn1Encodable {
    private TbsCertificateStructure tbsCert;
    private AlgorithmIdentifier sigAlgID;
    private DerBitString sig;
    public TbsCertificateStructure TbsCertificate { get; }
    public int Version { get; }
    public DerInteger SerialNumber { get; }
    public X509Name Issuer { get; }
    public Time StartDate { get; }
    public Time EndDate { get; }
    public X509Name Subject { get; }
    public SubjectPublicKeyInfo SubjectPublicKeyInfo { get; }
    public AlgorithmIdentifier SignatureAlgorithm { get; }
    public DerBitString Signature { get; }
    public X509CertificateStructure(TbsCertificateStructure tbsCert, AlgorithmIdentifier sigAlgID, DerBitString sig);
    private X509CertificateStructure(Asn1Sequence seq);
    public static X509CertificateStructure GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static X509CertificateStructure GetInstance(object obj);
    public TbsCertificateStructure get_TbsCertificate();
    public int get_Version();
    public DerInteger get_SerialNumber();
    public X509Name get_Issuer();
    public Time get_StartDate();
    public Time get_EndDate();
    public X509Name get_Subject();
    public SubjectPublicKeyInfo get_SubjectPublicKeyInfo();
    public AlgorithmIdentifier get_SignatureAlgorithm();
    public DerBitString get_Signature();
    public Byte[] GetSignatureOctets();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.X509DefaultEntryConverter : X509NameEntryConverter {
    public virtual Asn1Object GetConvertedValue(DerObjectIdentifier oid, string value);
}
public class Org.BouncyCastle.Asn1.X509.X509Extension : object {
    internal bool critical;
    internal Asn1OctetString value;
    public bool IsCritical { get; }
    public Asn1OctetString Value { get; }
    public X509Extension(DerBoolean critical, Asn1OctetString value);
    public X509Extension(bool critical, Asn1OctetString value);
    public bool get_IsCritical();
    public Asn1OctetString get_Value();
    public Asn1Encodable GetParsedValue();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static Asn1Object ConvertValueToObject(X509Extension ext);
}
public class Org.BouncyCastle.Asn1.X509.X509Extensions : Asn1Encodable {
    public static DerObjectIdentifier SubjectDirectoryAttributes;
    public static DerObjectIdentifier SubjectKeyIdentifier;
    public static DerObjectIdentifier KeyUsage;
    public static DerObjectIdentifier PrivateKeyUsagePeriod;
    public static DerObjectIdentifier SubjectAlternativeName;
    public static DerObjectIdentifier IssuerAlternativeName;
    public static DerObjectIdentifier BasicConstraints;
    public static DerObjectIdentifier CrlNumber;
    public static DerObjectIdentifier ReasonCode;
    public static DerObjectIdentifier InstructionCode;
    public static DerObjectIdentifier InvalidityDate;
    public static DerObjectIdentifier DeltaCrlIndicator;
    public static DerObjectIdentifier IssuingDistributionPoint;
    public static DerObjectIdentifier CertificateIssuer;
    public static DerObjectIdentifier NameConstraints;
    public static DerObjectIdentifier CrlDistributionPoints;
    public static DerObjectIdentifier CertificatePolicies;
    public static DerObjectIdentifier PolicyMappings;
    public static DerObjectIdentifier AuthorityKeyIdentifier;
    public static DerObjectIdentifier PolicyConstraints;
    public static DerObjectIdentifier ExtendedKeyUsage;
    public static DerObjectIdentifier FreshestCrl;
    public static DerObjectIdentifier InhibitAnyPolicy;
    public static DerObjectIdentifier AuthorityInfoAccess;
    public static DerObjectIdentifier SubjectInfoAccess;
    public static DerObjectIdentifier LogoType;
    public static DerObjectIdentifier BiometricInfo;
    public static DerObjectIdentifier QCStatements;
    public static DerObjectIdentifier AuditIdentity;
    public static DerObjectIdentifier NoRevAvail;
    public static DerObjectIdentifier TargetInformation;
    public static DerObjectIdentifier ExpiredCertsOnCrl;
    private IDictionary extensions;
    private IList ordering;
    public IEnumerable ExtensionOids { get; }
    private X509Extensions(Asn1Sequence seq);
    public X509Extensions(IDictionary extensions);
    public X509Extensions(IList ordering, IDictionary extensions);
    public X509Extensions(IList oids, IList values);
    [ObsoleteAttribute]
public X509Extensions(Hashtable extensions);
    [ObsoleteAttribute]
public X509Extensions(ArrayList ordering, Hashtable extensions);
    [ObsoleteAttribute]
public X509Extensions(ArrayList oids, ArrayList values);
    private static X509Extensions();
    public static X509Extension GetExtension(X509Extensions extensions, DerObjectIdentifier oid);
    public static Asn1Encodable GetExtensionParsedValue(X509Extensions extensions, DerObjectIdentifier oid);
    public static X509Extensions GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static X509Extensions GetInstance(object obj);
    [ObsoleteAttribute("Use ExtensionOids IEnumerable property")]
public IEnumerator Oids();
    public IEnumerable get_ExtensionOids();
    public X509Extension GetExtension(DerObjectIdentifier oid);
    public Asn1Encodable GetExtensionParsedValue(DerObjectIdentifier oid);
    public virtual Asn1Object ToAsn1Object();
    public bool Equivalent(X509Extensions other);
    public DerObjectIdentifier[] GetExtensionOids();
    public DerObjectIdentifier[] GetNonCriticalExtensionOids();
    public DerObjectIdentifier[] GetCriticalExtensionOids();
    private DerObjectIdentifier[] GetExtensionOids(bool isCritical);
    private static DerObjectIdentifier[] ToOidArray(IList oids);
}
public class Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator : object {
    private IDictionary extensions;
    private IList extOrdering;
    private static IDictionary dupsAllowed;
    public bool IsEmpty { get; }
    private static X509ExtensionsGenerator();
    public void Reset();
    public void AddExtension(DerObjectIdentifier oid, bool critical, Asn1Encodable extValue);
    public void AddExtension(DerObjectIdentifier oid, bool critical, Byte[] extValue);
    public void AddExtensions(X509Extensions extensions);
    public bool get_IsEmpty();
    public X509Extensions Generate();
    internal void AddExtension(DerObjectIdentifier oid, X509Extension x509Extension);
}
public class Org.BouncyCastle.Asn1.X509.X509Name : Asn1Encodable {
    public static DerObjectIdentifier C;
    public static DerObjectIdentifier O;
    public static DerObjectIdentifier OU;
    public static DerObjectIdentifier T;
    public static DerObjectIdentifier CN;
    public static DerObjectIdentifier Street;
    public static DerObjectIdentifier SerialNumber;
    public static DerObjectIdentifier L;
    public static DerObjectIdentifier ST;
    public static DerObjectIdentifier Surname;
    public static DerObjectIdentifier GivenName;
    public static DerObjectIdentifier Initials;
    public static DerObjectIdentifier Generation;
    public static DerObjectIdentifier UniqueIdentifier;
    public static DerObjectIdentifier BusinessCategory;
    public static DerObjectIdentifier PostalCode;
    public static DerObjectIdentifier DnQualifier;
    public static DerObjectIdentifier Pseudonym;
    public static DerObjectIdentifier DateOfBirth;
    public static DerObjectIdentifier PlaceOfBirth;
    public static DerObjectIdentifier Gender;
    public static DerObjectIdentifier CountryOfCitizenship;
    public static DerObjectIdentifier CountryOfResidence;
    public static DerObjectIdentifier NameAtBirth;
    public static DerObjectIdentifier PostalAddress;
    public static DerObjectIdentifier DmdName;
    public static DerObjectIdentifier TelephoneNumber;
    public static DerObjectIdentifier OrganizationIdentifier;
    public static DerObjectIdentifier Name;
    public static DerObjectIdentifier EmailAddress;
    public static DerObjectIdentifier UnstructuredName;
    public static DerObjectIdentifier UnstructuredAddress;
    public static DerObjectIdentifier E;
    public static DerObjectIdentifier DC;
    public static DerObjectIdentifier UID;
    private static Boolean[] defaultReverse;
    public static Hashtable DefaultSymbols;
    public static Hashtable RFC2253Symbols;
    public static Hashtable RFC1779Symbols;
    public static Hashtable DefaultLookup;
    private IList ordering;
    private X509NameEntryConverter converter;
    private IList values;
    private IList added;
    private Asn1Sequence seq;
    public static bool DefaultReverse { get; public set; }
    private static X509Name();
    protected X509Name(Asn1Sequence seq);
    public X509Name(IList ordering, IDictionary attributes);
    public X509Name(IList ordering, IDictionary attributes, X509NameEntryConverter converter);
    public X509Name(IList oids, IList values);
    public X509Name(IList oids, IList values, X509NameEntryConverter converter);
    public X509Name(string dirName);
    public X509Name(string dirName, X509NameEntryConverter converter);
    public X509Name(bool reverse, string dirName);
    public X509Name(bool reverse, string dirName, X509NameEntryConverter converter);
    public X509Name(bool reverse, IDictionary lookUp, string dirName);
    public X509Name(bool reverse, IDictionary lookUp, string dirName, X509NameEntryConverter converter);
    public static bool get_DefaultReverse();
    public static void set_DefaultReverse(bool value);
    public static X509Name GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static X509Name GetInstance(object obj);
    private DerObjectIdentifier DecodeOid(string name, IDictionary lookUp);
    public IList GetOidList();
    public IList GetValueList();
    public IList GetValueList(DerObjectIdentifier oid);
    public virtual Asn1Object ToAsn1Object();
    public bool Equivalent(X509Name other, bool inOrder);
    public bool Equivalent(X509Name other);
    private static bool equivalentStrings(string s1, string s2);
    private static string canonicalize(string s);
    private static Asn1Object decodeObject(string v);
    private static string stripInternalSpaces(string str);
    private void AppendValue(StringBuilder buf, IDictionary oidSymbols, DerObjectIdentifier oid, string val);
    public string ToString(bool reverse, IDictionary oidSymbols);
    public virtual string ToString();
}
public abstract class Org.BouncyCastle.Asn1.X509.X509NameEntryConverter : object {
    protected Asn1Object ConvertHexEncoded(string hexString, int offset);
    protected bool CanBePrintable(string str);
    public abstract virtual Asn1Object GetConvertedValue(DerObjectIdentifier oid, string value);
}
public class Org.BouncyCastle.Asn1.X509.X509NameTokenizer : object {
    private string value;
    private int index;
    private char separator;
    private StringBuilder buffer;
    public X509NameTokenizer(string oid);
    public X509NameTokenizer(string oid, char separator);
    public bool HasMoreTokens();
    public string NextToken();
}
public abstract class Org.BouncyCastle.Asn1.X509.X509ObjectIdentifiers : object {
    internal static string ID;
    public static DerObjectIdentifier CommonName;
    public static DerObjectIdentifier CountryName;
    public static DerObjectIdentifier LocalityName;
    public static DerObjectIdentifier StateOrProvinceName;
    public static DerObjectIdentifier Organization;
    public static DerObjectIdentifier OrganizationalUnitName;
    public static DerObjectIdentifier id_at_telephoneNumber;
    public static DerObjectIdentifier id_at_name;
    public static DerObjectIdentifier id_at_organizationIdentifier;
    public static DerObjectIdentifier IdSha1;
    public static DerObjectIdentifier RipeMD160;
    public static DerObjectIdentifier RipeMD160WithRsaEncryption;
    public static DerObjectIdentifier IdEARsa;
    public static DerObjectIdentifier IdPkix;
    public static DerObjectIdentifier IdPE;
    public static DerObjectIdentifier IdAD;
    public static DerObjectIdentifier IdADCAIssuers;
    public static DerObjectIdentifier IdADOcsp;
    public static DerObjectIdentifier OcspAccessMethod;
    public static DerObjectIdentifier CrlAccessMethod;
    private static X509ObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.X9.DHDomainParameters : Asn1Encodable {
    private DerInteger p;
    private DerInteger g;
    private DerInteger q;
    private DerInteger j;
    private DHValidationParms validationParms;
    public DerInteger P { get; }
    public DerInteger G { get; }
    public DerInteger Q { get; }
    public DerInteger J { get; }
    public DHValidationParms ValidationParms { get; }
    public DHDomainParameters(DerInteger p, DerInteger g, DerInteger q, DerInteger j, DHValidationParms validationParms);
    private DHDomainParameters(Asn1Sequence seq);
    public static DHDomainParameters GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static DHDomainParameters GetInstance(object obj);
    private static Asn1Encodable GetNext(IEnumerator e);
    public DerInteger get_P();
    public DerInteger get_G();
    public DerInteger get_Q();
    public DerInteger get_J();
    public DHValidationParms get_ValidationParms();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.DHPublicKey : Asn1Encodable {
    private DerInteger y;
    public DerInteger Y { get; }
    public DHPublicKey(DerInteger y);
    public static DHPublicKey GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static DHPublicKey GetInstance(object obj);
    public DerInteger get_Y();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.DHValidationParms : Asn1Encodable {
    private DerBitString seed;
    private DerInteger pgenCounter;
    public DerBitString Seed { get; }
    public DerInteger PgenCounter { get; }
    public DHValidationParms(DerBitString seed, DerInteger pgenCounter);
    private DHValidationParms(Asn1Sequence seq);
    public static DHValidationParms GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static DHValidationParms GetInstance(object obj);
    public DerBitString get_Seed();
    public DerInteger get_PgenCounter();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.ECNamedCurveTable : object {
    public static IEnumerable Names { get; }
    public static X9ECParameters GetByName(string name);
    public static string GetName(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static X9ECParameters GetByOid(DerObjectIdentifier oid);
    public static IEnumerable get_Names();
}
public class Org.BouncyCastle.Asn1.X9.KeySpecificInfo : Asn1Encodable {
    private DerObjectIdentifier algorithm;
    private Asn1OctetString counter;
    public DerObjectIdentifier Algorithm { get; }
    public Asn1OctetString Counter { get; }
    public KeySpecificInfo(DerObjectIdentifier algorithm, Asn1OctetString counter);
    public KeySpecificInfo(Asn1Sequence seq);
    public DerObjectIdentifier get_Algorithm();
    public Asn1OctetString get_Counter();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.OtherInfo : Asn1Encodable {
    private KeySpecificInfo keyInfo;
    private Asn1OctetString partyAInfo;
    private Asn1OctetString suppPubInfo;
    public KeySpecificInfo KeyInfo { get; }
    public Asn1OctetString PartyAInfo { get; }
    public Asn1OctetString SuppPubInfo { get; }
    public OtherInfo(KeySpecificInfo keyInfo, Asn1OctetString partyAInfo, Asn1OctetString suppPubInfo);
    public OtherInfo(Asn1Sequence seq);
    public KeySpecificInfo get_KeyInfo();
    public Asn1OctetString get_PartyAInfo();
    public Asn1OctetString get_SuppPubInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.X962NamedCurves : object {
    private static IDictionary objIds;
    private static IDictionary curves;
    private static IDictionary names;
    public static IEnumerable Names { get; }
    private static X962NamedCurves();
    private static X9ECPoint ConfigureBasepoint(ECCurve curve, string encoding);
    private static ECCurve ConfigureCurve(ECCurve curve);
    private static BigInteger FromHex(string hex);
    private static void DefineCurve(string name, DerObjectIdentifier oid, X9ECParametersHolder holder);
    public static X9ECParameters GetByName(string name);
    public static X9ECParameters GetByOid(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static string GetName(DerObjectIdentifier oid);
    public static IEnumerable get_Names();
}
public class Org.BouncyCastle.Asn1.X9.X962Parameters : Asn1Encodable {
    private Asn1Object _params;
    public bool IsNamedCurve { get; }
    public bool IsImplicitlyCA { get; }
    public Asn1Object Parameters { get; }
    public X962Parameters(X9ECParameters ecParameters);
    public X962Parameters(DerObjectIdentifier namedCurve);
    public X962Parameters(Asn1Null obj);
    [ObsoleteAttribute("Use 'GetInstance' instead")]
public X962Parameters(Asn1Object obj);
    public static X962Parameters GetInstance(object obj);
    public bool get_IsNamedCurve();
    public bool get_IsImplicitlyCA();
    public Asn1Object get_Parameters();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.X9Curve : Asn1Encodable {
    private ECCurve curve;
    private Byte[] seed;
    private DerObjectIdentifier fieldIdentifier;
    public ECCurve Curve { get; }
    public X9Curve(ECCurve curve);
    public X9Curve(ECCurve curve, Byte[] seed);
    [ObsoleteAttribute("Use constructor including order/cofactor")]
public X9Curve(X9FieldID fieldID, Asn1Sequence seq);
    public X9Curve(X9FieldID fieldID, BigInteger order, BigInteger cofactor, Asn1Sequence seq);
    public ECCurve get_Curve();
    public Byte[] GetSeed();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.X9ECParameters : Asn1Encodable {
    private X9FieldID fieldID;
    private ECCurve curve;
    private X9ECPoint g;
    private BigInteger n;
    private BigInteger h;
    private Byte[] seed;
    public ECCurve Curve { get; }
    public ECPoint G { get; }
    public BigInteger N { get; }
    public BigInteger H { get; }
    public X9Curve CurveEntry { get; }
    public X9FieldID FieldIDEntry { get; }
    public X9ECPoint BaseEntry { get; }
    public X9ECParameters(Asn1Sequence seq);
    public X9ECParameters(ECCurve curve, ECPoint g, BigInteger n);
    public X9ECParameters(ECCurve curve, X9ECPoint g, BigInteger n, BigInteger h);
    public X9ECParameters(ECCurve curve, ECPoint g, BigInteger n, BigInteger h);
    public X9ECParameters(ECCurve curve, ECPoint g, BigInteger n, BigInteger h, Byte[] seed);
    public X9ECParameters(ECCurve curve, X9ECPoint g, BigInteger n, BigInteger h, Byte[] seed);
    public static X9ECParameters GetInstance(object obj);
    public ECCurve get_Curve();
    public ECPoint get_G();
    public BigInteger get_N();
    public BigInteger get_H();
    public Byte[] GetSeed();
    public X9Curve get_CurveEntry();
    public X9FieldID get_FieldIDEntry();
    public X9ECPoint get_BaseEntry();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.X9.X9ECParametersHolder : object {
    private X9ECParameters parameters;
    public X9ECParameters Parameters { get; }
    public X9ECParameters get_Parameters();
    protected abstract virtual X9ECParameters CreateParameters();
}
public class Org.BouncyCastle.Asn1.X9.X9ECPoint : Asn1Encodable {
    private Asn1OctetString encoding;
    private ECCurve c;
    private ECPoint p;
    public ECPoint Point { get; }
    public bool IsPointCompressed { get; }
    public X9ECPoint(ECPoint p);
    public X9ECPoint(ECPoint p, bool compressed);
    public X9ECPoint(ECCurve c, Byte[] encoding);
    public X9ECPoint(ECCurve c, Asn1OctetString s);
    public Byte[] GetPointEncoding();
    public ECPoint get_Point();
    public bool get_IsPointCompressed();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.X9FieldElement : Asn1Encodable {
    private ECFieldElement f;
    public ECFieldElement Value { get; }
    public X9FieldElement(ECFieldElement f);
    [ObsoleteAttribute("Will be removed")]
public X9FieldElement(BigInteger p, Asn1OctetString s);
    [ObsoleteAttribute("Will be removed")]
public X9FieldElement(int m, int k1, int k2, int k3, Asn1OctetString s);
    public ECFieldElement get_Value();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.X9FieldID : Asn1Encodable {
    private DerObjectIdentifier id;
    private Asn1Object parameters;
    public DerObjectIdentifier Identifier { get; }
    public Asn1Object Parameters { get; }
    public X9FieldID(BigInteger primeP);
    public X9FieldID(int m, int k1);
    public X9FieldID(int m, int k1, int k2, int k3);
    private X9FieldID(Asn1Sequence seq);
    public static X9FieldID GetInstance(object obj);
    public DerObjectIdentifier get_Identifier();
    public Asn1Object get_Parameters();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.X9.X9IntegerConverter : object {
    public static int GetByteLength(ECFieldElement fe);
    public static int GetByteLength(ECCurve c);
    public static Byte[] IntegerToBytes(BigInteger s, int qLength);
}
public abstract class Org.BouncyCastle.Asn1.X9.X9ObjectIdentifiers : object {
    internal static string AnsiX962;
    public static DerObjectIdentifier ansi_X9_62;
    public static DerObjectIdentifier IdFieldType;
    public static DerObjectIdentifier PrimeField;
    public static DerObjectIdentifier CharacteristicTwoField;
    public static DerObjectIdentifier GNBasis;
    public static DerObjectIdentifier TPBasis;
    public static DerObjectIdentifier PPBasis;
    [ObsoleteAttribute("Use 'id_ecSigType' instead")]
public static string IdECSigType;
    public static DerObjectIdentifier id_ecSigType;
    public static DerObjectIdentifier ECDsaWithSha1;
    [ObsoleteAttribute("Use 'id_publicKeyType' instead")]
public static string IdPublicKeyType;
    public static DerObjectIdentifier id_publicKeyType;
    public static DerObjectIdentifier IdECPublicKey;
    public static DerObjectIdentifier ECDsaWithSha2;
    public static DerObjectIdentifier ECDsaWithSha224;
    public static DerObjectIdentifier ECDsaWithSha256;
    public static DerObjectIdentifier ECDsaWithSha384;
    public static DerObjectIdentifier ECDsaWithSha512;
    public static DerObjectIdentifier EllipticCurve;
    public static DerObjectIdentifier CTwoCurve;
    public static DerObjectIdentifier C2Pnb163v1;
    public static DerObjectIdentifier C2Pnb163v2;
    public static DerObjectIdentifier C2Pnb163v3;
    public static DerObjectIdentifier C2Pnb176w1;
    public static DerObjectIdentifier C2Tnb191v1;
    public static DerObjectIdentifier C2Tnb191v2;
    public static DerObjectIdentifier C2Tnb191v3;
    public static DerObjectIdentifier C2Onb191v4;
    public static DerObjectIdentifier C2Onb191v5;
    public static DerObjectIdentifier C2Pnb208w1;
    public static DerObjectIdentifier C2Tnb239v1;
    public static DerObjectIdentifier C2Tnb239v2;
    public static DerObjectIdentifier C2Tnb239v3;
    public static DerObjectIdentifier C2Onb239v4;
    public static DerObjectIdentifier C2Onb239v5;
    public static DerObjectIdentifier C2Pnb272w1;
    public static DerObjectIdentifier C2Pnb304w1;
    public static DerObjectIdentifier C2Tnb359v1;
    public static DerObjectIdentifier C2Pnb368w1;
    public static DerObjectIdentifier C2Tnb431r1;
    public static DerObjectIdentifier PrimeCurve;
    public static DerObjectIdentifier Prime192v1;
    public static DerObjectIdentifier Prime192v2;
    public static DerObjectIdentifier Prime192v3;
    public static DerObjectIdentifier Prime239v1;
    public static DerObjectIdentifier Prime239v2;
    public static DerObjectIdentifier Prime239v3;
    public static DerObjectIdentifier Prime256v1;
    public static DerObjectIdentifier IdDsa;
    public static DerObjectIdentifier IdDsaWithSha1;
    public static DerObjectIdentifier X9x63Scheme;
    public static DerObjectIdentifier DHSinglePassStdDHSha1KdfScheme;
    public static DerObjectIdentifier DHSinglePassCofactorDHSha1KdfScheme;
    public static DerObjectIdentifier MqvSinglePassSha1KdfScheme;
    public static DerObjectIdentifier ansi_x9_42;
    public static DerObjectIdentifier DHPublicNumber;
    public static DerObjectIdentifier X9x42Schemes;
    public static DerObjectIdentifier DHStatic;
    public static DerObjectIdentifier DHEphem;
    public static DerObjectIdentifier DHOneFlow;
    public static DerObjectIdentifier DHHybrid1;
    public static DerObjectIdentifier DHHybrid2;
    public static DerObjectIdentifier DHHybridOneFlow;
    public static DerObjectIdentifier Mqv2;
    public static DerObjectIdentifier Mqv1;
    private static X9ObjectIdentifiers();
}
public class Org.BouncyCastle.Bcpg.ArmoredInputStream : BaseInputStream {
    private static Byte[] decodingTable;
    private bool detectMissingChecksum;
    private Stream input;
    private bool start;
    private Int32[] outBuf;
    private int bufPtr;
    private Crc24 crc;
    private bool crcFound;
    private bool hasHeaders;
    private string header;
    private bool newLineFound;
    private bool clearText;
    private bool restart;
    private IList headerList;
    private int lastC;
    private bool isEndOfStream;
    private static ArmoredInputStream();
    public ArmoredInputStream(Stream input);
    public ArmoredInputStream(Stream input, bool hasHeaders);
    private static int Decode(int in0, int in1, int in2, int in3, Int32[] result);
    private bool ParseHeaders();
    public bool IsClearText();
    public bool IsEndOfStream();
    public string GetArmorHeaderLine();
    public String[] GetArmorHeaders();
    private int ReadIgnoreSpace();
    public virtual int ReadByte();
    public virtual int Read(Byte[] b, int off, int len);
    private void CheckIndexSize(int size, int off, int len);
    public virtual void Close();
    public virtual void SetDetectMissingCrc(bool detectMissing);
}
public class Org.BouncyCastle.Bcpg.ArmoredOutputStream : BaseOutputStream {
    public static string HeaderVersion;
    private static Byte[] encodingTable;
    private Stream outStream;
    private Int32[] buf;
    private int bufPtr;
    private Crc24 crc;
    private int chunkCount;
    private int lastb;
    private bool start;
    private bool clearText;
    private bool newLine;
    private string type;
    private static string nl;
    private static string headerStart;
    private static string headerTail;
    private static string footerStart;
    private static string footerTail;
    private static string Version;
    private IDictionary headers;
    public ArmoredOutputStream(Stream outStream);
    public ArmoredOutputStream(Stream outStream, IDictionary headers);
    private static ArmoredOutputStream();
    private static void Encode(Stream outStream, Int32[] data, int len);
    public void SetHeader(string name, string val);
    public void AddHeader(string name, string val);
    public void ResetHeaders();
    public void BeginClearText(HashAlgorithmTag hashAlgorithm);
    public void EndClearText();
    public virtual void WriteByte(byte b);
    public virtual void Close();
    private void DoClose();
    private void WriteHeaderEntry(string name, string v);
    private void DoWrite(string s);
}
public class Org.BouncyCastle.Bcpg.Attr.ImageAttrib : UserAttributeSubpacket {
    private static Byte[] Zeroes;
    private int hdrLength;
    private int _version;
    private int _encoding;
    private Byte[] imageData;
    public int Version { get; }
    public int Encoding { get; }
    public ImageAttrib(Byte[] data);
    public ImageAttrib(bool forceLongLength, Byte[] data);
    public ImageAttrib(Format imageType, Byte[] imageData);
    private static ImageAttrib();
    private static Byte[] ToByteArray(Format imageType, Byte[] imageData);
    public virtual int get_Version();
    public virtual int get_Encoding();
    public virtual Byte[] GetImageData();
}
public class Org.BouncyCastle.Bcpg.BcpgInputStream : BaseInputStream {
    private Stream m_in;
    private bool next;
    private int nextB;
    private BcpgInputStream(Stream inputStream);
    internal static BcpgInputStream Wrap(Stream inStr);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public Byte[] ReadAll();
    public void ReadFully(Byte[] buffer, int off, int len);
    public void ReadFully(Byte[] buffer);
    public PacketTag NextPacketTag();
    public Packet ReadPacket();
    public PacketTag SkipMarkerPackets();
    public virtual void Close();
}
public abstract class Org.BouncyCastle.Bcpg.BcpgObject : object {
    public virtual Byte[] GetEncoded();
    public abstract virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.BcpgOutputStream : BaseOutputStream {
    private Stream outStr;
    private Byte[] partialBuffer;
    private int partialBufferLength;
    private int partialPower;
    private int partialOffset;
    private static int BufferSizePower;
    public BcpgOutputStream(Stream outStr);
    public BcpgOutputStream(Stream outStr, PacketTag tag);
    public BcpgOutputStream(Stream outStr, PacketTag tag, long length, bool oldFormat);
    public BcpgOutputStream(Stream outStr, PacketTag tag, long length);
    public BcpgOutputStream(Stream outStr, PacketTag tag, Byte[] buffer);
    internal static BcpgOutputStream Wrap(Stream outStr);
    private void WriteNewPacketLength(long bodyLen);
    private void WriteHeader(PacketTag tag, bool oldPackets, bool partial, long bodyLen);
    private void PartialFlush(bool isLast);
    private void WritePartial(byte b);
    private void WritePartial(Byte[] buffer, int off, int len);
    public virtual void WriteByte(byte value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    internal virtual void WriteShort(short n);
    internal virtual void WriteInt(int n);
    internal virtual void WriteLong(long n);
    public void WritePacket(ContainedPacket p);
    internal void WritePacket(PacketTag tag, Byte[] body, bool oldFormat);
    public void WriteObject(BcpgObject bcpgObject);
    public void WriteObjects(BcpgObject[] v);
    public virtual void Flush();
    public void Finish();
    public virtual void Close();
}
public class Org.BouncyCastle.Bcpg.CompressedDataPacket : InputStreamPacket {
    private CompressionAlgorithmTag algorithm;
    public CompressionAlgorithmTag Algorithm { get; }
    internal CompressedDataPacket(BcpgInputStream bcpgIn);
    public CompressionAlgorithmTag get_Algorithm();
}
public enum Org.BouncyCastle.Bcpg.CompressionAlgorithmTag : Enum {
    public int value__;
    public static CompressionAlgorithmTag Uncompressed;
    public static CompressionAlgorithmTag Zip;
    public static CompressionAlgorithmTag ZLib;
    public static CompressionAlgorithmTag BZip2;
}
public abstract class Org.BouncyCastle.Bcpg.ContainedPacket : Packet {
    public Byte[] GetEncoded();
    public abstract virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.Crc24 : object {
    private static int Crc24Init;
    private static int Crc24Poly;
    private int crc;
    public int Value { get; }
    public void Update(int b);
    [ObsoleteAttribute("Use 'Value' property instead")]
public int GetValue();
    public int get_Value();
    public void Reset();
}
public class Org.BouncyCastle.Bcpg.DsaPublicBcpgKey : BcpgObject {
    private MPInteger p;
    private MPInteger q;
    private MPInteger g;
    private MPInteger y;
    public string Format { get; }
    public BigInteger G { get; }
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger Y { get; }
    public DsaPublicBcpgKey(BcpgInputStream bcpgIn);
    public DsaPublicBcpgKey(BigInteger p, BigInteger q, BigInteger g, BigInteger y);
    public sealed virtual string get_Format();
    public virtual Byte[] GetEncoded();
    public virtual void Encode(BcpgOutputStream bcpgOut);
    public BigInteger get_G();
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_Y();
}
public class Org.BouncyCastle.Bcpg.DsaSecretBcpgKey : BcpgObject {
    internal MPInteger x;
    public string Format { get; }
    public BigInteger X { get; }
    public DsaSecretBcpgKey(BcpgInputStream bcpgIn);
    public DsaSecretBcpgKey(BigInteger x);
    public sealed virtual string get_Format();
    public virtual Byte[] GetEncoded();
    public virtual void Encode(BcpgOutputStream bcpgOut);
    public BigInteger get_X();
}
public class Org.BouncyCastle.Bcpg.ECDHPublicBcpgKey : ECPublicBcpgKey {
    private byte reserved;
    private HashAlgorithmTag hashFunctionId;
    private SymmetricKeyAlgorithmTag symAlgorithmId;
    public byte Reserved { get; }
    public HashAlgorithmTag HashAlgorithm { get; }
    public SymmetricKeyAlgorithmTag SymmetricKeyAlgorithm { get; }
    public ECDHPublicBcpgKey(BcpgInputStream bcpgIn);
    public ECDHPublicBcpgKey(DerObjectIdentifier oid, ECPoint point, HashAlgorithmTag hashAlgorithm, SymmetricKeyAlgorithmTag symmetricKeyAlgorithm);
    public virtual byte get_Reserved();
    public virtual HashAlgorithmTag get_HashAlgorithm();
    public virtual SymmetricKeyAlgorithmTag get_SymmetricKeyAlgorithm();
    public virtual void Encode(BcpgOutputStream bcpgOut);
    private void VerifyHashAlgorithm();
    private void VerifySymmetricKeyAlgorithm();
}
public class Org.BouncyCastle.Bcpg.ECDsaPublicBcpgKey : ECPublicBcpgKey {
    protected internal ECDsaPublicBcpgKey(BcpgInputStream bcpgIn);
    public ECDsaPublicBcpgKey(DerObjectIdentifier oid, ECPoint point);
    public ECDsaPublicBcpgKey(DerObjectIdentifier oid, BigInteger encodedPoint);
}
public abstract class Org.BouncyCastle.Bcpg.ECPublicBcpgKey : BcpgObject {
    internal DerObjectIdentifier oid;
    internal BigInteger point;
    public string Format { get; }
    public BigInteger EncodedPoint { get; }
    public DerObjectIdentifier CurveOid { get; }
    protected ECPublicBcpgKey(BcpgInputStream bcpgIn);
    protected ECPublicBcpgKey(DerObjectIdentifier oid, ECPoint point);
    protected ECPublicBcpgKey(DerObjectIdentifier oid, BigInteger encodedPoint);
    public sealed virtual string get_Format();
    public virtual Byte[] GetEncoded();
    public virtual void Encode(BcpgOutputStream bcpgOut);
    public virtual BigInteger get_EncodedPoint();
    public virtual DerObjectIdentifier get_CurveOid();
    protected static Byte[] ReadBytesOfEncodedLength(BcpgInputStream bcpgIn);
}
public class Org.BouncyCastle.Bcpg.ECSecretBcpgKey : BcpgObject {
    internal MPInteger x;
    public string Format { get; }
    public BigInteger X { get; }
    public ECSecretBcpgKey(BcpgInputStream bcpgIn);
    public ECSecretBcpgKey(BigInteger x);
    public sealed virtual string get_Format();
    public virtual Byte[] GetEncoded();
    public virtual void Encode(BcpgOutputStream bcpgOut);
    public virtual BigInteger get_X();
}
public class Org.BouncyCastle.Bcpg.ElGamalPublicBcpgKey : BcpgObject {
    internal MPInteger p;
    internal MPInteger g;
    internal MPInteger y;
    public string Format { get; }
    public BigInteger P { get; }
    public BigInteger G { get; }
    public BigInteger Y { get; }
    public ElGamalPublicBcpgKey(BcpgInputStream bcpgIn);
    public ElGamalPublicBcpgKey(BigInteger p, BigInteger g, BigInteger y);
    public sealed virtual string get_Format();
    public virtual Byte[] GetEncoded();
    public BigInteger get_P();
    public BigInteger get_G();
    public BigInteger get_Y();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.ElGamalSecretBcpgKey : BcpgObject {
    internal MPInteger x;
    public string Format { get; }
    public BigInteger X { get; }
    public ElGamalSecretBcpgKey(BcpgInputStream bcpgIn);
    public ElGamalSecretBcpgKey(BigInteger x);
    public sealed virtual string get_Format();
    public BigInteger get_X();
    public virtual Byte[] GetEncoded();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.ExperimentalPacket : ContainedPacket {
    private PacketTag tag;
    private Byte[] contents;
    public PacketTag Tag { get; }
    internal ExperimentalPacket(PacketTag tag, BcpgInputStream bcpgIn);
    public PacketTag get_Tag();
    public Byte[] GetContents();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public enum Org.BouncyCastle.Bcpg.HashAlgorithmTag : Enum {
    public int value__;
    public static HashAlgorithmTag MD5;
    public static HashAlgorithmTag Sha1;
    public static HashAlgorithmTag RipeMD160;
    public static HashAlgorithmTag DoubleSha;
    public static HashAlgorithmTag MD2;
    public static HashAlgorithmTag Tiger192;
    public static HashAlgorithmTag Haval5pass160;
    public static HashAlgorithmTag Sha256;
    public static HashAlgorithmTag Sha384;
    public static HashAlgorithmTag Sha512;
    public static HashAlgorithmTag Sha224;
}
public interface Org.BouncyCastle.Bcpg.IBcpgKey {
    public string Format { get; }
    public abstract virtual string get_Format();
}
public class Org.BouncyCastle.Bcpg.InputStreamPacket : Packet {
    private BcpgInputStream bcpgIn;
    public InputStreamPacket(BcpgInputStream bcpgIn);
    public BcpgInputStream GetInputStream();
}
public class Org.BouncyCastle.Bcpg.LiteralDataPacket : InputStreamPacket {
    private int format;
    private Byte[] fileName;
    private long modDate;
    public int Format { get; }
    public long ModificationTime { get; }
    public string FileName { get; }
    internal LiteralDataPacket(BcpgInputStream bcpgIn);
    public int get_Format();
    public long get_ModificationTime();
    public string get_FileName();
    public Byte[] GetRawFileName();
}
public class Org.BouncyCastle.Bcpg.MarkerPacket : ContainedPacket {
    private Byte[] marker;
    public MarkerPacket(BcpgInputStream bcpgIn);
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.ModDetectionCodePacket : ContainedPacket {
    private Byte[] digest;
    internal ModDetectionCodePacket(BcpgInputStream bcpgIn);
    public ModDetectionCodePacket(Byte[] digest);
    public Byte[] GetDigest();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.MPInteger : BcpgObject {
    private BigInteger val;
    public BigInteger Value { get; }
    public MPInteger(BcpgInputStream bcpgIn);
    public MPInteger(BigInteger val);
    public BigInteger get_Value();
    public virtual void Encode(BcpgOutputStream bcpgOut);
    internal static void Encode(BcpgOutputStream bcpgOut, BigInteger val);
}
public class Org.BouncyCastle.Bcpg.OnePassSignaturePacket : ContainedPacket {
    private int version;
    private int sigType;
    private HashAlgorithmTag hashAlgorithm;
    private PublicKeyAlgorithmTag keyAlgorithm;
    private long keyId;
    private int nested;
    public int SignatureType { get; }
    public PublicKeyAlgorithmTag KeyAlgorithm { get; }
    public HashAlgorithmTag HashAlgorithm { get; }
    public long KeyId { get; }
    internal OnePassSignaturePacket(BcpgInputStream bcpgIn);
    public OnePassSignaturePacket(int sigType, HashAlgorithmTag hashAlgorithm, PublicKeyAlgorithmTag keyAlgorithm, long keyId, bool isNested);
    public int get_SignatureType();
    public PublicKeyAlgorithmTag get_KeyAlgorithm();
    public HashAlgorithmTag get_HashAlgorithm();
    public long get_KeyId();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public interface Org.BouncyCastle.Bcpg.OpenPgp.IStreamGenerator {
    public abstract virtual void Close();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedData : PgpObject {
    private CompressedDataPacket data;
    public CompressionAlgorithmTag Algorithm { get; }
    public PgpCompressedData(BcpgInputStream bcpgInput);
    public CompressionAlgorithmTag get_Algorithm();
    public Stream GetInputStream();
    public Stream GetDataStream();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedDataGenerator : object {
    private CompressionAlgorithmTag algorithm;
    private int compression;
    private Stream dOut;
    private BcpgOutputStream pkOut;
    public PgpCompressedDataGenerator(CompressionAlgorithmTag algorithm);
    public PgpCompressedDataGenerator(CompressionAlgorithmTag algorithm, int compression);
    public Stream Open(Stream outStr);
    public Stream Open(Stream outStr, Byte[] buffer);
    private void doOpen();
    public sealed virtual void Close();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpDataValidationException : PgpException {
    public PgpDataValidationException(string message);
    public PgpDataValidationException(string message, Exception exception);
}
public abstract class Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedData : object {
    internal InputStreamPacket encData;
    internal Stream encStream;
    internal TruncatedStream truncStream;
    internal PgpEncryptedData(InputStreamPacket encData);
    public virtual Stream GetInputStream();
    public bool IsIntegrityProtected();
    public bool Verify();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator : object {
    private BcpgOutputStream pOut;
    private CipherStream cOut;
    private IBufferedCipher c;
    private bool withIntegrityPacket;
    private bool oldFormat;
    private DigestStream digestOut;
    private IList methods;
    private SymmetricKeyAlgorithmTag defAlgorithm;
    private SecureRandom rand;
    public PgpEncryptedDataGenerator(SymmetricKeyAlgorithmTag encAlgorithm);
    public PgpEncryptedDataGenerator(SymmetricKeyAlgorithmTag encAlgorithm, bool withIntegrityPacket);
    public PgpEncryptedDataGenerator(SymmetricKeyAlgorithmTag encAlgorithm, SecureRandom rand);
    public PgpEncryptedDataGenerator(SymmetricKeyAlgorithmTag encAlgorithm, bool withIntegrityPacket, SecureRandom rand);
    public PgpEncryptedDataGenerator(SymmetricKeyAlgorithmTag encAlgorithm, SecureRandom rand, bool oldFormat);
    [ObsoleteAttribute("Use version that takes an explicit s2kDigest parameter")]
public void AddMethod(Char[] passPhrase);
    public void AddMethod(Char[] passPhrase, HashAlgorithmTag s2kDigest);
    public void AddMethodUtf8(Char[] passPhrase, HashAlgorithmTag s2kDigest);
    public void AddMethodRaw(Byte[] rawPassPhrase, HashAlgorithmTag s2kDigest);
    internal void DoAddMethod(Byte[] rawPassPhrase, bool clearPassPhrase, HashAlgorithmTag s2kDigest);
    public void AddMethod(PgpPublicKey key);
    public void AddMethod(PgpPublicKey key, bool sessionKeyObfuscation);
    private void AddCheckSum(Byte[] sessionInfo);
    private Byte[] CreateSessionInfo(SymmetricKeyAlgorithmTag algorithm, KeyParameter key);
    private Stream Open(Stream outStr, long length, Byte[] buffer);
    public Stream Open(Stream outStr, long length);
    public Stream Open(Stream outStr, Byte[] buffer);
    public sealed virtual void Close();
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataList : PgpObject {
    private IList list;
    private InputStreamPacket data;
    public PgpEncryptedData Item { get; }
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public PgpEncryptedDataList(BcpgInputStream bcpgInput);
    public PgpEncryptedData get_Item(int index);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public object Get(int index);
    public int get_Size();
    public int get_Count();
    public bool get_IsEmpty();
    public IEnumerable GetEncryptedDataObjects();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpException : Exception {
    [ObsoleteAttribute("Use InnerException property")]
public Exception UnderlyingException { get; }
    public PgpException(string message);
    public PgpException(string message, Exception exception);
    public Exception get_UnderlyingException();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpExperimental : PgpObject {
    private ExperimentalPacket p;
    public PgpExperimental(BcpgInputStream bcpgIn);
}
public abstract class Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyFlags : object {
    public static int CanCertify;
    public static int CanSign;
    public static int CanEncryptCommunications;
    public static int CanEncryptStorage;
    public static int MaybeSplit;
    public static int MaybeShared;
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair : object {
    private PgpPublicKey pub;
    private PgpPrivateKey priv;
    public long KeyId { get; }
    public PgpPublicKey PublicKey { get; }
    public PgpPrivateKey PrivateKey { get; }
    public PgpKeyPair(PublicKeyAlgorithmTag algorithm, AsymmetricCipherKeyPair keyPair, DateTime time);
    public PgpKeyPair(PublicKeyAlgorithmTag algorithm, AsymmetricKeyParameter pubKey, AsymmetricKeyParameter privKey, DateTime time);
    public PgpKeyPair(PgpPublicKey pub, PgpPrivateKey priv);
    public long get_KeyId();
    public PgpPublicKey get_PublicKey();
    public PgpPrivateKey get_PrivateKey();
}
public abstract class Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRing : PgpObject {
    internal static TrustPacket ReadOptionalTrustPacket(BcpgInputStream pIn);
    internal static IList ReadSignaturesAndTrust(BcpgInputStream pIn);
    internal static void ReadUserIDs(BcpgInputStream pIn, IList& ids, IList& idTrusts, IList& idSigs);
    private static bool IsUserTag(PacketTag tag);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator : object {
    private IList keys;
    private string id;
    private SymmetricKeyAlgorithmTag encAlgorithm;
    private HashAlgorithmTag hashAlgorithm;
    private int certificationLevel;
    private Byte[] rawPassPhrase;
    private bool useSha1;
    private PgpKeyPair masterKey;
    private PgpSignatureSubpacketVector hashedPacketVector;
    private PgpSignatureSubpacketVector unhashedPacketVector;
    private SecureRandom rand;
    [ObsoleteAttribute("Use version taking an explicit 'useSha1' parameter instead")]
public PgpKeyRingGenerator(int certificationLevel, PgpKeyPair masterKey, string id, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpKeyRingGenerator(int certificationLevel, PgpKeyPair masterKey, string id, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpKeyRingGenerator(int certificationLevel, PgpKeyPair masterKey, string id, SymmetricKeyAlgorithmTag encAlgorithm, bool utf8PassPhrase, Char[] passPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpKeyRingGenerator(int certificationLevel, PgpKeyPair masterKey, string id, SymmetricKeyAlgorithmTag encAlgorithm, Byte[] rawPassPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpKeyRingGenerator(int certificationLevel, PgpKeyPair masterKey, string id, SymmetricKeyAlgorithmTag encAlgorithm, HashAlgorithmTag hashAlgorithm, Char[] passPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpKeyRingGenerator(int certificationLevel, PgpKeyPair masterKey, string id, SymmetricKeyAlgorithmTag encAlgorithm, HashAlgorithmTag hashAlgorithm, bool utf8PassPhrase, Char[] passPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpKeyRingGenerator(int certificationLevel, PgpKeyPair masterKey, string id, SymmetricKeyAlgorithmTag encAlgorithm, HashAlgorithmTag hashAlgorithm, Byte[] rawPassPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public void AddSubKey(PgpKeyPair keyPair);
    public void AddSubKey(PgpKeyPair keyPair, HashAlgorithmTag hashAlgorithm);
    public void AddSubKey(PgpKeyPair keyPair, HashAlgorithmTag hashAlgorithm, HashAlgorithmTag primaryKeyBindingHashAlgorithm);
    public void AddSubKey(PgpKeyPair keyPair, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets);
    public void AddSubKey(PgpKeyPair keyPair, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, HashAlgorithmTag hashAlgorithm);
    public void AddSubKey(PgpKeyPair keyPair, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, HashAlgorithmTag hashAlgorithm, HashAlgorithmTag primaryKeyBindingHashAlgorithm);
    public PgpSecretKeyRing GenerateSecretKeyRing();
    public PgpPublicKeyRing GeneratePublicKeyRing();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyValidationException : PgpException {
    public PgpKeyValidationException(string message);
    public PgpKeyValidationException(string message, Exception exception);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData : PgpObject {
    public static char Binary;
    public static char Text;
    public static char Utf8;
    public static string Console;
    private LiteralDataPacket data;
    public int Format { get; }
    public string FileName { get; }
    public DateTime ModificationTime { get; }
    public PgpLiteralData(BcpgInputStream bcpgInput);
    public int get_Format();
    public string get_FileName();
    public Byte[] GetRawFileName();
    public DateTime get_ModificationTime();
    public Stream GetInputStream();
    public Stream GetDataStream();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralDataGenerator : object {
    public static char Binary;
    public static char Text;
    public static char Utf8;
    public static string Console;
    private BcpgOutputStream pkOut;
    private bool oldFormat;
    public PgpLiteralDataGenerator(bool oldFormat);
    private void WriteHeader(BcpgOutputStream outStr, char format, Byte[] encName, long modificationTime);
    public Stream Open(Stream outStr, char format, string name, long length, DateTime modificationTime);
    public Stream Open(Stream outStr, char format, string name, DateTime modificationTime, Byte[] buffer);
    public Stream Open(Stream outStr, char format, FileInfo file);
    public sealed virtual void Close();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpMarker : PgpObject {
    private MarkerPacket data;
    public PgpMarker(BcpgInputStream bcpgInput);
}
public abstract class Org.BouncyCastle.Bcpg.OpenPgp.PgpObject : object {
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpObjectFactory : object {
    private BcpgInputStream bcpgIn;
    public PgpObjectFactory(Stream inputStream);
    public PgpObjectFactory(Byte[] bytes);
    public PgpObject NextPgpObject();
    [ObsoleteAttribute("Use NextPgpObject() instead")]
public object NextObject();
    public IList AllPgpObjects();
    public IList FilterPgpObjects(Type type);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpOnePassSignature : object {
    private OnePassSignaturePacket sigPack;
    private int signatureType;
    private ISigner sig;
    private byte lastb;
    public long KeyId { get; }
    public int SignatureType { get; }
    public HashAlgorithmTag HashAlgorithm { get; }
    public PublicKeyAlgorithmTag KeyAlgorithm { get; }
    internal PgpOnePassSignature(BcpgInputStream bcpgInput);
    internal PgpOnePassSignature(OnePassSignaturePacket sigPack);
    private static OnePassSignaturePacket Cast(Packet packet);
    public void InitVerify(PgpPublicKey pubKey);
    public void Update(byte b);
    private void doCanonicalUpdateByte(byte b);
    private void doUpdateCRLF();
    public void Update(Byte[] bytes);
    public void Update(Byte[] bytes, int off, int length);
    public bool Verify(PgpSignature pgpSig);
    public long get_KeyId();
    public int get_SignatureType();
    public HashAlgorithmTag get_HashAlgorithm();
    public PublicKeyAlgorithmTag get_KeyAlgorithm();
    public Byte[] GetEncoded();
    public void Encode(Stream outStr);
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpOnePassSignatureList : PgpObject {
    private PgpOnePassSignature[] sigs;
    public PgpOnePassSignature Item { get; }
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public PgpOnePassSignatureList(PgpOnePassSignature[] sigs);
    public PgpOnePassSignatureList(PgpOnePassSignature sig);
    public PgpOnePassSignature get_Item(int index);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public PgpOnePassSignature Get(int index);
    public int get_Size();
    public int get_Count();
    public bool get_IsEmpty();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpPad : object {
    public static Byte[] PadSessionData(Byte[] sessionInfo);
    public static Byte[] PadSessionData(Byte[] sessionInfo, bool obfuscate);
    public static Byte[] UnpadSessionData(Byte[] encoded);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpPbeEncryptedData : PgpEncryptedData {
    private SymmetricKeyEncSessionPacket keyData;
    internal PgpPbeEncryptedData(SymmetricKeyEncSessionPacket keyData, InputStreamPacket encData);
    public virtual Stream GetInputStream();
    public Stream GetDataStream(Char[] passPhrase);
    public Stream GetDataStreamUtf8(Char[] passPhrase);
    public Stream GetDataStreamRaw(Byte[] rawPassPhrase);
    internal Stream DoGetDataStream(Byte[] rawPassPhrase, bool clearPassPhrase);
    private IBufferedCipher CreateStreamCipher(SymmetricKeyAlgorithmTag keyAlgorithm);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey : object {
    private long keyID;
    private PublicKeyPacket publicKeyPacket;
    private AsymmetricKeyParameter privateKey;
    public long KeyId { get; }
    public PublicKeyPacket PublicKeyPacket { get; }
    public AsymmetricKeyParameter Key { get; }
    public PgpPrivateKey(long keyID, PublicKeyPacket publicKeyPacket, AsymmetricKeyParameter privateKey);
    public long get_KeyId();
    public PublicKeyPacket get_PublicKeyPacket();
    public AsymmetricKeyParameter get_Key();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey : object {
    private static Int32[] MasterKeyCertificationTypes;
    private long keyId;
    private Byte[] fingerprint;
    private int keyStrength;
    internal PublicKeyPacket publicPk;
    internal TrustPacket trustPk;
    internal IList keySigs;
    internal IList ids;
    internal IList idTrusts;
    internal IList idSigs;
    internal IList subSigs;
    public int Version { get; }
    public DateTime CreationTime { get; }
    [ObsoleteAttribute("Use 'GetValidSeconds' instead")]
public int ValidDays { get; }
    public long KeyId { get; }
    public bool IsEncryptionKey { get; }
    public bool IsMasterKey { get; }
    public PublicKeyAlgorithmTag Algorithm { get; }
    public int BitStrength { get; }
    public PublicKeyPacket PublicKeyPacket { get; }
    public PgpPublicKey(PublicKeyAlgorithmTag algorithm, AsymmetricKeyParameter pubKey, DateTime time);
    public PgpPublicKey(PublicKeyPacket publicPk);
    internal PgpPublicKey(PublicKeyPacket publicPk, TrustPacket trustPk, IList sigs);
    internal PgpPublicKey(PgpPublicKey key, TrustPacket trust, IList subSigs);
    internal PgpPublicKey(PgpPublicKey pubKey);
    internal PgpPublicKey(PublicKeyPacket publicPk, TrustPacket trustPk, IList keySigs, IList ids, IList idTrusts, IList idSigs);
    internal PgpPublicKey(PublicKeyPacket publicPk, IList ids, IList idSigs);
    private static PgpPublicKey();
    public static Byte[] CalculateFingerprint(PublicKeyPacket publicPk);
    private static void UpdateDigest(IDigest d, BigInteger b);
    private void Init();
    public int get_Version();
    public DateTime get_CreationTime();
    public int get_ValidDays();
    public Byte[] GetTrustData();
    public long GetValidSeconds();
    private long GetExpirationTimeFromSig(bool selfSigned, int signatureType);
    public long get_KeyId();
    public Byte[] GetFingerprint();
    public bool get_IsEncryptionKey();
    public bool get_IsMasterKey();
    public PublicKeyAlgorithmTag get_Algorithm();
    public int get_BitStrength();
    public AsymmetricKeyParameter GetKey();
    private ECPublicKeyParameters GetECKey(string algorithm);
    public IEnumerable GetUserIds();
    public IEnumerable GetUserAttributes();
    public IEnumerable GetSignaturesForId(string id);
    public IEnumerable GetSignaturesForUserAttribute(PgpUserAttributeSubpacketVector userAttributes);
    public IEnumerable GetSignaturesOfType(int signatureType);
    public IEnumerable GetSignatures();
    public IEnumerable GetKeySignatures();
    public PublicKeyPacket get_PublicKeyPacket();
    public Byte[] GetEncoded();
    public void Encode(Stream outStr);
    public bool IsRevoked();
    public static PgpPublicKey AddCertification(PgpPublicKey key, string id, PgpSignature certification);
    public static PgpPublicKey AddCertification(PgpPublicKey key, PgpUserAttributeSubpacketVector userAttributes, PgpSignature certification);
    private static PgpPublicKey AddCert(PgpPublicKey key, object id, PgpSignature certification);
    public static PgpPublicKey RemoveCertification(PgpPublicKey key, PgpUserAttributeSubpacketVector userAttributes);
    public static PgpPublicKey RemoveCertification(PgpPublicKey key, string id);
    private static PgpPublicKey RemoveCert(PgpPublicKey key, object id);
    public static PgpPublicKey RemoveCertification(PgpPublicKey key, string id, PgpSignature certification);
    public static PgpPublicKey RemoveCertification(PgpPublicKey key, PgpUserAttributeSubpacketVector userAttributes, PgpSignature certification);
    private static PgpPublicKey RemoveCert(PgpPublicKey key, object id, PgpSignature certification);
    public static PgpPublicKey AddCertification(PgpPublicKey key, PgpSignature certification);
    public static PgpPublicKey RemoveCertification(PgpPublicKey key, PgpSignature certification);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyEncryptedData : PgpEncryptedData {
    private PublicKeyEncSessionPacket keyData;
    public long KeyId { get; }
    internal PgpPublicKeyEncryptedData(PublicKeyEncSessionPacket keyData, InputStreamPacket encData);
    private static IBufferedCipher GetKeyCipher(PublicKeyAlgorithmTag algorithm);
    private bool ConfirmCheckSum(Byte[] sessionInfo);
    public long get_KeyId();
    public SymmetricKeyAlgorithmTag GetSymmetricAlgorithm(PgpPrivateKey privKey);
    public Stream GetDataStream(PgpPrivateKey privKey);
    private Byte[] RecoverSessionData(PgpPrivateKey privKey);
    private static void ProcessEncodedMpi(IBufferedCipher cipher, int size, Byte[] mpiEnc);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing : PgpKeyRing {
    private IList keys;
    public PgpPublicKeyRing(Byte[] encoding);
    internal PgpPublicKeyRing(IList pubKeys);
    public PgpPublicKeyRing(Stream inputStream);
    public virtual PgpPublicKey GetPublicKey();
    public virtual PgpPublicKey GetPublicKey(long keyId);
    public virtual IEnumerable GetPublicKeys();
    public virtual Byte[] GetEncoded();
    public virtual void Encode(Stream outStr);
    public static PgpPublicKeyRing InsertPublicKey(PgpPublicKeyRing pubRing, PgpPublicKey pubKey);
    public static PgpPublicKeyRing RemovePublicKey(PgpPublicKeyRing pubRing, PgpPublicKey pubKey);
    internal static PublicKeyPacket ReadPublicKeyPacket(BcpgInputStream bcpgInput);
    internal static PgpPublicKey ReadSubkey(BcpgInputStream bcpgInput);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle : object {
    private IDictionary pubRings;
    private IList order;
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    private PgpPublicKeyRingBundle(IDictionary pubRings, IList order);
    public PgpPublicKeyRingBundle(Byte[] encoding);
    public PgpPublicKeyRingBundle(Stream inputStream);
    public PgpPublicKeyRingBundle(IEnumerable e);
    public int get_Size();
    public int get_Count();
    public IEnumerable GetKeyRings();
    public IEnumerable GetKeyRings(string userId);
    public IEnumerable GetKeyRings(string userId, bool matchPartial);
    public IEnumerable GetKeyRings(string userId, bool matchPartial, bool ignoreCase);
    public PgpPublicKey GetPublicKey(long keyId);
    public PgpPublicKeyRing GetPublicKeyRing(long keyId);
    public bool Contains(long keyID);
    public Byte[] GetEncoded();
    public void Encode(Stream outStr);
    public static PgpPublicKeyRingBundle AddPublicKeyRing(PgpPublicKeyRingBundle bundle, PgpPublicKeyRing publicKeyRing);
    public static PgpPublicKeyRingBundle RemovePublicKeyRing(PgpPublicKeyRingBundle bundle, PgpPublicKeyRing publicKeyRing);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey : object {
    private SecretKeyPacket secret;
    private PgpPublicKey pub;
    public bool IsSigningKey { get; }
    public bool IsMasterKey { get; }
    public bool IsPrivateKeyEmpty { get; }
    public SymmetricKeyAlgorithmTag KeyEncryptionAlgorithm { get; }
    public long KeyId { get; }
    public int S2kUsage { get; }
    public S2k S2k { get; }
    public PgpPublicKey PublicKey { get; }
    public IEnumerable UserIds { get; }
    public IEnumerable UserAttributes { get; }
    internal PgpSecretKey(SecretKeyPacket secret, PgpPublicKey pub);
    internal PgpSecretKey(PgpPrivateKey privKey, PgpPublicKey pubKey, SymmetricKeyAlgorithmTag encAlgorithm, Byte[] rawPassPhrase, bool clearPassPhrase, bool useSha1, SecureRandom rand, bool isMasterKey);
    [ObsoleteAttribute("Use the constructor taking an explicit 'useSha1' parameter instead")]
public PgpSecretKey(int certificationLevel, PgpKeyPair keyPair, string id, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpSecretKey(int certificationLevel, PgpKeyPair keyPair, string id, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpSecretKey(int certificationLevel, PgpKeyPair keyPair, string id, SymmetricKeyAlgorithmTag encAlgorithm, bool utf8PassPhrase, Char[] passPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpSecretKey(int certificationLevel, PgpKeyPair keyPair, string id, SymmetricKeyAlgorithmTag encAlgorithm, Byte[] rawPassPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    internal PgpSecretKey(int certificationLevel, PgpKeyPair keyPair, string id, SymmetricKeyAlgorithmTag encAlgorithm, Byte[] rawPassPhrase, bool clearPassPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpSecretKey(int certificationLevel, PgpKeyPair keyPair, string id, SymmetricKeyAlgorithmTag encAlgorithm, HashAlgorithmTag hashAlgorithm, Char[] passPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpSecretKey(int certificationLevel, PgpKeyPair keyPair, string id, SymmetricKeyAlgorithmTag encAlgorithm, HashAlgorithmTag hashAlgorithm, bool utf8PassPhrase, Char[] passPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpSecretKey(int certificationLevel, PgpKeyPair keyPair, string id, SymmetricKeyAlgorithmTag encAlgorithm, HashAlgorithmTag hashAlgorithm, Byte[] rawPassPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    internal PgpSecretKey(int certificationLevel, PgpKeyPair keyPair, string id, SymmetricKeyAlgorithmTag encAlgorithm, HashAlgorithmTag hashAlgorithm, Byte[] rawPassPhrase, bool clearPassPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpSecretKey(int certificationLevel, PublicKeyAlgorithmTag algorithm, AsymmetricKeyParameter pubKey, AsymmetricKeyParameter privKey, DateTime time, string id, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpSecretKey(int certificationLevel, PublicKeyAlgorithmTag algorithm, AsymmetricKeyParameter pubKey, AsymmetricKeyParameter privKey, DateTime time, string id, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    private static PgpPublicKey CertifiedPublicKey(int certificationLevel, PgpKeyPair keyPair, string id, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets);
    private static PgpPublicKey CertifiedPublicKey(int certificationLevel, PgpKeyPair keyPair, string id, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, HashAlgorithmTag hashAlgorithm);
    public bool get_IsSigningKey();
    public bool get_IsMasterKey();
    public bool get_IsPrivateKeyEmpty();
    public SymmetricKeyAlgorithmTag get_KeyEncryptionAlgorithm();
    public long get_KeyId();
    public int get_S2kUsage();
    public S2k get_S2k();
    public PgpPublicKey get_PublicKey();
    public IEnumerable get_UserIds();
    public IEnumerable get_UserAttributes();
    private Byte[] ExtractKeyData(Byte[] rawPassPhrase, bool clearPassPhrase);
    private static Byte[] RecoverKeyData(SymmetricKeyAlgorithmTag encAlgorithm, string modeAndPadding, KeyParameter key, Byte[] iv, Byte[] keyData, int keyOff, int keyLen);
    public PgpPrivateKey ExtractPrivateKey(Char[] passPhrase);
    public PgpPrivateKey ExtractPrivateKeyUtf8(Char[] passPhrase);
    public PgpPrivateKey ExtractPrivateKeyRaw(Byte[] rawPassPhrase);
    internal PgpPrivateKey DoExtractPrivateKey(Byte[] rawPassPhrase, bool clearPassPhrase);
    private ECPrivateKeyParameters GetECKey(string algorithm, BcpgInputStream bcpgIn);
    private static Byte[] Checksum(bool useSha1, Byte[] bytes, int length);
    public Byte[] GetEncoded();
    public void Encode(Stream outStr);
    public static PgpSecretKey CopyWithNewPassword(PgpSecretKey key, Char[] oldPassPhrase, Char[] newPassPhrase, SymmetricKeyAlgorithmTag newEncAlgorithm, SecureRandom rand);
    public static PgpSecretKey CopyWithNewPasswordUtf8(PgpSecretKey key, Char[] oldPassPhrase, Char[] newPassPhrase, SymmetricKeyAlgorithmTag newEncAlgorithm, SecureRandom rand);
    public static PgpSecretKey CopyWithNewPasswordRaw(PgpSecretKey key, Byte[] rawOldPassPhrase, Byte[] rawNewPassPhrase, SymmetricKeyAlgorithmTag newEncAlgorithm, SecureRandom rand);
    internal static PgpSecretKey DoCopyWithNewPassword(PgpSecretKey key, Byte[] rawOldPassPhrase, Byte[] rawNewPassPhrase, bool clearPassPhrase, SymmetricKeyAlgorithmTag newEncAlgorithm, SecureRandom rand);
    public static PgpSecretKey ReplacePublicKey(PgpSecretKey secretKey, PgpPublicKey publicKey);
    private static Byte[] EncryptKeyDataV3(Byte[] rawKeyData, SymmetricKeyAlgorithmTag encAlgorithm, Byte[] rawPassPhrase, bool clearPassPhrase, SecureRandom random, S2k& s2k, Byte[]& iv);
    private static Byte[] EncryptKeyDataV4(Byte[] rawKeyData, SymmetricKeyAlgorithmTag encAlgorithm, HashAlgorithmTag hashAlgorithm, Byte[] rawPassPhrase, bool clearPassPhrase, SecureRandom random, S2k& s2k, Byte[]& iv);
    private static Byte[] EncryptData(SymmetricKeyAlgorithmTag encAlgorithm, KeyParameter key, Byte[] data, int dataOff, int dataLen, SecureRandom random, Byte[]& iv);
    public static PgpSecretKey ParseSecretKeyFromSExpr(Stream inputStream, Char[] passPhrase, PgpPublicKey pubKey);
    public static PgpSecretKey ParseSecretKeyFromSExprUtf8(Stream inputStream, Char[] passPhrase, PgpPublicKey pubKey);
    public static PgpSecretKey ParseSecretKeyFromSExprRaw(Stream inputStream, Byte[] rawPassPhrase, PgpPublicKey pubKey);
    internal static PgpSecretKey DoParseSecretKeyFromSExpr(Stream inputStream, Byte[] rawPassPhrase, bool clearPassPhrase, PgpPublicKey pubKey);
    public static PgpSecretKey ParseSecretKeyFromSExpr(Stream inputStream, Char[] passPhrase);
    public static PgpSecretKey ParseSecretKeyFromSExprUtf8(Stream inputStream, Char[] passPhrase);
    public static PgpSecretKey ParseSecretKeyFromSExprRaw(Stream inputStream, Byte[] rawPassPhrase);
    internal static PgpSecretKey DoParseSecretKeyFromSExpr(Stream inputStream, Byte[] rawPassPhrase, bool clearPassPhrase);
    private static Byte[] GetDValue(Stream inputStream, Byte[] rawPassPhrase, bool clearPassPhrase, string curveName);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing : PgpKeyRing {
    private IList keys;
    private IList extraPubKeys;
    internal PgpSecretKeyRing(IList keys);
    private PgpSecretKeyRing(IList keys, IList extraPubKeys);
    public PgpSecretKeyRing(Byte[] encoding);
    public PgpSecretKeyRing(Stream inputStream);
    public PgpPublicKey GetPublicKey();
    public PgpSecretKey GetSecretKey();
    public IEnumerable GetSecretKeys();
    public PgpSecretKey GetSecretKey(long keyId);
    public IEnumerable GetExtraPublicKeys();
    public Byte[] GetEncoded();
    public void Encode(Stream outStr);
    public static PgpSecretKeyRing ReplacePublicKeys(PgpSecretKeyRing secretRing, PgpPublicKeyRing publicRing);
    public static PgpSecretKeyRing CopyWithNewPassword(PgpSecretKeyRing ring, Char[] oldPassPhrase, Char[] newPassPhrase, SymmetricKeyAlgorithmTag newEncAlgorithm, SecureRandom rand);
    public static PgpSecretKeyRing InsertSecretKey(PgpSecretKeyRing secRing, PgpSecretKey secKey);
    public static PgpSecretKeyRing RemoveSecretKey(PgpSecretKeyRing secRing, PgpSecretKey secKey);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle : object {
    private IDictionary secretRings;
    private IList order;
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    private PgpSecretKeyRingBundle(IDictionary secretRings, IList order);
    public PgpSecretKeyRingBundle(Byte[] encoding);
    public PgpSecretKeyRingBundle(Stream inputStream);
    public PgpSecretKeyRingBundle(IEnumerable e);
    public int get_Size();
    public int get_Count();
    public IEnumerable GetKeyRings();
    public IEnumerable GetKeyRings(string userId);
    public IEnumerable GetKeyRings(string userId, bool matchPartial);
    public IEnumerable GetKeyRings(string userId, bool matchPartial, bool ignoreCase);
    public PgpSecretKey GetSecretKey(long keyId);
    public PgpSecretKeyRing GetSecretKeyRing(long keyId);
    public bool Contains(long keyID);
    public Byte[] GetEncoded();
    public void Encode(Stream outStr);
    public static PgpSecretKeyRingBundle AddSecretKeyRing(PgpSecretKeyRingBundle bundle, PgpSecretKeyRing secretKeyRing);
    public static PgpSecretKeyRingBundle RemoveSecretKeyRing(PgpSecretKeyRingBundle bundle, PgpSecretKeyRing secretKeyRing);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature : object {
    public static int BinaryDocument;
    public static int CanonicalTextDocument;
    public static int StandAlone;
    public static int DefaultCertification;
    public static int NoCertification;
    public static int CasualCertification;
    public static int PositiveCertification;
    public static int SubkeyBinding;
    public static int PrimaryKeyBinding;
    public static int DirectKey;
    public static int KeyRevocation;
    public static int SubkeyRevocation;
    public static int CertificationRevocation;
    public static int Timestamp;
    private SignaturePacket sigPck;
    private int signatureType;
    private TrustPacket trustPck;
    private ISigner sig;
    private byte lastb;
    public int Version { get; }
    public PublicKeyAlgorithmTag KeyAlgorithm { get; }
    public HashAlgorithmTag HashAlgorithm { get; }
    public int SignatureType { get; }
    public long KeyId { get; }
    public DateTime CreationTime { get; }
    public bool HasSubpackets { get; }
    internal PgpSignature(BcpgInputStream bcpgInput);
    internal PgpSignature(SignaturePacket sigPacket);
    internal PgpSignature(SignaturePacket sigPacket, TrustPacket trustPacket);
    private static SignaturePacket Cast(Packet packet);
    private void GetSig();
    public int get_Version();
    public PublicKeyAlgorithmTag get_KeyAlgorithm();
    public HashAlgorithmTag get_HashAlgorithm();
    public bool IsCertification();
    public void InitVerify(PgpPublicKey pubKey);
    public void Update(byte b);
    private void doCanonicalUpdateByte(byte b);
    private void doUpdateCRLF();
    public void Update(Byte[] bytes);
    public void Update(Byte[] bytes, int off, int length);
    public bool Verify();
    private void UpdateWithIdData(int header, Byte[] idBytes);
    private void UpdateWithPublicKey(PgpPublicKey key);
    public bool VerifyCertification(PgpUserAttributeSubpacketVector userAttributes, PgpPublicKey key);
    public bool VerifyCertification(string id, PgpPublicKey key);
    public bool VerifyCertification(PgpPublicKey masterKey, PgpPublicKey pubKey);
    public bool VerifyCertification(PgpPublicKey pubKey);
    public int get_SignatureType();
    public long get_KeyId();
    [ObsoleteAttribute("Use 'CreationTime' property instead")]
public DateTime GetCreationTime();
    public DateTime get_CreationTime();
    public Byte[] GetSignatureTrailer();
    public bool get_HasSubpackets();
    public PgpSignatureSubpacketVector GetHashedSubPackets();
    public PgpSignatureSubpacketVector GetUnhashedSubPackets();
    private PgpSignatureSubpacketVector createSubpacketVector(SignatureSubpacket[] pcks);
    public Byte[] GetSignature();
    public Byte[] GetEncoded();
    public void Encode(Stream outStream);
    private Byte[] GetEncodedPublicKey(PgpPublicKey pubKey);
    public static bool IsCertification(int signatureType);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator : object {
    private static SignatureSubpacket[] EmptySignatureSubpackets;
    private PublicKeyAlgorithmTag keyAlgorithm;
    private HashAlgorithmTag hashAlgorithm;
    private PgpPrivateKey privKey;
    private ISigner sig;
    private IDigest dig;
    private int signatureType;
    private byte lastb;
    private SignatureSubpacket[] unhashed;
    private SignatureSubpacket[] hashed;
    public PgpSignatureGenerator(PublicKeyAlgorithmTag keyAlgorithm, HashAlgorithmTag hashAlgorithm);
    private static PgpSignatureGenerator();
    public void InitSign(int sigType, PgpPrivateKey key);
    public void InitSign(int sigType, PgpPrivateKey key, SecureRandom random);
    public void Update(byte b);
    private void doCanonicalUpdateByte(byte b);
    private void doUpdateCRLF();
    private void doUpdateByte(byte b);
    public void Update(Byte[] b);
    public void Update(Byte[] b, int off, int len);
    public void SetHashedSubpackets(PgpSignatureSubpacketVector hashedPackets);
    public void SetUnhashedSubpackets(PgpSignatureSubpacketVector unhashedPackets);
    public PgpOnePassSignature GenerateOnePassVersion(bool isNested);
    public PgpSignature Generate();
    public PgpSignature GenerateCertification(string id, PgpPublicKey pubKey);
    public PgpSignature GenerateCertification(PgpUserAttributeSubpacketVector userAttributes, PgpPublicKey pubKey);
    public PgpSignature GenerateCertification(PgpPublicKey masterKey, PgpPublicKey pubKey);
    public PgpSignature GenerateCertification(PgpPublicKey pubKey);
    private Byte[] GetEncodedPublicKey(PgpPublicKey pubKey);
    private bool packetPresent(SignatureSubpacket[] packets, SignatureSubpacketTag type);
    private SignatureSubpacket[] insertSubpacket(SignatureSubpacket[] packets, SignatureSubpacket subpacket);
    private void UpdateWithIdData(int header, Byte[] idBytes);
    private void UpdateWithPublicKey(PgpPublicKey key);
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureList : PgpObject {
    private PgpSignature[] sigs;
    public PgpSignature Item { get; }
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public PgpSignatureList(PgpSignature[] sigs);
    public PgpSignatureList(PgpSignature sig);
    public PgpSignature get_Item(int index);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public PgpSignature Get(int index);
    public int get_Size();
    public int get_Count();
    public bool get_IsEmpty();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator : object {
    private IList list;
    public PgpSignatureSubpacketGenerator(PgpSignatureSubpacketVector sigSubV);
    public void SetRevocable(bool isCritical, bool isRevocable);
    public void SetExportable(bool isCritical, bool isExportable);
    public void SetFeature(bool isCritical, byte feature);
    public void SetTrust(bool isCritical, int depth, int trustAmount);
    public void SetKeyExpirationTime(bool isCritical, long seconds);
    public void SetSignatureExpirationTime(bool isCritical, long seconds);
    public void SetSignatureCreationTime(bool isCritical, DateTime date);
    public void SetPreferredHashAlgorithms(bool isCritical, Int32[] algorithms);
    public void SetPreferredSymmetricAlgorithms(bool isCritical, Int32[] algorithms);
    public void SetPreferredCompressionAlgorithms(bool isCritical, Int32[] algorithms);
    public void SetKeyFlags(bool isCritical, int flags);
    public void SetSignerUserId(bool isCritical, string userId);
    public void SetSignerUserId(bool isCritical, Byte[] rawUserId);
    public void SetEmbeddedSignature(bool isCritical, PgpSignature pgpSignature);
    public void SetPrimaryUserId(bool isCritical, bool isPrimaryUserId);
    public void SetNotationData(bool isCritical, bool isHumanReadable, string notationName, string notationValue);
    public void SetRevocationReason(bool isCritical, RevocationReasonTag reason, string description);
    public void SetRevocationKey(bool isCritical, PublicKeyAlgorithmTag keyAlgorithm, Byte[] fingerprint);
    public void SetIssuerKeyID(bool isCritical, long keyID);
    public PgpSignatureSubpacketVector Generate();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector : object {
    private SignatureSubpacket[] packets;
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    internal PgpSignatureSubpacketVector(SignatureSubpacket[] packets);
    public static PgpSignatureSubpacketVector FromSubpackets(SignatureSubpacket[] packets);
    public SignatureSubpacket GetSubpacket(SignatureSubpacketTag type);
    public bool HasSubpacket(SignatureSubpacketTag type);
    public SignatureSubpacket[] GetSubpackets(SignatureSubpacketTag type);
    public NotationData[] GetNotationDataOccurrences();
    [ObsoleteAttribute("Use 'GetNotationDataOccurrences' instead")]
public NotationData[] GetNotationDataOccurences();
    public long GetIssuerKeyId();
    public bool HasSignatureCreationTime();
    public DateTime GetSignatureCreationTime();
    public long GetSignatureExpirationTime();
    public long GetKeyExpirationTime();
    public Int32[] GetPreferredHashAlgorithms();
    public Int32[] GetPreferredSymmetricAlgorithms();
    public Int32[] GetPreferredCompressionAlgorithms();
    public int GetKeyFlags();
    public string GetSignerUserId();
    public bool IsPrimaryUserId();
    public PgpSignatureList GetEmbeddedSignatures();
    public SignatureSubpacketTag[] GetCriticalTags();
    public Features GetFeatures();
    public int get_Size();
    public int get_Count();
    internal SignatureSubpacket[] ToSubpacketArray();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVector : object {
    private UserAttributeSubpacket[] packets;
    internal PgpUserAttributeSubpacketVector(UserAttributeSubpacket[] packets);
    public static PgpUserAttributeSubpacketVector FromSubpackets(UserAttributeSubpacket[] packets);
    public UserAttributeSubpacket GetSubpacket(UserAttributeSubpacketTag type);
    public ImageAttrib GetImageAttribute();
    internal UserAttributeSubpacket[] ToSubpacketArray();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVectorGenerator : object {
    private IList list;
    public virtual void SetImageAttribute(Format imageType, Byte[] imageData);
    public virtual PgpUserAttributeSubpacketVector Generate();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpUtilities : object {
    private static int ReadAhead;
    public static MPInteger[] DsaSigToMpi(Byte[] encoding);
    public static MPInteger[] RsaSigToMpi(Byte[] encoding);
    public static string GetDigestName(HashAlgorithmTag hashAlgorithm);
    public static string GetSignatureName(PublicKeyAlgorithmTag keyAlgorithm, HashAlgorithmTag hashAlgorithm);
    public static string GetSymmetricCipherName(SymmetricKeyAlgorithmTag algorithm);
    public static int GetKeySize(SymmetricKeyAlgorithmTag algorithm);
    public static KeyParameter MakeKey(SymmetricKeyAlgorithmTag algorithm, Byte[] keyBytes);
    public static KeyParameter MakeRandomKey(SymmetricKeyAlgorithmTag algorithm, SecureRandom random);
    internal static Byte[] EncodePassPhrase(Char[] passPhrase, bool utf8);
    public static KeyParameter MakeKeyFromPassPhrase(SymmetricKeyAlgorithmTag algorithm, S2k s2k, Char[] passPhrase);
    public static KeyParameter MakeKeyFromPassPhraseUtf8(SymmetricKeyAlgorithmTag algorithm, S2k s2k, Char[] passPhrase);
    public static KeyParameter MakeKeyFromPassPhraseRaw(SymmetricKeyAlgorithmTag algorithm, S2k s2k, Byte[] rawPassPhrase);
    internal static KeyParameter DoMakeKeyFromPassPhrase(SymmetricKeyAlgorithmTag algorithm, S2k s2k, Byte[] rawPassPhrase, bool clearPassPhrase);
    public static void WriteFileToLiteralData(Stream output, char fileType, FileInfo file);
    public static void WriteFileToLiteralData(Stream output, char fileType, FileInfo file, Byte[] buffer);
    private static void PipeFileContents(FileInfo file, Stream pOut, int bufSize);
    private static bool IsPossiblyBase64(int ch);
    public static Stream GetDecoderStream(Stream inputStream);
    internal static IWrapper CreateWrapper(SymmetricKeyAlgorithmTag encAlgorithm);
    internal static Byte[] GenerateIV(int length, SecureRandom random);
    internal static S2k GenerateS2k(HashAlgorithmTag hashAlgorithm, int s2kCount, SecureRandom random);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpV3SignatureGenerator : object {
    private PublicKeyAlgorithmTag keyAlgorithm;
    private HashAlgorithmTag hashAlgorithm;
    private PgpPrivateKey privKey;
    private ISigner sig;
    private IDigest dig;
    private int signatureType;
    private byte lastb;
    public PgpV3SignatureGenerator(PublicKeyAlgorithmTag keyAlgorithm, HashAlgorithmTag hashAlgorithm);
    public void InitSign(int sigType, PgpPrivateKey key);
    public void InitSign(int sigType, PgpPrivateKey key, SecureRandom random);
    public void Update(byte b);
    private void doCanonicalUpdateByte(byte b);
    private void doUpdateCRLF();
    private void doUpdateByte(byte b);
    public void Update(Byte[] b);
    public void Update(Byte[] b, int off, int len);
    public PgpOnePassSignature GenerateOnePassVersion(bool isNested);
    public PgpSignature Generate();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.Rfc6637Utilities : object {
    private static Byte[] ANONYMOUS_SENDER;
    private static Rfc6637Utilities();
    public static string GetAgreementAlgorithm(PublicKeyPacket pubKeyData);
    public static DerObjectIdentifier GetKeyEncryptionOID(SymmetricKeyAlgorithmTag algID);
    public static int GetKeyLength(SymmetricKeyAlgorithmTag algID);
    public static Byte[] CreateKey(PublicKeyPacket pubKeyData, ECPoint s);
    public static Byte[] CreateUserKeyingMaterial(PublicKeyPacket pubKeyData);
    private static Byte[] Kdf(HashAlgorithmTag digestAlg, ECPoint s, int keyLen, Byte[] parameters);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.SXprUtilities : object {
    private static int ReadLength(Stream input, int ch);
    internal static string ReadString(Stream input, int ch);
    internal static Byte[] ReadBytes(Stream input, int ch);
    internal static S2k ParseS2k(Stream input);
    internal static void SkipOpenParenthesis(Stream input);
    internal static void SkipCloseParenthesis(Stream input);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.WrappedGeneratorStream : FilterStream {
    private IStreamGenerator gen;
    public WrappedGeneratorStream(IStreamGenerator gen, Stream str);
    public virtual void Close();
}
public abstract class Org.BouncyCastle.Bcpg.OutputStreamPacket : object {
    private BcpgOutputStream bcpgOut;
    internal OutputStreamPacket(BcpgOutputStream bcpgOut);
    public abstract virtual BcpgOutputStream Open();
    public abstract virtual void Close();
}
public class Org.BouncyCastle.Bcpg.Packet : object {
}
public enum Org.BouncyCastle.Bcpg.PacketTag : Enum {
    public int value__;
    public static PacketTag Reserved;
    public static PacketTag PublicKeyEncryptedSession;
    public static PacketTag Signature;
    public static PacketTag SymmetricKeyEncryptedSessionKey;
    public static PacketTag OnePassSignature;
    public static PacketTag SecretKey;
    public static PacketTag PublicKey;
    public static PacketTag SecretSubkey;
    public static PacketTag CompressedData;
    public static PacketTag SymmetricKeyEncrypted;
    public static PacketTag Marker;
    public static PacketTag LiteralData;
    public static PacketTag Trust;
    public static PacketTag UserId;
    public static PacketTag PublicSubkey;
    public static PacketTag UserAttribute;
    public static PacketTag SymmetricEncryptedIntegrityProtected;
    public static PacketTag ModificationDetectionCode;
    public static PacketTag Experimental1;
    public static PacketTag Experimental2;
    public static PacketTag Experimental3;
    public static PacketTag Experimental4;
}
public enum Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag : Enum {
    public int value__;
    public static PublicKeyAlgorithmTag RsaGeneral;
    public static PublicKeyAlgorithmTag RsaEncrypt;
    public static PublicKeyAlgorithmTag RsaSign;
    public static PublicKeyAlgorithmTag ElGamalEncrypt;
    public static PublicKeyAlgorithmTag Dsa;
    [ObsoleteAttribute("Use 'ECDH' instead")]
public static PublicKeyAlgorithmTag EC;
    public static PublicKeyAlgorithmTag ECDH;
    public static PublicKeyAlgorithmTag ECDsa;
    public static PublicKeyAlgorithmTag ElGamalGeneral;
    public static PublicKeyAlgorithmTag DiffieHellman;
    public static PublicKeyAlgorithmTag EdDsa;
    public static PublicKeyAlgorithmTag Experimental_1;
    public static PublicKeyAlgorithmTag Experimental_2;
    public static PublicKeyAlgorithmTag Experimental_3;
    public static PublicKeyAlgorithmTag Experimental_4;
    public static PublicKeyAlgorithmTag Experimental_5;
    public static PublicKeyAlgorithmTag Experimental_6;
    public static PublicKeyAlgorithmTag Experimental_7;
    public static PublicKeyAlgorithmTag Experimental_8;
    public static PublicKeyAlgorithmTag Experimental_9;
    public static PublicKeyAlgorithmTag Experimental_10;
    public static PublicKeyAlgorithmTag Experimental_11;
}
public class Org.BouncyCastle.Bcpg.PublicKeyEncSessionPacket : ContainedPacket {
    private int version;
    private long keyId;
    private PublicKeyAlgorithmTag algorithm;
    private Byte[][] data;
    public int Version { get; }
    public long KeyId { get; }
    public PublicKeyAlgorithmTag Algorithm { get; }
    internal PublicKeyEncSessionPacket(BcpgInputStream bcpgIn);
    public PublicKeyEncSessionPacket(long keyId, PublicKeyAlgorithmTag algorithm, Byte[][] data);
    public int get_Version();
    public long get_KeyId();
    public PublicKeyAlgorithmTag get_Algorithm();
    public Byte[][] GetEncSessionKey();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.PublicKeyPacket : ContainedPacket {
    private int version;
    private long time;
    private int validDays;
    private PublicKeyAlgorithmTag algorithm;
    private IBcpgKey key;
    public int Version { get; }
    public PublicKeyAlgorithmTag Algorithm { get; }
    public int ValidDays { get; }
    public IBcpgKey Key { get; }
    internal PublicKeyPacket(BcpgInputStream bcpgIn);
    public PublicKeyPacket(PublicKeyAlgorithmTag algorithm, DateTime time, IBcpgKey key);
    public virtual int get_Version();
    public virtual PublicKeyAlgorithmTag get_Algorithm();
    public virtual int get_ValidDays();
    public virtual DateTime GetTime();
    public virtual IBcpgKey get_Key();
    public virtual Byte[] GetEncodedContents();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.PublicSubkeyPacket : PublicKeyPacket {
    internal PublicSubkeyPacket(BcpgInputStream bcpgIn);
    public PublicSubkeyPacket(PublicKeyAlgorithmTag algorithm, DateTime time, IBcpgKey key);
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.RevocationKey : SignatureSubpacket {
    public RevocationKeyTag SignatureClass { get; }
    public PublicKeyAlgorithmTag Algorithm { get; }
    public RevocationKey(bool isCritical, bool isLongLength, Byte[] data);
    public RevocationKey(bool isCritical, RevocationKeyTag signatureClass, PublicKeyAlgorithmTag keyAlgorithm, Byte[] fingerprint);
    private static Byte[] CreateData(RevocationKeyTag signatureClass, PublicKeyAlgorithmTag keyAlgorithm, Byte[] fingerprint);
    public virtual RevocationKeyTag get_SignatureClass();
    public virtual PublicKeyAlgorithmTag get_Algorithm();
    public virtual Byte[] GetFingerprint();
}
public enum Org.BouncyCastle.Bcpg.RevocationKeyTag : Enum {
    public byte value__;
    public static RevocationKeyTag ClassDefault;
    public static RevocationKeyTag ClassSensitive;
}
public class Org.BouncyCastle.Bcpg.RevocationReason : SignatureSubpacket {
    public RevocationReason(bool isCritical, bool isLongLength, Byte[] data);
    public RevocationReason(bool isCritical, RevocationReasonTag reason, string description);
    private static Byte[] CreateData(RevocationReasonTag reason, string description);
    public virtual RevocationReasonTag GetRevocationReason();
    public virtual string GetRevocationDescription();
}
public enum Org.BouncyCastle.Bcpg.RevocationReasonTag : Enum {
    public byte value__;
    public static RevocationReasonTag NoReason;
    public static RevocationReasonTag KeySuperseded;
    public static RevocationReasonTag KeyCompromised;
    public static RevocationReasonTag KeyRetired;
    public static RevocationReasonTag UserNoLongerValid;
}
public class Org.BouncyCastle.Bcpg.RsaPublicBcpgKey : BcpgObject {
    private MPInteger n;
    private MPInteger e;
    public BigInteger PublicExponent { get; }
    public BigInteger Modulus { get; }
    public string Format { get; }
    public RsaPublicBcpgKey(BcpgInputStream bcpgIn);
    public RsaPublicBcpgKey(BigInteger n, BigInteger e);
    public BigInteger get_PublicExponent();
    public BigInteger get_Modulus();
    public sealed virtual string get_Format();
    public virtual Byte[] GetEncoded();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.RsaSecretBcpgKey : BcpgObject {
    private MPInteger d;
    private MPInteger p;
    private MPInteger q;
    private MPInteger u;
    private BigInteger expP;
    private BigInteger expQ;
    private BigInteger crt;
    public BigInteger Modulus { get; }
    public BigInteger PrivateExponent { get; }
    public BigInteger PrimeP { get; }
    public BigInteger PrimeQ { get; }
    public BigInteger PrimeExponentP { get; }
    public BigInteger PrimeExponentQ { get; }
    public BigInteger CrtCoefficient { get; }
    public string Format { get; }
    public RsaSecretBcpgKey(BcpgInputStream bcpgIn);
    public RsaSecretBcpgKey(BigInteger d, BigInteger p, BigInteger q);
    public BigInteger get_Modulus();
    public BigInteger get_PrivateExponent();
    public BigInteger get_PrimeP();
    public BigInteger get_PrimeQ();
    public BigInteger get_PrimeExponentP();
    public BigInteger get_PrimeExponentQ();
    public BigInteger get_CrtCoefficient();
    public sealed virtual string get_Format();
    public virtual Byte[] GetEncoded();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.S2k : BcpgObject {
    private static int ExpBias;
    public static int Simple;
    public static int Salted;
    public static int SaltedAndIterated;
    public static int GnuDummyS2K;
    public static int GnuProtectionModeNoPrivateKey;
    public static int GnuProtectionModeDivertToCard;
    internal int type;
    internal HashAlgorithmTag algorithm;
    internal Byte[] iv;
    internal int itCount;
    internal int protectionMode;
    public int Type { get; }
    public HashAlgorithmTag HashAlgorithm { get; }
    public long IterationCount { get; }
    public int ProtectionMode { get; }
    internal S2k(Stream inStr);
    public S2k(HashAlgorithmTag algorithm);
    public S2k(HashAlgorithmTag algorithm, Byte[] iv);
    public S2k(HashAlgorithmTag algorithm, Byte[] iv, int itCount);
    public virtual int get_Type();
    public virtual HashAlgorithmTag get_HashAlgorithm();
    public virtual Byte[] GetIV();
    [ObsoleteAttribute("Use 'IterationCount' property instead")]
public long GetIterationCount();
    public virtual long get_IterationCount();
    public virtual int get_ProtectionMode();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.SecretKeyPacket : ContainedPacket {
    public static int UsageNone;
    public static int UsageChecksum;
    public static int UsageSha1;
    private PublicKeyPacket pubKeyPacket;
    private Byte[] secKeyData;
    private int s2kUsage;
    private SymmetricKeyAlgorithmTag encAlgorithm;
    private S2k s2k;
    private Byte[] iv;
    public SymmetricKeyAlgorithmTag EncAlgorithm { get; }
    public int S2kUsage { get; }
    public S2k S2k { get; }
    public PublicKeyPacket PublicKeyPacket { get; }
    internal SecretKeyPacket(BcpgInputStream bcpgIn);
    public SecretKeyPacket(PublicKeyPacket pubKeyPacket, SymmetricKeyAlgorithmTag encAlgorithm, S2k s2k, Byte[] iv, Byte[] secKeyData);
    public SecretKeyPacket(PublicKeyPacket pubKeyPacket, SymmetricKeyAlgorithmTag encAlgorithm, int s2kUsage, S2k s2k, Byte[] iv, Byte[] secKeyData);
    public SymmetricKeyAlgorithmTag get_EncAlgorithm();
    public int get_S2kUsage();
    public Byte[] GetIV();
    public S2k get_S2k();
    public PublicKeyPacket get_PublicKeyPacket();
    public Byte[] GetSecretKeyData();
    public Byte[] GetEncodedContents();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.SecretSubkeyPacket : SecretKeyPacket {
    internal SecretSubkeyPacket(BcpgInputStream bcpgIn);
    public SecretSubkeyPacket(PublicKeyPacket pubKeyPacket, SymmetricKeyAlgorithmTag encAlgorithm, S2k s2k, Byte[] iv, Byte[] secKeyData);
    public SecretSubkeyPacket(PublicKeyPacket pubKeyPacket, SymmetricKeyAlgorithmTag encAlgorithm, int s2kUsage, S2k s2k, Byte[] iv, Byte[] secKeyData);
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.Sig.EmbeddedSignature : SignatureSubpacket {
    public EmbeddedSignature(bool critical, bool isLongLength, Byte[] data);
}
public class Org.BouncyCastle.Bcpg.Sig.Exportable : SignatureSubpacket {
    public Exportable(bool critical, bool isLongLength, Byte[] data);
    public Exportable(bool critical, bool isExportable);
    private static Byte[] BooleanToByteArray(bool val);
    public bool IsExportable();
}
public class Org.BouncyCastle.Bcpg.Sig.Features : SignatureSubpacket {
    public static byte FEATURE_MODIFICATION_DETECTION;
    public static byte FEATURE_AEAD_ENCRYPTED_DATA;
    public static byte FEATURE_VERSION_5_PUBLIC_KEY;
    public bool SupportsModificationDetection { get; }
    public Features(bool critical, bool isLongLength, Byte[] data);
    public Features(bool critical, byte features);
    public Features(bool critical, int features);
    private static Features();
    private static Byte[] featureToByteArray(byte feature);
    public bool get_SupportsModificationDetection();
    public bool SupportsFeature(byte feature);
}
public class Org.BouncyCastle.Bcpg.Sig.IssuerKeyId : SignatureSubpacket {
    public long KeyId { get; }
    public IssuerKeyId(bool critical, bool isLongLength, Byte[] data);
    public IssuerKeyId(bool critical, long keyId);
    protected static Byte[] KeyIdToBytes(long keyId);
    public long get_KeyId();
}
public class Org.BouncyCastle.Bcpg.Sig.KeyExpirationTime : SignatureSubpacket {
    public long Time { get; }
    public KeyExpirationTime(bool critical, bool isLongLength, Byte[] data);
    public KeyExpirationTime(bool critical, long seconds);
    protected static Byte[] TimeToBytes(long t);
    public long get_Time();
}
public class Org.BouncyCastle.Bcpg.Sig.KeyFlags : SignatureSubpacket {
    public static int CertifyOther;
    public static int SignData;
    public static int EncryptComms;
    public static int EncryptStorage;
    public static int Split;
    public static int Authentication;
    public static int Shared;
    public int Flags { get; }
    public KeyFlags(bool critical, bool isLongLength, Byte[] data);
    public KeyFlags(bool critical, int flags);
    private static Byte[] IntToByteArray(int v);
    public int get_Flags();
}
public class Org.BouncyCastle.Bcpg.Sig.NotationData : SignatureSubpacket {
    public static int HeaderFlagLength;
    public static int HeaderNameLength;
    public static int HeaderValueLength;
    public bool IsHumanReadable { get; }
    public NotationData(bool critical, bool isLongLength, Byte[] data);
    public NotationData(bool critical, bool humanReadable, string notationName, string notationValue);
    private static Byte[] CreateData(bool humanReadable, string notationName, string notationValue);
    public bool get_IsHumanReadable();
    public string GetNotationName();
    public string GetNotationValue();
    public Byte[] GetNotationValueBytes();
}
public class Org.BouncyCastle.Bcpg.Sig.PreferredAlgorithms : SignatureSubpacket {
    public PreferredAlgorithms(SignatureSubpacketTag type, bool critical, bool isLongLength, Byte[] data);
    public PreferredAlgorithms(SignatureSubpacketTag type, bool critical, Int32[] preferences);
    private static Byte[] IntToByteArray(Int32[] v);
    public Int32[] GetPreferences();
}
public class Org.BouncyCastle.Bcpg.Sig.PrimaryUserId : SignatureSubpacket {
    public PrimaryUserId(bool critical, bool isLongLength, Byte[] data);
    public PrimaryUserId(bool critical, bool isPrimaryUserId);
    private static Byte[] BooleanToByteArray(bool val);
    public bool IsPrimaryUserId();
}
public class Org.BouncyCastle.Bcpg.Sig.Revocable : SignatureSubpacket {
    public Revocable(bool critical, bool isLongLength, Byte[] data);
    public Revocable(bool critical, bool isRevocable);
    private static Byte[] BooleanToByteArray(bool value);
    public bool IsRevocable();
}
public class Org.BouncyCastle.Bcpg.Sig.SignatureCreationTime : SignatureSubpacket {
    public SignatureCreationTime(bool critical, bool isLongLength, Byte[] data);
    public SignatureCreationTime(bool critical, DateTime date);
    protected static Byte[] TimeToBytes(DateTime time);
    public DateTime GetTime();
}
public class Org.BouncyCastle.Bcpg.Sig.SignatureExpirationTime : SignatureSubpacket {
    public long Time { get; }
    public SignatureExpirationTime(bool critical, bool isLongLength, Byte[] data);
    public SignatureExpirationTime(bool critical, long seconds);
    protected static Byte[] TimeToBytes(long t);
    public long get_Time();
}
public class Org.BouncyCastle.Bcpg.Sig.SignerUserId : SignatureSubpacket {
    public SignerUserId(bool critical, bool isLongLength, Byte[] data);
    public SignerUserId(bool critical, string userId);
    private static Byte[] UserIdToBytes(string id);
    public string GetId();
}
public class Org.BouncyCastle.Bcpg.Sig.TrustSignature : SignatureSubpacket {
    public int Depth { get; }
    public int TrustAmount { get; }
    public TrustSignature(bool critical, bool isLongLength, Byte[] data);
    public TrustSignature(bool critical, int depth, int trustAmount);
    private static Byte[] IntToByteArray(int v1, int v2);
    public int get_Depth();
    public int get_TrustAmount();
}
public class Org.BouncyCastle.Bcpg.SignaturePacket : ContainedPacket {
    private int version;
    private int signatureType;
    private long creationTime;
    private long keyId;
    private PublicKeyAlgorithmTag keyAlgorithm;
    private HashAlgorithmTag hashAlgorithm;
    private MPInteger[] signature;
    private Byte[] fingerprint;
    private SignatureSubpacket[] hashedData;
    private SignatureSubpacket[] unhashedData;
    private Byte[] signatureEncoding;
    public int Version { get; }
    public int SignatureType { get; }
    public long KeyId { get; }
    public PublicKeyAlgorithmTag KeyAlgorithm { get; }
    public HashAlgorithmTag HashAlgorithm { get; }
    public long CreationTime { get; }
    internal SignaturePacket(BcpgInputStream bcpgIn);
    public SignaturePacket(int signatureType, long keyId, PublicKeyAlgorithmTag keyAlgorithm, HashAlgorithmTag hashAlgorithm, SignatureSubpacket[] hashedData, SignatureSubpacket[] unhashedData, Byte[] fingerprint, MPInteger[] signature);
    public SignaturePacket(int version, int signatureType, long keyId, PublicKeyAlgorithmTag keyAlgorithm, HashAlgorithmTag hashAlgorithm, long creationTime, Byte[] fingerprint, MPInteger[] signature);
    public SignaturePacket(int version, int signatureType, long keyId, PublicKeyAlgorithmTag keyAlgorithm, HashAlgorithmTag hashAlgorithm, SignatureSubpacket[] hashedData, SignatureSubpacket[] unhashedData, Byte[] fingerprint, MPInteger[] signature);
    public int get_Version();
    public int get_SignatureType();
    public long get_KeyId();
    public Byte[] GetSignatureTrailer();
    public PublicKeyAlgorithmTag get_KeyAlgorithm();
    public HashAlgorithmTag get_HashAlgorithm();
    public MPInteger[] GetSignature();
    public Byte[] GetSignatureBytes();
    public SignatureSubpacket[] GetHashedSubPackets();
    public SignatureSubpacket[] GetUnhashedSubPackets();
    public long get_CreationTime();
    public virtual void Encode(BcpgOutputStream bcpgOut);
    private static void EncodeLengthAndData(BcpgOutputStream pOut, Byte[] data);
    private static Byte[] GetEncodedSubpackets(SignatureSubpacket[] ps);
    private void setCreationTime();
    public static SignaturePacket FromByteArray(Byte[] data);
}
public class Org.BouncyCastle.Bcpg.SignatureSubpacket : object {
    private SignatureSubpacketTag type;
    private bool critical;
    private bool isLongLength;
    internal Byte[] data;
    public SignatureSubpacketTag SubpacketType { get; }
    protected internal SignatureSubpacket(SignatureSubpacketTag type, bool critical, bool isLongLength, Byte[] data);
    public SignatureSubpacketTag get_SubpacketType();
    public bool IsCritical();
    public bool IsLongLength();
    public Byte[] GetData();
    public void Encode(Stream os);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Org.BouncyCastle.Bcpg.SignatureSubpacketsParser : object {
    private Stream input;
    public SignatureSubpacketsParser(Stream input);
    public SignatureSubpacket ReadPacket();
    private Byte[] CheckData(Byte[] data, int expected, int bytesRead, string name);
}
public enum Org.BouncyCastle.Bcpg.SignatureSubpacketTag : Enum {
    public int value__;
    public static SignatureSubpacketTag CreationTime;
    public static SignatureSubpacketTag ExpireTime;
    public static SignatureSubpacketTag Exportable;
    public static SignatureSubpacketTag TrustSig;
    public static SignatureSubpacketTag RegExp;
    public static SignatureSubpacketTag Revocable;
    public static SignatureSubpacketTag KeyExpireTime;
    public static SignatureSubpacketTag Placeholder;
    public static SignatureSubpacketTag PreferredSymmetricAlgorithms;
    public static SignatureSubpacketTag RevocationKey;
    public static SignatureSubpacketTag IssuerKeyId;
    public static SignatureSubpacketTag NotationData;
    public static SignatureSubpacketTag PreferredHashAlgorithms;
    public static SignatureSubpacketTag PreferredCompressionAlgorithms;
    public static SignatureSubpacketTag KeyServerPreferences;
    public static SignatureSubpacketTag PreferredKeyServer;
    public static SignatureSubpacketTag PrimaryUserId;
    public static SignatureSubpacketTag PolicyUrl;
    public static SignatureSubpacketTag KeyFlags;
    public static SignatureSubpacketTag SignerUserId;
    public static SignatureSubpacketTag RevocationReason;
    public static SignatureSubpacketTag Features;
    public static SignatureSubpacketTag SignatureTarget;
    public static SignatureSubpacketTag EmbeddedSignature;
}
public class Org.BouncyCastle.Bcpg.SymmetricEncDataPacket : InputStreamPacket {
    public SymmetricEncDataPacket(BcpgInputStream bcpgIn);
}
public class Org.BouncyCastle.Bcpg.SymmetricEncIntegrityPacket : InputStreamPacket {
    internal int version;
    internal SymmetricEncIntegrityPacket(BcpgInputStream bcpgIn);
}
public enum Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag : Enum {
    public int value__;
    public static SymmetricKeyAlgorithmTag Null;
    public static SymmetricKeyAlgorithmTag Idea;
    public static SymmetricKeyAlgorithmTag TripleDes;
    public static SymmetricKeyAlgorithmTag Cast5;
    public static SymmetricKeyAlgorithmTag Blowfish;
    public static SymmetricKeyAlgorithmTag Safer;
    public static SymmetricKeyAlgorithmTag Des;
    public static SymmetricKeyAlgorithmTag Aes128;
    public static SymmetricKeyAlgorithmTag Aes192;
    public static SymmetricKeyAlgorithmTag Aes256;
    public static SymmetricKeyAlgorithmTag Twofish;
    public static SymmetricKeyAlgorithmTag Camellia128;
    public static SymmetricKeyAlgorithmTag Camellia192;
    public static SymmetricKeyAlgorithmTag Camellia256;
}
public class Org.BouncyCastle.Bcpg.SymmetricKeyEncSessionPacket : ContainedPacket {
    private int version;
    private SymmetricKeyAlgorithmTag encAlgorithm;
    private S2k s2k;
    private Byte[] secKeyData;
    public SymmetricKeyAlgorithmTag EncAlgorithm { get; }
    public S2k S2k { get; }
    public int Version { get; }
    public SymmetricKeyEncSessionPacket(BcpgInputStream bcpgIn);
    public SymmetricKeyEncSessionPacket(SymmetricKeyAlgorithmTag encAlgorithm, S2k s2k, Byte[] secKeyData);
    public SymmetricKeyAlgorithmTag get_EncAlgorithm();
    public S2k get_S2k();
    public Byte[] GetSecKeyData();
    public int get_Version();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.TrustPacket : ContainedPacket {
    private Byte[] levelAndTrustAmount;
    public TrustPacket(BcpgInputStream bcpgIn);
    public TrustPacket(int trustCode);
    public Byte[] GetLevelAndTrustAmount();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.UnsupportedPacketVersionException : Exception {
    public UnsupportedPacketVersionException(string msg);
}
public class Org.BouncyCastle.Bcpg.UserAttributePacket : ContainedPacket {
    private UserAttributeSubpacket[] subpackets;
    public UserAttributePacket(BcpgInputStream bcpgIn);
    public UserAttributePacket(UserAttributeSubpacket[] subpackets);
    public UserAttributeSubpacket[] GetSubpackets();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.UserAttributeSubpacket : object {
    internal UserAttributeSubpacketTag type;
    private bool longLength;
    protected Byte[] data;
    public UserAttributeSubpacketTag SubpacketType { get; }
    protected internal UserAttributeSubpacket(UserAttributeSubpacketTag type, Byte[] data);
    protected internal UserAttributeSubpacket(UserAttributeSubpacketTag type, bool forceLongLength, Byte[] data);
    public virtual UserAttributeSubpacketTag get_SubpacketType();
    public virtual Byte[] GetData();
    public virtual void Encode(Stream os);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Bcpg.UserAttributeSubpacketsParser : object {
    private Stream input;
    public UserAttributeSubpacketsParser(Stream input);
    public virtual UserAttributeSubpacket ReadPacket();
}
public enum Org.BouncyCastle.Bcpg.UserAttributeSubpacketTag : Enum {
    public int value__;
    public static UserAttributeSubpacketTag ImageAttribute;
}
public class Org.BouncyCastle.Bcpg.UserIdPacket : ContainedPacket {
    private Byte[] idData;
    public UserIdPacket(BcpgInputStream bcpgIn);
    public UserIdPacket(string id);
    public string GetId();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Cmp.CertificateConfirmationContent : object {
    private DefaultDigestAlgorithmIdentifierFinder digestAlgFinder;
    private CertConfirmContent content;
    public CertificateConfirmationContent(CertConfirmContent content);
    public CertificateConfirmationContent(CertConfirmContent content, DefaultDigestAlgorithmIdentifierFinder digestAlgFinder);
    public CertConfirmContent ToAsn1Structure();
    public CertificateStatus[] GetStatusMessages();
}
public class Org.BouncyCastle.Cmp.CertificateConfirmationContentBuilder : object {
    private static DefaultSignatureAlgorithmIdentifierFinder sigAlgFinder;
    private DefaultDigestAlgorithmIdentifierFinder digestAlgFinder;
    private IList acceptedCerts;
    private IList acceptedReqIds;
    public CertificateConfirmationContentBuilder(DefaultDigestAlgorithmIdentifierFinder digestAlgFinder);
    private static CertificateConfirmationContentBuilder();
    public CertificateConfirmationContentBuilder AddAcceptedCertificate(X509Certificate certHolder, BigInteger certReqId);
    public CertificateConfirmationContent Build();
}
public class Org.BouncyCastle.Cmp.CertificateStatus : object {
    private static DefaultSignatureAlgorithmIdentifierFinder sigAlgFinder;
    private DefaultDigestAlgorithmIdentifierFinder digestAlgFinder;
    private CertStatus certStatus;
    public PkiStatusInfo PkiStatusInfo { get; }
    public BigInteger CertRequestId { get; }
    public CertificateStatus(DefaultDigestAlgorithmIdentifierFinder digestAlgFinder, CertStatus certStatus);
    private static CertificateStatus();
    public PkiStatusInfo get_PkiStatusInfo();
    public BigInteger get_CertRequestId();
    public bool IsVerified(X509Certificate cert);
}
public class Org.BouncyCastle.Cmp.CmpException : Exception {
    public CmpException(string message);
    public CmpException(string message, Exception innerException);
}
public class Org.BouncyCastle.Cmp.GeneralPkiMessage : object {
    private PkiMessage pkiMessage;
    public PkiHeader Header { get; }
    public PkiBody Body { get; }
    public bool HasProtection { get; }
    public GeneralPkiMessage(PkiMessage pkiMessage);
    public GeneralPkiMessage(Byte[] encoding);
    private static PkiMessage ParseBytes(Byte[] encoding);
    public PkiHeader get_Header();
    public PkiBody get_Body();
    public bool get_HasProtection();
    public PkiMessage ToAsn1Structure();
}
public class Org.BouncyCastle.Cmp.ProtectedPkiMessage : object {
    private PkiMessage pkiMessage;
    public PkiHeader Header { get; }
    public PkiBody Body { get; }
    public bool HasPasswordBasedMacProtected { get; }
    public ProtectedPkiMessage(GeneralPkiMessage pkiMessage);
    public ProtectedPkiMessage(PkiMessage pkiMessage);
    public PkiHeader get_Header();
    public PkiBody get_Body();
    public PkiMessage ToAsn1Message();
    public bool get_HasPasswordBasedMacProtected();
    public X509Certificate[] GetCertificates();
    public bool Verify(IVerifierFactory verifierFactory);
    private object Process(IStreamCalculator streamCalculator);
    public bool Verify(PKMacBuilder pkMacBuilder, Char[] password);
}
public class Org.BouncyCastle.Cmp.ProtectedPkiMessageBuilder : object {
    private PkiHeaderBuilder hdrBuilBuilder;
    private PkiBody body;
    private IList generalInfos;
    private IList extraCerts;
    public ProtectedPkiMessageBuilder(GeneralName sender, GeneralName recipient);
    public ProtectedPkiMessageBuilder(int pvno, GeneralName sender, GeneralName recipient);
    public ProtectedPkiMessageBuilder SetTransactionId(Byte[] tid);
    public ProtectedPkiMessageBuilder SetFreeText(PkiFreeText freeText);
    public ProtectedPkiMessageBuilder AddGeneralInfo(InfoTypeAndValue genInfo);
    public ProtectedPkiMessageBuilder SetMessageTime(DerGeneralizedTime generalizedTime);
    public ProtectedPkiMessageBuilder SetRecipKID(Byte[] id);
    public ProtectedPkiMessageBuilder SetRecipNonce(Byte[] nonce);
    public ProtectedPkiMessageBuilder SetSenderKID(Byte[] id);
    public ProtectedPkiMessageBuilder SetSenderNonce(Byte[] nonce);
    public ProtectedPkiMessageBuilder SetBody(PkiBody body);
    public ProtectedPkiMessageBuilder AddCmpCertificate(X509Certificate certificate);
    public ProtectedPkiMessage Build(ISignatureFactory signatureFactory);
    public ProtectedPkiMessage Build(IMacFactory factory);
    private void FinalizeHeader(AlgorithmIdentifier algorithmIdentifier);
    private ProtectedPkiMessage FinalizeMessage(PkiHeader header, DerBitString protection);
    private Byte[] CalculateSignature(IStreamCalculator signer, PkiHeader header, PkiBody body);
}
public class Org.BouncyCastle.Cmp.RevocationDetails : object {
    private RevDetails revDetails;
    public X509Name Subject { get; }
    public X509Name Issuer { get; }
    public BigInteger SerialNumber { get; }
    public RevocationDetails(RevDetails revDetails);
    public X509Name get_Subject();
    public X509Name get_Issuer();
    public BigInteger get_SerialNumber();
    public RevDetails ToASN1Structure();
}
public class Org.BouncyCastle.Cmp.RevocationDetailsBuilder : object {
    private CertTemplateBuilder _templateBuilder;
    public RevocationDetailsBuilder SetPublicKey(SubjectPublicKeyInfo publicKey);
    public RevocationDetailsBuilder SetIssuer(X509Name issuer);
    public RevocationDetailsBuilder SetSerialNumber(BigInteger serialNumber);
    public RevocationDetailsBuilder SetSubject(X509Name subject);
    public RevocationDetails Build();
}
internal class Org.BouncyCastle.Cms.BaseDigestCalculator : object {
    private Byte[] digest;
    internal BaseDigestCalculator(Byte[] digest);
    public sealed virtual Byte[] GetDigest();
}
public class Org.BouncyCastle.Cms.CmsAttributeTableGenerationException : CmsException {
    public CmsAttributeTableGenerationException(string name);
    public CmsAttributeTableGenerationException(string name, Exception e);
}
public interface Org.BouncyCastle.Cms.CmsAttributeTableGenerator {
    public abstract virtual AttributeTable GetAttributes(IDictionary parameters);
}
public enum Org.BouncyCastle.Cms.CmsAttributeTableParameter : Enum {
    public int value__;
    public static CmsAttributeTableParameter ContentType;
    public static CmsAttributeTableParameter Digest;
    public static CmsAttributeTableParameter Signature;
    public static CmsAttributeTableParameter DigestAlgorithmIdentifier;
}
public class Org.BouncyCastle.Cms.CmsAuthenticatedData : object {
    internal RecipientInformationStore recipientInfoStore;
    internal ContentInfo contentInfo;
    private AlgorithmIdentifier macAlg;
    private Asn1Set authAttrs;
    private Asn1Set unauthAttrs;
    private Byte[] mac;
    public AlgorithmIdentifier MacAlgorithmID { get; }
    public string MacAlgOid { get; }
    public ContentInfo ContentInfo { get; }
    public CmsAuthenticatedData(Byte[] authData);
    public CmsAuthenticatedData(Stream authData);
    public CmsAuthenticatedData(ContentInfo contentInfo);
    public Byte[] GetMac();
    public AlgorithmIdentifier get_MacAlgorithmID();
    public string get_MacAlgOid();
    public RecipientInformationStore GetRecipientInfos();
    public ContentInfo get_ContentInfo();
    public AttributeTable GetAuthAttrs();
    public AttributeTable GetUnauthAttrs();
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Cms.CmsAuthenticatedDataGenerator : CmsAuthenticatedGenerator {
    public CmsAuthenticatedDataGenerator(SecureRandom rand);
    private CmsAuthenticatedData Generate(CmsProcessable content, string macOid, CipherKeyGenerator keyGen);
    public CmsAuthenticatedData Generate(CmsProcessable content, string encryptionOid);
}
public class Org.BouncyCastle.Cms.CmsAuthenticatedDataParser : CmsContentInfoParser {
    internal RecipientInformationStore _recipientInfoStore;
    internal AuthenticatedDataParser authData;
    private AlgorithmIdentifier macAlg;
    private Byte[] mac;
    private AttributeTable authAttrs;
    private AttributeTable unauthAttrs;
    private bool authAttrNotRead;
    private bool unauthAttrNotRead;
    public AlgorithmIdentifier MacAlgorithmID { get; }
    public string MacAlgOid { get; }
    public Asn1Object MacAlgParams { get; }
    public CmsAuthenticatedDataParser(Byte[] envelopedData);
    public CmsAuthenticatedDataParser(Stream envelopedData);
    public AlgorithmIdentifier get_MacAlgorithmID();
    public string get_MacAlgOid();
    public Asn1Object get_MacAlgParams();
    public RecipientInformationStore GetRecipientInfos();
    public Byte[] GetMac();
    public AttributeTable GetAuthAttrs();
    public AttributeTable GetUnauthAttrs();
}
public class Org.BouncyCastle.Cms.CmsAuthenticatedDataStreamGenerator : CmsAuthenticatedGenerator {
    private int _bufferSize;
    private bool _berEncodeRecipientSet;
    public CmsAuthenticatedDataStreamGenerator(SecureRandom rand);
    public void SetBufferSize(int bufferSize);
    public void SetBerEncodeRecipients(bool berEncodeRecipientSet);
    private Stream Open(Stream outStr, string macOid, CipherKeyGenerator keyGen);
    protected Stream Open(Stream outStr, AlgorithmIdentifier macAlgId, ICipherParameters cipherParameters, Asn1EncodableVector recipientInfos);
    public Stream Open(Stream outStr, string encryptionOid);
    public Stream Open(Stream outStr, string encryptionOid, int keySize);
}
public class Org.BouncyCastle.Cms.CmsAuthenticatedGenerator : CmsEnvelopedGenerator {
    public CmsAuthenticatedGenerator(SecureRandom rand);
}
internal class Org.BouncyCastle.Cms.CmsAuthEnvelopedData : object {
    internal RecipientInformationStore recipientInfoStore;
    internal ContentInfo contentInfo;
    private OriginatorInfo originator;
    private AlgorithmIdentifier authEncAlg;
    private Asn1Set authAttrs;
    private Byte[] mac;
    private Asn1Set unauthAttrs;
    public CmsAuthEnvelopedData(Byte[] authEnvData);
    public CmsAuthEnvelopedData(Stream authEnvData);
    public CmsAuthEnvelopedData(ContentInfo contentInfo);
}
internal class Org.BouncyCastle.Cms.CmsAuthEnvelopedGenerator : object {
    public static string Aes128Ccm;
    public static string Aes192Ccm;
    public static string Aes256Ccm;
    public static string Aes128Gcm;
    public static string Aes192Gcm;
    public static string Aes256Gcm;
    private static CmsAuthEnvelopedGenerator();
}
public class Org.BouncyCastle.Cms.CmsCompressedData : object {
    internal ContentInfo contentInfo;
    public ContentInfo ContentInfo { get; }
    public CmsCompressedData(Byte[] compressedData);
    public CmsCompressedData(Stream compressedDataStream);
    public CmsCompressedData(ContentInfo contentInfo);
    public Byte[] GetContent();
    public Byte[] GetContent(int limit);
    public ContentInfo get_ContentInfo();
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Cms.CmsCompressedDataGenerator : object {
    public static string ZLib;
    public CmsCompressedData Generate(CmsProcessable content, string compressionOid);
}
public class Org.BouncyCastle.Cms.CmsCompressedDataParser : CmsContentInfoParser {
    public CmsCompressedDataParser(Byte[] compressedData);
    public CmsCompressedDataParser(Stream compressedData);
    public CmsTypedStream GetContent();
}
public class Org.BouncyCastle.Cms.CmsCompressedDataStreamGenerator : object {
    public static string ZLib;
    private int _bufferSize;
    public void SetBufferSize(int bufferSize);
    public Stream Open(Stream outStream, string compressionOID);
    public Stream Open(Stream outStream, string contentOID, string compressionOID);
}
public class Org.BouncyCastle.Cms.CmsContentInfoParser : object {
    protected ContentInfoParser contentInfo;
    protected Stream data;
    protected CmsContentInfoParser(Stream data);
    public void Close();
}
public class Org.BouncyCastle.Cms.CmsEnvelopedData : object {
    internal RecipientInformationStore recipientInfoStore;
    internal ContentInfo contentInfo;
    private AlgorithmIdentifier encAlg;
    private Asn1Set unprotectedAttributes;
    public AlgorithmIdentifier EncryptionAlgorithmID { get; }
    public string EncryptionAlgOid { get; }
    public ContentInfo ContentInfo { get; }
    public CmsEnvelopedData(Byte[] envelopedData);
    public CmsEnvelopedData(Stream envelopedData);
    public CmsEnvelopedData(ContentInfo contentInfo);
    public AlgorithmIdentifier get_EncryptionAlgorithmID();
    public string get_EncryptionAlgOid();
    public RecipientInformationStore GetRecipientInfos();
    public ContentInfo get_ContentInfo();
    public AttributeTable GetUnprotectedAttributes();
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Cms.CmsEnvelopedDataGenerator : CmsEnvelopedGenerator {
    public CmsEnvelopedDataGenerator(SecureRandom rand);
    private CmsEnvelopedData Generate(CmsProcessable content, string encryptionOid, CipherKeyGenerator keyGen);
    public CmsEnvelopedData Generate(CmsProcessable content, string encryptionOid);
    public CmsEnvelopedData Generate(CmsProcessable content, ICipherBuilderWithKey cipherBuilder);
    public CmsEnvelopedData Generate(CmsProcessable content, string encryptionOid, int keySize);
}
public class Org.BouncyCastle.Cms.CmsEnvelopedDataParser : CmsContentInfoParser {
    internal RecipientInformationStore recipientInfoStore;
    internal EnvelopedDataParser envelopedData;
    private AlgorithmIdentifier _encAlg;
    private AttributeTable _unprotectedAttributes;
    private bool _attrNotRead;
    public AlgorithmIdentifier EncryptionAlgorithmID { get; }
    public string EncryptionAlgOid { get; }
    public Asn1Object EncryptionAlgParams { get; }
    public CmsEnvelopedDataParser(Byte[] envelopedData);
    public CmsEnvelopedDataParser(Stream envelopedData);
    public AlgorithmIdentifier get_EncryptionAlgorithmID();
    public string get_EncryptionAlgOid();
    public Asn1Object get_EncryptionAlgParams();
    public RecipientInformationStore GetRecipientInfos();
    public AttributeTable GetUnprotectedAttributes();
}
public class Org.BouncyCastle.Cms.CmsEnvelopedDataStreamGenerator : CmsEnvelopedGenerator {
    private object _originatorInfo;
    private object _unprotectedAttributes;
    private int _bufferSize;
    private bool _berEncodeRecipientSet;
    private DerInteger Version { get; }
    public CmsEnvelopedDataStreamGenerator(SecureRandom rand);
    public void SetBufferSize(int bufferSize);
    public void SetBerEncodeRecipients(bool berEncodeRecipientSet);
    private DerInteger get_Version();
    private Stream Open(Stream outStream, string encryptionOid, CipherKeyGenerator keyGen);
    private Stream Open(Stream outStream, AlgorithmIdentifier encAlgID, ICipherParameters cipherParameters, Asn1EncodableVector recipientInfos);
    public Stream Open(Stream outStream, string encryptionOid);
    public Stream Open(Stream outStream, string encryptionOid, int keySize);
}
public class Org.BouncyCastle.Cms.CmsEnvelopedGenerator : object {
    internal static Int16[] rc2Table;
    public static string DesEde3Cbc;
    public static string RC2Cbc;
    public static string IdeaCbc;
    public static string Cast5Cbc;
    public static string Aes128Cbc;
    public static string Aes192Cbc;
    public static string Aes256Cbc;
    public static string Camellia128Cbc;
    public static string Camellia192Cbc;
    public static string Camellia256Cbc;
    public static string SeedCbc;
    public static string DesEde3Wrap;
    public static string Aes128Wrap;
    public static string Aes192Wrap;
    public static string Aes256Wrap;
    public static string Camellia128Wrap;
    public static string Camellia192Wrap;
    public static string Camellia256Wrap;
    public static string SeedWrap;
    public static string ECDHSha1Kdf;
    public static string ECMqvSha1Kdf;
    internal IList recipientInfoGenerators;
    internal SecureRandom rand;
    internal CmsAttributeTableGenerator unprotectedAttributeGenerator;
    public CmsAttributeTableGenerator UnprotectedAttributeGenerator { get; public set; }
    public CmsEnvelopedGenerator(SecureRandom rand);
    private static CmsEnvelopedGenerator();
    public CmsAttributeTableGenerator get_UnprotectedAttributeGenerator();
    public void set_UnprotectedAttributeGenerator(CmsAttributeTableGenerator value);
    public void AddKeyTransRecipient(X509Certificate cert);
    public void AddKeyTransRecipient(AsymmetricKeyParameter pubKey, Byte[] subKeyId);
    public void AddKekRecipient(string keyAlgorithm, KeyParameter key, Byte[] keyIdentifier);
    public void AddKekRecipient(string keyAlgorithm, KeyParameter key, KekIdentifier kekIdentifier);
    public void AddPasswordRecipient(CmsPbeKey pbeKey, string kekAlgorithmOid);
    public void AddKeyAgreementRecipient(string agreementAlgorithm, AsymmetricKeyParameter senderPrivateKey, AsymmetricKeyParameter senderPublicKey, X509Certificate recipientCert, string cekWrapAlgorithm);
    public void AddKeyAgreementRecipients(string agreementAlgorithm, AsymmetricKeyParameter senderPrivateKey, AsymmetricKeyParameter senderPublicKey, ICollection recipientCerts, string cekWrapAlgorithm);
    public void AddRecipientInfoGenerator(RecipientInfoGenerator recipientInfoGenerator);
    protected internal virtual AlgorithmIdentifier GetAlgorithmIdentifier(string encryptionOid, KeyParameter encKey, Asn1Encodable asn1Params, ICipherParameters& cipherParameters);
    protected internal virtual Asn1Encodable GenerateAsn1Parameters(string encryptionOid, Byte[] encKeyBytes);
}
internal class Org.BouncyCastle.Cms.CmsEnvelopedHelper : object {
    internal static CmsEnvelopedHelper Instance;
    private static IDictionary KeySizes;
    private static IDictionary BaseCipherNames;
    private static CmsEnvelopedHelper();
    private string GetAsymmetricEncryptionAlgName(string encryptionAlgOid);
    internal IBufferedCipher CreateAsymmetricCipher(string encryptionOid);
    internal IWrapper CreateWrapper(string encryptionOid);
    internal string GetRfc3211WrapperName(string oid);
    internal int GetKeySize(string oid);
    internal static RecipientInformationStore BuildRecipientInformationStore(Asn1Set recipientInfos, CmsSecureReadable secureReadable);
    private static void ReadRecipientInfo(IList infos, RecipientInfo info, CmsSecureReadable secureReadable);
}
public class Org.BouncyCastle.Cms.CmsException : Exception {
    public CmsException(string msg);
    public CmsException(string msg, Exception e);
}
public abstract class Org.BouncyCastle.Cms.CmsPbeKey : object {
    internal Char[] password;
    internal Byte[] salt;
    internal int iterationCount;
    [ObsoleteAttribute("Will be removed")]
public string Password { get; }
    public Byte[] Salt { get; }
    public int IterationCount { get; }
    public string Algorithm { get; }
    public string Format { get; }
    [ObsoleteAttribute("Use version taking 'char[]' instead")]
public CmsPbeKey(string password, Byte[] salt, int iterationCount);
    [ObsoleteAttribute("Use version taking 'char[]' instead")]
public CmsPbeKey(string password, AlgorithmIdentifier keyDerivationAlgorithm);
    public CmsPbeKey(Char[] password, Byte[] salt, int iterationCount);
    public CmsPbeKey(Char[] password, AlgorithmIdentifier keyDerivationAlgorithm);
    protected virtual override void Finalize();
    public string get_Password();
    public Byte[] get_Salt();
    [ObsoleteAttribute("Use 'Salt' property instead")]
public Byte[] GetSalt();
    public int get_IterationCount();
    public string get_Algorithm();
    public string get_Format();
    public Byte[] GetEncoded();
    internal abstract virtual KeyParameter GetEncoded(string algorithmOid);
}
public interface Org.BouncyCastle.Cms.CmsProcessable {
    public abstract virtual void Write(Stream outStream);
    [ObsoleteAttribute]
public abstract virtual object GetContent();
}
public class Org.BouncyCastle.Cms.CmsProcessableByteArray : object {
    private DerObjectIdentifier type;
    private Byte[] bytes;
    public DerObjectIdentifier Type { get; }
    public CmsProcessableByteArray(Byte[] bytes);
    public CmsProcessableByteArray(DerObjectIdentifier type, Byte[] bytes);
    public DerObjectIdentifier get_Type();
    public virtual Stream GetInputStream();
    public virtual void Write(Stream zOut);
    [ObsoleteAttribute]
public virtual object GetContent();
}
public class Org.BouncyCastle.Cms.CmsProcessableFile : object {
    private static int DefaultBufSize;
    private FileInfo _file;
    private int _bufSize;
    public CmsProcessableFile(FileInfo file);
    public CmsProcessableFile(FileInfo file, int bufSize);
    public virtual Stream GetInputStream();
    public virtual void Write(Stream zOut);
    [ObsoleteAttribute]
public virtual object GetContent();
}
public class Org.BouncyCastle.Cms.CmsProcessableInputStream : object {
    private Stream input;
    private bool used;
    public CmsProcessableInputStream(Stream input);
    public virtual Stream GetInputStream();
    public virtual void Write(Stream output);
    [ObsoleteAttribute]
public virtual object GetContent();
    protected virtual void CheckSingleUsage();
}
public interface Org.BouncyCastle.Cms.CmsReadable {
    public abstract virtual Stream GetInputStream();
}
internal interface Org.BouncyCastle.Cms.CmsSecureReadable {
    public AlgorithmIdentifier Algorithm { get; }
    public object CryptoObject { get; }
    public abstract virtual AlgorithmIdentifier get_Algorithm();
    public abstract virtual object get_CryptoObject();
    public abstract virtual CmsReadable GetReadable(KeyParameter key);
}
public class Org.BouncyCastle.Cms.CmsSignedData : object {
    private static CmsSignedHelper Helper;
    private CmsProcessable signedContent;
    private SignedData signedData;
    private ContentInfo contentInfo;
    private SignerInformationStore signerInfoStore;
    private IX509Store attrCertStore;
    private IX509Store certificateStore;
    private IX509Store crlStore;
    private IDictionary hashes;
    public int Version { get; }
    [ObsoleteAttribute("Use 'SignedContentType' property instead.")]
public string SignedContentTypeOid { get; }
    public DerObjectIdentifier SignedContentType { get; }
    public CmsProcessable SignedContent { get; }
    public ContentInfo ContentInfo { get; }
    private CmsSignedData(CmsSignedData c);
    public CmsSignedData(Byte[] sigBlock);
    public CmsSignedData(CmsProcessable signedContent, Byte[] sigBlock);
    public CmsSignedData(IDictionary hashes, Byte[] sigBlock);
    public CmsSignedData(CmsProcessable signedContent, Stream sigData);
    public CmsSignedData(Stream sigData);
    public CmsSignedData(CmsProcessable signedContent, ContentInfo sigData);
    public CmsSignedData(IDictionary hashes, ContentInfo sigData);
    public CmsSignedData(ContentInfo sigData);
    private static CmsSignedData();
    public int get_Version();
    internal IX509Store GetCertificates();
    public SignerInformationStore GetSignerInfos();
    public IX509Store GetAttributeCertificates(string type);
    public IX509Store GetCertificates(string type);
    public IX509Store GetCrls(string type);
    public string get_SignedContentTypeOid();
    public DerObjectIdentifier get_SignedContentType();
    public CmsProcessable get_SignedContent();
    public ContentInfo get_ContentInfo();
    public Byte[] GetEncoded();
    public Byte[] GetEncoded(string encoding);
    public static CmsSignedData ReplaceSigners(CmsSignedData signedData, SignerInformationStore signerInformationStore);
    public static CmsSignedData ReplaceCertificatesAndCrls(CmsSignedData signedData, IX509Store x509Certs, IX509Store x509Crls, IX509Store x509AttrCerts);
}
public class Org.BouncyCastle.Cms.CmsSignedDataGenerator : CmsSignedGenerator {
    private static CmsSignedHelper Helper;
    private IList signerInfs;
    public CmsSignedDataGenerator(SecureRandom rand);
    private static CmsSignedDataGenerator();
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string digestOID);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string encryptionOID, string digestOID);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string digestOID);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string encryptionOID, string digestOID);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string digestOID, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string encryptionOID, string digestOID, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string digestOID, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string encryptionOID, string digestOID, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string digestOID, CmsAttributeTableGenerator signedAttrGen, CmsAttributeTableGenerator unsignedAttrGen);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string encryptionOID, string digestOID, CmsAttributeTableGenerator signedAttrGen, CmsAttributeTableGenerator unsignedAttrGen);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string digestOID, CmsAttributeTableGenerator signedAttrGen, CmsAttributeTableGenerator unsignedAttrGen);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string encryptionOID, string digestOID, CmsAttributeTableGenerator signedAttrGen, CmsAttributeTableGenerator unsignedAttrGen);
    public void AddSignerInfoGenerator(SignerInfoGenerator signerInfoGenerator);
    private void doAddSigner(AsymmetricKeyParameter privateKey, SignerIdentifier signerIdentifier, string encryptionOID, string digestOID, CmsAttributeTableGenerator signedAttrGen, CmsAttributeTableGenerator unsignedAttrGen, AttributeTable baseSignedTable);
    public CmsSignedData Generate(CmsProcessable content);
    public CmsSignedData Generate(string signedContentType, CmsProcessable content, bool encapsulate);
    public CmsSignedData Generate(CmsProcessable content, bool encapsulate);
    public SignerInformationStore GenerateCounterSigners(SignerInformation signer);
}
public class Org.BouncyCastle.Cms.CmsSignedDataParser : CmsContentInfoParser {
    private static CmsSignedHelper Helper;
    private SignedDataParser _signedData;
    private DerObjectIdentifier _signedContentType;
    private CmsTypedStream _signedContent;
    private IDictionary _digests;
    private ISet _digestOids;
    private SignerInformationStore _signerInfoStore;
    private Asn1Set _certSet;
    private Asn1Set _crlSet;
    private bool _isCertCrlParsed;
    private IX509Store _attributeStore;
    private IX509Store _certificateStore;
    private IX509Store _crlStore;
    public int Version { get; }
    public ISet DigestOids { get; }
    public DerObjectIdentifier SignedContentType { get; }
    public CmsSignedDataParser(Byte[] sigBlock);
    public CmsSignedDataParser(CmsTypedStream signedContent, Byte[] sigBlock);
    public CmsSignedDataParser(Stream sigData);
    public CmsSignedDataParser(CmsTypedStream signedContent, Stream sigData);
    private static CmsSignedDataParser();
    public int get_Version();
    public ISet get_DigestOids();
    public SignerInformationStore GetSignerInfos();
    public IX509Store GetAttributeCertificates(string type);
    public IX509Store GetCertificates(string type);
    public IX509Store GetCrls(string type);
    private void PopulateCertCrlSets();
    public DerObjectIdentifier get_SignedContentType();
    public CmsTypedStream GetSignedContent();
    public static Stream ReplaceSigners(Stream original, SignerInformationStore signerInformationStore, Stream outStr);
    public static Stream ReplaceCertificatesAndCrls(Stream original, IX509Store x509Certs, IX509Store x509Crls, IX509Store x509AttrCerts, Stream outStr);
    private static Asn1Set GetAsn1Set(Asn1SetParser asn1SetParser);
}
public class Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator : CmsSignedGenerator {
    private static CmsSignedHelper Helper;
    private IList _signerInfs;
    private ISet _messageDigestOids;
    private IDictionary _messageDigests;
    private IDictionary _messageHashes;
    private bool _messageDigestsLocked;
    private int _bufferSize;
    public CmsSignedDataStreamGenerator(SecureRandom rand);
    private static CmsSignedDataStreamGenerator();
    public void SetBufferSize(int bufferSize);
    public void AddDigests(String[] digestOids);
    public void AddDigests(IEnumerable digestOids);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string digestOid);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string encryptionOid, string digestOid);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string digestOid, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string encryptionOid, string digestOid, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string digestOid, CmsAttributeTableGenerator signedAttrGenerator, CmsAttributeTableGenerator unsignedAttrGenerator);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string encryptionOid, string digestOid, CmsAttributeTableGenerator signedAttrGenerator, CmsAttributeTableGenerator unsignedAttrGenerator);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string digestOid);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string encryptionOid, string digestOid);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string digestOid, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string digestOid, CmsAttributeTableGenerator signedAttrGenerator, CmsAttributeTableGenerator unsignedAttrGenerator);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string encryptionOid, string digestOid, CmsAttributeTableGenerator signedAttrGenerator, CmsAttributeTableGenerator unsignedAttrGenerator);
    private void DoAddSigner(AsymmetricKeyParameter privateKey, SignerIdentifier signerIdentifier, string encryptionOid, string digestOid, CmsAttributeTableGenerator signedAttrGenerator, CmsAttributeTableGenerator unsignedAttrGenerator);
    internal virtual void AddSignerCallback(SignerInformation si);
    public Stream Open(Stream outStream);
    public Stream Open(Stream outStream, bool encapsulate);
    public Stream Open(Stream outStream, bool encapsulate, Stream dataOutputStream);
    public Stream Open(Stream outStream, string signedContentType, bool encapsulate);
    public Stream Open(Stream outStream, string signedContentType, bool encapsulate, Stream dataOutputStream);
    private void RegisterDigestOid(string digestOid);
    private void ConfigureDigest(string digestOid);
    internal void Generate(Stream outStream, string eContentType, bool encapsulate, Stream dataOutputStream, CmsProcessable content);
    private DerInteger CalculateVersion(DerObjectIdentifier contentOid);
    private bool CheckForVersion3(IList signerInfos);
    private static Stream AttachDigestsToOutputStream(ICollection digests, Stream s);
    private static Stream GetSafeOutputStream(Stream s);
    private static Stream GetSafeTeeOutputStream(Stream s1, Stream s2);
}
public class Org.BouncyCastle.Cms.CmsSignedGenerator : object {
    public static string Data;
    public static string DigestSha1;
    public static string DigestSha224;
    public static string DigestSha256;
    public static string DigestSha384;
    public static string DigestSha512;
    public static string DigestSha512_224;
    public static string DigestSha512_256;
    public static string DigestMD5;
    public static string DigestGost3411;
    public static string DigestRipeMD128;
    public static string DigestRipeMD160;
    public static string DigestRipeMD256;
    public static string EncryptionRsa;
    public static string EncryptionDsa;
    public static string EncryptionECDsa;
    public static string EncryptionRsaPss;
    public static string EncryptionGost3410;
    public static string EncryptionECGost3410;
    internal IList _certs;
    internal IList _crls;
    internal IList _signers;
    internal IDictionary _digests;
    internal bool _useDerForCerts;
    internal bool _useDerForCrls;
    protected SecureRandom rand;
    public bool UseDerForCerts { get; public set; }
    public bool UseDerForCrls { get; public set; }
    protected CmsSignedGenerator(SecureRandom rand);
    private static CmsSignedGenerator();
    protected internal virtual IDictionary GetBaseParameters(DerObjectIdentifier contentType, AlgorithmIdentifier digAlgId, Byte[] hash);
    protected internal virtual Asn1Set GetAttributeSet(AttributeTable attr);
    public void AddCertificates(IX509Store certStore);
    public void AddCrls(IX509Store crlStore);
    public void AddAttributeCertificates(IX509Store store);
    public void AddSigners(SignerInformationStore signerStore);
    public IDictionary GetGeneratedDigests();
    public bool get_UseDerForCerts();
    public void set_UseDerForCerts(bool value);
    public bool get_UseDerForCrls();
    public void set_UseDerForCrls(bool value);
    internal virtual void AddSignerCallback(SignerInformation si);
    internal static SignerIdentifier GetSignerIdentifier(X509Certificate cert);
    internal static SignerIdentifier GetSignerIdentifier(Byte[] subjectKeyIdentifier);
}
internal class Org.BouncyCastle.Cms.CmsSignedHelper : object {
    internal static CmsSignedHelper Instance;
    private static string EncryptionECDsaWithSha1;
    private static string EncryptionECDsaWithSha224;
    private static string EncryptionECDsaWithSha256;
    private static string EncryptionECDsaWithSha384;
    private static string EncryptionECDsaWithSha512;
    private static IDictionary encryptionAlgs;
    private static IDictionary digestAlgs;
    private static IDictionary digestAliases;
    private static ISet noParams;
    private static IDictionary ecAlgorithms;
    private static CmsSignedHelper();
    private static void AddEntries(DerObjectIdentifier oid, string digest, string encryption);
    internal string GetDigestAlgName(string digestAlgOid);
    internal AlgorithmIdentifier GetEncAlgorithmIdentifier(DerObjectIdentifier encOid, Asn1Encodable sigX509Parameters);
    internal String[] GetDigestAliases(string algName);
    internal string GetEncryptionAlgName(string encryptionAlgOid);
    internal IDigest GetDigestInstance(string algorithm);
    internal ISigner GetSignatureInstance(string algorithm);
    internal IX509Store CreateAttributeStore(string type, Asn1Set certSet);
    internal IX509Store CreateCertificateStore(string type, Asn1Set certSet);
    internal IX509Store CreateCrlStore(string type, Asn1Set crlSet);
    private void AddCertsFromSet(IList certs, Asn1Set certSet);
    private void AddCrlsFromSet(IList crls, Asn1Set crlSet);
    internal AlgorithmIdentifier FixAlgID(AlgorithmIdentifier algId);
    internal string GetEncOid(AsymmetricKeyParameter key, string digestOID);
    public IX509Store GetCertificates(Asn1Set certificates);
}
public class Org.BouncyCastle.Cms.CmsStreamException : IOException {
    public CmsStreamException(string name);
    public CmsStreamException(string name, Exception e);
}
public class Org.BouncyCastle.Cms.CmsTypedStream : object {
    private static int BufferSize;
    private string _oid;
    private Stream _in;
    public string ContentType { get; }
    public Stream ContentStream { get; }
    public CmsTypedStream(Stream inStream);
    public CmsTypedStream(string oid, Stream inStream);
    public CmsTypedStream(string oid, Stream inStream, int bufSize);
    public string get_ContentType();
    public Stream get_ContentStream();
    public void Drain();
}
internal class Org.BouncyCastle.Cms.CmsUtilities : object {
    internal static int MaximumMemory { get; }
    internal static int get_MaximumMemory();
    internal static ContentInfo ReadContentInfo(Byte[] input);
    internal static ContentInfo ReadContentInfo(Stream input);
    private static ContentInfo ReadContentInfo(Asn1InputStream aIn);
    public static Byte[] StreamToByteArray(Stream inStream);
    public static Byte[] StreamToByteArray(Stream inStream, int limit);
    public static IList GetCertificatesFromStore(IX509Store certStore);
    public static IList GetCrlsFromStore(IX509Store crlStore);
    public static Asn1Set CreateBerSetFromList(IList berObjects);
    public static Asn1Set CreateDerSetFromList(IList derObjects);
    internal static Stream CreateBerOctetOutputStream(Stream s, int tagNo, bool isExplicit, int bufferSize);
    internal static TbsCertificateStructure GetTbsCertificateStructure(X509Certificate cert);
    internal static IssuerAndSerialNumber GetIssuerAndSerialNumber(X509Certificate cert);
}
internal class Org.BouncyCastle.Cms.CounterSignatureDigestCalculator : object {
    private string alg;
    private Byte[] data;
    internal CounterSignatureDigestCalculator(string alg, Byte[] data);
    public sealed virtual Byte[] GetDigest();
}
public class Org.BouncyCastle.Cms.DefaultAuthenticatedAttributeTableGenerator : object {
    private IDictionary table;
    public DefaultAuthenticatedAttributeTableGenerator(AttributeTable attributeTable);
    protected virtual IDictionary CreateStandardAttributeTable(IDictionary parameters);
    public virtual AttributeTable GetAttributes(IDictionary parameters);
}
public class Org.BouncyCastle.Cms.DefaultDigestAlgorithmIdentifierFinder : object {
    private static IDictionary digestOids;
    private static IDictionary digestNameToOids;
    private static DefaultDigestAlgorithmIdentifierFinder();
    public AlgorithmIdentifier find(AlgorithmIdentifier sigAlgId);
    public AlgorithmIdentifier find(string digAlgName);
}
public class Org.BouncyCastle.Cms.DefaultSignatureAlgorithmIdentifierFinder : object {
    private static IDictionary algorithms;
    private static ISet noParams;
    private static IDictionary _params;
    private static ISet pkcs15RsaEncryption;
    private static IDictionary digestOids;
    private static IDictionary digestBuilders;
    private static DerObjectIdentifier ENCRYPTION_RSA;
    private static DerObjectIdentifier ENCRYPTION_DSA;
    private static DerObjectIdentifier ENCRYPTION_ECDSA;
    private static DerObjectIdentifier ENCRYPTION_RSA_PSS;
    private static DerObjectIdentifier ENCRYPTION_GOST3410;
    private static DerObjectIdentifier ENCRYPTION_ECGOST3410;
    private static DerObjectIdentifier ENCRYPTION_ECGOST3410_2012_256;
    private static DerObjectIdentifier ENCRYPTION_ECGOST3410_2012_512;
    private static DefaultSignatureAlgorithmIdentifierFinder();
    private static AlgorithmIdentifier Generate(string signatureAlgorithm);
    private static RsassaPssParameters CreatePssParams(AlgorithmIdentifier hashAlgId, int saltSize);
    public AlgorithmIdentifier Find(string sigAlgName);
}
public class Org.BouncyCastle.Cms.DefaultSignedAttributeTableGenerator : object {
    private IDictionary table;
    public DefaultSignedAttributeTableGenerator(AttributeTable attributeTable);
    protected virtual Hashtable createStandardAttributeTable(IDictionary parameters);
    private void DoCreateStandardAttributeTable(IDictionary parameters, IDictionary std);
    public virtual AttributeTable GetAttributes(IDictionary parameters);
}
internal class Org.BouncyCastle.Cms.EnvelopedDataHelper : object {
    private static IDictionary BaseCipherNames;
    private static IDictionary MacAlgNames;
    private static EnvelopedDataHelper();
    public static object CreateContentCipher(bool forEncryption, ICipherParameters encKey, AlgorithmIdentifier encryptionAlgID);
    public AlgorithmIdentifier GenerateEncryptionAlgID(DerObjectIdentifier encryptionOID, KeyParameter encKey, SecureRandom random);
    public CipherKeyGenerator CreateKeyGenerator(DerObjectIdentifier algorithm, SecureRandom random);
}
internal interface Org.BouncyCastle.Cms.IDigestCalculator {
    public abstract virtual Byte[] GetDigest();
}
internal interface Org.BouncyCastle.Cms.ISignerInfoGenerator {
    public abstract virtual SignerInfo Generate(DerObjectIdentifier contentType, AlgorithmIdentifier digestAlgorithm, Byte[] calculatedDigest);
}
internal class Org.BouncyCastle.Cms.KekRecipientInfoGenerator : object {
    private static CmsEnvelopedHelper Helper;
    private KeyParameter keyEncryptionKey;
    private string keyEncryptionKeyOID;
    private KekIdentifier kekIdentifier;
    private AlgorithmIdentifier keyEncryptionAlgorithm;
    unknown KekIdentifier KekIdentifier {internal set; }
    unknown KeyParameter KeyEncryptionKey {internal set; }
    unknown string KeyEncryptionKeyOID {internal set; }
    private static KekRecipientInfoGenerator();
    internal void set_KekIdentifier(KekIdentifier value);
    internal void set_KeyEncryptionKey(KeyParameter value);
    internal void set_KeyEncryptionKeyOID(string value);
    public sealed virtual RecipientInfo Generate(KeyParameter contentEncryptionKey, SecureRandom random);
    private static AlgorithmIdentifier DetermineKeyEncAlg(string algorithm, KeyParameter key);
}
public class Org.BouncyCastle.Cms.KekRecipientInformation : RecipientInformation {
    private KekRecipientInfo info;
    internal KekRecipientInformation(KekRecipientInfo info, CmsSecureReadable secureReadable);
    public virtual CmsTypedStream GetContentStream(ICipherParameters key);
}
internal class Org.BouncyCastle.Cms.KeyAgreeRecipientInfoGenerator : object {
    private static CmsEnvelopedHelper Helper;
    private DerObjectIdentifier keyAgreementOID;
    private DerObjectIdentifier keyEncryptionOID;
    private IList recipientCerts;
    private AsymmetricCipherKeyPair senderKeyPair;
    unknown DerObjectIdentifier KeyAgreementOID {internal set; }
    unknown DerObjectIdentifier KeyEncryptionOID {internal set; }
    unknown ICollection RecipientCerts {internal set; }
    unknown AsymmetricCipherKeyPair SenderKeyPair {internal set; }
    private static KeyAgreeRecipientInfoGenerator();
    internal void set_KeyAgreementOID(DerObjectIdentifier value);
    internal void set_KeyEncryptionOID(DerObjectIdentifier value);
    internal void set_RecipientCerts(ICollection value);
    internal void set_SenderKeyPair(AsymmetricCipherKeyPair value);
    public sealed virtual RecipientInfo Generate(KeyParameter contentEncryptionKey, SecureRandom random);
    private static OriginatorPublicKey CreateOriginatorPublicKey(AsymmetricKeyParameter publicKey);
}
public class Org.BouncyCastle.Cms.KeyAgreeRecipientInformation : RecipientInformation {
    private KeyAgreeRecipientInfo info;
    private Asn1OctetString encryptedKey;
    internal KeyAgreeRecipientInformation(KeyAgreeRecipientInfo info, RecipientID rid, Asn1OctetString encryptedKey, CmsSecureReadable secureReadable);
    internal static void ReadRecipientInfo(IList infos, KeyAgreeRecipientInfo info, CmsSecureReadable secureReadable);
    private AsymmetricKeyParameter GetSenderPublicKey(AsymmetricKeyParameter receiverPrivateKey, OriginatorIdentifierOrKey originator);
    private AsymmetricKeyParameter GetPublicKeyFromOriginatorPublicKey(AsymmetricKeyParameter receiverPrivateKey, OriginatorPublicKey originatorPublicKey);
    private AsymmetricKeyParameter GetPublicKeyFromOriginatorID(OriginatorID origID);
    private KeyParameter CalculateAgreedWrapKey(string wrapAlg, AsymmetricKeyParameter senderPublicKey, AsymmetricKeyParameter receiverPrivateKey);
    private KeyParameter UnwrapSessionKey(string wrapAlg, KeyParameter agreedKey);
    internal KeyParameter GetSessionKey(AsymmetricKeyParameter receiverPrivateKey);
    public virtual CmsTypedStream GetContentStream(ICipherParameters key);
}
public class Org.BouncyCastle.Cms.KeyTransRecipientInfoGenerator : object {
    private static CmsEnvelopedHelper Helper;
    private Asn1OctetString subjectKeyIdentifier;
    private IKeyWrapper keyWrapper;
    private SubjectPublicKeyInfo info;
    private IssuerAndSerialNumber issuerAndSerialNumber;
    private SecureRandom random;
    protected AlgorithmIdentifier AlgorithmDetails { get; }
    public KeyTransRecipientInfoGenerator(X509Certificate recipCert, IKeyWrapper keyWrapper);
    public KeyTransRecipientInfoGenerator(IssuerAndSerialNumber issuerAndSerial, IKeyWrapper keyWrapper);
    public KeyTransRecipientInfoGenerator(Byte[] subjectKeyID, IKeyWrapper keyWrapper);
    private static KeyTransRecipientInfoGenerator();
    public sealed virtual RecipientInfo Generate(KeyParameter contentEncryptionKey, SecureRandom random);
    protected virtual AlgorithmIdentifier get_AlgorithmDetails();
    protected virtual Byte[] GenerateWrappedKey(KeyParameter contentEncryptionKey);
}
public class Org.BouncyCastle.Cms.KeyTransRecipientInformation : RecipientInformation {
    private KeyTransRecipientInfo info;
    internal KeyTransRecipientInformation(KeyTransRecipientInfo info, CmsSecureReadable secureReadable);
    private string GetExchangeEncryptionAlgorithmName(AlgorithmIdentifier algo);
    internal KeyParameter UnwrapKey(ICipherParameters key);
    public virtual CmsTypedStream GetContentStream(ICipherParameters key);
}
public class Org.BouncyCastle.Cms.OriginatorID : X509CertStoreSelector {
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Org.BouncyCastle.Cms.OriginatorInfoGenerator : object {
    private IList origCerts;
    private IList origCrls;
    public OriginatorInfoGenerator(X509Certificate origCert);
    public OriginatorInfoGenerator(IX509Store origCerts);
    public OriginatorInfoGenerator(IX509Store origCerts, IX509Store origCrls);
    public virtual OriginatorInfo Generate();
}
public class Org.BouncyCastle.Cms.OriginatorInformation : object {
    private OriginatorInfo originatorInfo;
    internal OriginatorInformation(OriginatorInfo originatorInfo);
    public virtual IX509Store GetCertificates();
    public virtual IX509Store GetCrls();
    public virtual OriginatorInfo ToAsn1Structure();
}
internal class Org.BouncyCastle.Cms.PasswordRecipientInfoGenerator : object {
    private static CmsEnvelopedHelper Helper;
    private AlgorithmIdentifier keyDerivationAlgorithm;
    private KeyParameter keyEncryptionKey;
    private string keyEncryptionKeyOID;
    unknown AlgorithmIdentifier KeyDerivationAlgorithm {internal set; }
    unknown KeyParameter KeyEncryptionKey {internal set; }
    unknown string KeyEncryptionKeyOID {internal set; }
    private static PasswordRecipientInfoGenerator();
    internal void set_KeyDerivationAlgorithm(AlgorithmIdentifier value);
    internal void set_KeyEncryptionKey(KeyParameter value);
    internal void set_KeyEncryptionKeyOID(string value);
    public sealed virtual RecipientInfo Generate(KeyParameter contentEncryptionKey, SecureRandom random);
}
public class Org.BouncyCastle.Cms.PasswordRecipientInformation : RecipientInformation {
    private PasswordRecipientInfo info;
    public AlgorithmIdentifier KeyDerivationAlgorithm { get; }
    internal PasswordRecipientInformation(PasswordRecipientInfo info, CmsSecureReadable secureReadable);
    public virtual AlgorithmIdentifier get_KeyDerivationAlgorithm();
    public virtual CmsTypedStream GetContentStream(ICipherParameters key);
}
public class Org.BouncyCastle.Cms.Pkcs5Scheme2PbeKey : CmsPbeKey {
    [ObsoleteAttribute("Use version taking 'char[]' instead")]
public Pkcs5Scheme2PbeKey(string password, Byte[] salt, int iterationCount);
    [ObsoleteAttribute("Use version taking 'char[]' instead")]
public Pkcs5Scheme2PbeKey(string password, AlgorithmIdentifier keyDerivationAlgorithm);
    public Pkcs5Scheme2PbeKey(Char[] password, Byte[] salt, int iterationCount);
    public Pkcs5Scheme2PbeKey(Char[] password, AlgorithmIdentifier keyDerivationAlgorithm);
    internal virtual KeyParameter GetEncoded(string algorithmOid);
}
public class Org.BouncyCastle.Cms.Pkcs5Scheme2Utf8PbeKey : CmsPbeKey {
    [ObsoleteAttribute("Use version taking 'char[]' instead")]
public Pkcs5Scheme2Utf8PbeKey(string password, Byte[] salt, int iterationCount);
    [ObsoleteAttribute("Use version taking 'char[]' instead")]
public Pkcs5Scheme2Utf8PbeKey(string password, AlgorithmIdentifier keyDerivationAlgorithm);
    public Pkcs5Scheme2Utf8PbeKey(Char[] password, Byte[] salt, int iterationCount);
    public Pkcs5Scheme2Utf8PbeKey(Char[] password, AlgorithmIdentifier keyDerivationAlgorithm);
    internal virtual KeyParameter GetEncoded(string algorithmOid);
}
public class Org.BouncyCastle.Cms.RecipientID : X509CertStoreSelector {
    private Byte[] keyIdentifier;
    public Byte[] KeyIdentifier { get; public set; }
    public Byte[] get_KeyIdentifier();
    public void set_KeyIdentifier(Byte[] value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public interface Org.BouncyCastle.Cms.RecipientInfoGenerator {
    public abstract virtual RecipientInfo Generate(KeyParameter contentEncryptionKey, SecureRandom random);
}
public abstract class Org.BouncyCastle.Cms.RecipientInformation : object {
    internal RecipientID rid;
    internal AlgorithmIdentifier keyEncAlg;
    internal CmsSecureReadable secureReadable;
    private Byte[] resultMac;
    public RecipientID RecipientID { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithmID { get; }
    public string KeyEncryptionAlgOid { get; }
    public Asn1Object KeyEncryptionAlgParams { get; }
    internal RecipientInformation(AlgorithmIdentifier keyEncAlg, CmsSecureReadable secureReadable);
    internal string GetContentAlgorithmName();
    public RecipientID get_RecipientID();
    public AlgorithmIdentifier get_KeyEncryptionAlgorithmID();
    public string get_KeyEncryptionAlgOid();
    public Asn1Object get_KeyEncryptionAlgParams();
    internal CmsTypedStream GetContentFromSessionKey(KeyParameter sKey);
    public Byte[] GetContent(ICipherParameters key);
    public Byte[] GetMac();
    public abstract virtual CmsTypedStream GetContentStream(ICipherParameters key);
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Cms.RecipientInformationStore : object {
    private IList all;
    private IDictionary table;
    public RecipientInformation Item { get; }
    public int Count { get; }
    public RecipientInformationStore(ICollection recipientInfos);
    public RecipientInformation get_Item(RecipientID selector);
    public RecipientInformation GetFirstRecipient(RecipientID selector);
    public int get_Count();
    public ICollection GetRecipients();
    public ICollection GetRecipients(RecipientID selector);
}
public class Org.BouncyCastle.Cms.SignerID : X509CertStoreSelector {
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Org.BouncyCastle.Cms.SignerInfoGenerator : object {
    internal X509Certificate certificate;
    internal ISignatureFactory contentSigner;
    internal SignerIdentifier sigId;
    internal CmsAttributeTableGenerator signedGen;
    internal CmsAttributeTableGenerator unsignedGen;
    private bool isDirectSignature;
    internal SignerInfoGenerator(SignerIdentifier sigId, ISignatureFactory signerFactory);
    internal SignerInfoGenerator(SignerIdentifier sigId, ISignatureFactory signerFactory, bool isDirectSignature);
    internal SignerInfoGenerator(SignerIdentifier sigId, ISignatureFactory contentSigner, CmsAttributeTableGenerator signedGen, CmsAttributeTableGenerator unsignedGen);
    internal void setAssociatedCertificate(X509Certificate certificate);
    public SignerInfoGeneratorBuilder NewBuilder();
}
public class Org.BouncyCastle.Cms.SignerInfoGeneratorBuilder : object {
    private bool directSignature;
    private CmsAttributeTableGenerator signedGen;
    private CmsAttributeTableGenerator unsignedGen;
    public SignerInfoGeneratorBuilder SetDirectSignature(bool hasNoSignedAttributes);
    public SignerInfoGeneratorBuilder WithSignedAttributeGenerator(CmsAttributeTableGenerator signedGen);
    public SignerInfoGeneratorBuilder WithUnsignedAttributeGenerator(CmsAttributeTableGenerator unsignedGen);
    public SignerInfoGenerator Build(ISignatureFactory contentSigner, X509Certificate certificate);
    public SignerInfoGenerator Build(ISignatureFactory signerFactory, Byte[] subjectKeyIdentifier);
    private SignerInfoGenerator CreateGenerator(ISignatureFactory contentSigner, SignerIdentifier sigId);
}
public class Org.BouncyCastle.Cms.SignerInformation : object {
    private static CmsSignedHelper Helper;
    private SignerID sid;
    private CmsProcessable content;
    private Byte[] signature;
    private DerObjectIdentifier contentType;
    private Byte[] calculatedDigest;
    private Byte[] resultDigest;
    private AttributeTable signedAttributeTable;
    private AttributeTable unsignedAttributeTable;
    private bool isCounterSignature;
    protected SignerInfo info;
    protected AlgorithmIdentifier digestAlgorithm;
    protected AlgorithmIdentifier encryptionAlgorithm;
    protected Asn1Set signedAttributeSet;
    protected Asn1Set unsignedAttributeSet;
    public bool IsCounterSignature { get; }
    public DerObjectIdentifier ContentType { get; }
    public SignerID SignerID { get; }
    public int Version { get; }
    public AlgorithmIdentifier DigestAlgorithmID { get; }
    public string DigestAlgOid { get; }
    public Asn1Object DigestAlgParams { get; }
    public AlgorithmIdentifier EncryptionAlgorithmID { get; }
    public string EncryptionAlgOid { get; }
    public Asn1Object EncryptionAlgParams { get; }
    public AttributeTable SignedAttributes { get; }
    public AttributeTable UnsignedAttributes { get; }
    internal SignerInformation(SignerInfo info, DerObjectIdentifier contentType, CmsProcessable content, IDigestCalculator digestCalculator);
    protected SignerInformation(SignerInformation baseInfo);
    private static SignerInformation();
    public bool get_IsCounterSignature();
    public DerObjectIdentifier get_ContentType();
    public SignerID get_SignerID();
    public int get_Version();
    public AlgorithmIdentifier get_DigestAlgorithmID();
    public string get_DigestAlgOid();
    public Asn1Object get_DigestAlgParams();
    public Byte[] GetContentDigest();
    public AlgorithmIdentifier get_EncryptionAlgorithmID();
    public string get_EncryptionAlgOid();
    public Asn1Object get_EncryptionAlgParams();
    public AttributeTable get_SignedAttributes();
    public AttributeTable get_UnsignedAttributes();
    public Byte[] GetSignature();
    public SignerInformationStore GetCounterSignatures();
    public virtual Byte[] GetEncodedSignedAttributes();
    private bool DoVerify(AsymmetricKeyParameter key);
    private bool IsNull(Asn1Encodable o);
    private DigestInfo DerDecode(Byte[] encoding);
    private bool VerifyDigest(Byte[] digest, AsymmetricKeyParameter key, Byte[] signature);
    public bool Verify(AsymmetricKeyParameter pubKey);
    public bool Verify(X509Certificate cert);
    public SignerInfo ToSignerInfo();
    private Asn1Object GetSingleValuedSignedAttribute(DerObjectIdentifier attrOID, string printableName);
    private Time GetSigningTime();
    public static SignerInformation ReplaceUnsignedAttributes(SignerInformation signerInformation, AttributeTable unsignedAttributes);
    public static SignerInformation AddCounterSigners(SignerInformation signerInformation, SignerInformationStore counterSigners);
}
public class Org.BouncyCastle.Cms.SignerInformationStore : object {
    private IList all;
    private IDictionary table;
    public int Count { get; }
    public SignerInformationStore(SignerInformation signerInfo);
    public SignerInformationStore(ICollection signerInfos);
    public SignerInformation GetFirstSigner(SignerID selector);
    public int get_Count();
    public ICollection GetSigners();
    public ICollection GetSigners(SignerID selector);
}
public class Org.BouncyCastle.Cms.SimpleAttributeTableGenerator : object {
    private AttributeTable attributes;
    public SimpleAttributeTableGenerator(AttributeTable attributes);
    public virtual AttributeTable GetAttributes(IDictionary parameters);
}
public class Org.BouncyCastle.Crmf.AuthenticatorControl : object {
    private static DerObjectIdentifier type;
    private DerUtf8String token;
    public DerObjectIdentifier Type { get; }
    public Asn1Encodable Value { get; }
    public AuthenticatorControl(DerUtf8String token);
    public AuthenticatorControl(string token);
    private static AuthenticatorControl();
    public sealed virtual DerObjectIdentifier get_Type();
    public sealed virtual Asn1Encodable get_Value();
}
public class Org.BouncyCastle.Crmf.CertificateRequestMessage : object {
    public static int popRaVerified;
    public static int popSigningKey;
    public static int popKeyEncipherment;
    public static int popKeyAgreement;
    private CertReqMsg certReqMsg;
    private Controls controls;
    public bool HasControls { get; }
    public bool HasProofOfPossession { get; }
    public int ProofOfPossession { get; }
    public bool HasSigningKeyProofOfPossessionWithPkMac { get; }
    public CertificateRequestMessage(Byte[] encoded);
    public CertificateRequestMessage(CertReqMsg certReqMsg);
    private static CertificateRequestMessage();
    private static CertReqMsg ParseBytes(Byte[] encoding);
    public CertReqMsg ToAsn1Structure();
    public CertTemplate GetCertTemplate();
    public bool get_HasControls();
    public bool HasControl(DerObjectIdentifier objectIdentifier);
    public IControl GetControl(DerObjectIdentifier type);
    public AttributeTypeAndValue FindControl(DerObjectIdentifier type);
    public bool get_HasProofOfPossession();
    public int get_ProofOfPossession();
    public bool get_HasSigningKeyProofOfPossessionWithPkMac();
    public bool IsValidSigningKeyPop(IVerifierFactoryProvider verifierProvider);
    private bool verifySignature(IVerifierFactoryProvider verifierFactoryProvider, PopoSigningKey signKey);
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Crmf.CertificateRequestMessageBuilder : object {
    private BigInteger _certReqId;
    private X509ExtensionsGenerator _extGenerator;
    private CertTemplateBuilder _templateBuilder;
    private IList _controls;
    private ISignatureFactory _popSigner;
    private PKMacBuilder _pkMacBuilder;
    private Char[] _password;
    private GeneralName _sender;
    private int _popoType;
    private PopoPrivKey _popoPrivKey;
    private Asn1Null _popRaVerified;
    private PKMacValue _agreeMac;
    public CertificateRequestMessageBuilder(BigInteger certReqId);
    public CertificateRequestMessageBuilder SetPublicKey(SubjectPublicKeyInfo publicKeyInfo);
    public CertificateRequestMessageBuilder SetIssuer(X509Name issuer);
    public CertificateRequestMessageBuilder SetSubject(X509Name subject);
    public CertificateRequestMessageBuilder SetSerialNumber(BigInteger serialNumber);
    public CertificateRequestMessageBuilder SetValidity(Time notBefore, Time notAfter);
    public CertificateRequestMessageBuilder AddExtension(DerObjectIdentifier oid, bool critical, Asn1Encodable value);
    public CertificateRequestMessageBuilder AddExtension(DerObjectIdentifier oid, bool critical, Byte[] value);
    public CertificateRequestMessageBuilder AddControl(IControl control);
    public CertificateRequestMessageBuilder SetProofOfPossessionSignKeySigner(ISignatureFactory popoSignatureFactory);
    public CertificateRequestMessageBuilder SetProofOfPossessionSubsequentMessage(SubsequentMessage msg);
    public CertificateRequestMessageBuilder SetProofOfPossessionSubsequentMessage(int type, SubsequentMessage msg);
    public CertificateRequestMessageBuilder SetProofOfPossessionAgreeMac(PKMacValue macValue);
    public CertificateRequestMessageBuilder SetProofOfPossessionRaVerified();
    public CertificateRequestMessageBuilder SetAuthInfoPKMAC(PKMacBuilder pkmacFactory, Char[] password);
    public CertificateRequestMessageBuilder SetAuthInfoSender(X509Name sender);
    public CertificateRequestMessageBuilder SetAuthInfoSender(GeneralName sender);
    public CertificateRequestMessage Build();
}
public class Org.BouncyCastle.Crmf.CrmfException : Exception {
    public CrmfException(string message);
    public CrmfException(string message, Exception innerException);
}
public class Org.BouncyCastle.Crmf.DefaultPKMacPrimitivesProvider : object {
    public sealed virtual IDigest CreateDigest(AlgorithmIdentifier digestAlg);
    public sealed virtual IMac CreateMac(AlgorithmIdentifier macAlg);
}
internal class Org.BouncyCastle.Crmf.DefaultPKMacResult : object {
    private IMac mac;
    public DefaultPKMacResult(IMac mac);
    public sealed virtual Byte[] Collect();
    public sealed virtual int Collect(Byte[] sig, int sigOff);
}
public class Org.BouncyCastle.Crmf.EncryptedValueBuilder : object {
    private IKeyWrapper wrapper;
    private ICipherBuilderWithKey encryptor;
    private IEncryptedValuePadder padder;
    public EncryptedValueBuilder(IKeyWrapper wrapper, ICipherBuilderWithKey encryptor);
    public EncryptedValueBuilder(IKeyWrapper wrapper, ICipherBuilderWithKey encryptor, IEncryptedValuePadder padder);
    public EncryptedValue Build(Char[] revocationPassphrase);
    public EncryptedValue Build(X509Certificate holder);
    public EncryptedValue Build(PrivateKeyInfo privateKeyInfo);
    private EncryptedValue EncryptData(Byte[] data);
    private Byte[] PadData(Byte[] data);
}
public interface Org.BouncyCastle.Crmf.IControl {
    public DerObjectIdentifier Type { get; }
    public Asn1Encodable Value { get; }
    public abstract virtual DerObjectIdentifier get_Type();
    public abstract virtual Asn1Encodable get_Value();
}
public interface Org.BouncyCastle.Crmf.IEncryptedValuePadder {
    public abstract virtual Byte[] GetPaddedData(Byte[] data);
    public abstract virtual Byte[] GetUnpaddedData(Byte[] paddedData);
}
public interface Org.BouncyCastle.Crmf.IPKMacPrimitivesProvider {
    public abstract virtual IDigest CreateDigest(AlgorithmIdentifier digestAlg);
    public abstract virtual IMac CreateMac(AlgorithmIdentifier macAlg);
}
public class Org.BouncyCastle.Crmf.PkiArchiveControl : object {
    public static int encryptedPrivKey;
    public static int keyGenParameters;
    public static int archiveRemGenPrivKey;
    private static DerObjectIdentifier type;
    private PkiArchiveOptions pkiArchiveOptions;
    public DerObjectIdentifier Type { get; }
    public Asn1Encodable Value { get; }
    public int ArchiveType { get; }
    public bool EnvelopedData { get; }
    public PkiArchiveControl(PkiArchiveOptions pkiArchiveOptions);
    private static PkiArchiveControl();
    public sealed virtual DerObjectIdentifier get_Type();
    public sealed virtual Asn1Encodable get_Value();
    public int get_ArchiveType();
    public bool get_EnvelopedData();
    public CmsEnvelopedData GetEnvelopedData();
}
public class Org.BouncyCastle.Crmf.PkiArchiveControlBuilder : object {
    private CmsEnvelopedDataGenerator envGen;
    private CmsProcessableByteArray keyContent;
    public PkiArchiveControlBuilder(PrivateKeyInfo privateKeyInfo, GeneralName generalName);
    public PkiArchiveControlBuilder AddRecipientGenerator(RecipientInfoGenerator recipientGen);
    public PkiArchiveControl Build(ICipherBuilderWithKey contentEncryptor);
}
public class Org.BouncyCastle.Crmf.PKMacBuilder : object {
    private AlgorithmIdentifier owf;
    private AlgorithmIdentifier mac;
    private IPKMacPrimitivesProvider provider;
    private SecureRandom random;
    private PbmParameter parameters;
    private int iterationCount;
    private int saltLength;
    private int maxIterations;
    public PKMacBuilder(IPKMacPrimitivesProvider provider);
    public PKMacBuilder(IPKMacPrimitivesProvider provider, AlgorithmIdentifier digestAlgorithmIdentifier, AlgorithmIdentifier macAlgorithmIdentifier);
    public PKMacBuilder(IPKMacPrimitivesProvider provider, int maxIterations);
    private PKMacBuilder(AlgorithmIdentifier digestAlgorithmIdentifier, int iterationCount, AlgorithmIdentifier macAlgorithmIdentifier, IPKMacPrimitivesProvider provider);
    public PKMacBuilder SetSaltLength(int saltLength);
    public PKMacBuilder SetIterationCount(int iterationCount);
    public PKMacBuilder SetParameters(PbmParameter parameters);
    public PKMacBuilder SetSecureRandom(SecureRandom random);
    public IMacFactory Build(Char[] password);
    private void CheckIterationCountCeiling(int iterationCount);
    private IMacFactory GenCalculator(PbmParameter parameters, Char[] password);
}
internal class Org.BouncyCastle.Crmf.PKMacFactory : object {
    protected PbmParameter parameters;
    private Byte[] key;
    public object AlgorithmDetails { get; }
    public PKMacFactory(Byte[] key, PbmParameter parameters);
    public virtual object get_AlgorithmDetails();
    public virtual IStreamCalculator CreateCalculator();
}
internal class Org.BouncyCastle.Crmf.PKMacStreamCalculator : object {
    private MacSink _stream;
    public Stream Stream { get; }
    public PKMacStreamCalculator(IMac mac);
    public sealed virtual Stream get_Stream();
    public sealed virtual object GetResult();
}
public class Org.BouncyCastle.Crmf.ProofOfPossessionSigningKeyBuilder : object {
    private CertRequest _certRequest;
    private SubjectPublicKeyInfo _pubKeyInfo;
    private GeneralName _name;
    private PKMacValue _publicKeyMAC;
    public ProofOfPossessionSigningKeyBuilder(CertRequest certRequest);
    public ProofOfPossessionSigningKeyBuilder(SubjectPublicKeyInfo pubKeyInfo);
    public ProofOfPossessionSigningKeyBuilder SetSender(GeneralName name);
    public ProofOfPossessionSigningKeyBuilder SetPublicKeyMac(PKMacBuilder generator, Char[] password);
    public PopoSigningKey Build(ISignatureFactory signer);
}
public class Org.BouncyCastle.Crmf.RegTokenControl : object {
    private static DerObjectIdentifier type;
    private DerUtf8String token;
    public DerObjectIdentifier Type { get; }
    public Asn1Encodable Value { get; }
    public RegTokenControl(DerUtf8String token);
    public RegTokenControl(string token);
    private static RegTokenControl();
    public sealed virtual DerObjectIdentifier get_Type();
    public sealed virtual Asn1Encodable get_Value();
}
public class Org.BouncyCastle.Crypto.Agreement.DHAgreement : object {
    private DHPrivateKeyParameters key;
    private DHParameters dhParams;
    private BigInteger privateValue;
    private SecureRandom random;
    public void Init(ICipherParameters parameters);
    public BigInteger CalculateMessage();
    public BigInteger CalculateAgreement(DHPublicKeyParameters pub, BigInteger message);
}
public class Org.BouncyCastle.Crypto.Agreement.DHBasicAgreement : object {
    private DHPrivateKeyParameters key;
    private DHParameters dhParams;
    public virtual void Init(ICipherParameters parameters);
    public virtual int GetFieldSize();
    public virtual BigInteger CalculateAgreement(ICipherParameters pubKey);
}
public class Org.BouncyCastle.Crypto.Agreement.DHStandardGroups : object {
    private static BigInteger Two;
    private static string rfc2409_768_p;
    public static DHParameters rfc2409_768;
    private static string rfc2409_1024_p;
    public static DHParameters rfc2409_1024;
    private static string rfc3526_1536_p;
    private static int rfc3526_1536_l;
    public static DHParameters rfc3526_1536;
    private static string rfc3526_2048_p;
    private static int rfc3526_2048_l;
    public static DHParameters rfc3526_2048;
    private static string rfc3526_3072_p;
    private static int rfc3526_3072_l;
    public static DHParameters rfc3526_3072;
    private static string rfc3526_4096_p;
    private static int rfc3526_4096_l;
    public static DHParameters rfc3526_4096;
    private static string rfc3526_6144_p;
    private static int rfc3526_6144_l;
    public static DHParameters rfc3526_6144;
    private static string rfc3526_8192_p;
    private static int rfc3526_8192_l;
    public static DHParameters rfc3526_8192;
    public static DHParameters rfc4306_768;
    public static DHParameters rfc4306_1024;
    public static DHParameters rfc5996_768;
    public static DHParameters rfc5996_1024;
    private static string rfc7919_ffdhe2048_p;
    private static int rfc7919_ffdhe2048_l;
    public static DHParameters rfc7919_ffdhe2048;
    private static string rfc7919_ffdhe3072_p;
    private static int rfc7919_ffdhe3072_l;
    public static DHParameters rfc7919_ffdhe3072;
    private static string rfc7919_ffdhe4096_p;
    private static int rfc7919_ffdhe4096_l;
    public static DHParameters rfc7919_ffdhe4096;
    private static string rfc7919_ffdhe6144_p;
    private static int rfc7919_ffdhe6144_l;
    public static DHParameters rfc7919_ffdhe6144;
    private static string rfc7919_ffdhe8192_p;
    private static int rfc7919_ffdhe8192_l;
    public static DHParameters rfc7919_ffdhe8192;
    private static DHStandardGroups();
    private static BigInteger FromHex(string hex);
    private static DHParameters FromPG(string hexP, string hexG);
    private static DHParameters SafePrimeGen2(string hexP);
    private static DHParameters SafePrimeGen2(string hexP, int l);
}
public class Org.BouncyCastle.Crypto.Agreement.ECDHBasicAgreement : object {
    protected internal ECPrivateKeyParameters privKey;
    public virtual void Init(ICipherParameters parameters);
    public virtual int GetFieldSize();
    public virtual BigInteger CalculateAgreement(ICipherParameters pubKey);
}
public class Org.BouncyCastle.Crypto.Agreement.ECDHCBasicAgreement : object {
    private ECPrivateKeyParameters privKey;
    public virtual void Init(ICipherParameters parameters);
    public virtual int GetFieldSize();
    public virtual BigInteger CalculateAgreement(ICipherParameters pubKey);
}
public class Org.BouncyCastle.Crypto.Agreement.ECDHWithKdfBasicAgreement : ECDHBasicAgreement {
    private string algorithm;
    private IDerivationFunction kdf;
    public ECDHWithKdfBasicAgreement(string algorithm, IDerivationFunction kdf);
    public virtual BigInteger CalculateAgreement(ICipherParameters pubKey);
    private Byte[] BigIntToBytes(BigInteger r);
}
public class Org.BouncyCastle.Crypto.Agreement.ECMqvBasicAgreement : object {
    protected internal MqvPrivateParameters privParams;
    public virtual void Init(ICipherParameters parameters);
    public virtual int GetFieldSize();
    public virtual BigInteger CalculateAgreement(ICipherParameters pubKey);
    private static ECPoint CalculateMqvAgreement(ECDomainParameters parameters, ECPrivateKeyParameters d1U, ECPrivateKeyParameters d2U, ECPublicKeyParameters Q2U, ECPublicKeyParameters Q1V, ECPublicKeyParameters Q2V);
}
public class Org.BouncyCastle.Crypto.Agreement.ECMqvWithKdfBasicAgreement : ECMqvBasicAgreement {
    private string algorithm;
    private IDerivationFunction kdf;
    public ECMqvWithKdfBasicAgreement(string algorithm, IDerivationFunction kdf);
    public virtual BigInteger CalculateAgreement(ICipherParameters pubKey);
    private Byte[] BigIntToBytes(BigInteger r);
}
public class Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant : object {
    public static int STATE_INITIALIZED;
    public static int STATE_ROUND_1_CREATED;
    public static int STATE_ROUND_1_VALIDATED;
    public static int STATE_ROUND_2_CREATED;
    public static int STATE_ROUND_2_VALIDATED;
    public static int STATE_KEY_CALCULATED;
    public static int STATE_ROUND_3_CREATED;
    public static int STATE_ROUND_3_VALIDATED;
    private string participantId;
    private Char[] password;
    private IDigest digest;
    private SecureRandom random;
    private BigInteger p;
    private BigInteger q;
    private BigInteger g;
    private string partnerParticipantId;
    private BigInteger x1;
    private BigInteger x2;
    private BigInteger gx1;
    private BigInteger gx2;
    private BigInteger gx3;
    private BigInteger gx4;
    private BigInteger b;
    private int state;
    public int State { get; }
    public JPakeParticipant(string participantId, Char[] password);
    public JPakeParticipant(string participantId, Char[] password, JPakePrimeOrderGroup group);
    public JPakeParticipant(string participantId, Char[] password, JPakePrimeOrderGroup group, IDigest digest, SecureRandom random);
    private static JPakeParticipant();
    public virtual int get_State();
    public virtual JPakeRound1Payload CreateRound1PayloadToSend();
    public virtual void ValidateRound1PayloadReceived(JPakeRound1Payload round1PayloadReceived);
    public virtual JPakeRound2Payload CreateRound2PayloadToSend();
    public virtual void ValidateRound2PayloadReceived(JPakeRound2Payload round2PayloadReceived);
    public virtual BigInteger CalculateKeyingMaterial();
    public virtual JPakeRound3Payload CreateRound3PayloadToSend(BigInteger keyingMaterial);
    public virtual void ValidateRound3PayloadReceived(JPakeRound3Payload round3PayloadReceived, BigInteger keyingMaterial);
}
public class Org.BouncyCastle.Crypto.Agreement.JPake.JPakePrimeOrderGroup : object {
    private BigInteger p;
    private BigInteger q;
    private BigInteger g;
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger G { get; }
    public JPakePrimeOrderGroup(BigInteger p, BigInteger q, BigInteger g);
    public JPakePrimeOrderGroup(BigInteger p, BigInteger q, BigInteger g, bool skipChecks);
    public virtual BigInteger get_P();
    public virtual BigInteger get_Q();
    public virtual BigInteger get_G();
}
public class Org.BouncyCastle.Crypto.Agreement.JPake.JPakePrimeOrderGroups : object {
    public static JPakePrimeOrderGroup SUN_JCE_1024;
    public static JPakePrimeOrderGroup NIST_2048;
    public static JPakePrimeOrderGroup NIST_3072;
    private static JPakePrimeOrderGroups();
}
public class Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound1Payload : object {
    private string participantId;
    private BigInteger gx1;
    private BigInteger gx2;
    private BigInteger[] knowledgeProofForX1;
    private BigInteger[] knowledgeProofForX2;
    public string ParticipantId { get; }
    public BigInteger Gx1 { get; }
    public BigInteger Gx2 { get; }
    public BigInteger[] KnowledgeProofForX1 { get; }
    public BigInteger[] KnowledgeProofForX2 { get; }
    public JPakeRound1Payload(string participantId, BigInteger gx1, BigInteger gx2, BigInteger[] knowledgeProofForX1, BigInteger[] knowledgeProofForX2);
    public virtual string get_ParticipantId();
    public virtual BigInteger get_Gx1();
    public virtual BigInteger get_Gx2();
    public virtual BigInteger[] get_KnowledgeProofForX1();
    public virtual BigInteger[] get_KnowledgeProofForX2();
}
public class Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound2Payload : object {
    private string participantId;
    private BigInteger a;
    private BigInteger[] knowledgeProofForX2s;
    public string ParticipantId { get; }
    public BigInteger A { get; }
    public BigInteger[] KnowledgeProofForX2s { get; }
    public JPakeRound2Payload(string participantId, BigInteger a, BigInteger[] knowledgeProofForX2s);
    public virtual string get_ParticipantId();
    public virtual BigInteger get_A();
    public virtual BigInteger[] get_KnowledgeProofForX2s();
}
public class Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound3Payload : object {
    private string participantId;
    private BigInteger macTag;
    public string ParticipantId { get; }
    public BigInteger MacTag { get; }
    public JPakeRound3Payload(string participantId, BigInteger magTag);
    public virtual string get_ParticipantId();
    public virtual BigInteger get_MacTag();
}
public abstract class Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities : object {
    public static BigInteger Zero;
    public static BigInteger One;
    private static JPakeUtilities();
    public static BigInteger GenerateX1(BigInteger q, SecureRandom random);
    public static BigInteger GenerateX2(BigInteger q, SecureRandom random);
    public static BigInteger CalculateS(Char[] password);
    public static BigInteger CalculateGx(BigInteger p, BigInteger g, BigInteger x);
    public static BigInteger CalculateGA(BigInteger p, BigInteger gx1, BigInteger gx3, BigInteger gx4);
    public static BigInteger CalculateX2s(BigInteger q, BigInteger x2, BigInteger s);
    public static BigInteger CalculateA(BigInteger p, BigInteger q, BigInteger gA, BigInteger x2s);
    public static BigInteger[] CalculateZeroKnowledgeProof(BigInteger p, BigInteger q, BigInteger g, BigInteger gx, BigInteger x, string participantId, IDigest digest, SecureRandom random);
    private static BigInteger CalculateHashForZeroKnowledgeProof(BigInteger g, BigInteger gr, BigInteger gx, string participantId, IDigest digest);
    public static void ValidateGx4(BigInteger gx4);
    public static void ValidateGa(BigInteger ga);
    public static void ValidateZeroKnowledgeProof(BigInteger p, BigInteger q, BigInteger g, BigInteger gx, BigInteger[] zeroKnowledgeProof, string participantId, IDigest digest);
    public static BigInteger CalculateKeyingMaterial(BigInteger p, BigInteger q, BigInteger gx4, BigInteger x2, BigInteger s, BigInteger B);
    public static void ValidateParticipantIdsDiffer(string participantId1, string participantId2);
    public static void ValidateParticipantIdsEqual(string expectedParticipantId, string actualParticipantId);
    public static void ValidateNotNull(object obj, string description);
    public static BigInteger CalculateMacTag(string participantId, string partnerParticipantId, BigInteger gx1, BigInteger gx2, BigInteger gx3, BigInteger gx4, BigInteger keyingMaterial, IDigest digest);
    private static Byte[] CalculateMacKey(BigInteger keyingMaterial, IDigest digest);
    public static void ValidateMacTag(string participantId, string partnerParticipantId, BigInteger gx1, BigInteger gx2, BigInteger gx3, BigInteger gx4, BigInteger keyingMaterial, IDigest digest, BigInteger partnerMacTag);
    private static void UpdateDigest(IDigest digest, BigInteger bigInteger);
    private static void UpdateDigest(IDigest digest, string str);
    private static void UpdateDigest(IDigest digest, Byte[] bytes);
    private static void UpdateDigestIncludingSize(IDigest digest, BigInteger bigInteger);
    private static void UpdateDigestIncludingSize(IDigest digest, string str);
    private static void UpdateDigestIncludingSize(IDigest digest, Byte[] bytes);
    private static void UpdateMac(IMac mac, BigInteger bigInteger);
    private static void UpdateMac(IMac mac, string str);
    private static void UpdateMac(IMac mac, Byte[] bytes);
    private static Byte[] IntToByteArray(int value);
}
public class Org.BouncyCastle.Crypto.Agreement.Kdf.ConcatenationKdfGenerator : object {
    private IDigest mDigest;
    private Byte[] mShared;
    private Byte[] mOtherInfo;
    private int mHLen;
    public IDigest Digest { get; }
    public ConcatenationKdfGenerator(IDigest digest);
    public virtual void Init(IDerivationParameters param);
    public virtual IDigest get_Digest();
    public virtual int GenerateBytes(Byte[] outBytes, int outOff, int len);
}
public class Org.BouncyCastle.Crypto.Agreement.Kdf.DHKdfParameters : object {
    private DerObjectIdentifier algorithm;
    private int keySize;
    private Byte[] z;
    private Byte[] extraInfo;
    public DerObjectIdentifier Algorithm { get; }
    public int KeySize { get; }
    public DHKdfParameters(DerObjectIdentifier algorithm, int keySize, Byte[] z);
    public DHKdfParameters(DerObjectIdentifier algorithm, int keySize, Byte[] z, Byte[] extraInfo);
    public DerObjectIdentifier get_Algorithm();
    public int get_KeySize();
    public Byte[] GetZ();
    public Byte[] GetExtraInfo();
}
public class Org.BouncyCastle.Crypto.Agreement.Kdf.DHKekGenerator : object {
    private IDigest digest;
    private DerObjectIdentifier algorithm;
    private int keySize;
    private Byte[] z;
    private Byte[] partyAInfo;
    public IDigest Digest { get; }
    public DHKekGenerator(IDigest digest);
    public virtual void Init(IDerivationParameters param);
    public virtual IDigest get_Digest();
    public virtual int GenerateBytes(Byte[] outBytes, int outOff, int len);
}
public class Org.BouncyCastle.Crypto.Agreement.Kdf.ECDHKekGenerator : object {
    private IDerivationFunction kdf;
    private DerObjectIdentifier algorithm;
    private int keySize;
    private Byte[] z;
    public IDigest Digest { get; }
    public ECDHKekGenerator(IDigest digest);
    public virtual void Init(IDerivationParameters param);
    public virtual IDigest get_Digest();
    public virtual int GenerateBytes(Byte[] outBytes, int outOff, int len);
}
public class Org.BouncyCastle.Crypto.Agreement.SM2KeyExchange : object {
    private IDigest mDigest;
    private Byte[] mUserID;
    private ECPrivateKeyParameters mStaticKey;
    private ECPoint mStaticPubPoint;
    private ECPoint mEphemeralPubPoint;
    private ECDomainParameters mECParams;
    private int mW;
    private ECPrivateKeyParameters mEphemeralKey;
    private bool mInitiator;
    public SM2KeyExchange(IDigest digest);
    public virtual void Init(ICipherParameters privParam);
    public virtual Byte[] CalculateKey(int kLen, ICipherParameters pubParam);
    public virtual Byte[][] CalculateKeyWithConfirmation(int kLen, Byte[] confirmationTag, ICipherParameters pubParam);
    protected virtual ECPoint CalculateU(SM2KeyExchangePublicParameters otherPub);
    protected virtual Byte[] Kdf(ECPoint u, Byte[] za, Byte[] zb, int klen);
    private BigInteger Reduce(BigInteger x);
    private Byte[] S1(IDigest digest, ECPoint u, Byte[] inner);
    private Byte[] CalculateInnerHash(IDigest digest, ECPoint u, Byte[] za, Byte[] zb, ECPoint p1, ECPoint p2);
    private Byte[] S2(IDigest digest, ECPoint u, Byte[] inner);
    private Byte[] GetZ(IDigest digest, Byte[] userID, ECPoint pubPoint);
    private void AddUserID(IDigest digest, Byte[] userID);
    private void AddFieldElement(IDigest digest, ECFieldElement v);
}
public class Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Client : object {
    protected BigInteger N;
    protected BigInteger g;
    protected BigInteger privA;
    protected BigInteger pubA;
    protected BigInteger B;
    protected BigInteger x;
    protected BigInteger u;
    protected BigInteger S;
    protected BigInteger M1;
    protected BigInteger M2;
    protected BigInteger Key;
    protected IDigest digest;
    protected SecureRandom random;
    public virtual void Init(BigInteger N, BigInteger g, IDigest digest, SecureRandom random);
    public virtual void Init(Srp6GroupParameters group, IDigest digest, SecureRandom random);
    public virtual BigInteger GenerateClientCredentials(Byte[] salt, Byte[] identity, Byte[] password);
    public virtual BigInteger CalculateSecret(BigInteger serverB);
    protected virtual BigInteger SelectPrivateValue();
    private BigInteger CalculateS();
    public virtual BigInteger CalculateClientEvidenceMessage();
    public virtual bool VerifyServerEvidenceMessage(BigInteger serverM2);
    public virtual BigInteger CalculateSessionKey();
}
public class Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Server : object {
    protected BigInteger N;
    protected BigInteger g;
    protected BigInteger v;
    protected SecureRandom random;
    protected IDigest digest;
    protected BigInteger A;
    protected BigInteger privB;
    protected BigInteger pubB;
    protected BigInteger u;
    protected BigInteger S;
    protected BigInteger M1;
    protected BigInteger M2;
    protected BigInteger Key;
    public virtual void Init(BigInteger N, BigInteger g, BigInteger v, IDigest digest, SecureRandom random);
    public virtual void Init(Srp6GroupParameters group, BigInteger v, IDigest digest, SecureRandom random);
    public virtual BigInteger GenerateServerCredentials();
    public virtual BigInteger CalculateSecret(BigInteger clientA);
    protected virtual BigInteger SelectPrivateValue();
    private BigInteger CalculateS();
    public virtual bool VerifyClientEvidenceMessage(BigInteger clientM1);
    public virtual BigInteger CalculateServerEvidenceMessage();
    public virtual BigInteger CalculateSessionKey();
}
public class Org.BouncyCastle.Crypto.Agreement.Srp.Srp6StandardGroups : object {
    private static string rfc5054_1024_N;
    private static string rfc5054_1024_g;
    public static Srp6GroupParameters rfc5054_1024;
    private static string rfc5054_1536_N;
    private static string rfc5054_1536_g;
    public static Srp6GroupParameters rfc5054_1536;
    private static string rfc5054_2048_N;
    private static string rfc5054_2048_g;
    public static Srp6GroupParameters rfc5054_2048;
    private static string rfc5054_3072_N;
    private static string rfc5054_3072_g;
    public static Srp6GroupParameters rfc5054_3072;
    private static string rfc5054_4096_N;
    private static string rfc5054_4096_g;
    public static Srp6GroupParameters rfc5054_4096;
    private static string rfc5054_6144_N;
    private static string rfc5054_6144_g;
    public static Srp6GroupParameters rfc5054_6144;
    private static string rfc5054_8192_N;
    private static string rfc5054_8192_g;
    public static Srp6GroupParameters rfc5054_8192;
    private static Srp6StandardGroups();
    private static BigInteger FromHex(string hex);
    private static Srp6GroupParameters FromNG(string hexN, string hexG);
}
public class Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Utilities : object {
    public static BigInteger CalculateK(IDigest digest, BigInteger N, BigInteger g);
    public static BigInteger CalculateU(IDigest digest, BigInteger N, BigInteger A, BigInteger B);
    public static BigInteger CalculateX(IDigest digest, BigInteger N, Byte[] salt, Byte[] identity, Byte[] password);
    public static BigInteger GeneratePrivateValue(IDigest digest, BigInteger N, BigInteger g, SecureRandom random);
    public static BigInteger ValidatePublicValue(BigInteger N, BigInteger val);
    public static BigInteger CalculateM1(IDigest digest, BigInteger N, BigInteger A, BigInteger B, BigInteger S);
    public static BigInteger CalculateM2(IDigest digest, BigInteger N, BigInteger A, BigInteger M1, BigInteger S);
    public static BigInteger CalculateKey(IDigest digest, BigInteger N, BigInteger S);
    private static BigInteger HashPaddedTriplet(IDigest digest, BigInteger N, BigInteger n1, BigInteger n2, BigInteger n3);
    private static BigInteger HashPaddedPair(IDigest digest, BigInteger N, BigInteger n1, BigInteger n2);
    private static Byte[] GetPadded(BigInteger n, int length);
}
public class Org.BouncyCastle.Crypto.Agreement.Srp.Srp6VerifierGenerator : object {
    protected BigInteger N;
    protected BigInteger g;
    protected IDigest digest;
    public virtual void Init(BigInteger N, BigInteger g, IDigest digest);
    public virtual void Init(Srp6GroupParameters group, IDigest digest);
    public virtual BigInteger GenerateVerifier(Byte[] salt, Byte[] identity, Byte[] password);
}
public class Org.BouncyCastle.Crypto.Agreement.X25519Agreement : object {
    private X25519PrivateKeyParameters privateKey;
    public int AgreementSize { get; }
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual int get_AgreementSize();
    public sealed virtual void CalculateAgreement(ICipherParameters publicKey, Byte[] buf, int off);
}
public class Org.BouncyCastle.Crypto.Agreement.X448Agreement : object {
    private X448PrivateKeyParameters privateKey;
    public int AgreementSize { get; }
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual int get_AgreementSize();
    public sealed virtual void CalculateAgreement(ICipherParameters publicKey, Byte[] buf, int off);
}
public class Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair : object {
    private AsymmetricKeyParameter publicParameter;
    private AsymmetricKeyParameter privateParameter;
    public AsymmetricKeyParameter Public { get; }
    public AsymmetricKeyParameter Private { get; }
    public AsymmetricCipherKeyPair(AsymmetricKeyParameter publicParameter, AsymmetricKeyParameter privateParameter);
    public AsymmetricKeyParameter get_Public();
    public AsymmetricKeyParameter get_Private();
}
public abstract class Org.BouncyCastle.Crypto.AsymmetricKeyParameter : object {
    private bool privateKey;
    public bool IsPrivate { get; }
    protected AsymmetricKeyParameter(bool privateKey);
    public bool get_IsPrivate();
    public virtual bool Equals(object obj);
    protected bool Equals(AsymmetricKeyParameter other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.BufferedAeadBlockCipher : BufferedCipherBase {
    private IAeadBlockCipher cipher;
    public string AlgorithmName { get; }
    public BufferedAeadBlockCipher(IAeadBlockCipher cipher);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetBlockSize();
    public virtual int GetUpdateOutputSize(int length);
    public virtual int GetOutputSize(int length);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual Byte[] ProcessByte(byte input);
    public virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input, int inOff, int inLen);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.BufferedAeadCipher : BufferedCipherBase {
    private IAeadCipher cipher;
    public string AlgorithmName { get; }
    public BufferedAeadCipher(IAeadCipher cipher);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetBlockSize();
    public virtual int GetUpdateOutputSize(int length);
    public virtual int GetOutputSize(int length);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual Byte[] ProcessByte(byte input);
    public virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input, int inOff, int inLen);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher : BufferedCipherBase {
    private IAsymmetricBlockCipher cipher;
    private Byte[] buffer;
    private int bufOff;
    public string AlgorithmName { get; }
    public BufferedAsymmetricBlockCipher(IAsymmetricBlockCipher cipher);
    internal int GetBufferPosition();
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual int GetOutputSize(int length);
    public virtual int GetUpdateOutputSize(int length);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual Byte[] ProcessByte(byte input);
    public virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input, int inOff, int length);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.BufferedBlockCipher : BufferedCipherBase {
    internal Byte[] buf;
    internal int bufOff;
    internal bool forEncryption;
    internal IBlockCipher cipher;
    public string AlgorithmName { get; }
    public BufferedBlockCipher(IBlockCipher cipher);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetBlockSize();
    public virtual int GetUpdateOutputSize(int length);
    public virtual int GetOutputSize(int length);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual Byte[] ProcessByte(byte input);
    public virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input, int inOff, int inLen);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
}
public abstract class Org.BouncyCastle.Crypto.BufferedCipherBase : object {
    protected static Byte[] EmptyBuffer;
    public string AlgorithmName { get; }
    private static BufferedCipherBase();
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual int GetBlockSize();
    public abstract virtual int GetOutputSize(int inputLen);
    public abstract virtual int GetUpdateOutputSize(int inputLen);
    public abstract virtual Byte[] ProcessByte(byte input);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual Byte[] ProcessBytes(Byte[] input);
    public abstract virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual int ProcessBytes(Byte[] input, Byte[] output, int outOff);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public abstract virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input);
    public abstract virtual Byte[] DoFinal(Byte[] input, int inOff, int length);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual int DoFinal(Byte[] input, Byte[] output, int outOff);
    public virtual int DoFinal(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public abstract virtual void Reset();
}
public class Org.BouncyCastle.Crypto.BufferedIesCipher : BufferedCipherBase {
    private IesEngine engine;
    private bool forEncryption;
    private MemoryStream buffer;
    public string AlgorithmName { get; }
    public BufferedIesCipher(IesEngine engine);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetBlockSize();
    public virtual int GetOutputSize(int inputLen);
    public virtual int GetUpdateOutputSize(int inputLen);
    public virtual Byte[] ProcessByte(byte input);
    public virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input, int inOff, int length);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.BufferedStreamCipher : BufferedCipherBase {
    private IStreamCipher cipher;
    public string AlgorithmName { get; }
    public BufferedStreamCipher(IStreamCipher cipher);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetBlockSize();
    public virtual int GetOutputSize(int inputLen);
    public virtual int GetUpdateOutputSize(int inputLen);
    public virtual Byte[] ProcessByte(byte input);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input, int inOff, int length);
    public virtual void Reset();
}
internal class Org.BouncyCastle.Crypto.Check : object {
    internal static void DataLength(bool condition, string msg);
    internal static void DataLength(Byte[] buf, int off, int len, string msg);
    internal static void OutputLength(Byte[] buf, int off, int len, string msg);
}
public class Org.BouncyCastle.Crypto.CipherKeyGenerator : object {
    protected internal SecureRandom random;
    protected internal int strength;
    private bool uninitialised;
    private int defaultStrength;
    public int DefaultStrength { get; }
    internal CipherKeyGenerator(int defaultStrength);
    public int get_DefaultStrength();
    public void Init(KeyGenerationParameters parameters);
    protected virtual void engineInit(KeyGenerationParameters parameters);
    public Byte[] GenerateKey();
    protected virtual Byte[] engineGenerateKey();
}
public class Org.BouncyCastle.Crypto.CryptoException : Exception {
    public CryptoException(string message);
    public CryptoException(string message, Exception exception);
}
public class Org.BouncyCastle.Crypto.DataLengthException : CryptoException {
    public DataLengthException(string message);
    public DataLengthException(string message, Exception exception);
}
public class Org.BouncyCastle.Crypto.Digests.Blake2bDigest : object {
    private static UInt64[] blake2b_IV;
    private static Byte[0...,0...] blake2b_sigma;
    private static int ROUNDS;
    private static int BLOCK_LENGTH_BYTES;
    private int digestLength;
    private int keyLength;
    private Byte[] salt;
    private Byte[] personalization;
    private Byte[] key;
    private Byte[] buffer;
    private int bufferPos;
    private UInt64[] internalState;
    private UInt64[] chainValue;
    private ulong t0;
    private ulong t1;
    private ulong f0;
    public string AlgorithmName { get; }
    public Blake2bDigest(Blake2bDigest digest);
    public Blake2bDigest(int digestSize);
    public Blake2bDigest(Byte[] key);
    public Blake2bDigest(Byte[] key, int digestLength, Byte[] salt, Byte[] personalization);
    private static Blake2bDigest();
    private void Init();
    private void InitializeInternalState();
    public virtual void Update(byte b);
    public virtual void BlockUpdate(Byte[] message, int offset, int len);
    public virtual int DoFinal(Byte[] output, int outOffset);
    public virtual void Reset();
    private void Compress(Byte[] message, int messagePos);
    private void G(ulong m1, ulong m2, int posA, int posB, int posC, int posD);
    private static ulong Rotr64(ulong x, int rot);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual int GetByteLength();
    public virtual void ClearKey();
    public virtual void ClearSalt();
}
public class Org.BouncyCastle.Crypto.Digests.Blake2sDigest : object {
    private static UInt32[] blake2s_IV;
    private static Byte[0...,0...] blake2s_sigma;
    private static int ROUNDS;
    private static int BLOCK_LENGTH_BYTES;
    private int digestLength;
    private int keyLength;
    private Byte[] salt;
    private Byte[] personalization;
    private Byte[] key;
    private Byte[] buffer;
    private int bufferPos;
    private UInt32[] internalState;
    private UInt32[] chainValue;
    private UInt32 t0;
    private UInt32 t1;
    private UInt32 f0;
    public string AlgorithmName { get; }
    public Blake2sDigest(Blake2sDigest digest);
    public Blake2sDigest(int digestBits);
    public Blake2sDigest(Byte[] key);
    public Blake2sDigest(Byte[] key, int digestBytes, Byte[] salt, Byte[] personalization);
    private static Blake2sDigest();
    private void Init();
    private void InitializeInternalState();
    public virtual void Update(byte b);
    public virtual void BlockUpdate(Byte[] message, int offset, int len);
    public virtual int DoFinal(Byte[] output, int outOffset);
    public virtual void Reset();
    private void Compress(Byte[] message, int messagePos);
    private void G(UInt32 m1, UInt32 m2, int posA, int posB, int posC, int posD);
    private UInt32 rotr32(UInt32 x, int rot);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual int GetByteLength();
    public virtual void ClearKey();
    public virtual void ClearSalt();
}
public class Org.BouncyCastle.Crypto.Digests.CShakeDigest : ShakeDigest {
    private static Byte[] padding;
    private Byte[] diff;
    public string AlgorithmName { get; }
    public CShakeDigest(int bitLength, Byte[] N, Byte[] S);
    public CShakeDigest(CShakeDigest source);
    private static CShakeDigest();
    private static Byte[] EncodeString(Byte[] str);
    private void DiffPadAndAbsorb();
    public virtual string get_AlgorithmName();
    public virtual int DoOutput(Byte[] output, int outOff, int outLen);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Digests.Dstu7564Digest : object {
    private static int NB_512;
    private static int NB_1024;
    private static int NR_512;
    private static int NR_1024;
    private int hashSize;
    private int blockSize;
    private int columns;
    private int rounds;
    private UInt64[] state;
    private UInt64[] tempState1;
    private UInt64[] tempState2;
    private ulong inputBlocks;
    private int bufOff;
    private Byte[] buf;
    private static Byte[] S0;
    private static Byte[] S1;
    private static Byte[] S2;
    private static Byte[] S3;
    public string AlgorithmName { get; }
    public Dstu7564Digest(Dstu7564Digest digest);
    public Dstu7564Digest(int hashSizeBits);
    private static Dstu7564Digest();
    private void CopyIn(Dstu7564Digest digest);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual int GetByteLength();
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    protected virtual void ProcessBlock(Byte[] input, int inOff);
    private void P(UInt64[] s);
    private void Q(UInt64[] s);
    private static ulong MixColumn(ulong c);
    private void MixColumns(UInt64[] s);
    private static ulong Rotate(int n, ulong x);
    private void ShiftRows(UInt64[] s);
    private void SubBytes(UInt64[] s);
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public abstract class Org.BouncyCastle.Crypto.Digests.GeneralDigest : object {
    private static int BYTE_LENGTH;
    private Byte[] xBuf;
    private int xBufOff;
    private long byteCount;
    public string AlgorithmName { get; }
    internal GeneralDigest(GeneralDigest t);
    protected void CopyIn(GeneralDigest t);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public void Finish();
    public virtual void Reset();
    public sealed virtual int GetByteLength();
    internal abstract virtual void ProcessWord(Byte[] input, int inOff);
    internal abstract virtual void ProcessLength(long bitLength);
    internal abstract virtual void ProcessBlock();
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int GetDigestSize();
    public abstract virtual int DoFinal(Byte[] output, int outOff);
    public abstract virtual IMemoable Copy();
    public abstract virtual void Reset(IMemoable t);
}
public class Org.BouncyCastle.Crypto.Digests.Gost3411_2012_256Digest : Gost3411_2012Digest {
    private static Byte[] IV;
    public string AlgorithmName { get; }
    public Gost3411_2012_256Digest(Gost3411_2012_256Digest other);
    private static Gost3411_2012_256Digest();
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual IMemoable Copy();
}
public class Org.BouncyCastle.Crypto.Digests.Gost3411_2012_512Digest : Gost3411_2012Digest {
    private static Byte[] IV;
    public string AlgorithmName { get; }
    public Gost3411_2012_512Digest(Gost3411_2012_512Digest other);
    private static Gost3411_2012_512Digest();
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual IMemoable Copy();
}
public abstract class Org.BouncyCastle.Crypto.Digests.Gost3411_2012Digest : object {
    private Byte[] IV;
    private Byte[] N;
    private Byte[] Sigma;
    private Byte[] Ki;
    private Byte[] m;
    private Byte[] h;
    private Byte[] tmp;
    private Byte[] block;
    private int bOff;
    private static Byte[][] C;
    private static Byte[] Zero;
    private static UInt64[][] T;
    public string AlgorithmName { get; }
    protected Gost3411_2012Digest(Byte[] IV);
    private static Gost3411_2012Digest();
    public abstract virtual string get_AlgorithmName();
    public abstract virtual IMemoable Copy();
    public virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual int GetByteLength();
    public abstract virtual int GetDigestSize();
    public sealed virtual void Reset();
    public sealed virtual void Reset(IMemoable other);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    private void F(Byte[] V);
    private void xor512(Byte[] A, Byte[] B);
    private void E(Byte[] K, Byte[] m);
    private void g_N(Byte[] h, Byte[] N, Byte[] m);
    private void addMod512(Byte[] A, int num);
    private void addMod512(Byte[] A, Byte[] B);
    private void reverse(Byte[] src, Byte[] dst);
}
public class Org.BouncyCastle.Crypto.Digests.Gost3411Digest : object {
    private static int DIGEST_LENGTH;
    private Byte[] H;
    private Byte[] L;
    private Byte[] M;
    private Byte[] Sum;
    private Byte[][] C;
    private Byte[] xBuf;
    private int xBufOff;
    private ulong byteCount;
    private IBlockCipher cipher;
    private Byte[] sBox;
    private Byte[] K;
    private Byte[] a;
    internal Int16[] wS;
    internal Int16[] w_S;
    internal Byte[] S;
    internal Byte[] U;
    internal Byte[] V;
    internal Byte[] W;
    private static Byte[] C2;
    public string AlgorithmName { get; }
    public Gost3411Digest(Byte[] sBoxParam);
    public Gost3411Digest(Gost3411Digest t);
    private static Gost3411Digest();
    private static Byte[][] MakeC();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    private Byte[] P(Byte[] input);
    private Byte[] A(Byte[] input);
    private void E(Byte[] key, Byte[] s, int sOff, Byte[] input, int inOff);
    private void fw(Byte[] input);
    private void processBlock(Byte[] input, int inOff);
    private void finish();
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void sumByteArray(Byte[] input);
    private static void cpyBytesToShort(Byte[] S, Int16[] wS);
    private static void cpyShortToBytes(Int16[] wS, Byte[] S);
    public sealed virtual int GetByteLength();
    public sealed virtual IMemoable Copy();
    public sealed virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.KeccakDigest : object {
    private static UInt64[] KeccakRoundConstants;
    private UInt64[] state;
    protected Byte[] dataQueue;
    protected int rate;
    protected int bitsInQueue;
    protected internal int fixedOutputLength;
    protected bool squeezing;
    public string AlgorithmName { get; }
    public KeccakDigest(int bitLength);
    public KeccakDigest(KeccakDigest source);
    private static KeccakDigest();
    private void CopyIn(KeccakDigest source);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public virtual int DoFinal(Byte[] output, int outOff);
    protected virtual int DoFinal(Byte[] output, int outOff, byte partialByte, int partialBits);
    public virtual void Reset();
    public virtual int GetByteLength();
    private void Init(int bitLength);
    private void InitSponge(int rate);
    protected void Absorb(byte data);
    protected void Absorb(Byte[] data, int off, int len);
    protected void AbsorbBits(int data, int bits);
    private void PadAndSwitchToSqueezingPhase();
    protected void Squeeze(Byte[] output, int offset, long outputLength);
    private void KeccakAbsorb(Byte[] data, int off);
    private void KeccakExtract();
    private void KeccakPermutation();
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public abstract class Org.BouncyCastle.Crypto.Digests.LongDigest : object {
    private int MyByteLength;
    private Byte[] xBuf;
    private int xBufOff;
    private long byteCount1;
    private long byteCount2;
    internal ulong H1;
    internal ulong H2;
    internal ulong H3;
    internal ulong H4;
    internal ulong H5;
    internal ulong H6;
    internal ulong H7;
    internal ulong H8;
    private UInt64[] W;
    private int wOff;
    internal static UInt64[] K;
    public string AlgorithmName { get; }
    internal LongDigest(LongDigest t);
    private static LongDigest();
    protected void CopyIn(LongDigest t);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public void Finish();
    public virtual void Reset();
    internal void ProcessWord(Byte[] input, int inOff);
    private void AdjustByteCounts();
    internal void ProcessLength(long lowW, long hiW);
    internal void ProcessBlock();
    private static ulong Ch(ulong x, ulong y, ulong z);
    private static ulong Maj(ulong x, ulong y, ulong z);
    private static ulong Sum0(ulong x);
    private static ulong Sum1(ulong x);
    private static ulong Sigma0(ulong x);
    private static ulong Sigma1(ulong x);
    public sealed virtual int GetByteLength();
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int GetDigestSize();
    public abstract virtual int DoFinal(Byte[] output, int outOff);
    public abstract virtual IMemoable Copy();
    public abstract virtual void Reset(IMemoable t);
}
public class Org.BouncyCastle.Crypto.Digests.MD2Digest : object {
    private static int DigestLength;
    private static int BYTE_LENGTH;
    private Byte[] X;
    private int xOff;
    private Byte[] M;
    private int mOff;
    private Byte[] C;
    private int COff;
    private static Byte[] S;
    public string AlgorithmName { get; }
    public MD2Digest(MD2Digest t);
    private static MD2Digest();
    private void CopyIn(MD2Digest t);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual int GetByteLength();
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    internal void ProcessChecksum(Byte[] m);
    internal void ProcessBlock(Byte[] m);
    public sealed virtual IMemoable Copy();
    public sealed virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.MD4Digest : GeneralDigest {
    private static int DigestLength;
    private int H1;
    private int H2;
    private int H3;
    private int H4;
    private Int32[] X;
    private int xOff;
    private static int S11;
    private static int S12;
    private static int S13;
    private static int S14;
    private static int S21;
    private static int S22;
    private static int S23;
    private static int S24;
    private static int S31;
    private static int S32;
    private static int S33;
    private static int S34;
    public string AlgorithmName { get; }
    public MD4Digest(MD4Digest t);
    private void CopyIn(MD4Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    private void UnpackWord(int word, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private int RotateLeft(int x, int n);
    private int F(int u, int v, int w);
    private int G(int u, int v, int w);
    private int H(int u, int v, int w);
    internal virtual void ProcessBlock();
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.MD5Digest : GeneralDigest {
    private static int DigestLength;
    private UInt32 H1;
    private UInt32 H2;
    private UInt32 H3;
    private UInt32 H4;
    private UInt32[] X;
    private int xOff;
    private static int S11;
    private static int S12;
    private static int S13;
    private static int S14;
    private static int S21;
    private static int S22;
    private static int S23;
    private static int S24;
    private static int S31;
    private static int S32;
    private static int S33;
    private static int S34;
    private static int S41;
    private static int S42;
    private static int S43;
    private static int S44;
    public string AlgorithmName { get; }
    public MD5Digest(MD5Digest t);
    private static MD5Digest();
    private void CopyIn(MD5Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private static UInt32 RotateLeft(UInt32 x, int n);
    private static UInt32 F(UInt32 u, UInt32 v, UInt32 w);
    private static UInt32 G(UInt32 u, UInt32 v, UInt32 w);
    private static UInt32 H(UInt32 u, UInt32 v, UInt32 w);
    private static UInt32 K(UInt32 u, UInt32 v, UInt32 w);
    internal virtual void ProcessBlock();
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.NonMemoableDigest : object {
    protected IDigest mBaseDigest;
    public string AlgorithmName { get; }
    public NonMemoableDigest(IDigest baseDigest);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    public virtual int GetByteLength();
}
public class Org.BouncyCastle.Crypto.Digests.NullDigest : object {
    private MemoryStream bOut;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetByteLength();
    public sealed virtual int GetDigestSize();
    public sealed virtual void Update(byte b);
    public sealed virtual void BlockUpdate(Byte[] inBytes, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] outBytes, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Digests.ParallelHash : object {
    private static Byte[] N_PARALLEL_HASH;
    private CShakeDigest cshake;
    private CShakeDigest compressor;
    private int bitLength;
    private int outputLength;
    private int B;
    private Byte[] buffer;
    private Byte[] compressorBuffer;
    private bool firstOutput;
    private int nCount;
    private int bufOff;
    public string AlgorithmName { get; }
    public ParallelHash(int bitLength, Byte[] S, int B);
    public ParallelHash(int bitLength, Byte[] S, int B, int outputSize);
    public ParallelHash(ParallelHash source);
    private static ParallelHash();
    public virtual string get_AlgorithmName();
    public virtual int GetByteLength();
    public virtual int GetDigestSize();
    public virtual void Update(byte b);
    public virtual void BlockUpdate(Byte[] inBuf, int inOff, int len);
    private void compress();
    private void compress(Byte[] buf, int offSet, int len);
    private void wrapUp(int outputSize);
    public virtual int DoFinal(Byte[] outBuf, int outOff);
    public virtual int DoFinal(Byte[] outBuf, int outOff, int outLen);
    public virtual int DoOutput(Byte[] outBuf, int outOff, int outLen);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Digests.RipeMD128Digest : GeneralDigest {
    private static int DigestLength;
    private int H0;
    private int H1;
    private int H2;
    private int H3;
    private Int32[] X;
    private int xOff;
    public string AlgorithmName { get; }
    public RipeMD128Digest(RipeMD128Digest t);
    private void CopyIn(RipeMD128Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    private void UnpackWord(int word, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private int RL(int x, int n);
    private int F1(int x, int y, int z);
    private int F2(int x, int y, int z);
    private int F3(int x, int y, int z);
    private int F4(int x, int y, int z);
    private int F1(int a, int b, int c, int d, int x, int s);
    private int F2(int a, int b, int c, int d, int x, int s);
    private int F3(int a, int b, int c, int d, int x, int s);
    private int F4(int a, int b, int c, int d, int x, int s);
    private int FF1(int a, int b, int c, int d, int x, int s);
    private int FF2(int a, int b, int c, int d, int x, int s);
    private int FF3(int a, int b, int c, int d, int x, int s);
    private int FF4(int a, int b, int c, int d, int x, int s);
    internal virtual void ProcessBlock();
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.RipeMD160Digest : GeneralDigest {
    private static int DigestLength;
    private int H0;
    private int H1;
    private int H2;
    private int H3;
    private int H4;
    private Int32[] X;
    private int xOff;
    public string AlgorithmName { get; }
    public RipeMD160Digest(RipeMD160Digest t);
    private void CopyIn(RipeMD160Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    private void UnpackWord(int word, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private int RL(int x, int n);
    private int F1(int x, int y, int z);
    private int F2(int x, int y, int z);
    private int F3(int x, int y, int z);
    private int F4(int x, int y, int z);
    private int F5(int x, int y, int z);
    internal virtual void ProcessBlock();
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.RipeMD256Digest : GeneralDigest {
    private static int DigestLength;
    private int H0;
    private int H1;
    private int H2;
    private int H3;
    private int H4;
    private int H5;
    private int H6;
    private int H7;
    private Int32[] X;
    private int xOff;
    public string AlgorithmName { get; }
    public RipeMD256Digest(RipeMD256Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    private void CopyIn(RipeMD256Digest t);
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    private void UnpackWord(int word, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private int RL(int x, int n);
    private int F1(int x, int y, int z);
    private int F2(int x, int y, int z);
    private int F3(int x, int y, int z);
    private int F4(int x, int y, int z);
    private int F1(int a, int b, int c, int d, int x, int s);
    private int F2(int a, int b, int c, int d, int x, int s);
    private int F3(int a, int b, int c, int d, int x, int s);
    private int F4(int a, int b, int c, int d, int x, int s);
    private int FF1(int a, int b, int c, int d, int x, int s);
    private int FF2(int a, int b, int c, int d, int x, int s);
    private int FF3(int a, int b, int c, int d, int x, int s);
    private int FF4(int a, int b, int c, int d, int x, int s);
    internal virtual void ProcessBlock();
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.RipeMD320Digest : GeneralDigest {
    private static int DigestLength;
    private int H0;
    private int H1;
    private int H2;
    private int H3;
    private int H4;
    private int H5;
    private int H6;
    private int H7;
    private int H8;
    private int H9;
    private Int32[] X;
    private int xOff;
    public string AlgorithmName { get; }
    public RipeMD320Digest(RipeMD320Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    private void CopyIn(RipeMD320Digest t);
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    private void UnpackWord(int word, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private int RL(int x, int n);
    private int F1(int x, int y, int z);
    private int F2(int x, int y, int z);
    private int F3(int x, int y, int z);
    private int F4(int x, int y, int z);
    private int F5(int x, int y, int z);
    internal virtual void ProcessBlock();
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.Sha1Digest : GeneralDigest {
    private static int DigestLength;
    private UInt32 H1;
    private UInt32 H2;
    private UInt32 H3;
    private UInt32 H4;
    private UInt32 H5;
    private UInt32[] X;
    private int xOff;
    private static UInt32 Y1;
    private static UInt32 Y2;
    private static UInt32 Y3;
    private static UInt32 Y4;
    public string AlgorithmName { get; }
    public Sha1Digest(Sha1Digest t);
    private void CopyIn(Sha1Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private static UInt32 F(UInt32 u, UInt32 v, UInt32 w);
    private static UInt32 H(UInt32 u, UInt32 v, UInt32 w);
    private static UInt32 G(UInt32 u, UInt32 v, UInt32 w);
    internal virtual void ProcessBlock();
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.Sha224Digest : GeneralDigest {
    private static int DigestLength;
    private UInt32 H1;
    private UInt32 H2;
    private UInt32 H3;
    private UInt32 H4;
    private UInt32 H5;
    private UInt32 H6;
    private UInt32 H7;
    private UInt32 H8;
    private UInt32[] X;
    private int xOff;
    internal static UInt32[] K;
    public string AlgorithmName { get; }
    public Sha224Digest(Sha224Digest t);
    private static Sha224Digest();
    private void CopyIn(Sha224Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    internal virtual void ProcessBlock();
    private static UInt32 Ch(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 Maj(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 Sum0(UInt32 x);
    private static UInt32 Sum1(UInt32 x);
    private static UInt32 Theta0(UInt32 x);
    private static UInt32 Theta1(UInt32 x);
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.Sha256Digest : GeneralDigest {
    private static int DigestLength;
    private UInt32 H1;
    private UInt32 H2;
    private UInt32 H3;
    private UInt32 H4;
    private UInt32 H5;
    private UInt32 H6;
    private UInt32 H7;
    private UInt32 H8;
    private UInt32[] X;
    private int xOff;
    private static UInt32[] K;
    public string AlgorithmName { get; }
    public Sha256Digest(Sha256Digest t);
    private static Sha256Digest();
    private void CopyIn(Sha256Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private void initHs();
    internal virtual void ProcessBlock();
    private static UInt32 Sum1Ch(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 Sum0Maj(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 Theta0(UInt32 x);
    private static UInt32 Theta1(UInt32 x);
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.Sha384Digest : LongDigest {
    private static int DigestLength;
    public string AlgorithmName { get; }
    public Sha384Digest(Sha384Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.Sha3Digest : KeccakDigest {
    public string AlgorithmName { get; }
    public Sha3Digest(int bitLength);
    public Sha3Digest(Sha3Digest source);
    private static int CheckBitLength(int bitLength);
    public virtual string get_AlgorithmName();
    public virtual int DoFinal(Byte[] output, int outOff);
    protected virtual int DoFinal(Byte[] output, int outOff, byte partialByte, int partialBits);
    public virtual IMemoable Copy();
}
public class Org.BouncyCastle.Crypto.Digests.Sha512Digest : LongDigest {
    private static int DigestLength;
    public string AlgorithmName { get; }
    public Sha512Digest(Sha512Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.Sha512tDigest : LongDigest {
    private static ulong A5;
    private int digestLength;
    private ulong H1t;
    private ulong H2t;
    private ulong H3t;
    private ulong H4t;
    private ulong H5t;
    private ulong H6t;
    private ulong H7t;
    private ulong H8t;
    public string AlgorithmName { get; }
    public Sha512tDigest(int bitLength);
    public Sha512tDigest(Sha512tDigest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private void tIvGenerate(int bitLength);
    private static void UInt64_To_BE(ulong n, Byte[] bs, int off, int max);
    private static void UInt32_To_BE(UInt32 n, Byte[] bs, int off, int max);
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.ShakeDigest : KeccakDigest {
    public string AlgorithmName { get; }
    public ShakeDigest(int bitLength);
    public ShakeDigest(ShakeDigest source);
    private static int CheckBitLength(int bitLength);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff, int outLen);
    public virtual int DoOutput(Byte[] output, int outOff, int outLen);
    protected virtual int DoFinal(Byte[] output, int outOff, byte partialByte, int partialBits);
    protected virtual int DoFinal(Byte[] output, int outOff, int outLen, byte partialByte, int partialBits);
    public virtual IMemoable Copy();
}
public class Org.BouncyCastle.Crypto.Digests.ShortenedDigest : object {
    private IDigest baseDigest;
    private int length;
    public string AlgorithmName { get; }
    public ShortenedDigest(IDigest baseDigest, int length);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    public sealed virtual int GetByteLength();
}
public class Org.BouncyCastle.Crypto.Digests.SkeinDigest : object {
    public static int SKEIN_256;
    public static int SKEIN_512;
    public static int SKEIN_1024;
    private SkeinEngine engine;
    public string AlgorithmName { get; }
    public SkeinDigest(int stateSizeBits, int digestSizeBits);
    public SkeinDigest(SkeinDigest digest);
    public sealed virtual void Reset(IMemoable other);
    public sealed virtual IMemoable Copy();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual int GetByteLength();
    public void Init(SkeinParameters parameters);
    public sealed virtual void Reset();
    public sealed virtual void Update(byte inByte);
    public sealed virtual void BlockUpdate(Byte[] inBytes, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Digests.SkeinEngine : object {
    public static int SKEIN_256;
    public static int SKEIN_512;
    public static int SKEIN_1024;
    private static int PARAM_TYPE_KEY;
    private static int PARAM_TYPE_CONFIG;
    private static int PARAM_TYPE_MESSAGE;
    private static int PARAM_TYPE_OUTPUT;
    private static IDictionary INITIAL_STATES;
    private ThreefishEngine threefish;
    private int outputSizeBytes;
    private UInt64[] chain;
    private UInt64[] initialState;
    private Byte[] key;
    private Parameter[] preMessageParameters;
    private Parameter[] postMessageParameters;
    private UBI ubi;
    private Byte[] singleByte;
    public int OutputSize { get; }
    public int BlockSize { get; }
    private static SkeinEngine();
    public SkeinEngine(int blockSizeBits, int outputSizeBits);
    public SkeinEngine(SkeinEngine engine);
    private static void InitialState(int blockSize, int outputSize, UInt64[] state);
    private static int VariantIdentifier(int blockSizeBytes, int outputSizeBytes);
    private void CopyIn(SkeinEngine engine);
    private static Parameter[] Clone(Parameter[] data, Parameter[] existing);
    public sealed virtual IMemoable Copy();
    public sealed virtual void Reset(IMemoable other);
    public int get_OutputSize();
    public int get_BlockSize();
    public void Init(SkeinParameters parameters);
    private void InitParams(IDictionary parameters);
    private void CreateInitialState();
    public void Reset();
    private void UbiComplete(int type, Byte[] value);
    private void UbiInit(int type);
    private void UbiFinal();
    private void CheckInitialised();
    public void Update(byte inByte);
    public void Update(Byte[] inBytes, int inOff, int len);
    public int DoFinal(Byte[] outBytes, int outOff);
    private void Output(ulong outputSequence, Byte[] outBytes, int outOff, int outputBytes);
}
public class Org.BouncyCastle.Crypto.Digests.SM3Digest : GeneralDigest {
    private static int DIGEST_LENGTH;
    private static int BLOCK_SIZE;
    private UInt32[] V;
    private UInt32[] inwords;
    private int xOff;
    private UInt32[] W;
    private static UInt32[] T;
    public string AlgorithmName { get; }
    private static SM3Digest();
    public SM3Digest(SM3Digest t);
    private void CopyIn(SM3Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
    public virtual void Reset();
    public virtual int DoFinal(Byte[] output, int outOff);
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    private UInt32 P0(UInt32 x);
    private UInt32 P1(UInt32 x);
    private UInt32 FF0(UInt32 x, UInt32 y, UInt32 z);
    private UInt32 FF1(UInt32 x, UInt32 y, UInt32 z);
    private UInt32 GG0(UInt32 x, UInt32 y, UInt32 z);
    private UInt32 GG1(UInt32 x, UInt32 y, UInt32 z);
    internal virtual void ProcessBlock();
}
public class Org.BouncyCastle.Crypto.Digests.TigerDigest : object {
    private static int MyByteLength;
    private static Int64[] t1;
    private static Int64[] t2;
    private static Int64[] t3;
    private static Int64[] t4;
    private static int DigestLength;
    private long a;
    private long b;
    private long c;
    private long byteCount;
    private Byte[] Buffer;
    private int bOff;
    private Int64[] x;
    private int xOff;
    public string AlgorithmName { get; }
    public TigerDigest(TigerDigest t);
    private static TigerDigest();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual int GetByteLength();
    private void ProcessWord(Byte[] b, int off);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    private void RoundABC(long x, long mul);
    private void RoundBCA(long x, long mul);
    private void RoundCAB(long x, long mul);
    private void KeySchedule();
    private void ProcessBlock();
    private void UnpackWord(long r, Byte[] output, int outOff);
    private void ProcessLength(long bitLength);
    private void Finish();
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    public sealed virtual IMemoable Copy();
    public sealed virtual void Reset(IMemoable other);
}
public class Org.BouncyCastle.Crypto.Digests.TupleHash : object {
    private static Byte[] N_TUPLE_HASH;
    private CShakeDigest cshake;
    private int bitLength;
    private int outputLength;
    private bool firstOutput;
    public string AlgorithmName { get; }
    public TupleHash(int bitLength, Byte[] S);
    public TupleHash(int bitLength, Byte[] S, int outputSize);
    public TupleHash(TupleHash original);
    private static TupleHash();
    public virtual string get_AlgorithmName();
    public virtual int GetByteLength();
    public virtual int GetDigestSize();
    public virtual void Update(byte b);
    public virtual void BlockUpdate(Byte[] inBuf, int inOff, int len);
    private void wrapUp(int outputSize);
    public virtual int DoFinal(Byte[] outBuf, int outOff);
    public virtual int DoFinal(Byte[] outBuf, int outOff, int outLen);
    public virtual int DoOutput(Byte[] outBuf, int outOff, int outLen);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Digests.WhirlpoolDigest : object {
    private static int BYTE_LENGTH;
    private static int DIGEST_LENGTH_BYTES;
    private static int ROUNDS;
    private static int REDUCTION_POLYNOMIAL;
    private static Int32[] SBOX;
    private static Int64[] C0;
    private static Int64[] C1;
    private static Int64[] C2;
    private static Int64[] C3;
    private static Int64[] C4;
    private static Int64[] C5;
    private static Int64[] C6;
    private static Int64[] C7;
    private Int64[] _rc;
    private static Int16[] EIGHT;
    private static int BITCOUNT_ARRAY_SIZE;
    private Byte[] _buffer;
    private int _bufferPos;
    private Int16[] _bitCount;
    private Int64[] _hash;
    private Int64[] _K;
    private Int64[] _L;
    private Int64[] _block;
    private Int64[] _state;
    public string AlgorithmName { get; }
    private static WhirlpoolDigest();
    public WhirlpoolDigest(WhirlpoolDigest originalDigest);
    private static long packIntoLong(int b7, int b6, int b5, int b4, int b3, int b2, int b1, int b0);
    private static int maskWithReductionPolynomial(int input);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void processFilledBuffer();
    private static long bytesToLongFromBuffer(Byte[] buffer, int startPos);
    private static void convertLongToByteArray(long inputLong, Byte[] outputArray, int offSet);
    private void processBlock();
    public sealed virtual void Update(byte input);
    private void increment();
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    private void finish();
    private Byte[] copyBitLength();
    public sealed virtual int GetByteLength();
    public sealed virtual IMemoable Copy();
    public sealed virtual void Reset(IMemoable other);
}
internal class Org.BouncyCastle.Crypto.Digests.XofUtilities : object {
    internal static Byte[] LeftEncode(long strLen);
    internal static Byte[] RightEncode(long strLen);
    internal static Byte[] Encode(byte X);
    internal static Byte[] Encode(Byte[] inBuf, int inOff, int len);
}
public class Org.BouncyCastle.Crypto.EC.CustomNamedCurves : object {
    private static IDictionary nameToCurve;
    private static IDictionary nameToOid;
    private static IDictionary oidToCurve;
    private static IDictionary oidToName;
    private static IList names;
    public static IEnumerable Names { get; }
    private static CustomNamedCurves();
    private static X9ECPoint ConfigureBasepoint(ECCurve curve, string encoding);
    private static ECCurve ConfigureCurve(ECCurve curve);
    private static ECCurve ConfigureCurveGlv(ECCurve c, GlvTypeBParameters p);
    private static void DefineCurve(string name, X9ECParametersHolder holder);
    private static void DefineCurveWithOid(string name, DerObjectIdentifier oid, X9ECParametersHolder holder);
    private static void DefineCurveAlias(string name, DerObjectIdentifier oid);
    public static X9ECParameters GetByName(string name);
    public static X9ECParameters GetByOid(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static string GetName(DerObjectIdentifier oid);
    public static IEnumerable get_Names();
}
public class Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding : object {
    private static BigInteger Sixteen;
    private static BigInteger Six;
    private static Byte[] shadows;
    private static Byte[] inverse;
    private IAsymmetricBlockCipher engine;
    private bool forEncryption;
    private int bitSize;
    private int padBits;
    private BigInteger modulus;
    public string AlgorithmName { get; }
    public ISO9796d1Encoding(IAsymmetricBlockCipher cipher);
    private static ISO9796d1Encoding();
    public sealed virtual string get_AlgorithmName();
    public IAsymmetricBlockCipher GetUnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public void SetPadBits(int padBits);
    public int GetPadBits();
    public sealed virtual Byte[] ProcessBlock(Byte[] input, int inOff, int length);
    private Byte[] EncodeBlock(Byte[] input, int inOff, int inLen);
    private Byte[] DecodeBlock(Byte[] input, int inOff, int inLen);
}
public class Org.BouncyCastle.Crypto.Encodings.OaepEncoding : object {
    private Byte[] defHash;
    private IDigest mgf1Hash;
    private IAsymmetricBlockCipher engine;
    private SecureRandom random;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public OaepEncoding(IAsymmetricBlockCipher cipher);
    public OaepEncoding(IAsymmetricBlockCipher cipher, IDigest hash);
    public OaepEncoding(IAsymmetricBlockCipher cipher, IDigest hash, Byte[] encodingParams);
    public OaepEncoding(IAsymmetricBlockCipher cipher, IDigest hash, IDigest mgf1Hash, Byte[] encodingParams);
    public IAsymmetricBlockCipher GetUnderlyingCipher();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forEncryption, ICipherParameters param);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public sealed virtual Byte[] ProcessBlock(Byte[] inBytes, int inOff, int inLen);
    private Byte[] EncodeBlock(Byte[] inBytes, int inOff, int inLen);
    private Byte[] DecodeBlock(Byte[] inBytes, int inOff, int inLen);
    private Byte[] MaskGeneratorFunction(Byte[] Z, int zOff, int zLen, int length);
    private Byte[] MaskGeneratorFunction1(Byte[] Z, int zOff, int zLen, int length);
}
public class Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding : object {
    public static string StrictLengthEnabledProperty;
    private static int HeaderLength;
    private static Boolean[] strictLengthEnabled;
    private SecureRandom random;
    private IAsymmetricBlockCipher engine;
    private bool forEncryption;
    private bool forPrivateKey;
    private bool useStrictLength;
    private int pLen;
    private Byte[] fallback;
    private Byte[] blockBuffer;
    public static bool StrictLengthEnabled { get; public set; }
    public string AlgorithmName { get; }
    private static Pkcs1Encoding();
    public Pkcs1Encoding(IAsymmetricBlockCipher cipher);
    public Pkcs1Encoding(IAsymmetricBlockCipher cipher, int pLen);
    public Pkcs1Encoding(IAsymmetricBlockCipher cipher, Byte[] fallback);
    public static bool get_StrictLengthEnabled();
    public static void set_StrictLengthEnabled(bool value);
    public IAsymmetricBlockCipher GetUnderlyingCipher();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public sealed virtual Byte[] ProcessBlock(Byte[] input, int inOff, int length);
    private Byte[] EncodeBlock(Byte[] input, int inOff, int inLen);
    private static int CheckPkcs1Encoding(Byte[] encoded, int pLen);
    private Byte[] DecodeBlockOrRandom(Byte[] input, int inOff, int inLen);
    private Byte[] DecodeBlock(Byte[] input, int inOff, int inLen);
    private int FindStart(byte type, Byte[] block);
}
public class Org.BouncyCastle.Crypto.Engines.AesEngine : object {
    private static Byte[] S;
    private static Byte[] Si;
    private static Byte[] rcon;
    private static UInt32[] T0;
    private static UInt32[] Tinv0;
    private static UInt32 m1;
    private static UInt32 m2;
    private static UInt32 m3;
    private static UInt32 m4;
    private static UInt32 m5;
    private int ROUNDS;
    private UInt32[][] WorkingKey;
    private bool forEncryption;
    private Byte[] s;
    private static int BLOCK_SIZE;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static AesEngine();
    private static UInt32 Shift(UInt32 r, int shift);
    private static UInt32 FFmulX(UInt32 x);
    private static UInt32 FFmulX2(UInt32 x);
    private static UInt32 Inv_Mcol(UInt32 x);
    private static UInt32 SubWord(UInt32 x);
    private UInt32[][] GenerateWorkingKey(Byte[] key, bool forEncryption);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
    private void EncryptBlock(Byte[] input, int inOff, Byte[] output, int outOff, UInt32[][] KW);
    private void DecryptBlock(Byte[] input, int inOff, Byte[] output, int outOff, UInt32[][] KW);
}
[ObsoleteAttribute("Use AesEngine instead")]
public class Org.BouncyCastle.Crypto.Engines.AesFastEngine : object {
    private static Byte[] S;
    private static Byte[] Si;
    private static Byte[] rcon;
    private static UInt32[] T0;
    private static UInt32[] T1;
    private static UInt32[] T2;
    private static UInt32[] T3;
    private static UInt32[] Tinv0;
    private static UInt32[] Tinv1;
    private static UInt32[] Tinv2;
    private static UInt32[] Tinv3;
    private static UInt32 m1;
    private static UInt32 m2;
    private static UInt32 m3;
    private static UInt32 m4;
    private static UInt32 m5;
    private int ROUNDS;
    private UInt32[][] WorkingKey;
    private bool forEncryption;
    private static int BLOCK_SIZE;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static AesFastEngine();
    private static UInt32 Shift(UInt32 r, int shift);
    private static UInt32 FFmulX(UInt32 x);
    private static UInt32 FFmulX2(UInt32 x);
    private static UInt32 Inv_Mcol(UInt32 x);
    private static UInt32 SubWord(UInt32 x);
    private UInt32[][] GenerateWorkingKey(Byte[] key, bool forEncryption);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
    private void EncryptBlock(Byte[] input, int inOff, Byte[] output, int outOff, UInt32[][] KW);
    private void DecryptBlock(Byte[] input, int inOff, Byte[] output, int outOff, UInt32[][] KW);
}
public class Org.BouncyCastle.Crypto.Engines.AesLightEngine : object {
    private static Byte[] S;
    private static Byte[] Si;
    private static Byte[] rcon;
    private static UInt32 m1;
    private static UInt32 m2;
    private static UInt32 m3;
    private static UInt32 m4;
    private static UInt32 m5;
    private int ROUNDS;
    private UInt32[][] WorkingKey;
    private bool forEncryption;
    private static int BLOCK_SIZE;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static AesLightEngine();
    private static UInt32 Shift(UInt32 r, int shift);
    private static UInt32 FFmulX(UInt32 x);
    private static UInt32 FFmulX2(UInt32 x);
    private static UInt32 Mcol(UInt32 x);
    private static UInt32 Inv_Mcol(UInt32 x);
    private static UInt32 SubWord(UInt32 x);
    private UInt32[][] GenerateWorkingKey(Byte[] key, bool forEncryption);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
    private void EncryptBlock(Byte[] input, int inOff, Byte[] output, int outOff, UInt32[][] KW);
    private void DecryptBlock(Byte[] input, int inOff, Byte[] output, int outOff, UInt32[][] KW);
}
public class Org.BouncyCastle.Crypto.Engines.AesWrapEngine : Rfc3394WrapEngine {
}
public class Org.BouncyCastle.Crypto.Engines.AriaEngine : object {
    private static Byte[][] C;
    private static Byte[] SB1_sbox;
    private static Byte[] SB2_sbox;
    private static Byte[] SB3_sbox;
    private static Byte[] SB4_sbox;
    protected static int BlockSize;
    private Byte[][] m_roundKeys;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static AriaEngine();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
    protected static void A(Byte[] z);
    protected static void FE(Byte[] D, Byte[] RK);
    protected static void FO(Byte[] D, Byte[] RK);
    protected static Byte[][] KeySchedule(bool forEncryption, Byte[] K);
    protected static Byte[] KeyScheduleRound(Byte[] w, Byte[] wr, int n);
    protected static void ReverseKeys(Byte[][] keys);
    protected static byte SB1(byte x);
    protected static byte SB2(byte x);
    protected static byte SB3(byte x);
    protected static byte SB4(byte x);
    protected static void SL1(Byte[] z);
    protected static void SL2(Byte[] z);
    protected static void Xor(Byte[] z, Byte[] x);
}
public class Org.BouncyCastle.Crypto.Engines.BlowfishEngine : object {
    private static UInt32[] KP;
    private static UInt32[] KS0;
    private static UInt32[] KS1;
    private static UInt32[] KS2;
    private static UInt32[] KS3;
    private static int ROUNDS;
    private static int BLOCK_SIZE;
    private static int SBOX_SK;
    private static int P_SZ;
    private UInt32[] S0;
    private UInt32[] S1;
    private UInt32[] S2;
    private UInt32[] S3;
    private UInt32[] P;
    private bool encrypting;
    private Byte[] workingKey;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static BlowfishEngine();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    public sealed virtual int GetBlockSize();
    private UInt32 F(UInt32 x);
    private void ProcessTable(UInt32 xl, UInt32 xr, UInt32[] table);
    private void SetKey(Byte[] key);
    private void EncryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    private void DecryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
}
public class Org.BouncyCastle.Crypto.Engines.CamelliaEngine : object {
    private bool initialised;
    private bool _keyIs128;
    private static int BLOCK_SIZE;
    private UInt32[] subkey;
    private UInt32[] kw;
    private UInt32[] ke;
    private UInt32[] state;
    private static UInt32[] SIGMA;
    private static UInt32[] SBOX1_1110;
    private static UInt32[] SBOX4_4404;
    private static UInt32[] SBOX2_0222;
    private static UInt32[] SBOX3_3033;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static CamelliaEngine();
    private static UInt32 rightRotate(UInt32 x, int s);
    private static UInt32 leftRotate(UInt32 x, int s);
    private static void roldq(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static void decroldq(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static void roldqo32(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static void decroldqo32(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static UInt32 bytes2uint(Byte[] src, int offset);
    private static void uint2bytes(UInt32 word, Byte[] dst, int offset);
    private static void camelliaF2(UInt32[] s, UInt32[] skey, int keyoff);
    private static void camelliaFLs(UInt32[] s, UInt32[] fkey, int keyoff);
    private void setKey(bool forEncryption, Byte[] key);
    private int processBlock128(Byte[] input, int inOff, Byte[] output, int outOff);
    private int processBlock192or256(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Engines.CamelliaLightEngine : object {
    private static int BLOCK_SIZE;
    private bool initialised;
    private bool _keyis128;
    private UInt32[] subkey;
    private UInt32[] kw;
    private UInt32[] ke;
    private UInt32[] state;
    private static UInt32[] SIGMA;
    private static Byte[] SBOX1;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static CamelliaLightEngine();
    private static UInt32 rightRotate(UInt32 x, int s);
    private static UInt32 leftRotate(UInt32 x, int s);
    private static void roldq(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static void decroldq(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static void roldqo32(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static void decroldqo32(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static UInt32 bytes2uint(Byte[] src, int offset);
    private static void uint2bytes(UInt32 word, Byte[] dst, int offset);
    private byte lRot8(byte v, int rot);
    private UInt32 sbox2(int x);
    private UInt32 sbox3(int x);
    private UInt32 sbox4(int x);
    private void camelliaF2(UInt32[] s, UInt32[] skey, int keyoff);
    private void camelliaFLs(UInt32[] s, UInt32[] fkey, int keyoff);
    private void setKey(bool forEncryption, Byte[] key);
    private int processBlock128(Byte[] input, int inOff, Byte[] output, int outOff);
    private int processBlock192or256(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Engines.CamelliaWrapEngine : Rfc3394WrapEngine {
}
public class Org.BouncyCastle.Crypto.Engines.Cast5Engine : object {
    private static UInt32[] S1;
    private static UInt32[] S2;
    private static UInt32[] S3;
    private static UInt32[] S4;
    private static UInt32[] S5;
    private static UInt32[] S6;
    private static UInt32[] S7;
    private static UInt32[] S8;
    internal static int MAX_ROUNDS;
    internal static int RED_ROUNDS;
    private static int BLOCK_SIZE;
    private Int32[] _Kr;
    private UInt32[] _Km;
    private bool _encrypting;
    private Byte[] _workingKey;
    private int _rounds;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static Cast5Engine();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
    public virtual int GetBlockSize();
    internal virtual void SetKey(Byte[] key);
    internal virtual int EncryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    internal virtual int DecryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    internal static UInt32 F1(UInt32 D, UInt32 Kmi, int Kri);
    internal static UInt32 F2(UInt32 D, UInt32 Kmi, int Kri);
    internal static UInt32 F3(UInt32 D, UInt32 Kmi, int Kri);
    internal void CAST_Encipher(UInt32 L0, UInt32 R0, UInt32[] result);
    internal void CAST_Decipher(UInt32 L16, UInt32 R16, UInt32[] result);
    internal static void Bits32ToInts(UInt32 inData, Int32[] b, int offset);
    internal static UInt32 IntsTo32bits(Int32[] b, int i);
}
public class Org.BouncyCastle.Crypto.Engines.Cast6Engine : Cast5Engine {
    private static int ROUNDS;
    private static int BLOCK_SIZE;
    private Int32[] _Kr;
    private UInt32[] _Km;
    private Int32[] _Tr;
    private UInt32[] _Tm;
    private UInt32[] _workingKey;
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    public virtual void Reset();
    public virtual int GetBlockSize();
    internal virtual void SetKey(Byte[] key);
    internal virtual int EncryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    internal virtual int DecryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    private void CAST_Encipher(UInt32 A, UInt32 B, UInt32 C, UInt32 D, UInt32[] result);
    private void CAST_Decipher(UInt32 A, UInt32 B, UInt32 C, UInt32 D, UInt32[] result);
}
public class Org.BouncyCastle.Crypto.Engines.ChaCha7539Engine : Salsa20Engine {
    public string AlgorithmName { get; }
    protected int NonceSize { get; }
    public virtual string get_AlgorithmName();
    protected virtual int get_NonceSize();
    protected virtual void AdvanceCounter();
    protected virtual void ResetCounter();
    protected virtual void SetKey(Byte[] keyBytes, Byte[] ivBytes);
    protected virtual void GenerateKeyStream(Byte[] output);
}
public class Org.BouncyCastle.Crypto.Engines.ChaChaEngine : Salsa20Engine {
    public string AlgorithmName { get; }
    public ChaChaEngine(int rounds);
    public virtual string get_AlgorithmName();
    protected virtual void AdvanceCounter();
    protected virtual void ResetCounter();
    protected virtual void SetKey(Byte[] keyBytes, Byte[] ivBytes);
    protected virtual void GenerateKeyStream(Byte[] output);
    internal static void ChachaCore(int rounds, UInt32[] input, UInt32[] x);
}
public class Org.BouncyCastle.Crypto.Engines.DesEdeEngine : DesEngine {
    private Int32[] workingKey1;
    private Int32[] workingKey2;
    private Int32[] workingKey3;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine : object {
    private CbcBlockCipher engine;
    private KeyParameter param;
    private ParametersWithIV paramPlusIV;
    private Byte[] iv;
    private bool forWrapping;
    private static Byte[] IV2;
    private IDigest sha1;
    private Byte[] digest;
    public string AlgorithmName { get; }
    private static DesEdeWrapEngine();
    public virtual void Init(bool forWrapping, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual Byte[] Wrap(Byte[] input, int inOff, int length);
    public virtual Byte[] Unwrap(Byte[] input, int inOff, int length);
    private Byte[] CalculateCmsKeyChecksum(Byte[] key);
    private bool CheckCmsKeyChecksum(Byte[] key, Byte[] checksum);
    private static Byte[] reverse(Byte[] bs);
}
public class Org.BouncyCastle.Crypto.Engines.DesEngine : object {
    internal static int BLOCK_SIZE;
    private Int32[] workingKey;
    private static Int16[] bytebit;
    private static Int32[] bigbyte;
    private static Byte[] pc1;
    private static Byte[] totrot;
    private static Byte[] pc2;
    private static UInt32[] SP1;
    private static UInt32[] SP2;
    private static UInt32[] SP3;
    private static UInt32[] SP4;
    private static UInt32[] SP5;
    private static UInt32[] SP6;
    private static UInt32[] SP7;
    private static UInt32[] SP8;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static DesEngine();
    public virtual Int32[] GetWorkingKey();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
    protected static Int32[] GenerateWorkingKey(bool encrypting, Byte[] key);
    internal static void DesFunc(Int32[] wKey, Byte[] input, int inOff, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.Dstu7624Engine : object {
    private UInt64[] internalState;
    private UInt64[] workingKey;
    private UInt64[][] roundKeys;
    private int wordsInBlock;
    private int wordsInKey;
    private static int ROUNDS_128;
    private static int ROUNDS_256;
    private static int ROUNDS_512;
    private int roundsAmount;
    private bool forEncryption;
    private static ulong mdsMatrix;
    private static ulong mdsInvMatrix;
    private static Byte[] S0;
    private static Byte[] S1;
    private static Byte[] S2;
    private static Byte[] S3;
    private static Byte[] T0;
    private static Byte[] T1;
    private static Byte[] T2;
    private static Byte[] T3;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public Dstu7624Engine(int blockSizeBits);
    private static Dstu7624Engine();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    private void WorkingKeyExpandKT(UInt64[] workingKey, UInt64[] tempKeys);
    private void WorkingKeyExpandEven(UInt64[] workingKey, UInt64[] tempKey);
    private void WorkingKeyExpandOdd();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    private void EncryptionRound();
    private void DecryptionRound();
    private void DecryptBlock_128(Byte[] input, int inOff, Byte[] output, int outOff);
    private void EncryptBlock_128(Byte[] input, int inOff, Byte[] output, int outOff);
    private void SubBytes();
    private void InvSubBytes();
    private void ShiftRows();
    private void InvShiftRows();
    private void AddRoundKey(int round);
    private void SubRoundKey(int round);
    private void XorRoundKey(int round);
    private static ulong MixColumn(ulong c);
    private void MixColumns();
    private static ulong MixColumnInv(ulong c);
    private void MixColumnsInv();
    private static ulong MulX(ulong n);
    private static ulong MulX2(ulong n);
    private static ulong Rotate(int n, ulong x);
    private void RotateLeft(UInt64[] x, UInt64[] z);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual bool get_IsPartialBlockOkay();
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Engines.Dstu7624WrapEngine : object {
    private KeyParameter param;
    private Dstu7624Engine engine;
    private bool forWrapping;
    private int blockSize;
    public string AlgorithmName { get; }
    public Dstu7624WrapEngine(int blockSizeBits);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forWrapping, ICipherParameters parameters);
    public sealed virtual Byte[] Wrap(Byte[] input, int inOff, int length);
    public sealed virtual Byte[] Unwrap(Byte[] input, int inOff, int length);
}
public class Org.BouncyCastle.Crypto.Engines.ElGamalEngine : object {
    private ElGamalKeyParameters key;
    private SecureRandom random;
    private bool forEncryption;
    private int bitSize;
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetInputBlockSize();
    public virtual int GetOutputBlockSize();
    public virtual Byte[] ProcessBlock(Byte[] input, int inOff, int length);
}
public class Org.BouncyCastle.Crypto.Engines.Gost28147Engine : object {
    private static int BlockSize;
    private Int32[] workingKey;
    private bool forEncryption;
    private Byte[] S;
    private static Byte[] Sbox_Default;
    private static Byte[] ESbox_Test;
    private static Byte[] ESbox_A;
    private static Byte[] ESbox_B;
    private static Byte[] ESbox_C;
    private static Byte[] ESbox_D;
    private static Byte[] DSbox_Test;
    private static Byte[] DSbox_A;
    private static IDictionary sBoxes;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static Gost28147Engine();
    private static void AddSBox(string sBoxName, Byte[] sBox);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
    private Int32[] generateWorkingKey(bool forEncryption, Byte[] userKey);
    private int Gost28147_mainStep(int n1, int key);
    private void Gost28147Func(Int32[] workingKey, Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
    private static int bytesToint(Byte[] inBytes, int inOff);
    private static void intTobytes(int num, Byte[] outBytes, int outOff);
    public static Byte[] GetSBox(string sBoxName);
    public static string GetSBoxName(Byte[] sBox);
}
public class Org.BouncyCastle.Crypto.Engines.HC128Engine : object {
    private UInt32[] p;
    private UInt32[] q;
    private UInt32 cnt;
    private Byte[] key;
    private Byte[] iv;
    private bool initialised;
    private Byte[] buf;
    private int idx;
    public string AlgorithmName { get; }
    private static UInt32 F1(UInt32 x);
    private static UInt32 F2(UInt32 x);
    private UInt32 G1(UInt32 x, UInt32 y, UInt32 z);
    private UInt32 G2(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 RotateLeft(UInt32 x, int bits);
    private static UInt32 RotateRight(UInt32 x, int bits);
    private UInt32 H1(UInt32 x);
    private UInt32 H2(UInt32 x);
    private static UInt32 Mod1024(UInt32 x);
    private static UInt32 Mod512(UInt32 x);
    private static UInt32 Dim(UInt32 x, UInt32 y);
    private UInt32 Step();
    private void Init();
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    private byte GetByte();
    public virtual void ProcessBytes(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    public virtual void Reset();
    public virtual byte ReturnByte(byte input);
}
public class Org.BouncyCastle.Crypto.Engines.HC256Engine : object {
    private UInt32[] p;
    private UInt32[] q;
    private UInt32 cnt;
    private Byte[] key;
    private Byte[] iv;
    private bool initialised;
    private Byte[] buf;
    private int idx;
    public string AlgorithmName { get; }
    private UInt32 Step();
    private void Init();
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    private byte GetByte();
    public virtual void ProcessBytes(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    public virtual void Reset();
    public virtual byte ReturnByte(byte input);
    private static UInt32 RotateRight(UInt32 x, int bits);
}
public class Org.BouncyCastle.Crypto.Engines.IdeaEngine : object {
    private static int BLOCK_SIZE;
    private Int32[] workingKey;
    private static int MASK;
    private static int BASE;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static IdeaEngine();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
    private int BytesToWord(Byte[] input, int inOff);
    private void WordToBytes(int word, Byte[] outBytes, int outOff);
    private int Mul(int x, int y);
    private void IdeaFunc(Int32[] workingKey, Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private Int32[] ExpandKey(Byte[] uKey);
    private int MulInv(int x);
    private int AddInv(int x);
    private Int32[] InvertKey(Int32[] inKey);
    private Int32[] GenerateWorkingKey(bool forEncryption, Byte[] userKey);
}
public class Org.BouncyCastle.Crypto.Engines.IesEngine : object {
    private IBasicAgreement agree;
    private IDerivationFunction kdf;
    private IMac mac;
    private BufferedBlockCipher cipher;
    private Byte[] macBuf;
    private bool forEncryption;
    private ICipherParameters privParam;
    private ICipherParameters pubParam;
    private IesParameters param;
    public IesEngine(IBasicAgreement agree, IDerivationFunction kdf, IMac mac);
    public IesEngine(IBasicAgreement agree, IDerivationFunction kdf, IMac mac, BufferedBlockCipher cipher);
    public virtual void Init(bool forEncryption, ICipherParameters privParameters, ICipherParameters pubParameters, ICipherParameters iesParameters);
    private Byte[] DecryptBlock(Byte[] in_enc, int inOff, int inLen, Byte[] z);
    private Byte[] EncryptBlock(Byte[] input, int inOff, int inLen, Byte[] z);
    private Byte[] GenerateKdfBytes(KdfParameters kParam, int length);
    public virtual Byte[] ProcessBlock(Byte[] input, int inOff, int inLen);
}
public class Org.BouncyCastle.Crypto.Engines.IsaacEngine : object {
    private static int sizeL;
    private static int stateArraySize;
    private UInt32[] engineState;
    private UInt32[] results;
    private UInt32 a;
    private UInt32 b;
    private UInt32 c;
    private int index;
    private Byte[] keyStream;
    private Byte[] workingKey;
    private bool initialised;
    public string AlgorithmName { get; }
    private static IsaacEngine();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual byte ReturnByte(byte input);
    public virtual void ProcessBytes(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    public virtual string get_AlgorithmName();
    public virtual void Reset();
    private void setKey(Byte[] keyBytes);
    private void isaac();
    private void mix(UInt32[] x);
}
public class Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine : object {
    private bool forEncryption;
    private NaccacheSternKeyParameters key;
    private IList[] lookup;
    public string AlgorithmName { get; }
    [ObsoleteAttribute("Remove: no longer used")]
unknown bool Debug {public set; }
    public sealed virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual void set_Debug(bool value);
    public virtual int GetInputBlockSize();
    public virtual int GetOutputBlockSize();
    public virtual Byte[] ProcessBlock(Byte[] inBytes, int inOff, int length);
    public virtual Byte[] Encrypt(BigInteger plain);
    public virtual Byte[] AddCryptedBlocks(Byte[] block1, Byte[] block2);
    public virtual Byte[] ProcessData(Byte[] data);
    private static BigInteger chineseRemainder(IList congruences, IList primes);
}
public class Org.BouncyCastle.Crypto.Engines.NoekeonEngine : object {
    private static int Size;
    private static Byte[] RoundConstants;
    private UInt32[] k;
    private bool _initialised;
    private bool _forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static NoekeonEngine();
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
    private int EncryptBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    private int DecryptBlock(Byte[] input, int inOff, Byte[] output, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.NullEngine : object {
    private bool initialised;
    private static int BlockSize;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Engines.RC2Engine : object {
    private static Byte[] piTable;
    private static int BLOCK_SIZE;
    private Int32[] workingKey;
    private bool encrypting;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static RC2Engine();
    private Int32[] GenerateWorkingKey(Byte[] key, int bits);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual void Reset();
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    private int RotateWordLeft(int x, int y);
    private void EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private void DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.RC2WrapEngine : object {
    private CbcBlockCipher engine;
    private ICipherParameters parameters;
    private ParametersWithIV paramPlusIV;
    private Byte[] iv;
    private bool forWrapping;
    private SecureRandom sr;
    private static Byte[] IV2;
    private IDigest sha1;
    private Byte[] digest;
    public string AlgorithmName { get; }
    private static RC2WrapEngine();
    public virtual void Init(bool forWrapping, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual Byte[] Wrap(Byte[] input, int inOff, int length);
    public virtual Byte[] Unwrap(Byte[] input, int inOff, int length);
    private Byte[] CalculateCmsKeyChecksum(Byte[] key);
    private bool CheckCmsKeyChecksum(Byte[] key, Byte[] checksum);
}
public class Org.BouncyCastle.Crypto.Engines.RC4Engine : object {
    private static int STATE_LENGTH;
    private Byte[] engineState;
    private int x;
    private int y;
    private Byte[] workingKey;
    public string AlgorithmName { get; }
    private static RC4Engine();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual byte ReturnByte(byte input);
    public virtual void ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public virtual void Reset();
    private void SetKey(Byte[] keyBytes);
}
public class Org.BouncyCastle.Crypto.Engines.RC532Engine : object {
    private int _noRounds;
    private Int32[] _S;
    private static int P32;
    private static int Q32;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static RC532Engine();
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
    private void SetKey(Byte[] key);
    private int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int RotateLeft(int x, int y);
    private int RotateRight(int x, int y);
    private int BytesToWord(Byte[] src, int srcOff);
    private void WordToBytes(int word, Byte[] dst, int dstOff);
}
public class Org.BouncyCastle.Crypto.Engines.RC564Engine : object {
    private static int wordSize;
    private static int bytesPerWord;
    private int _noRounds;
    private Int64[] _S;
    private static long P64;
    private static long Q64;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static RC564Engine();
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
    private void SetKey(Byte[] key);
    private int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private long RotateLeft(long x, long y);
    private long RotateRight(long x, long y);
    private long BytesToWord(Byte[] src, int srcOff);
    private void WordToBytes(long word, Byte[] dst, int dstOff);
}
public class Org.BouncyCastle.Crypto.Engines.RC6Engine : object {
    private static int wordSize;
    private static int bytesPerWord;
    private static int _noRounds;
    private Int32[] _S;
    private static int P32;
    private static int Q32;
    private static int LGW;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static RC6Engine();
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
    private void SetKey(Byte[] key);
    private int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int RotateLeft(int x, int y);
    private int RotateRight(int x, int y);
    private int BytesToWord(Byte[] src, int srcOff);
    private void WordToBytes(int word, Byte[] dst, int dstOff);
}
public class Org.BouncyCastle.Crypto.Engines.Rfc3211WrapEngine : object {
    private CbcBlockCipher engine;
    private ParametersWithIV param;
    private bool forWrapping;
    private SecureRandom rand;
    public string AlgorithmName { get; }
    public Rfc3211WrapEngine(IBlockCipher engine);
    public virtual void Init(bool forWrapping, ICipherParameters param);
    public virtual string get_AlgorithmName();
    public virtual Byte[] Wrap(Byte[] inBytes, int inOff, int inLen);
    public virtual Byte[] Unwrap(Byte[] inBytes, int inOff, int inLen);
}
public class Org.BouncyCastle.Crypto.Engines.Rfc3394WrapEngine : object {
    private IBlockCipher engine;
    private KeyParameter param;
    private bool forWrapping;
    private Byte[] iv;
    public string AlgorithmName { get; }
    public Rfc3394WrapEngine(IBlockCipher engine);
    public virtual void Init(bool forWrapping, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual Byte[] Wrap(Byte[] input, int inOff, int inLen);
    public virtual Byte[] Unwrap(Byte[] input, int inOff, int inLen);
}
public class Org.BouncyCastle.Crypto.Engines.RijndaelEngine : object {
    private static int MAXROUNDS;
    private static int MAXKC;
    private static Byte[] Logtable;
    private static Byte[] Alogtable;
    private static Byte[] S;
    private static Byte[] Si;
    private static Byte[] rcon;
    private static Byte[][] shifts0;
    private static Byte[][] shifts1;
    private int BC;
    private long BC_MASK;
    private int ROUNDS;
    private int blockBits;
    private Int64[][] workingKey;
    private long A0;
    private long A1;
    private long A2;
    private long A3;
    private bool forEncryption;
    private Byte[] shifts0SC;
    private Byte[] shifts1SC;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public RijndaelEngine(int blockBits);
    private static RijndaelEngine();
    private byte Mul0x2(int b);
    private byte Mul0x3(int b);
    private byte Mul0x9(int b);
    private byte Mul0xb(int b);
    private byte Mul0xd(int b);
    private byte Mul0xe(int b);
    private void KeyAddition(Int64[] rk);
    private long Shift(long r, int shift);
    private void ShiftRow(Byte[] shiftsSC);
    private long ApplyS(long r, Byte[] box);
    private void Substitution(Byte[] box);
    private void MixColumn();
    private void InvMixColumn();
    private Int64[][] GenerateWorkingKey(Byte[] key);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
    private void UnPackBlock(Byte[] bytes, int off);
    private void PackBlock(Byte[] bytes, int off);
    private void EncryptBlock(Int64[][] rk);
    private void DecryptBlock(Int64[][] rk);
}
public class Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine : object {
    private IRsa core;
    private RsaKeyParameters key;
    private SecureRandom random;
    public string AlgorithmName { get; }
    public RsaBlindedEngine(IRsa rsa);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters param);
    public virtual int GetInputBlockSize();
    public virtual int GetOutputBlockSize();
    public virtual Byte[] ProcessBlock(Byte[] inBuf, int inOff, int inLen);
}
public class Org.BouncyCastle.Crypto.Engines.RsaBlindingEngine : object {
    private IRsa core;
    private RsaKeyParameters key;
    private BigInteger blindingFactor;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public RsaBlindingEngine(IRsa rsa);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters param);
    public virtual int GetInputBlockSize();
    public virtual int GetOutputBlockSize();
    public virtual Byte[] ProcessBlock(Byte[] inBuf, int inOff, int inLen);
    private BigInteger BlindMessage(BigInteger msg);
    private BigInteger UnblindMessage(BigInteger blindedMsg);
}
public class Org.BouncyCastle.Crypto.Engines.RsaCoreEngine : object {
    private RsaKeyParameters key;
    private bool forEncryption;
    private int bitSize;
    private void CheckInitialised();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetInputBlockSize();
    public virtual int GetOutputBlockSize();
    public virtual BigInteger ConvertInput(Byte[] inBuf, int inOff, int inLen);
    public virtual Byte[] ConvertOutput(BigInteger result);
    public virtual BigInteger ProcessBlock(BigInteger input);
}
public class Org.BouncyCastle.Crypto.Engines.RsaEngine : object {
    private IRsa core;
    public string AlgorithmName { get; }
    public RsaEngine(IRsa rsa);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetInputBlockSize();
    public virtual int GetOutputBlockSize();
    public virtual Byte[] ProcessBlock(Byte[] inBuf, int inOff, int inLen);
}
public class Org.BouncyCastle.Crypto.Engines.Salsa20Engine : object {
    public static int DEFAULT_ROUNDS;
    private static int StateSize;
    private static UInt32[] TAU_SIGMA;
    [ObsoleteAttribute]
protected static Byte[] sigma;
    [ObsoleteAttribute]
protected static Byte[] tau;
    protected int rounds;
    private int index;
    internal UInt32[] engineState;
    internal UInt32[] x;
    private Byte[] keyStream;
    private bool initialised;
    private UInt32 cW0;
    private UInt32 cW1;
    private UInt32 cW2;
    protected int NonceSize { get; }
    public string AlgorithmName { get; }
    public Salsa20Engine(int rounds);
    private static Salsa20Engine();
    internal void PackTauOrSigma(int keyLength, UInt32[] state, int stateOffset);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    protected virtual int get_NonceSize();
    public virtual string get_AlgorithmName();
    public virtual byte ReturnByte(byte input);
    protected virtual void AdvanceCounter();
    public virtual void ProcessBytes(Byte[] inBytes, int inOff, int len, Byte[] outBytes, int outOff);
    public virtual void Reset();
    protected virtual void ResetCounter();
    protected virtual void SetKey(Byte[] keyBytes, Byte[] ivBytes);
    protected virtual void GenerateKeyStream(Byte[] output);
    internal static void SalsaCore(int rounds, UInt32[] input, UInt32[] x);
    private void ResetLimitCounter();
    private bool LimitExceeded();
    private bool LimitExceeded(UInt32 len);
}
public class Org.BouncyCastle.Crypto.Engines.SeedEngine : object {
    private static int BlockSize;
    private static UInt32[] SS0;
    private static UInt32[] SS1;
    private static UInt32[] SS2;
    private static UInt32[] SS3;
    private static UInt32[] KC;
    private Int32[] wKey;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static SeedEngine();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] inBuf, int inOff, Byte[] outBuf, int outOff);
    public virtual void Reset();
    private Int32[] createWorkingKey(Byte[] inKey);
    private int extractW1(long lVal);
    private int extractW0(long lVal);
    private long rotateLeft8(long x);
    private long rotateRight8(long x);
    private long bytesToLong(Byte[] src, int srcOff);
    private void longToBytes(Byte[] dest, int destOff, long value);
    private int G(int x);
    private long F(int ki0, int ki1, long r);
    private int phaseCalc1(int r0, int ki0, int r1, int ki1);
    private int phaseCalc2(int r0, int ki0, int r1, int ki1);
}
public class Org.BouncyCastle.Crypto.Engines.SeedWrapEngine : Rfc3394WrapEngine {
}
public class Org.BouncyCastle.Crypto.Engines.SerpentEngine : SerpentEngineBase {
    protected virtual Int32[] MakeWorkingKey(Byte[] key);
    protected virtual void EncryptBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    protected virtual void DecryptBlock(Byte[] input, int inOff, Byte[] output, int outOff);
}
public abstract class Org.BouncyCastle.Crypto.Engines.SerpentEngineBase : object {
    protected static int BlockSize;
    internal static int ROUNDS;
    internal static int PHI;
    protected bool encrypting;
    protected Int32[] wKey;
    protected int X0;
    protected int X1;
    protected int X2;
    protected int X3;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static SerpentEngineBase();
    public virtual void Init(bool encrypting, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
    protected static int RotateLeft(int x, int bits);
    private static int RotateRight(int x, int bits);
    protected void Sb0(int a, int b, int c, int d);
    protected void Ib0(int a, int b, int c, int d);
    protected void Sb1(int a, int b, int c, int d);
    protected void Ib1(int a, int b, int c, int d);
    protected void Sb2(int a, int b, int c, int d);
    protected void Ib2(int a, int b, int c, int d);
    protected void Sb3(int a, int b, int c, int d);
    protected void Ib3(int a, int b, int c, int d);
    protected void Sb4(int a, int b, int c, int d);
    protected void Ib4(int a, int b, int c, int d);
    protected void Sb5(int a, int b, int c, int d);
    protected void Ib5(int a, int b, int c, int d);
    protected void Sb6(int a, int b, int c, int d);
    protected void Ib6(int a, int b, int c, int d);
    protected void Sb7(int a, int b, int c, int d);
    protected void Ib7(int a, int b, int c, int d);
    protected void LT();
    protected void InverseLT();
    protected abstract virtual Int32[] MakeWorkingKey(Byte[] key);
    protected abstract virtual void EncryptBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    protected abstract virtual void DecryptBlock(Byte[] input, int inOff, Byte[] output, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.SkipjackEngine : object {
    private static int BLOCK_SIZE;
    private static Int16[] ftable;
    private Int32[] key0;
    private Int32[] key1;
    private Int32[] key2;
    private Int32[] key3;
    private bool encrypting;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static SkipjackEngine();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
    private int G(int k, int w);
    public virtual int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int H(int k, int w);
    public virtual int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.SM2Engine : object {
    private IDigest mDigest;
    private bool mForEncryption;
    private ECKeyParameters mECKey;
    private ECDomainParameters mECParams;
    private int mCurveLength;
    private SecureRandom mRandom;
    public SM2Engine(IDigest digest);
    public virtual void Init(bool forEncryption, ICipherParameters param);
    public virtual Byte[] ProcessBlock(Byte[] input, int inOff, int inLen);
    protected virtual ECMultiplier CreateBasePointMultiplier();
    private Byte[] Encrypt(Byte[] input, int inOff, int inLen);
    private Byte[] Decrypt(Byte[] input, int inOff, int inLen);
    private bool NotEncrypted(Byte[] encData, Byte[] input, int inOff);
    private void Kdf(IDigest digest, ECPoint c1, Byte[] encData);
    private void Xor(Byte[] data, Byte[] kdfOut, int dOff, int dRemaining);
    private BigInteger NextK();
    private void AddFieldElement(IDigest digest, ECFieldElement v);
}
public class Org.BouncyCastle.Crypto.Engines.SM4Engine : object {
    private static int BlockSize;
    private static Byte[] Sbox;
    private static UInt32[] CK;
    private static UInt32[] FK;
    private UInt32[] rk;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static SM4Engine();
    private static UInt32 tau(UInt32 A);
    private static UInt32 L_ap(UInt32 B);
    private UInt32 T_ap(UInt32 Z);
    private void ExpandKey(bool forEncryption, Byte[] key);
    private static UInt32 L(UInt32 B);
    private static UInt32 T(UInt32 Z);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Engines.TeaEngine : object {
    private static int rounds;
    private static int block_size;
    private static UInt32 delta;
    private static UInt32 d_sum;
    private UInt32 _a;
    private UInt32 _b;
    private UInt32 _c;
    private UInt32 _d;
    private bool _initialised;
    private bool _forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int ProcessBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
    public virtual void Reset();
    private void setKey(Byte[] key);
    private int encryptBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
    private int decryptBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.ThreefishEngine : object {
    public static int BLOCKSIZE_256;
    public static int BLOCKSIZE_512;
    public static int BLOCKSIZE_1024;
    private static int TWEAK_SIZE_BYTES;
    private static int TWEAK_SIZE_WORDS;
    private static int ROUNDS_256;
    private static int ROUNDS_512;
    private static int ROUNDS_1024;
    private static int MAX_ROUNDS;
    private static ulong C_240;
    private static Int32[] MOD9;
    private static Int32[] MOD17;
    private static Int32[] MOD5;
    private static Int32[] MOD3;
    private int blocksizeBytes;
    private int blocksizeWords;
    private UInt64[] currentBlock;
    private UInt64[] t;
    private UInt64[] kw;
    private ThreefishCipher cipher;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static ThreefishEngine();
    public ThreefishEngine(int blocksizeBits);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    internal void Init(bool forEncryption, UInt64[] key, UInt64[] tweak);
    private void SetKey(UInt64[] key);
    private void SetTweak(UInt64[] tweak);
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual void Reset();
    public virtual int ProcessBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
    internal int ProcessBlock(UInt64[] inWords, UInt64[] outWords);
    internal static ulong BytesToWord(Byte[] bytes, int off);
    internal static void WordToBytes(ulong word, Byte[] bytes, int off);
    private static ulong RotlXor(ulong x, int n, ulong xor);
    private static ulong XorRotr(ulong x, int n, ulong xor);
}
public class Org.BouncyCastle.Crypto.Engines.TnepresEngine : SerpentEngineBase {
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    protected virtual Int32[] MakeWorkingKey(Byte[] key);
    protected virtual void EncryptBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    protected virtual void DecryptBlock(Byte[] input, int inOff, Byte[] output, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.TwofishEngine : object {
    private static Byte[0...,0...] P;
    private static int P_00;
    private static int P_01;
    private static int P_02;
    private static int P_03;
    private static int P_04;
    private static int P_10;
    private static int P_11;
    private static int P_12;
    private static int P_13;
    private static int P_14;
    private static int P_20;
    private static int P_21;
    private static int P_22;
    private static int P_23;
    private static int P_24;
    private static int P_30;
    private static int P_31;
    private static int P_32;
    private static int P_33;
    private static int P_34;
    private static int GF256_FDBK;
    private static int GF256_FDBK_2;
    private static int GF256_FDBK_4;
    private static int RS_GF_FDBK;
    private static int ROUNDS;
    private static int MAX_ROUNDS;
    private static int BLOCK_SIZE;
    private static int MAX_KEY_BITS;
    private static int INPUT_WHITEN;
    private static int OUTPUT_WHITEN;
    private static int ROUND_SUBKEYS;
    private static int TOTAL_SUBKEYS;
    private static int SK_STEP;
    private static int SK_BUMP;
    private static int SK_ROTL;
    private bool encrypting;
    private Int32[] gMDS0;
    private Int32[] gMDS1;
    private Int32[] gMDS2;
    private Int32[] gMDS3;
    private Int32[] gSubKeys;
    private Int32[] gSBox;
    private int k64Cnt;
    private Byte[] workingKey;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static TwofishEngine();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    public sealed virtual int GetBlockSize();
    private void SetKey(Byte[] key);
    private void EncryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    private void DecryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    private int F32(int x, Int32[] k32);
    private int RS_MDS_Encode(int k0, int k1);
    private int RS_rem(int x);
    private int LFSR1(int x);
    private int LFSR2(int x);
    private int Mx_X(int x);
    private int Mx_Y(int x);
    private int M_b0(int x);
    private int M_b1(int x);
    private int M_b2(int x);
    private int M_b3(int x);
    private int Fe32_0(int x);
    private int Fe32_3(int x);
}
public class Org.BouncyCastle.Crypto.Engines.VmpcEngine : object {
    protected byte n;
    protected Byte[] P;
    protected byte s;
    protected Byte[] workingIV;
    protected Byte[] workingKey;
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    protected virtual void InitKey(Byte[] keyBytes, Byte[] ivBytes);
    public virtual void ProcessBytes(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    public virtual void Reset();
    public virtual byte ReturnByte(byte input);
}
public class Org.BouncyCastle.Crypto.Engines.VmpcKsa3Engine : VmpcEngine {
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    protected virtual void InitKey(Byte[] keyBytes, Byte[] ivBytes);
}
public class Org.BouncyCastle.Crypto.Engines.XSalsa20Engine : Salsa20Engine {
    public string AlgorithmName { get; }
    protected int NonceSize { get; }
    public virtual string get_AlgorithmName();
    protected virtual int get_NonceSize();
    protected virtual void SetKey(Byte[] keyBytes, Byte[] ivBytes);
}
public class Org.BouncyCastle.Crypto.Engines.XteaEngine : object {
    private static int rounds;
    private static int block_size;
    private static int delta;
    private UInt32[] _S;
    private UInt32[] _sum0;
    private UInt32[] _sum1;
    private bool _initialised;
    private bool _forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int ProcessBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
    public virtual void Reset();
    private void setKey(Byte[] key);
    private int encryptBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
    private int decryptBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
}
public abstract class Org.BouncyCastle.Crypto.Fpe.FpeEngine : object {
    protected IBlockCipher baseCipher;
    protected bool forEncryption;
    protected FpeParameters fpeParameters;
    protected FpeEngine(IBlockCipher baseCipher);
    public virtual int ProcessBlock(Byte[] inBuf, int inOff, int length, Byte[] outBuf, int outOff);
    protected static bool IsOverrideSet(string propName);
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    protected abstract virtual int EncryptBlock(Byte[] inBuf, int inOff, int length, Byte[] outBuf, int outOff);
    protected abstract virtual int DecryptBlock(Byte[] inBuf, int inOff, int length, Byte[] outBuf, int outOff);
}
public class Org.BouncyCastle.Crypto.Fpe.FpeFf1Engine : FpeEngine {
    public FpeFf1Engine(IBlockCipher baseCipher);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    protected virtual int EncryptBlock(Byte[] inBuf, int inOff, int length, Byte[] outBuf, int outOff);
    protected virtual int DecryptBlock(Byte[] inBuf, int inOff, int length, Byte[] outBuf, int outOff);
}
public class Org.BouncyCastle.Crypto.Fpe.FpeFf3_1Engine : FpeEngine {
    public FpeFf3_1Engine(IBlockCipher baseCipher);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    protected virtual int EncryptBlock(Byte[] inBuf, int inOff, int length, Byte[] outBuf, int outOff);
    protected virtual int DecryptBlock(Byte[] inBuf, int inOff, int length, Byte[] outBuf, int outOff);
}
internal class Org.BouncyCastle.Crypto.Fpe.SP80038G : object {
    internal static string FPE_DISABLED;
    internal static string FF1_DISABLED;
    protected static int BLOCK_SIZE;
    protected static double LOG2;
    protected static double TWO_TO_96;
    private static SP80038G();
    public static Byte[] DecryptFF1(IBlockCipher cipher, int radix, Byte[] tweak, Byte[] buf, int off, int len);
    public static UInt16[] DecryptFF1w(IBlockCipher cipher, int radix, Byte[] tweak, UInt16[] buf, int off, int len);
    private static UInt16[] decFF1(IBlockCipher cipher, int radix, Byte[] T, int n, int u, int v, UInt16[] A, UInt16[] B);
    public static Byte[] DecryptFF3(IBlockCipher cipher, int radix, Byte[] tweak64, Byte[] buf, int off, int len);
    public static Byte[] DecryptFF3_1(IBlockCipher cipher, int radix, Byte[] tweak56, Byte[] buf, int off, int len);
    public static UInt16[] DecryptFF3_1w(IBlockCipher cipher, int radix, Byte[] tweak56, UInt16[] buf, int off, int len);
    public static Byte[] EncryptFF1(IBlockCipher cipher, int radix, Byte[] tweak, Byte[] buf, int off, int len);
    public static UInt16[] EncryptFF1w(IBlockCipher cipher, int radix, Byte[] tweak, UInt16[] buf, int off, int len);
    private static UInt16[] encFF1(IBlockCipher cipher, int radix, Byte[] T, int n, int u, int v, UInt16[] A, UInt16[] B);
    public static Byte[] EncryptFF3(IBlockCipher cipher, int radix, Byte[] tweak64, Byte[] buf, int off, int len);
    public static UInt16[] EncryptFF3w(IBlockCipher cipher, int radix, Byte[] tweak64, UInt16[] buf, int off, int len);
    public static UInt16[] EncryptFF3_1w(IBlockCipher cipher, int radix, Byte[] tweak56, UInt16[] buf, int off, int len);
    public static Byte[] EncryptFF3_1(IBlockCipher cipher, int radix, Byte[] tweak56, Byte[] buf, int off, int len);
    protected static BigInteger[] calculateModUV(BigInteger bigRadix, int u, int v);
    protected static Byte[] calculateP_FF1(int radix, byte uLow, int n, int t);
    protected static Byte[] calculateTweak64_FF3_1(Byte[] tweak56);
    protected static BigInteger calculateY_FF1(IBlockCipher cipher, BigInteger bigRadix, Byte[] T, int b, int d, int round, Byte[] P, UInt16[] AB);
    protected static BigInteger calculateY_FF3(IBlockCipher cipher, BigInteger bigRadix, Byte[] T, int wOff, UInt32 round, UInt16[] AB);
    protected static void checkArgs(IBlockCipher cipher, bool isFF1, int radix, UInt16[] buf, int off, int len);
    protected static void checkArgs(IBlockCipher cipher, bool isFF1, int radix, Byte[] buf, int off, int len);
    protected static void checkCipher(IBlockCipher cipher);
    protected static void checkData(bool isFF1, int radix, UInt16[] buf, int off, int len);
    protected static void checkData(bool isFF1, int radix, Byte[] buf, int off, int len);
    private static void checkLength(bool isFF1, int radix, int len);
    protected static Byte[] implDecryptFF3(IBlockCipher cipher, int radix, Byte[] tweak64, Byte[] buf, int off, int len);
    protected static UInt16[] implDecryptFF3w(IBlockCipher cipher, int radix, Byte[] tweak64, UInt16[] buf, int off, int len);
    private static UInt16[] decFF3_1(IBlockCipher cipher, int radix, Byte[] T, int n, int v, int u, UInt16[] A, UInt16[] B);
    protected static Byte[] implEncryptFF3(IBlockCipher cipher, int radix, Byte[] tweak64, Byte[] buf, int off, int len);
    protected static UInt16[] implEncryptFF3w(IBlockCipher cipher, int radix, Byte[] tweak64, UInt16[] buf, int off, int len);
    private static UInt16[] encFF3_1(IBlockCipher cipher, int radix, Byte[] t, int n, int v, int u, UInt16[] a, UInt16[] b);
    protected static BigInteger num(Byte[] buf, int off, int len);
    protected static BigInteger num(BigInteger R, UInt16[] x);
    protected static Byte[] prf(IBlockCipher c, Byte[] x);
    protected static void rev(Byte[] x);
    protected static void rev(UInt16[] x);
    protected static void str(BigInteger R, BigInteger x, int m, UInt16[] output, int off);
    protected static void xor(Byte[] x, int xOff, Byte[] y, int yOff, int len);
    private static Byte[] toByte(UInt16[] buf);
    private static UInt16[] toShort(Byte[] buf, int off, int len);
    private static int Ceil(double v);
}
public class Org.BouncyCastle.Crypto.Generators.BaseKdfBytesGenerator : object {
    private int counterStart;
    private IDigest digest;
    private Byte[] shared;
    private Byte[] iv;
    public IDigest Digest { get; }
    public BaseKdfBytesGenerator(int counterStart, IDigest digest);
    public virtual void Init(IDerivationParameters parameters);
    public virtual IDigest get_Digest();
    public virtual int GenerateBytes(Byte[] output, int outOff, int length);
}
public class Org.BouncyCastle.Crypto.Generators.BCrypt : object {
    private static UInt32[] MAGIC_STRING;
    internal static int MAGIC_STRING_LENGTH;
    private static UInt32[] KP;
    private static UInt32[] KS0;
    private static UInt32[] KS1;
    private static UInt32[] KS2;
    private static UInt32[] KS3;
    private static int ROUNDS;
    private static int SBOX_SK;
    private static int SBOX_SK2;
    private static int SBOX_SK3;
    private static int P_SZ;
    private UInt32[] S;
    private UInt32[] P;
    internal static int SALT_SIZE_BYTES;
    internal static int MIN_COST;
    internal static int MAX_COST;
    internal static int MAX_PASSWORD_BYTES;
    private static BCrypt();
    private UInt32 F(UInt32 x);
    private void ProcessTable(UInt32 xl, UInt32 xr, UInt32[] table);
    private void InitState();
    private void CyclicXorKey(Byte[] key);
    private Byte[] EncryptMagicString();
    private void ProcessTableWithSalt(UInt32[] table, UInt32[] salt32Bit, UInt32 iv1, UInt32 iv2);
    private Byte[] DeriveRawKey(int cost, Byte[] salt, Byte[] psw);
    public static Byte[] PasswordToByteArray(Char[] password);
    public static Byte[] Generate(Byte[] password, Byte[] salt, int cost);
}
public class Org.BouncyCastle.Crypto.Generators.DesEdeKeyGenerator : DesKeyGenerator {
    internal DesEdeKeyGenerator(int defaultStrength);
    protected virtual void engineInit(KeyGenerationParameters parameters);
    protected virtual Byte[] engineGenerateKey();
}
public class Org.BouncyCastle.Crypto.Generators.DesKeyGenerator : CipherKeyGenerator {
    internal DesKeyGenerator(int defaultStrength);
    protected virtual void engineInit(KeyGenerationParameters parameters);
    protected virtual Byte[] engineGenerateKey();
}
public class Org.BouncyCastle.Crypto.Generators.DHBasicKeyPairGenerator : object {
    private DHKeyGenerationParameters param;
    public virtual void Init(KeyGenerationParameters parameters);
    public virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
internal class Org.BouncyCastle.Crypto.Generators.DHKeyGeneratorHelper : object {
    internal static DHKeyGeneratorHelper Instance;
    private static DHKeyGeneratorHelper();
    internal BigInteger CalculatePrivate(DHParameters dhParams, SecureRandom random);
    internal BigInteger CalculatePublic(DHParameters dhParams, BigInteger x);
}
public class Org.BouncyCastle.Crypto.Generators.DHKeyPairGenerator : object {
    private DHKeyGenerationParameters param;
    public virtual void Init(KeyGenerationParameters parameters);
    public virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public class Org.BouncyCastle.Crypto.Generators.DHParametersGenerator : object {
    private int size;
    private int certainty;
    private SecureRandom random;
    public virtual void Init(int size, int certainty, SecureRandom random);
    public virtual DHParameters GenerateParameters();
}
internal class Org.BouncyCastle.Crypto.Generators.DHParametersHelper : object {
    private static BigInteger Six;
    private static Int32[][] primeLists;
    private static Int32[] primeProducts;
    private static BigInteger[] BigPrimeProducts;
    private static DHParametersHelper();
    private static BigInteger[] ConstructBigPrimeProducts(Int32[] primeProducts);
    internal static BigInteger[] GenerateSafePrimes(int size, int certainty, SecureRandom random);
    internal static BigInteger SelectGenerator(BigInteger p, BigInteger q, SecureRandom random);
}
public class Org.BouncyCastle.Crypto.Generators.DsaKeyPairGenerator : object {
    private static BigInteger One;
    private DsaKeyGenerationParameters param;
    private static DsaKeyPairGenerator();
    public sealed virtual void Init(KeyGenerationParameters parameters);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
    private static BigInteger GeneratePrivateKey(BigInteger q, SecureRandom random);
    private static BigInteger CalculatePublicKey(BigInteger p, BigInteger g, BigInteger x);
}
public class Org.BouncyCastle.Crypto.Generators.DsaParametersGenerator : object {
    private IDigest digest;
    private int L;
    private int N;
    private int certainty;
    private SecureRandom random;
    private bool use186_3;
    private int usageIndex;
    public DsaParametersGenerator(IDigest digest);
    public virtual void Init(int size, int certainty, SecureRandom random);
    public virtual void Init(DsaParameterGenerationParameters parameters);
    public virtual DsaParameters GenerateParameters();
    protected virtual DsaParameters GenerateParameters_FIPS186_2();
    protected virtual BigInteger CalculateGenerator_FIPS186_2(BigInteger p, BigInteger q, SecureRandom r);
    protected virtual DsaParameters GenerateParameters_FIPS186_3();
    protected virtual BigInteger CalculateGenerator_FIPS186_3_Unverifiable(BigInteger p, BigInteger q, SecureRandom r);
    protected virtual BigInteger CalculateGenerator_FIPS186_3_Verifiable(IDigest d, BigInteger p, BigInteger q, Byte[] seed, int index);
    private static bool IsValidDsaStrength(int strength);
    protected static void Hash(IDigest d, Byte[] input, Byte[] output);
    private static int GetDefaultN(int L);
    protected static void Inc(Byte[] buf);
}
public class Org.BouncyCastle.Crypto.Generators.ECKeyPairGenerator : object {
    private string algorithm;
    private ECDomainParameters parameters;
    private DerObjectIdentifier publicKeyParamSet;
    private SecureRandom random;
    public ECKeyPairGenerator(string algorithm);
    public sealed virtual void Init(KeyGenerationParameters parameters);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
    protected virtual ECMultiplier CreateBasePointMultiplier();
    internal static X9ECParameters FindECCurveByOid(DerObjectIdentifier oid);
    internal static ECPublicKeyParameters GetCorrespondingPublicKey(ECPrivateKeyParameters privKey);
}
public class Org.BouncyCastle.Crypto.Generators.Ed25519KeyPairGenerator : object {
    private SecureRandom random;
    public virtual void Init(KeyGenerationParameters parameters);
    public virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public class Org.BouncyCastle.Crypto.Generators.Ed448KeyPairGenerator : object {
    private SecureRandom random;
    public virtual void Init(KeyGenerationParameters parameters);
    public virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public class Org.BouncyCastle.Crypto.Generators.ElGamalKeyPairGenerator : object {
    private ElGamalKeyGenerationParameters param;
    public sealed virtual void Init(KeyGenerationParameters parameters);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public class Org.BouncyCastle.Crypto.Generators.ElGamalParametersGenerator : object {
    private int size;
    private int certainty;
    private SecureRandom random;
    public void Init(int size, int certainty, SecureRandom random);
    public ElGamalParameters GenerateParameters();
}
public class Org.BouncyCastle.Crypto.Generators.Gost3410KeyPairGenerator : object {
    private Gost3410KeyGenerationParameters param;
    public sealed virtual void Init(KeyGenerationParameters parameters);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public class Org.BouncyCastle.Crypto.Generators.Gost3410ParametersGenerator : object {
    private int size;
    private int typeproc;
    private SecureRandom init_random;
    public void Init(int size, int typeProcedure, SecureRandom random);
    private int procedure_A(int x0, int c, BigInteger[] pq, int size);
    private long procedure_Aa(long x0, long c, BigInteger[] pq, int size);
    private void procedure_B(int x0, int c, BigInteger[] pq);
    private void procedure_Bb(long x0, long c, BigInteger[] pq);
    private BigInteger procedure_C(BigInteger p, BigInteger q);
    public Gost3410Parameters GenerateParameters();
}
public class Org.BouncyCastle.Crypto.Generators.HkdfBytesGenerator : object {
    private HMac hMacHash;
    private int hashLen;
    private Byte[] info;
    private Byte[] currentT;
    private int generatedBytes;
    public IDigest Digest { get; }
    public HkdfBytesGenerator(IDigest hash);
    public virtual void Init(IDerivationParameters parameters);
    private KeyParameter Extract(Byte[] salt, Byte[] ikm);
    private void ExpandNext();
    public virtual IDigest get_Digest();
    public virtual int GenerateBytes(Byte[] output, int outOff, int len);
}
public class Org.BouncyCastle.Crypto.Generators.Kdf1BytesGenerator : BaseKdfBytesGenerator {
    public Kdf1BytesGenerator(IDigest digest);
}
public class Org.BouncyCastle.Crypto.Generators.Kdf2BytesGenerator : BaseKdfBytesGenerator {
    public Kdf2BytesGenerator(IDigest digest);
}
public class Org.BouncyCastle.Crypto.Generators.KdfCounterBytesGenerator : object {
    private static BigInteger IntegerMax;
    private static BigInteger Two;
    private IMac prf;
    private int h;
    private Byte[] fixedInputDataCtrPrefix;
    private Byte[] fixedInputData_afterCtr;
    private int maxSizeExcl;
    private Byte[] ios;
    private int generatedBytes;
    private Byte[] k;
    public IDigest Digest { get; }
    public KdfCounterBytesGenerator(IMac prf);
    private static KdfCounterBytesGenerator();
    public sealed virtual void Init(IDerivationParameters param);
    public sealed virtual IMac GetMac();
    public sealed virtual IDigest get_Digest();
    public sealed virtual int GenerateBytes(Byte[] output, int outOff, int length);
    private void generateNext();
}
public class Org.BouncyCastle.Crypto.Generators.KdfDoublePipelineIterationBytesGenerator : object {
    private static BigInteger IntegerMax;
    private static BigInteger Two;
    private IMac prf;
    private int h;
    private Byte[] fixedInputData;
    private int maxSizeExcl;
    private Byte[] ios;
    private bool useCounter;
    private int generatedBytes;
    private Byte[] a;
    private Byte[] k;
    public IDigest Digest { get; }
    public KdfDoublePipelineIterationBytesGenerator(IMac prf);
    private static KdfDoublePipelineIterationBytesGenerator();
    public sealed virtual void Init(IDerivationParameters parameters);
    private void generateNext();
    public sealed virtual IDigest get_Digest();
    public sealed virtual int GenerateBytes(Byte[] output, int outOff, int length);
    public sealed virtual IMac GetMac();
}
public class Org.BouncyCastle.Crypto.Generators.KdfFeedbackBytesGenerator : object {
    private static BigInteger IntegerMax;
    private static BigInteger Two;
    private IMac prf;
    private int h;
    private Byte[] fixedInputData;
    private int maxSizeExcl;
    private Byte[] ios;
    private Byte[] iv;
    private bool useCounter;
    private int generatedBytes;
    private Byte[] k;
    public IDigest Digest { get; }
    public KdfFeedbackBytesGenerator(IMac prf);
    private static KdfFeedbackBytesGenerator();
    public sealed virtual void Init(IDerivationParameters parameters);
    public sealed virtual IDigest get_Digest();
    public sealed virtual int GenerateBytes(Byte[] output, int outOff, int length);
    private void generateNext();
    public sealed virtual IMac GetMac();
}
public class Org.BouncyCastle.Crypto.Generators.Mgf1BytesGenerator : object {
    private IDigest digest;
    private Byte[] seed;
    private int hLen;
    public IDigest Digest { get; }
    public Mgf1BytesGenerator(IDigest digest);
    public sealed virtual void Init(IDerivationParameters parameters);
    public sealed virtual IDigest get_Digest();
    private void ItoOSP(int i, Byte[] sp);
    public sealed virtual int GenerateBytes(Byte[] output, int outOff, int length);
}
public class Org.BouncyCastle.Crypto.Generators.NaccacheSternKeyPairGenerator : object {
    private static Int32[] smallPrimes;
    private NaccacheSternKeyGenerationParameters param;
    private static NaccacheSternKeyPairGenerator();
    public sealed virtual void Init(KeyGenerationParameters parameters);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
    private static BigInteger generatePrime(int bitLength, int certainty, SecureRandom rand);
    private static IList permuteList(IList arr, SecureRandom rand);
    private static IList findFirstPrimes(int count);
}
public class Org.BouncyCastle.Crypto.Generators.OpenBsdBCrypt : object {
    private static Byte[] EncodingTable;
    private static Byte[] DecodingTable;
    private static string DefaultVersion;
    private static ISet AllowedVersions;
    private static OpenBsdBCrypt();
    private static string CreateBcryptString(string version, Byte[] password, Byte[] salt, int cost);
    public static string Generate(Char[] password, Byte[] salt, int cost);
    public static string Generate(string version, Char[] password, Byte[] salt, int cost);
    public static bool CheckPassword(string bcryptString, Char[] password);
    private static string EncodeData(Byte[] data);
    private static Byte[] DecodeSaltString(string saltString);
}
public class Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator : PbeParametersGenerator {
    private IDigest digest;
    public OpenSslPbeParametersGenerator(IDigest digest);
    public virtual void Init(Byte[] password, Byte[] salt, int iterationCount);
    public virtual void Init(Byte[] password, Byte[] salt);
    private Byte[] GenerateDerivedKey(int bytesNeeded);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public virtual ICipherParameters GenerateDerivedParameters(int keySize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public virtual ICipherParameters GenerateDerivedParameters(int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedMacParameters(int keySize);
}
public class Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator : PbeParametersGenerator {
    public static int KeyMaterial;
    public static int IVMaterial;
    public static int MacMaterial;
    private IDigest digest;
    private int u;
    private int v;
    public Pkcs12ParametersGenerator(IDigest digest);
    private void Adjust(Byte[] a, int aOff, Byte[] b);
    private Byte[] GenerateDerivedKey(int idByte, int n);
    public virtual ICipherParameters GenerateDerivedParameters(int keySize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize);
    public virtual ICipherParameters GenerateDerivedParameters(int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedMacParameters(int keySize);
}
public class Org.BouncyCastle.Crypto.Generators.Pkcs5S1ParametersGenerator : PbeParametersGenerator {
    private IDigest digest;
    public Pkcs5S1ParametersGenerator(IDigest digest);
    private Byte[] GenerateDerivedKey();
    public virtual ICipherParameters GenerateDerivedParameters(int keySize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize);
    public virtual ICipherParameters GenerateDerivedParameters(int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedMacParameters(int keySize);
}
public class Org.BouncyCastle.Crypto.Generators.Pkcs5S2ParametersGenerator : PbeParametersGenerator {
    private IMac hMac;
    private Byte[] state;
    public Pkcs5S2ParametersGenerator(IDigest digest);
    private void F(Byte[] S, int c, Byte[] iBuf, Byte[] outBytes, int outOff);
    private Byte[] GenerateDerivedKey(int dkLen);
    public virtual ICipherParameters GenerateDerivedParameters(int keySize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize);
    public virtual ICipherParameters GenerateDerivedParameters(int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedMacParameters(int keySize);
}
public class Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator : CipherKeyGenerator {
    private static byte R_MASK_LOW_2;
    private static byte R_MASK_HIGH_4;
    protected virtual void engineInit(KeyGenerationParameters param);
    protected virtual Byte[] engineGenerateKey();
    public static void Clamp(Byte[] key);
    public static void CheckKey(Byte[] key);
    private static void CheckMask(byte b, byte mask);
}
public class Org.BouncyCastle.Crypto.Generators.RsaBlindingFactorGenerator : object {
    private RsaKeyParameters key;
    private SecureRandom random;
    public void Init(ICipherParameters param);
    public BigInteger GenerateBlindingFactor();
}
public class Org.BouncyCastle.Crypto.Generators.RsaKeyPairGenerator : object {
    private static Int32[] SPECIAL_E_VALUES;
    private static int SPECIAL_E_HIGHEST;
    private static int SPECIAL_E_BITS;
    protected static BigInteger One;
    protected static BigInteger DefaultPublicExponent;
    protected static int DefaultTests;
    protected RsaKeyGenerationParameters parameters;
    private static RsaKeyPairGenerator();
    public virtual void Init(KeyGenerationParameters parameters);
    public virtual AsymmetricCipherKeyPair GenerateKeyPair();
    protected virtual BigInteger ChooseRandomPrime(int bitlength, BigInteger e);
}
public class Org.BouncyCastle.Crypto.Generators.SCrypt : object {
    public static Byte[] Generate(Byte[] P, Byte[] S, int N, int r, int p, int dkLen);
    private static Byte[] MFcrypt(Byte[] P, Byte[] S, int N, int r, int p, int dkLen);
    private static Byte[] SingleIterationPBKDF2(Byte[] P, Byte[] S, int dkLen);
    private static void SMix(UInt32[] B, int BOff, int N, int d, int r);
    private static void BlockMix(UInt32[] B, UInt32[] X1, UInt32[] X2, UInt32[] Y, int r);
    private static void Xor(UInt32[] a, UInt32[] b, int bOff, UInt32[] output);
    private static void Clear(Array array);
    private static void ClearAll(Array[] arrays);
    private static bool IsPowerOf2(int x);
}
public class Org.BouncyCastle.Crypto.Generators.X25519KeyPairGenerator : object {
    private SecureRandom random;
    public virtual void Init(KeyGenerationParameters parameters);
    public virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public class Org.BouncyCastle.Crypto.Generators.X448KeyPairGenerator : object {
    private SecureRandom random;
    public virtual void Init(KeyGenerationParameters parameters);
    public virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public interface Org.BouncyCastle.Crypto.IAlphabetMapper {
    public int Radix { get; }
    public abstract virtual int get_Radix();
    public abstract virtual Byte[] ConvertToIndexes(Char[] input);
    public abstract virtual Char[] ConvertToChars(Byte[] input);
}
public interface Org.BouncyCastle.Crypto.IAsymmetricBlockCipher {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual int GetInputBlockSize();
    public abstract virtual int GetOutputBlockSize();
    public abstract virtual Byte[] ProcessBlock(Byte[] inBuf, int inOff, int inLen);
}
public interface Org.BouncyCastle.Crypto.IAsymmetricCipherKeyPairGenerator {
    public abstract virtual void Init(KeyGenerationParameters parameters);
    public abstract virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public interface Org.BouncyCastle.Crypto.IBasicAgreement {
    public abstract virtual void Init(ICipherParameters parameters);
    public abstract virtual int GetFieldSize();
    public abstract virtual BigInteger CalculateAgreement(ICipherParameters pubKey);
}
public interface Org.BouncyCastle.Crypto.IBlockCipher {
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual int GetBlockSize();
    public abstract virtual bool get_IsPartialBlockOkay();
    public abstract virtual int ProcessBlock(Byte[] inBuf, int inOff, Byte[] outBuf, int outOff);
    public abstract virtual void Reset();
}
public interface Org.BouncyCastle.Crypto.IBlockResult {
    public abstract virtual Byte[] Collect();
    public abstract virtual int Collect(Byte[] destination, int offset);
}
public interface Org.BouncyCastle.Crypto.IBufferedCipher {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual int GetBlockSize();
    public abstract virtual int GetOutputSize(int inputLen);
    public abstract virtual int GetUpdateOutputSize(int inputLen);
    public abstract virtual Byte[] ProcessByte(byte input);
    public abstract virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public abstract virtual Byte[] ProcessBytes(Byte[] input);
    public abstract virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public abstract virtual int ProcessBytes(Byte[] input, Byte[] output, int outOff);
    public abstract virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public abstract virtual Byte[] DoFinal();
    public abstract virtual Byte[] DoFinal(Byte[] input);
    public abstract virtual Byte[] DoFinal(Byte[] input, int inOff, int length);
    public abstract virtual int DoFinal(Byte[] output, int outOff);
    public abstract virtual int DoFinal(Byte[] input, Byte[] output, int outOff);
    public abstract virtual int DoFinal(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public abstract virtual void Reset();
}
public interface Org.BouncyCastle.Crypto.ICipher {
    public Stream Stream { get; }
    public abstract virtual int GetMaxOutputSize(int inputLen);
    public abstract virtual int GetUpdateOutputSize(int inputLen);
    public abstract virtual Stream get_Stream();
}
public interface Org.BouncyCastle.Crypto.ICipherBuilder {
    public object AlgorithmDetails { get; }
    public abstract virtual object get_AlgorithmDetails();
    public abstract virtual int GetMaxOutputSize(int inputLen);
    public abstract virtual ICipher BuildCipher(Stream stream);
}
public interface Org.BouncyCastle.Crypto.ICipherBuilderWithKey {
    public ICipherParameters Key { get; }
    public abstract virtual ICipherParameters get_Key();
}
public interface Org.BouncyCastle.Crypto.ICipherParameters {
}
public interface Org.BouncyCastle.Crypto.IDecryptorBuilderProvider {
    public abstract virtual ICipherBuilder CreateDecryptorBuilder(object algorithmDetails);
}
public interface Org.BouncyCastle.Crypto.IDerivationFunction {
    public IDigest Digest { get; }
    public abstract virtual void Init(IDerivationParameters parameters);
    public abstract virtual IDigest get_Digest();
    public abstract virtual int GenerateBytes(Byte[] output, int outOff, int length);
}
public interface Org.BouncyCastle.Crypto.IDerivationParameters {
}
public interface Org.BouncyCastle.Crypto.IDigest {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int GetDigestSize();
    public abstract virtual int GetByteLength();
    public abstract virtual void Update(byte input);
    public abstract virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public abstract virtual int DoFinal(Byte[] output, int outOff);
    public abstract virtual void Reset();
}
public interface Org.BouncyCastle.Crypto.IDigestFactory {
    public object AlgorithmDetails { get; }
    public int DigestLength { get; }
    public abstract virtual object get_AlgorithmDetails();
    public abstract virtual int get_DigestLength();
    public abstract virtual IStreamCalculator CreateCalculator();
}
public interface Org.BouncyCastle.Crypto.IDsa {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forSigning, ICipherParameters parameters);
    public abstract virtual BigInteger[] GenerateSignature(Byte[] message);
    public abstract virtual bool VerifySignature(Byte[] message, BigInteger r, BigInteger s);
}
public interface Org.BouncyCastle.Crypto.IDsaExt {
    public BigInteger Order { get; }
    public abstract virtual BigInteger get_Order();
}
public interface Org.BouncyCastle.Crypto.IEntropySource {
    public bool IsPredictionResistant { get; }
    public int EntropySize { get; }
    public abstract virtual bool get_IsPredictionResistant();
    public abstract virtual Byte[] GetEntropy();
    public abstract virtual int get_EntropySize();
}
public interface Org.BouncyCastle.Crypto.IEntropySourceProvider {
    public abstract virtual IEntropySource Get(int bitsRequired);
}
public interface Org.BouncyCastle.Crypto.IKeyUnwrapper {
    public object AlgorithmDetails { get; }
    public abstract virtual object get_AlgorithmDetails();
    public abstract virtual IBlockResult Unwrap(Byte[] cipherText, int offset, int length);
}
public interface Org.BouncyCastle.Crypto.IKeyWrapper {
    public object AlgorithmDetails { get; }
    public abstract virtual object get_AlgorithmDetails();
    public abstract virtual IBlockResult Wrap(Byte[] keyData);
}
public interface Org.BouncyCastle.Crypto.IMac {
    public string AlgorithmName { get; }
    public abstract virtual void Init(ICipherParameters parameters);
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int GetMacSize();
    public abstract virtual void Update(byte input);
    public abstract virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public abstract virtual int DoFinal(Byte[] output, int outOff);
    public abstract virtual void Reset();
}
public interface Org.BouncyCastle.Crypto.IMacDerivationFunction {
    public abstract virtual IMac GetMac();
}
public interface Org.BouncyCastle.Crypto.IMacFactory {
    public object AlgorithmDetails { get; }
    public abstract virtual object get_AlgorithmDetails();
    public abstract virtual IStreamCalculator CreateCalculator();
}
public class Org.BouncyCastle.Crypto.InvalidCipherTextException : CryptoException {
    public InvalidCipherTextException(string message);
    public InvalidCipherTextException(string message, Exception exception);
}
public class Org.BouncyCastle.Crypto.IO.CipherStream : Stream {
    internal Stream stream;
    internal IBufferedCipher inCipher;
    internal IBufferedCipher outCipher;
    private Byte[] mInBuf;
    private int mInPos;
    private bool inStreamEnded;
    public IBufferedCipher ReadCipher { get; }
    public IBufferedCipher WriteCipher { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CipherStream(Stream stream, IBufferedCipher readCipher, IBufferedCipher writeCipher);
    public IBufferedCipher get_ReadCipher();
    public IBufferedCipher get_WriteCipher();
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    private bool FillInBuf();
    private Byte[] ReadAndProcessBlock();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte b);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public sealed virtual long Seek(long offset, SeekOrigin origin);
    public sealed virtual void SetLength(long length);
}
public class Org.BouncyCastle.Crypto.IO.DigestSink : BaseOutputStream {
    private IDigest mDigest;
    public IDigest Digest { get; }
    public DigestSink(IDigest digest);
    public virtual IDigest get_Digest();
    public virtual void WriteByte(byte b);
    public virtual void Write(Byte[] buf, int off, int len);
}
public class Org.BouncyCastle.Crypto.IO.DigestStream : Stream {
    protected Stream stream;
    protected IDigest inDigest;
    protected IDigest outDigest;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public DigestStream(Stream stream, IDigest readDigest, IDigest writeDigest);
    public virtual IDigest ReadDigest();
    public virtual IDigest WriteDigest();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte b);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long length);
}
public class Org.BouncyCastle.Crypto.IO.MacSink : BaseOutputStream {
    private IMac mMac;
    public IMac Mac { get; }
    public MacSink(IMac mac);
    public virtual IMac get_Mac();
    public virtual void WriteByte(byte b);
    public virtual void Write(Byte[] buf, int off, int len);
}
public class Org.BouncyCastle.Crypto.IO.MacStream : Stream {
    protected Stream stream;
    protected IMac inMac;
    protected IMac outMac;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public MacStream(Stream stream, IMac readMac, IMac writeMac);
    public virtual IMac ReadMac();
    public virtual IMac WriteMac();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte b);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long length);
}
public class Org.BouncyCastle.Crypto.IO.SignerSink : BaseOutputStream {
    private ISigner mSigner;
    public ISigner Signer { get; }
    public SignerSink(ISigner signer);
    public virtual ISigner get_Signer();
    public virtual void WriteByte(byte b);
    public virtual void Write(Byte[] buf, int off, int len);
}
public class Org.BouncyCastle.Crypto.IO.SignerStream : Stream {
    protected Stream stream;
    protected ISigner inSigner;
    protected ISigner outSigner;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public SignerStream(Stream stream, ISigner readSigner, ISigner writeSigner);
    public virtual ISigner ReadSigner();
    public virtual ISigner WriteSigner();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte b);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long length);
}
public interface Org.BouncyCastle.Crypto.IRawAgreement {
    public int AgreementSize { get; }
    public abstract virtual void Init(ICipherParameters parameters);
    public abstract virtual int get_AgreementSize();
    public abstract virtual void CalculateAgreement(ICipherParameters publicKey, Byte[] buf, int off);
}
public interface Org.BouncyCastle.Crypto.IRsa {
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual int GetInputBlockSize();
    public abstract virtual int GetOutputBlockSize();
    public abstract virtual BigInteger ConvertInput(Byte[] buf, int off, int len);
    public abstract virtual BigInteger ProcessBlock(BigInteger input);
    public abstract virtual Byte[] ConvertOutput(BigInteger result);
}
public interface Org.BouncyCastle.Crypto.ISignatureFactory {
    public object AlgorithmDetails { get; }
    public abstract virtual object get_AlgorithmDetails();
    public abstract virtual IStreamCalculator CreateCalculator();
}
public interface Org.BouncyCastle.Crypto.ISigner {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forSigning, ICipherParameters parameters);
    public abstract virtual void Update(byte input);
    public abstract virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public abstract virtual Byte[] GenerateSignature();
    public abstract virtual bool VerifySignature(Byte[] signature);
    public abstract virtual void Reset();
}
public interface Org.BouncyCastle.Crypto.ISignerWithRecovery {
    public abstract virtual bool HasFullMessage();
    public abstract virtual Byte[] GetRecoveredMessage();
    public abstract virtual void UpdateWithRecoveredMessage(Byte[] signature);
}
public interface Org.BouncyCastle.Crypto.IStreamCalculator {
    public Stream Stream { get; }
    public abstract virtual Stream get_Stream();
    public abstract virtual object GetResult();
}
public interface Org.BouncyCastle.Crypto.IStreamCipher {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual byte ReturnByte(byte input);
    public abstract virtual void ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public abstract virtual void Reset();
}
public interface Org.BouncyCastle.Crypto.IVerifier {
    public abstract virtual bool IsVerified(Byte[] data);
    public abstract virtual bool IsVerified(Byte[] source, int off, int length);
}
public interface Org.BouncyCastle.Crypto.IVerifierFactory {
    public object AlgorithmDetails { get; }
    public abstract virtual object get_AlgorithmDetails();
    public abstract virtual IStreamCalculator CreateCalculator();
}
public interface Org.BouncyCastle.Crypto.IVerifierFactoryProvider {
    public abstract virtual IVerifierFactory CreateVerifierFactory(object algorithmDetails);
}
public interface Org.BouncyCastle.Crypto.IWrapper {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forWrapping, ICipherParameters parameters);
    public abstract virtual Byte[] Wrap(Byte[] input, int inOff, int length);
    public abstract virtual Byte[] Unwrap(Byte[] input, int inOff, int length);
}
public interface Org.BouncyCastle.Crypto.IXof {
    public abstract virtual int DoFinal(Byte[] output, int outOff, int outLen);
    public abstract virtual int DoOutput(Byte[] output, int outOff, int outLen);
}
public class Org.BouncyCastle.Crypto.KeyGenerationParameters : object {
    private SecureRandom random;
    private int strength;
    public SecureRandom Random { get; }
    public int Strength { get; }
    public KeyGenerationParameters(SecureRandom random, int strength);
    public SecureRandom get_Random();
    public int get_Strength();
}
public class Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac : object {
    private Byte[] buf;
    private int bufOff;
    private IBlockCipher cipher;
    private IBlockCipherPadding padding;
    private int macSize;
    public string AlgorithmName { get; }
    public CbcBlockCipherMac(IBlockCipher cipher);
    public CbcBlockCipherMac(IBlockCipher cipher, IBlockCipherPadding padding);
    public CbcBlockCipherMac(IBlockCipher cipher, int macSizeInBits);
    public CbcBlockCipherMac(IBlockCipher cipher, int macSizeInBits, IBlockCipherPadding padding);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac : object {
    private Byte[] mac;
    private Byte[] Buffer;
    private int bufOff;
    private MacCFBBlockCipher cipher;
    private IBlockCipherPadding padding;
    private int macSize;
    public string AlgorithmName { get; }
    public CfbBlockCipherMac(IBlockCipher cipher);
    public CfbBlockCipherMac(IBlockCipher cipher, IBlockCipherPadding padding);
    public CfbBlockCipherMac(IBlockCipher cipher, int cfbBitSize, int macSizeInBits);
    public CfbBlockCipherMac(IBlockCipher cipher, int cfbBitSize, int macSizeInBits, IBlockCipherPadding padding);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Macs.CMac : object {
    private static byte CONSTANT_128;
    private static byte CONSTANT_64;
    private Byte[] ZEROES;
    private Byte[] mac;
    private Byte[] buf;
    private int bufOff;
    private IBlockCipher cipher;
    private int macSize;
    private Byte[] L;
    private Byte[] Lu;
    private Byte[] Lu2;
    public string AlgorithmName { get; }
    public CMac(IBlockCipher cipher);
    public CMac(IBlockCipher cipher, int macSizeInBits);
    public sealed virtual string get_AlgorithmName();
    private static int ShiftLeft(Byte[] block, Byte[] output);
    private static Byte[] DoubleLu(Byte[] input);
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] inBytes, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] outBytes, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Macs.Dstu7564Mac : object {
    private Dstu7564Digest engine;
    private int macSize;
    private ulong inputLength;
    private Byte[] paddedKey;
    private Byte[] invertedKey;
    public string AlgorithmName { get; }
    public Dstu7564Mac(int macSizeBits);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual int GetMacSize();
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual void Update(byte input);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void Pad();
    private Byte[] PadKey(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Macs.Dstu7624Mac : object {
    private int macSize;
    private Dstu7624Engine engine;
    private int blockSize;
    private Byte[] c;
    private Byte[] cTemp;
    private Byte[] kDelta;
    private Byte[] buf;
    private int bufOff;
    public string AlgorithmName { get; }
    public Dstu7624Mac(int blockSizeBits, int q);
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    private void processBlock(Byte[] input, int inOff);
    private void Xor(Byte[] c, int cOff, Byte[] input, int inOff, Byte[] xorResult);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Macs.GMac : object {
    private GcmBlockCipher cipher;
    private int macSizeBits;
    public string AlgorithmName { get; }
    public GMac(GcmBlockCipher cipher);
    public GMac(GcmBlockCipher cipher, int macSizeBits);
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Macs.Gost28147Mac : object {
    private static int blockSize;
    private static int macSize;
    private int bufOff;
    private Byte[] buf;
    private Byte[] mac;
    private bool firstStep;
    private Int32[] workingKey;
    private Byte[] macIV;
    private Byte[] S;
    public string AlgorithmName { get; }
    private static Int32[] GenerateWorkingKey(Byte[] userKey);
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetMacSize();
    private int gost28147_mainStep(int n1, int key);
    private void gost28147MacFunc(Int32[] workingKey, Byte[] input, int inOff, Byte[] output, int outOff);
    private static int bytesToint(Byte[] input, int inOff);
    private static void intTobytes(int num, Byte[] output, int outOff);
    private static Byte[] CM5func(Byte[] buf, int bufOff, Byte[] mac);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Macs.HMac : object {
    private static byte IPAD;
    private static byte OPAD;
    private IDigest digest;
    private int digestSize;
    private int blockLength;
    private IMemoable ipadState;
    private IMemoable opadState;
    private Byte[] inputPad;
    private Byte[] outputBuf;
    public string AlgorithmName { get; }
    public HMac(IDigest digest);
    public virtual string get_AlgorithmName();
    public virtual IDigest GetUnderlyingDigest();
    public virtual void Init(ICipherParameters parameters);
    public virtual int GetMacSize();
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private static void XorPad(Byte[] pad, int len, byte n);
}
public class Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac : object {
    private Byte[] mac;
    private Byte[] buf;
    private int bufOff;
    private IBlockCipher cipher;
    private IBlockCipherPadding padding;
    private int macSize;
    private KeyParameter lastKey2;
    private KeyParameter lastKey3;
    public string AlgorithmName { get; }
    public ISO9797Alg3Mac(IBlockCipher cipher);
    public ISO9797Alg3Mac(IBlockCipher cipher, IBlockCipherPadding padding);
    public ISO9797Alg3Mac(IBlockCipher cipher, int macSizeInBits);
    public ISO9797Alg3Mac(IBlockCipher cipher, int macSizeInBits, IBlockCipherPadding padding);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Macs.KMac : object {
    private static Byte[] padding;
    private CShakeDigest cshake;
    private int bitLength;
    private int outputLength;
    private Byte[] key;
    private bool initialised;
    private bool firstOutput;
    public string AlgorithmName { get; }
    public KMac(int bitLength, Byte[] S);
    private static KMac();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual int DoFinal(Byte[] output, int outOff, int outLen);
    public sealed virtual int DoOutput(Byte[] output, int outOff, int outLen);
    public sealed virtual int GetByteLength();
    public sealed virtual int GetDigestSize();
    public sealed virtual int GetMacSize();
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual void Reset();
    private void bytePad(Byte[] X, int w);
    private static Byte[] encode(Byte[] X);
    public sealed virtual void Update(byte input);
}
internal class Org.BouncyCastle.Crypto.Macs.MacCFBBlockCipher : object {
    private Byte[] IV;
    private Byte[] cfbV;
    private Byte[] cfbOutV;
    private int blockSize;
    private IBlockCipher cipher;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public MacCFBBlockCipher(IBlockCipher cipher, int bitBlockSize);
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    public sealed virtual void Reset();
    public void GetMacBlock(Byte[] mac);
}
public class Org.BouncyCastle.Crypto.Macs.Poly1305 : object {
    private static int BlockSize;
    private IBlockCipher cipher;
    private Byte[] singleByte;
    private UInt32 r0;
    private UInt32 r1;
    private UInt32 r2;
    private UInt32 r3;
    private UInt32 r4;
    private UInt32 s1;
    private UInt32 s2;
    private UInt32 s3;
    private UInt32 s4;
    private UInt32 k0;
    private UInt32 k1;
    private UInt32 k2;
    private UInt32 k3;
    private Byte[] currentBlock;
    private int currentBlockOffset;
    private UInt32 h0;
    private UInt32 h1;
    private UInt32 h2;
    private UInt32 h3;
    private UInt32 h4;
    public string AlgorithmName { get; }
    public Poly1305(IBlockCipher cipher);
    public sealed virtual void Init(ICipherParameters parameters);
    private void SetKey(Byte[] key, Byte[] nonce);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    private void ProcessBlock();
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    private static ulong mul32x32_64(UInt32 i1, UInt32 i2);
}
public class Org.BouncyCastle.Crypto.Macs.SipHash : object {
    protected int c;
    protected int d;
    protected long k0;
    protected long k1;
    protected long v0;
    protected long v1;
    protected long v2;
    protected long v3;
    protected long m;
    protected int wordPos;
    protected int wordCount;
    public string AlgorithmName { get; }
    public SipHash(int c, int d);
    public virtual string get_AlgorithmName();
    public virtual int GetMacSize();
    public virtual void Init(ICipherParameters parameters);
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int offset, int length);
    public virtual long DoFinal();
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    protected virtual void ProcessMessageWord();
    protected virtual void ApplySipRounds(int n);
    protected static long RotateLeft(long x, int n);
}
public class Org.BouncyCastle.Crypto.Macs.SkeinMac : object {
    public static int SKEIN_256;
    public static int SKEIN_512;
    public static int SKEIN_1024;
    private SkeinEngine engine;
    public string AlgorithmName { get; }
    public SkeinMac(int stateSizeBits, int digestSizeBits);
    public SkeinMac(SkeinMac mac);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual int GetMacSize();
    public sealed virtual void Reset();
    public sealed virtual void Update(byte inByte);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
}
public class Org.BouncyCastle.Crypto.Macs.VmpcMac : object {
    private byte g;
    private byte n;
    private Byte[] P;
    private byte s;
    private Byte[] T;
    private Byte[] workingIV;
    private Byte[] workingKey;
    private byte x1;
    private byte x2;
    private byte x3;
    private byte x4;
    public string AlgorithmName { get; }
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual string get_AlgorithmName();
    public virtual int GetMacSize();
    public virtual void Init(ICipherParameters parameters);
    private void initKey(Byte[] keyBytes, Byte[] ivBytes);
    public virtual void Reset();
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int len);
}
public class Org.BouncyCastle.Crypto.MaxBytesExceededException : CryptoException {
    public MaxBytesExceededException(string message);
    public MaxBytesExceededException(string message, Exception e);
}
public class Org.BouncyCastle.Crypto.Modes.CbcBlockCipher : object {
    private Byte[] IV;
    private Byte[] cbcV;
    private Byte[] cbcNextV;
    private int blockSize;
    private IBlockCipher cipher;
    private bool encrypting;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public CbcBlockCipher(IBlockCipher cipher);
    public IBlockCipher GetUnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Modes.CcmBlockCipher : object {
    private static int BlockSize;
    private IBlockCipher cipher;
    private Byte[] macBlock;
    private bool forEncryption;
    private Byte[] nonce;
    private Byte[] initialAssociatedText;
    private int macSize;
    private ICipherParameters keyParam;
    private MemoryStream associatedText;
    private MemoryStream data;
    public string AlgorithmName { get; }
    public CcmBlockCipher(IBlockCipher cipher);
    private static CcmBlockCipher();
    public virtual IBlockCipher GetUnderlyingCipher();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual void ProcessAadByte(byte input);
    public virtual void ProcessAadBytes(Byte[] inBytes, int inOff, int len);
    public virtual int ProcessByte(byte input, Byte[] outBytes, int outOff);
    public virtual int ProcessBytes(Byte[] inBytes, int inOff, int inLen, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] outBytes, int outOff);
    public virtual void Reset();
    public virtual Byte[] GetMac();
    public virtual int GetUpdateOutputSize(int len);
    public virtual int GetOutputSize(int len);
    public virtual Byte[] ProcessPacket(Byte[] input, int inOff, int inLen);
    public virtual int ProcessPacket(Byte[] input, int inOff, int inLen, Byte[] output, int outOff);
    private int CalculateMac(Byte[] data, int dataOff, int dataLen, Byte[] macBlock);
    private int GetMacSize(bool forEncryption, int requestedMacBits);
    private int GetAssociatedTextLength();
    private bool HasAssociatedText();
}
public class Org.BouncyCastle.Crypto.Modes.CfbBlockCipher : object {
    private Byte[] IV;
    private Byte[] cfbV;
    private Byte[] cfbOutV;
    private bool encrypting;
    private int blockSize;
    private IBlockCipher cipher;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public CfbBlockCipher(IBlockCipher cipher, int bitBlockSize);
    public IBlockCipher GetUnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    public int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Modes.ChaCha20Poly1305 : object {
    private static int BufSize;
    private static int KeySize;
    private static int NonceSize;
    private static int MacSize;
    private static Byte[] Zeroes;
    private static ulong AadLimit;
    private static ulong DataLimit;
    private ChaCha7539Engine mChacha20;
    private IMac mPoly1305;
    private Byte[] mKey;
    private Byte[] mNonce;
    private Byte[] mBuf;
    private Byte[] mMac;
    private Byte[] mInitialAad;
    private ulong mAadCount;
    private ulong mDataCount;
    private State mState;
    private int mBufPos;
    public string AlgorithmName { get; }
    public ChaCha20Poly1305(IMac poly1305);
    private static ChaCha20Poly1305();
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetOutputSize(int len);
    public virtual int GetUpdateOutputSize(int len);
    public virtual void ProcessAadByte(byte input);
    public virtual void ProcessAadBytes(Byte[] inBytes, int inOff, int len);
    public virtual int ProcessByte(byte input, Byte[] outBytes, int outOff);
    public virtual int ProcessBytes(Byte[] inBytes, int inOff, int len, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] outBytes, int outOff);
    public virtual Byte[] GetMac();
    public virtual void Reset();
    private void CheckAad();
    private void CheckData();
    private void FinishAad(State nextState);
    private void FinishData(State nextState);
    private ulong IncrementCount(ulong count, UInt32 increment, ulong limit);
    private void InitMac();
    private void PadMac(ulong count);
    private void ProcessData(Byte[] inBytes, int inOff, int inLen, Byte[] outBytes, int outOff);
    private void Reset(bool clearMac, bool resetCipher);
}
public class Org.BouncyCastle.Crypto.Modes.CtsBlockCipher : BufferedBlockCipher {
    private int blockSize;
    public CtsBlockCipher(IBlockCipher cipher);
    public virtual int GetUpdateOutputSize(int length);
    public virtual int GetOutputSize(int length);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
}
public class Org.BouncyCastle.Crypto.Modes.EaxBlockCipher : object {
    private SicBlockCipher cipher;
    private bool forEncryption;
    private int blockSize;
    private IMac mac;
    private Byte[] nonceMac;
    private Byte[] associatedTextMac;
    private Byte[] macBlock;
    private int macSize;
    private Byte[] bufBlock;
    private int bufOff;
    private bool cipherInitialized;
    private Byte[] initialAssociatedText;
    public string AlgorithmName { get; }
    public EaxBlockCipher(IBlockCipher cipher);
    public virtual string get_AlgorithmName();
    public virtual IBlockCipher GetUnderlyingCipher();
    public virtual int GetBlockSize();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    private void InitCipher();
    private void CalculateMac();
    public virtual void Reset();
    private void Reset(bool clearMac);
    public virtual void ProcessAadByte(byte input);
    public virtual void ProcessAadBytes(Byte[] inBytes, int inOff, int len);
    public virtual int ProcessByte(byte input, Byte[] outBytes, int outOff);
    public virtual int ProcessBytes(Byte[] inBytes, int inOff, int len, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] outBytes, int outOff);
    public virtual Byte[] GetMac();
    public virtual int GetUpdateOutputSize(int len);
    public virtual int GetOutputSize(int len);
    private int Process(byte b, Byte[] outBytes, int outOff);
    private bool VerifyMac(Byte[] mac, int off);
}
public class Org.BouncyCastle.Crypto.Modes.Gcm.BasicGcmExponentiator : object {
    private UInt64[] x;
    public sealed virtual void Init(Byte[] x);
    public sealed virtual void ExponentiateX(long pow, Byte[] output);
}
public class Org.BouncyCastle.Crypto.Modes.Gcm.BasicGcmMultiplier : object {
    private UInt64[] H;
    public sealed virtual void Init(Byte[] H);
    public sealed virtual void MultiplyH(Byte[] x);
}
internal abstract class Org.BouncyCastle.Crypto.Modes.Gcm.GcmUtilities : object {
    private static UInt32 E1;
    private static ulong E1UL;
    internal static Byte[] OneAsBytes();
    internal static UInt32[] OneAsUints();
    internal static UInt64[] OneAsUlongs();
    internal static Byte[] AsBytes(UInt32[] x);
    internal static void AsBytes(UInt32[] x, Byte[] z);
    internal static Byte[] AsBytes(UInt64[] x);
    internal static void AsBytes(UInt64[] x, Byte[] z);
    internal static UInt32[] AsUints(Byte[] bs);
    internal static void AsUints(Byte[] bs, UInt32[] output);
    internal static UInt64[] AsUlongs(Byte[] x);
    internal static void AsUlongs(Byte[] x, UInt64[] z);
    internal static void AsUlongs(Byte[] x, UInt64[] z, int zOff);
    internal static void Copy(UInt32[] x, UInt32[] z);
    internal static void Copy(UInt64[] x, UInt64[] z);
    internal static void Copy(UInt64[] x, int xOff, UInt64[] z, int zOff);
    internal static void DivideP(UInt64[] x, UInt64[] z);
    internal static void DivideP(UInt64[] x, int xOff, UInt64[] z, int zOff);
    internal static void Multiply(Byte[] x, Byte[] y);
    internal static void Multiply(UInt32[] x, UInt32[] y);
    internal static void Multiply(UInt64[] x, UInt64[] y);
    internal static void MultiplyP(UInt32[] x);
    internal static void MultiplyP(UInt32[] x, UInt32[] z);
    internal static void MultiplyP(UInt64[] x);
    internal static void MultiplyP(UInt64[] x, UInt64[] z);
    internal static void MultiplyP3(UInt64[] x, UInt64[] z);
    internal static void MultiplyP3(UInt64[] x, int xOff, UInt64[] z, int zOff);
    internal static void MultiplyP4(UInt64[] x, UInt64[] z);
    internal static void MultiplyP4(UInt64[] x, int xOff, UInt64[] z, int zOff);
    internal static void MultiplyP7(UInt64[] x, UInt64[] z);
    internal static void MultiplyP7(UInt64[] x, int xOff, UInt64[] z, int zOff);
    internal static void MultiplyP8(UInt32[] x);
    internal static void MultiplyP8(UInt32[] x, UInt32[] y);
    internal static void MultiplyP8(UInt64[] x);
    internal static void MultiplyP8(UInt64[] x, UInt64[] y);
    internal static void MultiplyP8(UInt64[] x, int xOff, UInt64[] y, int yOff);
    internal static void Square(UInt64[] x, UInt64[] z);
    internal static void Xor(Byte[] x, Byte[] y);
    internal static void Xor(Byte[] x, Byte[] y, int yOff);
    internal static void Xor(Byte[] x, int xOff, Byte[] y, int yOff, Byte[] z, int zOff);
    internal static void Xor(Byte[] x, Byte[] y, int yOff, int yLen);
    internal static void Xor(Byte[] x, int xOff, Byte[] y, int yOff, int len);
    internal static void Xor(Byte[] x, Byte[] y, Byte[] z);
    internal static void Xor(UInt32[] x, UInt32[] y);
    internal static void Xor(UInt32[] x, UInt32[] y, UInt32[] z);
    internal static void Xor(UInt64[] x, UInt64[] y);
    internal static void Xor(UInt64[] x, int xOff, UInt64[] y, int yOff);
    internal static void Xor(UInt64[] x, UInt64[] y, UInt64[] z);
    internal static void Xor(UInt64[] x, int xOff, UInt64[] y, int yOff, UInt64[] z, int zOff);
    private static ulong ImplMul64(ulong x, ulong y);
}
public interface Org.BouncyCastle.Crypto.Modes.Gcm.IGcmExponentiator {
    public abstract virtual void Init(Byte[] x);
    public abstract virtual void ExponentiateX(long pow, Byte[] output);
}
public interface Org.BouncyCastle.Crypto.Modes.Gcm.IGcmMultiplier {
    public abstract virtual void Init(Byte[] H);
    public abstract virtual void MultiplyH(Byte[] x);
}
public class Org.BouncyCastle.Crypto.Modes.Gcm.Tables1kGcmExponentiator : object {
    private IList lookupPowX2;
    public sealed virtual void Init(Byte[] x);
    public sealed virtual void ExponentiateX(long pow, Byte[] output);
    private void EnsureAvailable(int bit);
}
public class Org.BouncyCastle.Crypto.Modes.Gcm.Tables4kGcmMultiplier : object {
    private Byte[] H;
    private UInt64[] T;
    public sealed virtual void Init(Byte[] H);
    public sealed virtual void MultiplyH(Byte[] x);
}
public class Org.BouncyCastle.Crypto.Modes.Gcm.Tables64kGcmMultiplier : object {
    private Byte[] H;
    private UInt64[][] T;
    public sealed virtual void Init(Byte[] H);
    public sealed virtual void MultiplyH(Byte[] x);
}
public class Org.BouncyCastle.Crypto.Modes.Gcm.Tables8kGcmMultiplier : object {
    private Byte[] H;
    private UInt64[][] T;
    public sealed virtual void Init(Byte[] H);
    public sealed virtual void MultiplyH(Byte[] x);
}
public class Org.BouncyCastle.Crypto.Modes.GcmBlockCipher : object {
    private static int BlockSize;
    private IBlockCipher cipher;
    private IGcmMultiplier multiplier;
    private IGcmExponentiator exp;
    private bool forEncryption;
    private bool initialised;
    private int macSize;
    private Byte[] lastKey;
    private Byte[] nonce;
    private Byte[] initialAssociatedText;
    private Byte[] H;
    private Byte[] J0;
    private Byte[] bufBlock;
    private Byte[] macBlock;
    private Byte[] S;
    private Byte[] S_at;
    private Byte[] S_atPre;
    private Byte[] counter;
    private UInt32 blocksRemaining;
    private int bufOff;
    private ulong totalLength;
    private Byte[] atBlock;
    private int atBlockPos;
    private ulong atLength;
    private ulong atLengthPre;
    public string AlgorithmName { get; }
    public GcmBlockCipher(IBlockCipher c);
    public GcmBlockCipher(IBlockCipher c, IGcmMultiplier m);
    public virtual string get_AlgorithmName();
    public sealed virtual IBlockCipher GetUnderlyingCipher();
    public virtual int GetBlockSize();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual Byte[] GetMac();
    public virtual int GetOutputSize(int len);
    public virtual int GetUpdateOutputSize(int len);
    public virtual void ProcessAadByte(byte input);
    public virtual void ProcessAadBytes(Byte[] inBytes, int inOff, int len);
    private void InitCipher();
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual int ProcessBytes(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private void Reset(bool clearMac);
    private void ProcessBlock(Byte[] buf, int bufOff, Byte[] output, int outOff);
    private void ProcessPartial(Byte[] buf, int off, int len, Byte[] output, int outOff);
    private void gHASH(Byte[] Y, Byte[] b, int len);
    private void gHASHBlock(Byte[] Y, Byte[] b);
    private void gHASHBlock(Byte[] Y, Byte[] b, int off);
    private void gHASHPartial(Byte[] Y, Byte[] b, int off, int len);
    private void GetNextCtrBlock(Byte[] block);
    private void CheckStatus();
}
public class Org.BouncyCastle.Crypto.Modes.GcmSivBlockCipher : object {
    private static int BUFLEN;
    private static int HALFBUFLEN;
    private static int NONCELEN;
    private static int MAX_DATALEN;
    private static byte MASK;
    private static byte ADD;
    private static int INIT;
    private static int AEAD_COMPLETE;
    private IBlockCipher theCipher;
    private IGcmMultiplier theMultiplier;
    internal Byte[] theGHash;
    internal Byte[] theReverse;
    private GcmSivHasher theAEADHasher;
    private GcmSivHasher theDataHasher;
    private GcmSivCache thePlain;
    private GcmSivCache theEncData;
    private bool forEncryption;
    private Byte[] theInitialAEAD;
    private Byte[] theNonce;
    private int theFlags;
    public string AlgorithmName { get; }
    public GcmSivBlockCipher(IBlockCipher pCipher);
    public GcmSivBlockCipher(IBlockCipher pCipher, IGcmMultiplier pMultiplier);
    private static GcmSivBlockCipher();
    public virtual IBlockCipher GetUnderlyingCipher();
    public virtual int GetBlockSize();
    public virtual void Init(bool pEncrypt, ICipherParameters cipherParameters);
    public virtual string get_AlgorithmName();
    private void CheckAeadStatus(int pLen);
    private void CheckStatus(int pLen);
    public virtual void ProcessAadByte(byte pByte);
    public virtual void ProcessAadBytes(Byte[] pData, int pOffset, int pLen);
    public virtual int ProcessByte(byte pByte, Byte[] pOutput, int pOutOffset);
    public virtual int ProcessBytes(Byte[] pData, int pOffset, int pLen, Byte[] pOutput, int pOutOffset);
    public virtual int DoFinal(Byte[] pOutput, int pOffset);
    public virtual Byte[] GetMac();
    public virtual int GetUpdateOutputSize(int pLen);
    public virtual int GetOutputSize(int pLen);
    public virtual void Reset();
    private void ResetStreams();
    private static int bufLength(Byte[] pBuffer);
    private static void CheckBuffer(Byte[] pBuffer, int pOffset, int pLen, bool pOutput);
    private int encryptPlain(Byte[] pCounter, Byte[] pTarget, int pOffset);
    private void decryptPlain();
    private Byte[] calculateTag();
    private Byte[] completePolyVal();
    private void gHashLengths();
    private void gHASH(Byte[] pNext);
    private static void fillReverse(Byte[] pInput, int pOffset, int pLength, Byte[] pOutput);
    private static void xorBlock(Byte[] pLeft, Byte[] pRight);
    private static void xorBlock(Byte[] pLeft, Byte[] pRight, int pOffset, int pLength);
    private static void incrementCounter(Byte[] pCounter);
    private static void mulX(Byte[] pValue);
    private void deriveKeys(KeyParameter pKey);
}
public class Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher : object {
    private Byte[] IV;
    private Byte[] ofbV;
    private Byte[] ofbOutV;
    private int blockSize;
    private IBlockCipher cipher;
    private bool firstStep;
    private int N3;
    private int N4;
    private static int C1;
    private static int C2;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public GOfbBlockCipher(IBlockCipher cipher);
    public IBlockCipher GetUnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private int bytesToint(Byte[] inBytes, int inOff);
    private void intTobytes(int num, Byte[] outBytes, int outOff);
}
public interface Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher {
    public abstract virtual int GetBlockSize();
    public abstract virtual IBlockCipher GetUnderlyingCipher();
}
public interface Org.BouncyCastle.Crypto.Modes.IAeadCipher {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual void ProcessAadByte(byte input);
    public abstract virtual void ProcessAadBytes(Byte[] inBytes, int inOff, int len);
    public abstract virtual int ProcessByte(byte input, Byte[] outBytes, int outOff);
    public abstract virtual int ProcessBytes(Byte[] inBytes, int inOff, int len, Byte[] outBytes, int outOff);
    public abstract virtual int DoFinal(Byte[] outBytes, int outOff);
    public abstract virtual Byte[] GetMac();
    public abstract virtual int GetUpdateOutputSize(int len);
    public abstract virtual int GetOutputSize(int len);
    public abstract virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Modes.KCcmBlockCipher : object {
    private static int BYTES_IN_INT;
    private static int BITS_IN_BYTE;
    private static int MAX_MAC_BIT_LENGTH;
    private static int MIN_MAC_BIT_LENGTH;
    private IBlockCipher engine;
    private int macSize;
    private bool forEncryption;
    private Byte[] initialAssociatedText;
    private Byte[] mac;
    private Byte[] macBlock;
    private Byte[] nonce;
    private Byte[] G1;
    private Byte[] buffer;
    private Byte[] s;
    private Byte[] counter;
    private MemoryStream associatedText;
    private MemoryStream data;
    private int Nb_;
    public string AlgorithmName { get; }
    public KCcmBlockCipher(IBlockCipher engine);
    public KCcmBlockCipher(IBlockCipher engine, int Nb);
    private static KCcmBlockCipher();
    private void setNb(int Nb);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual IBlockCipher GetUnderlyingCipher();
    public virtual void ProcessAadByte(byte input);
    public virtual void ProcessAadBytes(Byte[] input, int inOff, int len);
    private void ProcessAAD(Byte[] assocText, int assocOff, int assocLen, int dataLen);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual int ProcessBytes(Byte[] input, int inOff, int inLen, Byte[] output, int outOff);
    public int ProcessPacket(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    private void ProcessBlock(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    private void CalculateMac(Byte[] authText, int authOff, int len);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual Byte[] GetMac();
    public virtual int GetUpdateOutputSize(int len);
    public virtual int GetOutputSize(int len);
    public virtual void Reset();
    private void intToBytes(int num, Byte[] outBytes, int outOff);
    private byte getFlag(bool authTextPresents, int macSize);
}
public class Org.BouncyCastle.Crypto.Modes.KCtrBlockCipher : object {
    private Byte[] IV;
    private Byte[] ofbV;
    private Byte[] ofbOutV;
    private bool initialised;
    private int byteCount;
    private int blockSize;
    private IBlockCipher cipher;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public KCtrBlockCipher(IBlockCipher cipher);
    public IBlockCipher GetUnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual byte ReturnByte(byte input);
    public sealed virtual void ProcessBytes(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    protected byte CalculateByte(byte b);
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void incrementCounterAt(int pos);
    private void checkCounter();
}
public class Org.BouncyCastle.Crypto.Modes.OcbBlockCipher : object {
    private static int BLOCK_SIZE;
    private IBlockCipher hashCipher;
    private IBlockCipher mainCipher;
    private bool forEncryption;
    private int macSize;
    private Byte[] initialAssociatedText;
    private IList L;
    private Byte[] L_Asterisk;
    private Byte[] L_Dollar;
    private Byte[] KtopInput;
    private Byte[] Stretch;
    private Byte[] OffsetMAIN_0;
    private Byte[] hashBlock;
    private Byte[] mainBlock;
    private int hashBlockPos;
    private int mainBlockPos;
    private long hashBlockCount;
    private long mainBlockCount;
    private Byte[] OffsetHASH;
    private Byte[] Sum;
    private Byte[] OffsetMAIN;
    private Byte[] Checksum;
    private Byte[] macBlock;
    public string AlgorithmName { get; }
    public OcbBlockCipher(IBlockCipher hashCipher, IBlockCipher mainCipher);
    public virtual IBlockCipher GetUnderlyingCipher();
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    protected virtual int ProcessNonce(Byte[] N);
    public virtual int GetBlockSize();
    public virtual Byte[] GetMac();
    public virtual int GetOutputSize(int len);
    public virtual int GetUpdateOutputSize(int len);
    public virtual void ProcessAadByte(byte input);
    public virtual void ProcessAadBytes(Byte[] input, int off, int len);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual int ProcessBytes(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    protected virtual void Clear(Byte[] bs);
    protected virtual Byte[] GetLSub(int n);
    protected virtual void ProcessHashBlock();
    protected virtual void ProcessMainBlock(Byte[] output, int outOff);
    protected virtual void Reset(bool clearMac);
    protected virtual void UpdateHASH(Byte[] LSub);
    protected static Byte[] OCB_double(Byte[] block);
    protected static void OCB_extend(Byte[] block, int pos);
    protected static int OCB_ntz(long x);
    protected static int ShiftLeft(Byte[] block, Byte[] output);
    protected static void Xor(Byte[] block, Byte[] val);
}
public class Org.BouncyCastle.Crypto.Modes.OfbBlockCipher : object {
    private Byte[] IV;
    private Byte[] ofbV;
    private Byte[] ofbOutV;
    private int blockSize;
    private IBlockCipher cipher;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public OfbBlockCipher(IBlockCipher cipher, int blockSize);
    public IBlockCipher GetUnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher : object {
    private Byte[] IV;
    private Byte[] FR;
    private Byte[] FRE;
    private IBlockCipher cipher;
    private int blockSize;
    private int count;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public OpenPgpCfbBlockCipher(IBlockCipher cipher);
    public IBlockCipher GetUnderlyingCipher();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    private byte EncryptByte(byte data, int blockOff);
    private int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Modes.SicBlockCipher : object {
    private IBlockCipher cipher;
    private int blockSize;
    private Byte[] counter;
    private Byte[] counterOut;
    private Byte[] IV;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public SicBlockCipher(IBlockCipher cipher);
    public virtual IBlockCipher GetUnderlyingCipher();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Operators.Asn1CipherBuilderWithKey : object {
    private KeyParameter encKey;
    private AlgorithmIdentifier algorithmIdentifier;
    public object AlgorithmDetails { get; }
    public ICipherParameters Key { get; }
    public Asn1CipherBuilderWithKey(DerObjectIdentifier encryptionOID, int keySize, SecureRandom random);
    public sealed virtual object get_AlgorithmDetails();
    public sealed virtual int GetMaxOutputSize(int inputLen);
    public sealed virtual ICipher BuildCipher(Stream stream);
    public sealed virtual ICipherParameters get_Key();
}
public class Org.BouncyCastle.Crypto.Operators.Asn1DigestFactory : object {
    private IDigest mDigest;
    private DerObjectIdentifier mOid;
    public object AlgorithmDetails { get; }
    public int DigestLength { get; }
    public Asn1DigestFactory(IDigest digest, DerObjectIdentifier oid);
    public static Asn1DigestFactory Get(DerObjectIdentifier oid);
    public static Asn1DigestFactory Get(string mechanism);
    public virtual object get_AlgorithmDetails();
    public virtual int get_DigestLength();
    public virtual IStreamCalculator CreateCalculator();
}
public class Org.BouncyCastle.Crypto.Operators.Asn1KeyUnwrapper : object {
    private string algorithm;
    private IKeyUnwrapper wrapper;
    public object AlgorithmDetails { get; }
    public Asn1KeyUnwrapper(string algorithm, ICipherParameters key);
    public Asn1KeyUnwrapper(DerObjectIdentifier algorithm, ICipherParameters key);
    public Asn1KeyUnwrapper(DerObjectIdentifier algorithm, Asn1Encodable parameters, ICipherParameters key);
    public sealed virtual object get_AlgorithmDetails();
    public sealed virtual IBlockResult Unwrap(Byte[] keyData, int offSet, int length);
}
public class Org.BouncyCastle.Crypto.Operators.Asn1KeyWrapper : object {
    private string algorithm;
    private IKeyWrapper wrapper;
    public object AlgorithmDetails { get; }
    public Asn1KeyWrapper(string algorithm, X509Certificate cert);
    public Asn1KeyWrapper(DerObjectIdentifier algorithm, X509Certificate cert);
    public Asn1KeyWrapper(DerObjectIdentifier algorithm, ICipherParameters key);
    public Asn1KeyWrapper(DerObjectIdentifier algorithm, Asn1Encodable parameters, X509Certificate cert);
    public Asn1KeyWrapper(DerObjectIdentifier algorithm, Asn1Encodable parameters, ICipherParameters key);
    public sealed virtual object get_AlgorithmDetails();
    public sealed virtual IBlockResult Wrap(Byte[] keyData);
}
public class Org.BouncyCastle.Crypto.Operators.Asn1SignatureFactory : object {
    private AlgorithmIdentifier algID;
    private string algorithm;
    private AsymmetricKeyParameter privateKey;
    private SecureRandom random;
    public object AlgorithmDetails { get; }
    public static IEnumerable SignatureAlgNames { get; }
    public Asn1SignatureFactory(string algorithm, AsymmetricKeyParameter privateKey);
    public Asn1SignatureFactory(string algorithm, AsymmetricKeyParameter privateKey, SecureRandom random);
    public sealed virtual object get_AlgorithmDetails();
    public sealed virtual IStreamCalculator CreateCalculator();
    public static IEnumerable get_SignatureAlgNames();
}
public class Org.BouncyCastle.Crypto.Operators.Asn1VerifierFactory : object {
    private AlgorithmIdentifier algID;
    private AsymmetricKeyParameter publicKey;
    public object AlgorithmDetails { get; }
    public Asn1VerifierFactory(string algorithm, AsymmetricKeyParameter publicKey);
    public Asn1VerifierFactory(AlgorithmIdentifier algorithm, AsymmetricKeyParameter publicKey);
    public sealed virtual object get_AlgorithmDetails();
    public sealed virtual IStreamCalculator CreateCalculator();
}
public class Org.BouncyCastle.Crypto.Operators.Asn1VerifierFactoryProvider : object {
    private AsymmetricKeyParameter publicKey;
    public IEnumerable SignatureAlgNames { get; }
    public Asn1VerifierFactoryProvider(AsymmetricKeyParameter publicKey);
    public sealed virtual IVerifierFactory CreateVerifierFactory(object algorithmDetails);
    public IEnumerable get_SignatureAlgNames();
}
public class Org.BouncyCastle.Crypto.Operators.BufferedCipherWrapper : object {
    private IBufferedCipher bufferedCipher;
    private CipherStream stream;
    public Stream Stream { get; }
    public BufferedCipherWrapper(IBufferedCipher bufferedCipher, Stream source);
    public sealed virtual int GetMaxOutputSize(int inputLen);
    public sealed virtual int GetUpdateOutputSize(int inputLen);
    public sealed virtual Stream get_Stream();
}
public class Org.BouncyCastle.Crypto.Operators.DefaultSignatureCalculator : object {
    private SignerSink mSignerSink;
    public Stream Stream { get; }
    public DefaultSignatureCalculator(ISigner signer);
    public sealed virtual Stream get_Stream();
    public sealed virtual object GetResult();
}
public class Org.BouncyCastle.Crypto.Operators.DefaultSignatureResult : object {
    private ISigner mSigner;
    public DefaultSignatureResult(ISigner signer);
    public sealed virtual Byte[] Collect();
    public sealed virtual int Collect(Byte[] sig, int sigOff);
}
public class Org.BouncyCastle.Crypto.Operators.DefaultVerifierCalculator : object {
    private SignerSink mSignerSink;
    public Stream Stream { get; }
    public DefaultVerifierCalculator(ISigner signer);
    public sealed virtual Stream get_Stream();
    public sealed virtual object GetResult();
}
public class Org.BouncyCastle.Crypto.Operators.DefaultVerifierResult : object {
    private ISigner mSigner;
    public DefaultVerifierResult(ISigner signer);
    public sealed virtual bool IsVerified(Byte[] signature);
    public sealed virtual bool IsVerified(Byte[] sig, int sigOff, int sigLen);
}
internal class Org.BouncyCastle.Crypto.Operators.DfDigestStream : object {
    private DigestSink mStream;
    public Stream Stream { get; }
    public DfDigestStream(IDigest digest);
    public sealed virtual Stream get_Stream();
    public sealed virtual object GetResult();
}
public class Org.BouncyCastle.Crypto.Operators.GenericKey : object {
    private AlgorithmIdentifier algorithmIdentifier;
    private object representation;
    public AlgorithmIdentifier AlgorithmIdentifier { get; }
    public object Representation { get; }
    public GenericKey(object representation);
    public GenericKey(AlgorithmIdentifier algorithmIdentifier, Byte[] representation);
    public GenericKey(AlgorithmIdentifier algorithmIdentifier, object representation);
    public AlgorithmIdentifier get_AlgorithmIdentifier();
    public object get_Representation();
}
internal class Org.BouncyCastle.Crypto.Operators.KeyWrapperUtil : object {
    private static IDictionary providerMap;
    private static KeyWrapperUtil();
    public static IKeyWrapper WrapperForName(string algorithm, ICipherParameters parameters);
    public static IKeyUnwrapper UnwrapperForName(string algorithm, ICipherParameters parameters);
}
internal class Org.BouncyCastle.Crypto.Operators.RsaOaepWrapper : object {
    private AlgorithmIdentifier algId;
    private IAsymmetricBlockCipher engine;
    public object AlgorithmDetails { get; }
    public RsaOaepWrapper(bool forWrapping, ICipherParameters parameters, DerObjectIdentifier digestOid);
    public RsaOaepWrapper(bool forWrapping, ICipherParameters parameters, DerObjectIdentifier digestOid, DerObjectIdentifier mgfOid);
    public sealed virtual object get_AlgorithmDetails();
    public sealed virtual IBlockResult Unwrap(Byte[] cipherText, int offset, int length);
    public sealed virtual IBlockResult Wrap(Byte[] keyData);
}
internal class Org.BouncyCastle.Crypto.Operators.RsaOaepWrapperProvider : object {
    private DerObjectIdentifier digestOid;
    private DerObjectIdentifier mgfOid;
    internal RsaOaepWrapperProvider(DerObjectIdentifier digestOid);
    internal RsaOaepWrapperProvider(DerObjectIdentifier digestOid, DerObjectIdentifier mgfOid);
    private sealed virtual override object Org.BouncyCastle.Crypto.Operators.WrapperProvider.CreateWrapper(bool forWrapping, ICipherParameters parameters);
}
internal class Org.BouncyCastle.Crypto.Operators.RsaPkcs1Wrapper : object {
    private AlgorithmIdentifier algId;
    private IAsymmetricBlockCipher engine;
    public object AlgorithmDetails { get; }
    public RsaPkcs1Wrapper(bool forWrapping, ICipherParameters parameters);
    public sealed virtual object get_AlgorithmDetails();
    public sealed virtual IBlockResult Unwrap(Byte[] cipherText, int offset, int length);
    public sealed virtual IBlockResult Wrap(Byte[] keyData);
}
internal class Org.BouncyCastle.Crypto.Operators.RsaPkcs1WrapperProvider : object {
    private sealed virtual override object Org.BouncyCastle.Crypto.Operators.WrapperProvider.CreateWrapper(bool forWrapping, ICipherParameters parameters);
}
internal interface Org.BouncyCastle.Crypto.Operators.WrapperProvider {
    public abstract virtual object CreateWrapper(bool forWrapping, ICipherParameters parameters);
}
internal class Org.BouncyCastle.Crypto.Operators.X509Utilities : object {
    private static Asn1Null derNull;
    private static IDictionary algorithms;
    private static IDictionary exParams;
    private static ISet noParams;
    private static X509Utilities();
    private static string GetDigestAlgName(DerObjectIdentifier digestAlgOID);
    internal static string GetSignatureName(AlgorithmIdentifier sigAlgId);
    private static RsassaPssParameters CreatePssParams(AlgorithmIdentifier hashAlgId, int saltSize);
    internal static DerObjectIdentifier GetAlgorithmOid(string algorithmName);
    internal static AlgorithmIdentifier GetSigAlgID(DerObjectIdentifier sigOid, string algorithmName);
    internal static IEnumerable GetAlgNames();
}
public class Org.BouncyCastle.Crypto.OutputLengthException : DataLengthException {
    public OutputLengthException(string message);
    public OutputLengthException(string message, Exception exception);
}
public interface Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding {
    public string PaddingName { get; }
    public abstract virtual void Init(SecureRandom random);
    public abstract virtual string get_PaddingName();
    public abstract virtual int AddPadding(Byte[] input, int inOff);
    public abstract virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Paddings.ISO10126d2Padding : object {
    private SecureRandom random;
    public string PaddingName { get; }
    public sealed virtual void Init(SecureRandom random);
    public sealed virtual string get_PaddingName();
    public sealed virtual int AddPadding(Byte[] input, int inOff);
    public sealed virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Paddings.ISO7816d4Padding : object {
    public string PaddingName { get; }
    public sealed virtual void Init(SecureRandom random);
    public sealed virtual string get_PaddingName();
    public sealed virtual int AddPadding(Byte[] input, int inOff);
    public sealed virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher : BufferedBlockCipher {
    private IBlockCipherPadding padding;
    public PaddedBufferedBlockCipher(IBlockCipher cipher, IBlockCipherPadding padding);
    public PaddedBufferedBlockCipher(IBlockCipher cipher);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetOutputSize(int length);
    public virtual int GetUpdateOutputSize(int length);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
}
public class Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding : object {
    public string PaddingName { get; }
    public sealed virtual void Init(SecureRandom random);
    public sealed virtual string get_PaddingName();
    public sealed virtual int AddPadding(Byte[] input, int inOff);
    public sealed virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Paddings.TbcPadding : object {
    public string PaddingName { get; }
    public sealed virtual string get_PaddingName();
    public virtual void Init(SecureRandom random);
    public virtual int AddPadding(Byte[] input, int inOff);
    public virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Paddings.X923Padding : object {
    private SecureRandom random;
    public string PaddingName { get; }
    public sealed virtual void Init(SecureRandom random);
    public sealed virtual string get_PaddingName();
    public sealed virtual int AddPadding(Byte[] input, int inOff);
    public sealed virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Paddings.ZeroBytePadding : object {
    public string PaddingName { get; }
    public sealed virtual string get_PaddingName();
    public sealed virtual void Init(SecureRandom random);
    public sealed virtual int AddPadding(Byte[] input, int inOff);
    public sealed virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Parameters.AeadParameters : object {
    private Byte[] associatedText;
    private Byte[] nonce;
    private KeyParameter key;
    private int macSize;
    public KeyParameter Key { get; }
    public int MacSize { get; }
    public AeadParameters(KeyParameter key, int macSize, Byte[] nonce);
    public AeadParameters(KeyParameter key, int macSize, Byte[] nonce, Byte[] associatedText);
    public virtual KeyParameter get_Key();
    public virtual int get_MacSize();
    public virtual Byte[] GetAssociatedText();
    public virtual Byte[] GetNonce();
}
[ObsoleteAttribute("Use AeadParameters")]
public class Org.BouncyCastle.Crypto.Parameters.CcmParameters : AeadParameters {
    public CcmParameters(KeyParameter key, int macSize, Byte[] nonce, Byte[] associatedText);
}
public class Org.BouncyCastle.Crypto.Parameters.DesEdeParameters : DesParameters {
    public static int DesEdeKeyLength;
    public DesEdeParameters(Byte[] key);
    public DesEdeParameters(Byte[] key, int keyOff, int keyLen);
    private static Byte[] FixKey(Byte[] key, int keyOff, int keyLen);
    public static bool IsWeakKey(Byte[] key, int offset, int length);
    public static bool IsWeakKey(Byte[] key, int offset);
    public static bool IsWeakKey(Byte[] key);
    public static bool IsRealEdeKey(Byte[] key, int offset);
    public static bool IsReal2Key(Byte[] key, int offset);
    public static bool IsReal3Key(Byte[] key, int offset);
}
public class Org.BouncyCastle.Crypto.Parameters.DesParameters : KeyParameter {
    public static int DesKeyLength;
    private static int N_DES_WEAK_KEYS;
    private static Byte[] DES_weak_keys;
    public DesParameters(Byte[] key);
    public DesParameters(Byte[] key, int keyOff, int keyLen);
    private static DesParameters();
    public static bool IsWeakKey(Byte[] key, int offset);
    public static bool IsWeakKey(Byte[] key);
    public static byte SetOddParity(byte b);
    public static void SetOddParity(Byte[] bytes);
    public static void SetOddParity(Byte[] bytes, int off, int len);
}
public class Org.BouncyCastle.Crypto.Parameters.DHKeyGenerationParameters : KeyGenerationParameters {
    private DHParameters parameters;
    public DHParameters Parameters { get; }
    public DHKeyGenerationParameters(SecureRandom random, DHParameters parameters);
    public DHParameters get_Parameters();
    internal static int GetStrength(DHParameters parameters);
}
public class Org.BouncyCastle.Crypto.Parameters.DHKeyParameters : AsymmetricKeyParameter {
    private DHParameters parameters;
    private DerObjectIdentifier algorithmOid;
    public DHParameters Parameters { get; }
    public DerObjectIdentifier AlgorithmOid { get; }
    protected DHKeyParameters(bool isPrivate, DHParameters parameters);
    protected DHKeyParameters(bool isPrivate, DHParameters parameters, DerObjectIdentifier algorithmOid);
    public DHParameters get_Parameters();
    public DerObjectIdentifier get_AlgorithmOid();
    public virtual bool Equals(object obj);
    protected bool Equals(DHKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DHParameters : object {
    private static int DefaultMinimumLength;
    private BigInteger p;
    private BigInteger g;
    private BigInteger q;
    private BigInteger j;
    private int m;
    private int l;
    private DHValidationParameters validation;
    public BigInteger P { get; }
    public BigInteger G { get; }
    public BigInteger Q { get; }
    public BigInteger J { get; }
    public int M { get; }
    public int L { get; }
    public DHValidationParameters ValidationParameters { get; }
    public DHParameters(BigInteger p, BigInteger g);
    public DHParameters(BigInteger p, BigInteger g, BigInteger q);
    public DHParameters(BigInteger p, BigInteger g, BigInteger q, int l);
    public DHParameters(BigInteger p, BigInteger g, BigInteger q, int m, int l);
    public DHParameters(BigInteger p, BigInteger g, BigInteger q, BigInteger j, DHValidationParameters validation);
    public DHParameters(BigInteger p, BigInteger g, BigInteger q, int m, int l, BigInteger j, DHValidationParameters validation);
    private static int GetDefaultMParam(int lParam);
    public BigInteger get_P();
    public BigInteger get_G();
    public BigInteger get_Q();
    public BigInteger get_J();
    public int get_M();
    public int get_L();
    public DHValidationParameters get_ValidationParameters();
    public virtual bool Equals(object obj);
    protected virtual bool Equals(DHParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DHPrivateKeyParameters : DHKeyParameters {
    private BigInteger x;
    public BigInteger X { get; }
    public DHPrivateKeyParameters(BigInteger x, DHParameters parameters);
    public DHPrivateKeyParameters(BigInteger x, DHParameters parameters, DerObjectIdentifier algorithmOid);
    public BigInteger get_X();
    public virtual bool Equals(object obj);
    protected bool Equals(DHPrivateKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DHPublicKeyParameters : DHKeyParameters {
    private BigInteger y;
    public BigInteger Y { get; }
    public DHPublicKeyParameters(BigInteger y, DHParameters parameters);
    public DHPublicKeyParameters(BigInteger y, DHParameters parameters, DerObjectIdentifier algorithmOid);
    private static BigInteger Validate(BigInteger y, DHParameters dhParams);
    public virtual BigInteger get_Y();
    public virtual bool Equals(object obj);
    protected bool Equals(DHPublicKeyParameters other);
    public virtual int GetHashCode();
    private static int Legendre(BigInteger a, BigInteger b);
}
public class Org.BouncyCastle.Crypto.Parameters.DHValidationParameters : object {
    private Byte[] seed;
    private int counter;
    public int Counter { get; }
    public DHValidationParameters(Byte[] seed, int counter);
    public Byte[] GetSeed();
    public int get_Counter();
    public virtual bool Equals(object obj);
    protected bool Equals(DHValidationParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DsaKeyGenerationParameters : KeyGenerationParameters {
    private DsaParameters parameters;
    public DsaParameters Parameters { get; }
    public DsaKeyGenerationParameters(SecureRandom random, DsaParameters parameters);
    public DsaParameters get_Parameters();
}
public abstract class Org.BouncyCastle.Crypto.Parameters.DsaKeyParameters : AsymmetricKeyParameter {
    private DsaParameters parameters;
    public DsaParameters Parameters { get; }
    protected DsaKeyParameters(bool isPrivate, DsaParameters parameters);
    public DsaParameters get_Parameters();
    public virtual bool Equals(object obj);
    protected bool Equals(DsaKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DsaParameterGenerationParameters : object {
    public static int DigitalSignatureUsage;
    public static int KeyEstablishmentUsage;
    private int l;
    private int n;
    private int certainty;
    private SecureRandom random;
    private int usageIndex;
    public int L { get; }
    public int N { get; }
    public int UsageIndex { get; }
    public int Certainty { get; }
    public SecureRandom Random { get; }
    public DsaParameterGenerationParameters(int L, int N, int certainty, SecureRandom random);
    public DsaParameterGenerationParameters(int L, int N, int certainty, SecureRandom random, int usageIndex);
    public virtual int get_L();
    public virtual int get_N();
    public virtual int get_UsageIndex();
    public virtual int get_Certainty();
    public virtual SecureRandom get_Random();
}
public class Org.BouncyCastle.Crypto.Parameters.DsaParameters : object {
    private BigInteger p;
    private BigInteger q;
    private BigInteger g;
    private DsaValidationParameters validation;
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger G { get; }
    public DsaValidationParameters ValidationParameters { get; }
    public DsaParameters(BigInteger p, BigInteger q, BigInteger g);
    public DsaParameters(BigInteger p, BigInteger q, BigInteger g, DsaValidationParameters parameters);
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_G();
    public DsaValidationParameters get_ValidationParameters();
    public virtual bool Equals(object obj);
    protected bool Equals(DsaParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DsaPrivateKeyParameters : DsaKeyParameters {
    private BigInteger x;
    public BigInteger X { get; }
    public DsaPrivateKeyParameters(BigInteger x, DsaParameters parameters);
    public BigInteger get_X();
    public virtual bool Equals(object obj);
    protected bool Equals(DsaPrivateKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DsaPublicKeyParameters : DsaKeyParameters {
    private BigInteger y;
    public BigInteger Y { get; }
    public DsaPublicKeyParameters(BigInteger y, DsaParameters parameters);
    private static BigInteger Validate(BigInteger y, DsaParameters parameters);
    public BigInteger get_Y();
    public virtual bool Equals(object obj);
    protected bool Equals(DsaPublicKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DsaValidationParameters : object {
    private Byte[] seed;
    private int counter;
    private int usageIndex;
    public int Counter { get; }
    public int UsageIndex { get; }
    public DsaValidationParameters(Byte[] seed, int counter);
    public DsaValidationParameters(Byte[] seed, int counter, int usageIndex);
    public virtual Byte[] GetSeed();
    public virtual int get_Counter();
    public virtual int get_UsageIndex();
    public virtual bool Equals(object obj);
    protected virtual bool Equals(DsaValidationParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.ECDomainParameters : object {
    private ECCurve curve;
    private Byte[] seed;
    private ECPoint g;
    private BigInteger n;
    private BigInteger h;
    private BigInteger hInv;
    public ECCurve Curve { get; }
    public ECPoint G { get; }
    public BigInteger N { get; }
    public BigInteger H { get; }
    public BigInteger HInv { get; }
    public ECDomainParameters(X9ECParameters x9);
    public ECDomainParameters(ECCurve curve, ECPoint g, BigInteger n);
    public ECDomainParameters(ECCurve curve, ECPoint g, BigInteger n, BigInteger h);
    public ECDomainParameters(ECCurve curve, ECPoint g, BigInteger n, BigInteger h, Byte[] seed);
    public ECCurve get_Curve();
    public ECPoint get_G();
    public BigInteger get_N();
    public BigInteger get_H();
    public BigInteger get_HInv();
    public Byte[] GetSeed();
    public virtual bool Equals(object obj);
    protected virtual bool Equals(ECDomainParameters other);
    public virtual int GetHashCode();
    public BigInteger ValidatePrivateScalar(BigInteger d);
    public ECPoint ValidatePublicPoint(ECPoint q);
    internal static ECPoint ValidatePublicPoint(ECCurve c, ECPoint q);
}
public class Org.BouncyCastle.Crypto.Parameters.ECGost3410Parameters : ECNamedDomainParameters {
    private DerObjectIdentifier _publicKeyParamSet;
    private DerObjectIdentifier _digestParamSet;
    private DerObjectIdentifier _encryptionParamSet;
    public DerObjectIdentifier PublicKeyParamSet { get; }
    public DerObjectIdentifier DigestParamSet { get; }
    public DerObjectIdentifier EncryptionParamSet { get; }
    public ECGost3410Parameters(ECNamedDomainParameters dp, DerObjectIdentifier publicKeyParamSet, DerObjectIdentifier digestParamSet, DerObjectIdentifier encryptionParamSet);
    public ECGost3410Parameters(ECDomainParameters dp, DerObjectIdentifier publicKeyParamSet, DerObjectIdentifier digestParamSet, DerObjectIdentifier encryptionParamSet);
    public DerObjectIdentifier get_PublicKeyParamSet();
    public DerObjectIdentifier get_DigestParamSet();
    public DerObjectIdentifier get_EncryptionParamSet();
}
public class Org.BouncyCastle.Crypto.Parameters.ECKeyGenerationParameters : KeyGenerationParameters {
    private ECDomainParameters domainParams;
    private DerObjectIdentifier publicKeyParamSet;
    public ECDomainParameters DomainParameters { get; }
    public DerObjectIdentifier PublicKeyParamSet { get; }
    public ECKeyGenerationParameters(ECDomainParameters domainParameters, SecureRandom random);
    public ECKeyGenerationParameters(DerObjectIdentifier publicKeyParamSet, SecureRandom random);
    public ECDomainParameters get_DomainParameters();
    public DerObjectIdentifier get_PublicKeyParamSet();
}
public abstract class Org.BouncyCastle.Crypto.Parameters.ECKeyParameters : AsymmetricKeyParameter {
    private static String[] algorithms;
    private string algorithm;
    private ECDomainParameters parameters;
    private DerObjectIdentifier publicKeyParamSet;
    public string AlgorithmName { get; }
    public ECDomainParameters Parameters { get; }
    public DerObjectIdentifier PublicKeyParamSet { get; }
    protected ECKeyParameters(string algorithm, bool isPrivate, ECDomainParameters parameters);
    protected ECKeyParameters(string algorithm, bool isPrivate, DerObjectIdentifier publicKeyParamSet);
    private static ECKeyParameters();
    public string get_AlgorithmName();
    public ECDomainParameters get_Parameters();
    public DerObjectIdentifier get_PublicKeyParamSet();
    public virtual bool Equals(object obj);
    protected bool Equals(ECKeyParameters other);
    public virtual int GetHashCode();
    internal ECKeyGenerationParameters CreateKeyGenerationParameters(SecureRandom random);
    internal static string VerifyAlgorithmName(string algorithm);
    internal static ECDomainParameters LookupParameters(DerObjectIdentifier publicKeyParamSet);
}
public class Org.BouncyCastle.Crypto.Parameters.ECNamedDomainParameters : ECDomainParameters {
    private DerObjectIdentifier name;
    public DerObjectIdentifier Name { get; }
    public ECNamedDomainParameters(DerObjectIdentifier name, ECDomainParameters dp);
    public ECNamedDomainParameters(DerObjectIdentifier name, X9ECParameters x9);
    public ECNamedDomainParameters(DerObjectIdentifier name, ECCurve curve, ECPoint g, BigInteger n);
    public ECNamedDomainParameters(DerObjectIdentifier name, ECCurve curve, ECPoint g, BigInteger n, BigInteger h);
    public ECNamedDomainParameters(DerObjectIdentifier name, ECCurve curve, ECPoint g, BigInteger n, BigInteger h, Byte[] seed);
    public DerObjectIdentifier get_Name();
}
public class Org.BouncyCastle.Crypto.Parameters.ECPrivateKeyParameters : ECKeyParameters {
    private BigInteger d;
    public BigInteger D { get; }
    public ECPrivateKeyParameters(BigInteger d, ECDomainParameters parameters);
    [ObsoleteAttribute("Use version with explicit 'algorithm' parameter")]
public ECPrivateKeyParameters(BigInteger d, DerObjectIdentifier publicKeyParamSet);
    public ECPrivateKeyParameters(string algorithm, BigInteger d, ECDomainParameters parameters);
    public ECPrivateKeyParameters(string algorithm, BigInteger d, DerObjectIdentifier publicKeyParamSet);
    public BigInteger get_D();
    public virtual bool Equals(object obj);
    protected bool Equals(ECPrivateKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.ECPublicKeyParameters : ECKeyParameters {
    private ECPoint q;
    public ECPoint Q { get; }
    public ECPublicKeyParameters(ECPoint q, ECDomainParameters parameters);
    [ObsoleteAttribute("Use version with explicit 'algorithm' parameter")]
public ECPublicKeyParameters(ECPoint q, DerObjectIdentifier publicKeyParamSet);
    public ECPublicKeyParameters(string algorithm, ECPoint q, ECDomainParameters parameters);
    public ECPublicKeyParameters(string algorithm, ECPoint q, DerObjectIdentifier publicKeyParamSet);
    public ECPoint get_Q();
    public virtual bool Equals(object obj);
    protected bool Equals(ECPublicKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.Ed25519KeyGenerationParameters : KeyGenerationParameters {
    public Ed25519KeyGenerationParameters(SecureRandom random);
}
public class Org.BouncyCastle.Crypto.Parameters.Ed25519PrivateKeyParameters : AsymmetricKeyParameter {
    public static int KeySize;
    public static int SignatureSize;
    private Byte[] data;
    private Ed25519PublicKeyParameters cachedPublicKey;
    public Ed25519PrivateKeyParameters(SecureRandom random);
    public Ed25519PrivateKeyParameters(Byte[] buf);
    public Ed25519PrivateKeyParameters(Byte[] buf, int off);
    public Ed25519PrivateKeyParameters(Stream input);
    private static Ed25519PrivateKeyParameters();
    public void Encode(Byte[] buf, int off);
    public Byte[] GetEncoded();
    public Ed25519PublicKeyParameters GeneratePublicKey();
    [ObsoleteAttribute("Use overload that doesn't take a public key")]
public void Sign(Algorithm algorithm, Ed25519PublicKeyParameters publicKey, Byte[] ctx, Byte[] msg, int msgOff, int msgLen, Byte[] sig, int sigOff);
    public void Sign(Algorithm algorithm, Byte[] ctx, Byte[] msg, int msgOff, int msgLen, Byte[] sig, int sigOff);
    private static Byte[] Validate(Byte[] buf);
}
public class Org.BouncyCastle.Crypto.Parameters.Ed25519PublicKeyParameters : AsymmetricKeyParameter {
    public static int KeySize;
    private Byte[] data;
    public Ed25519PublicKeyParameters(Byte[] buf);
    public Ed25519PublicKeyParameters(Byte[] buf, int off);
    public Ed25519PublicKeyParameters(Stream input);
    private static Ed25519PublicKeyParameters();
    public void Encode(Byte[] buf, int off);
    public Byte[] GetEncoded();
    private static Byte[] Validate(Byte[] buf);
}
public class Org.BouncyCastle.Crypto.Parameters.Ed448KeyGenerationParameters : KeyGenerationParameters {
    public Ed448KeyGenerationParameters(SecureRandom random);
}
public class Org.BouncyCastle.Crypto.Parameters.Ed448PrivateKeyParameters : AsymmetricKeyParameter {
    public static int KeySize;
    public static int SignatureSize;
    private Byte[] data;
    private Ed448PublicKeyParameters cachedPublicKey;
    public Ed448PrivateKeyParameters(SecureRandom random);
    public Ed448PrivateKeyParameters(Byte[] buf);
    public Ed448PrivateKeyParameters(Byte[] buf, int off);
    public Ed448PrivateKeyParameters(Stream input);
    private static Ed448PrivateKeyParameters();
    public void Encode(Byte[] buf, int off);
    public Byte[] GetEncoded();
    public Ed448PublicKeyParameters GeneratePublicKey();
    [ObsoleteAttribute("Use overload that doesn't take a public key")]
public void Sign(Algorithm algorithm, Ed448PublicKeyParameters publicKey, Byte[] ctx, Byte[] msg, int msgOff, int msgLen, Byte[] sig, int sigOff);
    public void Sign(Algorithm algorithm, Byte[] ctx, Byte[] msg, int msgOff, int msgLen, Byte[] sig, int sigOff);
    private static Byte[] Validate(Byte[] buf);
}
public class Org.BouncyCastle.Crypto.Parameters.Ed448PublicKeyParameters : AsymmetricKeyParameter {
    public static int KeySize;
    private Byte[] data;
    public Ed448PublicKeyParameters(Byte[] buf);
    public Ed448PublicKeyParameters(Byte[] buf, int off);
    public Ed448PublicKeyParameters(Stream input);
    private static Ed448PublicKeyParameters();
    public void Encode(Byte[] buf, int off);
    public Byte[] GetEncoded();
    private static Byte[] Validate(Byte[] buf);
}
public class Org.BouncyCastle.Crypto.Parameters.ElGamalKeyGenerationParameters : KeyGenerationParameters {
    private ElGamalParameters parameters;
    public ElGamalParameters Parameters { get; }
    public ElGamalKeyGenerationParameters(SecureRandom random, ElGamalParameters parameters);
    public ElGamalParameters get_Parameters();
    internal static int GetStrength(ElGamalParameters parameters);
}
public class Org.BouncyCastle.Crypto.Parameters.ElGamalKeyParameters : AsymmetricKeyParameter {
    private ElGamalParameters parameters;
    public ElGamalParameters Parameters { get; }
    protected ElGamalKeyParameters(bool isPrivate, ElGamalParameters parameters);
    public ElGamalParameters get_Parameters();
    public virtual bool Equals(object obj);
    protected bool Equals(ElGamalKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.ElGamalParameters : object {
    private BigInteger p;
    private BigInteger g;
    private int l;
    public BigInteger P { get; }
    public BigInteger G { get; }
    public int L { get; }
    public ElGamalParameters(BigInteger p, BigInteger g);
    public ElGamalParameters(BigInteger p, BigInteger g, int l);
    public BigInteger get_P();
    public BigInteger get_G();
    public int get_L();
    public virtual bool Equals(object obj);
    protected bool Equals(ElGamalParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.ElGamalPrivateKeyParameters : ElGamalKeyParameters {
    private BigInteger x;
    public BigInteger X { get; }
    public ElGamalPrivateKeyParameters(BigInteger x, ElGamalParameters parameters);
    public BigInteger get_X();
    public virtual bool Equals(object obj);
    protected bool Equals(ElGamalPrivateKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.ElGamalPublicKeyParameters : ElGamalKeyParameters {
    private BigInteger y;
    public BigInteger Y { get; }
    public ElGamalPublicKeyParameters(BigInteger y, ElGamalParameters parameters);
    public BigInteger get_Y();
    public virtual bool Equals(object obj);
    protected bool Equals(ElGamalPublicKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.FpeParameters : object {
    private KeyParameter key;
    private int radix;
    private Byte[] tweak;
    private bool useInverse;
    public KeyParameter Key { get; }
    public int Radix { get; }
    public bool UseInverseFunction { get; }
    public FpeParameters(KeyParameter key, int radix, Byte[] tweak);
    public FpeParameters(KeyParameter key, int radix, Byte[] tweak, bool useInverse);
    public KeyParameter get_Key();
    public int get_Radix();
    public bool get_UseInverseFunction();
    public Byte[] GetTweak();
}
public class Org.BouncyCastle.Crypto.Parameters.Gost3410KeyGenerationParameters : KeyGenerationParameters {
    private Gost3410Parameters parameters;
    private DerObjectIdentifier publicKeyParamSet;
    public Gost3410Parameters Parameters { get; }
    public DerObjectIdentifier PublicKeyParamSet { get; }
    public Gost3410KeyGenerationParameters(SecureRandom random, Gost3410Parameters parameters);
    public Gost3410KeyGenerationParameters(SecureRandom random, DerObjectIdentifier publicKeyParamSet);
    public Gost3410Parameters get_Parameters();
    public DerObjectIdentifier get_PublicKeyParamSet();
    private static Gost3410Parameters LookupParameters(DerObjectIdentifier publicKeyParamSet);
}
public abstract class Org.BouncyCastle.Crypto.Parameters.Gost3410KeyParameters : AsymmetricKeyParameter {
    private Gost3410Parameters parameters;
    private DerObjectIdentifier publicKeyParamSet;
    public Gost3410Parameters Parameters { get; }
    public DerObjectIdentifier PublicKeyParamSet { get; }
    protected Gost3410KeyParameters(bool isPrivate, Gost3410Parameters parameters);
    protected Gost3410KeyParameters(bool isPrivate, DerObjectIdentifier publicKeyParamSet);
    public Gost3410Parameters get_Parameters();
    public DerObjectIdentifier get_PublicKeyParamSet();
    private static Gost3410Parameters LookupParameters(DerObjectIdentifier publicKeyParamSet);
}
public class Org.BouncyCastle.Crypto.Parameters.Gost3410Parameters : object {
    private BigInteger p;
    private BigInteger q;
    private BigInteger a;
    private Gost3410ValidationParameters validation;
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger A { get; }
    public Gost3410ValidationParameters ValidationParameters { get; }
    public Gost3410Parameters(BigInteger p, BigInteger q, BigInteger a);
    public Gost3410Parameters(BigInteger p, BigInteger q, BigInteger a, Gost3410ValidationParameters validation);
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_A();
    public Gost3410ValidationParameters get_ValidationParameters();
    public virtual bool Equals(object obj);
    protected bool Equals(Gost3410Parameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.Gost3410PrivateKeyParameters : Gost3410KeyParameters {
    private BigInteger x;
    public BigInteger X { get; }
    public Gost3410PrivateKeyParameters(BigInteger x, Gost3410Parameters parameters);
    public Gost3410PrivateKeyParameters(BigInteger x, DerObjectIdentifier publicKeyParamSet);
    public BigInteger get_X();
}
public class Org.BouncyCastle.Crypto.Parameters.Gost3410PublicKeyParameters : Gost3410KeyParameters {
    private BigInteger y;
    public BigInteger Y { get; }
    public Gost3410PublicKeyParameters(BigInteger y, Gost3410Parameters parameters);
    public Gost3410PublicKeyParameters(BigInteger y, DerObjectIdentifier publicKeyParamSet);
    public BigInteger get_Y();
}
public class Org.BouncyCastle.Crypto.Parameters.Gost3410ValidationParameters : object {
    private int x0;
    private int c;
    private long x0L;
    private long cL;
    public int C { get; }
    public int X0 { get; }
    public long CL { get; }
    public long X0L { get; }
    public Gost3410ValidationParameters(int x0, int c);
    public Gost3410ValidationParameters(long x0L, long cL);
    public int get_C();
    public int get_X0();
    public long get_CL();
    public long get_X0L();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.HkdfParameters : object {
    private Byte[] ikm;
    private bool skipExpand;
    private Byte[] salt;
    private Byte[] info;
    public bool SkipExtract { get; }
    private HkdfParameters(Byte[] ikm, bool skip, Byte[] salt, Byte[] info);
    public HkdfParameters(Byte[] ikm, Byte[] salt, Byte[] info);
    public static HkdfParameters SkipExtractParameters(Byte[] ikm, Byte[] info);
    public static HkdfParameters DefaultParameters(Byte[] ikm);
    public virtual Byte[] GetIkm();
    public virtual bool get_SkipExtract();
    public virtual Byte[] GetSalt();
    public virtual Byte[] GetInfo();
}
public class Org.BouncyCastle.Crypto.Parameters.IesParameters : object {
    private Byte[] derivation;
    private Byte[] encoding;
    private int macKeySize;
    public int MacKeySize { get; }
    public IesParameters(Byte[] derivation, Byte[] encoding, int macKeySize);
    public Byte[] GetDerivationV();
    public Byte[] GetEncodingV();
    public int get_MacKeySize();
}
public class Org.BouncyCastle.Crypto.Parameters.IesWithCipherParameters : IesParameters {
    private int cipherKeySize;
    public int CipherKeySize { get; }
    public IesWithCipherParameters(Byte[] derivation, Byte[] encoding, int macKeySize, int cipherKeySize);
    public int get_CipherKeySize();
}
public class Org.BouncyCastle.Crypto.Parameters.Iso18033KdfParameters : object {
    private Byte[] seed;
    public Iso18033KdfParameters(Byte[] seed);
    public Byte[] GetSeed();
}
public class Org.BouncyCastle.Crypto.Parameters.KdfCounterParameters : object {
    private Byte[] ki;
    private Byte[] fixedInputDataCounterPrefix;
    private Byte[] fixedInputDataCounterSuffix;
    private int r;
    public Byte[] Ki { get; }
    public Byte[] FixedInputData { get; }
    public Byte[] FixedInputDataCounterPrefix { get; }
    public Byte[] FixedInputDataCounterSuffix { get; }
    public int R { get; }
    public KdfCounterParameters(Byte[] ki, Byte[] fixedInputDataCounterSuffix, int r);
    public KdfCounterParameters(Byte[] ki, Byte[] fixedInputDataCounterPrefix, Byte[] fixedInputDataCounterSuffix, int r);
    public Byte[] get_Ki();
    public Byte[] get_FixedInputData();
    public Byte[] get_FixedInputDataCounterPrefix();
    public Byte[] get_FixedInputDataCounterSuffix();
    public int get_R();
}
public class Org.BouncyCastle.Crypto.Parameters.KdfDoublePipelineIterationParameters : object {
    private static int UNUSED_R;
    private Byte[] ki;
    private bool useCounter;
    private int r;
    private Byte[] fixedInputData;
    public Byte[] Ki { get; }
    public bool UseCounter { get; }
    public int R { get; }
    public Byte[] FixedInputData { get; }
    private KdfDoublePipelineIterationParameters(Byte[] ki, Byte[] fixedInputData, int r, bool useCounter);
    private static KdfDoublePipelineIterationParameters();
    public static KdfDoublePipelineIterationParameters CreateWithCounter(Byte[] ki, Byte[] fixedInputData, int r);
    public static KdfDoublePipelineIterationParameters CreateWithoutCounter(Byte[] ki, Byte[] fixedInputData);
    public Byte[] get_Ki();
    public bool get_UseCounter();
    public int get_R();
    public Byte[] get_FixedInputData();
}
public class Org.BouncyCastle.Crypto.Parameters.KdfFeedbackParameters : object {
    private static int UNUSED_R;
    private Byte[] ki;
    private Byte[] iv;
    private bool useCounter;
    private int r;
    private Byte[] fixedInputData;
    public Byte[] Ki { get; }
    public Byte[] Iv { get; }
    public bool UseCounter { get; }
    public int R { get; }
    public Byte[] FixedInputData { get; }
    private KdfFeedbackParameters(Byte[] ki, Byte[] iv, Byte[] fixedInputData, int r, bool useCounter);
    private static KdfFeedbackParameters();
    public static KdfFeedbackParameters CreateWithCounter(Byte[] ki, Byte[] iv, Byte[] fixedInputData, int r);
    public static KdfFeedbackParameters CreateWithoutCounter(Byte[] ki, Byte[] iv, Byte[] fixedInputData);
    public Byte[] get_Ki();
    public Byte[] get_Iv();
    public bool get_UseCounter();
    public int get_R();
    public Byte[] get_FixedInputData();
}
public class Org.BouncyCastle.Crypto.Parameters.KdfParameters : object {
    private Byte[] iv;
    private Byte[] shared;
    public KdfParameters(Byte[] shared, Byte[] iv);
    public Byte[] GetSharedSecret();
    public Byte[] GetIV();
}
public class Org.BouncyCastle.Crypto.Parameters.KeyParameter : object {
    private Byte[] key;
    public KeyParameter(Byte[] key);
    public KeyParameter(Byte[] key, int keyOff, int keyLen);
    public Byte[] GetKey();
}
public class Org.BouncyCastle.Crypto.Parameters.MgfParameters : object {
    private Byte[] seed;
    public MgfParameters(Byte[] seed);
    public MgfParameters(Byte[] seed, int off, int len);
    public Byte[] GetSeed();
}
public class Org.BouncyCastle.Crypto.Parameters.MqvPrivateParameters : object {
    private ECPrivateKeyParameters staticPrivateKey;
    private ECPrivateKeyParameters ephemeralPrivateKey;
    private ECPublicKeyParameters ephemeralPublicKey;
    public ECPrivateKeyParameters StaticPrivateKey { get; }
    public ECPrivateKeyParameters EphemeralPrivateKey { get; }
    public ECPublicKeyParameters EphemeralPublicKey { get; }
    public MqvPrivateParameters(ECPrivateKeyParameters staticPrivateKey, ECPrivateKeyParameters ephemeralPrivateKey);
    public MqvPrivateParameters(ECPrivateKeyParameters staticPrivateKey, ECPrivateKeyParameters ephemeralPrivateKey, ECPublicKeyParameters ephemeralPublicKey);
    public virtual ECPrivateKeyParameters get_StaticPrivateKey();
    public virtual ECPrivateKeyParameters get_EphemeralPrivateKey();
    public virtual ECPublicKeyParameters get_EphemeralPublicKey();
}
public class Org.BouncyCastle.Crypto.Parameters.MqvPublicParameters : object {
    private ECPublicKeyParameters staticPublicKey;
    private ECPublicKeyParameters ephemeralPublicKey;
    public ECPublicKeyParameters StaticPublicKey { get; }
    public ECPublicKeyParameters EphemeralPublicKey { get; }
    public MqvPublicParameters(ECPublicKeyParameters staticPublicKey, ECPublicKeyParameters ephemeralPublicKey);
    public virtual ECPublicKeyParameters get_StaticPublicKey();
    public virtual ECPublicKeyParameters get_EphemeralPublicKey();
}
public class Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyGenerationParameters : KeyGenerationParameters {
    private int certainty;
    private int countSmallPrimes;
    public int Certainty { get; }
    public int CountSmallPrimes { get; }
    [ObsoleteAttribute("Remove: always false")]
public bool IsDebug { get; }
    public NaccacheSternKeyGenerationParameters(SecureRandom random, int strength, int certainty, int countSmallPrimes);
    [ObsoleteAttribute("Use version without 'debug' parameter")]
public NaccacheSternKeyGenerationParameters(SecureRandom random, int strength, int certainty, int countSmallPrimes, bool debug);
    public int get_Certainty();
    public int get_CountSmallPrimes();
    public bool get_IsDebug();
}
public class Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyParameters : AsymmetricKeyParameter {
    private BigInteger g;
    private BigInteger n;
    private int lowerSigmaBound;
    public BigInteger G { get; }
    public int LowerSigmaBound { get; }
    public BigInteger Modulus { get; }
    public NaccacheSternKeyParameters(bool privateKey, BigInteger g, BigInteger n, int lowerSigmaBound);
    public BigInteger get_G();
    public int get_LowerSigmaBound();
    public BigInteger get_Modulus();
}
public class Org.BouncyCastle.Crypto.Parameters.NaccacheSternPrivateKeyParameters : NaccacheSternKeyParameters {
    private BigInteger phiN;
    private IList smallPrimes;
    public BigInteger PhiN { get; }
    [ObsoleteAttribute("Use 'SmallPrimesList' instead")]
public ArrayList SmallPrimes { get; }
    public IList SmallPrimesList { get; }
    [ObsoleteAttribute]
public NaccacheSternPrivateKeyParameters(BigInteger g, BigInteger n, int lowerSigmaBound, ArrayList smallPrimes, BigInteger phiN);
    public NaccacheSternPrivateKeyParameters(BigInteger g, BigInteger n, int lowerSigmaBound, IList smallPrimes, BigInteger phiN);
    public BigInteger get_PhiN();
    public ArrayList get_SmallPrimes();
    public IList get_SmallPrimesList();
}
public class Org.BouncyCastle.Crypto.Parameters.ParametersWithID : object {
    private ICipherParameters parameters;
    private Byte[] id;
    public ICipherParameters Parameters { get; }
    public ParametersWithID(ICipherParameters parameters, Byte[] id);
    public ParametersWithID(ICipherParameters parameters, Byte[] id, int idOff, int idLen);
    public Byte[] GetID();
    public ICipherParameters get_Parameters();
}
public class Org.BouncyCastle.Crypto.Parameters.ParametersWithIV : object {
    private ICipherParameters parameters;
    private Byte[] iv;
    public ICipherParameters Parameters { get; }
    public ParametersWithIV(ICipherParameters parameters, Byte[] iv);
    public ParametersWithIV(ICipherParameters parameters, Byte[] iv, int ivOff, int ivLen);
    public Byte[] GetIV();
    public ICipherParameters get_Parameters();
}
public class Org.BouncyCastle.Crypto.Parameters.ParametersWithRandom : object {
    private ICipherParameters parameters;
    private SecureRandom random;
    public SecureRandom Random { get; }
    public ICipherParameters Parameters { get; }
    public ParametersWithRandom(ICipherParameters parameters, SecureRandom random);
    public ParametersWithRandom(ICipherParameters parameters);
    [ObsoleteAttribute("Use Random property instead")]
public SecureRandom GetRandom();
    public SecureRandom get_Random();
    public ICipherParameters get_Parameters();
}
public class Org.BouncyCastle.Crypto.Parameters.ParametersWithSalt : object {
    private Byte[] salt;
    private ICipherParameters parameters;
    public ICipherParameters Parameters { get; }
    public ParametersWithSalt(ICipherParameters parameters, Byte[] salt);
    public ParametersWithSalt(ICipherParameters parameters, Byte[] salt, int saltOff, int saltLen);
    public Byte[] GetSalt();
    public ICipherParameters get_Parameters();
}
public class Org.BouncyCastle.Crypto.Parameters.ParametersWithSBox : object {
    private ICipherParameters parameters;
    private Byte[] sBox;
    public ICipherParameters Parameters { get; }
    public ParametersWithSBox(ICipherParameters parameters, Byte[] sBox);
    public Byte[] GetSBox();
    public ICipherParameters get_Parameters();
}
public class Org.BouncyCastle.Crypto.Parameters.RC2Parameters : KeyParameter {
    private int bits;
    public int EffectiveKeyBits { get; }
    public RC2Parameters(Byte[] key);
    public RC2Parameters(Byte[] key, int keyOff, int keyLen);
    public RC2Parameters(Byte[] key, int bits);
    public RC2Parameters(Byte[] key, int keyOff, int keyLen, int bits);
    public int get_EffectiveKeyBits();
}
public class Org.BouncyCastle.Crypto.Parameters.RC5Parameters : KeyParameter {
    private int rounds;
    public int Rounds { get; }
    public RC5Parameters(Byte[] key, int rounds);
    public int get_Rounds();
}
public class Org.BouncyCastle.Crypto.Parameters.RsaBlindingParameters : object {
    private RsaKeyParameters publicKey;
    private BigInteger blindingFactor;
    public RsaKeyParameters PublicKey { get; }
    public BigInteger BlindingFactor { get; }
    public RsaBlindingParameters(RsaKeyParameters publicKey, BigInteger blindingFactor);
    public RsaKeyParameters get_PublicKey();
    public BigInteger get_BlindingFactor();
}
public class Org.BouncyCastle.Crypto.Parameters.RsaKeyGenerationParameters : KeyGenerationParameters {
    private BigInteger publicExponent;
    private int certainty;
    public BigInteger PublicExponent { get; }
    public int Certainty { get; }
    public RsaKeyGenerationParameters(BigInteger publicExponent, SecureRandom random, int strength, int certainty);
    public BigInteger get_PublicExponent();
    public int get_Certainty();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.RsaKeyParameters : AsymmetricKeyParameter {
    private static BigInteger SmallPrimesProduct;
    private BigInteger modulus;
    private BigInteger exponent;
    public BigInteger Modulus { get; }
    public BigInteger Exponent { get; }
    public RsaKeyParameters(bool isPrivate, BigInteger modulus, BigInteger exponent);
    private static RsaKeyParameters();
    private static BigInteger Validate(BigInteger modulus);
    public BigInteger get_Modulus();
    public BigInteger get_Exponent();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.RsaPrivateCrtKeyParameters : RsaKeyParameters {
    private BigInteger e;
    private BigInteger p;
    private BigInteger q;
    private BigInteger dP;
    private BigInteger dQ;
    private BigInteger qInv;
    public BigInteger PublicExponent { get; }
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger DP { get; }
    public BigInteger DQ { get; }
    public BigInteger QInv { get; }
    public RsaPrivateCrtKeyParameters(BigInteger modulus, BigInteger publicExponent, BigInteger privateExponent, BigInteger p, BigInteger q, BigInteger dP, BigInteger dQ, BigInteger qInv);
    public RsaPrivateCrtKeyParameters(RsaPrivateKeyStructure rsaPrivateKey);
    public BigInteger get_PublicExponent();
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_DP();
    public BigInteger get_DQ();
    public BigInteger get_QInv();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static void ValidateValue(BigInteger x, string name, string desc);
}
public class Org.BouncyCastle.Crypto.Parameters.SkeinParameters : object {
    public static int PARAM_TYPE_KEY;
    public static int PARAM_TYPE_CONFIG;
    public static int PARAM_TYPE_PERSONALISATION;
    public static int PARAM_TYPE_PUBLIC_KEY;
    public static int PARAM_TYPE_KEY_IDENTIFIER;
    public static int PARAM_TYPE_NONCE;
    public static int PARAM_TYPE_MESSAGE;
    public static int PARAM_TYPE_OUTPUT;
    private IDictionary parameters;
    private SkeinParameters(IDictionary parameters);
    public IDictionary GetParameters();
    public Byte[] GetKey();
    public Byte[] GetPersonalisation();
    public Byte[] GetPublicKey();
    public Byte[] GetKeyIdentifier();
    public Byte[] GetNonce();
}
public class Org.BouncyCastle.Crypto.Parameters.SM2KeyExchangePrivateParameters : object {
    private bool mInitiator;
    private ECPrivateKeyParameters mStaticPrivateKey;
    private ECPoint mStaticPublicPoint;
    private ECPrivateKeyParameters mEphemeralPrivateKey;
    private ECPoint mEphemeralPublicPoint;
    public bool IsInitiator { get; }
    public ECPrivateKeyParameters StaticPrivateKey { get; }
    public ECPoint StaticPublicPoint { get; }
    public ECPrivateKeyParameters EphemeralPrivateKey { get; }
    public ECPoint EphemeralPublicPoint { get; }
    public SM2KeyExchangePrivateParameters(bool initiator, ECPrivateKeyParameters staticPrivateKey, ECPrivateKeyParameters ephemeralPrivateKey);
    public virtual bool get_IsInitiator();
    public virtual ECPrivateKeyParameters get_StaticPrivateKey();
    public virtual ECPoint get_StaticPublicPoint();
    public virtual ECPrivateKeyParameters get_EphemeralPrivateKey();
    public virtual ECPoint get_EphemeralPublicPoint();
}
public class Org.BouncyCastle.Crypto.Parameters.SM2KeyExchangePublicParameters : object {
    private ECPublicKeyParameters mStaticPublicKey;
    private ECPublicKeyParameters mEphemeralPublicKey;
    public ECPublicKeyParameters StaticPublicKey { get; }
    public ECPublicKeyParameters EphemeralPublicKey { get; }
    public SM2KeyExchangePublicParameters(ECPublicKeyParameters staticPublicKey, ECPublicKeyParameters ephemeralPublicKey);
    public virtual ECPublicKeyParameters get_StaticPublicKey();
    public virtual ECPublicKeyParameters get_EphemeralPublicKey();
}
public class Org.BouncyCastle.Crypto.Parameters.Srp6GroupParameters : object {
    private BigInteger n;
    private BigInteger g;
    public BigInteger G { get; }
    public BigInteger N { get; }
    public Srp6GroupParameters(BigInteger N, BigInteger g);
    public BigInteger get_G();
    public BigInteger get_N();
}
public class Org.BouncyCastle.Crypto.Parameters.TweakableBlockCipherParameters : object {
    private Byte[] tweak;
    private KeyParameter key;
    public KeyParameter Key { get; }
    public Byte[] Tweak { get; }
    public TweakableBlockCipherParameters(KeyParameter key, Byte[] tweak);
    public KeyParameter get_Key();
    public Byte[] get_Tweak();
}
public class Org.BouncyCastle.Crypto.Parameters.X25519KeyGenerationParameters : KeyGenerationParameters {
    public X25519KeyGenerationParameters(SecureRandom random);
}
public class Org.BouncyCastle.Crypto.Parameters.X25519PrivateKeyParameters : AsymmetricKeyParameter {
    public static int KeySize;
    public static int SecretSize;
    private Byte[] data;
    public X25519PrivateKeyParameters(SecureRandom random);
    public X25519PrivateKeyParameters(Byte[] buf);
    public X25519PrivateKeyParameters(Byte[] buf, int off);
    public X25519PrivateKeyParameters(Stream input);
    private static X25519PrivateKeyParameters();
    public void Encode(Byte[] buf, int off);
    public Byte[] GetEncoded();
    public X25519PublicKeyParameters GeneratePublicKey();
    public void GenerateSecret(X25519PublicKeyParameters publicKey, Byte[] buf, int off);
    private static Byte[] Validate(Byte[] buf);
}
public class Org.BouncyCastle.Crypto.Parameters.X25519PublicKeyParameters : AsymmetricKeyParameter {
    public static int KeySize;
    private Byte[] data;
    public X25519PublicKeyParameters(Byte[] buf);
    public X25519PublicKeyParameters(Byte[] buf, int off);
    public X25519PublicKeyParameters(Stream input);
    private static X25519PublicKeyParameters();
    public void Encode(Byte[] buf, int off);
    public Byte[] GetEncoded();
    private static Byte[] Validate(Byte[] buf);
}
public class Org.BouncyCastle.Crypto.Parameters.X448KeyGenerationParameters : KeyGenerationParameters {
    public X448KeyGenerationParameters(SecureRandom random);
}
public class Org.BouncyCastle.Crypto.Parameters.X448PrivateKeyParameters : AsymmetricKeyParameter {
    public static int KeySize;
    public static int SecretSize;
    private Byte[] data;
    public X448PrivateKeyParameters(SecureRandom random);
    public X448PrivateKeyParameters(Byte[] buf);
    public X448PrivateKeyParameters(Byte[] buf, int off);
    public X448PrivateKeyParameters(Stream input);
    private static X448PrivateKeyParameters();
    public void Encode(Byte[] buf, int off);
    public Byte[] GetEncoded();
    public X448PublicKeyParameters GeneratePublicKey();
    public void GenerateSecret(X448PublicKeyParameters publicKey, Byte[] buf, int off);
    private static Byte[] Validate(Byte[] buf);
}
public class Org.BouncyCastle.Crypto.Parameters.X448PublicKeyParameters : AsymmetricKeyParameter {
    public static int KeySize;
    private Byte[] data;
    public X448PublicKeyParameters(Byte[] buf);
    public X448PublicKeyParameters(Byte[] buf, int off);
    public X448PublicKeyParameters(Stream input);
    private static X448PublicKeyParameters();
    public void Encode(Byte[] buf, int off);
    public Byte[] GetEncoded();
    private static Byte[] Validate(Byte[] buf);
}
public abstract class Org.BouncyCastle.Crypto.PbeParametersGenerator : object {
    protected Byte[] mPassword;
    protected Byte[] mSalt;
    protected int mIterationCount;
    public Byte[] Password { get; }
    public Byte[] Salt { get; }
    public int IterationCount { get; }
    public virtual void Init(Byte[] password, Byte[] salt, int iterationCount);
    public virtual Byte[] get_Password();
    [ObsoleteAttribute("Use 'Password' property")]
public Byte[] GetPassword();
    public virtual Byte[] get_Salt();
    [ObsoleteAttribute("Use 'Salt' property")]
public Byte[] GetSalt();
    public virtual int get_IterationCount();
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public abstract virtual ICipherParameters GenerateDerivedParameters(int keySize);
    public abstract virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public abstract virtual ICipherParameters GenerateDerivedParameters(int keySize, int ivSize);
    public abstract virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize, int ivSize);
    public abstract virtual ICipherParameters GenerateDerivedMacParameters(int keySize);
    public static Byte[] Pkcs5PasswordToBytes(Char[] password);
    [ObsoleteAttribute("Use version taking 'char[]' instead")]
public static Byte[] Pkcs5PasswordToBytes(string password);
    public static Byte[] Pkcs5PasswordToUtf8Bytes(Char[] password);
    [ObsoleteAttribute("Use version taking 'char[]' instead")]
public static Byte[] Pkcs5PasswordToUtf8Bytes(string password);
    public static Byte[] Pkcs12PasswordToBytes(Char[] password);
    public static Byte[] Pkcs12PasswordToBytes(Char[] password, bool wrongPkcs12Zero);
}
public class Org.BouncyCastle.Crypto.Prng.BasicEntropySourceProvider : object {
    private SecureRandom mSecureRandom;
    private bool mPredictionResistant;
    public BasicEntropySourceProvider(SecureRandom secureRandom, bool isPredictionResistant);
    public sealed virtual IEntropySource Get(int bitsRequired);
}
public class Org.BouncyCastle.Crypto.Prng.CryptoApiEntropySourceProvider : object {
    private RandomNumberGenerator mRng;
    private bool mPredictionResistant;
    public CryptoApiEntropySourceProvider(RandomNumberGenerator rng, bool isPredictionResistant);
    public sealed virtual IEntropySource Get(int bitsRequired);
}
public class Org.BouncyCastle.Crypto.Prng.CryptoApiRandomGenerator : object {
    private RandomNumberGenerator rndProv;
    public CryptoApiRandomGenerator(RandomNumberGenerator rng);
    public virtual void AddSeedMaterial(Byte[] seed);
    public virtual void AddSeedMaterial(long seed);
    public virtual void NextBytes(Byte[] bytes);
    public virtual void NextBytes(Byte[] bytes, int start, int len);
}
public class Org.BouncyCastle.Crypto.Prng.DigestRandomGenerator : object {
    private static long CYCLE_COUNT;
    private long stateCounter;
    private long seedCounter;
    private IDigest digest;
    private Byte[] state;
    private Byte[] seed;
    public DigestRandomGenerator(IDigest digest);
    public sealed virtual void AddSeedMaterial(Byte[] inSeed);
    public sealed virtual void AddSeedMaterial(long rSeed);
    public sealed virtual void NextBytes(Byte[] bytes);
    public sealed virtual void NextBytes(Byte[] bytes, int start, int len);
    private void CycleSeed();
    private void GenerateState();
    private void DigestAddCounter(long seedVal);
    private void DigestUpdate(Byte[] inSeed);
    private void DigestDoFinal(Byte[] result);
}
public class Org.BouncyCastle.Crypto.Prng.Drbg.CtrSP800Drbg : object {
    private static long TDEA_RESEED_MAX;
    private static long AES_RESEED_MAX;
    private static int TDEA_MAX_BITS_REQUEST;
    private static int AES_MAX_BITS_REQUEST;
    private IEntropySource mEntropySource;
    private IBlockCipher mEngine;
    private int mKeySizeInBits;
    private int mSeedLength;
    private int mSecurityStrength;
    private Byte[] mKey;
    private Byte[] mV;
    private long mReseedCounter;
    private bool mIsTdea;
    private static Byte[] K_BITS;
    public int BlockSize { get; }
    public CtrSP800Drbg(IBlockCipher engine, int keySizeInBits, int securityStrength, IEntropySource entropySource, Byte[] personalizationString, Byte[] nonce);
    private static CtrSP800Drbg();
    private void CTR_DRBG_Instantiate_algorithm(Byte[] entropy, Byte[] nonce, Byte[] personalisationString);
    private void CTR_DRBG_Update(Byte[] seed, Byte[] key, Byte[] v);
    private void CTR_DRBG_Reseed_algorithm(Byte[] additionalInput);
    private void XOR(Byte[] output, Byte[] a, Byte[] b, int bOff);
    private void AddOneTo(Byte[] longer);
    private Byte[] GetEntropy();
    private Byte[] Block_Cipher_df(Byte[] inputString, int bitLength);
    private void BCC(Byte[] bccOut, Byte[] k, Byte[] iV, Byte[] data);
    private void copyIntToByteArray(Byte[] buf, int value, int offSet);
    public sealed virtual int get_BlockSize();
    public sealed virtual int Generate(Byte[] output, Byte[] additionalInput, bool predictionResistant);
    public sealed virtual void Reseed(Byte[] additionalInput);
    private bool IsTdea(IBlockCipher cipher);
    private int GetMaxSecurityStrength(IBlockCipher cipher, int keySizeInBits);
    private Byte[] ExpandKey(Byte[] key);
    private void PadKey(Byte[] keyMaster, int keyOff, Byte[] tmp, int tmpOff);
}
internal class Org.BouncyCastle.Crypto.Prng.Drbg.DrbgUtilities : object {
    private static IDictionary maxSecurityStrengths;
    private static DrbgUtilities();
    internal static int GetMaxSecurityStrength(IDigest d);
    internal static int GetMaxSecurityStrength(IMac m);
    internal static Byte[] HashDF(IDigest digest, Byte[] seedMaterial, int seedLength);
    internal static bool IsTooLarge(Byte[] bytes, int maxBytes);
}
public class Org.BouncyCastle.Crypto.Prng.Drbg.HashSP800Drbg : object {
    private static Byte[] ONE;
    private static long RESEED_MAX;
    private static int MAX_BITS_REQUEST;
    private static IDictionary seedlens;
    private IDigest mDigest;
    private IEntropySource mEntropySource;
    private int mSecurityStrength;
    private int mSeedLength;
    private Byte[] mV;
    private Byte[] mC;
    private long mReseedCounter;
    public int BlockSize { get; }
    private static HashSP800Drbg();
    public HashSP800Drbg(IDigest digest, int securityStrength, IEntropySource entropySource, Byte[] personalizationString, Byte[] nonce);
    public sealed virtual int get_BlockSize();
    public sealed virtual int Generate(Byte[] output, Byte[] additionalInput, bool predictionResistant);
    private Byte[] GetEntropy();
    private void AddTo(Byte[] longer, Byte[] shorter);
    public sealed virtual void Reseed(Byte[] additionalInput);
    private Byte[] Hash(Byte[] input);
    private void DoHash(Byte[] input, Byte[] output);
    private Byte[] hashgen(Byte[] input, int lengthInBits);
}
public class Org.BouncyCastle.Crypto.Prng.Drbg.HMacSP800Drbg : object {
    private static long RESEED_MAX;
    private static int MAX_BITS_REQUEST;
    private Byte[] mK;
    private Byte[] mV;
    private IEntropySource mEntropySource;
    private IMac mHMac;
    private int mSecurityStrength;
    private long mReseedCounter;
    public int BlockSize { get; }
    public HMacSP800Drbg(IMac hMac, int securityStrength, IEntropySource entropySource, Byte[] personalizationString, Byte[] nonce);
    private static HMacSP800Drbg();
    private void hmac_DRBG_Update(Byte[] seedMaterial);
    private void hmac_DRBG_Update_Func(Byte[] seedMaterial, byte vValue);
    public sealed virtual int get_BlockSize();
    public sealed virtual int Generate(Byte[] output, Byte[] additionalInput, bool predictionResistant);
    public sealed virtual void Reseed(Byte[] additionalInput);
    private Byte[] GetEntropy();
}
public interface Org.BouncyCastle.Crypto.Prng.Drbg.ISP80090Drbg {
    public int BlockSize { get; }
    public abstract virtual int get_BlockSize();
    public abstract virtual int Generate(Byte[] output, Byte[] additionalInput, bool predictionResistant);
    public abstract virtual void Reseed(Byte[] additionalInput);
}
public abstract class Org.BouncyCastle.Crypto.Prng.EntropyUtilities : object {
    public static Byte[] GenerateSeed(IEntropySource entropySource, int numBytes);
}
internal interface Org.BouncyCastle.Crypto.Prng.IDrbgProvider {
    public abstract virtual ISP80090Drbg Get(IEntropySource entropySource);
}
public interface Org.BouncyCastle.Crypto.Prng.IRandomGenerator {
    public abstract virtual void AddSeedMaterial(Byte[] seed);
    public abstract virtual void AddSeedMaterial(long seed);
    public abstract virtual void NextBytes(Byte[] bytes);
    public abstract virtual void NextBytes(Byte[] bytes, int start, int len);
}
public class Org.BouncyCastle.Crypto.Prng.ReversedWindowGenerator : object {
    private IRandomGenerator generator;
    private Byte[] window;
    private int windowCount;
    public ReversedWindowGenerator(IRandomGenerator generator, int windowSize);
    public virtual void AddSeedMaterial(Byte[] seed);
    public virtual void AddSeedMaterial(long seed);
    public virtual void NextBytes(Byte[] bytes);
    public virtual void NextBytes(Byte[] bytes, int start, int len);
    private void doNextBytes(Byte[] bytes, int start, int len);
}
public class Org.BouncyCastle.Crypto.Prng.SP800SecureRandom : SecureRandom {
    private IDrbgProvider mDrbgProvider;
    private bool mPredictionResistant;
    private SecureRandom mRandomSource;
    private IEntropySource mEntropySource;
    private ISP80090Drbg mDrbg;
    internal SP800SecureRandom(SecureRandom randomSource, IEntropySource entropySource, IDrbgProvider drbgProvider, bool predictionResistant);
    public virtual void SetSeed(Byte[] seed);
    public virtual void SetSeed(long seed);
    public virtual void NextBytes(Byte[] bytes);
    public virtual void NextBytes(Byte[] buf, int off, int len);
    public virtual Byte[] GenerateSeed(int numBytes);
    public virtual void Reseed(Byte[] additionalInput);
}
public class Org.BouncyCastle.Crypto.Prng.SP800SecureRandomBuilder : object {
    private SecureRandom mRandom;
    private IEntropySourceProvider mEntropySourceProvider;
    private Byte[] mPersonalizationString;
    private int mSecurityStrength;
    private int mEntropyBitsRequired;
    public SP800SecureRandomBuilder(SecureRandom entropySource, bool predictionResistant);
    public SP800SecureRandomBuilder(IEntropySourceProvider entropySourceProvider);
    public SP800SecureRandomBuilder SetPersonalizationString(Byte[] personalizationString);
    public SP800SecureRandomBuilder SetSecurityStrength(int securityStrength);
    public SP800SecureRandomBuilder SetEntropyBitsRequired(int entropyBitsRequired);
    public SP800SecureRandom BuildHash(IDigest digest, Byte[] nonce, bool predictionResistant);
    public SP800SecureRandom BuildCtr(IBlockCipher cipher, int keySizeInBits, Byte[] nonce, bool predictionResistant);
    public SP800SecureRandom BuildHMac(IMac hMac, Byte[] nonce, bool predictionResistant);
}
public class Org.BouncyCastle.Crypto.Prng.ThreadedSeedGenerator : object {
    public Byte[] GenerateSeed(int numBytes, bool fast);
}
public class Org.BouncyCastle.Crypto.Prng.VmpcRandomGenerator : object {
    private byte n;
    private Byte[] P;
    private byte s;
    public virtual void AddSeedMaterial(Byte[] seed);
    public virtual void AddSeedMaterial(long seed);
    public virtual void NextBytes(Byte[] bytes);
    public virtual void NextBytes(Byte[] bytes, int start, int len);
}
internal class Org.BouncyCastle.Crypto.Prng.X931Rng : object {
    private static long BLOCK64_RESEED_MAX;
    private static long BLOCK128_RESEED_MAX;
    private static int BLOCK64_MAX_BITS_REQUEST;
    private static int BLOCK128_MAX_BITS_REQUEST;
    private IBlockCipher mEngine;
    private IEntropySource mEntropySource;
    private Byte[] mDT;
    private Byte[] mI;
    private Byte[] mR;
    private Byte[] mV;
    private long mReseedCounter;
    internal IEntropySource EntropySource { get; }
    internal X931Rng(IBlockCipher engine, Byte[] dateTimeVector, IEntropySource entropySource);
    internal int Generate(Byte[] output, bool predictionResistant);
    internal void Reseed();
    internal IEntropySource get_EntropySource();
    private void Process(Byte[] res, Byte[] a, Byte[] b);
    private void Increment(Byte[] val);
    private static bool IsTooLarge(Byte[] bytes, int maxBytes);
}
public class Org.BouncyCastle.Crypto.Prng.X931SecureRandom : SecureRandom {
    private bool mPredictionResistant;
    private SecureRandom mRandomSource;
    private X931Rng mDrbg;
    internal X931SecureRandom(SecureRandom randomSource, X931Rng drbg, bool predictionResistant);
    public virtual void SetSeed(Byte[] seed);
    public virtual void SetSeed(long seed);
    public virtual void NextBytes(Byte[] bytes);
    public virtual void NextBytes(Byte[] buf, int off, int len);
    public virtual Byte[] GenerateSeed(int numBytes);
}
public class Org.BouncyCastle.Crypto.Prng.X931SecureRandomBuilder : object {
    private SecureRandom mRandom;
    private IEntropySourceProvider mEntropySourceProvider;
    private Byte[] mDateTimeVector;
    public X931SecureRandomBuilder(SecureRandom entropySource, bool predictionResistant);
    public X931SecureRandomBuilder(IEntropySourceProvider entropySourceProvider);
    public X931SecureRandomBuilder SetDateTimeVector(Byte[] dateTimeVector);
    public X931SecureRandom Build(IBlockCipher engine, KeyParameter key, bool predictionResistant);
}
public class Org.BouncyCastle.Crypto.Signers.DsaDigestSigner : object {
    private IDsa dsa;
    private IDigest digest;
    private IDsaEncoding encoding;
    private bool forSigning;
    public string AlgorithmName { get; }
    public DsaDigestSigner(IDsa dsa, IDigest digest);
    public DsaDigestSigner(IDsaExt dsa, IDigest digest, IDsaEncoding encoding);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    public virtual void Reset();
    protected virtual BigInteger GetOrder();
}
public class Org.BouncyCastle.Crypto.Signers.DsaSigner : object {
    protected IDsaKCalculator kCalculator;
    protected DsaKeyParameters key;
    protected SecureRandom random;
    public string AlgorithmName { get; }
    public BigInteger Order { get; }
    public DsaSigner(IDsaKCalculator kCalculator);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual BigInteger get_Order();
    public virtual BigInteger[] GenerateSignature(Byte[] message);
    public virtual bool VerifySignature(Byte[] message, BigInteger r, BigInteger s);
    protected virtual BigInteger CalculateE(BigInteger n, Byte[] message);
    protected virtual SecureRandom InitSecureRandom(bool needed, SecureRandom provided);
}
public class Org.BouncyCastle.Crypto.Signers.ECDsaSigner : object {
    private static BigInteger Eight;
    protected IDsaKCalculator kCalculator;
    protected ECKeyParameters key;
    protected SecureRandom random;
    public string AlgorithmName { get; }
    public BigInteger Order { get; }
    public ECDsaSigner(IDsaKCalculator kCalculator);
    private static ECDsaSigner();
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual BigInteger get_Order();
    public virtual BigInteger[] GenerateSignature(Byte[] message);
    public virtual bool VerifySignature(Byte[] message, BigInteger r, BigInteger s);
    protected virtual BigInteger CalculateE(BigInteger n, Byte[] message);
    protected virtual ECMultiplier CreateBasePointMultiplier();
    protected virtual ECFieldElement GetDenominator(int coordinateSystem, ECPoint p);
    protected virtual SecureRandom InitSecureRandom(bool needed, SecureRandom provided);
}
public class Org.BouncyCastle.Crypto.Signers.ECGost3410Signer : object {
    private ECKeyParameters key;
    private SecureRandom random;
    private bool forSigning;
    public string AlgorithmName { get; }
    public BigInteger Order { get; }
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual BigInteger get_Order();
    public virtual BigInteger[] GenerateSignature(Byte[] message);
    public virtual bool VerifySignature(Byte[] message, BigInteger r, BigInteger s);
    protected virtual ECMultiplier CreateBasePointMultiplier();
}
public class Org.BouncyCastle.Crypto.Signers.ECNRSigner : object {
    private bool forSigning;
    private ECKeyParameters key;
    private SecureRandom random;
    public string AlgorithmName { get; }
    public BigInteger Order { get; }
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual BigInteger get_Order();
    public virtual BigInteger[] GenerateSignature(Byte[] message);
    public virtual bool VerifySignature(Byte[] message, BigInteger r, BigInteger s);
}
public class Org.BouncyCastle.Crypto.Signers.Ed25519ctxSigner : object {
    private Buffer buffer;
    private Byte[] context;
    private bool forSigning;
    private Ed25519PrivateKeyParameters privateKey;
    private Ed25519PublicKeyParameters publicKey;
    public string AlgorithmName { get; }
    public Ed25519ctxSigner(Byte[] context);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual void Update(byte b);
    public virtual void BlockUpdate(Byte[] buf, int off, int len);
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Signers.Ed25519phSigner : object {
    private IDigest prehash;
    private Byte[] context;
    private bool forSigning;
    private Ed25519PrivateKeyParameters privateKey;
    private Ed25519PublicKeyParameters publicKey;
    public string AlgorithmName { get; }
    public Ed25519phSigner(Byte[] context);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual void Update(byte b);
    public virtual void BlockUpdate(Byte[] buf, int off, int len);
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Signers.Ed25519Signer : object {
    private Buffer buffer;
    private bool forSigning;
    private Ed25519PrivateKeyParameters privateKey;
    private Ed25519PublicKeyParameters publicKey;
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual void Update(byte b);
    public virtual void BlockUpdate(Byte[] buf, int off, int len);
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Signers.Ed448phSigner : object {
    private IXof prehash;
    private Byte[] context;
    private bool forSigning;
    private Ed448PrivateKeyParameters privateKey;
    private Ed448PublicKeyParameters publicKey;
    public string AlgorithmName { get; }
    public Ed448phSigner(Byte[] context);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual void Update(byte b);
    public virtual void BlockUpdate(Byte[] buf, int off, int len);
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Signers.Ed448Signer : object {
    private Buffer buffer;
    private Byte[] context;
    private bool forSigning;
    private Ed448PrivateKeyParameters privateKey;
    private Ed448PublicKeyParameters publicKey;
    public string AlgorithmName { get; }
    public Ed448Signer(Byte[] context);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual void Update(byte b);
    public virtual void BlockUpdate(Byte[] buf, int off, int len);
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Signers.GenericSigner : object {
    private IAsymmetricBlockCipher engine;
    private IDigest digest;
    private bool forSigning;
    public string AlgorithmName { get; }
    public GenericSigner(IAsymmetricBlockCipher engine, IDigest digest);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Signers.Gost3410DigestSigner : object {
    private IDigest digest;
    private IDsa dsaSigner;
    private int size;
    private int halfSize;
    private bool forSigning;
    public string AlgorithmName { get; }
    public Gost3410DigestSigner(IDsa signer, IDigest digest);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Signers.Gost3410Signer : object {
    private Gost3410KeyParameters key;
    private SecureRandom random;
    public string AlgorithmName { get; }
    public BigInteger Order { get; }
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual BigInteger get_Order();
    public virtual BigInteger[] GenerateSignature(Byte[] message);
    public virtual bool VerifySignature(Byte[] message, BigInteger r, BigInteger s);
}
public class Org.BouncyCastle.Crypto.Signers.HMacDsaKCalculator : object {
    private HMac hMac;
    private Byte[] K;
    private Byte[] V;
    private BigInteger n;
    public bool IsDeterministic { get; }
    public HMacDsaKCalculator(IDigest digest);
    public virtual bool get_IsDeterministic();
    public virtual void Init(BigInteger n, SecureRandom random);
    public sealed virtual void Init(BigInteger n, BigInteger d, Byte[] message);
    public virtual BigInteger NextK();
    private BigInteger BitsToInt(Byte[] t);
}
public interface Org.BouncyCastle.Crypto.Signers.IDsaEncoding {
    public abstract virtual BigInteger[] Decode(BigInteger n, Byte[] encoding);
    public abstract virtual Byte[] Encode(BigInteger n, BigInteger r, BigInteger s);
}
public interface Org.BouncyCastle.Crypto.Signers.IDsaKCalculator {
    public bool IsDeterministic { get; }
    public abstract virtual bool get_IsDeterministic();
    public abstract virtual void Init(BigInteger n, SecureRandom random);
    public abstract virtual void Init(BigInteger n, BigInteger d, Byte[] message);
    public abstract virtual BigInteger NextK();
}
public class Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner : object {
    [ObsoleteAttribute("Use 'IsoTrailers' instead")]
public static int TrailerImplicit;
    [ObsoleteAttribute("Use 'IsoTrailers' instead")]
public static int TrailerRipeMD160;
    [ObsoleteAttribute("Use 'IsoTrailers' instead")]
public static int TrailerRipeMD128;
    [ObsoleteAttribute("Use 'IsoTrailers' instead")]
public static int TrailerSha1;
    [ObsoleteAttribute("Use 'IsoTrailers' instead")]
public static int TrailerSha256;
    [ObsoleteAttribute("Use 'IsoTrailers' instead")]
public static int TrailerSha512;
    [ObsoleteAttribute("Use 'IsoTrailers' instead")]
public static int TrailerSha384;
    [ObsoleteAttribute("Use 'IsoTrailers' instead")]
public static int TrailerWhirlpool;
    private IDigest digest;
    private IAsymmetricBlockCipher cipher;
    private SecureRandom random;
    private Byte[] standardSalt;
    private int hLen;
    private int trailer;
    private int keyBits;
    private Byte[] block;
    private Byte[] mBuf;
    private int messageLength;
    private int saltLength;
    private bool fullMessage;
    private Byte[] recoveredMessage;
    private Byte[] preSig;
    private Byte[] preBlock;
    private int preMStart;
    private int preTLength;
    public string AlgorithmName { get; }
    public Iso9796d2PssSigner(IAsymmetricBlockCipher cipher, IDigest digest, int saltLength, bool isImplicit);
    public Iso9796d2PssSigner(IAsymmetricBlockCipher cipher, IDigest digest, int saltLength);
    public sealed virtual Byte[] GetRecoveredMessage();
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    private bool IsSameAs(Byte[] a, Byte[] b);
    private void ClearBlock(Byte[] block);
    public virtual void UpdateWithRecoveredMessage(Byte[] signature);
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public virtual void Reset();
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    public virtual bool HasFullMessage();
    private void ItoOSP(int i, Byte[] sp);
    private void LtoOSP(long l, Byte[] sp);
    private Byte[] MaskGeneratorFunction1(Byte[] Z, int zOff, int zLen, int length);
}
public class Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer : object {
    [ObsoleteAttribute("Use 'IsoTrailers' instead")]
public static int TrailerImplicit;
    [ObsoleteAttribute("Use 'IsoTrailers' instead")]
public static int TrailerRipeMD160;
    [ObsoleteAttribute("Use 'IsoTrailers' instead")]
public static int TrailerRipeMD128;
    [ObsoleteAttribute("Use 'IsoTrailers' instead")]
public static int TrailerSha1;
    [ObsoleteAttribute("Use 'IsoTrailers' instead")]
public static int TrailerSha256;
    [ObsoleteAttribute("Use 'IsoTrailers' instead")]
public static int TrailerSha512;
    [ObsoleteAttribute("Use 'IsoTrailers' instead")]
public static int TrailerSha384;
    [ObsoleteAttribute("Use 'IsoTrailers' instead")]
public static int TrailerWhirlpool;
    private IDigest digest;
    private IAsymmetricBlockCipher cipher;
    private int trailer;
    private int keyBits;
    private Byte[] block;
    private Byte[] mBuf;
    private int messageLength;
    private bool fullMessage;
    private Byte[] recoveredMessage;
    private Byte[] preSig;
    private Byte[] preBlock;
    public string AlgorithmName { get; }
    public Iso9796d2Signer(IAsymmetricBlockCipher cipher, IDigest digest, bool isImplicit);
    public Iso9796d2Signer(IAsymmetricBlockCipher cipher, IDigest digest);
    public sealed virtual Byte[] GetRecoveredMessage();
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    private bool IsSameAs(Byte[] a, Byte[] b);
    private void ClearBlock(Byte[] block);
    public virtual void UpdateWithRecoveredMessage(Byte[] signature);
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public virtual void Reset();
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    private bool ReturnFalse(Byte[] block);
    public virtual bool HasFullMessage();
}
public class Org.BouncyCastle.Crypto.Signers.IsoTrailers : object {
    public static int TRAILER_IMPLICIT;
    public static int TRAILER_RIPEMD160;
    public static int TRAILER_RIPEMD128;
    public static int TRAILER_SHA1;
    public static int TRAILER_SHA256;
    public static int TRAILER_SHA512;
    public static int TRAILER_SHA384;
    public static int TRAILER_WHIRLPOOL;
    public static int TRAILER_SHA224;
    public static int TRAILER_SHA512_224;
    public static int TRAILER_SHA512_256;
    private static IDictionary trailerMap;
    private static IsoTrailers();
    private static IDictionary CreateTrailerMap();
    public static int GetTrailer(IDigest digest);
    public static bool NoTrailerAvailable(IDigest digest);
}
public class Org.BouncyCastle.Crypto.Signers.PlainDsaEncoding : object {
    public static PlainDsaEncoding Instance;
    private static PlainDsaEncoding();
    public virtual BigInteger[] Decode(BigInteger n, Byte[] encoding);
    public virtual Byte[] Encode(BigInteger n, BigInteger r, BigInteger s);
    protected virtual BigInteger CheckValue(BigInteger n, BigInteger x);
    protected virtual BigInteger DecodeValue(BigInteger n, Byte[] buf, int off, int len);
    protected virtual void EncodeValue(BigInteger n, BigInteger x, Byte[] buf, int off, int len);
}
public class Org.BouncyCastle.Crypto.Signers.PssSigner : object {
    public static byte TrailerImplicit;
    private IDigest contentDigest1;
    private IDigest contentDigest2;
    private IDigest mgfDigest;
    private IAsymmetricBlockCipher cipher;
    private SecureRandom random;
    private int hLen;
    private int mgfhLen;
    private int sLen;
    private bool sSet;
    private int emBits;
    private Byte[] salt;
    private Byte[] mDash;
    private Byte[] block;
    private byte trailer;
    public string AlgorithmName { get; }
    public PssSigner(IAsymmetricBlockCipher cipher, IDigest digest);
    public PssSigner(IAsymmetricBlockCipher cipher, IDigest digest, int saltLen);
    public PssSigner(IAsymmetricBlockCipher cipher, IDigest digest, Byte[] salt);
    public PssSigner(IAsymmetricBlockCipher cipher, IDigest contentDigest, IDigest mgfDigest, int saltLen);
    public PssSigner(IAsymmetricBlockCipher cipher, IDigest contentDigest, IDigest mgfDigest, Byte[] salt);
    public PssSigner(IAsymmetricBlockCipher cipher, IDigest digest, int saltLen, byte trailer);
    public PssSigner(IAsymmetricBlockCipher cipher, IDigest contentDigest, IDigest mgfDigest, int saltLen, byte trailer);
    private PssSigner(IAsymmetricBlockCipher cipher, IDigest contentDigest1, IDigest contentDigest2, IDigest mgfDigest, int saltLen, Byte[] salt, byte trailer);
    public static PssSigner CreateRawSigner(IAsymmetricBlockCipher cipher, IDigest digest);
    public static PssSigner CreateRawSigner(IAsymmetricBlockCipher cipher, IDigest contentDigest, IDigest mgfDigest, int saltLen, byte trailer);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    private void ClearBlock(Byte[] block);
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public virtual void Reset();
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    private void ItoOSP(int i, Byte[] sp);
    private Byte[] MaskGeneratorFunction(Byte[] Z, int zOff, int zLen, int length);
    private Byte[] MaskGeneratorFunction1(Byte[] Z, int zOff, int zLen, int length);
}
public class Org.BouncyCastle.Crypto.Signers.RandomDsaKCalculator : object {
    private BigInteger q;
    private SecureRandom random;
    public bool IsDeterministic { get; }
    public virtual bool get_IsDeterministic();
    public virtual void Init(BigInteger n, SecureRandom random);
    public virtual void Init(BigInteger n, BigInteger d, Byte[] message);
    public virtual BigInteger NextK();
}
public class Org.BouncyCastle.Crypto.Signers.RsaDigestSigner : object {
    private IAsymmetricBlockCipher rsaEngine;
    private AlgorithmIdentifier algId;
    private IDigest digest;
    private bool forSigning;
    private static IDictionary oidMap;
    public string AlgorithmName { get; }
    private static RsaDigestSigner();
    public RsaDigestSigner(IDigest digest);
    public RsaDigestSigner(IDigest digest, DerObjectIdentifier digestOid);
    public RsaDigestSigner(IDigest digest, AlgorithmIdentifier algId);
    public RsaDigestSigner(IRsa rsa, IDigest digest, DerObjectIdentifier digestOid);
    public RsaDigestSigner(IRsa rsa, IDigest digest, AlgorithmIdentifier algId);
    public RsaDigestSigner(IAsymmetricBlockCipher rsaEngine, IDigest digest, AlgorithmIdentifier algId);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    public virtual void Reset();
    private Byte[] DerEncode(Byte[] hash);
}
public class Org.BouncyCastle.Crypto.Signers.SM2Signer : object {
    private IDsaKCalculator kCalculator;
    private IDigest digest;
    private IDsaEncoding encoding;
    private ECDomainParameters ecParams;
    private ECPoint pubPoint;
    private ECKeyParameters ecKey;
    private Byte[] z;
    public string AlgorithmName { get; }
    public SM2Signer(IDigest digest);
    public SM2Signer(IDsaEncoding encoding);
    public SM2Signer(IDsaEncoding encoding, IDigest digest);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual void Update(byte b);
    public virtual void BlockUpdate(Byte[] buf, int off, int len);
    public virtual bool VerifySignature(Byte[] signature);
    public virtual void Reset();
    public virtual Byte[] GenerateSignature();
    private bool VerifySignature(BigInteger r, BigInteger s);
    private Byte[] GetZ(Byte[] userID);
    private void AddUserID(IDigest digest, Byte[] userID);
    private void AddFieldElement(IDigest digest, ECFieldElement v);
    protected virtual BigInteger CalculateE(BigInteger n, Byte[] message);
    protected virtual ECMultiplier CreateBasePointMultiplier();
}
public class Org.BouncyCastle.Crypto.Signers.StandardDsaEncoding : object {
    public static StandardDsaEncoding Instance;
    private static StandardDsaEncoding();
    public virtual BigInteger[] Decode(BigInteger n, Byte[] encoding);
    public virtual Byte[] Encode(BigInteger n, BigInteger r, BigInteger s);
    protected virtual BigInteger CheckValue(BigInteger n, BigInteger x);
    protected virtual BigInteger DecodeValue(BigInteger n, Asn1Sequence s, int pos);
    protected virtual DerInteger EncodeValue(BigInteger n, BigInteger x);
}
public class Org.BouncyCastle.Crypto.Signers.X931Signer : object {
    [ObsoleteAttribute("Use 'IsoTrailers' instead")]
public static int TRAILER_IMPLICIT;
    [ObsoleteAttribute("Use 'IsoTrailers' instead")]
public static int TRAILER_RIPEMD160;
    [ObsoleteAttribute("Use 'IsoTrailers' instead")]
public static int TRAILER_RIPEMD128;
    [ObsoleteAttribute("Use 'IsoTrailers' instead")]
public static int TRAILER_SHA1;
    [ObsoleteAttribute("Use 'IsoTrailers' instead")]
public static int TRAILER_SHA256;
    [ObsoleteAttribute("Use 'IsoTrailers' instead")]
public static int TRAILER_SHA512;
    [ObsoleteAttribute("Use 'IsoTrailers' instead")]
public static int TRAILER_SHA384;
    [ObsoleteAttribute("Use 'IsoTrailers' instead")]
public static int TRAILER_WHIRLPOOL;
    [ObsoleteAttribute("Use 'IsoTrailers' instead")]
public static int TRAILER_SHA224;
    private IDigest digest;
    private IAsymmetricBlockCipher cipher;
    private RsaKeyParameters kParam;
    private int trailer;
    private int keyBits;
    private Byte[] block;
    public string AlgorithmName { get; }
    public X931Signer(IAsymmetricBlockCipher cipher, IDigest digest, bool isImplicit);
    public X931Signer(IAsymmetricBlockCipher cipher, IDigest digest);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    private void ClearBlock(Byte[] block);
    public virtual void Update(byte b);
    public virtual void BlockUpdate(Byte[] input, int off, int len);
    public virtual void Reset();
    public virtual Byte[] GenerateSignature();
    private void CreateSignatureBlock();
    public virtual bool VerifySignature(Byte[] signature);
}
public class Org.BouncyCastle.Crypto.SimpleBlockResult : object {
    private Byte[] result;
    public int Length { get; }
    public SimpleBlockResult(Byte[] result);
    public int get_Length();
    public sealed virtual Byte[] Collect();
    public sealed virtual int Collect(Byte[] destination, int offset);
}
public class Org.BouncyCastle.Crypto.StreamBlockCipher : object {
    private IBlockCipher cipher;
    private Byte[] oneByte;
    public string AlgorithmName { get; }
    public StreamBlockCipher(IBlockCipher cipher);
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual byte ReturnByte(byte input);
    public sealed virtual void ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public abstract class Org.BouncyCastle.Crypto.Tls.AbstractTlsAgreementCredentials : AbstractTlsCredentials {
    public abstract virtual Byte[] GenerateAgreement(AsymmetricKeyParameter peerPublicKey);
}
public class Org.BouncyCastle.Crypto.Tls.AbstractTlsCipherFactory : object {
    public virtual TlsCipher CreateCipher(TlsContext context, int encryptionAlgorithm, int macAlgorithm);
}
public abstract class Org.BouncyCastle.Crypto.Tls.AbstractTlsClient : AbstractTlsPeer {
    protected TlsCipherFactory mCipherFactory;
    protected TlsClientContext mContext;
    protected IList mSupportedSignatureAlgorithms;
    protected Int32[] mNamedCurves;
    protected Byte[] mClientECPointFormats;
    protected Byte[] mServerECPointFormats;
    protected int mSelectedCipherSuite;
    protected short mSelectedCompressionMethod;
    public ProtocolVersion ClientHelloRecordLayerVersion { get; }
    public ProtocolVersion ClientVersion { get; }
    public bool IsFallback { get; }
    public ProtocolVersion MinimumVersion { get; }
    public AbstractTlsClient(TlsCipherFactory cipherFactory);
    protected virtual bool AllowUnexpectedServerExtension(int extensionType, Byte[] extensionData);
    protected virtual void CheckForUnexpectedServerExtension(IDictionary serverExtensions, int extensionType);
    public virtual void Init(TlsClientContext context);
    public virtual TlsSession GetSessionToResume();
    public virtual ProtocolVersion get_ClientHelloRecordLayerVersion();
    public virtual ProtocolVersion get_ClientVersion();
    public virtual bool get_IsFallback();
    public virtual IDictionary GetClientExtensions();
    public virtual ProtocolVersion get_MinimumVersion();
    public virtual void NotifyServerVersion(ProtocolVersion serverVersion);
    public abstract virtual Int32[] GetCipherSuites();
    public virtual Byte[] GetCompressionMethods();
    public virtual void NotifySessionID(Byte[] sessionID);
    public virtual void NotifySelectedCipherSuite(int selectedCipherSuite);
    public virtual void NotifySelectedCompressionMethod(byte selectedCompressionMethod);
    public virtual void ProcessServerExtensions(IDictionary serverExtensions);
    public virtual void ProcessServerSupplementalData(IList serverSupplementalData);
    public abstract virtual TlsKeyExchange GetKeyExchange();
    public abstract virtual TlsAuthentication GetAuthentication();
    public virtual IList GetClientSupplementalData();
    public virtual TlsCompression GetCompression();
    public virtual TlsCipher GetCipher();
    public virtual void NotifyNewSessionTicket(NewSessionTicket newSessionTicket);
}
internal abstract class Org.BouncyCastle.Crypto.Tls.AbstractTlsContext : object {
    private static long counter;
    private IRandomGenerator mNonceRandom;
    private SecureRandom mSecureRandom;
    private SecurityParameters mSecurityParameters;
    private ProtocolVersion mClientVersion;
    private ProtocolVersion mServerVersion;
    private TlsSession mSession;
    private object mUserObject;
    public IRandomGenerator NonceRandomGenerator { get; }
    public SecureRandom SecureRandom { get; }
    public SecurityParameters SecurityParameters { get; }
    public bool IsServer { get; }
    public ProtocolVersion ClientVersion { get; }
    public ProtocolVersion ServerVersion { get; }
    public TlsSession ResumableSession { get; }
    public object UserObject { get; public set; }
    internal AbstractTlsContext(SecureRandom secureRandom, SecurityParameters securityParameters);
    private static AbstractTlsContext();
    private static long NextCounterValue();
    private static IRandomGenerator CreateNonceRandom(SecureRandom secureRandom, int connectionEnd);
    public virtual IRandomGenerator get_NonceRandomGenerator();
    public virtual SecureRandom get_SecureRandom();
    public virtual SecurityParameters get_SecurityParameters();
    public abstract virtual bool get_IsServer();
    public virtual ProtocolVersion get_ClientVersion();
    internal virtual void SetClientVersion(ProtocolVersion clientVersion);
    public virtual ProtocolVersion get_ServerVersion();
    internal virtual void SetServerVersion(ProtocolVersion serverVersion);
    public virtual TlsSession get_ResumableSession();
    internal virtual void SetResumableSession(TlsSession session);
    public virtual object get_UserObject();
    public virtual void set_UserObject(object value);
    public virtual Byte[] ExportKeyingMaterial(string asciiLabel, Byte[] context_value, int length);
}
public abstract class Org.BouncyCastle.Crypto.Tls.AbstractTlsCredentials : object {
    public Certificate Certificate { get; }
    public abstract virtual Certificate get_Certificate();
}
public abstract class Org.BouncyCastle.Crypto.Tls.AbstractTlsEncryptionCredentials : AbstractTlsCredentials {
    public abstract virtual Byte[] DecryptPreMasterSecret(Byte[] encryptedPreMasterSecret);
}
public abstract class Org.BouncyCastle.Crypto.Tls.AbstractTlsKeyExchange : object {
    protected int mKeyExchange;
    protected IList mSupportedSignatureAlgorithms;
    protected TlsContext mContext;
    public bool RequiresServerKeyExchange { get; }
    protected AbstractTlsKeyExchange(int keyExchange, IList supportedSignatureAlgorithms);
    protected virtual DigitallySigned ParseSignature(Stream input);
    public virtual void Init(TlsContext context);
    public abstract virtual void SkipServerCredentials();
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public virtual bool get_RequiresServerKeyExchange();
    public virtual Byte[] GenerateServerKeyExchange();
    public virtual void SkipServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    public abstract virtual void ValidateCertificateRequest(CertificateRequest certificateRequest);
    public virtual void SkipClientCredentials();
    public abstract virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void ProcessClientCertificate(Certificate clientCertificate);
    public abstract virtual void GenerateClientKeyExchange(Stream output);
    public virtual void ProcessClientKeyExchange(Stream input);
    public abstract virtual Byte[] GeneratePremasterSecret();
}
public abstract class Org.BouncyCastle.Crypto.Tls.AbstractTlsPeer : object {
    private TlsCloseable modreq(System.Runtime.CompilerServices.IsVolatile) mCloseHandle;
    public virtual void Cancel();
    public virtual void NotifyCloseHandle(TlsCloseable closeHandle);
    public virtual int GetHandshakeTimeoutMillis();
    public virtual bool RequiresExtendedMasterSecret();
    public virtual bool ShouldUseGmtUnixTime();
    public virtual void NotifySecureRenegotiation(bool secureRenegotiation);
    public abstract virtual TlsCompression GetCompression();
    public abstract virtual TlsCipher GetCipher();
    public virtual void NotifyAlertRaised(byte alertLevel, byte alertDescription, string message, Exception cause);
    public virtual void NotifyAlertReceived(byte alertLevel, byte alertDescription);
    public virtual void NotifyHandshakeComplete();
}
public abstract class Org.BouncyCastle.Crypto.Tls.AbstractTlsServer : AbstractTlsPeer {
    protected TlsCipherFactory mCipherFactory;
    protected TlsServerContext mContext;
    protected ProtocolVersion mClientVersion;
    protected Int32[] mOfferedCipherSuites;
    protected Byte[] mOfferedCompressionMethods;
    protected IDictionary mClientExtensions;
    protected bool mEncryptThenMacOffered;
    protected short mMaxFragmentLengthOffered;
    protected bool mTruncatedHMacOffered;
    protected IList mSupportedSignatureAlgorithms;
    protected bool mEccCipherSuitesOffered;
    protected Int32[] mNamedCurves;
    protected Byte[] mClientECPointFormats;
    protected Byte[] mServerECPointFormats;
    protected ProtocolVersion mServerVersion;
    protected int mSelectedCipherSuite;
    protected byte mSelectedCompressionMethod;
    protected IDictionary mServerExtensions;
    protected bool AllowEncryptThenMac { get; }
    protected bool AllowTruncatedHMac { get; }
    protected ProtocolVersion MaximumVersion { get; }
    protected ProtocolVersion MinimumVersion { get; }
    public AbstractTlsServer(TlsCipherFactory cipherFactory);
    protected virtual bool get_AllowEncryptThenMac();
    protected virtual bool get_AllowTruncatedHMac();
    protected virtual IDictionary CheckServerExtensions();
    protected abstract virtual Int32[] GetCipherSuites();
    protected Byte[] GetCompressionMethods();
    protected virtual ProtocolVersion get_MaximumVersion();
    protected virtual ProtocolVersion get_MinimumVersion();
    protected virtual bool SupportsClientEccCapabilities(Int32[] namedCurves, Byte[] ecPointFormats);
    public virtual void Init(TlsServerContext context);
    public virtual void NotifyClientVersion(ProtocolVersion clientVersion);
    public virtual void NotifyFallback(bool isFallback);
    public virtual void NotifyOfferedCipherSuites(Int32[] offeredCipherSuites);
    public virtual void NotifyOfferedCompressionMethods(Byte[] offeredCompressionMethods);
    public virtual void ProcessClientExtensions(IDictionary clientExtensions);
    public virtual ProtocolVersion GetServerVersion();
    public virtual int GetSelectedCipherSuite();
    public virtual byte GetSelectedCompressionMethod();
    public virtual IDictionary GetServerExtensions();
    public virtual IList GetServerSupplementalData();
    public abstract virtual TlsCredentials GetCredentials();
    public virtual CertificateStatus GetCertificateStatus();
    public abstract virtual TlsKeyExchange GetKeyExchange();
    public virtual CertificateRequest GetCertificateRequest();
    public virtual void ProcessClientSupplementalData(IList clientSupplementalData);
    public virtual void NotifyClientCertificate(Certificate clientCertificate);
    public virtual TlsCompression GetCompression();
    public virtual TlsCipher GetCipher();
    public virtual NewSessionTicket GetNewSessionTicket();
}
public abstract class Org.BouncyCastle.Crypto.Tls.AbstractTlsSigner : object {
    protected TlsContext mContext;
    public virtual void Init(TlsContext context);
    public virtual Byte[] GenerateRawSignature(AsymmetricKeyParameter privateKey, Byte[] md5AndSha1);
    public abstract virtual Byte[] GenerateRawSignature(SignatureAndHashAlgorithm algorithm, AsymmetricKeyParameter privateKey, Byte[] hash);
    public virtual bool VerifyRawSignature(Byte[] sigBytes, AsymmetricKeyParameter publicKey, Byte[] md5AndSha1);
    public abstract virtual bool VerifyRawSignature(SignatureAndHashAlgorithm algorithm, Byte[] sigBytes, AsymmetricKeyParameter publicKey, Byte[] hash);
    public virtual ISigner CreateSigner(AsymmetricKeyParameter privateKey);
    public abstract virtual ISigner CreateSigner(SignatureAndHashAlgorithm algorithm, AsymmetricKeyParameter privateKey);
    public virtual ISigner CreateVerifyer(AsymmetricKeyParameter publicKey);
    public abstract virtual ISigner CreateVerifyer(SignatureAndHashAlgorithm algorithm, AsymmetricKeyParameter publicKey);
    public abstract virtual bool IsValidPublicKey(AsymmetricKeyParameter publicKey);
}
public abstract class Org.BouncyCastle.Crypto.Tls.AbstractTlsSignerCredentials : AbstractTlsCredentials {
    public SignatureAndHashAlgorithm SignatureAndHashAlgorithm { get; }
    public abstract virtual Byte[] GenerateCertificateSignature(Byte[] hash);
    public virtual SignatureAndHashAlgorithm get_SignatureAndHashAlgorithm();
}
public abstract class Org.BouncyCastle.Crypto.Tls.AlertDescription : object {
    public static byte close_notify;
    public static byte unexpected_message;
    public static byte bad_record_mac;
    public static byte decryption_failed;
    public static byte record_overflow;
    public static byte decompression_failure;
    public static byte handshake_failure;
    public static byte no_certificate;
    public static byte bad_certificate;
    public static byte unsupported_certificate;
    public static byte certificate_revoked;
    public static byte certificate_expired;
    public static byte certificate_unknown;
    public static byte illegal_parameter;
    public static byte unknown_ca;
    public static byte access_denied;
    public static byte decode_error;
    public static byte decrypt_error;
    public static byte export_restriction;
    public static byte protocol_version;
    public static byte insufficient_security;
    public static byte internal_error;
    public static byte user_canceled;
    public static byte no_renegotiation;
    public static byte unsupported_extension;
    public static byte certificate_unobtainable;
    public static byte unrecognized_name;
    public static byte bad_certificate_status_response;
    public static byte bad_certificate_hash_value;
    public static byte unknown_psk_identity;
    public static byte inappropriate_fallback;
    public static string GetName(byte alertDescription);
    public static string GetText(byte alertDescription);
}
public abstract class Org.BouncyCastle.Crypto.Tls.AlertLevel : object {
    public static byte warning;
    public static byte fatal;
    public static string GetName(byte alertDescription);
    public static string GetText(byte alertDescription);
}
public class Org.BouncyCastle.Crypto.Tls.BasicTlsPskIdentity : object {
    protected Byte[] mIdentity;
    protected Byte[] mPsk;
    public BasicTlsPskIdentity(Byte[] identity, Byte[] psk);
    public BasicTlsPskIdentity(string identity, Byte[] psk);
    public virtual void SkipIdentityHint();
    public virtual void NotifyIdentityHint(Byte[] psk_identity_hint);
    public virtual Byte[] GetPskIdentity();
    public virtual Byte[] GetPsk();
}
public abstract class Org.BouncyCastle.Crypto.Tls.BulkCipherAlgorithm : object {
    public static int cls_null;
    public static int rc4;
    public static int rc2;
    public static int des;
    public static int cls_3des;
    public static int des40;
    public static int aes;
    public static int idea;
}
public class Org.BouncyCastle.Crypto.Tls.ByteQueue : object {
    private static int DefaultCapacity;
    private Byte[] databuf;
    private int skipped;
    private int available;
    private bool readOnlyBuf;
    public int Available { get; }
    public ByteQueue(int capacity);
    public ByteQueue(Byte[] buf, int off, int len);
    public static int NextTwoPow(int i);
    public void AddData(Byte[] data, int offset, int len);
    public int get_Available();
    public void CopyTo(Stream output, int length);
    public void Read(Byte[] buf, int offset, int len, int skip);
    public MemoryStream ReadFrom(int length);
    public void RemoveData(int i);
    public void RemoveData(Byte[] buf, int off, int len, int skip);
    public Byte[] RemoveData(int len, int skip);
    public void Shrink();
}
public class Org.BouncyCastle.Crypto.Tls.ByteQueueStream : Stream {
    private ByteQueue buffer;
    public int Available { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public virtual int get_Available();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual int Peek(Byte[] buf);
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buf);
    public virtual int Read(Byte[] buf, int off, int len);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Skip(int n);
    public virtual void Write(Byte[] buf);
    public virtual void Write(Byte[] buf, int off, int len);
    public virtual void WriteByte(byte b);
}
public abstract class Org.BouncyCastle.Crypto.Tls.CertChainType : object {
    public static byte individual_certs;
    public static byte pkipath;
    public static bool IsValid(byte certChainType);
}
public class Org.BouncyCastle.Crypto.Tls.Certificate : object {
    public static Certificate EmptyChain;
    protected X509CertificateStructure[] mCertificateList;
    public int Length { get; }
    public bool IsEmpty { get; }
    public Certificate(X509CertificateStructure[] certificateList);
    private static Certificate();
    public virtual X509CertificateStructure[] GetCertificateList();
    public virtual X509CertificateStructure GetCertificateAt(int index);
    public virtual int get_Length();
    public virtual bool get_IsEmpty();
    public virtual void Encode(Stream output);
    public static Certificate Parse(Stream input);
    protected virtual X509CertificateStructure[] CloneCertificateList();
}
public class Org.BouncyCastle.Crypto.Tls.CertificateRequest : object {
    protected Byte[] mCertificateTypes;
    protected IList mSupportedSignatureAlgorithms;
    protected IList mCertificateAuthorities;
    public Byte[] CertificateTypes { get; }
    public IList SupportedSignatureAlgorithms { get; }
    public IList CertificateAuthorities { get; }
    public CertificateRequest(Byte[] certificateTypes, IList supportedSignatureAlgorithms, IList certificateAuthorities);
    public virtual Byte[] get_CertificateTypes();
    public virtual IList get_SupportedSignatureAlgorithms();
    public virtual IList get_CertificateAuthorities();
    public virtual void Encode(Stream output);
    public static CertificateRequest Parse(TlsContext context, Stream input);
}
public class Org.BouncyCastle.Crypto.Tls.CertificateStatus : object {
    protected byte mStatusType;
    protected object mResponse;
    public byte StatusType { get; }
    public object Response { get; }
    public CertificateStatus(byte statusType, object response);
    public virtual byte get_StatusType();
    public virtual object get_Response();
    public virtual OcspResponse GetOcspResponse();
    public virtual void Encode(Stream output);
    public static CertificateStatus Parse(Stream input);
    protected static bool IsCorrectType(byte statusType, object response);
}
public class Org.BouncyCastle.Crypto.Tls.CertificateStatusRequest : object {
    protected byte mStatusType;
    protected object mRequest;
    public byte StatusType { get; }
    public object Request { get; }
    public CertificateStatusRequest(byte statusType, object request);
    public virtual byte get_StatusType();
    public virtual object get_Request();
    public virtual OcspStatusRequest GetOcspStatusRequest();
    public virtual void Encode(Stream output);
    public static CertificateStatusRequest Parse(Stream input);
    protected static bool IsCorrectType(byte statusType, object request);
}
public abstract class Org.BouncyCastle.Crypto.Tls.CertificateStatusType : object {
    public static byte ocsp;
}
public class Org.BouncyCastle.Crypto.Tls.CertificateType : object {
    public static byte X509;
    public static byte OpenPGP;
    public static byte RawPublicKey;
}
public class Org.BouncyCastle.Crypto.Tls.CertificateUrl : object {
    protected byte mType;
    protected IList mUrlAndHashList;
    public byte Type { get; }
    public IList UrlAndHashList { get; }
    public CertificateUrl(byte type, IList urlAndHashList);
    public virtual byte get_Type();
    public virtual IList get_UrlAndHashList();
    public virtual void Encode(Stream output);
    public static CertificateUrl parse(TlsContext context, Stream input);
}
public class Org.BouncyCastle.Crypto.Tls.Chacha20Poly1305 : object {
    private static Byte[] Zeroes;
    protected TlsContext context;
    protected ChaCha7539Engine encryptCipher;
    protected ChaCha7539Engine decryptCipher;
    protected Byte[] encryptIV;
    protected Byte[] decryptIV;
    public Chacha20Poly1305(TlsContext context);
    private static Chacha20Poly1305();
    public virtual int GetPlaintextLimit(int ciphertextLimit);
    public virtual Byte[] EncodePlaintext(long seqNo, byte type, Byte[] plaintext, int offset, int len);
    public virtual Byte[] DecodeCiphertext(long seqNo, byte type, Byte[] ciphertext, int offset, int len);
    protected virtual KeyParameter InitRecord(IStreamCipher cipher, bool forEncryption, long seqNo, Byte[] iv);
    protected virtual Byte[] CalculateNonce(long seqNo, Byte[] iv);
    protected virtual KeyParameter GenerateRecordMacKey(IStreamCipher cipher);
    protected virtual Byte[] CalculateRecordMac(KeyParameter macKey, Byte[] additionalData, Byte[] buf, int off, int len);
    protected virtual void UpdateRecordMacLength(IMac mac, int len);
    protected virtual void UpdateRecordMacText(IMac mac, Byte[] buf, int off, int len);
    protected virtual Byte[] GetAdditionalData(long seqNo, byte type, int len);
}
public abstract class Org.BouncyCastle.Crypto.Tls.ChangeCipherSpec : object {
    public static byte change_cipher_spec;
}
public abstract class Org.BouncyCastle.Crypto.Tls.CipherSuite : object {
    public static int TLS_NULL_WITH_NULL_NULL;
    public static int TLS_RSA_WITH_NULL_MD5;
    public static int TLS_RSA_WITH_NULL_SHA;
    public static int TLS_RSA_EXPORT_WITH_RC4_40_MD5;
    public static int TLS_RSA_WITH_RC4_128_MD5;
    public static int TLS_RSA_WITH_RC4_128_SHA;
    public static int TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5;
    public static int TLS_RSA_WITH_IDEA_CBC_SHA;
    public static int TLS_RSA_EXPORT_WITH_DES40_CBC_SHA;
    public static int TLS_RSA_WITH_DES_CBC_SHA;
    public static int TLS_RSA_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA;
    public static int TLS_DH_DSS_WITH_DES_CBC_SHA;
    public static int TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA;
    public static int TLS_DH_RSA_WITH_DES_CBC_SHA;
    public static int TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA;
    public static int TLS_DHE_DSS_WITH_DES_CBC_SHA;
    public static int TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA;
    public static int TLS_DHE_RSA_WITH_DES_CBC_SHA;
    public static int TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_DH_anon_EXPORT_WITH_RC4_40_MD5;
    public static int TLS_DH_anon_WITH_RC4_128_MD5;
    public static int TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA;
    public static int TLS_DH_anon_WITH_DES_CBC_SHA;
    public static int TLS_DH_anon_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_RSA_WITH_AES_128_CBC_SHA;
    public static int TLS_DH_DSS_WITH_AES_128_CBC_SHA;
    public static int TLS_DH_RSA_WITH_AES_128_CBC_SHA;
    public static int TLS_DHE_DSS_WITH_AES_128_CBC_SHA;
    public static int TLS_DHE_RSA_WITH_AES_128_CBC_SHA;
    public static int TLS_DH_anon_WITH_AES_128_CBC_SHA;
    public static int TLS_RSA_WITH_AES_256_CBC_SHA;
    public static int TLS_DH_DSS_WITH_AES_256_CBC_SHA;
    public static int TLS_DH_RSA_WITH_AES_256_CBC_SHA;
    public static int TLS_DHE_DSS_WITH_AES_256_CBC_SHA;
    public static int TLS_DHE_RSA_WITH_AES_256_CBC_SHA;
    public static int TLS_DH_anon_WITH_AES_256_CBC_SHA;
    public static int TLS_RSA_WITH_CAMELLIA_128_CBC_SHA;
    public static int TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA;
    public static int TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA;
    public static int TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA;
    public static int TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA;
    public static int TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA;
    public static int TLS_RSA_WITH_CAMELLIA_256_CBC_SHA;
    public static int TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA;
    public static int TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA;
    public static int TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA;
    public static int TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA;
    public static int TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA;
    public static int TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256;
    public static int TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256;
    public static int TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256;
    public static int TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256;
    public static int TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256;
    public static int TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256;
    public static int TLS_RSA_WITH_SEED_CBC_SHA;
    public static int TLS_DH_DSS_WITH_SEED_CBC_SHA;
    public static int TLS_DH_RSA_WITH_SEED_CBC_SHA;
    public static int TLS_DHE_DSS_WITH_SEED_CBC_SHA;
    public static int TLS_DHE_RSA_WITH_SEED_CBC_SHA;
    public static int TLS_DH_anon_WITH_SEED_CBC_SHA;
    public static int TLS_PSK_WITH_RC4_128_SHA;
    public static int TLS_PSK_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_PSK_WITH_AES_128_CBC_SHA;
    public static int TLS_PSK_WITH_AES_256_CBC_SHA;
    public static int TLS_DHE_PSK_WITH_RC4_128_SHA;
    public static int TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_DHE_PSK_WITH_AES_128_CBC_SHA;
    public static int TLS_DHE_PSK_WITH_AES_256_CBC_SHA;
    public static int TLS_RSA_PSK_WITH_RC4_128_SHA;
    public static int TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_RSA_PSK_WITH_AES_128_CBC_SHA;
    public static int TLS_RSA_PSK_WITH_AES_256_CBC_SHA;
    public static int TLS_ECDH_ECDSA_WITH_NULL_SHA;
    public static int TLS_ECDH_ECDSA_WITH_RC4_128_SHA;
    public static int TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA;
    public static int TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA;
    public static int TLS_ECDHE_ECDSA_WITH_NULL_SHA;
    public static int TLS_ECDHE_ECDSA_WITH_RC4_128_SHA;
    public static int TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA;
    public static int TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA;
    public static int TLS_ECDH_RSA_WITH_NULL_SHA;
    public static int TLS_ECDH_RSA_WITH_RC4_128_SHA;
    public static int TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_ECDH_RSA_WITH_AES_128_CBC_SHA;
    public static int TLS_ECDH_RSA_WITH_AES_256_CBC_SHA;
    public static int TLS_ECDHE_RSA_WITH_NULL_SHA;
    public static int TLS_ECDHE_RSA_WITH_RC4_128_SHA;
    public static int TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA;
    public static int TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA;
    public static int TLS_ECDH_anon_WITH_NULL_SHA;
    public static int TLS_ECDH_anon_WITH_RC4_128_SHA;
    public static int TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_ECDH_anon_WITH_AES_128_CBC_SHA;
    public static int TLS_ECDH_anon_WITH_AES_256_CBC_SHA;
    public static int TLS_PSK_WITH_NULL_SHA;
    public static int TLS_DHE_PSK_WITH_NULL_SHA;
    public static int TLS_RSA_PSK_WITH_NULL_SHA;
    public static int TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_SRP_SHA_WITH_AES_128_CBC_SHA;
    public static int TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA;
    public static int TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA;
    public static int TLS_SRP_SHA_WITH_AES_256_CBC_SHA;
    public static int TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA;
    public static int TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA;
    public static int TLS_RSA_WITH_NULL_SHA256;
    public static int TLS_RSA_WITH_AES_128_CBC_SHA256;
    public static int TLS_RSA_WITH_AES_256_CBC_SHA256;
    public static int TLS_DH_DSS_WITH_AES_128_CBC_SHA256;
    public static int TLS_DH_RSA_WITH_AES_128_CBC_SHA256;
    public static int TLS_DHE_DSS_WITH_AES_128_CBC_SHA256;
    public static int TLS_DHE_RSA_WITH_AES_128_CBC_SHA256;
    public static int TLS_DH_DSS_WITH_AES_256_CBC_SHA256;
    public static int TLS_DH_RSA_WITH_AES_256_CBC_SHA256;
    public static int TLS_DHE_DSS_WITH_AES_256_CBC_SHA256;
    public static int TLS_DHE_RSA_WITH_AES_256_CBC_SHA256;
    public static int TLS_DH_anon_WITH_AES_128_CBC_SHA256;
    public static int TLS_DH_anon_WITH_AES_256_CBC_SHA256;
    public static int TLS_RSA_WITH_AES_128_GCM_SHA256;
    public static int TLS_RSA_WITH_AES_256_GCM_SHA384;
    public static int TLS_DHE_RSA_WITH_AES_128_GCM_SHA256;
    public static int TLS_DHE_RSA_WITH_AES_256_GCM_SHA384;
    public static int TLS_DH_RSA_WITH_AES_128_GCM_SHA256;
    public static int TLS_DH_RSA_WITH_AES_256_GCM_SHA384;
    public static int TLS_DHE_DSS_WITH_AES_128_GCM_SHA256;
    public static int TLS_DHE_DSS_WITH_AES_256_GCM_SHA384;
    public static int TLS_DH_DSS_WITH_AES_128_GCM_SHA256;
    public static int TLS_DH_DSS_WITH_AES_256_GCM_SHA384;
    public static int TLS_DH_anon_WITH_AES_128_GCM_SHA256;
    public static int TLS_DH_anon_WITH_AES_256_GCM_SHA384;
    public static int TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256;
    public static int TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384;
    public static int TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256;
    public static int TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384;
    public static int TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256;
    public static int TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384;
    public static int TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256;
    public static int TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384;
    public static int TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256;
    public static int TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384;
    public static int TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256;
    public static int TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384;
    public static int TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256;
    public static int TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384;
    public static int TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256;
    public static int TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384;
    public static int TLS_PSK_WITH_AES_128_GCM_SHA256;
    public static int TLS_PSK_WITH_AES_256_GCM_SHA384;
    public static int TLS_DHE_PSK_WITH_AES_128_GCM_SHA256;
    public static int TLS_DHE_PSK_WITH_AES_256_GCM_SHA384;
    public static int TLS_RSA_PSK_WITH_AES_128_GCM_SHA256;
    public static int TLS_RSA_PSK_WITH_AES_256_GCM_SHA384;
    public static int TLS_PSK_WITH_AES_128_CBC_SHA256;
    public static int TLS_PSK_WITH_AES_256_CBC_SHA384;
    public static int TLS_PSK_WITH_NULL_SHA256;
    public static int TLS_PSK_WITH_NULL_SHA384;
    public static int TLS_DHE_PSK_WITH_AES_128_CBC_SHA256;
    public static int TLS_DHE_PSK_WITH_AES_256_CBC_SHA384;
    public static int TLS_DHE_PSK_WITH_NULL_SHA256;
    public static int TLS_DHE_PSK_WITH_NULL_SHA384;
    public static int TLS_RSA_PSK_WITH_AES_128_CBC_SHA256;
    public static int TLS_RSA_PSK_WITH_AES_256_CBC_SHA384;
    public static int TLS_RSA_PSK_WITH_NULL_SHA256;
    public static int TLS_RSA_PSK_WITH_NULL_SHA384;
    public static int TLS_ECDHE_PSK_WITH_RC4_128_SHA;
    public static int TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA;
    public static int TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA;
    public static int TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256;
    public static int TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384;
    public static int TLS_ECDHE_PSK_WITH_NULL_SHA;
    public static int TLS_ECDHE_PSK_WITH_NULL_SHA256;
    public static int TLS_ECDHE_PSK_WITH_NULL_SHA384;
    public static int TLS_EMPTY_RENEGOTIATION_INFO_SCSV;
    public static int TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384;
    public static int TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384;
    public static int TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384;
    public static int TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384;
    public static int TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384;
    public static int TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384;
    public static int TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384;
    public static int TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384;
    public static int TLS_RSA_WITH_AES_128_CCM;
    public static int TLS_RSA_WITH_AES_256_CCM;
    public static int TLS_DHE_RSA_WITH_AES_128_CCM;
    public static int TLS_DHE_RSA_WITH_AES_256_CCM;
    public static int TLS_RSA_WITH_AES_128_CCM_8;
    public static int TLS_RSA_WITH_AES_256_CCM_8;
    public static int TLS_DHE_RSA_WITH_AES_128_CCM_8;
    public static int TLS_DHE_RSA_WITH_AES_256_CCM_8;
    public static int TLS_PSK_WITH_AES_128_CCM;
    public static int TLS_PSK_WITH_AES_256_CCM;
    public static int TLS_DHE_PSK_WITH_AES_128_CCM;
    public static int TLS_DHE_PSK_WITH_AES_256_CCM;
    public static int TLS_PSK_WITH_AES_128_CCM_8;
    public static int TLS_PSK_WITH_AES_256_CCM_8;
    public static int TLS_PSK_DHE_WITH_AES_128_CCM_8;
    public static int TLS_PSK_DHE_WITH_AES_256_CCM_8;
    public static int TLS_ECDHE_ECDSA_WITH_AES_128_CCM;
    public static int TLS_ECDHE_ECDSA_WITH_AES_256_CCM;
    public static int TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8;
    public static int TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8;
    public static int TLS_FALLBACK_SCSV;
    public static int DRAFT_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256;
    public static int DRAFT_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256;
    public static int DRAFT_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256;
    public static int DRAFT_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256;
    public static int DRAFT_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256;
    public static int DRAFT_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256;
    public static int DRAFT_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256;
    public static bool IsScsv(int cipherSuite);
}
public abstract class Org.BouncyCastle.Crypto.Tls.CipherType : object {
    public static int stream;
    public static int block;
    public static int aead;
}
public abstract class Org.BouncyCastle.Crypto.Tls.ClientAuthenticationType : object {
    public static byte anonymous;
    public static byte certificate_based;
    public static byte psk;
}
public abstract class Org.BouncyCastle.Crypto.Tls.ClientCertificateType : object {
    public static byte rsa_sign;
    public static byte dss_sign;
    public static byte rsa_fixed_dh;
    public static byte dss_fixed_dh;
    public static byte rsa_ephemeral_dh_RESERVED;
    public static byte dss_ephemeral_dh_RESERVED;
    public static byte fortezza_dms_RESERVED;
    public static byte ecdsa_sign;
    public static byte rsa_fixed_ecdh;
    public static byte ecdsa_fixed_ecdh;
}
internal class Org.BouncyCastle.Crypto.Tls.CombinedHash : object {
    protected TlsContext mContext;
    protected IDigest mMd5;
    protected IDigest mSha1;
    public string AlgorithmName { get; }
    internal CombinedHash(CombinedHash t);
    public virtual void Init(TlsContext context);
    public virtual TlsHandshakeHash NotifyPrfDetermined();
    public virtual void TrackHashAlgorithm(byte hashAlgorithm);
    public virtual void SealHashAlgorithms();
    public virtual TlsHandshakeHash StopTracking();
    public virtual IDigest ForkPrfHash();
    public virtual Byte[] GetFinalHash(byte hashAlgorithm);
    public virtual string get_AlgorithmName();
    public virtual int GetByteLength();
    public virtual int GetDigestSize();
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    protected virtual void Ssl3Complete(IDigest d, Byte[] ipad, Byte[] opad, int padLength);
}
public abstract class Org.BouncyCastle.Crypto.Tls.CompressionMethod : object {
    public static byte cls_null;
    public static byte DEFLATE;
}
public abstract class Org.BouncyCastle.Crypto.Tls.ConnectionEnd : object {
    public static int server;
    public static int client;
}
public abstract class Org.BouncyCastle.Crypto.Tls.ContentType : object {
    public static byte change_cipher_spec;
    public static byte alert;
    public static byte handshake;
    public static byte application_data;
    public static byte heartbeat;
}
public interface Org.BouncyCastle.Crypto.Tls.DatagramTransport {
    public abstract virtual int GetReceiveLimit();
    public abstract virtual int GetSendLimit();
    public abstract virtual int Receive(Byte[] buf, int off, int len, int waitMillis);
    public abstract virtual void Send(Byte[] buf, int off, int len);
}
public class Org.BouncyCastle.Crypto.Tls.DefaultTlsAgreementCredentials : AbstractTlsAgreementCredentials {
    protected Certificate mCertificate;
    protected AsymmetricKeyParameter mPrivateKey;
    protected IBasicAgreement mBasicAgreement;
    protected bool mTruncateAgreement;
    public Certificate Certificate { get; }
    public DefaultTlsAgreementCredentials(Certificate certificate, AsymmetricKeyParameter privateKey);
    public virtual Certificate get_Certificate();
    public virtual Byte[] GenerateAgreement(AsymmetricKeyParameter peerPublicKey);
}
public class Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory : AbstractTlsCipherFactory {
    public virtual TlsCipher CreateCipher(TlsContext context, int encryptionAlgorithm, int macAlgorithm);
    protected virtual TlsBlockCipher CreateAESCipher(TlsContext context, int cipherKeySize, int macAlgorithm);
    protected virtual TlsBlockCipher CreateCamelliaCipher(TlsContext context, int cipherKeySize, int macAlgorithm);
    protected virtual TlsCipher CreateChaCha20Poly1305(TlsContext context);
    protected virtual TlsAeadCipher CreateCipher_Aes_Ccm(TlsContext context, int cipherKeySize, int macSize);
    protected virtual TlsAeadCipher CreateCipher_Aes_Gcm(TlsContext context, int cipherKeySize, int macSize);
    protected virtual TlsAeadCipher CreateCipher_Aes_Ocb(TlsContext context, int cipherKeySize, int macSize);
    protected virtual TlsAeadCipher CreateCipher_Camellia_Gcm(TlsContext context, int cipherKeySize, int macSize);
    protected virtual TlsBlockCipher CreateDesEdeCipher(TlsContext context, int macAlgorithm);
    protected virtual TlsNullCipher CreateNullCipher(TlsContext context, int macAlgorithm);
    protected virtual TlsStreamCipher CreateRC4Cipher(TlsContext context, int cipherKeySize, int macAlgorithm);
    protected virtual TlsBlockCipher CreateSeedCipher(TlsContext context, int macAlgorithm);
    protected virtual IBlockCipher CreateAesEngine();
    protected virtual IBlockCipher CreateCamelliaEngine();
    protected virtual IBlockCipher CreateAesBlockCipher();
    protected virtual IAeadBlockCipher CreateAeadBlockCipher_Aes_Ccm();
    protected virtual IAeadBlockCipher CreateAeadBlockCipher_Aes_Gcm();
    protected virtual IAeadBlockCipher CreateAeadBlockCipher_Aes_Ocb();
    protected virtual IAeadBlockCipher CreateAeadBlockCipher_Camellia_Gcm();
    protected virtual IBlockCipher CreateCamelliaBlockCipher();
    protected virtual IBlockCipher CreateDesEdeBlockCipher();
    protected virtual IStreamCipher CreateRC4StreamCipher();
    protected virtual IBlockCipher CreateSeedBlockCipher();
    protected virtual IDigest CreateHMacDigest(int macAlgorithm);
}
public abstract class Org.BouncyCastle.Crypto.Tls.DefaultTlsClient : AbstractTlsClient {
    protected TlsDHVerifier mDHVerifier;
    public DefaultTlsClient(TlsCipherFactory cipherFactory);
    public DefaultTlsClient(TlsCipherFactory cipherFactory, TlsDHVerifier dhVerifier);
    public virtual Int32[] GetCipherSuites();
    public virtual TlsKeyExchange GetKeyExchange();
    protected virtual TlsKeyExchange CreateDHKeyExchange(int keyExchange);
    protected virtual TlsKeyExchange CreateDheKeyExchange(int keyExchange);
    protected virtual TlsKeyExchange CreateECDHKeyExchange(int keyExchange);
    protected virtual TlsKeyExchange CreateECDheKeyExchange(int keyExchange);
    protected virtual TlsKeyExchange CreateRsaKeyExchange();
}
public class Org.BouncyCastle.Crypto.Tls.DefaultTlsDHVerifier : object {
    public static int DefaultMinimumPrimeBits;
    protected static IList DefaultGroups;
    protected IList mGroups;
    protected int mMinimumPrimeBits;
    public int MinimumPrimeBits { get; }
    private static DefaultTlsDHVerifier();
    public DefaultTlsDHVerifier(int minimumPrimeBits);
    public DefaultTlsDHVerifier(IList groups, int minimumPrimeBits);
    private static void AddDefaultGroup(DHParameters dhParameters);
    public virtual bool Accept(DHParameters dhParameters);
    public virtual int get_MinimumPrimeBits();
    protected virtual bool AreGroupsEqual(DHParameters a, DHParameters b);
    protected virtual bool AreParametersEqual(BigInteger a, BigInteger b);
    protected virtual bool CheckGroup(DHParameters dhParameters);
    protected virtual bool CheckMinimumPrimeBits(DHParameters dhParameters);
}
public class Org.BouncyCastle.Crypto.Tls.DefaultTlsEncryptionCredentials : AbstractTlsEncryptionCredentials {
    protected TlsContext mContext;
    protected Certificate mCertificate;
    protected AsymmetricKeyParameter mPrivateKey;
    public Certificate Certificate { get; }
    public DefaultTlsEncryptionCredentials(TlsContext context, Certificate certificate, AsymmetricKeyParameter privateKey);
    public virtual Certificate get_Certificate();
    public virtual Byte[] DecryptPreMasterSecret(Byte[] encryptedPreMasterSecret);
}
public abstract class Org.BouncyCastle.Crypto.Tls.DefaultTlsServer : AbstractTlsServer {
    public DefaultTlsServer(TlsCipherFactory cipherFactory);
    protected virtual TlsSignerCredentials GetDsaSignerCredentials();
    protected virtual TlsSignerCredentials GetECDsaSignerCredentials();
    protected virtual TlsEncryptionCredentials GetRsaEncryptionCredentials();
    protected virtual TlsSignerCredentials GetRsaSignerCredentials();
    protected virtual DHParameters GetDHParameters();
    protected virtual Int32[] GetCipherSuites();
    public virtual TlsCredentials GetCredentials();
    public virtual TlsKeyExchange GetKeyExchange();
    protected virtual TlsKeyExchange CreateDHKeyExchange(int keyExchange);
    protected virtual TlsKeyExchange CreateDheKeyExchange(int keyExchange);
    protected virtual TlsKeyExchange CreateECDHKeyExchange(int keyExchange);
    protected virtual TlsKeyExchange CreateECDheKeyExchange(int keyExchange);
    protected virtual TlsKeyExchange CreateRsaKeyExchange();
}
public class Org.BouncyCastle.Crypto.Tls.DefaultTlsSignerCredentials : AbstractTlsSignerCredentials {
    protected TlsContext mContext;
    protected Certificate mCertificate;
    protected AsymmetricKeyParameter mPrivateKey;
    protected SignatureAndHashAlgorithm mSignatureAndHashAlgorithm;
    protected TlsSigner mSigner;
    public Certificate Certificate { get; }
    public SignatureAndHashAlgorithm SignatureAndHashAlgorithm { get; }
    public DefaultTlsSignerCredentials(TlsContext context, Certificate certificate, AsymmetricKeyParameter privateKey);
    public DefaultTlsSignerCredentials(TlsContext context, Certificate certificate, AsymmetricKeyParameter privateKey, SignatureAndHashAlgorithm signatureAndHashAlgorithm);
    public virtual Certificate get_Certificate();
    public virtual Byte[] GenerateCertificateSignature(Byte[] hash);
    public virtual SignatureAndHashAlgorithm get_SignatureAndHashAlgorithm();
}
public class Org.BouncyCastle.Crypto.Tls.DefaultTlsSrpGroupVerifier : object {
    protected static IList DefaultGroups;
    protected IList mGroups;
    private static DefaultTlsSrpGroupVerifier();
    public DefaultTlsSrpGroupVerifier(IList groups);
    public virtual bool Accept(Srp6GroupParameters group);
    protected virtual bool AreGroupsEqual(Srp6GroupParameters a, Srp6GroupParameters b);
    protected virtual bool AreParametersEqual(BigInteger a, BigInteger b);
}
internal class Org.BouncyCastle.Crypto.Tls.DeferredHash : object {
    protected static int BUFFERING_HASH_LIMIT;
    protected TlsContext mContext;
    private DigestInputBuffer mBuf;
    private IDictionary mHashes;
    private int mPrfHashAlgorithm;
    public string AlgorithmName { get; }
    private DeferredHash(byte prfHashAlgorithm, IDigest prfHash);
    public virtual void Init(TlsContext context);
    public virtual TlsHandshakeHash NotifyPrfDetermined();
    public virtual void TrackHashAlgorithm(byte hashAlgorithm);
    public virtual void SealHashAlgorithms();
    public virtual TlsHandshakeHash StopTracking();
    public virtual IDigest ForkPrfHash();
    public virtual Byte[] GetFinalHash(byte hashAlgorithm);
    public virtual string get_AlgorithmName();
    public virtual int GetByteLength();
    public virtual int GetDigestSize();
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    protected virtual void CheckStopBuffering();
    protected virtual void CheckTrackingHash(byte hashAlgorithm);
}
internal class Org.BouncyCastle.Crypto.Tls.DigestInputBuffer : MemoryStream {
    internal void UpdateDigest(IDigest d);
}
public class Org.BouncyCastle.Crypto.Tls.DigitallySigned : object {
    protected SignatureAndHashAlgorithm mAlgorithm;
    protected Byte[] mSignature;
    public SignatureAndHashAlgorithm Algorithm { get; }
    public Byte[] Signature { get; }
    public DigitallySigned(SignatureAndHashAlgorithm algorithm, Byte[] signature);
    public virtual SignatureAndHashAlgorithm get_Algorithm();
    public virtual Byte[] get_Signature();
    public virtual void Encode(Stream output);
    public static DigitallySigned Parse(TlsContext context, Stream input);
}
public class Org.BouncyCastle.Crypto.Tls.DtlsClientProtocol : DtlsProtocol {
    public DtlsClientProtocol(SecureRandom secureRandom);
    public virtual DtlsTransport Connect(TlsClient client, DatagramTransport transport);
    internal virtual void AbortClientHandshake(ClientHandshakeState state, DtlsRecordLayer recordLayer, byte alertDescription);
    internal virtual DtlsTransport ClientHandshake(ClientHandshakeState state, DtlsRecordLayer recordLayer);
    protected virtual Byte[] GenerateCertificateVerify(ClientHandshakeState state, DigitallySigned certificateVerify);
    protected virtual Byte[] GenerateClientHello(ClientHandshakeState state, TlsClient client);
    protected virtual Byte[] GenerateClientKeyExchange(ClientHandshakeState state);
    protected virtual void InvalidateSession(ClientHandshakeState state);
    protected virtual void ProcessCertificateRequest(ClientHandshakeState state, Byte[] body);
    protected virtual void ProcessCertificateStatus(ClientHandshakeState state, Byte[] body);
    protected virtual Byte[] ProcessHelloVerifyRequest(ClientHandshakeState state, Byte[] body);
    protected virtual void ProcessNewSessionTicket(ClientHandshakeState state, Byte[] body);
    protected virtual Certificate ProcessServerCertificate(ClientHandshakeState state, Byte[] body);
    protected virtual void ProcessServerHello(ClientHandshakeState state, Byte[] body);
    protected virtual void ProcessServerKeyExchange(ClientHandshakeState state, Byte[] body);
    protected virtual void ProcessServerSupplementalData(ClientHandshakeState state, Byte[] body);
    protected virtual void ReportServerVersion(ClientHandshakeState state, ProtocolVersion server_version);
    protected static Byte[] PatchClientHelloWithCookie(Byte[] clientHelloBody, Byte[] cookie);
}
internal class Org.BouncyCastle.Crypto.Tls.DtlsEpoch : object {
    private DtlsReplayWindow mReplayWindow;
    private int mEpoch;
    private TlsCipher mCipher;
    private long mSequenceNumber;
    internal TlsCipher Cipher { get; }
    internal int Epoch { get; }
    internal DtlsReplayWindow ReplayWindow { get; }
    internal long SequenceNumber { get; }
    internal DtlsEpoch(int epoch, TlsCipher cipher);
    internal long AllocateSequenceNumber();
    internal TlsCipher get_Cipher();
    internal int get_Epoch();
    internal DtlsReplayWindow get_ReplayWindow();
    internal long get_SequenceNumber();
}
internal interface Org.BouncyCastle.Crypto.Tls.DtlsHandshakeRetransmit {
    public abstract virtual void ReceivedHandshakeRecord(int epoch, Byte[] buf, int off, int len);
}
public abstract class Org.BouncyCastle.Crypto.Tls.DtlsProtocol : object {
    protected SecureRandom mSecureRandom;
    protected DtlsProtocol(SecureRandom secureRandom);
    protected virtual void ProcessFinished(Byte[] body, Byte[] expected_verify_data);
    internal static void ApplyMaxFragmentLengthExtension(DtlsRecordLayer recordLayer, short maxFragmentLength);
    protected static short EvaluateMaxFragmentLengthExtension(bool resumedSession, IDictionary clientExtensions, IDictionary serverExtensions, byte alertDescription);
    protected static Byte[] GenerateCertificate(Certificate certificate);
    protected static Byte[] GenerateSupplementalData(IList supplementalData);
    protected static void ValidateSelectedCipherSuite(int selectedCipherSuite, byte alertDescription);
}
internal class Org.BouncyCastle.Crypto.Tls.DtlsReassembler : object {
    private byte mMsgType;
    private Byte[] mBody;
    private IList mMissing;
    internal byte MsgType { get; }
    internal DtlsReassembler(byte msg_type, int length);
    internal byte get_MsgType();
    internal Byte[] GetBodyIfComplete();
    internal void ContributeFragment(byte msg_type, int length, Byte[] buf, int off, int fragment_offset, int fragment_length);
    internal void Reset();
}
internal class Org.BouncyCastle.Crypto.Tls.DtlsRecordLayer : object {
    private static int RECORD_HEADER_LENGTH;
    private static int MAX_FRAGMENT_LENGTH;
    private static long TCP_MSL;
    private static long RETRANSMIT_TIMEOUT;
    private DatagramTransport mTransport;
    private TlsContext mContext;
    private TlsPeer mPeer;
    private ByteQueue mRecordQueue;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) mClosed;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) mFailed;
    private ProtocolVersion modreq(System.Runtime.CompilerServices.IsVolatile) mReadVersion;
    private ProtocolVersion modreq(System.Runtime.CompilerServices.IsVolatile) mWriteVersion;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) mInHandshake;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) mPlaintextLimit;
    private DtlsEpoch mCurrentEpoch;
    private DtlsEpoch mPendingEpoch;
    private DtlsEpoch mReadEpoch;
    private DtlsEpoch mWriteEpoch;
    private DtlsHandshakeRetransmit mRetransmit;
    private DtlsEpoch mRetransmitEpoch;
    private Timeout mRetransmitTimeout;
    internal bool IsClosed { get; }
    internal int ReadEpoch { get; }
    internal ProtocolVersion ReadVersion { get; internal set; }
    internal DtlsRecordLayer(DatagramTransport transport, TlsContext context, TlsPeer peer, byte contentType);
    private static void SendDatagram(DatagramTransport sender, Byte[] buf, int off, int len);
    internal bool get_IsClosed();
    internal virtual void SetPlaintextLimit(int plaintextLimit);
    internal virtual int get_ReadEpoch();
    internal virtual ProtocolVersion get_ReadVersion();
    internal virtual void set_ReadVersion(ProtocolVersion value);
    internal virtual void SetWriteVersion(ProtocolVersion writeVersion);
    internal virtual void InitPendingEpoch(TlsCipher pendingCipher);
    internal virtual void HandshakeSuccessful(DtlsHandshakeRetransmit retransmit);
    internal virtual void ResetWriteEpoch();
    public virtual int GetReceiveLimit();
    public virtual int GetSendLimit();
    public virtual int Receive(Byte[] buf, int off, int len, int waitMillis);
    public virtual void Send(Byte[] buf, int off, int len);
    public virtual void Close();
    internal virtual void Failed();
    internal virtual void Fail(byte alertDescription);
    internal virtual void Warn(byte alertDescription, string message);
    private void CloseTransport();
    private void RaiseAlert(byte alertLevel, byte alertDescription, string message, Exception cause);
    private int ReceiveDatagram(Byte[] buf, int off, int len, int waitMillis);
    private int ProcessRecord(int received, Byte[] record, Byte[] buf, int off);
    private int ReceiveRecord(Byte[] buf, int off, int len, int waitMillis);
    private void SendRecord(byte contentType, Byte[] buf, int off, int len);
    private static long GetMacSequenceNumber(int epoch, long sequence_number);
}
internal class Org.BouncyCastle.Crypto.Tls.DtlsReliableHandshake : object {
    private static int MaxReceiveAhead;
    private static int MessageHeaderLength;
    private static int InitialResendMillis;
    private static int MaxResendMillis;
    private DtlsRecordLayer mRecordLayer;
    private Timeout mHandshakeTimeout;
    private TlsHandshakeHash mHandshakeHash;
    private IDictionary mCurrentInboundFlight;
    private IDictionary mPreviousInboundFlight;
    private IList mOutboundFlight;
    private int mResendMillis;
    private Timeout mResendTimeout;
    private int mMessageSeq;
    private int mNextReceiveSeq;
    internal TlsHandshakeHash HandshakeHash { get; }
    internal DtlsReliableHandshake(TlsContext context, DtlsRecordLayer transport, int timeoutMillis);
    internal void NotifyHelloComplete();
    internal TlsHandshakeHash get_HandshakeHash();
    internal TlsHandshakeHash PrepareToFinish();
    internal void SendMessage(byte msg_type, Byte[] body);
    internal Byte[] ReceiveMessageBody(byte msg_type);
    internal Message ReceiveMessage();
    internal void Finish();
    internal void ResetHandshakeMessagesDigest();
    private int BackOff(int timeoutMillis);
    private void CheckInboundFlight();
    private Message GetPendingMessage();
    private void PrepareInboundFlight(IDictionary nextFlight);
    private void ProcessRecord(int windowSize, int epoch, Byte[] buf, int off, int len);
    private void ResendOutboundFlight();
    private Message UpdateHandshakeMessagesDigest(Message message);
    private void WriteMessage(Message message);
    private void WriteHandshakeFragment(Message message, int fragment_offset, int fragment_length);
    private static bool CheckAll(IDictionary inboundFlight);
    private static void ResetAll(IDictionary inboundFlight);
}
internal class Org.BouncyCastle.Crypto.Tls.DtlsReplayWindow : object {
    private static long VALID_SEQ_MASK;
    private static long WINDOW_SIZE;
    private long mLatestConfirmedSeq;
    private long mBitmap;
    internal bool ShouldDiscard(long seq);
    internal void ReportAuthenticated(long seq);
    internal void Reset();
}
public class Org.BouncyCastle.Crypto.Tls.DtlsServerProtocol : DtlsProtocol {
    protected bool mVerifyRequests;
    public bool VerifyRequests { get; public set; }
    public DtlsServerProtocol(SecureRandom secureRandom);
    public virtual bool get_VerifyRequests();
    public virtual void set_VerifyRequests(bool value);
    public virtual DtlsTransport Accept(TlsServer server, DatagramTransport transport);
    internal virtual void AbortServerHandshake(ServerHandshakeState state, DtlsRecordLayer recordLayer, byte alertDescription);
    internal virtual DtlsTransport ServerHandshake(ServerHandshakeState state, DtlsRecordLayer recordLayer);
    protected virtual void InvalidateSession(ServerHandshakeState state);
    protected virtual Byte[] GenerateCertificateRequest(ServerHandshakeState state, CertificateRequest certificateRequest);
    protected virtual Byte[] GenerateCertificateStatus(ServerHandshakeState state, CertificateStatus certificateStatus);
    protected virtual Byte[] GenerateNewSessionTicket(ServerHandshakeState state, NewSessionTicket newSessionTicket);
    protected virtual Byte[] GenerateServerHello(ServerHandshakeState state);
    protected virtual void NotifyClientCertificate(ServerHandshakeState state, Certificate clientCertificate);
    protected virtual void ProcessClientCertificate(ServerHandshakeState state, Byte[] body);
    protected virtual void ProcessCertificateVerify(ServerHandshakeState state, Byte[] body, TlsHandshakeHash prepareFinishHash);
    protected virtual void ProcessClientHello(ServerHandshakeState state, Byte[] body);
    protected virtual void ProcessClientKeyExchange(ServerHandshakeState state, Byte[] body);
    protected virtual void ProcessClientSupplementalData(ServerHandshakeState state, Byte[] body);
    protected virtual bool ExpectCertificateVerifyMessage(ServerHandshakeState state);
}
public class Org.BouncyCastle.Crypto.Tls.DtlsTransport : object {
    private DtlsRecordLayer mRecordLayer;
    internal DtlsTransport(DtlsRecordLayer recordLayer);
    public virtual int GetReceiveLimit();
    public virtual int GetSendLimit();
    public virtual int Receive(Byte[] buf, int off, int len, int waitMillis);
    public virtual void Send(Byte[] buf, int off, int len);
    public virtual void Close();
}
public abstract class Org.BouncyCastle.Crypto.Tls.ECBasisType : object {
    public static byte ec_basis_trinomial;
    public static byte ec_basis_pentanomial;
    public static bool IsValid(byte ecBasisType);
}
public abstract class Org.BouncyCastle.Crypto.Tls.ECCurveType : object {
    public static byte explicit_prime;
    public static byte explicit_char2;
    public static byte named_curve;
}
public abstract class Org.BouncyCastle.Crypto.Tls.ECPointFormat : object {
    public static byte uncompressed;
    public static byte ansiX962_compressed_prime;
    public static byte ansiX962_compressed_char2;
}
public abstract class Org.BouncyCastle.Crypto.Tls.EncryptionAlgorithm : object {
    public static int NULL;
    public static int RC4_40;
    public static int RC4_128;
    public static int RC2_CBC_40;
    public static int IDEA_CBC;
    public static int DES40_CBC;
    public static int DES_CBC;
    public static int cls_3DES_EDE_CBC;
    public static int AES_128_CBC;
    public static int AES_256_CBC;
    public static int AES_128_GCM;
    public static int AES_256_GCM;
    public static int CAMELLIA_128_CBC;
    public static int CAMELLIA_256_CBC;
    public static int SEED_CBC;
    public static int AES_128_CCM;
    public static int AES_128_CCM_8;
    public static int AES_256_CCM;
    public static int AES_256_CCM_8;
    public static int CAMELLIA_128_GCM;
    public static int CAMELLIA_256_GCM;
    public static int CHACHA20_POLY1305;
    public static int AES_128_OCB_TAGLEN96;
    public static int AES_256_OCB_TAGLEN96;
}
public abstract class Org.BouncyCastle.Crypto.Tls.ExporterLabel : object {
    public static string client_finished;
    public static string server_finished;
    public static string master_secret;
    public static string key_expansion;
    public static string client_EAP_encryption;
    public static string ttls_keying_material;
    public static string ttls_challenge;
    public static string dtls_srtp;
    public static string extended_master_secret;
    private static ExporterLabel();
}
public abstract class Org.BouncyCastle.Crypto.Tls.ExtensionType : object {
    public static int server_name;
    public static int max_fragment_length;
    public static int client_certificate_url;
    public static int trusted_ca_keys;
    public static int truncated_hmac;
    public static int status_request;
    public static int user_mapping;
    public static int client_authz;
    public static int server_authz;
    public static int cert_type;
    public static int supported_groups;
    [ObsoleteAttribute("Use 'supported_groups' instead")]
public static int elliptic_curves;
    public static int ec_point_formats;
    public static int srp;
    public static int signature_algorithms;
    public static int use_srtp;
    public static int heartbeat;
    public static int application_layer_protocol_negotiation;
    public static int status_request_v2;
    public static int signed_certificate_timestamp;
    public static int client_certificate_type;
    public static int server_certificate_type;
    public static int padding;
    public static int encrypt_then_mac;
    public static int extended_master_secret;
    public static int DRAFT_token_binding;
    public static int cached_info;
    public static int session_ticket;
    public static int negotiated_ff_dhe_groups;
    public static int renegotiation_info;
    private static ExtensionType();
}
public abstract class Org.BouncyCastle.Crypto.Tls.FiniteFieldDheGroup : object {
    public static byte ffdhe2432;
    public static byte ffdhe3072;
    public static byte ffdhe4096;
    public static byte ffdhe6144;
    public static byte ffdhe8192;
    public static bool IsValid(byte group);
}
public abstract class Org.BouncyCastle.Crypto.Tls.HandshakeType : object {
    public static byte hello_request;
    public static byte client_hello;
    public static byte server_hello;
    public static byte certificate;
    public static byte server_key_exchange;
    public static byte certificate_request;
    public static byte server_hello_done;
    public static byte certificate_verify;
    public static byte client_key_exchange;
    public static byte finished;
    public static byte certificate_url;
    public static byte certificate_status;
    public static byte hello_verify_request;
    public static byte supplemental_data;
    public static byte session_ticket;
}
public abstract class Org.BouncyCastle.Crypto.Tls.HashAlgorithm : object {
    public static byte none;
    public static byte md5;
    public static byte sha1;
    public static byte sha224;
    public static byte sha256;
    public static byte sha384;
    public static byte sha512;
    public static string GetName(byte hashAlgorithm);
    public static string GetText(byte hashAlgorithm);
    public static bool IsPrivate(byte hashAlgorithm);
    public static bool IsRecognized(byte hashAlgorithm);
}
public class Org.BouncyCastle.Crypto.Tls.HeartbeatExtension : object {
    protected byte mMode;
    public byte Mode { get; }
    public HeartbeatExtension(byte mode);
    public virtual byte get_Mode();
    public virtual void Encode(Stream output);
    public static HeartbeatExtension Parse(Stream input);
}
public class Org.BouncyCastle.Crypto.Tls.HeartbeatMessage : object {
    protected byte mType;
    protected Byte[] mPayload;
    protected int mPaddingLength;
    public HeartbeatMessage(byte type, Byte[] payload, int paddingLength);
    public virtual void Encode(TlsContext context, Stream output);
    public static HeartbeatMessage Parse(Stream input);
}
public abstract class Org.BouncyCastle.Crypto.Tls.HeartbeatMessageType : object {
    public static byte heartbeat_request;
    public static byte heartbeat_response;
    public static bool IsValid(byte heartbeatMessageType);
}
public abstract class Org.BouncyCastle.Crypto.Tls.HeartbeatMode : object {
    public static byte peer_allowed_to_send;
    public static byte peer_not_allowed_to_send;
    public static bool IsValid(byte heartbeatMode);
}
public abstract class Org.BouncyCastle.Crypto.Tls.KeyExchangeAlgorithm : object {
    public static int NULL;
    public static int RSA;
    public static int RSA_EXPORT;
    public static int DHE_DSS;
    public static int DHE_DSS_EXPORT;
    public static int DHE_RSA;
    public static int DHE_RSA_EXPORT;
    public static int DH_DSS;
    public static int DH_DSS_EXPORT;
    public static int DH_RSA;
    public static int DH_RSA_EXPORT;
    public static int DH_anon;
    public static int DH_anon_EXPORT;
    public static int PSK;
    public static int DHE_PSK;
    public static int RSA_PSK;
    public static int ECDH_ECDSA;
    public static int ECDHE_ECDSA;
    public static int ECDH_RSA;
    public static int ECDHE_RSA;
    public static int ECDH_anon;
    public static int SRP;
    public static int SRP_DSS;
    public static int SRP_RSA;
    public static int ECDHE_PSK;
}
public abstract class Org.BouncyCastle.Crypto.Tls.MacAlgorithm : object {
    public static int cls_null;
    public static int md5;
    public static int sha;
    public static int hmac_md5;
    public static int hmac_sha1;
    public static int hmac_sha256;
    public static int hmac_sha384;
    public static int hmac_sha512;
}
public abstract class Org.BouncyCastle.Crypto.Tls.MaxFragmentLength : object {
    public static byte pow2_9;
    public static byte pow2_10;
    public static byte pow2_11;
    public static byte pow2_12;
    public static bool IsValid(byte maxFragmentLength);
}
public abstract class Org.BouncyCastle.Crypto.Tls.NamedCurve : object {
    public static int sect163k1;
    public static int sect163r1;
    public static int sect163r2;
    public static int sect193r1;
    public static int sect193r2;
    public static int sect233k1;
    public static int sect233r1;
    public static int sect239k1;
    public static int sect283k1;
    public static int sect283r1;
    public static int sect409k1;
    public static int sect409r1;
    public static int sect571k1;
    public static int sect571r1;
    public static int secp160k1;
    public static int secp160r1;
    public static int secp160r2;
    public static int secp192k1;
    public static int secp192r1;
    public static int secp224k1;
    public static int secp224r1;
    public static int secp256k1;
    public static int secp256r1;
    public static int secp384r1;
    public static int secp521r1;
    public static int brainpoolP256r1;
    public static int brainpoolP384r1;
    public static int brainpoolP512r1;
    public static int arbitrary_explicit_prime_curves;
    public static int arbitrary_explicit_char2_curves;
    public static bool IsValid(int namedCurve);
    public static bool RefersToASpecificNamedCurve(int namedCurve);
}
public abstract class Org.BouncyCastle.Crypto.Tls.NameType : object {
    public static byte host_name;
    public static bool IsValid(byte nameType);
}
public class Org.BouncyCastle.Crypto.Tls.NewSessionTicket : object {
    protected long mTicketLifetimeHint;
    protected Byte[] mTicket;
    public long TicketLifetimeHint { get; }
    public Byte[] Ticket { get; }
    public NewSessionTicket(long ticketLifetimeHint, Byte[] ticket);
    public virtual long get_TicketLifetimeHint();
    public virtual Byte[] get_Ticket();
    public virtual void Encode(Stream output);
    public static NewSessionTicket Parse(Stream input);
}
public class Org.BouncyCastle.Crypto.Tls.OcspStatusRequest : object {
    protected IList mResponderIDList;
    protected X509Extensions mRequestExtensions;
    public IList ResponderIDList { get; }
    public X509Extensions RequestExtensions { get; }
    public OcspStatusRequest(IList responderIDList, X509Extensions requestExtensions);
    public virtual IList get_ResponderIDList();
    public virtual X509Extensions get_RequestExtensions();
    public virtual void Encode(Stream output);
    public static OcspStatusRequest Parse(Stream input);
}
public abstract class Org.BouncyCastle.Crypto.Tls.PrfAlgorithm : object {
    public static int tls_prf_legacy;
    public static int tls_prf_sha256;
    public static int tls_prf_sha384;
}
public class Org.BouncyCastle.Crypto.Tls.ProtocolVersion : object {
    public static ProtocolVersion SSLv3;
    public static ProtocolVersion TLSv10;
    public static ProtocolVersion TLSv11;
    public static ProtocolVersion TLSv12;
    public static ProtocolVersion DTLSv10;
    public static ProtocolVersion DTLSv12;
    private int version;
    private string name;
    public int FullVersion { get; }
    public int MajorVersion { get; }
    public int MinorVersion { get; }
    public bool IsDtls { get; }
    public bool IsSsl { get; }
    public bool IsTls { get; }
    private ProtocolVersion(int v, string name);
    private static ProtocolVersion();
    public int get_FullVersion();
    public int get_MajorVersion();
    public int get_MinorVersion();
    public bool get_IsDtls();
    public bool get_IsSsl();
    public bool get_IsTls();
    public ProtocolVersion GetEquivalentTLSVersion();
    public bool IsEqualOrEarlierVersionOf(ProtocolVersion version);
    public bool IsLaterVersionOf(ProtocolVersion version);
    public virtual bool Equals(object other);
    public bool Equals(ProtocolVersion other);
    public virtual int GetHashCode();
    public static ProtocolVersion Get(int major, int minor);
    public virtual string ToString();
    private static ProtocolVersion GetUnknownVersion(int major, int minor, string prefix);
}
public class Org.BouncyCastle.Crypto.Tls.PskTlsClient : AbstractTlsClient {
    protected TlsDHVerifier mDHVerifier;
    protected TlsPskIdentity mPskIdentity;
    public PskTlsClient(TlsPskIdentity pskIdentity);
    public PskTlsClient(TlsCipherFactory cipherFactory, TlsPskIdentity pskIdentity);
    public PskTlsClient(TlsCipherFactory cipherFactory, TlsDHVerifier dhVerifier, TlsPskIdentity pskIdentity);
    public virtual Int32[] GetCipherSuites();
    public virtual TlsKeyExchange GetKeyExchange();
    public virtual TlsAuthentication GetAuthentication();
    protected virtual TlsKeyExchange CreatePskKeyExchange(int keyExchange);
}
public class Org.BouncyCastle.Crypto.Tls.PskTlsServer : AbstractTlsServer {
    protected TlsPskIdentityManager mPskIdentityManager;
    public PskTlsServer(TlsPskIdentityManager pskIdentityManager);
    public PskTlsServer(TlsCipherFactory cipherFactory, TlsPskIdentityManager pskIdentityManager);
    protected virtual TlsEncryptionCredentials GetRsaEncryptionCredentials();
    protected virtual DHParameters GetDHParameters();
    protected virtual Int32[] GetCipherSuites();
    public virtual TlsCredentials GetCredentials();
    public virtual TlsKeyExchange GetKeyExchange();
    protected virtual TlsKeyExchange CreatePskKeyExchange(int keyExchange);
}
internal class Org.BouncyCastle.Crypto.Tls.RecordStream : object {
    private static int DEFAULT_PLAINTEXT_LIMIT;
    internal static int TLS_HEADER_SIZE;
    internal static int TLS_HEADER_TYPE_OFFSET;
    internal static int TLS_HEADER_VERSION_OFFSET;
    internal static int TLS_HEADER_LENGTH_OFFSET;
    private TlsProtocol mHandler;
    private Stream mInput;
    private Stream mOutput;
    private TlsCompression mPendingCompression;
    private TlsCompression mReadCompression;
    private TlsCompression mWriteCompression;
    private TlsCipher mPendingCipher;
    private TlsCipher mReadCipher;
    private TlsCipher mWriteCipher;
    private SequenceNumber mReadSeqNo;
    private SequenceNumber mWriteSeqNo;
    private MemoryStream mBuffer;
    private TlsHandshakeHash mHandshakeHash;
    private BaseOutputStream mHandshakeHashUpdater;
    private ProtocolVersion mReadVersion;
    private ProtocolVersion mWriteVersion;
    private bool mRestrictReadVersion;
    private int mPlaintextLimit;
    private int mCompressedLimit;
    private int mCiphertextLimit;
    internal ProtocolVersion ReadVersion { get; internal set; }
    internal TlsHandshakeHash HandshakeHash { get; }
    internal Stream HandshakeHashUpdater { get; }
    internal RecordStream(TlsProtocol handler, Stream input, Stream output);
    internal virtual void Init(TlsContext context);
    internal virtual int GetPlaintextLimit();
    internal virtual void SetPlaintextLimit(int plaintextLimit);
    internal virtual ProtocolVersion get_ReadVersion();
    internal virtual void set_ReadVersion(ProtocolVersion value);
    internal virtual void SetWriteVersion(ProtocolVersion writeVersion);
    internal virtual void SetRestrictReadVersion(bool enabled);
    internal virtual void SetPendingConnectionState(TlsCompression tlsCompression, TlsCipher tlsCipher);
    internal virtual void SentWriteCipherSpec();
    internal virtual void ReceivedReadCipherSpec();
    internal virtual void FinaliseHandshake();
    internal virtual void CheckRecordHeader(Byte[] recordHeader);
    internal virtual bool ReadRecord();
    internal virtual Byte[] DecodeAndVerify(byte type, Stream input, int len);
    internal virtual void WriteRecord(byte type, Byte[] plaintext, int plaintextOffset, int plaintextLength);
    internal virtual void NotifyHelloComplete();
    internal virtual TlsHandshakeHash get_HandshakeHash();
    internal virtual Stream get_HandshakeHashUpdater();
    internal virtual TlsHandshakeHash PrepareToFinish();
    internal virtual void SafeClose();
    internal virtual void Flush();
    private Byte[] GetBufferContents();
    private static void CheckType(byte type, byte alertDescription);
    private static void CheckLength(int length, int limit, byte alertDescription);
}
public class Org.BouncyCastle.Crypto.Tls.SecurityParameters : object {
    internal int entity;
    internal int cipherSuite;
    internal byte compressionAlgorithm;
    internal int prfAlgorithm;
    internal int verifyDataLength;
    internal Byte[] masterSecret;
    internal Byte[] clientRandom;
    internal Byte[] serverRandom;
    internal Byte[] sessionHash;
    internal Byte[] pskIdentity;
    internal Byte[] srpIdentity;
    internal short maxFragmentLength;
    internal bool truncatedHMac;
    internal bool encryptThenMac;
    internal bool extendedMasterSecret;
    public int Entity { get; }
    public int CipherSuite { get; }
    public byte CompressionAlgorithm { get; }
    public int PrfAlgorithm { get; }
    public int VerifyDataLength { get; }
    public Byte[] MasterSecret { get; }
    public Byte[] ClientRandom { get; }
    public Byte[] ServerRandom { get; }
    public Byte[] SessionHash { get; }
    public Byte[] PskIdentity { get; }
    public Byte[] SrpIdentity { get; }
    public bool IsExtendedMasterSecret { get; }
    internal virtual void Clear();
    public virtual int get_Entity();
    public virtual int get_CipherSuite();
    public virtual byte get_CompressionAlgorithm();
    public virtual int get_PrfAlgorithm();
    public virtual int get_VerifyDataLength();
    public virtual Byte[] get_MasterSecret();
    public virtual Byte[] get_ClientRandom();
    public virtual Byte[] get_ServerRandom();
    public virtual Byte[] get_SessionHash();
    public virtual Byte[] get_PskIdentity();
    public virtual Byte[] get_SrpIdentity();
    public virtual bool get_IsExtendedMasterSecret();
}
public class Org.BouncyCastle.Crypto.Tls.ServerName : object {
    protected byte mNameType;
    protected object mName;
    public byte NameType { get; }
    public object Name { get; }
    public ServerName(byte nameType, object name);
    public virtual byte get_NameType();
    public virtual object get_Name();
    public virtual string GetHostName();
    public virtual void Encode(Stream output);
    public static ServerName Parse(Stream input);
    protected static bool IsCorrectType(byte nameType, object name);
}
public class Org.BouncyCastle.Crypto.Tls.ServerNameList : object {
    protected IList mServerNameList;
    public IList ServerNames { get; }
    public ServerNameList(IList serverNameList);
    public virtual IList get_ServerNames();
    public virtual void Encode(Stream output);
    public static ServerNameList Parse(Stream input);
    private static Byte[] CheckNameType(Byte[] nameTypesSeen, byte nameType);
}
public abstract class Org.BouncyCastle.Crypto.Tls.ServerOnlyTlsAuthentication : object {
    public abstract virtual void NotifyServerCertificate(Certificate serverCertificate);
    public sealed virtual TlsCredentials GetClientCredentials(CertificateRequest certificateRequest);
}
public class Org.BouncyCastle.Crypto.Tls.ServerSrpParams : object {
    protected BigInteger m_N;
    protected BigInteger m_g;
    protected BigInteger m_B;
    protected Byte[] m_s;
    public BigInteger B { get; }
    public BigInteger G { get; }
    public BigInteger N { get; }
    public Byte[] S { get; }
    public ServerSrpParams(BigInteger N, BigInteger g, Byte[] s, BigInteger B);
    public virtual BigInteger get_B();
    public virtual BigInteger get_G();
    public virtual BigInteger get_N();
    public virtual Byte[] get_S();
    public virtual void Encode(Stream output);
    public static ServerSrpParams Parse(Stream input);
}
public class Org.BouncyCastle.Crypto.Tls.SessionParameters : object {
    private int mCipherSuite;
    private byte mCompressionAlgorithm;
    private Byte[] mMasterSecret;
    private Certificate mPeerCertificate;
    private Byte[] mPskIdentity;
    private Byte[] mSrpIdentity;
    private Byte[] mEncodedServerExtensions;
    private bool mExtendedMasterSecret;
    public int CipherSuite { get; }
    public byte CompressionAlgorithm { get; }
    public bool IsExtendedMasterSecret { get; }
    public Byte[] MasterSecret { get; }
    public Certificate PeerCertificate { get; }
    public Byte[] PskIdentity { get; }
    public Byte[] SrpIdentity { get; }
    private SessionParameters(int cipherSuite, byte compressionAlgorithm, Byte[] masterSecret, Certificate peerCertificate, Byte[] pskIdentity, Byte[] srpIdentity, Byte[] encodedServerExtensions, bool extendedMasterSecret);
    public void Clear();
    public SessionParameters Copy();
    public int get_CipherSuite();
    public byte get_CompressionAlgorithm();
    public bool get_IsExtendedMasterSecret();
    public Byte[] get_MasterSecret();
    public Certificate get_PeerCertificate();
    public Byte[] get_PskIdentity();
    public Byte[] get_SrpIdentity();
    public IDictionary ReadServerExtensions();
}
public abstract class Org.BouncyCastle.Crypto.Tls.SignatureAlgorithm : object {
    public static byte anonymous;
    public static byte rsa;
    public static byte dsa;
    public static byte ecdsa;
}
public class Org.BouncyCastle.Crypto.Tls.SignatureAndHashAlgorithm : object {
    protected byte mHash;
    protected byte mSignature;
    public byte Hash { get; }
    public byte Signature { get; }
    public SignatureAndHashAlgorithm(byte hash, byte signature);
    public virtual byte get_Hash();
    public virtual byte get_Signature();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual void Encode(Stream output);
    public static SignatureAndHashAlgorithm Parse(Stream input);
}
internal class Org.BouncyCastle.Crypto.Tls.SignerInputBuffer : MemoryStream {
    internal void UpdateSigner(ISigner s);
}
public class Org.BouncyCastle.Crypto.Tls.SimulatedTlsSrpIdentityManager : object {
    private static Byte[] PREFIX_PASSWORD;
    private static Byte[] PREFIX_SALT;
    protected Srp6GroupParameters mGroup;
    protected Srp6VerifierGenerator mVerifierGenerator;
    protected IMac mMac;
    public SimulatedTlsSrpIdentityManager(Srp6GroupParameters group, Srp6VerifierGenerator verifierGenerator, IMac mac);
    private static SimulatedTlsSrpIdentityManager();
    public static SimulatedTlsSrpIdentityManager GetRfc5054Default(Srp6GroupParameters group, Byte[] seedKey);
    public virtual TlsSrpLoginParameters GetLoginParameters(Byte[] identity);
}
public class Org.BouncyCastle.Crypto.Tls.SrpTlsClient : AbstractTlsClient {
    protected TlsSrpGroupVerifier mGroupVerifier;
    protected Byte[] mIdentity;
    protected Byte[] mPassword;
    protected bool RequireSrpServerExtension { get; }
    public SrpTlsClient(Byte[] identity, Byte[] password);
    public SrpTlsClient(TlsCipherFactory cipherFactory, Byte[] identity, Byte[] password);
    public SrpTlsClient(TlsCipherFactory cipherFactory, TlsSrpGroupVerifier groupVerifier, Byte[] identity, Byte[] password);
    protected virtual bool get_RequireSrpServerExtension();
    public virtual Int32[] GetCipherSuites();
    public virtual IDictionary GetClientExtensions();
    public virtual void ProcessServerExtensions(IDictionary serverExtensions);
    public virtual TlsKeyExchange GetKeyExchange();
    public virtual TlsAuthentication GetAuthentication();
    protected virtual TlsKeyExchange CreateSrpKeyExchange(int keyExchange);
}
public class Org.BouncyCastle.Crypto.Tls.SrpTlsServer : AbstractTlsServer {
    protected TlsSrpIdentityManager mSrpIdentityManager;
    protected Byte[] mSrpIdentity;
    protected TlsSrpLoginParameters mLoginParameters;
    public SrpTlsServer(TlsSrpIdentityManager srpIdentityManager);
    public SrpTlsServer(TlsCipherFactory cipherFactory, TlsSrpIdentityManager srpIdentityManager);
    protected virtual TlsSignerCredentials GetDsaSignerCredentials();
    protected virtual TlsSignerCredentials GetRsaSignerCredentials();
    protected virtual Int32[] GetCipherSuites();
    public virtual void ProcessClientExtensions(IDictionary clientExtensions);
    public virtual int GetSelectedCipherSuite();
    public virtual TlsCredentials GetCredentials();
    public virtual TlsKeyExchange GetKeyExchange();
    protected virtual TlsKeyExchange CreateSrpKeyExchange(int keyExchange);
}
public abstract class Org.BouncyCastle.Crypto.Tls.SrtpProtectionProfile : object {
    public static int SRTP_AES128_CM_HMAC_SHA1_80;
    public static int SRTP_AES128_CM_HMAC_SHA1_32;
    public static int SRTP_NULL_HMAC_SHA1_80;
    public static int SRTP_NULL_HMAC_SHA1_32;
    public static int SRTP_AEAD_AES_128_GCM;
    public static int SRTP_AEAD_AES_256_GCM;
}
public class Org.BouncyCastle.Crypto.Tls.Ssl3Mac : object {
    private static byte IPAD_BYTE;
    private static byte OPAD_BYTE;
    internal static Byte[] IPAD;
    internal static Byte[] OPAD;
    private IDigest digest;
    private int padLength;
    private Byte[] secret;
    public string AlgorithmName { get; }
    public Ssl3Mac(IDigest digest);
    private static Ssl3Mac();
    public virtual string get_AlgorithmName();
    public virtual void Init(ICipherParameters parameters);
    public virtual int GetMacSize();
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private static Byte[] GenPad(byte b, int count);
}
public class Org.BouncyCastle.Crypto.Tls.SupplementalDataEntry : object {
    protected int mDataType;
    protected Byte[] mData;
    public int DataType { get; }
    public Byte[] Data { get; }
    public SupplementalDataEntry(int dataType, Byte[] data);
    public virtual int get_DataType();
    public virtual Byte[] get_Data();
}
public abstract class Org.BouncyCastle.Crypto.Tls.SupplementalDataType : object {
    public static int user_mapping_data;
}
internal class Org.BouncyCastle.Crypto.Tls.Timeout : object {
    private long durationMillis;
    private long startMillis;
    internal Timeout(long durationMillis);
    internal Timeout(long durationMillis, long currentTimeMillis);
    internal long RemainingMillis(long currentTimeMillis);
    internal static int ConstrainWaitMillis(int waitMillis, Timeout timeout, long currentTimeMillis);
    internal static Timeout ForWaitMillis(int waitMillis);
    internal static Timeout ForWaitMillis(int waitMillis, long currentTimeMillis);
    internal static int GetWaitMillis(Timeout timeout, long currentTimeMillis);
    internal static bool HasExpired(Timeout timeout, long currentTimeMillis);
}
public class Org.BouncyCastle.Crypto.Tls.TlsAeadCipher : object {
    public static int NONCE_RFC5288;
    internal static int NONCE_DRAFT_CHACHA20_POLY1305;
    protected TlsContext context;
    protected int macSize;
    protected int record_iv_length;
    protected IAeadBlockCipher encryptCipher;
    protected IAeadBlockCipher decryptCipher;
    protected Byte[] encryptImplicitNonce;
    protected Byte[] decryptImplicitNonce;
    protected int nonceMode;
    public TlsAeadCipher(TlsContext context, IAeadBlockCipher clientWriteCipher, IAeadBlockCipher serverWriteCipher, int cipherKeySize, int macSize);
    internal TlsAeadCipher(TlsContext context, IAeadBlockCipher clientWriteCipher, IAeadBlockCipher serverWriteCipher, int cipherKeySize, int macSize, int nonceMode);
    public virtual int GetPlaintextLimit(int ciphertextLimit);
    public virtual Byte[] EncodePlaintext(long seqNo, byte type, Byte[] plaintext, int offset, int len);
    public virtual Byte[] DecodeCiphertext(long seqNo, byte type, Byte[] ciphertext, int offset, int len);
    protected virtual Byte[] GetAdditionalData(long seqNo, byte type, int len);
}
public interface Org.BouncyCastle.Crypto.Tls.TlsAgreementCredentials {
    public abstract virtual Byte[] GenerateAgreement(AsymmetricKeyParameter peerPublicKey);
}
public interface Org.BouncyCastle.Crypto.Tls.TlsAuthentication {
    public abstract virtual void NotifyServerCertificate(Certificate serverCertificate);
    public abstract virtual TlsCredentials GetClientCredentials(CertificateRequest certificateRequest);
}
public class Org.BouncyCastle.Crypto.Tls.TlsBlockCipher : object {
    protected TlsContext context;
    protected Byte[] randomData;
    protected bool useExplicitIV;
    protected bool encryptThenMac;
    protected IBlockCipher encryptCipher;
    protected IBlockCipher decryptCipher;
    protected TlsMac mWriteMac;
    protected TlsMac mReadMac;
    public TlsMac WriteMac { get; }
    public TlsMac ReadMac { get; }
    public TlsBlockCipher(TlsContext context, IBlockCipher clientWriteCipher, IBlockCipher serverWriteCipher, IDigest clientWriteDigest, IDigest serverWriteDigest, int cipherKeySize);
    public virtual TlsMac get_WriteMac();
    public virtual TlsMac get_ReadMac();
    public virtual int GetPlaintextLimit(int ciphertextLimit);
    public virtual Byte[] EncodePlaintext(long seqNo, byte type, Byte[] plaintext, int offset, int len);
    public virtual Byte[] DecodeCiphertext(long seqNo, byte type, Byte[] ciphertext, int offset, int len);
    protected virtual int CheckPaddingConstantTime(Byte[] buf, int off, int len, int blockSize, int macSize);
    protected virtual int ChooseExtraPadBlocks(SecureRandom r, int max);
    protected virtual int LowestBitSet(int x);
}
public interface Org.BouncyCastle.Crypto.Tls.TlsCipher {
    public abstract virtual int GetPlaintextLimit(int ciphertextLimit);
    public abstract virtual Byte[] EncodePlaintext(long seqNo, byte type, Byte[] plaintext, int offset, int len);
    public abstract virtual Byte[] DecodeCiphertext(long seqNo, byte type, Byte[] ciphertext, int offset, int len);
}
public interface Org.BouncyCastle.Crypto.Tls.TlsCipherFactory {
    public abstract virtual TlsCipher CreateCipher(TlsContext context, int encryptionAlgorithm, int macAlgorithm);
}
public interface Org.BouncyCastle.Crypto.Tls.TlsClient {
    public ProtocolVersion ClientHelloRecordLayerVersion { get; }
    public ProtocolVersion ClientVersion { get; }
    public bool IsFallback { get; }
    public abstract virtual void Init(TlsClientContext context);
    public abstract virtual TlsSession GetSessionToResume();
    public abstract virtual ProtocolVersion get_ClientHelloRecordLayerVersion();
    public abstract virtual ProtocolVersion get_ClientVersion();
    public abstract virtual bool get_IsFallback();
    public abstract virtual Int32[] GetCipherSuites();
    public abstract virtual Byte[] GetCompressionMethods();
    public abstract virtual IDictionary GetClientExtensions();
    public abstract virtual void NotifyServerVersion(ProtocolVersion selectedVersion);
    public abstract virtual void NotifySessionID(Byte[] sessionID);
    public abstract virtual void NotifySelectedCipherSuite(int selectedCipherSuite);
    public abstract virtual void NotifySelectedCompressionMethod(byte selectedCompressionMethod);
    public abstract virtual void ProcessServerExtensions(IDictionary serverExtensions);
    public abstract virtual void ProcessServerSupplementalData(IList serverSupplementalData);
    public abstract virtual TlsKeyExchange GetKeyExchange();
    public abstract virtual TlsAuthentication GetAuthentication();
    public abstract virtual IList GetClientSupplementalData();
    public abstract virtual void NotifyNewSessionTicket(NewSessionTicket newSessionTicket);
}
public interface Org.BouncyCastle.Crypto.Tls.TlsClientContext {
}
internal class Org.BouncyCastle.Crypto.Tls.TlsClientContextImpl : AbstractTlsContext {
    public bool IsServer { get; }
    internal TlsClientContextImpl(SecureRandom secureRandom, SecurityParameters securityParameters);
    public virtual bool get_IsServer();
}
public class Org.BouncyCastle.Crypto.Tls.TlsClientProtocol : TlsProtocol {
    protected TlsClient mTlsClient;
    internal TlsClientContextImpl mTlsClientContext;
    protected Byte[] mSelectedSessionID;
    protected TlsKeyExchange mKeyExchange;
    protected TlsAuthentication mAuthentication;
    protected CertificateStatus mCertificateStatus;
    protected CertificateRequest mCertificateRequest;
    protected TlsContext Context { get; }
    internal AbstractTlsContext ContextAdmin { get; }
    protected TlsPeer Peer { get; }
    public TlsClientProtocol(Stream stream, SecureRandom secureRandom);
    public TlsClientProtocol(Stream input, Stream output, SecureRandom secureRandom);
    public TlsClientProtocol(SecureRandom secureRandom);
    public virtual void Connect(TlsClient tlsClient);
    protected virtual void CleanupHandshake();
    protected virtual TlsContext get_Context();
    internal virtual AbstractTlsContext get_ContextAdmin();
    protected virtual TlsPeer get_Peer();
    protected virtual void HandleHandshakeMessage(byte type, MemoryStream buf);
    protected virtual void HandleSupplementalData(IList serverSupplementalData);
    protected virtual void ReceiveNewSessionTicketMessage(MemoryStream buf);
    protected virtual void ReceiveServerHelloMessage(MemoryStream buf);
    protected virtual void SendCertificateVerifyMessage(DigitallySigned certificateVerify);
    protected virtual void SendClientHelloMessage();
    protected virtual void SendClientKeyExchangeMessage();
}
public interface Org.BouncyCastle.Crypto.Tls.TlsCloseable {
    public abstract virtual void Close();
}
public interface Org.BouncyCastle.Crypto.Tls.TlsCompression {
    public abstract virtual Stream Compress(Stream output);
    public abstract virtual Stream Decompress(Stream output);
}
public interface Org.BouncyCastle.Crypto.Tls.TlsContext {
    public IRandomGenerator NonceRandomGenerator { get; }
    public SecureRandom SecureRandom { get; }
    public SecurityParameters SecurityParameters { get; }
    public bool IsServer { get; }
    public ProtocolVersion ClientVersion { get; }
    public ProtocolVersion ServerVersion { get; }
    public TlsSession ResumableSession { get; }
    public object UserObject { get; public set; }
    public abstract virtual IRandomGenerator get_NonceRandomGenerator();
    public abstract virtual SecureRandom get_SecureRandom();
    public abstract virtual SecurityParameters get_SecurityParameters();
    public abstract virtual bool get_IsServer();
    public abstract virtual ProtocolVersion get_ClientVersion();
    public abstract virtual ProtocolVersion get_ServerVersion();
    public abstract virtual TlsSession get_ResumableSession();
    public abstract virtual object get_UserObject();
    public abstract virtual void set_UserObject(object value);
    public abstract virtual Byte[] ExportKeyingMaterial(string asciiLabel, Byte[] context_value, int length);
}
public interface Org.BouncyCastle.Crypto.Tls.TlsCredentials {
    public Certificate Certificate { get; }
    public abstract virtual Certificate get_Certificate();
}
public class Org.BouncyCastle.Crypto.Tls.TlsDeflateCompression : object {
    public static int LEVEL_NONE;
    public static int LEVEL_FASTEST;
    public static int LEVEL_SMALLEST;
    public static int LEVEL_DEFAULT;
    protected ZStream zIn;
    protected ZStream zOut;
    public TlsDeflateCompression(int level);
    public virtual Stream Compress(Stream output);
    public virtual Stream Decompress(Stream output);
}
public class Org.BouncyCastle.Crypto.Tls.TlsDheKeyExchange : TlsDHKeyExchange {
    protected TlsSignerCredentials mServerCredentials;
    [ObsoleteAttribute("Use constructor that takes a TlsDHVerifier")]
public TlsDheKeyExchange(int keyExchange, IList supportedSignatureAlgorithms, DHParameters dhParameters);
    public TlsDheKeyExchange(int keyExchange, IList supportedSignatureAlgorithms, TlsDHVerifier dhVerifier, DHParameters dhParameters);
    public virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public virtual Byte[] GenerateServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    protected virtual ISigner InitVerifyer(TlsSigner tlsSigner, SignatureAndHashAlgorithm algorithm, SecurityParameters securityParameters);
}
public class Org.BouncyCastle.Crypto.Tls.TlsDHKeyExchange : AbstractTlsKeyExchange {
    protected TlsSigner mTlsSigner;
    protected TlsDHVerifier mDHVerifier;
    protected DHParameters mDHParameters;
    protected AsymmetricKeyParameter mServerPublicKey;
    protected TlsAgreementCredentials mAgreementCredentials;
    protected DHPrivateKeyParameters mDHAgreePrivateKey;
    protected DHPublicKeyParameters mDHAgreePublicKey;
    public bool RequiresServerKeyExchange { get; }
    [ObsoleteAttribute("Use constructor that takes a TlsDHVerifier")]
public TlsDHKeyExchange(int keyExchange, IList supportedSignatureAlgorithms, DHParameters dhParameters);
    public TlsDHKeyExchange(int keyExchange, IList supportedSignatureAlgorithms, TlsDHVerifier dhVerifier, DHParameters dhParameters);
    public virtual void Init(TlsContext context);
    public virtual void SkipServerCredentials();
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual bool get_RequiresServerKeyExchange();
    public virtual Byte[] GenerateServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    public virtual void ValidateCertificateRequest(CertificateRequest certificateRequest);
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual void ProcessClientCertificate(Certificate clientCertificate);
    public virtual void ProcessClientKeyExchange(Stream input);
    public virtual Byte[] GeneratePremasterSecret();
}
public abstract class Org.BouncyCastle.Crypto.Tls.TlsDHUtilities : object {
    internal static BigInteger Two;
    private static string draft_ffdhe2432_p;
    internal static DHParameters draft_ffdhe2432;
    private static string draft_ffdhe3072_p;
    internal static DHParameters draft_ffdhe3072;
    private static string draft_ffdhe4096_p;
    internal static DHParameters draft_ffdhe4096;
    private static string draft_ffdhe6144_p;
    internal static DHParameters draft_ffdhe6144;
    private static string draft_ffdhe8192_p;
    internal static DHParameters draft_ffdhe8192;
    private static TlsDHUtilities();
    private static BigInteger FromHex(string hex);
    private static DHParameters FromSafeP(string hexP);
    public static void AddNegotiatedDheGroupsClientExtension(IDictionary extensions, Byte[] dheGroups);
    public static void AddNegotiatedDheGroupsServerExtension(IDictionary extensions, byte dheGroup);
    public static Byte[] GetNegotiatedDheGroupsClientExtension(IDictionary extensions);
    public static short GetNegotiatedDheGroupsServerExtension(IDictionary extensions);
    public static Byte[] CreateNegotiatedDheGroupsClientExtension(Byte[] dheGroups);
    public static Byte[] CreateNegotiatedDheGroupsServerExtension(byte dheGroup);
    public static Byte[] ReadNegotiatedDheGroupsClientExtension(Byte[] extensionData);
    public static byte ReadNegotiatedDheGroupsServerExtension(Byte[] extensionData);
    public static DHParameters GetParametersForDHEGroup(short dheGroup);
    public static bool ContainsDheCipherSuites(Int32[] cipherSuites);
    public static bool IsDheCipherSuite(int cipherSuite);
    public static bool AreCompatibleParameters(DHParameters a, DHParameters b);
    public static Byte[] CalculateDHBasicAgreement(DHPublicKeyParameters publicKey, DHPrivateKeyParameters privateKey);
    public static AsymmetricCipherKeyPair GenerateDHKeyPair(SecureRandom random, DHParameters dhParams);
    public static DHPrivateKeyParameters GenerateEphemeralClientKeyExchange(SecureRandom random, DHParameters dhParams, Stream output);
    public static DHPrivateKeyParameters GenerateEphemeralServerKeyExchange(SecureRandom random, DHParameters dhParams, Stream output);
    public static BigInteger ReadDHParameter(Stream input);
    public static DHParameters ReadDHParameters(Stream input);
    public static DHParameters ReceiveDHParameters(TlsDHVerifier dhVerifier, Stream input);
    public static void WriteDHParameter(BigInteger x, Stream output);
    public static void WriteDHParameters(DHParameters dhParameters, Stream output);
}
public interface Org.BouncyCastle.Crypto.Tls.TlsDHVerifier {
    public abstract virtual bool Accept(DHParameters dhParameters);
}
public abstract class Org.BouncyCastle.Crypto.Tls.TlsDsaSigner : AbstractTlsSigner {
    protected byte SignatureAlgorithm { get; }
    public virtual Byte[] GenerateRawSignature(SignatureAndHashAlgorithm algorithm, AsymmetricKeyParameter privateKey, Byte[] hash);
    public virtual bool VerifyRawSignature(SignatureAndHashAlgorithm algorithm, Byte[] sigBytes, AsymmetricKeyParameter publicKey, Byte[] hash);
    public virtual ISigner CreateSigner(SignatureAndHashAlgorithm algorithm, AsymmetricKeyParameter privateKey);
    public virtual ISigner CreateVerifyer(SignatureAndHashAlgorithm algorithm, AsymmetricKeyParameter publicKey);
    protected virtual ICipherParameters MakeInitParameters(bool forSigning, ICipherParameters cp);
    protected virtual ISigner MakeSigner(SignatureAndHashAlgorithm algorithm, bool raw, bool forSigning, ICipherParameters cp);
    protected abstract virtual byte get_SignatureAlgorithm();
    protected abstract virtual IDsa CreateDsaImpl(byte hashAlgorithm);
}
public class Org.BouncyCastle.Crypto.Tls.TlsDssSigner : TlsDsaSigner {
    protected byte SignatureAlgorithm { get; }
    public virtual bool IsValidPublicKey(AsymmetricKeyParameter publicKey);
    protected virtual IDsa CreateDsaImpl(byte hashAlgorithm);
    protected virtual byte get_SignatureAlgorithm();
}
public abstract class Org.BouncyCastle.Crypto.Tls.TlsEccUtilities : object {
    private static String[] CurveNames;
    private static TlsEccUtilities();
    public static void AddSupportedEllipticCurvesExtension(IDictionary extensions, Int32[] namedCurves);
    public static void AddSupportedPointFormatsExtension(IDictionary extensions, Byte[] ecPointFormats);
    public static Int32[] GetSupportedEllipticCurvesExtension(IDictionary extensions);
    public static Byte[] GetSupportedPointFormatsExtension(IDictionary extensions);
    public static Byte[] CreateSupportedEllipticCurvesExtension(Int32[] namedCurves);
    public static Byte[] CreateSupportedPointFormatsExtension(Byte[] ecPointFormats);
    public static Int32[] ReadSupportedEllipticCurvesExtension(Byte[] extensionData);
    public static Byte[] ReadSupportedPointFormatsExtension(Byte[] extensionData);
    public static string GetNameOfNamedCurve(int namedCurve);
    public static ECDomainParameters GetParametersForNamedCurve(int namedCurve);
    public static bool HasAnySupportedNamedCurves();
    public static bool ContainsEccCipherSuites(Int32[] cipherSuites);
    public static bool IsEccCipherSuite(int cipherSuite);
    public static bool AreOnSameCurve(ECDomainParameters a, ECDomainParameters b);
    public static bool IsSupportedNamedCurve(int namedCurve);
    public static bool IsCompressionPreferred(Byte[] ecPointFormats, byte compressionFormat);
    public static Byte[] SerializeECFieldElement(int fieldSize, BigInteger x);
    public static Byte[] SerializeECPoint(Byte[] ecPointFormats, ECPoint point);
    public static Byte[] SerializeECPublicKey(Byte[] ecPointFormats, ECPublicKeyParameters keyParameters);
    public static BigInteger DeserializeECFieldElement(int fieldSize, Byte[] encoding);
    public static ECPoint DeserializeECPoint(Byte[] ecPointFormats, ECCurve curve, Byte[] encoding);
    public static ECPublicKeyParameters DeserializeECPublicKey(Byte[] ecPointFormats, ECDomainParameters curve_params, Byte[] encoding);
    public static Byte[] CalculateECDHBasicAgreement(ECPublicKeyParameters publicKey, ECPrivateKeyParameters privateKey);
    public static AsymmetricCipherKeyPair GenerateECKeyPair(SecureRandom random, ECDomainParameters ecParams);
    public static ECPrivateKeyParameters GenerateEphemeralClientKeyExchange(SecureRandom random, Byte[] ecPointFormats, ECDomainParameters ecParams, Stream output);
    internal static ECPrivateKeyParameters GenerateEphemeralServerKeyExchange(SecureRandom random, Int32[] namedCurves, Byte[] ecPointFormats, Stream output);
    public static ECPublicKeyParameters ValidateECPublicKey(ECPublicKeyParameters key);
    public static int ReadECExponent(int fieldSize, Stream input);
    public static BigInteger ReadECFieldElement(int fieldSize, Stream input);
    public static BigInteger ReadECParameter(Stream input);
    public static ECDomainParameters ReadECParameters(Int32[] namedCurves, Byte[] ecPointFormats, Stream input);
    private static void CheckNamedCurve(Int32[] namedCurves, int namedCurve);
    public static void WriteECExponent(int k, Stream output);
    public static void WriteECFieldElement(ECFieldElement x, Stream output);
    public static void WriteECFieldElement(int fieldSize, BigInteger x, Stream output);
    public static void WriteECParameter(BigInteger x, Stream output);
    public static void WriteExplicitECParameters(Byte[] ecPointFormats, ECDomainParameters ecParameters, Stream output);
    public static void WriteECPoint(Byte[] ecPointFormats, ECPoint point, Stream output);
    public static void WriteNamedECParameters(int namedCurve, Stream output);
}
public class Org.BouncyCastle.Crypto.Tls.TlsECDheKeyExchange : TlsECDHKeyExchange {
    protected TlsSignerCredentials mServerCredentials;
    public TlsECDheKeyExchange(int keyExchange, IList supportedSignatureAlgorithms, Int32[] namedCurves, Byte[] clientECPointFormats, Byte[] serverECPointFormats);
    public virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public virtual Byte[] GenerateServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    public virtual void ValidateCertificateRequest(CertificateRequest certificateRequest);
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    protected virtual ISigner InitVerifyer(TlsSigner tlsSigner, SignatureAndHashAlgorithm algorithm, SecurityParameters securityParameters);
}
public class Org.BouncyCastle.Crypto.Tls.TlsECDHKeyExchange : AbstractTlsKeyExchange {
    protected TlsSigner mTlsSigner;
    protected Int32[] mNamedCurves;
    protected Byte[] mClientECPointFormats;
    protected Byte[] mServerECPointFormats;
    protected AsymmetricKeyParameter mServerPublicKey;
    protected TlsAgreementCredentials mAgreementCredentials;
    protected ECPrivateKeyParameters mECAgreePrivateKey;
    protected ECPublicKeyParameters mECAgreePublicKey;
    public bool RequiresServerKeyExchange { get; }
    public TlsECDHKeyExchange(int keyExchange, IList supportedSignatureAlgorithms, Int32[] namedCurves, Byte[] clientECPointFormats, Byte[] serverECPointFormats);
    public virtual void Init(TlsContext context);
    public virtual void SkipServerCredentials();
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual bool get_RequiresServerKeyExchange();
    public virtual Byte[] GenerateServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    public virtual void ValidateCertificateRequest(CertificateRequest certificateRequest);
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual void ProcessClientCertificate(Certificate clientCertificate);
    public virtual void ProcessClientKeyExchange(Stream input);
    public virtual Byte[] GeneratePremasterSecret();
}
public class Org.BouncyCastle.Crypto.Tls.TlsECDsaSigner : TlsDsaSigner {
    protected byte SignatureAlgorithm { get; }
    public virtual bool IsValidPublicKey(AsymmetricKeyParameter publicKey);
    protected virtual IDsa CreateDsaImpl(byte hashAlgorithm);
    protected virtual byte get_SignatureAlgorithm();
}
public interface Org.BouncyCastle.Crypto.Tls.TlsEncryptionCredentials {
    public abstract virtual Byte[] DecryptPreMasterSecret(Byte[] encryptedPreMasterSecret);
}
public class Org.BouncyCastle.Crypto.Tls.TlsException : IOException {
    public TlsException(string message);
    public TlsException(string message, Exception cause);
}
public abstract class Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities : object {
    public static IDictionary EnsureExtensionsInitialised(IDictionary extensions);
    public static void AddClientCertificateTypeExtensionClient(IDictionary extensions, Byte[] certificateTypes);
    public static void AddClientCertificateTypeExtensionServer(IDictionary extensions, byte certificateType);
    public static void AddEncryptThenMacExtension(IDictionary extensions);
    public static void AddExtendedMasterSecretExtension(IDictionary extensions);
    public static void AddHeartbeatExtension(IDictionary extensions, HeartbeatExtension heartbeatExtension);
    public static void AddMaxFragmentLengthExtension(IDictionary extensions, byte maxFragmentLength);
    public static void AddPaddingExtension(IDictionary extensions, int dataLength);
    public static void AddServerCertificateTypeExtensionClient(IDictionary extensions, Byte[] certificateTypes);
    public static void AddServerCertificateTypeExtensionServer(IDictionary extensions, byte certificateType);
    public static void AddServerNameExtension(IDictionary extensions, ServerNameList serverNameList);
    public static void AddStatusRequestExtension(IDictionary extensions, CertificateStatusRequest statusRequest);
    public static void AddTruncatedHMacExtension(IDictionary extensions);
    public static Byte[] GetClientCertificateTypeExtensionClient(IDictionary extensions);
    public static short GetClientCertificateTypeExtensionServer(IDictionary extensions);
    public static HeartbeatExtension GetHeartbeatExtension(IDictionary extensions);
    public static short GetMaxFragmentLengthExtension(IDictionary extensions);
    public static int GetPaddingExtension(IDictionary extensions);
    public static Byte[] GetServerCertificateTypeExtensionClient(IDictionary extensions);
    public static short GetServerCertificateTypeExtensionServer(IDictionary extensions);
    public static ServerNameList GetServerNameExtension(IDictionary extensions);
    public static CertificateStatusRequest GetStatusRequestExtension(IDictionary extensions);
    public static bool HasEncryptThenMacExtension(IDictionary extensions);
    public static bool HasExtendedMasterSecretExtension(IDictionary extensions);
    public static bool HasTruncatedHMacExtension(IDictionary extensions);
    public static Byte[] CreateCertificateTypeExtensionClient(Byte[] certificateTypes);
    public static Byte[] CreateCertificateTypeExtensionServer(byte certificateType);
    public static Byte[] CreateEmptyExtensionData();
    public static Byte[] CreateEncryptThenMacExtension();
    public static Byte[] CreateExtendedMasterSecretExtension();
    public static Byte[] CreateHeartbeatExtension(HeartbeatExtension heartbeatExtension);
    public static Byte[] CreateMaxFragmentLengthExtension(byte maxFragmentLength);
    public static Byte[] CreatePaddingExtension(int dataLength);
    public static Byte[] CreateServerNameExtension(ServerNameList serverNameList);
    public static Byte[] CreateStatusRequestExtension(CertificateStatusRequest statusRequest);
    public static Byte[] CreateTruncatedHMacExtension();
    private static bool ReadEmptyExtensionData(Byte[] extensionData);
    public static Byte[] ReadCertificateTypeExtensionClient(Byte[] extensionData);
    public static byte ReadCertificateTypeExtensionServer(Byte[] extensionData);
    public static bool ReadEncryptThenMacExtension(Byte[] extensionData);
    public static bool ReadExtendedMasterSecretExtension(Byte[] extensionData);
    public static HeartbeatExtension ReadHeartbeatExtension(Byte[] extensionData);
    public static byte ReadMaxFragmentLengthExtension(Byte[] extensionData);
    public static int ReadPaddingExtension(Byte[] extensionData);
    public static ServerNameList ReadServerNameExtension(Byte[] extensionData);
    public static CertificateStatusRequest ReadStatusRequestExtension(Byte[] extensionData);
    public static bool ReadTruncatedHMacExtension(Byte[] extensionData);
}
public class Org.BouncyCastle.Crypto.Tls.TlsFatalAlert : TlsException {
    private byte alertDescription;
    public byte AlertDescription { get; }
    public TlsFatalAlert(byte alertDescription);
    public TlsFatalAlert(byte alertDescription, Exception alertCause);
    public virtual byte get_AlertDescription();
}
public class Org.BouncyCastle.Crypto.Tls.TlsFatalAlertReceived : TlsException {
    private byte alertDescription;
    public byte AlertDescription { get; }
    public TlsFatalAlertReceived(byte alertDescription);
    public virtual byte get_AlertDescription();
}
public interface Org.BouncyCastle.Crypto.Tls.TlsHandshakeHash {
    public abstract virtual void Init(TlsContext context);
    public abstract virtual TlsHandshakeHash NotifyPrfDetermined();
    public abstract virtual void TrackHashAlgorithm(byte hashAlgorithm);
    public abstract virtual void SealHashAlgorithms();
    public abstract virtual TlsHandshakeHash StopTracking();
    public abstract virtual IDigest ForkPrfHash();
    public abstract virtual Byte[] GetFinalHash(byte hashAlgorithm);
}
public interface Org.BouncyCastle.Crypto.Tls.TlsKeyExchange {
    public bool RequiresServerKeyExchange { get; }
    public abstract virtual void Init(TlsContext context);
    public abstract virtual void SkipServerCredentials();
    public abstract virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public abstract virtual void ProcessServerCertificate(Certificate serverCertificate);
    public abstract virtual bool get_RequiresServerKeyExchange();
    public abstract virtual Byte[] GenerateServerKeyExchange();
    public abstract virtual void SkipServerKeyExchange();
    public abstract virtual void ProcessServerKeyExchange(Stream input);
    public abstract virtual void ValidateCertificateRequest(CertificateRequest certificateRequest);
    public abstract virtual void SkipClientCredentials();
    public abstract virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public abstract virtual void ProcessClientCertificate(Certificate clientCertificate);
    public abstract virtual void GenerateClientKeyExchange(Stream output);
    public abstract virtual void ProcessClientKeyExchange(Stream input);
    public abstract virtual Byte[] GeneratePremasterSecret();
}
public class Org.BouncyCastle.Crypto.Tls.TlsMac : object {
    protected TlsContext context;
    protected Byte[] secret;
    protected IMac mac;
    protected int digestBlockSize;
    protected int digestOverhead;
    protected int macLength;
    public Byte[] MacSecret { get; }
    public int Size { get; }
    public TlsMac(TlsContext context, IDigest digest, Byte[] key, int keyOff, int keyLen);
    public virtual Byte[] get_MacSecret();
    public virtual int get_Size();
    public virtual Byte[] CalculateMac(long seqNo, byte type, Byte[] message, int offset, int length);
    public virtual Byte[] CalculateMacConstantTime(long seqNo, byte type, Byte[] message, int offset, int length, int fullLength, Byte[] dummyData);
    protected virtual int GetDigestBlockCount(int inputLength);
    protected virtual Byte[] Truncate(Byte[] bs);
}
public class Org.BouncyCastle.Crypto.Tls.TlsNoCloseNotifyException : EndOfStreamException {
}
public class Org.BouncyCastle.Crypto.Tls.TlsNullCipher : object {
    protected TlsContext context;
    protected TlsMac writeMac;
    protected TlsMac readMac;
    public TlsNullCipher(TlsContext context);
    public TlsNullCipher(TlsContext context, IDigest clientWriteDigest, IDigest serverWriteDigest);
    public virtual int GetPlaintextLimit(int ciphertextLimit);
    public virtual Byte[] EncodePlaintext(long seqNo, byte type, Byte[] plaintext, int offset, int len);
    public virtual Byte[] DecodeCiphertext(long seqNo, byte type, Byte[] ciphertext, int offset, int len);
}
public class Org.BouncyCastle.Crypto.Tls.TlsNullCompression : object {
    public virtual Stream Compress(Stream output);
    public virtual Stream Decompress(Stream output);
}
public interface Org.BouncyCastle.Crypto.Tls.TlsPeer {
    public abstract virtual void NotifyCloseHandle(TlsCloseable closehandle);
    public abstract virtual void Cancel();
    public abstract virtual int GetHandshakeTimeoutMillis();
    public abstract virtual bool RequiresExtendedMasterSecret();
    public abstract virtual bool ShouldUseGmtUnixTime();
    public abstract virtual void NotifySecureRenegotiation(bool secureRenegotiation);
    public abstract virtual TlsCompression GetCompression();
    public abstract virtual TlsCipher GetCipher();
    public abstract virtual void NotifyAlertRaised(byte alertLevel, byte alertDescription, string message, Exception cause);
    public abstract virtual void NotifyAlertReceived(byte alertLevel, byte alertDescription);
    public abstract virtual void NotifyHandshakeComplete();
}
public abstract class Org.BouncyCastle.Crypto.Tls.TlsProtocol : object {
    protected static short CS_START;
    protected static short CS_CLIENT_HELLO;
    protected static short CS_SERVER_HELLO;
    protected static short CS_SERVER_SUPPLEMENTAL_DATA;
    protected static short CS_SERVER_CERTIFICATE;
    protected static short CS_CERTIFICATE_STATUS;
    protected static short CS_SERVER_KEY_EXCHANGE;
    protected static short CS_CERTIFICATE_REQUEST;
    protected static short CS_SERVER_HELLO_DONE;
    protected static short CS_CLIENT_SUPPLEMENTAL_DATA;
    protected static short CS_CLIENT_CERTIFICATE;
    protected static short CS_CLIENT_KEY_EXCHANGE;
    protected static short CS_CERTIFICATE_VERIFY;
    protected static short CS_CLIENT_FINISHED;
    protected static short CS_SERVER_SESSION_TICKET;
    protected static short CS_SERVER_FINISHED;
    protected static short CS_END;
    protected static short ADS_MODE_1_Nsub1;
    protected static short ADS_MODE_0_N;
    protected static short ADS_MODE_0_N_FIRSTONLY;
    private ByteQueue mApplicationDataQueue;
    private ByteQueue mAlertQueue;
    private ByteQueue mHandshakeQueue;
    internal RecordStream mRecordStream;
    protected SecureRandom mSecureRandom;
    private TlsStream mTlsStream;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) mClosed;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) mFailedWithError;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) mAppDataReady;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) mAppDataSplitEnabled;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) mAppDataSplitMode;
    private Byte[] mExpectedVerifyData;
    protected TlsSession mTlsSession;
    protected SessionParameters mSessionParameters;
    protected SecurityParameters mSecurityParameters;
    protected Certificate mPeerCertificate;
    protected Int32[] mOfferedCipherSuites;
    protected Byte[] mOfferedCompressionMethods;
    protected IDictionary mClientExtensions;
    protected IDictionary mServerExtensions;
    protected short mConnectionState;
    protected bool mResumedSession;
    protected bool mReceivedChangeCipherSpec;
    protected bool mSecureRenegotiation;
    protected bool mAllowCertificateStatus;
    protected bool mExpectSessionTicket;
    protected bool mBlocking;
    protected ByteQueueStream mInputBuffers;
    protected ByteQueueStream mOutputBuffer;
    protected TlsContext Context { get; }
    internal AbstractTlsContext ContextAdmin { get; }
    protected TlsPeer Peer { get; }
    public Stream Stream { get; }
    public bool IsClosed { get; }
    public TlsProtocol(Stream stream, SecureRandom secureRandom);
    public TlsProtocol(Stream input, Stream output, SecureRandom secureRandom);
    public TlsProtocol(SecureRandom secureRandom);
    protected abstract virtual TlsContext get_Context();
    internal abstract virtual AbstractTlsContext get_ContextAdmin();
    protected abstract virtual TlsPeer get_Peer();
    protected virtual void HandleAlertMessage(byte alertLevel, byte alertDescription);
    protected virtual void HandleAlertWarningMessage(byte alertDescription);
    protected virtual void HandleChangeCipherSpecMessage();
    protected virtual void HandleClose(bool user_canceled);
    protected virtual void HandleException(byte alertDescription, string message, Exception cause);
    protected virtual void HandleFailure();
    protected abstract virtual void HandleHandshakeMessage(byte type, MemoryStream buf);
    protected virtual void ApplyMaxFragmentLengthExtension();
    protected virtual void CheckReceivedChangeCipherSpec(bool expected);
    protected virtual void CleanupHandshake();
    protected virtual void BlockForHandshake();
    protected virtual void CompleteHandshake();
    protected internal void ProcessRecord(byte protocol, Byte[] buf, int off, int len);
    private void ProcessHandshakeQueue(ByteQueue queue);
    private void ProcessApplicationDataQueue();
    private void ProcessAlertQueue();
    private void ProcessChangeCipherSpec(Byte[] buf, int off, int len);
    protected internal virtual int ApplicationDataAvailable();
    protected internal virtual int ReadApplicationData(Byte[] buf, int offset, int len);
    protected virtual void SafeCheckRecordHeader(Byte[] recordHeader);
    protected virtual void SafeReadRecord();
    protected virtual void SafeWriteRecord(byte type, Byte[] buf, int offset, int len);
    protected internal virtual void WriteData(Byte[] buf, int offset, int len);
    protected virtual void SetAppDataSplitMode(int appDataSplitMode);
    protected virtual void WriteHandshakeMessage(Byte[] buf, int off, int len);
    public virtual Stream get_Stream();
    public virtual void CloseInput();
    public virtual void OfferInput(Byte[] input);
    public virtual void OfferInput(Byte[] input, int inputOff, int inputLen);
    public virtual int GetAvailableInputBytes();
    public virtual int ReadInput(Byte[] buffer, int offset, int length);
    public virtual void OfferOutput(Byte[] buffer, int offset, int length);
    public virtual int GetAvailableOutputBytes();
    public virtual int ReadOutput(Byte[] buffer, int offset, int length);
    protected virtual void InvalidateSession();
    protected virtual void ProcessFinishedMessage(MemoryStream buf);
    protected virtual void RaiseAlertFatal(byte alertDescription, string message, Exception cause);
    protected virtual void RaiseAlertWarning(byte alertDescription, string message);
    protected virtual void SendCertificateMessage(Certificate certificate);
    protected virtual void SendChangeCipherSpecMessage();
    protected virtual void SendFinishedMessage();
    protected virtual void SendSupplementalDataMessage(IList supplementalData);
    protected virtual Byte[] CreateVerifyData(bool isServer);
    public virtual void Close();
    protected internal virtual void Flush();
    public virtual bool get_IsClosed();
    protected virtual short ProcessMaxFragmentLengthExtension(IDictionary clientExtensions, IDictionary serverExtensions, byte alertDescription);
    protected virtual void RefuseRenegotiation();
    protected internal static void AssertEmpty(MemoryStream buf);
    protected internal static Byte[] CreateRandomBlock(bool useGmtUnixTime, IRandomGenerator randomGenerator);
    protected internal static Byte[] CreateRenegotiationInfo(Byte[] renegotiated_connection);
    protected internal static void EstablishMasterSecret(TlsContext context, TlsKeyExchange keyExchange);
    protected internal static Byte[] GetCurrentPrfHash(TlsContext context, TlsHandshakeHash handshakeHash, Byte[] sslSender);
    protected internal static IDictionary ReadExtensions(MemoryStream input);
    protected internal static IList ReadSupplementalDataMessage(MemoryStream input);
    protected internal static void WriteExtensions(Stream output, IDictionary extensions);
    protected internal static void WriteSelectedExtensions(Stream output, IDictionary extensions, bool selectEmpty);
    protected internal static void WriteSupplementalData(Stream output, IList supplementalData);
    protected internal static int GetPrfAlgorithm(TlsContext context, int ciphersuite);
}
[ObsoleteAttribute("Use 'TlsClientProtocol' instead")]
public class Org.BouncyCastle.Crypto.Tls.TlsProtocolHandler : TlsClientProtocol {
    public TlsProtocolHandler(Stream stream, SecureRandom secureRandom);
    public TlsProtocolHandler(Stream input, Stream output, SecureRandom secureRandom);
}
public interface Org.BouncyCastle.Crypto.Tls.TlsPskIdentity {
    public abstract virtual void SkipIdentityHint();
    public abstract virtual void NotifyIdentityHint(Byte[] psk_identity_hint);
    public abstract virtual Byte[] GetPskIdentity();
    public abstract virtual Byte[] GetPsk();
}
public interface Org.BouncyCastle.Crypto.Tls.TlsPskIdentityManager {
    public abstract virtual Byte[] GetHint();
    public abstract virtual Byte[] GetPsk(Byte[] identity);
}
public class Org.BouncyCastle.Crypto.Tls.TlsPskKeyExchange : AbstractTlsKeyExchange {
    protected TlsPskIdentity mPskIdentity;
    protected TlsPskIdentityManager mPskIdentityManager;
    protected TlsDHVerifier mDHVerifier;
    protected DHParameters mDHParameters;
    protected Int32[] mNamedCurves;
    protected Byte[] mClientECPointFormats;
    protected Byte[] mServerECPointFormats;
    protected Byte[] mPskIdentityHint;
    protected Byte[] mPsk;
    protected DHPrivateKeyParameters mDHAgreePrivateKey;
    protected DHPublicKeyParameters mDHAgreePublicKey;
    protected ECPrivateKeyParameters mECAgreePrivateKey;
    protected ECPublicKeyParameters mECAgreePublicKey;
    protected AsymmetricKeyParameter mServerPublicKey;
    protected RsaKeyParameters mRsaServerPublicKey;
    protected TlsEncryptionCredentials mServerCredentials;
    protected Byte[] mPremasterSecret;
    public bool RequiresServerKeyExchange { get; }
    [ObsoleteAttribute("Use constructor that takes a TlsDHVerifier")]
public TlsPskKeyExchange(int keyExchange, IList supportedSignatureAlgorithms, TlsPskIdentity pskIdentity, TlsPskIdentityManager pskIdentityManager, DHParameters dhParameters, Int32[] namedCurves, Byte[] clientECPointFormats, Byte[] serverECPointFormats);
    public TlsPskKeyExchange(int keyExchange, IList supportedSignatureAlgorithms, TlsPskIdentity pskIdentity, TlsPskIdentityManager pskIdentityManager, TlsDHVerifier dhVerifier, DHParameters dhParameters, Int32[] namedCurves, Byte[] clientECPointFormats, Byte[] serverECPointFormats);
    public virtual void SkipServerCredentials();
    public virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public virtual Byte[] GenerateServerKeyExchange();
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual bool get_RequiresServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    public virtual void ValidateCertificateRequest(CertificateRequest certificateRequest);
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual void ProcessClientKeyExchange(Stream input);
    public virtual Byte[] GeneratePremasterSecret();
    protected virtual Byte[] GenerateOtherSecret(int pskLength);
    protected virtual RsaKeyParameters ValidateRsaPublicKey(RsaKeyParameters key);
}
public class Org.BouncyCastle.Crypto.Tls.TlsRsaKeyExchange : AbstractTlsKeyExchange {
    protected AsymmetricKeyParameter mServerPublicKey;
    protected RsaKeyParameters mRsaServerPublicKey;
    protected TlsEncryptionCredentials mServerCredentials;
    protected Byte[] mPremasterSecret;
    public TlsRsaKeyExchange(IList supportedSignatureAlgorithms);
    public virtual void SkipServerCredentials();
    public virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual void ValidateCertificateRequest(CertificateRequest certificateRequest);
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual void ProcessClientKeyExchange(Stream input);
    public virtual Byte[] GeneratePremasterSecret();
    protected virtual RsaKeyParameters ValidateRsaPublicKey(RsaKeyParameters key);
}
public class Org.BouncyCastle.Crypto.Tls.TlsRsaSigner : AbstractTlsSigner {
    public virtual Byte[] GenerateRawSignature(SignatureAndHashAlgorithm algorithm, AsymmetricKeyParameter privateKey, Byte[] hash);
    public virtual bool VerifyRawSignature(SignatureAndHashAlgorithm algorithm, Byte[] sigBytes, AsymmetricKeyParameter publicKey, Byte[] hash);
    public virtual ISigner CreateSigner(SignatureAndHashAlgorithm algorithm, AsymmetricKeyParameter privateKey);
    public virtual ISigner CreateVerifyer(SignatureAndHashAlgorithm algorithm, AsymmetricKeyParameter publicKey);
    public virtual bool IsValidPublicKey(AsymmetricKeyParameter publicKey);
    protected virtual ISigner MakeSigner(SignatureAndHashAlgorithm algorithm, bool raw, bool forSigning, ICipherParameters cp);
    protected virtual IAsymmetricBlockCipher CreateRsaImpl();
}
public abstract class Org.BouncyCastle.Crypto.Tls.TlsRsaUtilities : object {
    public static Byte[] GenerateEncryptedPreMasterSecret(TlsContext context, RsaKeyParameters rsaServerPublicKey, Stream output);
    public static Byte[] SafeDecryptPreMasterSecret(TlsContext context, RsaKeyParameters rsaServerPrivateKey, Byte[] encryptedPreMasterSecret);
}
public interface Org.BouncyCastle.Crypto.Tls.TlsServer {
    public abstract virtual void Init(TlsServerContext context);
    public abstract virtual void NotifyClientVersion(ProtocolVersion clientVersion);
    public abstract virtual void NotifyFallback(bool isFallback);
    public abstract virtual void NotifyOfferedCipherSuites(Int32[] offeredCipherSuites);
    public abstract virtual void NotifyOfferedCompressionMethods(Byte[] offeredCompressionMethods);
    public abstract virtual void ProcessClientExtensions(IDictionary clientExtensions);
    public abstract virtual ProtocolVersion GetServerVersion();
    public abstract virtual int GetSelectedCipherSuite();
    public abstract virtual byte GetSelectedCompressionMethod();
    public abstract virtual IDictionary GetServerExtensions();
    public abstract virtual IList GetServerSupplementalData();
    public abstract virtual TlsCredentials GetCredentials();
    public abstract virtual CertificateStatus GetCertificateStatus();
    public abstract virtual TlsKeyExchange GetKeyExchange();
    public abstract virtual CertificateRequest GetCertificateRequest();
    public abstract virtual void ProcessClientSupplementalData(IList clientSupplementalData);
    public abstract virtual void NotifyClientCertificate(Certificate clientCertificate);
    public abstract virtual NewSessionTicket GetNewSessionTicket();
}
public interface Org.BouncyCastle.Crypto.Tls.TlsServerContext {
}
internal class Org.BouncyCastle.Crypto.Tls.TlsServerContextImpl : AbstractTlsContext {
    public bool IsServer { get; }
    internal TlsServerContextImpl(SecureRandom secureRandom, SecurityParameters securityParameters);
    public virtual bool get_IsServer();
}
public class Org.BouncyCastle.Crypto.Tls.TlsServerProtocol : TlsProtocol {
    protected TlsServer mTlsServer;
    internal TlsServerContextImpl mTlsServerContext;
    protected TlsKeyExchange mKeyExchange;
    protected TlsCredentials mServerCredentials;
    protected CertificateRequest mCertificateRequest;
    protected short mClientCertificateType;
    protected TlsHandshakeHash mPrepareFinishHash;
    protected TlsContext Context { get; }
    internal AbstractTlsContext ContextAdmin { get; }
    protected TlsPeer Peer { get; }
    public TlsServerProtocol(Stream stream, SecureRandom secureRandom);
    public TlsServerProtocol(Stream input, Stream output, SecureRandom secureRandom);
    public TlsServerProtocol(SecureRandom secureRandom);
    public virtual void Accept(TlsServer tlsServer);
    protected virtual void CleanupHandshake();
    protected virtual TlsContext get_Context();
    internal virtual AbstractTlsContext get_ContextAdmin();
    protected virtual TlsPeer get_Peer();
    protected virtual void HandleHandshakeMessage(byte type, MemoryStream buf);
    protected virtual void HandleAlertWarningMessage(byte alertDescription);
    protected virtual void NotifyClientCertificate(Certificate clientCertificate);
    protected virtual void ReceiveCertificateMessage(MemoryStream buf);
    protected virtual void ReceiveCertificateVerifyMessage(MemoryStream buf);
    protected virtual void ReceiveClientHelloMessage(MemoryStream buf);
    protected virtual void ReceiveClientKeyExchangeMessage(MemoryStream buf);
    protected virtual void SendCertificateRequestMessage(CertificateRequest certificateRequest);
    protected virtual void SendCertificateStatusMessage(CertificateStatus certificateStatus);
    protected virtual void SendNewSessionTicketMessage(NewSessionTicket newSessionTicket);
    protected virtual void SendServerHelloMessage();
    protected virtual void SendServerHelloDoneMessage();
    protected virtual void SendServerKeyExchangeMessage(Byte[] serverKeyExchange);
    protected virtual bool ExpectCertificateVerifyMessage();
}
public interface Org.BouncyCastle.Crypto.Tls.TlsSession {
    public Byte[] SessionID { get; }
    public bool IsResumable { get; }
    public abstract virtual SessionParameters ExportSessionParameters();
    public abstract virtual Byte[] get_SessionID();
    public abstract virtual void Invalidate();
    public abstract virtual bool get_IsResumable();
}
internal class Org.BouncyCastle.Crypto.Tls.TlsSessionImpl : object {
    internal Byte[] mSessionID;
    internal SessionParameters mSessionParameters;
    internal bool mResumable;
    public Byte[] SessionID { get; }
    public bool IsResumable { get; }
    internal TlsSessionImpl(Byte[] sessionID, SessionParameters sessionParameters);
    public virtual SessionParameters ExportSessionParameters();
    public virtual Byte[] get_SessionID();
    public virtual void Invalidate();
    public virtual bool get_IsResumable();
}
public interface Org.BouncyCastle.Crypto.Tls.TlsSigner {
    public abstract virtual void Init(TlsContext context);
    public abstract virtual Byte[] GenerateRawSignature(AsymmetricKeyParameter privateKey, Byte[] md5AndSha1);
    public abstract virtual Byte[] GenerateRawSignature(SignatureAndHashAlgorithm algorithm, AsymmetricKeyParameter privateKey, Byte[] hash);
    public abstract virtual bool VerifyRawSignature(Byte[] sigBytes, AsymmetricKeyParameter publicKey, Byte[] md5AndSha1);
    public abstract virtual bool VerifyRawSignature(SignatureAndHashAlgorithm algorithm, Byte[] sigBytes, AsymmetricKeyParameter publicKey, Byte[] hash);
    public abstract virtual ISigner CreateSigner(AsymmetricKeyParameter privateKey);
    public abstract virtual ISigner CreateSigner(SignatureAndHashAlgorithm algorithm, AsymmetricKeyParameter privateKey);
    public abstract virtual ISigner CreateVerifyer(AsymmetricKeyParameter publicKey);
    public abstract virtual ISigner CreateVerifyer(SignatureAndHashAlgorithm algorithm, AsymmetricKeyParameter publicKey);
    public abstract virtual bool IsValidPublicKey(AsymmetricKeyParameter publicKey);
}
public interface Org.BouncyCastle.Crypto.Tls.TlsSignerCredentials {
    public SignatureAndHashAlgorithm SignatureAndHashAlgorithm { get; }
    public abstract virtual Byte[] GenerateCertificateSignature(Byte[] hash);
    public abstract virtual SignatureAndHashAlgorithm get_SignatureAndHashAlgorithm();
}
public interface Org.BouncyCastle.Crypto.Tls.TlsSrpGroupVerifier {
    public abstract virtual bool Accept(Srp6GroupParameters group);
}
public interface Org.BouncyCastle.Crypto.Tls.TlsSrpIdentityManager {
    public abstract virtual TlsSrpLoginParameters GetLoginParameters(Byte[] identity);
}
public class Org.BouncyCastle.Crypto.Tls.TlsSrpKeyExchange : AbstractTlsKeyExchange {
    protected TlsSigner mTlsSigner;
    protected TlsSrpGroupVerifier mGroupVerifier;
    protected Byte[] mIdentity;
    protected Byte[] mPassword;
    protected AsymmetricKeyParameter mServerPublicKey;
    protected Srp6GroupParameters mSrpGroup;
    protected Srp6Client mSrpClient;
    protected Srp6Server mSrpServer;
    protected BigInteger mSrpPeerCredentials;
    protected BigInteger mSrpVerifier;
    protected Byte[] mSrpSalt;
    protected TlsSignerCredentials mServerCredentials;
    public bool RequiresServerKeyExchange { get; }
    [ObsoleteAttribute("Use constructor taking an explicit 'groupVerifier' argument")]
public TlsSrpKeyExchange(int keyExchange, IList supportedSignatureAlgorithms, Byte[] identity, Byte[] password);
    public TlsSrpKeyExchange(int keyExchange, IList supportedSignatureAlgorithms, TlsSrpGroupVerifier groupVerifier, Byte[] identity, Byte[] password);
    public TlsSrpKeyExchange(int keyExchange, IList supportedSignatureAlgorithms, Byte[] identity, TlsSrpLoginParameters loginParameters);
    protected static TlsSigner CreateSigner(int keyExchange);
    public virtual void Init(TlsContext context);
    public virtual void SkipServerCredentials();
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public virtual bool get_RequiresServerKeyExchange();
    public virtual Byte[] GenerateServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    public virtual void ValidateCertificateRequest(CertificateRequest certificateRequest);
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual void ProcessClientKeyExchange(Stream input);
    public virtual Byte[] GeneratePremasterSecret();
    protected virtual ISigner InitVerifyer(TlsSigner tlsSigner, SignatureAndHashAlgorithm algorithm, SecurityParameters securityParameters);
}
public class Org.BouncyCastle.Crypto.Tls.TlsSrpLoginParameters : object {
    protected Srp6GroupParameters mGroup;
    protected BigInteger mVerifier;
    protected Byte[] mSalt;
    public Srp6GroupParameters Group { get; }
    public Byte[] Salt { get; }
    public BigInteger Verifier { get; }
    public TlsSrpLoginParameters(Srp6GroupParameters group, BigInteger verifier, Byte[] salt);
    public virtual Srp6GroupParameters get_Group();
    public virtual Byte[] get_Salt();
    public virtual BigInteger get_Verifier();
}
public abstract class Org.BouncyCastle.Crypto.Tls.TlsSrpUtilities : object {
    public static void AddSrpExtension(IDictionary extensions, Byte[] identity);
    public static Byte[] GetSrpExtension(IDictionary extensions);
    public static Byte[] CreateSrpExtension(Byte[] identity);
    public static Byte[] ReadSrpExtension(Byte[] extensionData);
    public static BigInteger ReadSrpParameter(Stream input);
    public static void WriteSrpParameter(BigInteger x, Stream output);
    public static bool IsSrpCipherSuite(int cipherSuite);
}
public abstract class Org.BouncyCastle.Crypto.Tls.TlsSRTPUtils : object {
    public static void AddUseSrtpExtension(IDictionary extensions, UseSrtpData useSRTPData);
    public static UseSrtpData GetUseSrtpExtension(IDictionary extensions);
    public static Byte[] CreateUseSrtpExtension(UseSrtpData useSrtpData);
    public static UseSrtpData ReadUseSrtpExtension(Byte[] extensionData);
}
internal class Org.BouncyCastle.Crypto.Tls.TlsStream : Stream {
    private TlsProtocol handler;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal TlsStream(TlsProtocol handler);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Close();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buf, int off, int len);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buf, int off, int len);
    public virtual void WriteByte(byte b);
}
public class Org.BouncyCastle.Crypto.Tls.TlsStreamCipher : object {
    protected TlsContext context;
    protected IStreamCipher encryptCipher;
    protected IStreamCipher decryptCipher;
    protected TlsMac writeMac;
    protected TlsMac readMac;
    protected bool usesNonce;
    public TlsStreamCipher(TlsContext context, IStreamCipher clientWriteCipher, IStreamCipher serverWriteCipher, IDigest clientWriteDigest, IDigest serverWriteDigest, int cipherKeySize, bool usesNonce);
    public virtual int GetPlaintextLimit(int ciphertextLimit);
    public virtual Byte[] EncodePlaintext(long seqNo, byte type, Byte[] plaintext, int offset, int len);
    public virtual Byte[] DecodeCiphertext(long seqNo, byte type, Byte[] ciphertext, int offset, int len);
    protected virtual void CheckMac(long seqNo, byte type, Byte[] recBuf, int recStart, int recEnd, Byte[] calcBuf, int calcOff, int calcLen);
    protected virtual void UpdateIV(IStreamCipher cipher, bool forEncryption, long seqNo);
}
public class Org.BouncyCastle.Crypto.Tls.TlsTimeoutException : TlsException {
    public TlsTimeoutException(string message);
    public TlsTimeoutException(string message, Exception cause);
}
public abstract class Org.BouncyCastle.Crypto.Tls.TlsUtilities : object {
    public static Byte[] EmptyBytes;
    public static Int16[] EmptyShorts;
    public static Int32[] EmptyInts;
    public static Int64[] EmptyLongs;
    internal static Byte[] SSL_CLIENT;
    internal static Byte[] SSL_SERVER;
    internal static Byte[][] SSL3_CONST;
    private static TlsUtilities();
    public static void CheckUint8(int i);
    public static void CheckUint8(long i);
    public static void CheckUint16(int i);
    public static void CheckUint16(long i);
    public static void CheckUint24(int i);
    public static void CheckUint24(long i);
    public static void CheckUint32(long i);
    public static void CheckUint48(long i);
    public static void CheckUint64(long i);
    public static bool IsValidUint8(int i);
    public static bool IsValidUint8(long i);
    public static bool IsValidUint16(int i);
    public static bool IsValidUint16(long i);
    public static bool IsValidUint24(int i);
    public static bool IsValidUint24(long i);
    public static bool IsValidUint32(long i);
    public static bool IsValidUint48(long i);
    public static bool IsValidUint64(long i);
    public static bool IsSsl(TlsContext context);
    public static bool IsTlsV11(ProtocolVersion version);
    public static bool IsTlsV11(TlsContext context);
    public static bool IsTlsV12(ProtocolVersion version);
    public static bool IsTlsV12(TlsContext context);
    public static void WriteUint8(byte i, Stream output);
    public static void WriteUint8(byte i, Byte[] buf, int offset);
    public static void WriteUint16(int i, Stream output);
    public static void WriteUint16(int i, Byte[] buf, int offset);
    public static void WriteUint24(int i, Stream output);
    public static void WriteUint24(int i, Byte[] buf, int offset);
    public static void WriteUint32(long i, Stream output);
    public static void WriteUint32(long i, Byte[] buf, int offset);
    public static void WriteUint48(long i, Stream output);
    public static void WriteUint48(long i, Byte[] buf, int offset);
    public static void WriteUint64(long i, Stream output);
    public static void WriteUint64(long i, Byte[] buf, int offset);
    public static void WriteOpaque8(Byte[] buf, Stream output);
    public static void WriteOpaque16(Byte[] buf, Stream output);
    public static void WriteOpaque24(Byte[] buf, Stream output);
    public static void WriteUint8Array(Byte[] uints, Stream output);
    public static void WriteUint8Array(Byte[] uints, Byte[] buf, int offset);
    public static void WriteUint8ArrayWithUint8Length(Byte[] uints, Stream output);
    public static void WriteUint8ArrayWithUint8Length(Byte[] uints, Byte[] buf, int offset);
    public static void WriteUint16Array(Int32[] uints, Stream output);
    public static void WriteUint16Array(Int32[] uints, Byte[] buf, int offset);
    public static void WriteUint16ArrayWithUint16Length(Int32[] uints, Stream output);
    public static void WriteUint16ArrayWithUint16Length(Int32[] uints, Byte[] buf, int offset);
    public static byte DecodeUint8(Byte[] buf);
    public static Byte[] DecodeUint8ArrayWithUint8Length(Byte[] buf);
    public static Byte[] EncodeOpaque8(Byte[] buf);
    public static Byte[] EncodeUint8(byte val);
    public static Byte[] EncodeUint8ArrayWithUint8Length(Byte[] uints);
    public static Byte[] EncodeUint16ArrayWithUint16Length(Int32[] uints);
    public static byte ReadUint8(Stream input);
    public static byte ReadUint8(Byte[] buf, int offset);
    public static int ReadUint16(Stream input);
    public static int ReadUint16(Byte[] buf, int offset);
    public static int ReadUint24(Stream input);
    public static int ReadUint24(Byte[] buf, int offset);
    public static long ReadUint32(Stream input);
    public static long ReadUint32(Byte[] buf, int offset);
    public static long ReadUint48(Stream input);
    public static long ReadUint48(Byte[] buf, int offset);
    public static Byte[] ReadAllOrNothing(int length, Stream input);
    public static Byte[] ReadFully(int length, Stream input);
    public static void ReadFully(Byte[] buf, Stream input);
    public static Byte[] ReadOpaque8(Stream input);
    public static Byte[] ReadOpaque16(Stream input);
    public static Byte[] ReadOpaque24(Stream input);
    public static Byte[] ReadUint8Array(int count, Stream input);
    public static Int32[] ReadUint16Array(int count, Stream input);
    public static ProtocolVersion ReadVersion(Byte[] buf, int offset);
    public static ProtocolVersion ReadVersion(Stream input);
    public static int ReadVersionRaw(Byte[] buf, int offset);
    public static int ReadVersionRaw(Stream input);
    public static Asn1Object ReadAsn1Object(Byte[] encoding);
    public static Asn1Object ReadDerObject(Byte[] encoding);
    public static void WriteGmtUnixTime(Byte[] buf, int offset);
    public static void WriteVersion(ProtocolVersion version, Stream output);
    public static void WriteVersion(ProtocolVersion version, Byte[] buf, int offset);
    public static IList GetAllSignatureAlgorithms();
    public static IList GetDefaultDssSignatureAlgorithms();
    public static IList GetDefaultECDsaSignatureAlgorithms();
    public static IList GetDefaultRsaSignatureAlgorithms();
    public static Byte[] GetExtensionData(IDictionary extensions, int extensionType);
    public static IList GetDefaultSupportedSignatureAlgorithms();
    public static SignatureAndHashAlgorithm GetSignatureAndHashAlgorithm(TlsContext context, TlsSignerCredentials signerCredentials);
    public static bool HasExpectedEmptyExtensionData(IDictionary extensions, int extensionType, byte alertDescription);
    public static TlsSession ImportSession(Byte[] sessionID, SessionParameters sessionParameters);
    public static bool IsSignatureAlgorithmsExtensionAllowed(ProtocolVersion clientVersion);
    public static void AddSignatureAlgorithmsExtension(IDictionary extensions, IList supportedSignatureAlgorithms);
    public static IList GetSignatureAlgorithmsExtension(IDictionary extensions);
    public static Byte[] CreateSignatureAlgorithmsExtension(IList supportedSignatureAlgorithms);
    public static IList ReadSignatureAlgorithmsExtension(Byte[] extensionData);
    public static void EncodeSupportedSignatureAlgorithms(IList supportedSignatureAlgorithms, bool allowAnonymous, Stream output);
    public static IList ParseSupportedSignatureAlgorithms(bool allowAnonymous, Stream input);
    public static void VerifySupportedSignatureAlgorithm(IList supportedSignatureAlgorithms, SignatureAndHashAlgorithm signatureAlgorithm);
    public static Byte[] PRF(TlsContext context, Byte[] secret, string asciiLabel, Byte[] seed, int size);
    public static Byte[] PRF_legacy(Byte[] secret, string asciiLabel, Byte[] seed, int size);
    internal static Byte[] PRF_legacy(Byte[] secret, Byte[] label, Byte[] labelSeed, int size);
    internal static Byte[] Concat(Byte[] a, Byte[] b);
    internal static void HMacHash(IDigest digest, Byte[] secret, Byte[] seed, Byte[] output);
    internal static void ValidateKeyUsage(X509CertificateStructure c, int keyUsageBits);
    internal static Byte[] CalculateKeyBlock(TlsContext context, int size);
    internal static Byte[] CalculateKeyBlock_Ssl(Byte[] master_secret, Byte[] random, int size);
    internal static Byte[] CalculateMasterSecret(TlsContext context, Byte[] pre_master_secret);
    internal static Byte[] CalculateMasterSecret_Ssl(Byte[] pre_master_secret, Byte[] random);
    internal static Byte[] CalculateVerifyData(TlsContext context, string asciiLabel, Byte[] handshakeHash);
    public static IDigest CreateHash(byte hashAlgorithm);
    public static IDigest CreateHash(SignatureAndHashAlgorithm signatureAndHashAlgorithm);
    public static IDigest CloneHash(byte hashAlgorithm, IDigest hash);
    public static IDigest CreatePrfHash(int prfAlgorithm);
    public static IDigest ClonePrfHash(int prfAlgorithm, IDigest hash);
    public static byte GetHashAlgorithmForPrfAlgorithm(int prfAlgorithm);
    public static DerObjectIdentifier GetOidForHashAlgorithm(byte hashAlgorithm);
    internal static short GetClientCertificateType(Certificate clientCertificate, Certificate serverCertificate);
    internal static void TrackHashAlgorithms(TlsHandshakeHash handshakeHash, IList supportedSignatureAlgorithms);
    public static bool HasSigningCapability(byte clientCertificateType);
    public static TlsSigner CreateTlsSigner(byte clientCertificateType);
    private static Byte[][] GenSsl3Const();
    private static IList VectorOfOne(object obj);
    public static int GetCipherType(int ciphersuite);
    public static int GetEncryptionAlgorithm(int ciphersuite);
    public static int GetKeyExchangeAlgorithm(int ciphersuite);
    public static int GetMacAlgorithm(int ciphersuite);
    public static ProtocolVersion GetMinimumVersion(int ciphersuite);
    public static bool IsAeadCipherSuite(int ciphersuite);
    public static bool IsBlockCipherSuite(int ciphersuite);
    public static bool IsStreamCipherSuite(int ciphersuite);
    public static bool IsValidCipherSuiteForSignatureAlgorithms(int cipherSuite, IList sigAlgs);
    public static bool IsValidCipherSuiteForVersion(int cipherSuite, ProtocolVersion serverVersion);
    public static IList GetUsableSignatureAlgorithms(IList sigHashAlgs);
    public static bool IsTimeout(SocketException e);
}
public class Org.BouncyCastle.Crypto.Tls.UrlAndHash : object {
    protected string mUrl;
    protected Byte[] mSha1Hash;
    public string Url { get; }
    public Byte[] Sha1Hash { get; }
    public UrlAndHash(string url, Byte[] sha1Hash);
    public virtual string get_Url();
    public virtual Byte[] get_Sha1Hash();
    public virtual void Encode(Stream output);
    public static UrlAndHash Parse(TlsContext context, Stream input);
}
public abstract class Org.BouncyCastle.Crypto.Tls.UserMappingType : object {
    public static byte upn_domain_hint;
}
public class Org.BouncyCastle.Crypto.Tls.UseSrtpData : object {
    protected Int32[] mProtectionProfiles;
    protected Byte[] mMki;
    public Int32[] ProtectionProfiles { get; }
    public Byte[] Mki { get; }
    public UseSrtpData(Int32[] protectionProfiles, Byte[] mki);
    public virtual Int32[] get_ProtectionProfiles();
    public virtual Byte[] get_Mki();
}
public class Org.BouncyCastle.Crypto.Utilities.AlgorithmIdentifierFactory : object {
    public static DerObjectIdentifier IDEA_CBC;
    public static DerObjectIdentifier CAST5_CBC;
    private static Int16[] rc2Table;
    private static AlgorithmIdentifierFactory();
    public static AlgorithmIdentifier GenerateEncryptionAlgID(DerObjectIdentifier encryptionOID, int keySize, SecureRandom random);
}
public class Org.BouncyCastle.Crypto.Utilities.BasicAlphabetMapper : object {
    private IDictionary indexMap;
    private IDictionary charMap;
    public int Radix { get; }
    public BasicAlphabetMapper(string alphabet);
    public BasicAlphabetMapper(Char[] alphabet);
    public sealed virtual int get_Radix();
    public sealed virtual Byte[] ConvertToIndexes(Char[] input);
    public sealed virtual Char[] ConvertToChars(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Utilities.CipherFactory : object {
    private static Int16[] rc2Ekb;
    private static CipherFactory();
    public static object CreateContentCipher(bool forEncryption, ICipherParameters encKey, AlgorithmIdentifier encryptionAlgID);
    private static BufferedBlockCipher CreateCipher(DerObjectIdentifier algorithm);
}
public class Org.BouncyCastle.Crypto.Utilities.CipherKeyGeneratorFactory : object {
    public static CipherKeyGenerator CreateKeyGenerator(DerObjectIdentifier algorithm, SecureRandom random);
    private static CipherKeyGenerator CreateCipherKeyGenerator(SecureRandom random, int keySize);
}
internal class Org.BouncyCastle.Crypto.Utilities.Pack : object {
    internal static void UInt16_To_BE(ushort n, Byte[] bs);
    internal static void UInt16_To_BE(ushort n, Byte[] bs, int off);
    internal static void UInt16_To_BE(UInt16[] ns, Byte[] bs, int off);
    internal static void UInt16_To_BE(UInt16[] ns, int nsOff, int nsLen, Byte[] bs, int bsOff);
    internal static Byte[] UInt16_To_BE(ushort n);
    internal static Byte[] UInt16_To_BE(UInt16[] ns);
    internal static Byte[] UInt16_To_BE(UInt16[] ns, int nsOff, int nsLen);
    internal static ushort BE_To_UInt16(Byte[] bs, int off);
    internal static void BE_To_UInt16(Byte[] bs, int bsOff, UInt16[] ns, int nsOff);
    internal static UInt16[] BE_To_UInt16(Byte[] bs);
    internal static UInt16[] BE_To_UInt16(Byte[] bs, int off, int len);
    internal static void UInt32_To_BE(UInt32 n, Byte[] bs);
    internal static void UInt32_To_BE(UInt32 n, Byte[] bs, int off);
    internal static void UInt32_To_BE(UInt32[] ns, Byte[] bs, int off);
    internal static void UInt32_To_BE(UInt32[] ns, int nsOff, int nsLen, Byte[] bs, int bsOff);
    internal static Byte[] UInt32_To_BE(UInt32 n);
    internal static Byte[] UInt32_To_BE(UInt32[] ns);
    internal static UInt32 BE_To_UInt32(Byte[] bs);
    internal static UInt32 BE_To_UInt32(Byte[] bs, int off);
    internal static void BE_To_UInt32(Byte[] bs, int off, UInt32[] ns);
    internal static void BE_To_UInt32(Byte[] bs, int bsOff, UInt32[] ns, int nsOff, int nsLen);
    internal static Byte[] UInt64_To_BE(ulong n);
    internal static void UInt64_To_BE(ulong n, Byte[] bs);
    internal static void UInt64_To_BE(ulong n, Byte[] bs, int off);
    internal static Byte[] UInt64_To_BE(UInt64[] ns);
    internal static void UInt64_To_BE(UInt64[] ns, Byte[] bs, int off);
    internal static void UInt64_To_BE(UInt64[] ns, int nsOff, int nsLen, Byte[] bs, int bsOff);
    internal static ulong BE_To_UInt64(Byte[] bs, int off);
    internal static void BE_To_UInt64(Byte[] bs, int off, UInt64[] ns);
    internal static void BE_To_UInt64(Byte[] bs, int bsOff, UInt64[] ns, int nsOff, int nsLen);
    internal static void UInt16_To_LE(ushort n, Byte[] bs);
    internal static void UInt16_To_LE(ushort n, Byte[] bs, int off);
    internal static ushort LE_To_UInt16(Byte[] bs);
    internal static ushort LE_To_UInt16(Byte[] bs, int off);
    internal static Byte[] UInt32_To_LE(UInt32 n);
    internal static void UInt32_To_LE(UInt32 n, Byte[] bs);
    internal static void UInt32_To_LE(UInt32 n, Byte[] bs, int off);
    internal static Byte[] UInt32_To_LE(UInt32[] ns);
    internal static void UInt32_To_LE(UInt32[] ns, Byte[] bs, int off);
    internal static void UInt32_To_LE(UInt32[] ns, int nsOff, int nsLen, Byte[] bs, int bsOff);
    internal static UInt32 LE_To_UInt32(Byte[] bs);
    internal static UInt32 LE_To_UInt32(Byte[] bs, int off);
    internal static void LE_To_UInt32(Byte[] bs, int off, UInt32[] ns);
    internal static void LE_To_UInt32(Byte[] bs, int bOff, UInt32[] ns, int nOff, int count);
    internal static UInt32[] LE_To_UInt32(Byte[] bs, int off, int count);
    internal static Byte[] UInt64_To_LE(ulong n);
    internal static void UInt64_To_LE(ulong n, Byte[] bs);
    internal static void UInt64_To_LE(ulong n, Byte[] bs, int off);
    internal static Byte[] UInt64_To_LE(UInt64[] ns);
    internal static void UInt64_To_LE(UInt64[] ns, Byte[] bs, int off);
    internal static void UInt64_To_LE(UInt64[] ns, int nsOff, int nsLen, Byte[] bs, int bsOff);
    internal static ulong LE_To_UInt64(Byte[] bs);
    internal static ulong LE_To_UInt64(Byte[] bs, int off);
    internal static void LE_To_UInt64(Byte[] bs, int off, UInt64[] ns);
    internal static void LE_To_UInt64(Byte[] bs, int bsOff, UInt64[] ns, int nsOff, int nsLen);
}
public class Org.BouncyCastle.Math.BigInteger : object {
    internal static Int32[][] primeLists;
    internal static Int32[] primeProducts;
    private static long IMASK;
    private static ulong UIMASK;
    private static Int32[] ZeroMagnitude;
    private static Byte[] ZeroEncoding;
    private static BigInteger[] SMALL_CONSTANTS;
    public static BigInteger Zero;
    public static BigInteger One;
    public static BigInteger Two;
    public static BigInteger Three;
    public static BigInteger Four;
    public static BigInteger Ten;
    private static Byte[] BitLengthTable;
    private static int chunk2;
    private static int chunk8;
    private static int chunk10;
    private static int chunk16;
    private static BigInteger radix2;
    private static BigInteger radix2E;
    private static BigInteger radix8;
    private static BigInteger radix8E;
    private static BigInteger radix10;
    private static BigInteger radix10E;
    private static BigInteger radix16;
    private static BigInteger radix16E;
    private static SecureRandom RandomSource;
    private static Int32[] ExpWindowThresholds;
    private static int BitsPerByte;
    private static int BitsPerInt;
    private static int BytesPerInt;
    private Int32[] magnitude;
    private int sign;
    private int nBits;
    private int nBitLength;
    private int mQuote;
    public int BitCount { get; }
    public int BitLength { get; }
    public int IntValue { get; }
    public int IntValueExact { get; }
    public long LongValue { get; }
    public long LongValueExact { get; }
    public int SignValue { get; }
    private static BigInteger();
    private BigInteger(int signum, Int32[] mag, bool checkMag);
    public BigInteger(string value);
    public BigInteger(string str, int radix);
    public BigInteger(Byte[] bytes);
    public BigInteger(Byte[] bytes, int offset, int length);
    public BigInteger(int sign, Byte[] bytes);
    public BigInteger(int sign, Byte[] bytes, int offset, int length);
    public BigInteger(int sizeInBits, Random random);
    public BigInteger(int bitLength, int certainty, Random random);
    private static int GetByteLength(int nBits);
    public static BigInteger Arbitrary(int sizeInBits);
    private static Int32[] MakeMagnitude(Byte[] bytes, int offset, int length);
    public BigInteger Abs();
    private static Int32[] AddMagnitudes(Int32[] a, Int32[] b);
    public BigInteger Add(BigInteger value);
    private BigInteger AddToMagnitude(Int32[] magToAdd);
    public BigInteger And(BigInteger value);
    public BigInteger AndNot(BigInteger val);
    public int get_BitCount();
    public static int BitCnt(int i);
    private static int CalcBitLength(int sign, int indx, Int32[] mag);
    public int get_BitLength();
    internal static int BitLen(int w);
    private bool QuickPow2Check();
    public int CompareTo(object obj);
    private static int CompareTo(int xIndx, Int32[] x, int yIndx, Int32[] y);
    private static int CompareNoLeadingZeroes(int xIndx, Int32[] x, int yIndx, Int32[] y);
    public int CompareTo(BigInteger value);
    private Int32[] Divide(Int32[] x, Int32[] y);
    public BigInteger Divide(BigInteger val);
    public BigInteger[] DivideAndRemainder(BigInteger val);
    public virtual bool Equals(object obj);
    private bool IsEqualMagnitude(BigInteger x);
    public BigInteger Gcd(BigInteger value);
    public virtual int GetHashCode();
    private BigInteger Inc();
    public int get_IntValue();
    public int get_IntValueExact();
    public bool IsProbablePrime(int certainty);
    internal bool IsProbablePrime(int certainty, bool randomlySelected);
    private bool CheckProbablePrime(int certainty, Random random, bool randomlySelected);
    public bool RabinMillerTest(int certainty, Random random);
    internal bool RabinMillerTest(int certainty, Random random, bool randomlySelected);
    public long get_LongValue();
    public long get_LongValueExact();
    public BigInteger Max(BigInteger value);
    public BigInteger Min(BigInteger value);
    public BigInteger Mod(BigInteger m);
    public BigInteger ModInverse(BigInteger m);
    private BigInteger ModInversePow2(BigInteger m);
    private static int ModInverse32(int d);
    private static long ModInverse64(long d);
    private static BigInteger ExtEuclid(BigInteger a, BigInteger b, BigInteger& u1Out);
    private static void ZeroOut(Int32[] x);
    public BigInteger ModPow(BigInteger e, BigInteger m);
    private static BigInteger ModPowBarrett(BigInteger b, BigInteger e, BigInteger m);
    private static BigInteger ReduceBarrett(BigInteger x, BigInteger m, BigInteger mr, BigInteger yu);
    private static BigInteger ModPowMonty(BigInteger b, BigInteger e, BigInteger m, bool convert);
    private static Int32[] GetWindowList(Int32[] mag, int extraBits);
    private static int CreateWindowEntry(int mult, int zeroes);
    private static Int32[] Square(Int32[] w, Int32[] x);
    private static Int32[] Multiply(Int32[] x, Int32[] y, Int32[] z);
    private int GetMQuote();
    private static void MontgomeryReduce(Int32[] x, Int32[] m, UInt32 mDash);
    private static void MultiplyMonty(Int32[] a, Int32[] x, Int32[] y, Int32[] m, UInt32 mDash, bool smallMontyModulus);
    private static void SquareMonty(Int32[] a, Int32[] x, Int32[] m, UInt32 mDash, bool smallMontyModulus);
    private static UInt32 MultiplyMontyNIsOne(UInt32 x, UInt32 y, UInt32 m, UInt32 mDash);
    public BigInteger Multiply(BigInteger val);
    public BigInteger Square();
    public BigInteger Negate();
    public BigInteger NextProbablePrime();
    public BigInteger Not();
    public BigInteger Pow(int exp);
    public static BigInteger ProbablePrime(int bitLength, Random random);
    private int Remainder(int m);
    private static Int32[] Remainder(Int32[] x, Int32[] y);
    public BigInteger Remainder(BigInteger n);
    private Int32[] LastNBits(int n);
    private BigInteger DivideWords(int w);
    private BigInteger RemainderWords(int w);
    private static Int32[] ShiftLeft(Int32[] mag, int n);
    private static int ShiftLeftOneInPlace(Int32[] x, int carry);
    public BigInteger ShiftLeft(int n);
    private static void ShiftRightInPlace(int start, Int32[] mag, int n);
    private static void ShiftRightOneInPlace(int start, Int32[] mag);
    public BigInteger ShiftRight(int n);
    public int get_SignValue();
    private static Int32[] Subtract(int xStart, Int32[] x, int yStart, Int32[] y);
    public BigInteger Subtract(BigInteger n);
    private static Int32[] doSubBigLil(Int32[] bigMag, Int32[] lilMag);
    public Byte[] ToByteArray();
    public Byte[] ToByteArrayUnsigned();
    private Byte[] ToByteArray(bool unsigned);
    public virtual string ToString();
    public string ToString(int radix);
    private static void ToString(StringBuilder sb, int radix, IList moduli, int scale, BigInteger pos);
    private static void AppendZeroExtendedString(StringBuilder sb, string s, int minLength);
    private static BigInteger CreateUValueOf(ulong value);
    private static BigInteger CreateValueOf(long value);
    public static BigInteger ValueOf(long value);
    public int GetLowestSetBit();
    private int GetLowestSetBitMaskFirst(int firstWordMask);
    public bool TestBit(int n);
    public BigInteger Or(BigInteger value);
    public BigInteger Xor(BigInteger value);
    public BigInteger SetBit(int n);
    public BigInteger ClearBit(int n);
    public BigInteger FlipBit(int n);
    private BigInteger FlipExistingBit(int n);
}
internal class Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal : object {
    private BigInteger bigInt;
    private int scale;
    public int IntValue { get; }
    public long LongValue { get; }
    public int Scale { get; }
    public SimpleBigDecimal(BigInteger bigInt, int scale);
    private SimpleBigDecimal(SimpleBigDecimal limBigDec);
    public static SimpleBigDecimal GetInstance(BigInteger val, int scale);
    private void CheckScale(SimpleBigDecimal b);
    public SimpleBigDecimal AdjustScale(int newScale);
    public SimpleBigDecimal Add(SimpleBigDecimal b);
    public SimpleBigDecimal Add(BigInteger b);
    public SimpleBigDecimal Negate();
    public SimpleBigDecimal Subtract(SimpleBigDecimal b);
    public SimpleBigDecimal Subtract(BigInteger b);
    public SimpleBigDecimal Multiply(SimpleBigDecimal b);
    public SimpleBigDecimal Multiply(BigInteger b);
    public SimpleBigDecimal Divide(SimpleBigDecimal b);
    public SimpleBigDecimal Divide(BigInteger b);
    public SimpleBigDecimal ShiftLeft(int n);
    public int CompareTo(SimpleBigDecimal val);
    public int CompareTo(BigInteger val);
    public BigInteger Floor();
    public BigInteger Round();
    public int get_IntValue();
    public long get_LongValue();
    public int get_Scale();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Abc.Tnaf : object {
    private static BigInteger MinusOne;
    private static BigInteger MinusTwo;
    private static BigInteger MinusThree;
    private static BigInteger Four;
    public static sbyte Width;
    public static sbyte Pow2Width;
    public static ZTauElement[] Alpha0;
    public static SByte[][] Alpha0Tnaf;
    public static ZTauElement[] Alpha1;
    public static SByte[][] Alpha1Tnaf;
    private static Tnaf();
    public static BigInteger Norm(sbyte mu, ZTauElement lambda);
    public static SimpleBigDecimal Norm(sbyte mu, SimpleBigDecimal u, SimpleBigDecimal v);
    public static ZTauElement Round(SimpleBigDecimal lambda0, SimpleBigDecimal lambda1, sbyte mu);
    public static SimpleBigDecimal ApproximateDivisionByN(BigInteger k, BigInteger s, BigInteger vm, sbyte a, int m, int c);
    public static SByte[] TauAdicNaf(sbyte mu, ZTauElement lambda);
    public static AbstractF2mPoint Tau(AbstractF2mPoint p);
    public static sbyte GetMu(AbstractF2mCurve curve);
    public static sbyte GetMu(ECFieldElement curveA);
    public static sbyte GetMu(int curveA);
    public static BigInteger[] GetLucas(sbyte mu, int k, bool doV);
    public static BigInteger GetTw(sbyte mu, int w);
    public static BigInteger[] GetSi(AbstractF2mCurve curve);
    public static BigInteger[] GetSi(int fieldSize, int curveA, BigInteger cofactor);
    protected static int GetShiftsForCofactor(BigInteger h);
    public static ZTauElement PartModReduction(BigInteger k, int m, sbyte a, BigInteger[] s, sbyte mu, sbyte c);
    public static AbstractF2mPoint MultiplyRTnaf(AbstractF2mPoint p, BigInteger k);
    public static AbstractF2mPoint MultiplyTnaf(AbstractF2mPoint p, ZTauElement lambda);
    public static AbstractF2mPoint MultiplyFromTnaf(AbstractF2mPoint p, SByte[] u);
    public static SByte[] TauAdicWNaf(sbyte mu, ZTauElement lambda, sbyte width, BigInteger pow2w, BigInteger tw, ZTauElement[] alpha);
    public static AbstractF2mPoint[] GetPreComp(AbstractF2mPoint p, sbyte a);
}
internal class Org.BouncyCastle.Math.EC.Abc.ZTauElement : object {
    public BigInteger u;
    public BigInteger v;
    public ZTauElement(BigInteger u, BigInteger v);
}
public abstract class Org.BouncyCastle.Math.EC.AbstractECLookupTable : object {
    public int Size { get; }
    public abstract virtual ECPoint Lookup(int index);
    public abstract virtual int get_Size();
    public virtual ECPoint LookupVar(int index);
}
public abstract class Org.BouncyCastle.Math.EC.AbstractF2mCurve : ECCurve {
    private BigInteger[] si;
    public bool IsKoblitz { get; }
    protected AbstractF2mCurve(int m, int k1, int k2, int k3);
    public static BigInteger Inverse(int m, Int32[] ks, BigInteger x);
    private static IFiniteField BuildField(int m, int k1, int k2, int k3);
    [ObsoleteAttribute("Per-point compression property will be removed")]
public virtual ECPoint CreatePoint(BigInteger x, BigInteger y, bool withCompression);
    public virtual bool IsValidFieldElement(BigInteger x);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
    protected virtual ECPoint DecompressPoint(int yTilde, BigInteger X1);
    internal ECFieldElement SolveQuadraticEquation(ECFieldElement beta);
    internal virtual BigInteger[] GetSi();
    public virtual bool get_IsKoblitz();
    private static BigInteger ImplRandomFieldElementMult(SecureRandom r, int m);
}
public abstract class Org.BouncyCastle.Math.EC.AbstractF2mFieldElement : ECFieldElement {
    public bool HasFastTrace { get; }
    public virtual ECFieldElement HalfTrace();
    public virtual bool get_HasFastTrace();
    public virtual int Trace();
}
public abstract class Org.BouncyCastle.Math.EC.AbstractF2mPoint : ECPointBase {
    protected AbstractF2mPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    protected AbstractF2mPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual bool SatisfiesCurveEquation();
    protected virtual bool SatisfiesOrder();
    public virtual ECPoint ScaleX(ECFieldElement scale);
    public virtual ECPoint ScaleXNegateY(ECFieldElement scale);
    public virtual ECPoint ScaleY(ECFieldElement scale);
    public virtual ECPoint ScaleYNegateX(ECFieldElement scale);
    public virtual ECPoint Subtract(ECPoint b);
    public virtual AbstractF2mPoint Tau();
    public virtual AbstractF2mPoint TauPow(int pow);
}
public abstract class Org.BouncyCastle.Math.EC.AbstractFpCurve : ECCurve {
    protected AbstractFpCurve(BigInteger q);
    public virtual bool IsValidFieldElement(BigInteger x);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
    protected virtual ECPoint DecompressPoint(int yTilde, BigInteger X1);
    private static BigInteger ImplRandomFieldElement(SecureRandom r, BigInteger p);
    private static BigInteger ImplRandomFieldElementMult(SecureRandom r, BigInteger p);
}
public abstract class Org.BouncyCastle.Math.EC.AbstractFpFieldElement : ECFieldElement {
}
public abstract class Org.BouncyCastle.Math.EC.AbstractFpPoint : ECPointBase {
    protected internal bool CompressionYTilde { get; }
    protected AbstractFpPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    protected AbstractFpPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected internal virtual bool get_CompressionYTilde();
    protected virtual bool SatisfiesCurveEquation();
    public virtual ECPoint Subtract(ECPoint b);
}
internal class Org.BouncyCastle.Math.EC.Custom.Djb.Curve25519 : AbstractFpCurve {
    public static BigInteger q;
    private static BigInteger C_a;
    private static BigInteger C_b;
    private static int CURVE25519_DEFAULT_COORDS;
    private static int CURVE25519_FE_INTS;
    private static ECFieldElement[] CURVE25519_AFFINE_ZS;
    protected Curve25519Point m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static Curve25519();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
}
internal class Org.BouncyCastle.Math.EC.Custom.Djb.Curve25519Field : object {
    internal static UInt32[] P;
    private static UInt32 P7;
    private static UInt32[] PExt;
    private static UInt32 PInv;
    private static Curve25519Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void AddOne(UInt32[] x, UInt32[] z);
    public static UInt32[] FromBigInteger(BigInteger x);
    public static void Half(UInt32[] x, UInt32[] z);
    public static void Inv(UInt32[] x, UInt32[] z);
    public static int IsZero(UInt32[] x);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void MultiplyAddToExt(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Random(SecureRandom r, UInt32[] z);
    public static void RandomMult(SecureRandom r, UInt32[] z);
    public static void Reduce(UInt32[] xx, UInt32[] z);
    public static void Reduce27(UInt32 x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z);
    public static void SquareN(UInt32[] x, int n, UInt32[] z);
    public static void Subtract(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void SubtractExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void Twice(UInt32[] x, UInt32[] z);
    private static UInt32 AddPTo(UInt32[] z);
    private static UInt32 AddPExtTo(UInt32[] zz);
    private static int SubPFrom(UInt32[] z);
    private static int SubPExtFrom(UInt32[] zz);
}
internal class Org.BouncyCastle.Math.EC.Custom.Djb.Curve25519FieldElement : AbstractFpFieldElement {
    public static BigInteger Q;
    private static UInt32[] PRECOMP_POW2;
    protected internal UInt32[] x;
    public bool IsZero { get; }
    public bool IsOne { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public Curve25519FieldElement(BigInteger x);
    protected internal Curve25519FieldElement(UInt32[] x);
    private static Curve25519FieldElement();
    public virtual bool get_IsZero();
    public virtual bool get_IsOne();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(Curve25519FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Djb.Curve25519Point : AbstractFpPoint {
    public Curve25519Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public Curve25519Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal Curve25519Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement GetZCoord(int index);
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
    protected virtual Curve25519FieldElement CalculateJacobianModifiedW(Curve25519FieldElement Z, UInt32[] ZSquared);
    protected virtual Curve25519FieldElement GetJacobianModifiedW();
    protected virtual Curve25519Point TwiceJacobianModified(bool calculateW);
}
internal class Org.BouncyCastle.Math.EC.Custom.GM.SM2P256V1Curve : AbstractFpCurve {
    public static BigInteger q;
    private static int SM2P256V1_DEFAULT_COORDS;
    private static int SM2P256V1_FE_INTS;
    private static ECFieldElement[] SM2P256V1_AFFINE_ZS;
    protected SM2P256V1Point m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static SM2P256V1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
}
internal class Org.BouncyCastle.Math.EC.Custom.GM.SM2P256V1Field : object {
    internal static UInt32[] P;
    private static UInt32[] PExt;
    private static UInt32 P7;
    private static UInt32 PExt15;
    private static SM2P256V1Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void AddOne(UInt32[] x, UInt32[] z);
    public static UInt32[] FromBigInteger(BigInteger x);
    public static void Inv(UInt32[] x, UInt32[] z);
    public static void Half(UInt32[] x, UInt32[] z);
    public static int IsZero(UInt32[] x);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void MultiplyAddToExt(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Random(SecureRandom r, UInt32[] z);
    public static void RandomMult(SecureRandom r, UInt32[] z);
    public static void Reduce(UInt32[] xx, UInt32[] z);
    public static void Reduce32(UInt32 x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z);
    public static void SquareN(UInt32[] x, int n, UInt32[] z);
    public static void Subtract(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void SubtractExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void Twice(UInt32[] x, UInt32[] z);
    private static void AddPInvTo(UInt32[] z);
    private static void SubPInvFrom(UInt32[] z);
}
internal class Org.BouncyCastle.Math.EC.Custom.GM.SM2P256V1FieldElement : AbstractFpFieldElement {
    public static BigInteger Q;
    protected internal UInt32[] x;
    public bool IsZero { get; }
    public bool IsOne { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public SM2P256V1FieldElement(BigInteger x);
    protected internal SM2P256V1FieldElement(UInt32[] x);
    private static SM2P256V1FieldElement();
    public virtual bool get_IsZero();
    public virtual bool get_IsOne();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SM2P256V1FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.GM.SM2P256V1Point : AbstractFpPoint {
    public SM2P256V1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SM2P256V1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SM2P256V1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP128R1Curve : AbstractFpCurve {
    public static BigInteger q;
    private static int SECP128R1_DEFAULT_COORDS;
    private static int SECP128R1_FE_INTS;
    private static ECFieldElement[] SECP128R1_AFFINE_ZS;
    protected SecP128R1Point m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static SecP128R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP128R1Field : object {
    internal static UInt32[] P;
    private static UInt32[] PExt;
    private static UInt32[] PExtInv;
    private static UInt32 P3;
    private static UInt32 PExt7;
    private static SecP128R1Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void AddOne(UInt32[] x, UInt32[] z);
    public static UInt32[] FromBigInteger(BigInteger x);
    public static void Half(UInt32[] x, UInt32[] z);
    public static void Inv(UInt32[] x, UInt32[] z);
    public static int IsZero(UInt32[] x);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void MultiplyAddToExt(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Random(SecureRandom r, UInt32[] z);
    public static void RandomMult(SecureRandom r, UInt32[] z);
    public static void Reduce(UInt32[] xx, UInt32[] z);
    public static void Reduce32(UInt32 x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z);
    public static void SquareN(UInt32[] x, int n, UInt32[] z);
    public static void Subtract(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void SubtractExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void Twice(UInt32[] x, UInt32[] z);
    private static void AddPInvTo(UInt32[] z);
    private static void SubPInvFrom(UInt32[] z);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP128R1FieldElement : AbstractFpFieldElement {
    public static BigInteger Q;
    protected internal UInt32[] x;
    public bool IsZero { get; }
    public bool IsOne { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public SecP128R1FieldElement(BigInteger x);
    protected internal SecP128R1FieldElement(UInt32[] x);
    private static SecP128R1FieldElement();
    public virtual bool get_IsZero();
    public virtual bool get_IsOne();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecP128R1FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP128R1Point : AbstractFpPoint {
    public SecP128R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecP128R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecP128R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP160K1Curve : AbstractFpCurve {
    public static BigInteger q;
    private static int SECP160K1_DEFAULT_COORDS;
    private static int SECP160K1_FE_INTS;
    private static ECFieldElement[] SECP160K1_AFFINE_ZS;
    protected SecP160K1Point m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static SecP160K1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP160K1Point : AbstractFpPoint {
    public SecP160K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecP160K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecP160K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R1Curve : AbstractFpCurve {
    public static BigInteger q;
    private static int SECP160R1_DEFAULT_COORDS;
    private static int SECP160R1_FE_INTS;
    private static ECFieldElement[] SECP160R1_AFFINE_ZS;
    protected SecP160R1Point m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static SecP160R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R1Field : object {
    internal static UInt32[] P;
    private static UInt32[] PExt;
    private static UInt32[] PExtInv;
    private static UInt32 P4;
    private static UInt32 PExt9;
    private static UInt32 PInv;
    private static SecP160R1Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void AddOne(UInt32[] x, UInt32[] z);
    public static UInt32[] FromBigInteger(BigInteger x);
    public static void Half(UInt32[] x, UInt32[] z);
    public static void Inv(UInt32[] x, UInt32[] z);
    public static int IsZero(UInt32[] x);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void MultiplyAddToExt(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Random(SecureRandom r, UInt32[] z);
    public static void RandomMult(SecureRandom r, UInt32[] z);
    public static void Reduce(UInt32[] xx, UInt32[] z);
    public static void Reduce32(UInt32 x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z);
    public static void SquareN(UInt32[] x, int n, UInt32[] z);
    public static void Subtract(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void SubtractExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void Twice(UInt32[] x, UInt32[] z);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R1FieldElement : AbstractFpFieldElement {
    public static BigInteger Q;
    protected internal UInt32[] x;
    public bool IsZero { get; }
    public bool IsOne { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public SecP160R1FieldElement(BigInteger x);
    protected internal SecP160R1FieldElement(UInt32[] x);
    private static SecP160R1FieldElement();
    public virtual bool get_IsZero();
    public virtual bool get_IsOne();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecP160R1FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R1Point : AbstractFpPoint {
    public SecP160R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecP160R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecP160R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R2Curve : AbstractFpCurve {
    public static BigInteger q;
    private static int SECP160R2_DEFAULT_COORDS;
    private static int SECP160R2_FE_INTS;
    private static ECFieldElement[] SECP160R2_AFFINE_ZS;
    protected SecP160R2Point m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static SecP160R2Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R2Field : object {
    internal static UInt32[] P;
    private static UInt32[] PExt;
    private static UInt32[] PExtInv;
    private static UInt32 P4;
    private static UInt32 PExt9;
    private static UInt32 PInv33;
    private static SecP160R2Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void AddOne(UInt32[] x, UInt32[] z);
    public static UInt32[] FromBigInteger(BigInteger x);
    public static void Half(UInt32[] x, UInt32[] z);
    public static void Inv(UInt32[] x, UInt32[] z);
    public static int IsZero(UInt32[] x);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void MultiplyAddToExt(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Random(SecureRandom r, UInt32[] z);
    public static void RandomMult(SecureRandom r, UInt32[] z);
    public static void Reduce(UInt32[] xx, UInt32[] z);
    public static void Reduce32(UInt32 x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z);
    public static void SquareN(UInt32[] x, int n, UInt32[] z);
    public static void Subtract(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void SubtractExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void Twice(UInt32[] x, UInt32[] z);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R2FieldElement : AbstractFpFieldElement {
    public static BigInteger Q;
    protected internal UInt32[] x;
    public bool IsZero { get; }
    public bool IsOne { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public SecP160R2FieldElement(BigInteger x);
    protected internal SecP160R2FieldElement(UInt32[] x);
    private static SecP160R2FieldElement();
    public virtual bool get_IsZero();
    public virtual bool get_IsOne();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecP160R2FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R2Point : AbstractFpPoint {
    public SecP160R2Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecP160R2Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecP160R2Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP192K1Curve : AbstractFpCurve {
    public static BigInteger q;
    private static int SECP192K1_DEFAULT_COORDS;
    private static int SECP192K1_FE_INTS;
    private static ECFieldElement[] SECP192K1_AFFINE_ZS;
    protected SecP192K1Point m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static SecP192K1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP192K1Field : object {
    internal static UInt32[] P;
    private static UInt32[] PExt;
    private static UInt32[] PExtInv;
    private static UInt32 P5;
    private static UInt32 PExt11;
    private static UInt32 PInv33;
    private static SecP192K1Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void AddOne(UInt32[] x, UInt32[] z);
    public static UInt32[] FromBigInteger(BigInteger x);
    public static void Half(UInt32[] x, UInt32[] z);
    public static void Inv(UInt32[] x, UInt32[] z);
    public static int IsZero(UInt32[] x);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void MultiplyAddToExt(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Random(SecureRandom r, UInt32[] z);
    public static void RandomMult(SecureRandom r, UInt32[] z);
    public static void Reduce(UInt32[] xx, UInt32[] z);
    public static void Reduce32(UInt32 x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z);
    public static void SquareN(UInt32[] x, int n, UInt32[] z);
    public static void Subtract(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void SubtractExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void Twice(UInt32[] x, UInt32[] z);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP192K1FieldElement : AbstractFpFieldElement {
    public static BigInteger Q;
    protected internal UInt32[] x;
    public bool IsZero { get; }
    public bool IsOne { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public SecP192K1FieldElement(BigInteger x);
    protected internal SecP192K1FieldElement(UInt32[] x);
    private static SecP192K1FieldElement();
    public virtual bool get_IsZero();
    public virtual bool get_IsOne();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecP192K1FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP192K1Point : AbstractFpPoint {
    public SecP192K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecP192K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecP192K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP192R1Curve : AbstractFpCurve {
    public static BigInteger q;
    private static int SECP192R1_DEFAULT_COORDS;
    private static int SECP192R1_FE_INTS;
    private static ECFieldElement[] SECP192R1_AFFINE_ZS;
    protected SecP192R1Point m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static SecP192R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP192R1Field : object {
    internal static UInt32[] P;
    private static UInt32[] PExt;
    private static UInt32[] PExtInv;
    private static UInt32 P5;
    private static UInt32 PExt11;
    private static SecP192R1Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void AddOne(UInt32[] x, UInt32[] z);
    public static UInt32[] FromBigInteger(BigInteger x);
    public static void Half(UInt32[] x, UInt32[] z);
    public static void Inv(UInt32[] x, UInt32[] z);
    public static int IsZero(UInt32[] x);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void MultiplyAddToExt(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Random(SecureRandom r, UInt32[] z);
    public static void RandomMult(SecureRandom r, UInt32[] z);
    public static void Reduce(UInt32[] xx, UInt32[] z);
    public static void Reduce32(UInt32 x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z);
    public static void SquareN(UInt32[] x, int n, UInt32[] z);
    public static void Subtract(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void SubtractExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void Twice(UInt32[] x, UInt32[] z);
    private static void AddPInvTo(UInt32[] z);
    private static void SubPInvFrom(UInt32[] z);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP192R1FieldElement : AbstractFpFieldElement {
    public static BigInteger Q;
    protected internal UInt32[] x;
    public bool IsZero { get; }
    public bool IsOne { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public SecP192R1FieldElement(BigInteger x);
    protected internal SecP192R1FieldElement(UInt32[] x);
    private static SecP192R1FieldElement();
    public virtual bool get_IsZero();
    public virtual bool get_IsOne();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecP192R1FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP192R1Point : AbstractFpPoint {
    public SecP192R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecP192R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecP192R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP224K1Curve : AbstractFpCurve {
    public static BigInteger q;
    private static int SECP224K1_DEFAULT_COORDS;
    private static int SECP224K1_FE_INTS;
    private static ECFieldElement[] SECP224K1_AFFINE_ZS;
    protected SecP224K1Point m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static SecP224K1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP224K1Field : object {
    internal static UInt32[] P;
    private static UInt32[] PExt;
    private static UInt32[] PExtInv;
    private static UInt32 P6;
    private static UInt32 PExt13;
    private static UInt32 PInv33;
    private static SecP224K1Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void AddOne(UInt32[] x, UInt32[] z);
    public static UInt32[] FromBigInteger(BigInteger x);
    public static void Half(UInt32[] x, UInt32[] z);
    public static void Inv(UInt32[] x, UInt32[] z);
    public static int IsZero(UInt32[] x);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void MultiplyAddToExt(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Random(SecureRandom r, UInt32[] z);
    public static void RandomMult(SecureRandom r, UInt32[] z);
    public static void Reduce(UInt32[] xx, UInt32[] z);
    public static void Reduce32(UInt32 x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z);
    public static void SquareN(UInt32[] x, int n, UInt32[] z);
    public static void Subtract(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void SubtractExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void Twice(UInt32[] x, UInt32[] z);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP224K1FieldElement : AbstractFpFieldElement {
    public static BigInteger Q;
    private static UInt32[] PRECOMP_POW2;
    protected internal UInt32[] x;
    public bool IsZero { get; }
    public bool IsOne { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public SecP224K1FieldElement(BigInteger x);
    protected internal SecP224K1FieldElement(UInt32[] x);
    private static SecP224K1FieldElement();
    public virtual bool get_IsZero();
    public virtual bool get_IsOne();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecP224K1FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP224K1Point : AbstractFpPoint {
    public SecP224K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecP224K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecP224K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP224R1Curve : AbstractFpCurve {
    public static BigInteger q;
    private static int SECP224R1_DEFAULT_COORDS;
    private static int SECP224R1_FE_INTS;
    private static ECFieldElement[] SECP224R1_AFFINE_ZS;
    protected SecP224R1Point m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static SecP224R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP224R1Field : object {
    internal static UInt32[] P;
    private static UInt32[] PExt;
    private static UInt32[] PExtInv;
    private static UInt32 P6;
    private static UInt32 PExt13;
    private static SecP224R1Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void AddOne(UInt32[] x, UInt32[] z);
    public static UInt32[] FromBigInteger(BigInteger x);
    public static void Half(UInt32[] x, UInt32[] z);
    public static void Inv(UInt32[] x, UInt32[] z);
    public static int IsZero(UInt32[] x);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void MultiplyAddToExt(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Random(SecureRandom r, UInt32[] z);
    public static void RandomMult(SecureRandom r, UInt32[] z);
    public static void Reduce(UInt32[] xx, UInt32[] z);
    public static void Reduce32(UInt32 x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z);
    public static void SquareN(UInt32[] x, int n, UInt32[] z);
    public static void Subtract(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void SubtractExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void Twice(UInt32[] x, UInt32[] z);
    private static void AddPInvTo(UInt32[] z);
    private static void SubPInvFrom(UInt32[] z);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP224R1FieldElement : AbstractFpFieldElement {
    public static BigInteger Q;
    protected internal UInt32[] x;
    public bool IsZero { get; }
    public bool IsOne { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public SecP224R1FieldElement(BigInteger x);
    protected internal SecP224R1FieldElement(UInt32[] x);
    private static SecP224R1FieldElement();
    public virtual bool get_IsZero();
    public virtual bool get_IsOne();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecP224R1FieldElement other);
    public virtual int GetHashCode();
    private static bool IsSquare(UInt32[] x);
    private static void RM(UInt32[] nc, UInt32[] d0, UInt32[] e0, UInt32[] d1, UInt32[] e1, UInt32[] f1, UInt32[] t);
    private static void RP(UInt32[] nc, UInt32[] d1, UInt32[] e1, UInt32[] f1, UInt32[] t);
    private static void RS(UInt32[] d, UInt32[] e, UInt32[] f, UInt32[] t);
    private static bool TrySqrt(UInt32[] nc, UInt32[] r, UInt32[] t);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP224R1Point : AbstractFpPoint {
    public SecP224R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecP224R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecP224R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP256K1Curve : AbstractFpCurve {
    public static BigInteger q;
    private static int SECP256K1_DEFAULT_COORDS;
    private static int SECP256K1_FE_INTS;
    private static ECFieldElement[] SECP256K1_AFFINE_ZS;
    protected SecP256K1Point m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static SecP256K1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP256K1Field : object {
    internal static UInt32[] P;
    private static UInt32[] PExt;
    private static UInt32[] PExtInv;
    private static UInt32 P7;
    private static UInt32 PExt15;
    private static UInt32 PInv33;
    private static SecP256K1Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void AddOne(UInt32[] x, UInt32[] z);
    public static UInt32[] FromBigInteger(BigInteger x);
    public static void Half(UInt32[] x, UInt32[] z);
    public static void Inv(UInt32[] x, UInt32[] z);
    public static int IsZero(UInt32[] x);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void MultiplyAddToExt(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Random(SecureRandom r, UInt32[] z);
    public static void RandomMult(SecureRandom r, UInt32[] z);
    public static void Reduce(UInt32[] xx, UInt32[] z);
    public static void Reduce32(UInt32 x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z);
    public static void SquareN(UInt32[] x, int n, UInt32[] z);
    public static void Subtract(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void SubtractExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void Twice(UInt32[] x, UInt32[] z);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP256K1FieldElement : AbstractFpFieldElement {
    public static BigInteger Q;
    protected internal UInt32[] x;
    public bool IsZero { get; }
    public bool IsOne { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public SecP256K1FieldElement(BigInteger x);
    protected internal SecP256K1FieldElement(UInt32[] x);
    private static SecP256K1FieldElement();
    public virtual bool get_IsZero();
    public virtual bool get_IsOne();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecP256K1FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP256K1Point : AbstractFpPoint {
    public SecP256K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecP256K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecP256K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP256R1Curve : AbstractFpCurve {
    public static BigInteger q;
    private static int SECP256R1_DEFAULT_COORDS;
    private static int SECP256R1_FE_INTS;
    private static ECFieldElement[] SECP256R1_AFFINE_ZS;
    protected SecP256R1Point m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static SecP256R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP256R1Field : object {
    internal static UInt32[] P;
    private static UInt32[] PExt;
    private static UInt32 P7;
    private static UInt32 PExt15;
    private static SecP256R1Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void AddOne(UInt32[] x, UInt32[] z);
    public static UInt32[] FromBigInteger(BigInteger x);
    public static void Half(UInt32[] x, UInt32[] z);
    public static void Inv(UInt32[] x, UInt32[] z);
    public static int IsZero(UInt32[] x);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void MultiplyAddToExt(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Random(SecureRandom r, UInt32[] z);
    public static void RandomMult(SecureRandom r, UInt32[] z);
    public static void Reduce(UInt32[] xx, UInt32[] z);
    public static void Reduce32(UInt32 x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z);
    public static void SquareN(UInt32[] x, int n, UInt32[] z);
    public static void Subtract(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void SubtractExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void Twice(UInt32[] x, UInt32[] z);
    private static void AddPInvTo(UInt32[] z);
    private static void SubPInvFrom(UInt32[] z);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP256R1FieldElement : AbstractFpFieldElement {
    public static BigInteger Q;
    protected internal UInt32[] x;
    public bool IsZero { get; }
    public bool IsOne { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public SecP256R1FieldElement(BigInteger x);
    protected internal SecP256R1FieldElement(UInt32[] x);
    private static SecP256R1FieldElement();
    public virtual bool get_IsZero();
    public virtual bool get_IsOne();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecP256R1FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP256R1Point : AbstractFpPoint {
    public SecP256R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecP256R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecP256R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP384R1Curve : AbstractFpCurve {
    public static BigInteger q;
    private static int SECP384R1_DEFAULT_COORDS;
    private static int SECP384R1_FE_INTS;
    private static ECFieldElement[] SECP384R1_AFFINE_ZS;
    protected SecP384R1Point m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static SecP384R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP384R1Field : object {
    internal static UInt32[] P;
    private static UInt32[] PExt;
    private static UInt32[] PExtInv;
    private static UInt32 P11;
    private static UInt32 PExt23;
    private static SecP384R1Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void AddOne(UInt32[] x, UInt32[] z);
    public static UInt32[] FromBigInteger(BigInteger x);
    public static void Half(UInt32[] x, UInt32[] z);
    public static void Inv(UInt32[] x, UInt32[] z);
    public static int IsZero(UInt32[] x);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Random(SecureRandom r, UInt32[] z);
    public static void RandomMult(SecureRandom r, UInt32[] z);
    public static void Reduce(UInt32[] xx, UInt32[] z);
    public static void Reduce32(UInt32 x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z);
    public static void SquareN(UInt32[] x, int n, UInt32[] z);
    public static void Subtract(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void SubtractExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void Twice(UInt32[] x, UInt32[] z);
    private static void AddPInvTo(UInt32[] z);
    private static void SubPInvFrom(UInt32[] z);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP384R1FieldElement : AbstractFpFieldElement {
    public static BigInteger Q;
    protected internal UInt32[] x;
    public bool IsZero { get; }
    public bool IsOne { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public SecP384R1FieldElement(BigInteger x);
    protected internal SecP384R1FieldElement(UInt32[] x);
    private static SecP384R1FieldElement();
    public virtual bool get_IsZero();
    public virtual bool get_IsOne();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecP384R1FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP384R1Point : AbstractFpPoint {
    public SecP384R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecP384R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecP384R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP521R1Curve : AbstractFpCurve {
    public static BigInteger q;
    private static int SECP521R1_DEFAULT_COORDS;
    private static int SECP521R1_FE_INTS;
    private static ECFieldElement[] SECP521R1_AFFINE_ZS;
    protected SecP521R1Point m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static SecP521R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    public virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP521R1Field : object {
    internal static UInt32[] P;
    private static UInt32 P16;
    private static SecP521R1Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddOne(UInt32[] x, UInt32[] z);
    public static UInt32[] FromBigInteger(BigInteger x);
    public static void Half(UInt32[] x, UInt32[] z);
    public static void Inv(UInt32[] x, UInt32[] z);
    public static int IsZero(UInt32[] x);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Random(SecureRandom r, UInt32[] z);
    public static void RandomMult(SecureRandom r, UInt32[] z);
    public static void Reduce(UInt32[] xx, UInt32[] z);
    public static void Reduce23(UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z);
    public static void SquareN(UInt32[] x, int n, UInt32[] z);
    public static void Subtract(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void Twice(UInt32[] x, UInt32[] z);
    protected static void ImplMultiply(UInt32[] x, UInt32[] y, UInt32[] zz);
    protected static void ImplSquare(UInt32[] x, UInt32[] zz);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP521R1FieldElement : AbstractFpFieldElement {
    public static BigInteger Q;
    protected internal UInt32[] x;
    public bool IsZero { get; }
    public bool IsOne { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public SecP521R1FieldElement(BigInteger x);
    protected internal SecP521R1FieldElement(UInt32[] x);
    private static SecP521R1FieldElement();
    public virtual bool get_IsZero();
    public virtual bool get_IsOne();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecP521R1FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecP521R1Point : AbstractFpPoint {
    public SecP521R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecP521R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecP521R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT113Field : object {
    private static ulong M49;
    private static ulong M57;
    public static void Add(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void AddExt(UInt64[] xx, UInt64[] yy, UInt64[] zz);
    public static void AddOne(UInt64[] x, UInt64[] z);
    private static void AddTo(UInt64[] x, UInt64[] z);
    public static UInt64[] FromBigInteger(BigInteger x);
    public static void HalfTrace(UInt64[] x, UInt64[] z);
    public static void Invert(UInt64[] x, UInt64[] z);
    public static void Multiply(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void MultiplyAddToExt(UInt64[] x, UInt64[] y, UInt64[] zz);
    public static void Reduce(UInt64[] xx, UInt64[] z);
    public static void Reduce15(UInt64[] z, int zOff);
    public static void Sqrt(UInt64[] x, UInt64[] z);
    public static void Square(UInt64[] x, UInt64[] z);
    public static void SquareAddToExt(UInt64[] x, UInt64[] zz);
    public static void SquareN(UInt64[] x, int n, UInt64[] z);
    public static UInt32 Trace(UInt64[] x);
    protected static void ImplMultiply(UInt64[] x, UInt64[] y, UInt64[] zz);
    protected static void ImplMulw(UInt64[] u, ulong x, ulong y, UInt64[] z, int zOff);
    protected static void ImplSquare(UInt64[] x, UInt64[] zz);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT113FieldElement : AbstractF2mFieldElement {
    protected internal UInt64[] x;
    public bool IsOne { get; }
    public bool IsZero { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public bool HasFastTrace { get; }
    public int Representation { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    public SecT113FieldElement(BigInteger x);
    protected internal SecT113FieldElement(UInt64[] x);
    public virtual bool get_IsOne();
    public virtual bool get_IsZero();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement MultiplyMinusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement MultiplyPlusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement SquareMinusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePlusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePow(int pow);
    public virtual ECFieldElement HalfTrace();
    public virtual bool get_HasFastTrace();
    public virtual int Trace();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual int get_Representation();
    public virtual int get_M();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecT113FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT113R1Curve : AbstractF2mCurve {
    private static int SECT113R1_DEFAULT_COORDS;
    private static int SECT113R1_FE_LONGS;
    private static ECFieldElement[] SECT113R1_AFFINE_ZS;
    protected SecT113R1Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT113R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT113R1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    public SecT113R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecT113R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecT113R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT113R2Curve : AbstractF2mCurve {
    private static int SECT113R2_DEFAULT_COORDS;
    private static int SECT113R2_FE_LONGS;
    private static ECFieldElement[] SECT113R2_AFFINE_ZS;
    protected SecT113R2Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT113R2Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT113R2Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    public SecT113R2Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecT113R2Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecT113R2Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT131Field : object {
    private static ulong M03;
    private static ulong M44;
    private static UInt64[] ROOT_Z;
    private static SecT131Field();
    public static void Add(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void AddExt(UInt64[] xx, UInt64[] yy, UInt64[] zz);
    public static void AddOne(UInt64[] x, UInt64[] z);
    private static void AddTo(UInt64[] x, UInt64[] z);
    public static UInt64[] FromBigInteger(BigInteger x);
    public static void HalfTrace(UInt64[] x, UInt64[] z);
    public static void Invert(UInt64[] x, UInt64[] z);
    public static void Multiply(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void MultiplyAddToExt(UInt64[] x, UInt64[] y, UInt64[] zz);
    public static void Reduce(UInt64[] xx, UInt64[] z);
    public static void Reduce61(UInt64[] z, int zOff);
    public static void Sqrt(UInt64[] x, UInt64[] z);
    public static void Square(UInt64[] x, UInt64[] z);
    public static void SquareAddToExt(UInt64[] x, UInt64[] zz);
    public static void SquareN(UInt64[] x, int n, UInt64[] z);
    public static UInt32 Trace(UInt64[] x);
    protected static void ImplCompactExt(UInt64[] zz);
    protected static void ImplMultiply(UInt64[] x, UInt64[] y, UInt64[] zz);
    protected static void ImplMulw(UInt64[] u, ulong x, ulong y, UInt64[] z, int zOff);
    protected static void ImplSquare(UInt64[] x, UInt64[] zz);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT131FieldElement : AbstractF2mFieldElement {
    protected internal UInt64[] x;
    public bool IsOne { get; }
    public bool IsZero { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public bool HasFastTrace { get; }
    public int Representation { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    public SecT131FieldElement(BigInteger x);
    protected internal SecT131FieldElement(UInt64[] x);
    public virtual bool get_IsOne();
    public virtual bool get_IsZero();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement MultiplyMinusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement MultiplyPlusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement SquareMinusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePlusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePow(int pow);
    public virtual ECFieldElement HalfTrace();
    public virtual bool get_HasFastTrace();
    public virtual int Trace();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual int get_Representation();
    public virtual int get_M();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecT131FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT131R1Curve : AbstractF2mCurve {
    private static int SECT131R1_DEFAULT_COORDS;
    private static int SECT131R1_FE_LONGS;
    private static ECFieldElement[] SECT131R1_AFFINE_ZS;
    protected SecT131R1Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT131R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT131R1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    public SecT131R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecT131R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecT131R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT131R2Curve : AbstractF2mCurve {
    private static int SECT131R2_DEFAULT_COORDS;
    private static int SECT131R2_FE_LONGS;
    private static ECFieldElement[] SECT131R2_AFFINE_ZS;
    protected SecT131R2Point m_infinity;
    public int FieldSize { get; }
    public ECPoint Infinity { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT131R2Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual ECPoint get_Infinity();
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT131R2Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    public SecT131R2Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecT131R2Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecT131R2Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT163Field : object {
    private static ulong M35;
    private static ulong M55;
    private static UInt64[] ROOT_Z;
    private static SecT163Field();
    public static void Add(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void AddExt(UInt64[] xx, UInt64[] yy, UInt64[] zz);
    public static void AddOne(UInt64[] x, UInt64[] z);
    private static void AddTo(UInt64[] x, UInt64[] z);
    public static UInt64[] FromBigInteger(BigInteger x);
    public static void HalfTrace(UInt64[] x, UInt64[] z);
    public static void Invert(UInt64[] x, UInt64[] z);
    public static void Multiply(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void MultiplyAddToExt(UInt64[] x, UInt64[] y, UInt64[] zz);
    public static void Reduce(UInt64[] xx, UInt64[] z);
    public static void Reduce29(UInt64[] z, int zOff);
    public static void Sqrt(UInt64[] x, UInt64[] z);
    public static void Square(UInt64[] x, UInt64[] z);
    public static void SquareAddToExt(UInt64[] x, UInt64[] zz);
    public static void SquareN(UInt64[] x, int n, UInt64[] z);
    public static UInt32 Trace(UInt64[] x);
    protected static void ImplCompactExt(UInt64[] zz);
    protected static void ImplMultiply(UInt64[] x, UInt64[] y, UInt64[] zz);
    protected static void ImplMulw(UInt64[] u, ulong x, ulong y, UInt64[] z, int zOff);
    protected static void ImplSquare(UInt64[] x, UInt64[] zz);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT163FieldElement : AbstractF2mFieldElement {
    protected internal UInt64[] x;
    public bool IsOne { get; }
    public bool IsZero { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public bool HasFastTrace { get; }
    public int Representation { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    public SecT163FieldElement(BigInteger x);
    protected internal SecT163FieldElement(UInt64[] x);
    public virtual bool get_IsOne();
    public virtual bool get_IsZero();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement MultiplyMinusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement MultiplyPlusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement SquareMinusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePlusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePow(int pow);
    public virtual ECFieldElement HalfTrace();
    public virtual bool get_HasFastTrace();
    public virtual int Trace();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual int get_Representation();
    public virtual int get_M();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecT163FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT163K1Curve : AbstractF2mCurve {
    private static int SECT163K1_DEFAULT_COORDS;
    private static int SECT163K1_FE_LONGS;
    private static ECFieldElement[] SECT163K1_AFFINE_ZS;
    protected SecT163K1Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT163K1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    protected virtual ECMultiplier CreateDefaultMultiplier();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT163K1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    public SecT163K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecT163K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecT163K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT163R1Curve : AbstractF2mCurve {
    private static int SECT163R1_DEFAULT_COORDS;
    private static int SECT163R1_FE_LONGS;
    private static ECFieldElement[] SECT163R1_AFFINE_ZS;
    protected SecT163R1Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT163R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT163R1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    public SecT163R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecT163R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecT163R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT163R2Curve : AbstractF2mCurve {
    private static int SECT163R2_DEFAULT_COORDS;
    private static int SECT163R2_FE_LONGS;
    private static ECFieldElement[] SECT163R2_AFFINE_ZS;
    protected SecT163R2Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT163R2Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT163R2Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    public SecT163R2Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecT163R2Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecT163R2Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT193Field : object {
    private static ulong M01;
    private static ulong M49;
    public static void Add(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void AddExt(UInt64[] xx, UInt64[] yy, UInt64[] zz);
    public static void AddOne(UInt64[] x, UInt64[] z);
    private static void AddTo(UInt64[] x, UInt64[] z);
    public static UInt64[] FromBigInteger(BigInteger x);
    public static void HalfTrace(UInt64[] x, UInt64[] z);
    public static void Invert(UInt64[] x, UInt64[] z);
    public static void Multiply(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void MultiplyAddToExt(UInt64[] x, UInt64[] y, UInt64[] zz);
    public static void Reduce(UInt64[] xx, UInt64[] z);
    public static void Reduce63(UInt64[] z, int zOff);
    public static void Sqrt(UInt64[] x, UInt64[] z);
    public static void Square(UInt64[] x, UInt64[] z);
    public static void SquareAddToExt(UInt64[] x, UInt64[] zz);
    public static void SquareN(UInt64[] x, int n, UInt64[] z);
    public static UInt32 Trace(UInt64[] x);
    protected static void ImplCompactExt(UInt64[] zz);
    protected static void ImplExpand(UInt64[] x, UInt64[] z);
    protected static void ImplMultiply(UInt64[] x, UInt64[] y, UInt64[] zz);
    protected static void ImplMulwAcc(UInt64[] u, ulong x, ulong y, UInt64[] z, int zOff);
    protected static void ImplSquare(UInt64[] x, UInt64[] zz);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT193FieldElement : AbstractF2mFieldElement {
    protected internal UInt64[] x;
    public bool IsOne { get; }
    public bool IsZero { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public bool HasFastTrace { get; }
    public int Representation { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    public SecT193FieldElement(BigInteger x);
    protected internal SecT193FieldElement(UInt64[] x);
    public virtual bool get_IsOne();
    public virtual bool get_IsZero();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement MultiplyMinusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement MultiplyPlusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement SquareMinusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePlusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePow(int pow);
    public virtual ECFieldElement HalfTrace();
    public virtual bool get_HasFastTrace();
    public virtual int Trace();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual int get_Representation();
    public virtual int get_M();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecT193FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT193R1Curve : AbstractF2mCurve {
    private static int SECT193R1_DEFAULT_COORDS;
    private static int SECT193R1_FE_LONGS;
    private static ECFieldElement[] SECT193R1_AFFINE_ZS;
    protected SecT193R1Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT193R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT193R1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    public SecT193R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecT193R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecT193R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT193R2Curve : AbstractF2mCurve {
    private static int SECT193R2_DEFAULT_COORDS;
    private static int SECT193R2_FE_LONGS;
    private static ECFieldElement[] SECT193R2_AFFINE_ZS;
    protected SecT193R2Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT193R2Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT193R2Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    public SecT193R2Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecT193R2Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecT193R2Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT233Field : object {
    private static ulong M41;
    private static ulong M59;
    public static void Add(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void AddExt(UInt64[] xx, UInt64[] yy, UInt64[] zz);
    public static void AddOne(UInt64[] x, UInt64[] z);
    private static void AddTo(UInt64[] x, UInt64[] z);
    public static UInt64[] FromBigInteger(BigInteger x);
    public static void HalfTrace(UInt64[] x, UInt64[] z);
    public static void Invert(UInt64[] x, UInt64[] z);
    public static void Multiply(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void MultiplyAddToExt(UInt64[] x, UInt64[] y, UInt64[] zz);
    public static void Reduce(UInt64[] xx, UInt64[] z);
    public static void Reduce23(UInt64[] z, int zOff);
    public static void Sqrt(UInt64[] x, UInt64[] z);
    public static void Square(UInt64[] x, UInt64[] z);
    public static void SquareAddToExt(UInt64[] x, UInt64[] zz);
    public static void SquareN(UInt64[] x, int n, UInt64[] z);
    public static UInt32 Trace(UInt64[] x);
    protected static void ImplCompactExt(UInt64[] zz);
    protected static void ImplExpand(UInt64[] x, UInt64[] z);
    protected static void ImplMultiply(UInt64[] x, UInt64[] y, UInt64[] zz);
    protected static void ImplMulwAcc(UInt64[] u, ulong x, ulong y, UInt64[] z, int zOff);
    protected static void ImplSquare(UInt64[] x, UInt64[] zz);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT233FieldElement : AbstractF2mFieldElement {
    protected internal UInt64[] x;
    public bool IsOne { get; }
    public bool IsZero { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public bool HasFastTrace { get; }
    public int Representation { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    public SecT233FieldElement(BigInteger x);
    protected internal SecT233FieldElement(UInt64[] x);
    public virtual bool get_IsOne();
    public virtual bool get_IsZero();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement MultiplyMinusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement MultiplyPlusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement SquareMinusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePlusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePow(int pow);
    public virtual ECFieldElement HalfTrace();
    public virtual bool get_HasFastTrace();
    public virtual int Trace();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual int get_Representation();
    public virtual int get_M();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecT233FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT233K1Curve : AbstractF2mCurve {
    private static int SECT233K1_DEFAULT_COORDS;
    private static int SECT233K1_FE_LONGS;
    private static ECFieldElement[] SECT233K1_AFFINE_ZS;
    protected SecT233K1Point m_infinity;
    public int FieldSize { get; }
    public ECPoint Infinity { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT233K1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    protected virtual ECMultiplier CreateDefaultMultiplier();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual ECPoint get_Infinity();
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT233K1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    public SecT233K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecT233K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecT233K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT233R1Curve : AbstractF2mCurve {
    private static int SECT233R1_DEFAULT_COORDS;
    private static int SECT233R1_FE_LONGS;
    private static ECFieldElement[] SECT233R1_AFFINE_ZS;
    protected SecT233R1Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT233R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT233R1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    public SecT233R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecT233R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecT233R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT239Field : object {
    private static ulong M47;
    private static ulong M60;
    public static void Add(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void AddExt(UInt64[] xx, UInt64[] yy, UInt64[] zz);
    public static void AddOne(UInt64[] x, UInt64[] z);
    private static void AddTo(UInt64[] x, UInt64[] z);
    public static UInt64[] FromBigInteger(BigInteger x);
    public static void HalfTrace(UInt64[] x, UInt64[] z);
    public static void Invert(UInt64[] x, UInt64[] z);
    public static void Multiply(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void MultiplyAddToExt(UInt64[] x, UInt64[] y, UInt64[] zz);
    public static void Reduce(UInt64[] xx, UInt64[] z);
    public static void Reduce17(UInt64[] z, int zOff);
    public static void Sqrt(UInt64[] x, UInt64[] z);
    public static void Square(UInt64[] x, UInt64[] z);
    public static void SquareAddToExt(UInt64[] x, UInt64[] zz);
    public static void SquareN(UInt64[] x, int n, UInt64[] z);
    public static UInt32 Trace(UInt64[] x);
    protected static void ImplCompactExt(UInt64[] zz);
    protected static void ImplExpand(UInt64[] x, UInt64[] z);
    protected static void ImplMultiply(UInt64[] x, UInt64[] y, UInt64[] zz);
    protected static void ImplMulwAcc(UInt64[] u, ulong x, ulong y, UInt64[] z, int zOff);
    protected static void ImplSquare(UInt64[] x, UInt64[] zz);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT239FieldElement : AbstractF2mFieldElement {
    protected internal UInt64[] x;
    public bool IsOne { get; }
    public bool IsZero { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public bool HasFastTrace { get; }
    public int Representation { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    public SecT239FieldElement(BigInteger x);
    protected internal SecT239FieldElement(UInt64[] x);
    public virtual bool get_IsOne();
    public virtual bool get_IsZero();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement MultiplyMinusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement MultiplyPlusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement SquareMinusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePlusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePow(int pow);
    public virtual ECFieldElement HalfTrace();
    public virtual bool get_HasFastTrace();
    public virtual int Trace();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual int get_Representation();
    public virtual int get_M();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecT239FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT239K1Curve : AbstractF2mCurve {
    private static int SECT239K1_DEFAULT_COORDS;
    private static int SECT239K1_FE_LONGS;
    private static ECFieldElement[] SECT239K1_AFFINE_ZS;
    protected SecT239K1Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT239K1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    protected virtual ECMultiplier CreateDefaultMultiplier();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT239K1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    public SecT239K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecT239K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecT239K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT283Field : object {
    private static ulong M27;
    private static ulong M57;
    private static UInt64[] ROOT_Z;
    private static SecT283Field();
    public static void Add(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void AddExt(UInt64[] xx, UInt64[] yy, UInt64[] zz);
    public static void AddOne(UInt64[] x, UInt64[] z);
    private static void AddTo(UInt64[] x, UInt64[] z);
    public static UInt64[] FromBigInteger(BigInteger x);
    public static void HalfTrace(UInt64[] x, UInt64[] z);
    public static void Invert(UInt64[] x, UInt64[] z);
    public static void Multiply(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void MultiplyAddToExt(UInt64[] x, UInt64[] y, UInt64[] zz);
    public static void Reduce(UInt64[] xx, UInt64[] z);
    public static void Reduce37(UInt64[] z, int zOff);
    public static void Sqrt(UInt64[] x, UInt64[] z);
    public static void Square(UInt64[] x, UInt64[] z);
    public static void SquareAddToExt(UInt64[] x, UInt64[] zz);
    public static void SquareN(UInt64[] x, int n, UInt64[] z);
    public static UInt32 Trace(UInt64[] x);
    protected static void ImplCompactExt(UInt64[] zz);
    protected static void ImplExpand(UInt64[] x, UInt64[] z);
    protected static void ImplMultiply(UInt64[] x, UInt64[] y, UInt64[] zz);
    protected static void ImplMulw(UInt64[] u, ulong x, ulong y, UInt64[] z, int zOff);
    protected static void ImplSquare(UInt64[] x, UInt64[] zz);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT283FieldElement : AbstractF2mFieldElement {
    protected internal UInt64[] x;
    public bool IsOne { get; }
    public bool IsZero { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public bool HasFastTrace { get; }
    public int Representation { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    public SecT283FieldElement(BigInteger x);
    protected internal SecT283FieldElement(UInt64[] x);
    public virtual bool get_IsOne();
    public virtual bool get_IsZero();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement MultiplyMinusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement MultiplyPlusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement SquareMinusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePlusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePow(int pow);
    public virtual ECFieldElement HalfTrace();
    public virtual bool get_HasFastTrace();
    public virtual int Trace();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual int get_Representation();
    public virtual int get_M();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecT283FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT283K1Curve : AbstractF2mCurve {
    private static int SECT283K1_DEFAULT_COORDS;
    private static int SECT283K1_FE_LONGS;
    private static ECFieldElement[] SECT283K1_AFFINE_ZS;
    protected SecT283K1Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT283K1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    protected virtual ECMultiplier CreateDefaultMultiplier();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT283K1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    public SecT283K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecT283K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecT283K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT283R1Curve : AbstractF2mCurve {
    private static int SECT283R1_DEFAULT_COORDS;
    private static int SECT283R1_FE_LONGS;
    private static ECFieldElement[] SECT283R1_AFFINE_ZS;
    protected SecT283R1Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT283R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT283R1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    public SecT283R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecT283R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecT283R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT409Field : object {
    private static ulong M25;
    private static ulong M59;
    public static void Add(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void AddExt(UInt64[] xx, UInt64[] yy, UInt64[] zz);
    public static void AddOne(UInt64[] x, UInt64[] z);
    private static void AddTo(UInt64[] x, UInt64[] z);
    public static UInt64[] FromBigInteger(BigInteger x);
    public static void HalfTrace(UInt64[] x, UInt64[] z);
    public static void Invert(UInt64[] x, UInt64[] z);
    public static void Multiply(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void MultiplyAddToExt(UInt64[] x, UInt64[] y, UInt64[] zz);
    public static void Reduce(UInt64[] xx, UInt64[] z);
    public static void Reduce39(UInt64[] z, int zOff);
    public static void Sqrt(UInt64[] x, UInt64[] z);
    public static void Square(UInt64[] x, UInt64[] z);
    public static void SquareAddToExt(UInt64[] x, UInt64[] zz);
    public static void SquareN(UInt64[] x, int n, UInt64[] z);
    public static UInt32 Trace(UInt64[] x);
    protected static void ImplCompactExt(UInt64[] zz);
    protected static void ImplExpand(UInt64[] x, UInt64[] z);
    protected static void ImplMultiply(UInt64[] x, UInt64[] y, UInt64[] zz);
    protected static void ImplMulwAcc(UInt64[] u, ulong x, ulong y, UInt64[] z, int zOff);
    protected static void ImplSquare(UInt64[] x, UInt64[] zz);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT409FieldElement : AbstractF2mFieldElement {
    protected internal UInt64[] x;
    public bool IsOne { get; }
    public bool IsZero { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public bool HasFastTrace { get; }
    public int Representation { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    public SecT409FieldElement(BigInteger x);
    protected internal SecT409FieldElement(UInt64[] x);
    public virtual bool get_IsOne();
    public virtual bool get_IsZero();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement MultiplyMinusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement MultiplyPlusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement SquareMinusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePlusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePow(int pow);
    public virtual ECFieldElement HalfTrace();
    public virtual bool get_HasFastTrace();
    public virtual int Trace();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual int get_Representation();
    public virtual int get_M();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecT409FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT409K1Curve : AbstractF2mCurve {
    private static int SECT409K1_DEFAULT_COORDS;
    private static int SECT409K1_FE_LONGS;
    private static ECFieldElement[] SECT409K1_AFFINE_ZS;
    protected SecT409K1Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT409K1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    protected virtual ECMultiplier CreateDefaultMultiplier();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT409K1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    public SecT409K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecT409K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecT409K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT409R1Curve : AbstractF2mCurve {
    private static int SECT409R1_DEFAULT_COORDS;
    private static int SECT409R1_FE_LONGS;
    private static ECFieldElement[] SECT409R1_AFFINE_ZS;
    protected SecT409R1Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT409R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT409R1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    public SecT409R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecT409R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecT409R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT571Field : object {
    private static ulong M59;
    private static UInt64[] ROOT_Z;
    private static SecT571Field();
    public static void Add(UInt64[] x, UInt64[] y, UInt64[] z);
    private static void Add(UInt64[] x, int xOff, UInt64[] y, int yOff, UInt64[] z, int zOff);
    public static void AddBothTo(UInt64[] x, UInt64[] y, UInt64[] z);
    private static void AddBothTo(UInt64[] x, int xOff, UInt64[] y, int yOff, UInt64[] z, int zOff);
    public static void AddExt(UInt64[] xx, UInt64[] yy, UInt64[] zz);
    public static void AddOne(UInt64[] x, UInt64[] z);
    private static void AddTo(UInt64[] x, UInt64[] z);
    public static UInt64[] FromBigInteger(BigInteger x);
    public static void HalfTrace(UInt64[] x, UInt64[] z);
    public static void Invert(UInt64[] x, UInt64[] z);
    public static void Multiply(UInt64[] x, UInt64[] y, UInt64[] z);
    public static void MultiplyAddToExt(UInt64[] x, UInt64[] y, UInt64[] zz);
    public static void MultiplyPrecomp(UInt64[] x, UInt64[] precomp, UInt64[] z);
    public static void MultiplyPrecompAddToExt(UInt64[] x, UInt64[] precomp, UInt64[] zz);
    public static UInt64[] PrecompMultiplicand(UInt64[] x);
    public static void Reduce(UInt64[] xx, UInt64[] z);
    public static void Reduce5(UInt64[] z, int zOff);
    public static void Sqrt(UInt64[] x, UInt64[] z);
    public static void Square(UInt64[] x, UInt64[] z);
    public static void SquareAddToExt(UInt64[] x, UInt64[] zz);
    public static void SquareN(UInt64[] x, int n, UInt64[] z);
    public static UInt32 Trace(UInt64[] x);
    protected static void ImplMultiply(UInt64[] x, UInt64[] y, UInt64[] zz);
    protected static void ImplMultiplyPrecomp(UInt64[] x, UInt64[] precomp, UInt64[] zz);
    protected static void ImplMulwAcc(UInt64[] u, ulong x, ulong y, UInt64[] z, int zOff);
    protected static void ImplSquare(UInt64[] x, UInt64[] zz);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT571FieldElement : AbstractF2mFieldElement {
    protected internal UInt64[] x;
    public bool IsOne { get; }
    public bool IsZero { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public bool HasFastTrace { get; }
    public int Representation { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    public SecT571FieldElement(BigInteger x);
    protected internal SecT571FieldElement(UInt64[] x);
    public virtual bool get_IsOne();
    public virtual bool get_IsZero();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement MultiplyMinusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement MultiplyPlusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement SquareMinusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePlusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePow(int pow);
    public virtual ECFieldElement HalfTrace();
    public virtual bool get_HasFastTrace();
    public virtual int Trace();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual int get_Representation();
    public virtual int get_M();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecT571FieldElement other);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT571K1Curve : AbstractF2mCurve {
    private static int SECT571K1_DEFAULT_COORDS;
    private static int SECT571K1_FE_LONGS;
    private static ECFieldElement[] SECT571K1_AFFINE_ZS;
    protected SecT571K1Point m_infinity;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT571K1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    protected virtual ECMultiplier CreateDefaultMultiplier();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT571K1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    public SecT571K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecT571K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecT571K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT571R1Curve : AbstractF2mCurve {
    private static int SECT571R1_DEFAULT_COORDS;
    private static int SECT571R1_FE_LONGS;
    private static ECFieldElement[] SECT571R1_AFFINE_ZS;
    protected SecT571R1Point m_infinity;
    internal static SecT571FieldElement SecT571R1_B;
    internal static SecT571FieldElement SecT571R1_B_SQRT;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public bool IsTrinomial { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    private static SecT571R1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual bool get_IsKoblitz();
    public virtual int get_M();
    public virtual bool get_IsTrinomial();
    public virtual int get_K1();
    public virtual int get_K2();
    public virtual int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
internal class Org.BouncyCastle.Math.EC.Custom.Sec.SecT571R1Point : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    public SecT571R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecT571R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecT571R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
public class Org.BouncyCastle.Math.EC.ECAlgorithms : object {
    public static bool IsF2mCurve(ECCurve c);
    public static bool IsF2mField(IFiniteField field);
    public static bool IsFpCurve(ECCurve c);
    public static bool IsFpField(IFiniteField field);
    public static ECPoint SumOfMultiplies(ECPoint[] ps, BigInteger[] ks);
    public static ECPoint SumOfTwoMultiplies(ECPoint P, BigInteger a, ECPoint Q, BigInteger b);
    public static ECPoint ShamirsTrick(ECPoint P, BigInteger k, ECPoint Q, BigInteger l);
    public static ECPoint ImportPoint(ECCurve c, ECPoint p);
    public static void MontgomeryTrick(ECFieldElement[] zs, int off, int len);
    public static void MontgomeryTrick(ECFieldElement[] zs, int off, int len, ECFieldElement scale);
    public static ECPoint ReferenceMultiply(ECPoint p, BigInteger k);
    public static ECPoint ValidatePoint(ECPoint p);
    public static ECPoint CleanPoint(ECCurve c, ECPoint p);
    internal static ECPoint ImplCheckResult(ECPoint p);
    internal static ECPoint ImplShamirsTrickJsf(ECPoint P, BigInteger k, ECPoint Q, BigInteger l);
    internal static ECPoint ImplShamirsTrickWNaf(ECPoint P, BigInteger k, ECPoint Q, BigInteger l);
    internal static ECPoint ImplShamirsTrickWNaf(ECEndomorphism endomorphism, ECPoint P, BigInteger k, BigInteger l);
    private static ECPoint ImplShamirsTrickWNaf(ECPoint[] preCompP, ECPoint[] preCompNegP, Byte[] wnafP, ECPoint[] preCompQ, ECPoint[] preCompNegQ, Byte[] wnafQ);
    internal static ECPoint ImplSumOfMultiplies(ECPoint[] ps, BigInteger[] ks);
    internal static ECPoint ImplSumOfMultipliesGlv(ECPoint[] ps, BigInteger[] ks, GlvEndomorphism glvEndomorphism);
    internal static ECPoint ImplSumOfMultiplies(ECEndomorphism endomorphism, ECPoint[] ps, BigInteger[] ks);
    private static ECPoint ImplSumOfMultiplies(Boolean[] negs, WNafPreCompInfo[] infos, Byte[][] wnafs);
    private static ECPoint ImplShamirsTrickFixedPoint(ECPoint p, BigInteger k, ECPoint q, BigInteger l);
}
public abstract class Org.BouncyCastle.Math.EC.ECCurve : object {
    public static int COORD_AFFINE;
    public static int COORD_HOMOGENEOUS;
    public static int COORD_JACOBIAN;
    public static int COORD_JACOBIAN_CHUDNOVSKY;
    public static int COORD_JACOBIAN_MODIFIED;
    public static int COORD_LAMBDA_AFFINE;
    public static int COORD_LAMBDA_PROJECTIVE;
    public static int COORD_SKEWED;
    protected IFiniteField m_field;
    protected ECFieldElement m_a;
    protected ECFieldElement m_b;
    protected BigInteger m_order;
    protected BigInteger m_cofactor;
    protected int m_coord;
    protected ECEndomorphism m_endomorphism;
    protected ECMultiplier m_multiplier;
    public int FieldSize { get; }
    public ECPoint Infinity { get; }
    public IFiniteField Field { get; }
    public ECFieldElement A { get; }
    public ECFieldElement B { get; }
    public BigInteger Order { get; }
    public BigInteger Cofactor { get; }
    public int CoordinateSystem { get; }
    protected ECCurve(IFiniteField field);
    public static Int32[] GetAllCoordinateSystems();
    public abstract virtual int get_FieldSize();
    public abstract virtual ECFieldElement FromBigInteger(BigInteger x);
    public abstract virtual bool IsValidFieldElement(BigInteger x);
    public abstract virtual ECFieldElement RandomFieldElement(SecureRandom r);
    public abstract virtual ECFieldElement RandomFieldElementMult(SecureRandom r);
    public virtual Config Configure();
    public virtual ECPoint ValidatePoint(BigInteger x, BigInteger y);
    [ObsoleteAttribute("Per-point compression property will be removed")]
public virtual ECPoint ValidatePoint(BigInteger x, BigInteger y, bool withCompression);
    public virtual ECPoint CreatePoint(BigInteger x, BigInteger y);
    [ObsoleteAttribute("Per-point compression property will be removed")]
public virtual ECPoint CreatePoint(BigInteger x, BigInteger y, bool withCompression);
    protected abstract virtual ECCurve CloneCurve();
    protected internal abstract virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal abstract virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECMultiplier CreateDefaultMultiplier();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual PreCompInfo GetPreCompInfo(ECPoint point, string name);
    public virtual PreCompInfo Precompute(ECPoint point, string name, IPreCompCallback callback);
    public virtual ECPoint ImportPoint(ECPoint p);
    public virtual void NormalizeAll(ECPoint[] points);
    public virtual void NormalizeAll(ECPoint[] points, int off, int len, ECFieldElement iso);
    public abstract virtual ECPoint get_Infinity();
    public virtual IFiniteField get_Field();
    public virtual ECFieldElement get_A();
    public virtual ECFieldElement get_B();
    public virtual BigInteger get_Order();
    public virtual BigInteger get_Cofactor();
    public virtual int get_CoordinateSystem();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
    protected virtual void CheckPoint(ECPoint point);
    protected virtual void CheckPoints(ECPoint[] points);
    protected virtual void CheckPoints(ECPoint[] points, int off, int len);
    public virtual bool Equals(ECCurve other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected abstract virtual ECPoint DecompressPoint(int yTilde, BigInteger X1);
    public virtual ECEndomorphism GetEndomorphism();
    public virtual ECMultiplier GetMultiplier();
    public virtual ECPoint DecodePoint(Byte[] encoded);
}
public abstract class Org.BouncyCastle.Math.EC.ECFieldElement : object {
    public string FieldName { get; }
    public int FieldSize { get; }
    public int BitLength { get; }
    public bool IsOne { get; }
    public bool IsZero { get; }
    public abstract virtual BigInteger ToBigInteger();
    public abstract virtual string get_FieldName();
    public abstract virtual int get_FieldSize();
    public abstract virtual ECFieldElement Add(ECFieldElement b);
    public abstract virtual ECFieldElement AddOne();
    public abstract virtual ECFieldElement Subtract(ECFieldElement b);
    public abstract virtual ECFieldElement Multiply(ECFieldElement b);
    public abstract virtual ECFieldElement Divide(ECFieldElement b);
    public abstract virtual ECFieldElement Negate();
    public abstract virtual ECFieldElement Square();
    public abstract virtual ECFieldElement Invert();
    public abstract virtual ECFieldElement Sqrt();
    public virtual int get_BitLength();
    public virtual bool get_IsOne();
    public virtual bool get_IsZero();
    public virtual ECFieldElement MultiplyMinusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement MultiplyPlusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquareMinusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePlusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePow(int pow);
    public virtual bool TestBitZero();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual Byte[] GetEncoded();
}
public interface Org.BouncyCastle.Math.EC.ECLookupTable {
    public int Size { get; }
    public abstract virtual int get_Size();
    public abstract virtual ECPoint Lookup(int index);
    public abstract virtual ECPoint LookupVar(int index);
}
public abstract class Org.BouncyCastle.Math.EC.ECPoint : object {
    private static SecureRandom Random;
    protected static ECFieldElement[] EMPTY_ZS;
    protected internal ECCurve m_curve;
    protected internal ECFieldElement m_x;
    protected internal ECFieldElement m_y;
    protected internal ECFieldElement[] m_zs;
    protected internal bool m_withCompression;
    protected internal IDictionary m_preCompTable;
    public ECCurve Curve { get; }
    protected int CurveCoordinateSystem { get; }
    public ECFieldElement AffineXCoord { get; }
    public ECFieldElement AffineYCoord { get; }
    public ECFieldElement XCoord { get; }
    public ECFieldElement YCoord { get; }
    protected internal ECFieldElement RawXCoord { get; }
    protected internal ECFieldElement RawYCoord { get; }
    protected internal ECFieldElement[] RawZCoords { get; }
    public bool IsInfinity { get; }
    public bool IsCompressed { get; }
    protected internal bool CompressionYTilde { get; }
    protected ECPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal ECPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    private static ECPoint();
    protected static ECFieldElement[] GetInitialZCoords(ECCurve curve);
    protected abstract virtual bool SatisfiesCurveEquation();
    protected virtual bool SatisfiesOrder();
    public ECPoint GetDetachedPoint();
    public virtual ECCurve get_Curve();
    protected abstract virtual ECPoint Detach();
    protected virtual int get_CurveCoordinateSystem();
    public virtual ECFieldElement get_AffineXCoord();
    public virtual ECFieldElement get_AffineYCoord();
    public virtual ECFieldElement get_XCoord();
    public virtual ECFieldElement get_YCoord();
    public virtual ECFieldElement GetZCoord(int index);
    public virtual ECFieldElement[] GetZCoords();
    protected internal ECFieldElement get_RawXCoord();
    protected internal ECFieldElement get_RawYCoord();
    protected internal ECFieldElement[] get_RawZCoords();
    protected virtual void CheckNormalized();
    public virtual bool IsNormalized();
    public virtual ECPoint Normalize();
    internal virtual ECPoint Normalize(ECFieldElement zInv);
    protected virtual ECPoint CreateScaledPoint(ECFieldElement sx, ECFieldElement sy);
    public bool get_IsInfinity();
    public bool get_IsCompressed();
    public bool IsValid();
    internal bool IsValidPartial();
    internal bool ImplIsValid(bool decompressed, bool checkOrder);
    public virtual ECPoint ScaleX(ECFieldElement scale);
    public virtual ECPoint ScaleXNegateY(ECFieldElement scale);
    public virtual ECPoint ScaleY(ECFieldElement scale);
    public virtual ECPoint ScaleYNegateX(ECFieldElement scale);
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECPoint other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual Byte[] GetEncoded();
    public abstract virtual Byte[] GetEncoded(bool compressed);
    protected internal abstract virtual bool get_CompressionYTilde();
    public abstract virtual ECPoint Add(ECPoint b);
    public abstract virtual ECPoint Subtract(ECPoint b);
    public abstract virtual ECPoint Negate();
    public virtual ECPoint TimesPow2(int e);
    public abstract virtual ECPoint Twice();
    public abstract virtual ECPoint Multiply(BigInteger b);
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
}
public abstract class Org.BouncyCastle.Math.EC.ECPointBase : ECPoint {
    protected internal ECPointBase(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal ECPointBase(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual Byte[] GetEncoded(bool compressed);
    public virtual ECPoint Multiply(BigInteger k);
}
public interface Org.BouncyCastle.Math.EC.ECPointMap {
    public abstract virtual ECPoint Map(ECPoint p);
}
public interface Org.BouncyCastle.Math.EC.Endo.ECEndomorphism {
    public ECPointMap PointMap { get; }
    public bool HasEfficientPointMap { get; }
    public abstract virtual ECPointMap get_PointMap();
    public abstract virtual bool get_HasEfficientPointMap();
}
public class Org.BouncyCastle.Math.EC.Endo.EndoPreCompInfo : object {
    protected ECEndomorphism m_endomorphism;
    protected ECPoint m_mappedPoint;
    public ECEndomorphism Endomorphism { get; public set; }
    public ECPoint MappedPoint { get; public set; }
    public virtual ECEndomorphism get_Endomorphism();
    public virtual void set_Endomorphism(ECEndomorphism value);
    public virtual ECPoint get_MappedPoint();
    public virtual void set_MappedPoint(ECPoint value);
}
public abstract class Org.BouncyCastle.Math.EC.Endo.EndoUtilities : object {
    public static string PRECOMP_NAME;
    private static EndoUtilities();
    public static BigInteger[] DecomposeScalar(ScalarSplitParameters p, BigInteger k);
    public static ECPoint MapPoint(ECEndomorphism endomorphism, ECPoint p);
    private static BigInteger CalculateB(BigInteger k, BigInteger g, int t);
}
public interface Org.BouncyCastle.Math.EC.Endo.GlvEndomorphism {
    public abstract virtual BigInteger[] DecomposeScalar(BigInteger k);
}
public class Org.BouncyCastle.Math.EC.Endo.GlvTypeAEndomorphism : object {
    protected GlvTypeAParameters m_parameters;
    protected ECPointMap m_pointMap;
    public ECPointMap PointMap { get; }
    public bool HasEfficientPointMap { get; }
    public GlvTypeAEndomorphism(ECCurve curve, GlvTypeAParameters parameters);
    public virtual BigInteger[] DecomposeScalar(BigInteger k);
    public virtual ECPointMap get_PointMap();
    public virtual bool get_HasEfficientPointMap();
}
public class Org.BouncyCastle.Math.EC.Endo.GlvTypeAParameters : object {
    protected BigInteger m_i;
    protected BigInteger m_lambda;
    protected ScalarSplitParameters m_splitParams;
    public BigInteger I { get; }
    public BigInteger Lambda { get; }
    public ScalarSplitParameters SplitParams { get; }
    public GlvTypeAParameters(BigInteger i, BigInteger lambda, ScalarSplitParameters splitParams);
    public virtual BigInteger get_I();
    public virtual BigInteger get_Lambda();
    public virtual ScalarSplitParameters get_SplitParams();
}
public class Org.BouncyCastle.Math.EC.Endo.GlvTypeBEndomorphism : object {
    protected GlvTypeBParameters m_parameters;
    protected ECPointMap m_pointMap;
    public ECPointMap PointMap { get; }
    public bool HasEfficientPointMap { get; }
    public GlvTypeBEndomorphism(ECCurve curve, GlvTypeBParameters parameters);
    public virtual BigInteger[] DecomposeScalar(BigInteger k);
    public virtual ECPointMap get_PointMap();
    public virtual bool get_HasEfficientPointMap();
}
public class Org.BouncyCastle.Math.EC.Endo.GlvTypeBParameters : object {
    protected BigInteger m_beta;
    protected BigInteger m_lambda;
    protected ScalarSplitParameters m_splitParams;
    public BigInteger Beta { get; }
    public BigInteger Lambda { get; }
    public ScalarSplitParameters SplitParams { get; }
    [ObsoleteAttribute("Access via SplitParams instead")]
public BigInteger[] V1 { get; }
    [ObsoleteAttribute("Access via SplitParams instead")]
public BigInteger[] V2 { get; }
    [ObsoleteAttribute("Access via SplitParams instead")]
public BigInteger G1 { get; }
    [ObsoleteAttribute("Access via SplitParams instead")]
public BigInteger G2 { get; }
    [ObsoleteAttribute("Access via SplitParams instead")]
public int Bits { get; }
    [ObsoleteAttribute("Use constructor taking a ScalarSplitParameters instead")]
public GlvTypeBParameters(BigInteger beta, BigInteger lambda, BigInteger[] v1, BigInteger[] v2, BigInteger g1, BigInteger g2, int bits);
    public GlvTypeBParameters(BigInteger beta, BigInteger lambda, ScalarSplitParameters splitParams);
    public virtual BigInteger get_Beta();
    public virtual BigInteger get_Lambda();
    public virtual ScalarSplitParameters get_SplitParams();
    public virtual BigInteger[] get_V1();
    public virtual BigInteger[] get_V2();
    public virtual BigInteger get_G1();
    public virtual BigInteger get_G2();
    public virtual int get_Bits();
}
public class Org.BouncyCastle.Math.EC.Endo.ScalarSplitParameters : object {
    protected BigInteger m_v1A;
    protected BigInteger m_v1B;
    protected BigInteger m_v2A;
    protected BigInteger m_v2B;
    protected BigInteger m_g1;
    protected BigInteger m_g2;
    protected int m_bits;
    public BigInteger V1A { get; }
    public BigInteger V1B { get; }
    public BigInteger V2A { get; }
    public BigInteger V2B { get; }
    public BigInteger G1 { get; }
    public BigInteger G2 { get; }
    public int Bits { get; }
    public ScalarSplitParameters(BigInteger[] v1, BigInteger[] v2, BigInteger g1, BigInteger g2, int bits);
    private static void CheckVector(BigInteger[] v, string name);
    public virtual BigInteger get_V1A();
    public virtual BigInteger get_V1B();
    public virtual BigInteger get_V2A();
    public virtual BigInteger get_V2B();
    public virtual BigInteger get_G1();
    public virtual BigInteger get_G2();
    public virtual int get_Bits();
}
public class Org.BouncyCastle.Math.EC.F2mCurve : AbstractF2mCurve {
    private static int F2M_DEFAULT_COORDS;
    private int m;
    private int k1;
    private int k2;
    private int k3;
    protected F2mPoint m_infinity;
    public int FieldSize { get; }
    public ECPoint Infinity { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    [ObsoleteAttribute("Use constructor taking order/cofactor")]
public F2mCurve(int m, int k, BigInteger a, BigInteger b);
    public F2mCurve(int m, int k, BigInteger a, BigInteger b, BigInteger order, BigInteger cofactor);
    [ObsoleteAttribute("Use constructor taking order/cofactor")]
public F2mCurve(int m, int k1, int k2, int k3, BigInteger a, BigInteger b);
    public F2mCurve(int m, int k1, int k2, int k3, BigInteger a, BigInteger b, BigInteger order, BigInteger cofactor);
    protected F2mCurve(int m, int k1, int k2, int k3, ECFieldElement a, ECFieldElement b, BigInteger order, BigInteger cofactor);
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    protected virtual ECMultiplier CreateDefaultMultiplier();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual ECPoint get_Infinity();
    public int get_M();
    public bool IsTrinomial();
    public int get_K1();
    public int get_K2();
    public int get_K3();
    public virtual ECLookupTable CreateCacheSafeLookupTable(ECPoint[] points, int off, int len);
}
public class Org.BouncyCastle.Math.EC.F2mFieldElement : AbstractF2mFieldElement {
    public static int Gnb;
    public static int Tpb;
    public static int Ppb;
    private int representation;
    private int m;
    private Int32[] ks;
    internal LongArray x;
    public int BitLength { get; }
    public bool IsOne { get; }
    public bool IsZero { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public int Representation { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    [ObsoleteAttribute("Use ECCurve.FromBigInteger to construct field elements")]
public F2mFieldElement(int m, int k1, int k2, int k3, BigInteger x);
    [ObsoleteAttribute("Use ECCurve.FromBigInteger to construct field elements")]
public F2mFieldElement(int m, int k, BigInteger x);
    internal F2mFieldElement(int m, Int32[] ks, LongArray x);
    public virtual int get_BitLength();
    public virtual bool get_IsOne();
    public virtual bool get_IsZero();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public static void CheckFieldElements(ECFieldElement a, ECFieldElement b);
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement MultiplyMinusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement MultiplyPlusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement SquareMinusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePlusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePow(int pow);
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public int get_Representation();
    public int get_M();
    public int get_K1();
    public int get_K2();
    public int get_K3();
    public virtual bool Equals(object obj);
    public virtual bool Equals(F2mFieldElement other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Math.EC.F2mPoint : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    [ObsoleteAttribute("Use ECCurve.CreatePoint to construct points")]
public F2mPoint(ECCurve curve, ECFieldElement x, ECFieldElement y);
    [ObsoleteAttribute("Per-point compression property will be removed, see GetEncoded(bool)")]
public F2mPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal F2mPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
public class Org.BouncyCastle.Math.EC.FpCurve : AbstractFpCurve {
    private static int FP_DEFAULT_COORDS;
    protected BigInteger m_q;
    protected BigInteger m_r;
    protected FpPoint m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    [ObsoleteAttribute("Use constructor taking order/cofactor")]
public FpCurve(BigInteger q, BigInteger a, BigInteger b);
    public FpCurve(BigInteger q, BigInteger a, BigInteger b, BigInteger order, BigInteger cofactor);
    [ObsoleteAttribute("Use constructor taking order/cofactor")]
protected FpCurve(BigInteger q, BigInteger r, ECFieldElement a, ECFieldElement b);
    protected FpCurve(BigInteger q, BigInteger r, ECFieldElement a, ECFieldElement b, BigInteger order, BigInteger cofactor);
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual ECPoint ImportPoint(ECPoint p);
}
public class Org.BouncyCastle.Math.EC.FpFieldElement : AbstractFpFieldElement {
    private BigInteger q;
    private BigInteger r;
    private BigInteger x;
    public string FieldName { get; }
    public int FieldSize { get; }
    public BigInteger Q { get; }
    [ObsoleteAttribute("Use ECCurve.FromBigInteger to construct field elements")]
public FpFieldElement(BigInteger q, BigInteger x);
    internal FpFieldElement(BigInteger q, BigInteger r, BigInteger x);
    internal static BigInteger CalculateResidue(BigInteger p);
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public BigInteger get_Q();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement MultiplyMinusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement MultiplyPlusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement SquareMinusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePlusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    private ECFieldElement CheckSqrt(ECFieldElement z);
    private BigInteger[] LucasSequence(BigInteger P, BigInteger Q, BigInteger k);
    protected virtual BigInteger ModAdd(BigInteger x1, BigInteger x2);
    protected virtual BigInteger ModDouble(BigInteger x);
    protected virtual BigInteger ModHalf(BigInteger x);
    protected virtual BigInteger ModHalfAbs(BigInteger x);
    protected virtual BigInteger ModInverse(BigInteger x);
    protected virtual BigInteger ModMult(BigInteger x1, BigInteger x2);
    protected virtual BigInteger ModReduce(BigInteger x);
    protected virtual BigInteger ModSubtract(BigInteger x1, BigInteger x2);
    public virtual bool Equals(object obj);
    public virtual bool Equals(FpFieldElement other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Math.EC.FpPoint : AbstractFpPoint {
    [ObsoleteAttribute("Use ECCurve.CreatePoint to construct points")]
public FpPoint(ECCurve curve, ECFieldElement x, ECFieldElement y);
    [ObsoleteAttribute("Per-point compression property will be removed, see GetEncoded(bool)")]
public FpPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal FpPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement GetZCoord(int index);
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint TimesPow2(int e);
    protected virtual ECFieldElement Two(ECFieldElement x);
    protected virtual ECFieldElement Three(ECFieldElement x);
    protected virtual ECFieldElement Four(ECFieldElement x);
    protected virtual ECFieldElement Eight(ECFieldElement x);
    protected virtual ECFieldElement DoubleProductFromSquares(ECFieldElement a, ECFieldElement b, ECFieldElement aSquared, ECFieldElement bSquared);
    public virtual ECPoint Negate();
    protected virtual ECFieldElement CalculateJacobianModifiedW(ECFieldElement Z, ECFieldElement ZSquared);
    protected virtual ECFieldElement GetJacobianModifiedW();
    protected virtual FpPoint TwiceJacobianModified(bool calculateW);
}
internal class Org.BouncyCastle.Math.EC.LongArray : object {
    private static UInt16[] INTERLEAVE2_TABLE;
    private static Int32[] INTERLEAVE3_TABLE;
    private static Int32[] INTERLEAVE4_TABLE;
    private static Int32[] INTERLEAVE5_TABLE;
    private static Int64[] INTERLEAVE7_TABLE;
    private static string ZEROES;
    internal static Byte[] BitLengths;
    private Int64[] m_ints;
    public int Length { get; }
    public LongArray(int intLen);
    public LongArray(Int64[] ints);
    public LongArray(Int64[] ints, int off, int len);
    public LongArray(BigInteger bigInt);
    private static LongArray();
    internal void CopyTo(Int64[] z, int zOff);
    public bool IsOne();
    public bool IsZero();
    public int GetUsedLength();
    public int GetUsedLengthFrom(int from);
    public int Degree();
    private int DegreeFrom(int limit);
    private static int BitLength(long w);
    private Int64[] ResizedInts(int newLen);
    public BigInteger ToBigInteger();
    private static long ShiftUp(Int64[] x, int xOff, int count, int shift);
    private static long ShiftUp(Int64[] x, int xOff, Int64[] z, int zOff, int count, int shift);
    public LongArray AddOne();
    private void AddShiftedByBitsSafe(LongArray other, int otherDegree, int bits);
    private static long AddShiftedUp(Int64[] x, int xOff, Int64[] y, int yOff, int count, int shift);
    private static long AddShiftedDown(Int64[] x, int xOff, Int64[] y, int yOff, int count, int shift);
    public void AddShiftedByWords(LongArray other, int words);
    private static void Add(Int64[] x, int xOff, Int64[] y, int yOff, int count);
    private static void Add(Int64[] x, int xOff, Int64[] y, int yOff, Int64[] z, int zOff, int count);
    private static void AddBoth(Int64[] x, int xOff, Int64[] y1, int y1Off, Int64[] y2, int y2Off, int count);
    private static void Distribute(Int64[] x, int src, int dst1, int dst2, int count);
    public int get_Length();
    private static void FlipWord(Int64[] buf, int off, int bit, long word);
    public bool TestBitZero();
    private static bool TestBit(Int64[] buf, int off, int n);
    private static void FlipBit(Int64[] buf, int off, int n);
    private static void MultiplyWord(long a, Int64[] b, int bLen, Int64[] c, int cOff);
    public LongArray ModMultiplyLD(LongArray other, int m, Int32[] ks);
    public LongArray ModMultiply(LongArray other, int m, Int32[] ks);
    public LongArray ModMultiplyAlt(LongArray other, int m, Int32[] ks);
    public LongArray ModReduce(int m, Int32[] ks);
    public LongArray Multiply(LongArray other, int m, Int32[] ks);
    public void Reduce(int m, Int32[] ks);
    private static LongArray ReduceResult(Int64[] buf, int off, int len, int m, Int32[] ks);
    private static int ReduceInPlace(Int64[] buf, int off, int len, int m, Int32[] ks);
    private static void ReduceBitWise(Int64[] buf, int off, int BitLength, int m, Int32[] ks);
    private static void ReduceBit(Int64[] buf, int off, int bit, int m, Int32[] ks);
    private static void ReduceWordWise(Int64[] buf, int off, int len, int toBit, int m, Int32[] ks);
    private static void ReduceWord(Int64[] buf, int off, int bit, long word, int m, Int32[] ks);
    private static void ReduceVectorWise(Int64[] buf, int off, int len, int words, int m, Int32[] ks);
    private static void FlipVector(Int64[] x, int xOff, Int64[] y, int yOff, int yLen, int bits);
    public LongArray ModSquare(int m, Int32[] ks);
    public LongArray ModSquareN(int n, int m, Int32[] ks);
    public LongArray Square(int m, Int32[] ks);
    private static void SquareInPlace(Int64[] x, int xLen, int m, Int32[] ks);
    private static void Interleave(Int64[] x, int xOff, Int64[] z, int zOff, int count, int width);
    private static void Interleave3(Int64[] x, int xOff, Int64[] z, int zOff, int count);
    private static long Interleave3(long x);
    private static long Interleave3_21to63(int x);
    private static void Interleave5(Int64[] x, int xOff, Int64[] z, int zOff, int count);
    private static long Interleave5(long x);
    private static long Interleave3_13to65(int x);
    private static void Interleave7(Int64[] x, int xOff, Int64[] z, int zOff, int count);
    private static long Interleave7(long x);
    private static void Interleave2_n(Int64[] x, int xOff, Int64[] z, int zOff, int count, int rounds);
    private static long Interleave2_n(long x, int rounds);
    private static long Interleave4_16to64(int x);
    private static long Interleave2_32to64(int x);
    public LongArray ModInverse(int m, Int32[] ks);
    public virtual bool Equals(object obj);
    public virtual bool Equals(LongArray other);
    public virtual int GetHashCode();
    public LongArray Copy();
    public virtual string ToString();
}
public abstract class Org.BouncyCastle.Math.EC.Multiplier.AbstractECMultiplier : object {
    public virtual ECPoint Multiply(ECPoint p, BigInteger k);
    protected abstract virtual ECPoint MultiplyPositive(ECPoint p, BigInteger k);
    protected virtual ECPoint CheckResult(ECPoint p);
}
[ObsoleteAttribute("Will be removed")]
public class Org.BouncyCastle.Math.EC.Multiplier.DoubleAddMultiplier : AbstractECMultiplier {
    protected virtual ECPoint MultiplyPositive(ECPoint p, BigInteger k);
}
public interface Org.BouncyCastle.Math.EC.Multiplier.ECMultiplier {
    public abstract virtual ECPoint Multiply(ECPoint p, BigInteger k);
}
public class Org.BouncyCastle.Math.EC.Multiplier.FixedPointCombMultiplier : AbstractECMultiplier {
    protected virtual ECPoint MultiplyPositive(ECPoint p, BigInteger k);
}
public class Org.BouncyCastle.Math.EC.Multiplier.FixedPointPreCompInfo : object {
    protected ECPoint m_offset;
    protected ECLookupTable m_lookupTable;
    protected int m_width;
    public ECLookupTable LookupTable { get; public set; }
    public ECPoint Offset { get; public set; }
    public int Width { get; public set; }
    public virtual ECLookupTable get_LookupTable();
    public virtual void set_LookupTable(ECLookupTable value);
    public virtual ECPoint get_Offset();
    public virtual void set_Offset(ECPoint value);
    public virtual int get_Width();
    public virtual void set_Width(int value);
}
public class Org.BouncyCastle.Math.EC.Multiplier.FixedPointUtilities : object {
    public static string PRECOMP_NAME;
    private static FixedPointUtilities();
    public static int GetCombSize(ECCurve c);
    public static FixedPointPreCompInfo GetFixedPointPreCompInfo(PreCompInfo preCompInfo);
    public static FixedPointPreCompInfo Precompute(ECPoint p);
}
public class Org.BouncyCastle.Math.EC.Multiplier.GlvMultiplier : AbstractECMultiplier {
    protected ECCurve curve;
    protected GlvEndomorphism glvEndomorphism;
    public GlvMultiplier(ECCurve curve, GlvEndomorphism glvEndomorphism);
    protected virtual ECPoint MultiplyPositive(ECPoint p, BigInteger k);
}
public interface Org.BouncyCastle.Math.EC.Multiplier.IPreCompCallback {
    public abstract virtual PreCompInfo Precompute(PreCompInfo existing);
}
[ObsoleteAttribute("Will be removed")]
public class Org.BouncyCastle.Math.EC.Multiplier.MixedNafR2LMultiplier : AbstractECMultiplier {
    protected int additionCoord;
    protected int doublingCoord;
    public MixedNafR2LMultiplier(int additionCoord, int doublingCoord);
    protected virtual ECPoint MultiplyPositive(ECPoint p, BigInteger k);
    protected virtual ECCurve ConfigureCurve(ECCurve c, int coord);
}
[ObsoleteAttribute("Will be removed")]
public class Org.BouncyCastle.Math.EC.Multiplier.MontgomeryLadderMultiplier : AbstractECMultiplier {
    protected virtual ECPoint MultiplyPositive(ECPoint p, BigInteger k);
}
[ObsoleteAttribute("Will be removed")]
public class Org.BouncyCastle.Math.EC.Multiplier.NafL2RMultiplier : AbstractECMultiplier {
    protected virtual ECPoint MultiplyPositive(ECPoint p, BigInteger k);
}
[ObsoleteAttribute("Will be removed")]
public class Org.BouncyCastle.Math.EC.Multiplier.NafR2LMultiplier : AbstractECMultiplier {
    protected virtual ECPoint MultiplyPositive(ECPoint p, BigInteger k);
}
public interface Org.BouncyCastle.Math.EC.Multiplier.PreCompInfo {
}
[ObsoleteAttribute("Will be removed")]
public class Org.BouncyCastle.Math.EC.Multiplier.ReferenceMultiplier : AbstractECMultiplier {
    protected virtual ECPoint MultiplyPositive(ECPoint p, BigInteger k);
}
internal class Org.BouncyCastle.Math.EC.Multiplier.ValidityPreCompInfo : object {
    internal static string PRECOMP_NAME;
    private bool failed;
    private bool curveEquationPassed;
    private bool orderPassed;
    private static ValidityPreCompInfo();
    internal bool HasFailed();
    internal void ReportFailed();
    internal bool HasCurveEquationPassed();
    internal void ReportCurveEquationPassed();
    internal bool HasOrderPassed();
    internal void ReportOrderPassed();
}
public class Org.BouncyCastle.Math.EC.Multiplier.WNafL2RMultiplier : AbstractECMultiplier {
    protected virtual ECPoint MultiplyPositive(ECPoint p, BigInteger k);
}
public class Org.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo : object {
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_promotionCountdown;
    protected int m_confWidth;
    protected ECPoint[] m_preComp;
    protected ECPoint[] m_preCompNeg;
    protected ECPoint m_twice;
    protected int m_width;
    internal int PromotionCountdown { get; internal set; }
    public bool IsPromoted { get; }
    public int ConfWidth { get; public set; }
    public ECPoint[] PreComp { get; public set; }
    public ECPoint[] PreCompNeg { get; public set; }
    public ECPoint Twice { get; public set; }
    public int Width { get; public set; }
    internal int DecrementPromotionCountdown();
    internal int get_PromotionCountdown();
    internal void set_PromotionCountdown(int value);
    public virtual bool get_IsPromoted();
    public virtual int get_ConfWidth();
    public virtual void set_ConfWidth(int value);
    public virtual ECPoint[] get_PreComp();
    public virtual void set_PreComp(ECPoint[] value);
    public virtual ECPoint[] get_PreCompNeg();
    public virtual void set_PreCompNeg(ECPoint[] value);
    public virtual ECPoint get_Twice();
    public virtual void set_Twice(ECPoint value);
    public virtual int get_Width();
    public virtual void set_Width(int value);
}
public abstract class Org.BouncyCastle.Math.EC.Multiplier.WNafUtilities : object {
    public static string PRECOMP_NAME;
    private static Int32[] DEFAULT_WINDOW_SIZE_CUTOFFS;
    private static int MAX_WIDTH;
    private static ECPoint[] EMPTY_POINTS;
    private static WNafUtilities();
    public static void ConfigureBasepoint(ECPoint p);
    public static Int32[] GenerateCompactNaf(BigInteger k);
    public static Int32[] GenerateCompactWindowNaf(int width, BigInteger k);
    public static Byte[] GenerateJsf(BigInteger g, BigInteger h);
    public static Byte[] GenerateNaf(BigInteger k);
    public static Byte[] GenerateWindowNaf(int width, BigInteger k);
    public static int GetNafWeight(BigInteger k);
    public static WNafPreCompInfo GetWNafPreCompInfo(ECPoint p);
    public static WNafPreCompInfo GetWNafPreCompInfo(PreCompInfo preCompInfo);
    public static int GetWindowSize(int bits);
    public static int GetWindowSize(int bits, int maxWidth);
    public static int GetWindowSize(int bits, Int32[] windowSizeCutoffs);
    public static int GetWindowSize(int bits, Int32[] windowSizeCutoffs, int maxWidth);
    [ObsoleteAttribute]
public static ECPoint MapPointWithPrecomp(ECPoint p, int minWidth, bool includeNegated, ECPointMap pointMap);
    public static WNafPreCompInfo Precompute(ECPoint p, int minWidth, bool includeNegated);
    public static WNafPreCompInfo PrecomputeWithPointMap(ECPoint p, ECPointMap pointMap, WNafPreCompInfo fromWNaf, bool includeNegated);
    private static Byte[] Trim(Byte[] a, int length);
    private static Int32[] Trim(Int32[] a, int length);
    private static ECPoint[] ResizeTable(ECPoint[] a, int length);
}
public class Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier : AbstractECMultiplier {
    internal static string PRECOMP_NAME;
    private static WTauNafMultiplier();
    protected virtual ECPoint MultiplyPositive(ECPoint point, BigInteger k);
    private AbstractF2mPoint MultiplyWTnaf(AbstractF2mPoint p, ZTauElement lambda, sbyte a, sbyte mu);
    private static AbstractF2mPoint MultiplyFromWTnaf(AbstractF2mPoint p, SByte[] u);
}
public class Org.BouncyCastle.Math.EC.Multiplier.WTauNafPreCompInfo : object {
    protected AbstractF2mPoint[] m_preComp;
    public AbstractF2mPoint[] PreComp { get; public set; }
    public virtual AbstractF2mPoint[] get_PreComp();
    public virtual void set_PreComp(AbstractF2mPoint[] value);
}
[ObsoleteAttribute("Will be removed")]
public class Org.BouncyCastle.Math.EC.Multiplier.ZSignedDigitL2RMultiplier : AbstractECMultiplier {
    protected virtual ECPoint MultiplyPositive(ECPoint p, BigInteger k);
}
[ObsoleteAttribute("Will be removed")]
public class Org.BouncyCastle.Math.EC.Multiplier.ZSignedDigitR2LMultiplier : AbstractECMultiplier {
    protected virtual ECPoint MultiplyPositive(ECPoint p, BigInteger k);
}
public abstract class Org.BouncyCastle.Math.EC.Rfc7748.X25519 : object {
    public static int PointSize;
    public static int ScalarSize;
    private static int C_A;
    private static int C_A24;
    public static bool CalculateAgreement(Byte[] k, int kOff, Byte[] u, int uOff, Byte[] r, int rOff);
    private static UInt32 Decode32(Byte[] bs, int off);
    private static void DecodeScalar(Byte[] k, int kOff, UInt32[] n);
    public static void GeneratePrivateKey(SecureRandom random, Byte[] k);
    public static void GeneratePublicKey(Byte[] k, int kOff, Byte[] r, int rOff);
    private static void PointDouble(Int32[] x, Int32[] z);
    public static void Precompute();
    public static void ScalarMult(Byte[] k, int kOff, Byte[] u, int uOff, Byte[] r, int rOff);
    public static void ScalarMultBase(Byte[] k, int kOff, Byte[] r, int rOff);
}
public abstract class Org.BouncyCastle.Math.EC.Rfc7748.X25519Field : object {
    public static int Size;
    private static int M24;
    private static int M25;
    private static int M26;
    private static UInt32[] P32;
    private static Int32[] RootNegOne;
    private static X25519Field();
    public static void Add(Int32[] x, Int32[] y, Int32[] z);
    public static void AddOne(Int32[] z);
    public static void AddOne(Int32[] z, int zOff);
    public static void Apm(Int32[] x, Int32[] y, Int32[] zp, Int32[] zm);
    public static int AreEqual(Int32[] x, Int32[] y);
    public static bool AreEqualVar(Int32[] x, Int32[] y);
    public static void Carry(Int32[] z);
    public static void CMov(int cond, Int32[] x, int xOff, Int32[] z, int zOff);
    public static void CNegate(int negate, Int32[] z);
    public static void Copy(Int32[] x, int xOff, Int32[] z, int zOff);
    public static Int32[] Create();
    public static Int32[] CreateTable(int n);
    public static void CSwap(int swap, Int32[] a, Int32[] b);
    [CLSCompliantAttribute("False")]
public static void Decode(UInt32[] x, int xOff, Int32[] z);
    public static void Decode(Byte[] x, int xOff, Int32[] z);
    private static void Decode128(UInt32[] x, int xOff, Int32[] z, int zOff);
    private static void Decode128(Byte[] bs, int off, Int32[] z, int zOff);
    private static UInt32 Decode32(Byte[] bs, int off);
    [CLSCompliantAttribute("False")]
public static void Encode(Int32[] x, UInt32[] z, int zOff);
    public static void Encode(Int32[] x, Byte[] z, int zOff);
    private static void Encode128(Int32[] x, int xOff, UInt32[] z, int zOff);
    private static void Encode128(Int32[] x, int xOff, Byte[] bs, int off);
    private static void Encode32(UInt32 n, Byte[] bs, int off);
    public static void Inv(Int32[] x, Int32[] z);
    public static void InvVar(Int32[] x, Int32[] z);
    public static int IsOne(Int32[] x);
    public static bool IsOneVar(Int32[] x);
    public static int IsZero(Int32[] x);
    public static bool IsZeroVar(Int32[] x);
    public static void Mul(Int32[] x, int y, Int32[] z);
    public static void Mul(Int32[] x, Int32[] y, Int32[] z);
    public static void Negate(Int32[] x, Int32[] z);
    public static void Normalize(Int32[] z);
    public static void One(Int32[] z);
    private static void PowPm5d8(Int32[] x, Int32[] rx2, Int32[] rz);
    private static void Reduce(Int32[] z, int x);
    public static void Sqr(Int32[] x, Int32[] z);
    public static void Sqr(Int32[] x, int n, Int32[] z);
    public static bool SqrtRatioVar(Int32[] u, Int32[] v, Int32[] z);
    public static void Sub(Int32[] x, Int32[] y, Int32[] z);
    public static void SubOne(Int32[] z);
    public static void Zero(Int32[] z);
}
public abstract class Org.BouncyCastle.Math.EC.Rfc7748.X448 : object {
    public static int PointSize;
    public static int ScalarSize;
    private static UInt32 C_A;
    private static UInt32 C_A24;
    public static bool CalculateAgreement(Byte[] k, int kOff, Byte[] u, int uOff, Byte[] r, int rOff);
    private static UInt32 Decode32(Byte[] bs, int off);
    private static void DecodeScalar(Byte[] k, int kOff, UInt32[] n);
    public static void GeneratePrivateKey(SecureRandom random, Byte[] k);
    public static void GeneratePublicKey(Byte[] k, int kOff, Byte[] r, int rOff);
    private static void PointDouble(UInt32[] x, UInt32[] z);
    public static void Precompute();
    public static void ScalarMult(Byte[] k, int kOff, Byte[] u, int uOff, Byte[] r, int rOff);
    public static void ScalarMultBase(Byte[] k, int kOff, Byte[] r, int rOff);
}
[CLSCompliantAttribute("False")]
public abstract class Org.BouncyCastle.Math.EC.Rfc7748.X448Field : object {
    public static int Size;
    private static UInt32 M28;
    private static UInt32[] P32;
    private static X448Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddOne(UInt32[] z);
    public static void AddOne(UInt32[] z, int zOff);
    public static int AreEqual(UInt32[] x, UInt32[] y);
    public static bool AreEqualVar(UInt32[] x, UInt32[] y);
    public static void Carry(UInt32[] z);
    public static void CMov(int cond, UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static void CNegate(int negate, UInt32[] z);
    public static void Copy(UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static UInt32[] Create();
    public static UInt32[] CreateTable(int n);
    public static void CSwap(int swap, UInt32[] a, UInt32[] b);
    public static void Decode(UInt32[] x, int xOff, UInt32[] z);
    public static void Decode(Byte[] x, int xOff, UInt32[] z);
    private static void Decode224(UInt32[] x, int xOff, UInt32[] z, int zOff);
    private static UInt32 Decode24(Byte[] bs, int off);
    private static UInt32 Decode32(Byte[] bs, int off);
    private static void Decode56(Byte[] bs, int off, UInt32[] z, int zOff);
    public static void Encode(UInt32[] x, UInt32[] z, int zOff);
    public static void Encode(UInt32[] x, Byte[] z, int zOff);
    private static void Encode224(UInt32[] x, int xOff, UInt32[] z, int zOff);
    private static void Encode24(UInt32 n, Byte[] bs, int off);
    private static void Encode32(UInt32 n, Byte[] bs, int off);
    private static void Encode56(UInt32[] x, int xOff, Byte[] bs, int off);
    public static void Inv(UInt32[] x, UInt32[] z);
    public static void InvVar(UInt32[] x, UInt32[] z);
    public static int IsOne(UInt32[] x);
    public static bool IsOneVar(UInt32[] x);
    public static int IsZero(UInt32[] x);
    public static bool IsZeroVar(UInt32[] x);
    public static void Mul(UInt32[] x, UInt32 y, UInt32[] z);
    public static void Mul(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Normalize(UInt32[] z);
    public static void One(UInt32[] z);
    private static void PowPm3d4(UInt32[] x, UInt32[] z);
    private static void Reduce(UInt32[] z, int x);
    public static void Sqr(UInt32[] x, UInt32[] z);
    public static void Sqr(UInt32[] x, int n, UInt32[] z);
    public static bool SqrtRatioVar(UInt32[] u, UInt32[] v, UInt32[] z);
    public static void Sub(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void SubOne(UInt32[] z);
    public static void Zero(UInt32[] z);
}
public abstract class Org.BouncyCastle.Math.EC.Rfc8032.Ed25519 : object {
    private static long M08L;
    private static long M28L;
    private static long M32L;
    private static int CoordUints;
    private static int PointBytes;
    private static int ScalarUints;
    private static int ScalarBytes;
    public static int PrehashSize;
    public static int PublicKeySize;
    public static int SecretKeySize;
    public static int SignatureSize;
    private static Byte[] Dom2Prefix;
    private static UInt32[] P;
    private static UInt32[] L;
    private static int L0;
    private static int L1;
    private static int L2;
    private static int L3;
    private static int L4;
    private static Int32[] B_x;
    private static Int32[] B_y;
    private static Int32[] C_d;
    private static Int32[] C_d2;
    private static Int32[] C_d4;
    private static int WnafWidthBase;
    private static int PrecompBlocks;
    private static int PrecompTeeth;
    private static int PrecompSpacing;
    private static int PrecompPoints;
    private static int PrecompMask;
    private static object precompLock;
    private static PointExt[] precompBaseTable;
    private static Int32[] precompBase;
    private static Ed25519();
    private static Byte[] CalculateS(Byte[] r, Byte[] k, Byte[] s);
    private static bool CheckContextVar(Byte[] ctx, byte phflag);
    private static int CheckPoint(Int32[] x, Int32[] y);
    private static int CheckPoint(Int32[] x, Int32[] y, Int32[] z);
    private static bool CheckPointVar(Byte[] p);
    private static bool CheckScalarVar(Byte[] s, UInt32[] n);
    private static Byte[] Copy(Byte[] buf, int off, int len);
    private static IDigest CreateDigest();
    public static IDigest CreatePrehash();
    private static UInt32 Decode24(Byte[] bs, int off);
    private static UInt32 Decode32(Byte[] bs, int off);
    private static void Decode32(Byte[] bs, int bsOff, UInt32[] n, int nOff, int nLen);
    private static bool DecodePointVar(Byte[] p, int pOff, bool negate, PointAffine r);
    private static void DecodeScalar(Byte[] k, int kOff, UInt32[] n);
    private static void Dom2(IDigest d, byte phflag, Byte[] ctx);
    private static void Encode24(UInt32 n, Byte[] bs, int off);
    private static void Encode32(UInt32 n, Byte[] bs, int off);
    private static void Encode56(ulong n, Byte[] bs, int off);
    private static int EncodePoint(PointAccum p, Byte[] r, int rOff);
    public static void GeneratePrivateKey(SecureRandom random, Byte[] k);
    public static void GeneratePublicKey(Byte[] sk, int skOff, Byte[] pk, int pkOff);
    private static UInt32 GetWindow4(UInt32[] x, int n);
    private static SByte[] GetWnafVar(UInt32[] n, int width);
    private static void ImplSign(IDigest d, Byte[] h, Byte[] s, Byte[] pk, int pkOff, Byte[] ctx, byte phflag, Byte[] m, int mOff, int mLen, Byte[] sig, int sigOff);
    private static void ImplSign(Byte[] sk, int skOff, Byte[] ctx, byte phflag, Byte[] m, int mOff, int mLen, Byte[] sig, int sigOff);
    private static void ImplSign(Byte[] sk, int skOff, Byte[] pk, int pkOff, Byte[] ctx, byte phflag, Byte[] m, int mOff, int mLen, Byte[] sig, int sigOff);
    private static bool ImplVerify(Byte[] sig, int sigOff, Byte[] pk, int pkOff, Byte[] ctx, byte phflag, Byte[] m, int mOff, int mLen);
    private static bool IsNeutralElementVar(Int32[] x, Int32[] y);
    private static bool IsNeutralElementVar(Int32[] x, Int32[] y, Int32[] z);
    private static void PointAdd(PointExt p, PointAccum r);
    private static void PointAdd(PointExt p, PointExt r);
    private static void PointAddVar(bool negate, PointExt p, PointAccum r);
    private static void PointAddVar(bool negate, PointExt p, PointExt q, PointExt r);
    private static void PointAddPrecomp(PointPrecomp p, PointAccum r);
    private static PointExt PointCopy(PointAccum p);
    private static PointExt PointCopy(PointAffine p);
    private static PointExt PointCopy(PointExt p);
    private static void PointCopy(PointAffine p, PointAccum r);
    private static void PointCopy(PointExt p, PointExt r);
    private static void PointDouble(PointAccum r);
    private static void PointExtendXY(PointAccum p);
    private static void PointExtendXY(PointExt p);
    private static void PointLookup(int block, int index, PointPrecomp p);
    private static void PointLookup(UInt32[] x, int n, Int32[] table, PointExt r);
    private static void PointLookup(Int32[] table, int index, PointExt r);
    private static Int32[] PointPrecompute(PointAffine p, int count);
    private static PointExt[] PointPrecomputeVar(PointExt p, int count);
    private static void PointSetNeutral(PointAccum p);
    private static void PointSetNeutral(PointExt p);
    public static void Precompute();
    private static void PruneScalar(Byte[] n, int nOff, Byte[] r);
    private static Byte[] ReduceScalar(Byte[] n);
    private static void ScalarMult(Byte[] k, PointAffine p, PointAccum r);
    private static void ScalarMultBase(Byte[] k, PointAccum r);
    private static void ScalarMultBaseEncoded(Byte[] k, Byte[] r, int rOff);
    internal static void ScalarMultBaseYZ(Byte[] k, int kOff, Int32[] y, Int32[] z);
    private static void ScalarMultOrderVar(PointAffine p, PointAccum r);
    private static void ScalarMultStrausVar(UInt32[] nb, UInt32[] np, PointAffine p, PointAccum r);
    public static void Sign(Byte[] sk, int skOff, Byte[] m, int mOff, int mLen, Byte[] sig, int sigOff);
    public static void Sign(Byte[] sk, int skOff, Byte[] pk, int pkOff, Byte[] m, int mOff, int mLen, Byte[] sig, int sigOff);
    public static void Sign(Byte[] sk, int skOff, Byte[] ctx, Byte[] m, int mOff, int mLen, Byte[] sig, int sigOff);
    public static void Sign(Byte[] sk, int skOff, Byte[] pk, int pkOff, Byte[] ctx, Byte[] m, int mOff, int mLen, Byte[] sig, int sigOff);
    public static void SignPrehash(Byte[] sk, int skOff, Byte[] ctx, Byte[] ph, int phOff, Byte[] sig, int sigOff);
    public static void SignPrehash(Byte[] sk, int skOff, Byte[] pk, int pkOff, Byte[] ctx, Byte[] ph, int phOff, Byte[] sig, int sigOff);
    public static void SignPrehash(Byte[] sk, int skOff, Byte[] ctx, IDigest ph, Byte[] sig, int sigOff);
    public static void SignPrehash(Byte[] sk, int skOff, Byte[] pk, int pkOff, Byte[] ctx, IDigest ph, Byte[] sig, int sigOff);
    public static bool ValidatePublicKeyFull(Byte[] pk, int pkOff);
    public static bool ValidatePublicKeyPartial(Byte[] pk, int pkOff);
    public static bool Verify(Byte[] sig, int sigOff, Byte[] pk, int pkOff, Byte[] m, int mOff, int mLen);
    public static bool Verify(Byte[] sig, int sigOff, Byte[] pk, int pkOff, Byte[] ctx, Byte[] m, int mOff, int mLen);
    public static bool VerifyPrehash(Byte[] sig, int sigOff, Byte[] pk, int pkOff, Byte[] ctx, Byte[] ph, int phOff);
    public static bool VerifyPrehash(Byte[] sig, int sigOff, Byte[] pk, int pkOff, Byte[] ctx, IDigest ph);
}
public abstract class Org.BouncyCastle.Math.EC.Rfc8032.Ed448 : object {
    private static ulong M26UL;
    private static ulong M28UL;
    private static int CoordUints;
    private static int PointBytes;
    private static int ScalarUints;
    private static int ScalarBytes;
    public static int PrehashSize;
    public static int PublicKeySize;
    public static int SecretKeySize;
    public static int SignatureSize;
    private static Byte[] Dom4Prefix;
    private static UInt32[] P;
    private static UInt32[] L;
    private static int L_0;
    private static int L_1;
    private static int L_2;
    private static int L_3;
    private static int L_4;
    private static int L_5;
    private static int L_6;
    private static int L_7;
    private static int L4_0;
    private static int L4_1;
    private static int L4_2;
    private static int L4_3;
    private static int L4_4;
    private static int L4_5;
    private static int L4_6;
    private static int L4_7;
    private static UInt32[] B_x;
    private static UInt32[] B_y;
    private static int C_d;
    private static int WnafWidthBase;
    private static int PrecompBlocks;
    private static int PrecompTeeth;
    private static int PrecompSpacing;
    private static int PrecompPoints;
    private static int PrecompMask;
    private static object precompLock;
    private static PointExt[] precompBaseTable;
    private static UInt32[] precompBase;
    private static Ed448();
    private static Byte[] CalculateS(Byte[] r, Byte[] k, Byte[] s);
    private static bool CheckContextVar(Byte[] ctx);
    private static int CheckPoint(UInt32[] x, UInt32[] y);
    private static int CheckPoint(UInt32[] x, UInt32[] y, UInt32[] z);
    private static bool CheckPointVar(Byte[] p);
    private static bool CheckScalarVar(Byte[] s, UInt32[] n);
    private static Byte[] Copy(Byte[] buf, int off, int len);
    public static IXof CreatePrehash();
    private static IXof CreateXof();
    private static UInt32 Decode16(Byte[] bs, int off);
    private static UInt32 Decode24(Byte[] bs, int off);
    private static UInt32 Decode32(Byte[] bs, int off);
    private static void Decode32(Byte[] bs, int bsOff, UInt32[] n, int nOff, int nLen);
    private static bool DecodePointVar(Byte[] p, int pOff, bool negate, PointExt r);
    private static void DecodeScalar(Byte[] k, int kOff, UInt32[] n);
    private static void Dom4(IXof d, byte phflag, Byte[] ctx);
    private static void Encode24(UInt32 n, Byte[] bs, int off);
    private static void Encode32(UInt32 n, Byte[] bs, int off);
    private static void Encode56(ulong n, Byte[] bs, int off);
    private static int EncodePoint(PointExt p, Byte[] r, int rOff);
    public static void GeneratePrivateKey(SecureRandom random, Byte[] k);
    public static void GeneratePublicKey(Byte[] sk, int skOff, Byte[] pk, int pkOff);
    private static UInt32 GetWindow4(UInt32[] x, int n);
    private static SByte[] GetWnafVar(UInt32[] n, int width);
    private static void ImplSign(IXof d, Byte[] h, Byte[] s, Byte[] pk, int pkOff, Byte[] ctx, byte phflag, Byte[] m, int mOff, int mLen, Byte[] sig, int sigOff);
    private static void ImplSign(Byte[] sk, int skOff, Byte[] ctx, byte phflag, Byte[] m, int mOff, int mLen, Byte[] sig, int sigOff);
    private static void ImplSign(Byte[] sk, int skOff, Byte[] pk, int pkOff, Byte[] ctx, byte phflag, Byte[] m, int mOff, int mLen, Byte[] sig, int sigOff);
    private static bool ImplVerify(Byte[] sig, int sigOff, Byte[] pk, int pkOff, Byte[] ctx, byte phflag, Byte[] m, int mOff, int mLen);
    private static bool IsNeutralElementVar(UInt32[] x, UInt32[] y);
    private static bool IsNeutralElementVar(UInt32[] x, UInt32[] y, UInt32[] z);
    private static void PointAdd(PointExt p, PointExt r);
    private static void PointAddVar(bool negate, PointExt p, PointExt r);
    private static void PointAddPrecomp(PointPrecomp p, PointExt r);
    private static PointExt PointCopy(PointExt p);
    private static void PointCopy(PointExt p, PointExt r);
    private static void PointDouble(PointExt r);
    private static void PointExtendXY(PointExt p);
    private static void PointLookup(int block, int index, PointPrecomp p);
    private static void PointLookup(UInt32[] x, int n, UInt32[] table, PointExt r);
    private static UInt32[] PointPrecompute(PointExt p, int count);
    private static PointExt[] PointPrecomputeVar(PointExt p, int count);
    private static void PointSetNeutral(PointExt p);
    public static void Precompute();
    private static void PruneScalar(Byte[] n, int nOff, Byte[] r);
    private static Byte[] ReduceScalar(Byte[] n);
    private static void ScalarMult(Byte[] k, PointExt p, PointExt r);
    private static void ScalarMultBase(Byte[] k, PointExt r);
    private static void ScalarMultBaseEncoded(Byte[] k, Byte[] r, int rOff);
    internal static void ScalarMultBaseXY(Byte[] k, int kOff, UInt32[] x, UInt32[] y);
    private static void ScalarMultOrderVar(PointExt p, PointExt r);
    private static void ScalarMultStrausVar(UInt32[] nb, UInt32[] np, PointExt p, PointExt r);
    public static void Sign(Byte[] sk, int skOff, Byte[] ctx, Byte[] m, int mOff, int mLen, Byte[] sig, int sigOff);
    public static void Sign(Byte[] sk, int skOff, Byte[] pk, int pkOff, Byte[] ctx, Byte[] m, int mOff, int mLen, Byte[] sig, int sigOff);
    public static void SignPrehash(Byte[] sk, int skOff, Byte[] ctx, Byte[] ph, int phOff, Byte[] sig, int sigOff);
    public static void SignPrehash(Byte[] sk, int skOff, Byte[] pk, int pkOff, Byte[] ctx, Byte[] ph, int phOff, Byte[] sig, int sigOff);
    public static void SignPrehash(Byte[] sk, int skOff, Byte[] ctx, IXof ph, Byte[] sig, int sigOff);
    public static void SignPrehash(Byte[] sk, int skOff, Byte[] pk, int pkOff, Byte[] ctx, IXof ph, Byte[] sig, int sigOff);
    public static bool ValidatePublicKeyFull(Byte[] pk, int pkOff);
    public static bool ValidatePublicKeyPartial(Byte[] pk, int pkOff);
    public static bool Verify(Byte[] sig, int sigOff, Byte[] pk, int pkOff, Byte[] ctx, Byte[] m, int mOff, int mLen);
    public static bool VerifyPrehash(Byte[] sig, int sigOff, Byte[] pk, int pkOff, Byte[] ctx, Byte[] ph, int phOff);
    public static bool VerifyPrehash(Byte[] sig, int sigOff, Byte[] pk, int pkOff, Byte[] ctx, IXof ph);
}
public class Org.BouncyCastle.Math.EC.ScaleXNegateYPointMap : object {
    protected ECFieldElement scale;
    public ScaleXNegateYPointMap(ECFieldElement scale);
    public virtual ECPoint Map(ECPoint p);
}
public class Org.BouncyCastle.Math.EC.ScaleXPointMap : object {
    protected ECFieldElement scale;
    public ScaleXPointMap(ECFieldElement scale);
    public virtual ECPoint Map(ECPoint p);
}
public class Org.BouncyCastle.Math.EC.ScaleYNegateXPointMap : object {
    protected ECFieldElement scale;
    public ScaleYNegateXPointMap(ECFieldElement scale);
    public virtual ECPoint Map(ECPoint p);
}
public class Org.BouncyCastle.Math.EC.ScaleYPointMap : object {
    protected ECFieldElement scale;
    public ScaleYPointMap(ECFieldElement scale);
    public virtual ECPoint Map(ECPoint p);
}
public class Org.BouncyCastle.Math.EC.SimpleLookupTable : AbstractECLookupTable {
    private ECPoint[] points;
    public int Size { get; }
    public SimpleLookupTable(ECPoint[] points, int off, int len);
    private static ECPoint[] Copy(ECPoint[] points, int off, int len);
    public virtual int get_Size();
    public virtual ECPoint Lookup(int index);
    public virtual ECPoint LookupVar(int index);
}
public abstract class Org.BouncyCastle.Math.Field.FiniteFields : object {
    internal static IFiniteField GF_2;
    internal static IFiniteField GF_3;
    private static FiniteFields();
    public static IPolynomialExtensionField GetBinaryExtensionField(Int32[] exponents);
    public static IFiniteField GetPrimeField(BigInteger characteristic);
}
internal class Org.BouncyCastle.Math.Field.GenericPolynomialExtensionField : object {
    protected IFiniteField subfield;
    protected IPolynomial minimalPolynomial;
    public BigInteger Characteristic { get; }
    public int Dimension { get; }
    public IFiniteField Subfield { get; }
    public int Degree { get; }
    public IPolynomial MinimalPolynomial { get; }
    internal GenericPolynomialExtensionField(IFiniteField subfield, IPolynomial polynomial);
    public virtual BigInteger get_Characteristic();
    public virtual int get_Dimension();
    public virtual IFiniteField get_Subfield();
    public virtual int get_Degree();
    public virtual IPolynomial get_MinimalPolynomial();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.Field.GF2Polynomial : object {
    protected Int32[] exponents;
    public int Degree { get; }
    internal GF2Polynomial(Int32[] exponents);
    public virtual int get_Degree();
    public virtual Int32[] GetExponentsPresent();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public interface Org.BouncyCastle.Math.Field.IExtensionField {
    public IFiniteField Subfield { get; }
    public int Degree { get; }
    public abstract virtual IFiniteField get_Subfield();
    public abstract virtual int get_Degree();
}
public interface Org.BouncyCastle.Math.Field.IFiniteField {
    public BigInteger Characteristic { get; }
    public int Dimension { get; }
    public abstract virtual BigInteger get_Characteristic();
    public abstract virtual int get_Dimension();
}
public interface Org.BouncyCastle.Math.Field.IPolynomial {
    public int Degree { get; }
    public abstract virtual int get_Degree();
    public abstract virtual Int32[] GetExponentsPresent();
}
public interface Org.BouncyCastle.Math.Field.IPolynomialExtensionField {
    public IPolynomial MinimalPolynomial { get; }
    public abstract virtual IPolynomial get_MinimalPolynomial();
}
internal class Org.BouncyCastle.Math.Field.PrimeField : object {
    protected BigInteger characteristic;
    public BigInteger Characteristic { get; }
    public int Dimension { get; }
    internal PrimeField(BigInteger characteristic);
    public virtual BigInteger get_Characteristic();
    public virtual int get_Dimension();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class Org.BouncyCastle.Math.Primes : object {
    public static int SmallFactorLimit;
    private static BigInteger One;
    private static BigInteger Two;
    private static BigInteger Three;
    private static Primes();
    public static STOutput GenerateSTRandomPrime(IDigest hash, int length, Byte[] inputSeed);
    public static MROutput EnhancedMRProbablePrimeTest(BigInteger candidate, SecureRandom random, int iterations);
    public static bool HasAnySmallFactors(BigInteger candidate);
    public static bool IsMRProbablePrime(BigInteger candidate, SecureRandom random, int iterations);
    public static bool IsMRProbablePrimeToBase(BigInteger candidate, BigInteger baseValue);
    private static void CheckCandidate(BigInteger n, string name);
    private static bool ImplHasAnySmallFactors(BigInteger x);
    private static bool ImplMRProbablePrimeToBase(BigInteger w, BigInteger wSubOne, BigInteger m, int a, BigInteger b);
    private static STOutput ImplSTRandomPrime(IDigest d, int length, Byte[] primeSeed);
    private static UInt32 Extract32(Byte[] bs);
    private static void Hash(IDigest d, Byte[] input, Byte[] output, int outPos);
    private static BigInteger HashGen(IDigest d, Byte[] seed, int count);
    private static void Inc(Byte[] seed, int c);
    private static bool IsPrime32(UInt32 x);
}
internal abstract class Org.BouncyCastle.Math.Raw.Bits : object {
    internal static UInt32 BitPermuteStep(UInt32 x, UInt32 m, int s);
    internal static ulong BitPermuteStep(ulong x, ulong m, int s);
    internal static UInt32 BitPermuteStepSimple(UInt32 x, UInt32 m, int s);
    internal static ulong BitPermuteStepSimple(ulong x, ulong m, int s);
}
internal abstract class Org.BouncyCastle.Math.Raw.Interleave : object {
    private static ulong M32;
    private static ulong M64;
    private static ulong M64R;
    internal static UInt32 Expand8to16(UInt32 x);
    internal static UInt32 Expand16to32(UInt32 x);
    internal static ulong Expand32to64(UInt32 x);
    internal static void Expand64To128(ulong x, UInt64[] z, int zOff);
    internal static void Expand64To128(UInt64[] xs, int xsOff, int xsLen, UInt64[] zs, int zsOff);
    internal static void Expand64To128Rev(ulong x, UInt64[] z, int zOff);
    internal static UInt32 Shuffle(UInt32 x);
    internal static ulong Shuffle(ulong x);
    internal static UInt32 Shuffle2(UInt32 x);
    internal static UInt32 Unshuffle(UInt32 x);
    internal static ulong Unshuffle(ulong x);
    internal static UInt32 Unshuffle2(UInt32 x);
}
internal abstract class Org.BouncyCastle.Math.Raw.Mod : object {
    private static SecureRandom RandomSource;
    private static int M30;
    private static ulong M32UL;
    private static Mod();
    public static void CheckedModOddInverse(UInt32[] m, UInt32[] x, UInt32[] z);
    public static void CheckedModOddInverseVar(UInt32[] m, UInt32[] x, UInt32[] z);
    public static UInt32 Inverse32(UInt32 d);
    public static UInt32 ModOddInverse(UInt32[] m, UInt32[] x, UInt32[] z);
    public static bool ModOddInverseVar(UInt32[] m, UInt32[] x, UInt32[] z);
    public static UInt32[] Random(UInt32[] p);
    private static int Add30(int len30, Int32[] D, Int32[] M);
    private static void CNegate30(int len30, int cond, Int32[] D);
    private static void CNormalize30(int len30, int condNegate, Int32[] D, Int32[] M);
    private static void Decode30(int bits, Int32[] x, int xOff, UInt32[] z, int zOff);
    private static int Divsteps30(int eta, int f0, int g0, Int32[] t);
    private static int Divsteps30Var(int eta, int f0, int g0, Int32[] t);
    private static void Encode30(int bits, UInt32[] x, int xOff, Int32[] z, int zOff);
    private static int EqualTo(int len, Int32[] x, int y);
    private static int EqualToZero(int len, Int32[] x);
    private static int GetMaximumDivsteps(int bits);
    private static bool IsOne(int len, Int32[] x);
    private static bool IsZero(int len, Int32[] x);
    private static int Negate30(int len30, Int32[] D);
    private static void UpdateDE30(int len30, Int32[] D, Int32[] E, Int32[] t, int m0Inv32, Int32[] M);
    private static void UpdateFG30(int len30, Int32[] F, Int32[] G, Int32[] t);
}
internal abstract class Org.BouncyCastle.Math.Raw.Nat : object {
    private static ulong M;
    public static UInt32 Add(int len, UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 Add33At(int len, UInt32 x, UInt32[] z, int zPos);
    public static UInt32 Add33At(int len, UInt32 x, UInt32[] z, int zOff, int zPos);
    public static UInt32 Add33To(int len, UInt32 x, UInt32[] z);
    public static UInt32 Add33To(int len, UInt32 x, UInt32[] z, int zOff);
    public static UInt32 AddBothTo(int len, UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 AddBothTo(int len, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 AddDWordAt(int len, ulong x, UInt32[] z, int zPos);
    public static UInt32 AddDWordAt(int len, ulong x, UInt32[] z, int zOff, int zPos);
    public static UInt32 AddDWordTo(int len, ulong x, UInt32[] z);
    public static UInt32 AddDWordTo(int len, ulong x, UInt32[] z, int zOff);
    public static UInt32 AddTo(int len, UInt32[] x, UInt32[] z);
    public static UInt32 AddTo(int len, UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static UInt32 AddTo(int len, UInt32[] x, int xOff, UInt32[] z, int zOff, UInt32 cIn);
    public static UInt32 AddToEachOther(int len, UInt32[] u, int uOff, UInt32[] v, int vOff);
    public static UInt32 AddWordAt(int len, UInt32 x, UInt32[] z, int zPos);
    public static UInt32 AddWordAt(int len, UInt32 x, UInt32[] z, int zOff, int zPos);
    public static UInt32 AddWordTo(int len, UInt32 x, UInt32[] z);
    public static UInt32 AddWordTo(int len, UInt32 x, UInt32[] z, int zOff);
    public static UInt32 CAdd(int len, int mask, UInt32[] x, UInt32[] y, UInt32[] z);
    public static void CMov(int len, int mask, UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static void CMov(int len, int mask, Int32[] x, int xOff, Int32[] z, int zOff);
    public static int Compare(int len, UInt32[] x, UInt32[] y);
    public static int Compare(int len, UInt32[] x, int xOff, UInt32[] y, int yOff);
    public static void Copy(int len, UInt32[] x, UInt32[] z);
    public static UInt32[] Copy(int len, UInt32[] x);
    public static void Copy(int len, UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static UInt64[] Copy64(int len, UInt64[] x);
    public static void Copy64(int len, UInt64[] x, UInt64[] z);
    public static void Copy64(int len, UInt64[] x, int xOff, UInt64[] z, int zOff);
    public static UInt32[] Create(int len);
    public static UInt64[] Create64(int len);
    public static int CSub(int len, int mask, UInt32[] x, UInt32[] y, UInt32[] z);
    public static int CSub(int len, int mask, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static int Dec(int len, UInt32[] z);
    public static int Dec(int len, UInt32[] x, UInt32[] z);
    public static int DecAt(int len, UInt32[] z, int zPos);
    public static int DecAt(int len, UInt32[] z, int zOff, int zPos);
    public static bool Eq(int len, UInt32[] x, UInt32[] y);
    public static UInt32 EqualTo(int len, UInt32[] x, UInt32 y);
    public static UInt32 EqualTo(int len, UInt32[] x, int xOff, UInt32 y);
    public static UInt32 EqualTo(int len, UInt32[] x, UInt32[] y);
    public static UInt32 EqualTo(int len, UInt32[] x, int xOff, UInt32[] y, int yOff);
    public static UInt32 EqualToZero(int len, UInt32[] x);
    public static UInt32 EqualToZero(int len, UInt32[] x, int xOff);
    public static UInt32[] FromBigInteger(int bits, BigInteger x);
    public static UInt64[] FromBigInteger64(int bits, BigInteger x);
    public static UInt32 GetBit(UInt32[] x, int bit);
    public static bool Gte(int len, UInt32[] x, UInt32[] y);
    public static UInt32 Inc(int len, UInt32[] z);
    public static UInt32 Inc(int len, UInt32[] x, UInt32[] z);
    public static UInt32 IncAt(int len, UInt32[] z, int zPos);
    public static UInt32 IncAt(int len, UInt32[] z, int zOff, int zPos);
    public static bool IsOne(int len, UInt32[] x);
    public static bool IsZero(int len, UInt32[] x);
    public static int LessThan(int len, UInt32[] x, UInt32[] y);
    public static int LessThan(int len, UInt32[] x, int xOff, UInt32[] y, int yOff);
    public static void Mul(int len, UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Mul(int len, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] zz, int zzOff);
    public static void Mul(UInt32[] x, int xOff, int xLen, UInt32[] y, int yOff, int yLen, UInt32[] zz, int zzOff);
    public static UInt32 MulAddTo(int len, UInt32[] x, UInt32[] y, UInt32[] zz);
    public static UInt32 MulAddTo(int len, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] zz, int zzOff);
    public static UInt32 Mul31BothAdd(int len, UInt32 a, UInt32[] x, UInt32 b, UInt32[] y, UInt32[] z, int zOff);
    public static UInt32 MulWord(int len, UInt32 x, UInt32[] y, UInt32[] z);
    public static UInt32 MulWord(int len, UInt32 x, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 MulWordAddTo(int len, UInt32 x, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 MulWordDwordAddAt(int len, UInt32 x, ulong y, UInt32[] z, int zPos);
    public static UInt32 ShiftDownBit(int len, UInt32[] z, UInt32 c);
    public static UInt32 ShiftDownBit(int len, UInt32[] z, int zOff, UInt32 c);
    public static UInt32 ShiftDownBit(int len, UInt32[] x, UInt32 c, UInt32[] z);
    public static UInt32 ShiftDownBit(int len, UInt32[] x, int xOff, UInt32 c, UInt32[] z, int zOff);
    public static UInt32 ShiftDownBits(int len, UInt32[] z, int bits, UInt32 c);
    public static UInt32 ShiftDownBits(int len, UInt32[] z, int zOff, int bits, UInt32 c);
    public static UInt32 ShiftDownBits(int len, UInt32[] x, int bits, UInt32 c, UInt32[] z);
    public static UInt32 ShiftDownBits(int len, UInt32[] x, int xOff, int bits, UInt32 c, UInt32[] z, int zOff);
    public static UInt32 ShiftDownWord(int len, UInt32[] z, UInt32 c);
    public static UInt32 ShiftUpBit(int len, UInt32[] z, UInt32 c);
    public static UInt32 ShiftUpBit(int len, UInt32[] z, int zOff, UInt32 c);
    public static UInt32 ShiftUpBit(int len, UInt32[] x, UInt32 c, UInt32[] z);
    public static UInt32 ShiftUpBit(int len, UInt32[] x, int xOff, UInt32 c, UInt32[] z, int zOff);
    public static ulong ShiftUpBit64(int len, UInt64[] x, int xOff, ulong c, UInt64[] z, int zOff);
    public static UInt32 ShiftUpBits(int len, UInt32[] z, int bits, UInt32 c);
    public static UInt32 ShiftUpBits(int len, UInt32[] z, int zOff, int bits, UInt32 c);
    public static ulong ShiftUpBits64(int len, UInt64[] z, int zOff, int bits, ulong c);
    public static UInt32 ShiftUpBits(int len, UInt32[] x, int bits, UInt32 c, UInt32[] z);
    public static UInt32 ShiftUpBits(int len, UInt32[] x, int xOff, int bits, UInt32 c, UInt32[] z, int zOff);
    public static ulong ShiftUpBits64(int len, UInt64[] x, int xOff, int bits, ulong c, UInt64[] z, int zOff);
    public static void Square(int len, UInt32[] x, UInt32[] zz);
    public static void Square(int len, UInt32[] x, int xOff, UInt32[] zz, int zzOff);
    [ObsoleteAttribute("Use 'SquareWordAddTo' instead")]
public static UInt32 SquareWordAdd(UInt32[] x, int xPos, UInt32[] z);
    [ObsoleteAttribute("Use 'SquareWordAddTo' instead")]
public static UInt32 SquareWordAdd(UInt32[] x, int xOff, int xPos, UInt32[] z, int zOff);
    public static UInt32 SquareWordAddTo(UInt32[] x, int xPos, UInt32[] z);
    public static UInt32 SquareWordAddTo(UInt32[] x, int xOff, int xPos, UInt32[] z, int zOff);
    public static int Sub(int len, UInt32[] x, UInt32[] y, UInt32[] z);
    public static int Sub(int len, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static int Sub33At(int len, UInt32 x, UInt32[] z, int zPos);
    public static int Sub33At(int len, UInt32 x, UInt32[] z, int zOff, int zPos);
    public static int Sub33From(int len, UInt32 x, UInt32[] z);
    public static int Sub33From(int len, UInt32 x, UInt32[] z, int zOff);
    public static int SubBothFrom(int len, UInt32[] x, UInt32[] y, UInt32[] z);
    public static int SubBothFrom(int len, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static int SubDWordAt(int len, ulong x, UInt32[] z, int zPos);
    public static int SubDWordAt(int len, ulong x, UInt32[] z, int zOff, int zPos);
    public static int SubDWordFrom(int len, ulong x, UInt32[] z);
    public static int SubDWordFrom(int len, ulong x, UInt32[] z, int zOff);
    public static int SubFrom(int len, UInt32[] x, UInt32[] z);
    public static int SubFrom(int len, UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static int SubWordAt(int len, UInt32 x, UInt32[] z, int zPos);
    public static int SubWordAt(int len, UInt32 x, UInt32[] z, int zOff, int zPos);
    public static int SubWordFrom(int len, UInt32 x, UInt32[] z);
    public static int SubWordFrom(int len, UInt32 x, UInt32[] z, int zOff);
    public static BigInteger ToBigInteger(int len, UInt32[] x);
    public static void Zero(int len, UInt32[] z);
    public static void Zero64(int len, UInt64[] z);
}
internal abstract class Org.BouncyCastle.Math.Raw.Nat128 : object {
    private static ulong M;
    public static UInt32 Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 AddBothTo(UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 AddTo(UInt32[] x, UInt32[] z);
    public static UInt32 AddTo(UInt32[] x, int xOff, UInt32[] z, int zOff, UInt32 cIn);
    public static UInt32 AddToEachOther(UInt32[] u, int uOff, UInt32[] v, int vOff);
    public static void Copy(UInt32[] x, UInt32[] z);
    public static void Copy(UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static void Copy64(UInt64[] x, UInt64[] z);
    public static void Copy64(UInt64[] x, int xOff, UInt64[] z, int zOff);
    public static UInt32[] Create();
    public static UInt64[] Create64();
    public static UInt32[] CreateExt();
    public static UInt64[] CreateExt64();
    public static bool Diff(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static bool Eq(UInt32[] x, UInt32[] y);
    public static bool Eq64(UInt64[] x, UInt64[] y);
    public static UInt32 GetBit(UInt32[] x, int bit);
    public static bool Gte(UInt32[] x, UInt32[] y);
    public static bool Gte(UInt32[] x, int xOff, UInt32[] y, int yOff);
    public static bool IsOne(UInt32[] x);
    public static bool IsOne64(UInt64[] x);
    public static bool IsZero(UInt32[] x);
    public static bool IsZero64(UInt64[] x);
    public static void Mul(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Mul(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] zz, int zzOff);
    public static UInt32 MulAddTo(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static UInt32 MulAddTo(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] zz, int zzOff);
    public static ulong Mul33Add(UInt32 w, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 MulWordAddExt(UInt32 x, UInt32[] yy, int yyOff, UInt32[] zz, int zzOff);
    public static UInt32 Mul33DWordAdd(UInt32 x, ulong y, UInt32[] z, int zOff);
    public static UInt32 Mul33WordAdd(UInt32 x, UInt32 y, UInt32[] z, int zOff);
    public static UInt32 MulWordDwordAdd(UInt32 x, ulong y, UInt32[] z, int zOff);
    public static UInt32 MulWordsAdd(UInt32 x, UInt32 y, UInt32[] z, int zOff);
    public static UInt32 MulWord(UInt32 x, UInt32[] y, UInt32[] z, int zOff);
    public static void Square(UInt32[] x, UInt32[] zz);
    public static void Square(UInt32[] x, int xOff, UInt32[] zz, int zzOff);
    public static int Sub(UInt32[] x, UInt32[] y, UInt32[] z);
    public static int Sub(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static int SubBothFrom(UInt32[] x, UInt32[] y, UInt32[] z);
    public static int SubFrom(UInt32[] x, UInt32[] z);
    public static int SubFrom(UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static BigInteger ToBigInteger(UInt32[] x);
    public static BigInteger ToBigInteger64(UInt64[] x);
    public static void Zero(UInt32[] z);
}
internal abstract class Org.BouncyCastle.Math.Raw.Nat160 : object {
    private static ulong M;
    public static UInt32 Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 AddBothTo(UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 AddTo(UInt32[] x, UInt32[] z);
    public static UInt32 AddTo(UInt32[] x, int xOff, UInt32[] z, int zOff, UInt32 cIn);
    public static UInt32 AddToEachOther(UInt32[] u, int uOff, UInt32[] v, int vOff);
    public static void Copy(UInt32[] x, UInt32[] z);
    public static void Copy(UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static UInt32[] Create();
    public static UInt32[] CreateExt();
    public static bool Diff(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static bool Eq(UInt32[] x, UInt32[] y);
    public static UInt32 GetBit(UInt32[] x, int bit);
    public static bool Gte(UInt32[] x, UInt32[] y);
    public static bool Gte(UInt32[] x, int xOff, UInt32[] y, int yOff);
    public static bool IsOne(UInt32[] x);
    public static bool IsZero(UInt32[] x);
    public static void Mul(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Mul(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] zz, int zzOff);
    public static UInt32 MulAddTo(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static UInt32 MulAddTo(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] zz, int zzOff);
    public static ulong Mul33Add(UInt32 w, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 MulWordAddExt(UInt32 x, UInt32[] yy, int yyOff, UInt32[] zz, int zzOff);
    public static UInt32 Mul33DWordAdd(UInt32 x, ulong y, UInt32[] z, int zOff);
    public static UInt32 Mul33WordAdd(UInt32 x, UInt32 y, UInt32[] z, int zOff);
    public static UInt32 MulWordDwordAdd(UInt32 x, ulong y, UInt32[] z, int zOff);
    public static UInt32 MulWordsAdd(UInt32 x, UInt32 y, UInt32[] z, int zOff);
    public static UInt32 MulWord(UInt32 x, UInt32[] y, UInt32[] z, int zOff);
    public static void Square(UInt32[] x, UInt32[] zz);
    public static void Square(UInt32[] x, int xOff, UInt32[] zz, int zzOff);
    public static int Sub(UInt32[] x, UInt32[] y, UInt32[] z);
    public static int Sub(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static int SubBothFrom(UInt32[] x, UInt32[] y, UInt32[] z);
    public static int SubFrom(UInt32[] x, UInt32[] z);
    public static int SubFrom(UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static BigInteger ToBigInteger(UInt32[] x);
    public static void Zero(UInt32[] z);
}
internal abstract class Org.BouncyCastle.Math.Raw.Nat192 : object {
    private static ulong M;
    public static UInt32 Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 AddBothTo(UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 AddTo(UInt32[] x, UInt32[] z);
    public static UInt32 AddTo(UInt32[] x, int xOff, UInt32[] z, int zOff, UInt32 cIn);
    public static UInt32 AddToEachOther(UInt32[] u, int uOff, UInt32[] v, int vOff);
    public static void Copy(UInt32[] x, UInt32[] z);
    public static void Copy(UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static void Copy64(UInt64[] x, UInt64[] z);
    public static void Copy64(UInt64[] x, int xOff, UInt64[] z, int zOff);
    public static UInt32[] Create();
    public static UInt64[] Create64();
    public static UInt32[] CreateExt();
    public static UInt64[] CreateExt64();
    public static bool Diff(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static bool Eq(UInt32[] x, UInt32[] y);
    public static bool Eq64(UInt64[] x, UInt64[] y);
    public static UInt32 GetBit(UInt32[] x, int bit);
    public static bool Gte(UInt32[] x, UInt32[] y);
    public static bool Gte(UInt32[] x, int xOff, UInt32[] y, int yOff);
    public static bool IsOne(UInt32[] x);
    public static bool IsOne64(UInt64[] x);
    public static bool IsZero(UInt32[] x);
    public static bool IsZero64(UInt64[] x);
    public static void Mul(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Mul(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] zz, int zzOff);
    public static UInt32 MulAddTo(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static UInt32 MulAddTo(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] zz, int zzOff);
    public static ulong Mul33Add(UInt32 w, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 MulWordAddExt(UInt32 x, UInt32[] yy, int yyOff, UInt32[] zz, int zzOff);
    public static UInt32 Mul33DWordAdd(UInt32 x, ulong y, UInt32[] z, int zOff);
    public static UInt32 Mul33WordAdd(UInt32 x, UInt32 y, UInt32[] z, int zOff);
    public static UInt32 MulWordDwordAdd(UInt32 x, ulong y, UInt32[] z, int zOff);
    public static UInt32 MulWord(UInt32 x, UInt32[] y, UInt32[] z, int zOff);
    public static void Square(UInt32[] x, UInt32[] zz);
    public static void Square(UInt32[] x, int xOff, UInt32[] zz, int zzOff);
    public static int Sub(UInt32[] x, UInt32[] y, UInt32[] z);
    public static int Sub(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static int SubBothFrom(UInt32[] x, UInt32[] y, UInt32[] z);
    public static int SubFrom(UInt32[] x, UInt32[] z);
    public static int SubFrom(UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static BigInteger ToBigInteger(UInt32[] x);
    public static BigInteger ToBigInteger64(UInt64[] x);
    public static void Zero(UInt32[] z);
}
internal abstract class Org.BouncyCastle.Math.Raw.Nat224 : object {
    private static ulong M;
    public static UInt32 Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 Add(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 AddBothTo(UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 AddBothTo(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 AddTo(UInt32[] x, UInt32[] z);
    public static UInt32 AddTo(UInt32[] x, int xOff, UInt32[] z, int zOff, UInt32 cIn);
    public static UInt32 AddToEachOther(UInt32[] u, int uOff, UInt32[] v, int vOff);
    public static void Copy(UInt32[] x, UInt32[] z);
    public static void Copy(UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static UInt32[] Create();
    public static UInt32[] CreateExt();
    public static bool Diff(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static bool Eq(UInt32[] x, UInt32[] y);
    public static UInt32 GetBit(UInt32[] x, int bit);
    public static bool Gte(UInt32[] x, UInt32[] y);
    public static bool Gte(UInt32[] x, int xOff, UInt32[] y, int yOff);
    public static bool IsOne(UInt32[] x);
    public static bool IsZero(UInt32[] x);
    public static void Mul(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Mul(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] zz, int zzOff);
    public static UInt32 MulAddTo(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static UInt32 MulAddTo(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] zz, int zzOff);
    public static ulong Mul33Add(UInt32 w, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 MulByWord(UInt32 x, UInt32[] z);
    public static UInt32 MulByWordAddTo(UInt32 x, UInt32[] y, UInt32[] z);
    public static UInt32 MulWordAddTo(UInt32 x, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 Mul33DWordAdd(UInt32 x, ulong y, UInt32[] z, int zOff);
    public static UInt32 Mul33WordAdd(UInt32 x, UInt32 y, UInt32[] z, int zOff);
    public static UInt32 MulWordDwordAdd(UInt32 x, ulong y, UInt32[] z, int zOff);
    public static UInt32 MulWord(UInt32 x, UInt32[] y, UInt32[] z, int zOff);
    public static void Square(UInt32[] x, UInt32[] zz);
    public static void Square(UInt32[] x, int xOff, UInt32[] zz, int zzOff);
    public static int Sub(UInt32[] x, UInt32[] y, UInt32[] z);
    public static int Sub(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static int SubBothFrom(UInt32[] x, UInt32[] y, UInt32[] z);
    public static int SubFrom(UInt32[] x, UInt32[] z);
    public static int SubFrom(UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static BigInteger ToBigInteger(UInt32[] x);
    public static void Zero(UInt32[] z);
}
internal abstract class Org.BouncyCastle.Math.Raw.Nat256 : object {
    private static ulong M;
    public static UInt32 Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 Add(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 AddBothTo(UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 AddBothTo(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 AddTo(UInt32[] x, UInt32[] z);
    public static UInt32 AddTo(UInt32[] x, int xOff, UInt32[] z, int zOff, UInt32 cIn);
    public static UInt32 AddToEachOther(UInt32[] u, int uOff, UInt32[] v, int vOff);
    public static void Copy(UInt32[] x, UInt32[] z);
    public static void Copy(UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static void Copy64(UInt64[] x, UInt64[] z);
    public static void Copy64(UInt64[] x, int xOff, UInt64[] z, int zOff);
    public static UInt32[] Create();
    public static UInt64[] Create64();
    public static UInt32[] CreateExt();
    public static UInt64[] CreateExt64();
    public static bool Diff(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static bool Eq(UInt32[] x, UInt32[] y);
    public static bool Eq64(UInt64[] x, UInt64[] y);
    public static UInt32 GetBit(UInt32[] x, int bit);
    public static bool Gte(UInt32[] x, UInt32[] y);
    public static bool Gte(UInt32[] x, int xOff, UInt32[] y, int yOff);
    public static bool IsOne(UInt32[] x);
    public static bool IsOne64(UInt64[] x);
    public static bool IsZero(UInt32[] x);
    public static bool IsZero64(UInt64[] x);
    public static void Mul(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Mul(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] zz, int zzOff);
    public static UInt32 MulAddTo(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static UInt32 MulAddTo(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] zz, int zzOff);
    public static ulong Mul33Add(UInt32 w, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 MulByWord(UInt32 x, UInt32[] z);
    public static UInt32 MulByWordAddTo(UInt32 x, UInt32[] y, UInt32[] z);
    public static UInt32 MulWordAddTo(UInt32 x, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 Mul33DWordAdd(UInt32 x, ulong y, UInt32[] z, int zOff);
    public static UInt32 Mul33WordAdd(UInt32 x, UInt32 y, UInt32[] z, int zOff);
    public static UInt32 MulWordDwordAdd(UInt32 x, ulong y, UInt32[] z, int zOff);
    public static UInt32 MulWord(UInt32 x, UInt32[] y, UInt32[] z, int zOff);
    public static void Square(UInt32[] x, UInt32[] zz);
    public static void Square(UInt32[] x, int xOff, UInt32[] zz, int zzOff);
    public static int Sub(UInt32[] x, UInt32[] y, UInt32[] z);
    public static int Sub(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static int SubBothFrom(UInt32[] x, UInt32[] y, UInt32[] z);
    public static int SubFrom(UInt32[] x, UInt32[] z);
    public static int SubFrom(UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static BigInteger ToBigInteger(UInt32[] x);
    public static BigInteger ToBigInteger64(UInt64[] x);
    public static void Zero(UInt32[] z);
}
internal abstract class Org.BouncyCastle.Math.Raw.Nat320 : object {
    public static void Copy64(UInt64[] x, UInt64[] z);
    public static void Copy64(UInt64[] x, int xOff, UInt64[] z, int zOff);
    public static UInt64[] Create64();
    public static UInt64[] CreateExt64();
    public static bool Eq64(UInt64[] x, UInt64[] y);
    public static bool IsOne64(UInt64[] x);
    public static bool IsZero64(UInt64[] x);
    public static BigInteger ToBigInteger64(UInt64[] x);
}
internal abstract class Org.BouncyCastle.Math.Raw.Nat384 : object {
    public static void Mul(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Square(UInt32[] x, UInt32[] zz);
}
internal abstract class Org.BouncyCastle.Math.Raw.Nat448 : object {
    public static void Copy64(UInt64[] x, UInt64[] z);
    public static void Copy64(UInt64[] x, int xOff, UInt64[] z, int zOff);
    public static UInt64[] Create64();
    public static UInt64[] CreateExt64();
    public static bool Eq64(UInt64[] x, UInt64[] y);
    public static bool IsOne64(UInt64[] x);
    public static bool IsZero64(UInt64[] x);
    public static void Mul(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Square(UInt32[] x, UInt32[] zz);
    public static BigInteger ToBigInteger64(UInt64[] x);
}
internal abstract class Org.BouncyCastle.Math.Raw.Nat512 : object {
    public static void Mul(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Square(UInt32[] x, UInt32[] zz);
}
internal abstract class Org.BouncyCastle.Math.Raw.Nat576 : object {
    public static void Copy64(UInt64[] x, UInt64[] z);
    public static void Copy64(UInt64[] x, int xOff, UInt64[] z, int zOff);
    public static UInt64[] Create64();
    public static UInt64[] CreateExt64();
    public static bool Eq64(UInt64[] x, UInt64[] y);
    public static bool IsOne64(UInt64[] x);
    public static bool IsZero64(UInt64[] x);
    public static BigInteger ToBigInteger64(UInt64[] x);
}
public class Org.BouncyCastle.Ocsp.BasicOcspResp : X509ExtensionBase {
    private BasicOcspResponse resp;
    private ResponseData data;
    public int Version { get; }
    public RespID ResponderId { get; }
    public DateTime ProducedAt { get; }
    public SingleResp[] Responses { get; }
    public X509Extensions ResponseExtensions { get; }
    public string SignatureAlgName { get; }
    public string SignatureAlgOid { get; }
    public BasicOcspResp(BasicOcspResponse resp);
    public Byte[] GetTbsResponseData();
    public int get_Version();
    public RespID get_ResponderId();
    public DateTime get_ProducedAt();
    public SingleResp[] get_Responses();
    public X509Extensions get_ResponseExtensions();
    protected virtual X509Extensions GetX509Extensions();
    public string get_SignatureAlgName();
    public string get_SignatureAlgOid();
    [ObsoleteAttribute("RespData class is no longer required as all functionality is available on this class")]
public RespData GetResponseData();
    public Byte[] GetSignature();
    private IList GetCertList();
    public X509Certificate[] GetCerts();
    public IX509Store GetCertificates(string type);
    public bool Verify(AsymmetricKeyParameter publicKey);
    public Byte[] GetEncoded();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Ocsp.BasicOcspRespGenerator : object {
    private IList list;
    private X509Extensions responseExtensions;
    private RespID responderID;
    public IEnumerable SignatureAlgNames { get; }
    public BasicOcspRespGenerator(RespID responderID);
    public BasicOcspRespGenerator(AsymmetricKeyParameter publicKey);
    public void AddResponse(CertificateID certID, CertificateStatus certStatus);
    public void AddResponse(CertificateID certID, CertificateStatus certStatus, X509Extensions singleExtensions);
    public void AddResponse(CertificateID certID, CertificateStatus certStatus, DateTime nextUpdate, X509Extensions singleExtensions);
    public void AddResponse(CertificateID certID, CertificateStatus certStatus, DateTime thisUpdate, DateTime nextUpdate, X509Extensions singleExtensions);
    public void SetResponseExtensions(X509Extensions responseExtensions);
    private BasicOcspResp GenerateResponse(ISignatureFactory signatureCalculator, X509Certificate[] chain, DateTime producedAt);
    public BasicOcspResp Generate(string signingAlgorithm, AsymmetricKeyParameter privateKey, X509Certificate[] chain, DateTime thisUpdate);
    public BasicOcspResp Generate(string signingAlgorithm, AsymmetricKeyParameter privateKey, X509Certificate[] chain, DateTime producedAt, SecureRandom random);
    public BasicOcspResp Generate(ISignatureFactory signatureCalculatorFactory, X509Certificate[] chain, DateTime producedAt);
    public IEnumerable get_SignatureAlgNames();
}
public class Org.BouncyCastle.Ocsp.CertificateID : object {
    public static string HashSha1;
    private CertID id;
    public string HashAlgOid { get; }
    public BigInteger SerialNumber { get; }
    public CertificateID(CertID id);
    public CertificateID(string hashAlgorithm, X509Certificate issuerCert, BigInteger serialNumber);
    public string get_HashAlgOid();
    public Byte[] GetIssuerNameHash();
    public Byte[] GetIssuerKeyHash();
    public BigInteger get_SerialNumber();
    public bool MatchesIssuer(X509Certificate issuerCert);
    public CertID ToAsn1Object();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static CertificateID DeriveCertificateID(CertificateID original, BigInteger newSerialNumber);
    private static CertID CreateCertID(AlgorithmIdentifier hashAlg, X509Certificate issuerCert, DerInteger serialNumber);
}
public abstract class Org.BouncyCastle.Ocsp.CertificateStatus : object {
    public static CertificateStatus Good;
}
[ObsoleteAttribute("Use version with correct spelling 'OcspRespStatus'")]
public abstract class Org.BouncyCastle.Ocsp.OcscpRespStatus : OcspRespStatus {
}
public class Org.BouncyCastle.Ocsp.OcspException : Exception {
    public OcspException(string message);
    public OcspException(string message, Exception e);
}
public class Org.BouncyCastle.Ocsp.OcspReq : X509ExtensionBase {
    private OcspRequest req;
    public int Version { get; }
    public GeneralName RequestorName { get; }
    public X509Extensions RequestExtensions { get; }
    public string SignatureAlgOid { get; }
    public bool IsSigned { get; }
    public OcspReq(OcspRequest req);
    public OcspReq(Byte[] req);
    public OcspReq(Stream inStr);
    private OcspReq(Asn1InputStream aIn);
    public Byte[] GetTbsRequest();
    public int get_Version();
    public GeneralName get_RequestorName();
    public Req[] GetRequestList();
    public X509Extensions get_RequestExtensions();
    protected virtual X509Extensions GetX509Extensions();
    public string get_SignatureAlgOid();
    public Byte[] GetSignature();
    private IList GetCertList();
    public X509Certificate[] GetCerts();
    public IX509Store GetCertificates(string type);
    public bool get_IsSigned();
    public bool Verify(AsymmetricKeyParameter publicKey);
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Ocsp.OcspReqGenerator : object {
    private IList list;
    private GeneralName requestorName;
    private X509Extensions requestExtensions;
    public IEnumerable SignatureAlgNames { get; }
    public void AddRequest(CertificateID certId);
    public void AddRequest(CertificateID certId, X509Extensions singleRequestExtensions);
    public void SetRequestorName(X509Name requestorName);
    public void SetRequestorName(GeneralName requestorName);
    public void SetRequestExtensions(X509Extensions requestExtensions);
    private OcspReq GenerateRequest(DerObjectIdentifier signingAlgorithm, AsymmetricKeyParameter privateKey, X509Certificate[] chain, SecureRandom random);
    public OcspReq Generate();
    public OcspReq Generate(string signingAlgorithm, AsymmetricKeyParameter privateKey, X509Certificate[] chain);
    public OcspReq Generate(string signingAlgorithm, AsymmetricKeyParameter privateKey, X509Certificate[] chain, SecureRandom random);
    public IEnumerable get_SignatureAlgNames();
}
public class Org.BouncyCastle.Ocsp.OcspResp : object {
    private OcspResponse resp;
    public int Status { get; }
    public OcspResp(OcspResponse resp);
    public OcspResp(Byte[] resp);
    public OcspResp(Stream inStr);
    private OcspResp(Asn1InputStream aIn);
    public int get_Status();
    public object GetResponseObject();
    public Byte[] GetEncoded();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Ocsp.OCSPRespGenerator : object {
    public static int Successful;
    public static int MalformedRequest;
    public static int InternalError;
    public static int TryLater;
    public static int SigRequired;
    public static int Unauthorized;
    public OcspResp Generate(int status, object response);
}
public abstract class Org.BouncyCastle.Ocsp.OcspRespStatus : object {
    public static int Successful;
    public static int MalformedRequest;
    public static int InternalError;
    public static int TryLater;
    public static int SigRequired;
    public static int Unauthorized;
}
internal class Org.BouncyCastle.Ocsp.OcspUtilities : object {
    private static IDictionary algorithms;
    private static IDictionary oids;
    private static ISet noParams;
    internal static IEnumerable AlgNames { get; }
    private static OcspUtilities();
    internal static DerObjectIdentifier GetAlgorithmOid(string algorithmName);
    internal static string GetAlgorithmName(DerObjectIdentifier oid);
    internal static AlgorithmIdentifier GetSigAlgID(DerObjectIdentifier sigOid);
    internal static IEnumerable get_AlgNames();
}
public class Org.BouncyCastle.Ocsp.Req : X509ExtensionBase {
    private Request req;
    public X509Extensions SingleRequestExtensions { get; }
    public Req(Request req);
    public CertificateID GetCertID();
    public X509Extensions get_SingleRequestExtensions();
    protected virtual X509Extensions GetX509Extensions();
}
public class Org.BouncyCastle.Ocsp.RespData : X509ExtensionBase {
    internal ResponseData data;
    public int Version { get; }
    public DateTime ProducedAt { get; }
    public X509Extensions ResponseExtensions { get; }
    public RespData(ResponseData data);
    public int get_Version();
    public RespID GetResponderId();
    public DateTime get_ProducedAt();
    public SingleResp[] GetResponses();
    public X509Extensions get_ResponseExtensions();
    protected virtual X509Extensions GetX509Extensions();
}
public class Org.BouncyCastle.Ocsp.RespID : object {
    internal ResponderID id;
    public RespID(ResponderID id);
    public RespID(X509Name name);
    public RespID(AsymmetricKeyParameter publicKey);
    public ResponderID ToAsn1Object();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Ocsp.RevokedStatus : CertificateStatus {
    internal RevokedInfo info;
    public DateTime RevocationTime { get; }
    public bool HasRevocationReason { get; }
    public int RevocationReason { get; }
    public RevokedStatus(RevokedInfo info);
    public RevokedStatus(DateTime revocationDate, int reason);
    public DateTime get_RevocationTime();
    public bool get_HasRevocationReason();
    public int get_RevocationReason();
}
public class Org.BouncyCastle.Ocsp.SingleResp : X509ExtensionBase {
    internal SingleResponse resp;
    public DateTime ThisUpdate { get; }
    public DateTimeObject NextUpdate { get; }
    public X509Extensions SingleExtensions { get; }
    public SingleResp(SingleResponse resp);
    public CertificateID GetCertID();
    public object GetCertStatus();
    public DateTime get_ThisUpdate();
    public DateTimeObject get_NextUpdate();
    public X509Extensions get_SingleExtensions();
    protected virtual X509Extensions GetX509Extensions();
}
public class Org.BouncyCastle.Ocsp.UnknownStatus : CertificateStatus {
}
public interface Org.BouncyCastle.OpenSsl.IPasswordFinder {
    public abstract virtual Char[] GetPassword();
}
public class Org.BouncyCastle.OpenSsl.MiscPemGenerator : object {
    private object obj;
    private string algorithm;
    private Char[] password;
    private SecureRandom random;
    public MiscPemGenerator(object obj);
    public MiscPemGenerator(object obj, string algorithm, Char[] password, SecureRandom random);
    private static PemObject CreatePemObject(object obj);
    private static PemObject CreatePemObject(object obj, string algorithm, Char[] password, SecureRandom random);
    private static Byte[] EncodePrivateKey(AsymmetricKeyParameter akp, String& keyType);
    public sealed virtual PemObject Generate();
}
public class Org.BouncyCastle.OpenSsl.PemException : IOException {
    public PemException(string message);
    public PemException(string message, Exception exception);
}
public class Org.BouncyCastle.OpenSsl.PemReader : PemReader {
    private IPasswordFinder pFinder;
    private static PemReader();
    public PemReader(TextReader reader);
    public PemReader(TextReader reader, IPasswordFinder pFinder);
    public object ReadObject();
    private AsymmetricKeyParameter ReadRsaPublicKey(PemObject pemObject);
    private AsymmetricKeyParameter ReadPublicKey(PemObject pemObject);
    private X509Certificate ReadCertificate(PemObject pemObject);
    private X509Crl ReadCrl(PemObject pemObject);
    private Pkcs10CertificationRequest ReadCertificateRequest(PemObject pemObject);
    private IX509AttributeCertificate ReadAttributeCertificate(PemObject pemObject);
    private ContentInfo ReadPkcs7(PemObject pemObject);
    private object ReadPrivateKey(PemObject pemObject);
    private static X9ECParameters GetCurveParameters(string name);
}
internal class Org.BouncyCastle.OpenSsl.PemUtilities : object {
    private static PemUtilities();
    private static void ParseDekAlgName(string dekAlgName, PemBaseAlg& baseAlg, PemMode& mode);
    internal static Byte[] Crypt(bool encrypt, Byte[] bytes, Char[] password, string dekAlgName, Byte[] iv);
    private static ICipherParameters GetCipherParameters(Char[] password, PemBaseAlg baseAlg, Byte[] salt);
}
public class Org.BouncyCastle.OpenSsl.PemWriter : PemWriter {
    public PemWriter(TextWriter writer);
    public void WriteObject(object obj);
    public void WriteObject(object obj, string algorithm, Char[] password, SecureRandom random);
}
public class Org.BouncyCastle.OpenSsl.Pkcs8Generator : object {
    public static string PbeSha1_RC4_128;
    public static string PbeSha1_RC4_40;
    public static string PbeSha1_3DES;
    public static string PbeSha1_2DES;
    public static string PbeSha1_RC2_128;
    public static string PbeSha1_RC2_40;
    private Char[] password;
    private string algorithm;
    private int iterationCount;
    private AsymmetricKeyParameter privKey;
    private SecureRandom random;
    unknown SecureRandom SecureRandom {public set; }
    unknown Char[] Password {public set; }
    unknown int IterationCount {public set; }
    public Pkcs8Generator(AsymmetricKeyParameter privKey);
    public Pkcs8Generator(AsymmetricKeyParameter privKey, string algorithm);
    private static Pkcs8Generator();
    public void set_SecureRandom(SecureRandom value);
    public void set_Password(Char[] value);
    public void set_IterationCount(int value);
    public sealed virtual PemObject Generate();
}
public class Org.BouncyCastle.Operators.CmsContentEncryptorBuilder : object {
    private static IDictionary KeySizes;
    private DerObjectIdentifier encryptionOID;
    private int keySize;
    private EnvelopedDataHelper helper;
    private static CmsContentEncryptorBuilder();
    public CmsContentEncryptorBuilder(DerObjectIdentifier encryptionOID);
    public CmsContentEncryptorBuilder(DerObjectIdentifier encryptionOID, int keySize);
    private static int GetKeySize(DerObjectIdentifier oid);
    public ICipherBuilderWithKey Build();
}
public class Org.BouncyCastle.Operators.CmsKeyTransRecipientInfoGenerator : KeyTransRecipientInfoGenerator {
    public CmsKeyTransRecipientInfoGenerator(X509Certificate recipCert, IKeyWrapper keyWrapper);
    public CmsKeyTransRecipientInfoGenerator(IssuerAndSerialNumber issuerAndSerial, IKeyWrapper keyWrapper);
    public CmsKeyTransRecipientInfoGenerator(Byte[] subjectKeyID, IKeyWrapper keyWrapper);
}
public class Org.BouncyCastle.Pkcs.AsymmetricKeyEntry : Pkcs12Entry {
    private AsymmetricKeyParameter key;
    public AsymmetricKeyParameter Key { get; }
    public AsymmetricKeyEntry(AsymmetricKeyParameter key);
    [ObsoleteAttribute]
public AsymmetricKeyEntry(AsymmetricKeyParameter key, Hashtable attributes);
    public AsymmetricKeyEntry(AsymmetricKeyParameter key, IDictionary attributes);
    public AsymmetricKeyParameter get_Key();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Pkcs.EncryptedPrivateKeyInfoFactory : object {
    public static EncryptedPrivateKeyInfo CreateEncryptedPrivateKeyInfo(DerObjectIdentifier algorithm, Char[] passPhrase, Byte[] salt, int iterationCount, AsymmetricKeyParameter key);
    public static EncryptedPrivateKeyInfo CreateEncryptedPrivateKeyInfo(string algorithm, Char[] passPhrase, Byte[] salt, int iterationCount, AsymmetricKeyParameter key);
    public static EncryptedPrivateKeyInfo CreateEncryptedPrivateKeyInfo(string algorithm, Char[] passPhrase, Byte[] salt, int iterationCount, PrivateKeyInfo keyInfo);
    public static EncryptedPrivateKeyInfo CreateEncryptedPrivateKeyInfo(DerObjectIdentifier cipherAlgorithm, DerObjectIdentifier prfAlgorithm, Char[] passPhrase, Byte[] salt, int iterationCount, SecureRandom random, AsymmetricKeyParameter key);
    public static EncryptedPrivateKeyInfo CreateEncryptedPrivateKeyInfo(DerObjectIdentifier cipherAlgorithm, DerObjectIdentifier prfAlgorithm, Char[] passPhrase, Byte[] salt, int iterationCount, SecureRandom random, PrivateKeyInfo keyInfo);
}
public class Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest : CertificationRequest {
    protected static IDictionary algorithms;
    protected static IDictionary exParams;
    protected static IDictionary keyAlgorithms;
    protected static IDictionary oids;
    protected static ISet noParams;
    private static Pkcs10CertificationRequest();
    public Pkcs10CertificationRequest(Byte[] encoded);
    public Pkcs10CertificationRequest(Asn1Sequence seq);
    public Pkcs10CertificationRequest(Stream input);
    public Pkcs10CertificationRequest(string signatureAlgorithm, X509Name subject, AsymmetricKeyParameter publicKey, Asn1Set attributes, AsymmetricKeyParameter signingKey);
    [ObsoleteAttribute("Use constructor without 'signingKey' parameter (ignored here)")]
public Pkcs10CertificationRequest(ISignatureFactory signatureFactory, X509Name subject, AsymmetricKeyParameter publicKey, Asn1Set attributes, AsymmetricKeyParameter signingKey);
    public Pkcs10CertificationRequest(ISignatureFactory signatureFactory, X509Name subject, AsymmetricKeyParameter publicKey, Asn1Set attributes);
    private static RsassaPssParameters CreatePssParams(AlgorithmIdentifier hashAlgId, int saltSize);
    private void Init(ISignatureFactory signatureFactory, X509Name subject, AsymmetricKeyParameter publicKey, Asn1Set attributes);
    public AsymmetricKeyParameter GetPublicKey();
    public bool Verify();
    public bool Verify(AsymmetricKeyParameter publicKey);
    public bool Verify(IVerifierFactoryProvider verifierProvider);
    public bool Verify(IVerifierFactory verifier);
    private void SetSignatureParameters(ISigner signature, Asn1Encodable asn1Params);
    internal static string GetSignatureName(AlgorithmIdentifier sigAlgId);
    private static string GetDigestAlgName(DerObjectIdentifier digestAlgOID);
    public X509Extensions GetRequestedExtensions();
}
public class Org.BouncyCastle.Pkcs.Pkcs10CertificationRequestDelaySigned : Pkcs10CertificationRequest {
    public Pkcs10CertificationRequestDelaySigned(Byte[] encoded);
    public Pkcs10CertificationRequestDelaySigned(Asn1Sequence seq);
    public Pkcs10CertificationRequestDelaySigned(Stream input);
    public Pkcs10CertificationRequestDelaySigned(string signatureAlgorithm, X509Name subject, AsymmetricKeyParameter publicKey, Asn1Set attributes, AsymmetricKeyParameter signingKey);
    public Pkcs10CertificationRequestDelaySigned(string signatureAlgorithm, X509Name subject, AsymmetricKeyParameter publicKey, Asn1Set attributes);
    public Byte[] GetDataToSign();
    public void SignRequest(Byte[] signedData);
    public void SignRequest(DerBitString signedData);
}
[DefaultMemberAttribute("Item")]
public abstract class Org.BouncyCastle.Pkcs.Pkcs12Entry : object {
    private IDictionary attributes;
    public Asn1Encodable Item { get; }
    public Asn1Encodable Item { get; }
    public IEnumerable BagAttributeKeys { get; }
    protected internal Pkcs12Entry(IDictionary attributes);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public Asn1Encodable GetBagAttribute(DerObjectIdentifier oid);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public Asn1Encodable GetBagAttribute(string oid);
    [ObsoleteAttribute("Use 'BagAttributeKeys' property")]
public IEnumerator GetBagAttributeKeys();
    public Asn1Encodable get_Item(DerObjectIdentifier oid);
    public Asn1Encodable get_Item(string oid);
    public IEnumerable get_BagAttributeKeys();
}
public class Org.BouncyCastle.Pkcs.Pkcs12Store : object {
    public static string IgnoreUselessPasswordProperty;
    private IgnoresCaseHashtable keys;
    private IDictionary localIds;
    private IgnoresCaseHashtable certs;
    private IDictionary chainCerts;
    private IDictionary keyCerts;
    private DerObjectIdentifier keyAlgorithm;
    private DerObjectIdentifier keyPrfAlgorithm;
    private DerObjectIdentifier certAlgorithm;
    private DerObjectIdentifier certPrfAlgorithm;
    private bool useDerEncoding;
    private AsymmetricKeyEntry unmarkedKeyEntry;
    private static int MinIterations;
    private static int SaltSize;
    public IEnumerable Aliases { get; }
    public int Count { get; }
    internal Pkcs12Store(DerObjectIdentifier keyAlgorithm, DerObjectIdentifier certAlgorithm, bool useDerEncoding);
    internal Pkcs12Store(DerObjectIdentifier keyAlgorithm, DerObjectIdentifier keyPrfAlgorithm, DerObjectIdentifier certAlgorithm, DerObjectIdentifier certPrfAlgorithm, bool useDerEncoding);
    public Pkcs12Store(Stream input, Char[] password);
    private static SubjectKeyIdentifier CreateSubjectKeyID(AsymmetricKeyParameter pubKey);
    protected virtual void LoadKeyBag(PrivateKeyInfo privKeyInfo, Asn1Set bagAttributes);
    protected virtual void LoadPkcs8ShroudedKeyBag(EncryptedPrivateKeyInfo encPrivKeyInfo, Asn1Set bagAttributes, Char[] password, bool wrongPkcs12Zero);
    public void Load(Stream input, Char[] password);
    public AsymmetricKeyEntry GetKey(string alias);
    public bool IsCertificateEntry(string alias);
    public bool IsKeyEntry(string alias);
    private IDictionary GetAliasesTable();
    public IEnumerable get_Aliases();
    public bool ContainsAlias(string alias);
    public X509CertificateEntry GetCertificate(string alias);
    public string GetCertificateAlias(X509Certificate cert);
    public X509CertificateEntry[] GetCertificateChain(string alias);
    public void SetCertificateEntry(string alias, X509CertificateEntry certEntry);
    public void SetKeyEntry(string alias, AsymmetricKeyEntry keyEntry, X509CertificateEntry[] chain);
    public void DeleteEntry(string alias);
    public bool IsEntryOfType(string alias, Type entryType);
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size();
    public int get_Count();
    public void Save(Stream stream, Char[] password, SecureRandom random);
    internal static Byte[] CalculatePbeMac(DerObjectIdentifier oid, Byte[] salt, int itCount, Char[] password, bool wrongPkcs12Zero, Byte[] data);
    private static Byte[] CryptPbeData(bool forEncryption, AlgorithmIdentifier algId, Char[] password, bool wrongPkcs12Zero, Byte[] data);
}
public class Org.BouncyCastle.Pkcs.Pkcs12StoreBuilder : object {
    private DerObjectIdentifier keyAlgorithm;
    private DerObjectIdentifier certAlgorithm;
    private DerObjectIdentifier keyPrfAlgorithm;
    private DerObjectIdentifier certPrfAlgorithm;
    private bool useDerEncoding;
    public Pkcs12Store Build();
    public Pkcs12StoreBuilder SetCertAlgorithm(DerObjectIdentifier certAlgorithm);
    public Pkcs12StoreBuilder SetKeyAlgorithm(DerObjectIdentifier keyAlgorithm);
    public Pkcs12StoreBuilder SetKeyAlgorithm(DerObjectIdentifier keyAlgorithm, DerObjectIdentifier keyPrfAlgorithm);
    public Pkcs12StoreBuilder SetUseDerEncoding(bool useDerEncoding);
}
public class Org.BouncyCastle.Pkcs.Pkcs12Utilities : object {
    public static Byte[] ConvertToDefiniteLength(Byte[] berPkcs12File);
    public static Byte[] ConvertToDefiniteLength(Byte[] berPkcs12File, Char[] passwd);
}
public class Org.BouncyCastle.Pkcs.Pkcs8EncryptedPrivateKeyInfo : object {
    private EncryptedPrivateKeyInfo encryptedPrivateKeyInfo;
    public Pkcs8EncryptedPrivateKeyInfo(EncryptedPrivateKeyInfo encryptedPrivateKeyInfo);
    public Pkcs8EncryptedPrivateKeyInfo(Byte[] encryptedPrivateKeyInfo);
    private static EncryptedPrivateKeyInfo parseBytes(Byte[] pkcs8Encoding);
    public EncryptedPrivateKeyInfo ToAsn1Structure();
    public Byte[] GetEncryptedData();
    public Byte[] GetEncoded();
    public PrivateKeyInfo DecryptPrivateKeyInfo(IDecryptorBuilderProvider inputDecryptorProvider);
}
public class Org.BouncyCastle.Pkcs.Pkcs8EncryptedPrivateKeyInfoBuilder : object {
    private PrivateKeyInfo privateKeyInfo;
    public Pkcs8EncryptedPrivateKeyInfoBuilder(Byte[] privateKeyInfo);
    public Pkcs8EncryptedPrivateKeyInfoBuilder(PrivateKeyInfo privateKeyInfo);
    public Pkcs8EncryptedPrivateKeyInfo Build(ICipherBuilder encryptor);
}
public class Org.BouncyCastle.Pkcs.PkcsException : Exception {
    public PkcsException(string message);
    public PkcsException(string message, Exception underlying);
}
public class Org.BouncyCastle.Pkcs.PkcsIOException : IOException {
    public PkcsIOException(string message);
    public PkcsIOException(string message, Exception underlying);
}
public class Org.BouncyCastle.Pkcs.PrivateKeyInfoFactory : object {
    public static PrivateKeyInfo CreatePrivateKeyInfo(AsymmetricKeyParameter privateKey);
    public static PrivateKeyInfo CreatePrivateKeyInfo(AsymmetricKeyParameter privateKey, Asn1Set attributes);
    public static PrivateKeyInfo CreatePrivateKeyInfo(Char[] passPhrase, EncryptedPrivateKeyInfo encInfo);
    public static PrivateKeyInfo CreatePrivateKeyInfo(Char[] passPhrase, bool wrongPkcs12Zero, EncryptedPrivateKeyInfo encInfo);
    private static void ExtractBytes(Byte[] encKey, int size, int offSet, BigInteger bI);
}
public class Org.BouncyCastle.Pkcs.X509CertificateEntry : Pkcs12Entry {
    private X509Certificate cert;
    public X509Certificate Certificate { get; }
    public X509CertificateEntry(X509Certificate cert);
    [ObsoleteAttribute]
public X509CertificateEntry(X509Certificate cert, Hashtable attributes);
    public X509CertificateEntry(X509Certificate cert, IDictionary attributes);
    public X509Certificate get_Certificate();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Pkix.CertStatus : object {
    public static int Unrevoked;
    public static int Undetermined;
    private int status;
    private DateTimeObject revocationDate;
    public DateTimeObject RevocationDate { get; public set; }
    public int Status { get; public set; }
    public DateTimeObject get_RevocationDate();
    public void set_RevocationDate(DateTimeObject value);
    public int get_Status();
    public void set_Status(int value);
}
public abstract class Org.BouncyCastle.Pkix.PkixAttrCertChecker : object {
    public abstract virtual ISet GetSupportedExtensions();
    public abstract virtual void Check(IX509AttributeCertificate attrCert, PkixCertPath certPath, PkixCertPath holderCertPath, ICollection unresolvedCritExts);
    public abstract virtual PkixAttrCertChecker Clone();
}
public class Org.BouncyCastle.Pkix.PkixAttrCertPathBuilder : object {
    private Exception certPathException;
    public virtual PkixCertPathBuilderResult Build(PkixBuilderParameters pkixParams);
    private PkixCertPathBuilderResult Build(IX509AttributeCertificate attrCert, X509Certificate tbvCert, PkixBuilderParameters pkixParams, IList tbvPath);
}
public class Org.BouncyCastle.Pkix.PkixAttrCertPathValidator : object {
    public virtual PkixCertPathValidatorResult Validate(PkixCertPath certPath, PkixParameters pkixParams);
}
public class Org.BouncyCastle.Pkix.PkixBuilderParameters : PkixParameters {
    private int maxPathLength;
    private ISet excludedCerts;
    public int MaxPathLength { get; public set; }
    public PkixBuilderParameters(ISet trustAnchors, IX509Selector targetConstraints);
    public static PkixBuilderParameters GetInstance(PkixParameters pkixParams);
    public virtual int get_MaxPathLength();
    public virtual void set_MaxPathLength(int value);
    public virtual ISet GetExcludedCerts();
    public virtual void SetExcludedCerts(ISet excludedCerts);
    protected virtual void SetParams(PkixParameters parameters);
    public virtual object Clone();
    public virtual string ToString();
}
public class Org.BouncyCastle.Pkix.PkixCertPath : object {
    internal static IList certPathEncodings;
    private IList certificates;
    public IEnumerable Encodings { get; }
    public IList Certificates { get; }
    private static PkixCertPath();
    public PkixCertPath(ICollection certificates);
    public PkixCertPath(Stream inStream);
    public PkixCertPath(Stream inStream, string encoding);
    private static IList SortCerts(IList certs);
    public virtual IEnumerable get_Encodings();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual Byte[] GetEncoded();
    public virtual Byte[] GetEncoded(string encoding);
    public virtual IList get_Certificates();
    private Asn1Object ToAsn1Object(X509Certificate cert);
    private Byte[] ToDerEncoded(Asn1Encodable obj);
}
public class Org.BouncyCastle.Pkix.PkixCertPathBuilder : object {
    private Exception certPathException;
    public virtual PkixCertPathBuilderResult Build(PkixBuilderParameters pkixParams);
    protected virtual PkixCertPathBuilderResult Build(X509Certificate tbvCert, PkixBuilderParameters pkixParams, IList tbvPath);
}
public class Org.BouncyCastle.Pkix.PkixCertPathBuilderException : GeneralSecurityException {
    public PkixCertPathBuilderException(string message);
    public PkixCertPathBuilderException(string message, Exception exception);
}
public class Org.BouncyCastle.Pkix.PkixCertPathBuilderResult : PkixCertPathValidatorResult {
    private PkixCertPath certPath;
    public PkixCertPath CertPath { get; }
    public PkixCertPathBuilderResult(PkixCertPath certPath, TrustAnchor trustAnchor, PkixPolicyNode policyTree, AsymmetricKeyParameter subjectPublicKey);
    public PkixCertPath get_CertPath();
    public virtual string ToString();
}
public abstract class Org.BouncyCastle.Pkix.PkixCertPathChecker : object {
    public abstract virtual void Init(bool forward);
    public abstract virtual bool IsForwardCheckingSupported();
    public abstract virtual ISet GetSupportedExtensions();
    public abstract virtual void Check(X509Certificate cert, ISet unresolvedCritExts);
    public virtual object Clone();
}
public class Org.BouncyCastle.Pkix.PkixCertPathValidator : object {
    public virtual PkixCertPathValidatorResult Validate(PkixCertPath certPath, PkixParameters paramsPkix);
    internal static void CheckCertificate(X509Certificate cert);
}
public class Org.BouncyCastle.Pkix.PkixCertPathValidatorException : GeneralSecurityException {
    private Exception cause;
    private PkixCertPath certPath;
    private int index;
    public string Message { get; }
    public PkixCertPath CertPath { get; }
    public int Index { get; }
    public PkixCertPathValidatorException(string message);
    public PkixCertPathValidatorException(string message, Exception cause);
    public PkixCertPathValidatorException(string message, Exception cause, PkixCertPath certPath, int index);
    public virtual string get_Message();
    public PkixCertPath get_CertPath();
    public int get_Index();
}
public class Org.BouncyCastle.Pkix.PkixCertPathValidatorResult : object {
    private TrustAnchor trustAnchor;
    private PkixPolicyNode policyTree;
    private AsymmetricKeyParameter subjectPublicKey;
    public PkixPolicyNode PolicyTree { get; }
    public TrustAnchor TrustAnchor { get; }
    public AsymmetricKeyParameter SubjectPublicKey { get; }
    public PkixCertPathValidatorResult(TrustAnchor trustAnchor, PkixPolicyNode policyTree, AsymmetricKeyParameter subjectPublicKey);
    public PkixPolicyNode get_PolicyTree();
    public TrustAnchor get_TrustAnchor();
    public AsymmetricKeyParameter get_SubjectPublicKey();
    public object Clone();
    public virtual string ToString();
}
public class Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities : object {
    private static PkixCrlUtilities CrlUtilities;
    internal static string ANY_POLICY;
    internal static string CRL_NUMBER;
    internal static int KEY_CERT_SIGN;
    internal static int CRL_SIGN;
    internal static String[] crlReasons;
    private static PkixCertPathValidatorUtilities();
    internal static TrustAnchor FindTrustAnchor(X509Certificate cert, ISet trustAnchors);
    internal static bool IsIssuerTrustAnchor(X509Certificate cert, ISet trustAnchors);
    internal static void AddAdditionalStoresFromAltNames(X509Certificate cert, PkixParameters pkixParams);
    internal static DateTime GetValidDate(PkixParameters paramsPKIX);
    internal static X509Name GetIssuerPrincipal(object cert);
    internal static bool IsSelfIssued(X509Certificate cert);
    internal static AlgorithmIdentifier GetAlgorithmIdentifier(AsymmetricKeyParameter key);
    internal static bool IsAnyPolicy(ISet policySet);
    internal static void AddAdditionalStoreFromLocation(string location, PkixParameters pkixParams);
    private static BigInteger GetSerialNumber(object cert);
    internal static ISet GetQualifierSet(Asn1Sequence qualifiers);
    internal static PkixPolicyNode RemovePolicyNode(PkixPolicyNode validPolicyTree, IList[] policyNodes, PkixPolicyNode _node);
    private static void RemovePolicyNodeRecurse(IList[] policyNodes, PkixPolicyNode _node);
    internal static void PrepareNextCertB1(int i, IList[] policyNodes, string id_p, IDictionary m_idp, X509Certificate cert);
    internal static PkixPolicyNode PrepareNextCertB2(int i, IList[] policyNodes, string id_p, PkixPolicyNode validPolicyTree);
    internal static void GetCertStatus(DateTime validDate, X509Crl crl, object cert, CertStatus certStatus);
    internal static AsymmetricKeyParameter GetNextWorkingKey(IList certs, int index);
    internal static DateTime GetValidCertDateFromValidityModel(PkixParameters paramsPkix, PkixCertPath certPath, int index);
    internal static ICollection FindCertificates(X509CertStoreSelector certSelect, IList certStores);
    internal static void GetCrlIssuersFromDistributionPoint(DistributionPoint dp, ICollection issuerPrincipals, X509CrlStoreSelector selector, PkixParameters pkixParams);
    internal static ISet GetCompleteCrls(DistributionPoint dp, object cert, DateTime currentDate, PkixParameters paramsPKIX);
    internal static ISet GetDeltaCrls(DateTime currentDate, PkixParameters paramsPKIX, X509Crl completeCRL);
    private static bool isDeltaCrl(X509Crl crl);
    internal static ICollection FindCertificates(X509AttrCertStoreSelector certSelect, IList certStores);
    internal static void AddAdditionalStoresFromCrlDistributionPoint(CrlDistPoint crldp, PkixParameters pkixParams);
    internal static bool ProcessCertD1i(int index, IList[] policyNodes, DerObjectIdentifier pOid, ISet pq);
    internal static void ProcessCertD1ii(int index, IList[] policyNodes, DerObjectIdentifier _poid, ISet _pq);
    internal static ICollection FindIssuerCerts(X509Certificate cert, PkixBuilderParameters pkixParams);
    internal static Asn1Object GetExtensionValue(IX509Extension ext, DerObjectIdentifier oid);
}
public class Org.BouncyCastle.Pkix.PkixCrlUtilities : object {
    public virtual ISet FindCrls(X509CrlStoreSelector crlselect, PkixParameters paramsPkix, DateTime currentDate);
    public virtual ISet FindCrls(X509CrlStoreSelector crlselect, PkixParameters paramsPkix);
    private ICollection FindCrls(X509CrlStoreSelector crlSelect, IList crlStores);
}
public class Org.BouncyCastle.Pkix.PkixNameConstraintValidator : object {
    private static DerObjectIdentifier SerialNumberOid;
    private ISet excludedSubtreesDN;
    private ISet excludedSubtreesDNS;
    private ISet excludedSubtreesEmail;
    private ISet excludedSubtreesURI;
    private ISet excludedSubtreesIP;
    private ISet excludedSubtreesOtherName;
    private ISet permittedSubtreesDN;
    private ISet permittedSubtreesDNS;
    private ISet permittedSubtreesEmail;
    private ISet permittedSubtreesURI;
    private ISet permittedSubtreesIP;
    private ISet permittedSubtreesOtherName;
    private static PkixNameConstraintValidator();
    private static bool WithinDNSubtree(Asn1Sequence dns, Asn1Sequence subtree);
    public void CheckPermittedDN(Asn1Sequence dn);
    public void CheckExcludedDN(Asn1Sequence dn);
    private ISet IntersectDN(ISet permitted, ISet dns);
    private ISet UnionDN(ISet excluded, Asn1Sequence dn);
    private ISet IntersectOtherName(ISet permitted, ISet otherNames);
    private void IntersectOtherName(OtherName otherName1, OtherName otherName2, ISet intersect);
    private ISet UnionOtherName(ISet permitted, OtherName otherName);
    private ISet IntersectEmail(ISet permitted, ISet emails);
    private ISet UnionEmail(ISet excluded, string email);
    private ISet IntersectIP(ISet permitted, ISet ips);
    private ISet UnionIP(ISet excluded, Byte[] ip);
    private ISet UnionIPRange(Byte[] ipWithSubmask1, Byte[] ipWithSubmask2);
    private ISet IntersectIPRange(Byte[] ipWithSubmask1, Byte[] ipWithSubmask2);
    private Byte[] IpWithSubnetMask(Byte[] ip, Byte[] subnetMask);
    private Byte[][] ExtractIPsAndSubnetMasks(Byte[] ipWithSubmask1, Byte[] ipWithSubmask2);
    private Byte[][] MinMaxIPs(Byte[] ip1, Byte[] subnetmask1, Byte[] ip2, Byte[] subnetmask2);
    private bool IsOtherNameConstrained(OtherName constraint, OtherName otherName);
    private bool IsOtherNameConstrained(ISet constraints, OtherName otherName);
    private void CheckPermittedOtherName(ISet permitted, OtherName name);
    private void CheckExcludedOtherName(ISet excluded, OtherName name);
    private bool IsEmailConstrained(string constraint, string email);
    private bool IsEmailConstrained(ISet constraints, string email);
    private void CheckPermittedEmail(ISet permitted, string email);
    private void CheckExcludedEmail(ISet excluded, string email);
    private bool IsDnsConstrained(string constraint, string dns);
    private bool IsDnsConstrained(ISet constraints, string dns);
    private void CheckPermittedDns(ISet permitted, string dns);
    private void CheckExcludedDns(ISet excluded, string dns);
    private bool IsDirectoryConstrained(ISet constraints, Asn1Sequence directory);
    private void CheckPermittedDirectory(ISet permitted, Asn1Sequence directory);
    private void CheckExcludedDirectory(ISet excluded, Asn1Sequence directory);
    private bool IsUriConstrained(string constraint, string uri);
    private bool IsUriConstrained(ISet constraints, string uri);
    private void CheckPermittedUri(ISet permitted, string uri);
    private void CheckExcludedUri(ISet excluded, string uri);
    private bool IsIPConstrained(Byte[] constraint, Byte[] ip);
    private bool IsIPConstrained(ISet constraints, Byte[] ip);
    private void CheckPermittedIP(ISet permitted, Byte[] ip);
    private void CheckExcludedIP(ISet excluded, Byte[] ip);
    private bool WithinDomain(string testDomain, string domain);
    private void UnionEmail(string email1, string email2, ISet union);
    private void unionURI(string email1, string email2, ISet union);
    private ISet IntersectDns(ISet permitted, ISet dnss);
    private ISet UnionDns(ISet excluded, string dns);
    private void IntersectEmail(string email1, string email2, ISet intersect);
    private ISet IntersectUri(ISet permitted, ISet uris);
    private ISet UnionUri(ISet excluded, string uri);
    private void IntersectUri(string email1, string email2, ISet intersect);
    private static string ExtractHostFromURL(string url);
    public void checkPermitted(GeneralName name);
    public void checkExcluded(GeneralName name);
    public void IntersectPermittedSubtree(Asn1Sequence permitted);
    private string ExtractNameAsString(GeneralName name);
    public void IntersectEmptyPermittedSubtree(int nameType);
    public void AddExcludedSubtree(GeneralSubtree subtree);
    private static Byte[] Max(Byte[] ip1, Byte[] ip2);
    private static Byte[] Min(Byte[] ip1, Byte[] ip2);
    private static int CompareTo(Byte[] ip1, Byte[] ip2);
    private static Byte[] Or(Byte[] ip1, Byte[] ip2);
    [ObsoleteAttribute("Use GetHashCode instead")]
public int HashCode();
    public virtual int GetHashCode();
    private int HashCollection(ICollection c);
    public virtual bool Equals(object o);
    private bool CollectionsAreEqual(ICollection coll1, ICollection coll2);
    private bool SpecialEquals(object o1, object o2);
    private string StringifyIP(Byte[] ip);
    private string StringifyIPCollection(ISet ips);
    private string StringifyOtherNameCollection(ISet otherNames);
    public virtual string ToString();
}
public class Org.BouncyCastle.Pkix.PkixNameConstraintValidatorException : Exception {
    public PkixNameConstraintValidatorException(string msg);
}
public class Org.BouncyCastle.Pkix.PkixParameters : object {
    public static int PkixValidityModel;
    public static int ChainValidityModel;
    private ISet trustAnchors;
    private DateTimeObject date;
    private IList certPathCheckers;
    private bool revocationEnabled;
    private ISet initialPolicies;
    private bool explicitPolicyRequired;
    private bool anyPolicyInhibited;
    private bool policyMappingInhibited;
    private bool policyQualifiersRejected;
    private IX509Selector certSelector;
    private IList stores;
    private IX509Selector selector;
    private bool additionalLocationsEnabled;
    private IList additionalStores;
    private ISet trustedACIssuers;
    private ISet necessaryACAttributes;
    private ISet prohibitedACAttributes;
    private ISet attrCertCheckers;
    private int validityModel;
    private bool useDeltas;
    public bool IsRevocationEnabled { get; public set; }
    public bool IsExplicitPolicyRequired { get; public set; }
    public bool IsAnyPolicyInhibited { get; public set; }
    public bool IsPolicyMappingInhibited { get; public set; }
    public bool IsPolicyQualifiersRejected { get; public set; }
    public DateTimeObject Date { get; public set; }
    public bool IsUseDeltasEnabled { get; public set; }
    public int ValidityModel { get; public set; }
    public bool IsAdditionalLocationsEnabled { get; }
    public PkixParameters(ISet trustAnchors);
    public virtual bool get_IsRevocationEnabled();
    public virtual void set_IsRevocationEnabled(bool value);
    public virtual bool get_IsExplicitPolicyRequired();
    public virtual void set_IsExplicitPolicyRequired(bool value);
    public virtual bool get_IsAnyPolicyInhibited();
    public virtual void set_IsAnyPolicyInhibited(bool value);
    public virtual bool get_IsPolicyMappingInhibited();
    public virtual void set_IsPolicyMappingInhibited(bool value);
    public virtual bool get_IsPolicyQualifiersRejected();
    public virtual void set_IsPolicyQualifiersRejected(bool value);
    public virtual DateTimeObject get_Date();
    public virtual void set_Date(DateTimeObject value);
    public virtual ISet GetTrustAnchors();
    public virtual void SetTrustAnchors(ISet tas);
    public virtual X509CertStoreSelector GetTargetCertConstraints();
    public virtual void SetTargetCertConstraints(IX509Selector selector);
    public virtual ISet GetInitialPolicies();
    public virtual void SetInitialPolicies(ISet initialPolicies);
    public virtual void SetCertPathCheckers(IList checkers);
    public virtual IList GetCertPathCheckers();
    public virtual void AddCertPathChecker(PkixCertPathChecker checker);
    public virtual object Clone();
    protected virtual void SetParams(PkixParameters parameters);
    public virtual bool get_IsUseDeltasEnabled();
    public virtual void set_IsUseDeltasEnabled(bool value);
    public virtual int get_ValidityModel();
    public virtual void set_ValidityModel(int value);
    public virtual void SetStores(IList stores);
    public virtual void AddStore(IX509Store store);
    public virtual void AddAdditionalStore(IX509Store store);
    public virtual IList GetAdditionalStores();
    public virtual IList GetStores();
    public virtual bool get_IsAdditionalLocationsEnabled();
    public virtual void SetAdditionalLocationsEnabled(bool enabled);
    public virtual IX509Selector GetTargetConstraints();
    public virtual void SetTargetConstraints(IX509Selector selector);
    public virtual ISet GetTrustedACIssuers();
    public virtual void SetTrustedACIssuers(ISet trustedACIssuers);
    public virtual ISet GetNecessaryACAttributes();
    public virtual void SetNecessaryACAttributes(ISet necessaryACAttributes);
    public virtual ISet GetProhibitedACAttributes();
    public virtual void SetProhibitedACAttributes(ISet prohibitedACAttributes);
    public virtual ISet GetAttrCertCheckers();
    public virtual void SetAttrCertCheckers(ISet attrCertCheckers);
}
public class Org.BouncyCastle.Pkix.PkixPolicyNode : object {
    protected IList mChildren;
    protected int mDepth;
    protected ISet mExpectedPolicies;
    protected PkixPolicyNode mParent;
    protected ISet mPolicyQualifiers;
    protected string mValidPolicy;
    protected bool mCritical;
    public int Depth { get; }
    public IEnumerable Children { get; }
    public bool IsCritical { get; public set; }
    public ISet PolicyQualifiers { get; }
    public string ValidPolicy { get; }
    public bool HasChildren { get; }
    public ISet ExpectedPolicies { get; public set; }
    public PkixPolicyNode Parent { get; public set; }
    public PkixPolicyNode(IList children, int depth, ISet expectedPolicies, PkixPolicyNode parent, ISet policyQualifiers, string validPolicy, bool critical);
    public virtual int get_Depth();
    public virtual IEnumerable get_Children();
    public virtual bool get_IsCritical();
    public virtual void set_IsCritical(bool value);
    public virtual ISet get_PolicyQualifiers();
    public virtual string get_ValidPolicy();
    public virtual bool get_HasChildren();
    public virtual ISet get_ExpectedPolicies();
    public virtual void set_ExpectedPolicies(ISet value);
    public virtual PkixPolicyNode get_Parent();
    public virtual void set_Parent(PkixPolicyNode value);
    public virtual void AddChild(PkixPolicyNode child);
    public virtual void RemoveChild(PkixPolicyNode child);
    public virtual string ToString();
    public virtual string ToString(string indent);
    public virtual object Clone();
    public virtual PkixPolicyNode Copy();
}
internal class Org.BouncyCastle.Pkix.ReasonsMask : object {
    private int _reasons;
    internal static ReasonsMask AllReasons;
    internal bool IsAllReasons { get; }
    public ReasonFlags Reasons { get; }
    internal ReasonsMask(int reasons);
    private static ReasonsMask();
    internal void AddReasons(ReasonsMask mask);
    internal bool get_IsAllReasons();
    internal ReasonsMask Intersect(ReasonsMask mask);
    internal bool HasNewReasons(ReasonsMask mask);
    public ReasonFlags get_Reasons();
}
public class Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities : object {
    private static PkixCrlUtilities CrlUtilities;
    internal static string ANY_POLICY;
    internal static int KEY_CERT_SIGN;
    internal static int CRL_SIGN;
    internal static String[] CrlReasons;
    private static Rfc3280CertPathUtilities();
    internal static void ProcessCrlB2(DistributionPoint dp, object cert, X509Crl crl);
    internal static void ProcessCertBC(PkixCertPath certPath, int index, PkixNameConstraintValidator nameConstraintValidator);
    internal static void PrepareNextCertA(PkixCertPath certPath, int index);
    internal static PkixPolicyNode ProcessCertD(PkixCertPath certPath, int index, ISet acceptablePolicies, PkixPolicyNode validPolicyTree, IList[] policyNodes, int inhibitAnyPolicy);
    internal static void ProcessCrlB1(DistributionPoint dp, object cert, X509Crl crl);
    internal static ReasonsMask ProcessCrlD(X509Crl crl, DistributionPoint dp);
    internal static ISet ProcessCrlF(X509Crl crl, object cert, X509Certificate defaultCRLSignCert, AsymmetricKeyParameter defaultCRLSignKey, PkixParameters paramsPKIX, IList certPathCerts);
    internal static AsymmetricKeyParameter ProcessCrlG(X509Crl crl, ISet keys);
    internal static X509Crl ProcessCrlH(ISet deltaCrls, AsymmetricKeyParameter key);
    private static void CheckCrl(DistributionPoint dp, PkixParameters paramsPKIX, X509Certificate cert, DateTime validDate, X509Certificate defaultCRLSignCert, AsymmetricKeyParameter defaultCRLSignKey, CertStatus certStatus, ReasonsMask reasonMask, IList certPathCerts);
    protected static void CheckCrls(PkixParameters paramsPKIX, X509Certificate cert, DateTime validDate, X509Certificate sign, AsymmetricKeyParameter workingPublicKey, IList certPathCerts);
    internal static PkixPolicyNode PrepareCertB(PkixCertPath certPath, int index, IList[] policyNodes, PkixPolicyNode validPolicyTree, int policyMapping);
    internal static ISet[] ProcessCrlA1ii(DateTime currentDate, PkixParameters paramsPKIX, X509Certificate cert, X509Crl crl);
    internal static ISet ProcessCrlA1i(DateTime currentDate, PkixParameters paramsPKIX, X509Certificate cert, X509Crl crl);
    internal static void ProcessCertF(PkixCertPath certPath, int index, PkixPolicyNode validPolicyTree, int explicitPolicy);
    internal static void ProcessCertA(PkixCertPath certPath, PkixParameters paramsPKIX, int index, AsymmetricKeyParameter workingPublicKey, X509Name workingIssuerName, X509Certificate sign);
    internal static int PrepareNextCertI1(PkixCertPath certPath, int index, int explicitPolicy);
    internal static int PrepareNextCertI2(PkixCertPath certPath, int index, int policyMapping);
    internal static void PrepareNextCertG(PkixCertPath certPath, int index, PkixNameConstraintValidator nameConstraintValidator);
    internal static int PrepareNextCertJ(PkixCertPath certPath, int index, int inhibitAnyPolicy);
    internal static void PrepareNextCertK(PkixCertPath certPath, int index);
    internal static int PrepareNextCertL(PkixCertPath certPath, int index, int maxPathLength);
    internal static int PrepareNextCertM(PkixCertPath certPath, int index, int maxPathLength);
    internal static void PrepareNextCertN(PkixCertPath certPath, int index);
    internal static void PrepareNextCertO(PkixCertPath certPath, int index, ISet criticalExtensions, IList pathCheckers);
    internal static int PrepareNextCertH1(PkixCertPath certPath, int index, int explicitPolicy);
    internal static int PrepareNextCertH2(PkixCertPath certPath, int index, int policyMapping);
    internal static int PrepareNextCertH3(PkixCertPath certPath, int index, int inhibitAnyPolicy);
    internal static int WrapupCertA(int explicitPolicy, X509Certificate cert);
    internal static int WrapupCertB(PkixCertPath certPath, int index, int explicitPolicy);
    internal static void WrapupCertF(PkixCertPath certPath, int index, IList pathCheckers, ISet criticalExtensions);
    internal static PkixPolicyNode WrapupCertG(PkixCertPath certPath, PkixParameters paramsPKIX, ISet userInitialPolicySet, int index, IList[] policyNodes, PkixPolicyNode validPolicyTree, ISet acceptablePolicies);
    internal static void ProcessCrlC(X509Crl deltaCRL, X509Crl completeCRL, PkixParameters pkixParams);
    internal static void ProcessCrlI(DateTime validDate, X509Crl deltacrl, object cert, CertStatus certStatus, PkixParameters pkixParams);
    internal static void ProcessCrlJ(DateTime validDate, X509Crl completecrl, object cert, CertStatus certStatus);
    internal static PkixPolicyNode ProcessCertE(PkixCertPath certPath, int index, PkixPolicyNode validPolicyTree);
}
internal class Org.BouncyCastle.Pkix.Rfc3281CertPathUtilities : object {
    internal static void ProcessAttrCert7(IX509AttributeCertificate attrCert, PkixCertPath certPath, PkixCertPath holderCertPath, PkixParameters pkixParams);
    internal static void CheckCrls(IX509AttributeCertificate attrCert, PkixParameters paramsPKIX, X509Certificate issuerCert, DateTime validDate, IList certPathCerts);
    internal static void AdditionalChecks(IX509AttributeCertificate attrCert, PkixParameters pkixParams);
    internal static void ProcessAttrCert5(IX509AttributeCertificate attrCert, PkixParameters pkixParams);
    internal static void ProcessAttrCert4(X509Certificate acIssuerCert, PkixParameters pkixParams);
    internal static void ProcessAttrCert3(X509Certificate acIssuerCert, PkixParameters pkixParams);
    internal static PkixCertPathValidatorResult ProcessAttrCert2(PkixCertPath certPath, PkixParameters pkixParams);
    internal static PkixCertPath ProcessAttrCert1(IX509AttributeCertificate attrCert, PkixParameters pkixParams);
    private static void CheckCrl(DistributionPoint dp, IX509AttributeCertificate attrCert, PkixParameters paramsPKIX, DateTime validDate, X509Certificate issuerCert, CertStatus certStatus, ReasonsMask reasonMask, IList certPathCerts);
}
public class Org.BouncyCastle.Pkix.TrustAnchor : object {
    private AsymmetricKeyParameter pubKey;
    private string caName;
    private X509Name caPrincipal;
    private X509Certificate trustedCert;
    private Byte[] ncBytes;
    private NameConstraints nc;
    public X509Certificate TrustedCert { get; }
    public X509Name CA { get; }
    public string CAName { get; }
    public AsymmetricKeyParameter CAPublicKey { get; }
    public Byte[] GetNameConstraints { get; }
    public TrustAnchor(X509Certificate trustedCert, Byte[] nameConstraints);
    public TrustAnchor(X509Name caPrincipal, AsymmetricKeyParameter pubKey, Byte[] nameConstraints);
    public TrustAnchor(string caName, AsymmetricKeyParameter pubKey, Byte[] nameConstraints);
    public X509Certificate get_TrustedCert();
    public X509Name get_CA();
    public string get_CAName();
    public AsymmetricKeyParameter get_CAPublicKey();
    private void setNameConstraints(Byte[] bytes);
    public Byte[] get_GetNameConstraints();
    public virtual string ToString();
}
public class Org.BouncyCastle.Security.AgreementUtilities : object {
    private static IDictionary algorithms;
    private static AgreementUtilities();
    public static IBasicAgreement GetBasicAgreement(DerObjectIdentifier oid);
    public static IBasicAgreement GetBasicAgreement(string algorithm);
    public static IBasicAgreement GetBasicAgreementWithKdf(DerObjectIdentifier oid, string wrapAlgorithm);
    public static IBasicAgreement GetBasicAgreementWithKdf(string agreeAlgorithm, string wrapAlgorithm);
    public static IRawAgreement GetRawAgreement(DerObjectIdentifier oid);
    public static IRawAgreement GetRawAgreement(string algorithm);
    public static string GetAlgorithmName(DerObjectIdentifier oid);
    private static string GetMechanism(string algorithm);
}
public class Org.BouncyCastle.Security.Certificates.CertificateEncodingException : CertificateException {
    public CertificateEncodingException(string msg);
    public CertificateEncodingException(string msg, Exception e);
}
public class Org.BouncyCastle.Security.Certificates.CertificateException : GeneralSecurityException {
    public CertificateException(string message);
    public CertificateException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.Certificates.CertificateExpiredException : CertificateException {
    public CertificateExpiredException(string message);
    public CertificateExpiredException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.Certificates.CertificateNotYetValidException : CertificateException {
    public CertificateNotYetValidException(string message);
    public CertificateNotYetValidException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.Certificates.CertificateParsingException : CertificateException {
    public CertificateParsingException(string message);
    public CertificateParsingException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.Certificates.CrlException : GeneralSecurityException {
    public CrlException(string msg);
    public CrlException(string msg, Exception e);
}
public class Org.BouncyCastle.Security.CipherUtilities : object {
    private static IDictionary algorithms;
    private static IDictionary oids;
    public static ICollection Algorithms { get; }
    private static CipherUtilities();
    public static DerObjectIdentifier GetObjectIdentifier(string mechanism);
    public static ICollection get_Algorithms();
    public static IBufferedCipher GetCipher(DerObjectIdentifier oid);
    public static IBufferedCipher GetCipher(string algorithm);
    public static string GetAlgorithmName(DerObjectIdentifier oid);
    private static int GetDigitIndex(string s);
    private static IBlockCipher CreateBlockCipher(CipherAlgorithm cipherAlgorithm);
}
public class Org.BouncyCastle.Security.DigestUtilities : object {
    private static IDictionary algorithms;
    private static IDictionary oids;
    public static ICollection Algorithms { get; }
    private static DigestUtilities();
    public static DerObjectIdentifier GetObjectIdentifier(string mechanism);
    public static ICollection get_Algorithms();
    public static IDigest GetDigest(DerObjectIdentifier id);
    public static IDigest GetDigest(string algorithm);
    public static string GetAlgorithmName(DerObjectIdentifier oid);
    public static Byte[] CalculateDigest(DerObjectIdentifier id, Byte[] input);
    public static Byte[] CalculateDigest(string algorithm, Byte[] input);
    public static Byte[] DoFinal(IDigest digest);
    public static Byte[] DoFinal(IDigest digest, Byte[] input);
}
public class Org.BouncyCastle.Security.DotNetUtilities : object {
    public static X509Certificate ToX509Certificate(X509CertificateStructure x509Struct);
    public static X509Certificate ToX509Certificate(X509Certificate x509Cert);
    public static X509Certificate FromX509Certificate(X509Certificate x509Cert);
    public static AsymmetricCipherKeyPair GetDsaKeyPair(DSA dsa);
    public static AsymmetricCipherKeyPair GetDsaKeyPair(DSAParameters dp);
    public static DsaPublicKeyParameters GetDsaPublicKey(DSA dsa);
    public static DsaPublicKeyParameters GetDsaPublicKey(DSAParameters dp);
    public static AsymmetricCipherKeyPair GetRsaKeyPair(RSA rsa);
    public static AsymmetricCipherKeyPair GetRsaKeyPair(RSAParameters rp);
    public static RsaKeyParameters GetRsaPublicKey(RSA rsa);
    public static RsaKeyParameters GetRsaPublicKey(RSAParameters rp);
    public static AsymmetricCipherKeyPair GetKeyPair(AsymmetricAlgorithm privateKey);
    public static RSA ToRSA(RsaKeyParameters rsaKey);
    public static RSA ToRSA(RsaKeyParameters rsaKey, CspParameters csp);
    public static RSA ToRSA(RsaPrivateCrtKeyParameters privKey);
    public static RSA ToRSA(RsaPrivateCrtKeyParameters privKey, CspParameters csp);
    public static RSA ToRSA(RsaPrivateKeyStructure privKey);
    public static RSA ToRSA(RsaPrivateKeyStructure privKey, CspParameters csp);
    public static RSAParameters ToRSAParameters(RsaKeyParameters rsaKey);
    public static RSAParameters ToRSAParameters(RsaPrivateCrtKeyParameters privKey);
    public static RSAParameters ToRSAParameters(RsaPrivateKeyStructure privKey);
    private static Byte[] ConvertRSAParametersField(BigInteger n, int size);
    private static RSA CreateRSAProvider(RSAParameters rp);
    private static RSA CreateRSAProvider(RSAParameters rp, CspParameters csp);
}
public class Org.BouncyCastle.Security.EncryptionException : IOException {
    public EncryptionException(string message);
    public EncryptionException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.GeneralSecurityException : Exception {
    public GeneralSecurityException(string message);
    public GeneralSecurityException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.GeneratorUtilities : object {
    private static IDictionary kgAlgorithms;
    private static IDictionary kpgAlgorithms;
    private static IDictionary defaultKeySizes;
    private static GeneratorUtilities();
    private static void AddDefaultKeySizeEntries(int size, String[] algorithms);
    private static void AddKgAlgorithm(string canonicalName, Object[] aliases);
    private static void AddKpgAlgorithm(string canonicalName, Object[] aliases);
    private static void AddHMacKeyGenerator(string algorithm, Object[] aliases);
    internal static string GetCanonicalKeyGeneratorAlgorithm(string algorithm);
    internal static string GetCanonicalKeyPairGeneratorAlgorithm(string algorithm);
    public static CipherKeyGenerator GetKeyGenerator(DerObjectIdentifier oid);
    public static CipherKeyGenerator GetKeyGenerator(string algorithm);
    public static IAsymmetricCipherKeyPairGenerator GetKeyPairGenerator(DerObjectIdentifier oid);
    public static IAsymmetricCipherKeyPairGenerator GetKeyPairGenerator(string algorithm);
    internal static int GetDefaultKeySize(DerObjectIdentifier oid);
    internal static int GetDefaultKeySize(string algorithm);
    private static int FindDefaultKeySize(string canonicalName);
}
public class Org.BouncyCastle.Security.InvalidKeyException : KeyException {
    public InvalidKeyException(string message);
    public InvalidKeyException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.InvalidParameterException : KeyException {
    public InvalidParameterException(string message);
    public InvalidParameterException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.KeyException : GeneralSecurityException {
    public KeyException(string message);
    public KeyException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.MacUtilities : object {
    private static IDictionary algorithms;
    private static MacUtilities();
    public static IMac GetMac(DerObjectIdentifier id);
    public static IMac GetMac(string algorithm);
    public static string GetAlgorithmName(DerObjectIdentifier oid);
    public static Byte[] CalculateMac(string algorithm, ICipherParameters cp, Byte[] input);
    public static Byte[] DoFinal(IMac mac);
    public static Byte[] DoFinal(IMac mac, Byte[] input);
}
[ObsoleteAttribute("Never thrown")]
public class Org.BouncyCastle.Security.NoSuchAlgorithmException : GeneralSecurityException {
    public NoSuchAlgorithmException(string message);
    public NoSuchAlgorithmException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.ParameterUtilities : object {
    private static IDictionary algorithms;
    private static IDictionary basicIVSizes;
    private static ParameterUtilities();
    private static void AddAlgorithm(string canonicalName, Object[] aliases);
    private static void AddBasicIVSizeEntries(int size, String[] algorithms);
    public static string GetCanonicalAlgorithmName(string algorithm);
    public static KeyParameter CreateKeyParameter(DerObjectIdentifier algOid, Byte[] keyBytes);
    public static KeyParameter CreateKeyParameter(string algorithm, Byte[] keyBytes);
    public static KeyParameter CreateKeyParameter(DerObjectIdentifier algOid, Byte[] keyBytes, int offset, int length);
    public static KeyParameter CreateKeyParameter(string algorithm, Byte[] keyBytes, int offset, int length);
    public static ICipherParameters GetCipherParameters(DerObjectIdentifier algOid, ICipherParameters key, Asn1Object asn1Params);
    public static ICipherParameters GetCipherParameters(string algorithm, ICipherParameters key, Asn1Object asn1Params);
    public static Asn1Encodable GenerateParameters(DerObjectIdentifier algID, SecureRandom random);
    public static Asn1Encodable GenerateParameters(string algorithm, SecureRandom random);
    public static ICipherParameters WithRandom(ICipherParameters cp, SecureRandom random);
    private static Asn1OctetString CreateIVOctetString(SecureRandom random, int ivLength);
    private static Byte[] CreateIV(SecureRandom random, int ivLength);
    private static int FindBasicIVSize(string canonicalName);
}
public class Org.BouncyCastle.Security.PasswordException : IOException {
    public PasswordException(string message);
    public PasswordException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.PbeUtilities : object {
    private static string Pkcs5S1;
    private static string Pkcs5S2;
    private static string Pkcs12;
    private static string OpenSsl;
    private static IDictionary algorithms;
    private static IDictionary algorithmType;
    private static IDictionary oids;
    public static ICollection Algorithms { get; }
    private static PbeUtilities();
    private static PbeParametersGenerator MakePbeGenerator(string type, IDigest digest, Byte[] key, Byte[] salt, int iterationCount);
    public static DerObjectIdentifier GetObjectIdentifier(string mechanism);
    public static ICollection get_Algorithms();
    public static bool IsPkcs12(string algorithm);
    public static bool IsPkcs5Scheme1(string algorithm);
    public static bool IsPkcs5Scheme2(string algorithm);
    public static bool IsOpenSsl(string algorithm);
    public static bool IsPbeAlgorithm(string algorithm);
    public static Asn1Encodable GenerateAlgorithmParameters(DerObjectIdentifier algorithmOid, Byte[] salt, int iterationCount);
    public static Asn1Encodable GenerateAlgorithmParameters(string algorithm, Byte[] salt, int iterationCount);
    public static Asn1Encodable GenerateAlgorithmParameters(DerObjectIdentifier cipherAlgorithm, DerObjectIdentifier hashAlgorithm, Byte[] salt, int iterationCount, SecureRandom secureRandom);
    public static ICipherParameters GenerateCipherParameters(DerObjectIdentifier algorithmOid, Char[] password, Asn1Encodable pbeParameters);
    public static ICipherParameters GenerateCipherParameters(DerObjectIdentifier algorithmOid, Char[] password, bool wrongPkcs12Zero, Asn1Encodable pbeParameters);
    public static ICipherParameters GenerateCipherParameters(AlgorithmIdentifier algID, Char[] password);
    public static ICipherParameters GenerateCipherParameters(AlgorithmIdentifier algID, Char[] password, bool wrongPkcs12Zero);
    public static ICipherParameters GenerateCipherParameters(string algorithm, Char[] password, Asn1Encodable pbeParameters);
    public static ICipherParameters GenerateCipherParameters(string algorithm, Char[] password, bool wrongPkcs12Zero, Asn1Encodable pbeParameters);
    public static object CreateEngine(DerObjectIdentifier algorithmOid);
    public static object CreateEngine(AlgorithmIdentifier algID);
    public static object CreateEngine(string algorithm);
    public static string GetEncodingName(DerObjectIdentifier oid);
    private static ICipherParameters FixDesParity(string mechanism, ICipherParameters parameters);
}
public class Org.BouncyCastle.Security.PrivateKeyFactory : object {
    public static AsymmetricKeyParameter CreateKey(Byte[] privateKeyInfoData);
    public static AsymmetricKeyParameter CreateKey(Stream inStr);
    public static AsymmetricKeyParameter CreateKey(PrivateKeyInfo keyInfo);
    private static Byte[] GetRawKey(PrivateKeyInfo keyInfo);
    public static AsymmetricKeyParameter DecryptKey(Char[] passPhrase, EncryptedPrivateKeyInfo encInfo);
    public static AsymmetricKeyParameter DecryptKey(Char[] passPhrase, Byte[] encryptedPrivateKeyInfoData);
    public static AsymmetricKeyParameter DecryptKey(Char[] passPhrase, Stream encryptedPrivateKeyInfoStream);
    private static AsymmetricKeyParameter DecryptKey(Char[] passPhrase, Asn1Object asn1Object);
    public static Byte[] EncryptKey(DerObjectIdentifier algorithm, Char[] passPhrase, Byte[] salt, int iterationCount, AsymmetricKeyParameter key);
    public static Byte[] EncryptKey(string algorithm, Char[] passPhrase, Byte[] salt, int iterationCount, AsymmetricKeyParameter key);
}
public class Org.BouncyCastle.Security.PublicKeyFactory : object {
    public static AsymmetricKeyParameter CreateKey(Byte[] keyInfoData);
    public static AsymmetricKeyParameter CreateKey(Stream inStr);
    public static AsymmetricKeyParameter CreateKey(SubjectPublicKeyInfo keyInfo);
    private static Byte[] GetRawKey(SubjectPublicKeyInfo keyInfo);
    private static bool IsPkcsDHParam(Asn1Sequence seq);
    private static DHPublicKeyParameters ReadPkcsDHParam(DerObjectIdentifier algOid, BigInteger y, Asn1Sequence seq);
}
public class Org.BouncyCastle.Security.SecureRandom : Random {
    private static long counter;
    private static SecureRandom master;
    protected IRandomGenerator generator;
    private static double DoubleScale;
    private static SecureRandom Master { get; }
    [ObsoleteAttribute("Use GetInstance/SetSeed instead")]
public SecureRandom(Byte[] seed);
    public SecureRandom(IRandomGenerator generator);
    private static SecureRandom();
    private static long NextCounterValue();
    private static SecureRandom get_Master();
    private static DigestRandomGenerator CreatePrng(string digestName, bool autoSeed);
    public static Byte[] GetNextBytes(SecureRandom secureRandom, int length);
    public static SecureRandom GetInstance(string algorithm);
    public static SecureRandom GetInstance(string algorithm, bool autoSeed);
    [ObsoleteAttribute("Call GenerateSeed() on a SecureRandom instance instead")]
public static Byte[] GetSeed(int length);
    public virtual Byte[] GenerateSeed(int length);
    public virtual void SetSeed(Byte[] seed);
    public virtual void SetSeed(long seed);
    public virtual int Next();
    public virtual int Next(int maxValue);
    public virtual int Next(int minValue, int maxValue);
    public virtual void NextBytes(Byte[] buf);
    public virtual void NextBytes(Byte[] buf, int off, int len);
    public virtual double NextDouble();
    public virtual int NextInt();
    public virtual long NextLong();
}
public class Org.BouncyCastle.Security.SecurityUtilityException : Exception {
    public SecurityUtilityException(string message);
    public SecurityUtilityException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.SignatureException : GeneralSecurityException {
    public SignatureException(string message);
    public SignatureException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.SignerUtilities : object {
    internal static IDictionary algorithms;
    internal static IDictionary oids;
    public static ICollection Algorithms { get; }
    private static SignerUtilities();
    public static DerObjectIdentifier GetObjectIdentifier(string mechanism);
    public static ICollection get_Algorithms();
    public static Asn1Encodable GetDefaultX509Parameters(DerObjectIdentifier id);
    public static Asn1Encodable GetDefaultX509Parameters(string algorithm);
    private static Asn1Encodable GetPssX509Parameters(string digestName);
    public static ISigner GetSigner(DerObjectIdentifier id);
    public static ISigner GetSigner(string algorithm);
    public static string GetEncodingName(DerObjectIdentifier oid);
    public static ISigner InitSigner(DerObjectIdentifier algorithmOid, bool forSigning, AsymmetricKeyParameter privateKey, SecureRandom random);
    public static ISigner InitSigner(string algorithm, bool forSigning, AsymmetricKeyParameter privateKey, SecureRandom random);
}
public class Org.BouncyCastle.Security.WrapperUtilities : object {
    private static IDictionary algorithms;
    private static WrapperUtilities();
    public static IWrapper GetWrapper(DerObjectIdentifier oid);
    public static IWrapper GetWrapper(string algorithm);
    public static string GetAlgorithmName(DerObjectIdentifier oid);
}
public abstract class Org.BouncyCastle.Tls.AbstractTlsClient : AbstractTlsPeer {
    protected TlsClientContext m_context;
    protected ProtocolVersion[] m_protocolVersions;
    protected Int32[] m_cipherSuites;
    protected IList m_supportedGroups;
    protected IList m_supportedSignatureAlgorithms;
    protected IList m_supportedSignatureAlgorithmsCert;
    protected AbstractTlsClient(TlsCrypto crypto);
    protected virtual bool AllowUnexpectedServerExtension(int extensionType, Byte[] extensionData);
    protected virtual IList GetNamedGroupRoles();
    protected virtual void CheckForUnexpectedServerExtension(IDictionary serverExtensions, int extensionType);
    public virtual TlsPskIdentity GetPskIdentity();
    public virtual TlsSrpIdentity GetSrpIdentity();
    public virtual TlsDHGroupVerifier GetDHGroupVerifier();
    public virtual TlsSrpConfigVerifier GetSrpConfigVerifier();
    protected virtual IList GetCertificateAuthorities();
    protected virtual IList GetProtocolNames();
    protected virtual CertificateStatusRequest GetCertificateStatusRequest();
    protected virtual IList GetMultiCertStatusRequest();
    protected virtual IList GetSniServerNames();
    protected virtual IList GetSupportedGroups(IList namedGroupRoles);
    protected virtual IList GetSupportedSignatureAlgorithms();
    protected virtual IList GetSupportedSignatureAlgorithmsCert();
    protected virtual IList GetTrustedCAIndication();
    public virtual void Init(TlsClientContext context);
    public virtual ProtocolVersion[] GetProtocolVersions();
    public virtual Int32[] GetCipherSuites();
    public virtual void NotifyHandshakeBeginning();
    public virtual TlsSession GetSessionToResume();
    public virtual IList GetExternalPsks();
    public virtual bool IsFallback();
    public virtual IDictionary GetClientExtensions();
    public virtual IList GetEarlyKeyShareGroups();
    public virtual void NotifyServerVersion(ProtocolVersion serverVersion);
    public virtual void NotifySessionToResume(TlsSession session);
    public virtual void NotifySessionID(Byte[] sessionID);
    public virtual void NotifySelectedCipherSuite(int selectedCipherSuite);
    public virtual void NotifySelectedPsk(TlsPsk selectedPsk);
    public virtual void ProcessServerExtensions(IDictionary serverExtensions);
    public virtual void ProcessServerSupplementalData(IList serverSupplementalData);
    public abstract virtual TlsAuthentication GetAuthentication();
    public virtual IList GetClientSupplementalData();
    public virtual void NotifyNewSessionTicket(NewSessionTicket newSessionTicket);
}
internal abstract class Org.BouncyCastle.Tls.AbstractTlsContext : object {
    private static long counter;
    private TlsCrypto m_crypto;
    private int m_connectionEnd;
    private TlsNonceGenerator m_nonceGenerator;
    private SecurityParameters m_securityParameters;
    private ProtocolVersion[] m_clientSupportedVersions;
    private ProtocolVersion m_clientVersion;
    private ProtocolVersion m_rsaPreMasterSecretVersion;
    private TlsSession m_session;
    private object m_userObject;
    private bool m_connected;
    internal bool IsConnected { get; }
    internal bool IsHandshaking { get; }
    public TlsCrypto Crypto { get; }
    public TlsNonceGenerator NonceGenerator { get; }
    public SecurityParameters SecurityParameters { get; }
    public bool IsServer { get; }
    public ProtocolVersion[] ClientSupportedVersions { get; }
    public ProtocolVersion ClientVersion { get; }
    public ProtocolVersion RsaPreMasterSecretVersion { get; }
    public ProtocolVersion ServerVersion { get; }
    public TlsSession ResumableSession { get; }
    public TlsSession Session { get; }
    public object UserObject { get; public set; }
    internal AbstractTlsContext(TlsCrypto crypto, int connectionEnd);
    private static AbstractTlsContext();
    private static long NextCounterValue();
    private static TlsNonceGenerator CreateNonceGenerator(TlsCrypto crypto, int connectionEnd);
    internal void HandshakeBeginning(TlsPeer peer);
    internal void HandshakeComplete(TlsPeer peer, TlsSession session);
    internal bool get_IsConnected();
    internal bool get_IsHandshaking();
    public sealed virtual TlsCrypto get_Crypto();
    public virtual TlsNonceGenerator get_NonceGenerator();
    public sealed virtual SecurityParameters get_SecurityParameters();
    public abstract virtual bool get_IsServer();
    public virtual ProtocolVersion[] get_ClientSupportedVersions();
    internal void SetClientSupportedVersions(ProtocolVersion[] clientSupportedVersions);
    public virtual ProtocolVersion get_ClientVersion();
    internal void SetClientVersion(ProtocolVersion clientVersion);
    public virtual ProtocolVersion get_RsaPreMasterSecretVersion();
    internal void SetRsaPreMasterSecretVersion(ProtocolVersion rsaPreMasterSecretVersion);
    public virtual ProtocolVersion get_ServerVersion();
    public virtual TlsSession get_ResumableSession();
    public virtual TlsSession get_Session();
    public virtual object get_UserObject();
    public virtual void set_UserObject(object value);
    public virtual Byte[] ExportChannelBinding(int channelBinding);
    public virtual Byte[] ExportEarlyKeyingMaterial(string asciiLabel, Byte[] context, int length);
    public virtual Byte[] ExportKeyingMaterial(string asciiLabel, Byte[] context, int length);
    protected virtual Byte[] ExportKeyingMaterial13(TlsSecret secret, int cryptoHashAlgorithm, string asciiLabel, Byte[] context, int length);
    protected virtual TlsSecret CheckEarlyExportSecret(TlsSecret secret);
    protected virtual TlsSecret CheckExportSecret(TlsSecret secret);
}
public abstract class Org.BouncyCastle.Tls.AbstractTlsKeyExchange : object {
    protected int m_keyExchange;
    protected TlsContext m_context;
    public bool RequiresServerKeyExchange { get; }
    public bool RequiresCertificateVerify { get; }
    protected AbstractTlsKeyExchange(int keyExchange);
    public virtual void Init(TlsContext context);
    public abstract virtual void SkipServerCredentials();
    public abstract virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual bool get_RequiresServerKeyExchange();
    public virtual Byte[] GenerateServerKeyExchange();
    public virtual void SkipServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    public virtual Int16[] GetClientCertificateTypes();
    public virtual void SkipClientCredentials();
    public abstract virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void ProcessClientCertificate(Certificate clientCertificate);
    public abstract virtual void GenerateClientKeyExchange(Stream output);
    public virtual void ProcessClientKeyExchange(Stream input);
    public virtual bool get_RequiresCertificateVerify();
    public abstract virtual TlsSecret GeneratePreMasterSecret();
}
public abstract class Org.BouncyCastle.Tls.AbstractTlsKeyExchangeFactory : object {
    public virtual TlsKeyExchange CreateDHKeyExchange(int keyExchange);
    public virtual TlsKeyExchange CreateDHanonKeyExchangeClient(int keyExchange, TlsDHGroupVerifier dhGroupVerifier);
    public virtual TlsKeyExchange CreateDHanonKeyExchangeServer(int keyExchange, TlsDHConfig dhConfig);
    public virtual TlsKeyExchange CreateDheKeyExchangeClient(int keyExchange, TlsDHGroupVerifier dhGroupVerifier);
    public virtual TlsKeyExchange CreateDheKeyExchangeServer(int keyExchange, TlsDHConfig dhConfig);
    public virtual TlsKeyExchange CreateECDHKeyExchange(int keyExchange);
    public virtual TlsKeyExchange CreateECDHanonKeyExchangeClient(int keyExchange);
    public virtual TlsKeyExchange CreateECDHanonKeyExchangeServer(int keyExchange, TlsECConfig ecConfig);
    public virtual TlsKeyExchange CreateECDheKeyExchangeClient(int keyExchange);
    public virtual TlsKeyExchange CreateECDheKeyExchangeServer(int keyExchange, TlsECConfig ecConfig);
    public virtual TlsKeyExchange CreatePskKeyExchangeClient(int keyExchange, TlsPskIdentity pskIdentity, TlsDHGroupVerifier dhGroupVerifier);
    public virtual TlsKeyExchange CreatePskKeyExchangeServer(int keyExchange, TlsPskIdentityManager pskIdentityManager, TlsDHConfig dhConfig, TlsECConfig ecConfig);
    public virtual TlsKeyExchange CreateRsaKeyExchange(int keyExchange);
    public virtual TlsKeyExchange CreateSrpKeyExchangeClient(int keyExchange, TlsSrpIdentity srpIdentity, TlsSrpConfigVerifier srpConfigVerifier);
    public virtual TlsKeyExchange CreateSrpKeyExchangeServer(int keyExchange, TlsSrpLoginParameters loginParameters);
}
public abstract class Org.BouncyCastle.Tls.AbstractTlsPeer : object {
    private TlsCrypto m_crypto;
    private TlsCloseable modreq(System.Runtime.CompilerServices.IsVolatile) m_closeHandle;
    public TlsCrypto Crypto { get; }
    protected AbstractTlsPeer(TlsCrypto crypto);
    protected virtual ProtocolVersion[] GetSupportedVersions();
    protected abstract virtual Int32[] GetSupportedCipherSuites();
    public virtual void Cancel();
    public virtual TlsCrypto get_Crypto();
    public virtual void NotifyCloseHandle(TlsCloseable closeHandle);
    public abstract virtual ProtocolVersion[] GetProtocolVersions();
    public abstract virtual Int32[] GetCipherSuites();
    public virtual void NotifyHandshakeBeginning();
    public virtual int GetHandshakeTimeoutMillis();
    public virtual bool AllowLegacyResumption();
    public virtual int GetMaxCertificateChainLength();
    public virtual int GetMaxHandshakeMessageSize();
    public virtual Int16[] GetPskKeyExchangeModes();
    public virtual bool RequiresCloseNotify();
    public virtual bool RequiresExtendedMasterSecret();
    public virtual bool ShouldCheckSigAlgOfPeerCerts();
    public virtual bool ShouldUseExtendedMasterSecret();
    public virtual bool ShouldUseExtendedPadding();
    public virtual bool ShouldUseGmtUnixTime();
    public virtual void NotifySecureRenegotiation(bool secureRenegotiation);
    public virtual TlsKeyExchangeFactory GetKeyExchangeFactory();
    public virtual void NotifyAlertRaised(short alertLevel, short alertDescription, string message, Exception cause);
    public virtual void NotifyAlertReceived(short alertLevel, short alertDescription);
    public virtual void NotifyHandshakeComplete();
    public virtual TlsHeartbeat GetHeartbeat();
    public virtual short GetHeartbeatPolicy();
}
public abstract class Org.BouncyCastle.Tls.AbstractTlsServer : AbstractTlsPeer {
    protected TlsServerContext m_context;
    protected ProtocolVersion[] m_protocolVersions;
    protected Int32[] m_cipherSuites;
    protected Int32[] m_offeredCipherSuites;
    protected IDictionary m_clientExtensions;
    protected bool m_encryptThenMACOffered;
    protected short m_maxFragmentLengthOffered;
    protected bool m_truncatedHMacOffered;
    protected bool m_clientSentECPointFormats;
    protected CertificateStatusRequest m_certificateStatusRequest;
    protected IList m_statusRequestV2;
    protected IList m_trustedCAKeys;
    protected int m_selectedCipherSuite;
    protected IList m_clientProtocolNames;
    protected ProtocolName m_selectedProtocolName;
    protected IDictionary m_serverExtensions;
    public AbstractTlsServer(TlsCrypto crypto);
    protected virtual bool AllowCertificateStatus();
    protected virtual bool AllowEncryptThenMac();
    protected virtual bool AllowMultiCertStatus();
    protected virtual bool AllowTruncatedHmac();
    protected virtual bool AllowTrustedCAIndication();
    protected virtual int GetMaximumNegotiableCurveBits();
    protected virtual int GetMaximumNegotiableFiniteFieldBits();
    protected virtual IList GetProtocolNames();
    protected virtual bool IsSelectableCipherSuite(int cipherSuite, int availCurveBits, int availFiniteFieldBits, IList sigAlgs);
    protected virtual bool PreferLocalCipherSuites();
    protected virtual bool SelectCipherSuite(int cipherSuite);
    protected virtual int SelectDH(int minimumFiniteFieldBits);
    protected virtual int SelectDHDefault(int minimumFiniteFieldBits);
    protected virtual int SelectECDH(int minimumCurveBits);
    protected virtual int SelectECDHDefault(int minimumCurveBits);
    protected virtual ProtocolName SelectProtocolName();
    protected virtual ProtocolName SelectProtocolName(IList clientProtocolNames, IList serverProtocolNames);
    protected virtual bool ShouldSelectProtocolNameEarly();
    public virtual void Init(TlsServerContext context);
    public virtual ProtocolVersion[] GetProtocolVersions();
    public virtual Int32[] GetCipherSuites();
    public virtual void NotifyHandshakeBeginning();
    public virtual TlsSession GetSessionToResume(Byte[] sessionID);
    public virtual Byte[] GetNewSessionID();
    public virtual TlsPskExternal GetExternalPsk(IList identities);
    public virtual void NotifySession(TlsSession session);
    public virtual void NotifyClientVersion(ProtocolVersion clientVersion);
    public virtual void NotifyFallback(bool isFallback);
    public virtual void NotifyOfferedCipherSuites(Int32[] offeredCipherSuites);
    public virtual void ProcessClientExtensions(IDictionary clientExtensions);
    public virtual ProtocolVersion GetServerVersion();
    public virtual Int32[] GetSupportedGroups();
    public virtual int GetSelectedCipherSuite();
    public virtual IDictionary GetServerExtensions();
    public virtual void GetServerExtensionsForConnection(IDictionary serverExtensions);
    public virtual IList GetServerSupplementalData();
    public abstract virtual TlsCredentials GetCredentials();
    public virtual CertificateStatus GetCertificateStatus();
    public virtual CertificateRequest GetCertificateRequest();
    public virtual TlsPskIdentityManager GetPskIdentityManager();
    public virtual TlsSrpLoginParameters GetSrpLoginParameters();
    public virtual TlsDHConfig GetDHConfig();
    public virtual TlsECConfig GetECDHConfig();
    public virtual void ProcessClientSupplementalData(IList clientSupplementalData);
    public virtual void NotifyClientCertificate(Certificate clientCertificate);
    public virtual NewSessionTicket GetNewSessionTicket();
}
public abstract class Org.BouncyCastle.Tls.AlertDescription : object {
    public static short close_notify;
    public static short unexpected_message;
    public static short bad_record_mac;
    public static short decryption_failed;
    public static short record_overflow;
    public static short decompression_failure;
    public static short handshake_failure;
    public static short no_certificate;
    public static short bad_certificate;
    public static short unsupported_certificate;
    public static short certificate_revoked;
    public static short certificate_expired;
    public static short certificate_unknown;
    public static short illegal_parameter;
    public static short unknown_ca;
    public static short access_denied;
    public static short decode_error;
    public static short decrypt_error;
    public static short export_restriction;
    public static short protocol_version;
    public static short insufficient_security;
    public static short internal_error;
    public static short user_canceled;
    public static short no_renegotiation;
    public static short unsupported_extension;
    public static short certificate_unobtainable;
    public static short unrecognized_name;
    public static short bad_certificate_status_response;
    public static short bad_certificate_hash_value;
    public static short unknown_psk_identity;
    public static short no_application_protocol;
    public static short inappropriate_fallback;
    public static short missing_extension;
    public static short certificate_required;
    public static string GetName(short alertDescription);
    public static string GetText(short alertDescription);
}
public abstract class Org.BouncyCastle.Tls.AlertLevel : object {
    public static short warning;
    public static short fatal;
    public static string GetName(short alertDescription);
    public static string GetText(short alertDescription);
}
public class Org.BouncyCastle.Tls.BasicTlsPskExternal : object {
    protected Byte[] m_identity;
    protected TlsSecret m_key;
    protected int m_prfAlgorithm;
    public Byte[] Identity { get; }
    public TlsSecret Key { get; }
    public int PrfAlgorithm { get; }
    public BasicTlsPskExternal(Byte[] identity, TlsSecret key);
    public BasicTlsPskExternal(Byte[] identity, TlsSecret key, int prfAlgorithm);
    public virtual Byte[] get_Identity();
    public virtual TlsSecret get_Key();
    public virtual int get_PrfAlgorithm();
}
public class Org.BouncyCastle.Tls.BasicTlsPskIdentity : object {
    protected Byte[] m_identity;
    protected Byte[] m_psk;
    public BasicTlsPskIdentity(Byte[] identity, Byte[] psk);
    public BasicTlsPskIdentity(string identity, Byte[] psk);
    public virtual void SkipIdentityHint();
    public virtual void NotifyIdentityHint(Byte[] psk_identity_hint);
    public virtual Byte[] GetPskIdentity();
    public sealed virtual Byte[] GetPsk();
}
public class Org.BouncyCastle.Tls.BasicTlsSrpIdentity : object {
    protected Byte[] m_identity;
    protected Byte[] m_password;
    public BasicTlsSrpIdentity(Byte[] identity, Byte[] password);
    public BasicTlsSrpIdentity(string identity, string password);
    public virtual Byte[] GetSrpIdentity();
    public virtual Byte[] GetSrpPassword();
}
public class Org.BouncyCastle.Tls.ByteQueue : object {
    private Byte[] m_databuf;
    private int m_skipped;
    private int m_available;
    private bool m_readOnlyBuf;
    public int Available { get; }
    public ByteQueue(int capacity);
    public ByteQueue(Byte[] buf, int off, int len);
    public static int NextTwoPow(int i);
    public void AddData(Byte[] buf, int off, int len);
    public int get_Available();
    public void CopyTo(Stream output, int length);
    public void Read(Byte[] buf, int offset, int len, int skip);
    internal HandshakeMessageInput ReadHandshakeMessage(int length);
    public int ReadInt32();
    public void RemoveData(int i);
    public void RemoveData(Byte[] buf, int off, int len, int skip);
    public Byte[] RemoveData(int len, int skip);
    public void Shrink();
}
public class Org.BouncyCastle.Tls.ByteQueueInputStream : BaseInputStream {
    private ByteQueue m_buffer;
    public int Available { get; }
    public void AddBytes(Byte[] buf);
    public void AddBytes(Byte[] buf, int bufOff, int bufLen);
    public int Peek(Byte[] buf);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buf, int off, int len);
    public long Skip(long n);
    public int get_Available();
    public virtual void Close();
}
public class Org.BouncyCastle.Tls.ByteQueueOutputStream : BaseOutputStream {
    private ByteQueue m_buffer;
    public ByteQueue Buffer { get; }
    public ByteQueue get_Buffer();
    public virtual void WriteByte(byte b);
    public virtual void Write(Byte[] buf, int off, int len);
}
public abstract class Org.BouncyCastle.Tls.CachedInformationType : object {
    public static short cert;
    public static short cert_req;
    public static string GetName(short cachedInformationType);
    public static string GetText(short cachedInformationType);
}
public abstract class Org.BouncyCastle.Tls.CertChainType : object {
    public static short individual_certs;
    public static short pkipath;
    public static string GetName(short certChainType);
    public static string GetText(short certChainType);
    public static bool IsValid(short certChainType);
}
public class Org.BouncyCastle.Tls.Certificate : object {
    private static TlsCertificate[] EmptyCerts;
    private static CertificateEntry[] EmptyCertEntries;
    public static Certificate EmptyChain;
    public static Certificate EmptyChainTls13;
    private Byte[] m_certificateRequestContext;
    private CertificateEntry[] m_certificateEntryList;
    public short CertificateType { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    public Certificate(TlsCertificate[] certificateList);
    public Certificate(Byte[] certificateRequestContext, CertificateEntry[] certificateEntryList);
    private static Certificate();
    private static CertificateEntry[] Convert(TlsCertificate[] certificateList);
    public Byte[] GetCertificateRequestContext();
    public TlsCertificate[] GetCertificateList();
    public TlsCertificate GetCertificateAt(int index);
    public CertificateEntry GetCertificateEntryAt(int index);
    public CertificateEntry[] GetCertificateEntryList();
    public short get_CertificateType();
    public int get_Length();
    public bool get_IsEmpty();
    public void Encode(TlsContext context, Stream messageOutput, Stream endPointHashOutput);
    public static Certificate Parse(ParseOptions options, TlsContext context, Stream messageInput, Stream endPointHashOutput);
    private static void CalculateEndPointHash(TlsContext context, TlsCertificate cert, Byte[] encoding, Stream output);
    private TlsCertificate[] CloneCertificateList();
    private CertificateEntry[] CloneCertificateEntryList();
}
public class Org.BouncyCastle.Tls.CertificateEntry : object {
    private TlsCertificate m_certificate;
    private IDictionary m_extensions;
    public TlsCertificate Certificate { get; }
    public IDictionary Extensions { get; }
    public CertificateEntry(TlsCertificate certificate, IDictionary extensions);
    public TlsCertificate get_Certificate();
    public IDictionary get_Extensions();
}
public class Org.BouncyCastle.Tls.CertificateRequest : object {
    private Byte[] m_certificateRequestContext;
    private Int16[] m_certificateTypes;
    private IList m_supportedSignatureAlgorithms;
    private IList m_supportedSignatureAlgorithmsCert;
    private IList m_certificateAuthorities;
    public Int16[] CertificateTypes { get; }
    public IList SupportedSignatureAlgorithms { get; }
    public IList SupportedSignatureAlgorithmsCert { get; }
    public IList CertificateAuthorities { get; }
    public CertificateRequest(Int16[] certificateTypes, IList supportedSignatureAlgorithms, IList certificateAuthorities);
    public CertificateRequest(Byte[] certificateRequestContext, IList supportedSignatureAlgorithms, IList supportedSignatureAlgorithmsCert, IList certificateAuthorities);
    private CertificateRequest(Byte[] certificateRequestContext, Int16[] certificateTypes, IList supportedSignatureAlgorithms, IList supportedSignatureAlgorithmsCert, IList certificateAuthorities);
    private static IList CheckSupportedSignatureAlgorithms(IList supportedSignatureAlgorithms, short alertDescription);
    public Byte[] GetCertificateRequestContext();
    public Int16[] get_CertificateTypes();
    public IList get_SupportedSignatureAlgorithms();
    public IList get_SupportedSignatureAlgorithmsCert();
    public IList get_CertificateAuthorities();
    public bool HasCertificateRequestContext(Byte[] certificateRequestContext);
    public void Encode(TlsContext context, Stream output);
    public static CertificateRequest Parse(TlsContext context, Stream input);
}
public class Org.BouncyCastle.Tls.CertificateStatus : object {
    private short m_statusType;
    private object m_response;
    public short StatusType { get; }
    public object Response { get; }
    public OcspResponse OcspResponse { get; }
    public IList OcspResponseList { get; }
    public CertificateStatus(short statusType, object response);
    public short get_StatusType();
    public object get_Response();
    public OcspResponse get_OcspResponse();
    public IList get_OcspResponseList();
    public void Encode(Stream output);
    public static CertificateStatus Parse(TlsContext context, Stream input);
    private static bool IsCorrectType(short statusType, object response);
    private static bool IsOcspResponseList(object response);
    private static void RequireStatusRequestVersion(int minVersion, int statusRequestVersion);
}
public class Org.BouncyCastle.Tls.CertificateStatusRequest : object {
    private short m_statusType;
    private object m_request;
    public short StatusType { get; }
    public object Request { get; }
    public OcspStatusRequest OcspStatusRequest { get; }
    public CertificateStatusRequest(short statusType, object request);
    public short get_StatusType();
    public object get_Request();
    public OcspStatusRequest get_OcspStatusRequest();
    public void Encode(Stream output);
    public static CertificateStatusRequest Parse(Stream input);
    private static bool IsCorrectType(short statusType, object request);
}
public class Org.BouncyCastle.Tls.CertificateStatusRequestItemV2 : object {
    private short m_statusType;
    private object m_request;
    public short StatusType { get; }
    public object Request { get; }
    public OcspStatusRequest OcspStatusRequest { get; }
    public CertificateStatusRequestItemV2(short statusType, object request);
    public short get_StatusType();
    public object get_Request();
    public OcspStatusRequest get_OcspStatusRequest();
    public void Encode(Stream output);
    public static CertificateStatusRequestItemV2 Parse(Stream input);
    private static bool IsCorrectType(short statusType, object request);
}
public abstract class Org.BouncyCastle.Tls.CertificateStatusType : object {
    public static short ocsp;
    public static short ocsp_multi;
}
public abstract class Org.BouncyCastle.Tls.CertificateType : object {
    public static short X509;
    public static short OpenPGP;
    public static short RawPublicKey;
}
public class Org.BouncyCastle.Tls.CertificateUrl : object {
    private short m_type;
    private IList m_urlAndHashList;
    public short Type { get; }
    public IList UrlAndHashList { get; }
    public CertificateUrl(short type, IList urlAndHashList);
    public short get_Type();
    public IList get_UrlAndHashList();
    public void Encode(Stream output);
    public static CertificateUrl Parse(TlsContext context, Stream input);
}
public abstract class Org.BouncyCastle.Tls.ChangeCipherSpec : object {
    public static short change_cipher_spec;
}
public abstract class Org.BouncyCastle.Tls.ChannelBinding : object {
    public static int tls_server_end_point;
    public static int tls_unique;
    public static int tls_unique_for_telnet;
}
public abstract class Org.BouncyCastle.Tls.CipherSuite : object {
    public static int TLS_NULL_WITH_NULL_NULL;
    public static int TLS_RSA_WITH_NULL_MD5;
    public static int TLS_RSA_WITH_NULL_SHA;
    public static int TLS_RSA_EXPORT_WITH_RC4_40_MD5;
    public static int TLS_RSA_WITH_RC4_128_MD5;
    public static int TLS_RSA_WITH_RC4_128_SHA;
    public static int TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5;
    public static int TLS_RSA_WITH_IDEA_CBC_SHA;
    public static int TLS_RSA_EXPORT_WITH_DES40_CBC_SHA;
    public static int TLS_RSA_WITH_DES_CBC_SHA;
    public static int TLS_RSA_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA;
    public static int TLS_DH_DSS_WITH_DES_CBC_SHA;
    public static int TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA;
    public static int TLS_DH_RSA_WITH_DES_CBC_SHA;
    public static int TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA;
    public static int TLS_DHE_DSS_WITH_DES_CBC_SHA;
    public static int TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA;
    public static int TLS_DHE_RSA_WITH_DES_CBC_SHA;
    public static int TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_DH_anon_EXPORT_WITH_RC4_40_MD5;
    public static int TLS_DH_anon_WITH_RC4_128_MD5;
    public static int TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA;
    public static int TLS_DH_anon_WITH_DES_CBC_SHA;
    public static int TLS_DH_anon_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_RSA_WITH_AES_128_CBC_SHA;
    public static int TLS_DH_DSS_WITH_AES_128_CBC_SHA;
    public static int TLS_DH_RSA_WITH_AES_128_CBC_SHA;
    public static int TLS_DHE_DSS_WITH_AES_128_CBC_SHA;
    public static int TLS_DHE_RSA_WITH_AES_128_CBC_SHA;
    public static int TLS_DH_anon_WITH_AES_128_CBC_SHA;
    public static int TLS_RSA_WITH_AES_256_CBC_SHA;
    public static int TLS_DH_DSS_WITH_AES_256_CBC_SHA;
    public static int TLS_DH_RSA_WITH_AES_256_CBC_SHA;
    public static int TLS_DHE_DSS_WITH_AES_256_CBC_SHA;
    public static int TLS_DHE_RSA_WITH_AES_256_CBC_SHA;
    public static int TLS_DH_anon_WITH_AES_256_CBC_SHA;
    public static int TLS_RSA_WITH_CAMELLIA_128_CBC_SHA;
    public static int TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA;
    public static int TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA;
    public static int TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA;
    public static int TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA;
    public static int TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA;
    public static int TLS_RSA_WITH_CAMELLIA_256_CBC_SHA;
    public static int TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA;
    public static int TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA;
    public static int TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA;
    public static int TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA;
    public static int TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA;
    public static int TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256;
    public static int TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256;
    public static int TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256;
    public static int TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256;
    public static int TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256;
    public static int TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256;
    public static int TLS_RSA_WITH_SEED_CBC_SHA;
    public static int TLS_DH_DSS_WITH_SEED_CBC_SHA;
    public static int TLS_DH_RSA_WITH_SEED_CBC_SHA;
    public static int TLS_DHE_DSS_WITH_SEED_CBC_SHA;
    public static int TLS_DHE_RSA_WITH_SEED_CBC_SHA;
    public static int TLS_DH_anon_WITH_SEED_CBC_SHA;
    public static int TLS_PSK_WITH_RC4_128_SHA;
    public static int TLS_PSK_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_PSK_WITH_AES_128_CBC_SHA;
    public static int TLS_PSK_WITH_AES_256_CBC_SHA;
    public static int TLS_DHE_PSK_WITH_RC4_128_SHA;
    public static int TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_DHE_PSK_WITH_AES_128_CBC_SHA;
    public static int TLS_DHE_PSK_WITH_AES_256_CBC_SHA;
    public static int TLS_RSA_PSK_WITH_RC4_128_SHA;
    public static int TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_RSA_PSK_WITH_AES_128_CBC_SHA;
    public static int TLS_RSA_PSK_WITH_AES_256_CBC_SHA;
    public static int TLS_ECDH_ECDSA_WITH_NULL_SHA;
    public static int TLS_ECDH_ECDSA_WITH_RC4_128_SHA;
    public static int TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA;
    public static int TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA;
    public static int TLS_ECDHE_ECDSA_WITH_NULL_SHA;
    public static int TLS_ECDHE_ECDSA_WITH_RC4_128_SHA;
    public static int TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA;
    public static int TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA;
    public static int TLS_ECDH_RSA_WITH_NULL_SHA;
    public static int TLS_ECDH_RSA_WITH_RC4_128_SHA;
    public static int TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_ECDH_RSA_WITH_AES_128_CBC_SHA;
    public static int TLS_ECDH_RSA_WITH_AES_256_CBC_SHA;
    public static int TLS_ECDHE_RSA_WITH_NULL_SHA;
    public static int TLS_ECDHE_RSA_WITH_RC4_128_SHA;
    public static int TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA;
    public static int TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA;
    public static int TLS_ECDH_anon_WITH_NULL_SHA;
    public static int TLS_ECDH_anon_WITH_RC4_128_SHA;
    public static int TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_ECDH_anon_WITH_AES_128_CBC_SHA;
    public static int TLS_ECDH_anon_WITH_AES_256_CBC_SHA;
    public static int TLS_PSK_WITH_NULL_SHA;
    public static int TLS_DHE_PSK_WITH_NULL_SHA;
    public static int TLS_RSA_PSK_WITH_NULL_SHA;
    public static int TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_SRP_SHA_WITH_AES_128_CBC_SHA;
    public static int TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA;
    public static int TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA;
    public static int TLS_SRP_SHA_WITH_AES_256_CBC_SHA;
    public static int TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA;
    public static int TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA;
    public static int TLS_RSA_WITH_NULL_SHA256;
    public static int TLS_RSA_WITH_AES_128_CBC_SHA256;
    public static int TLS_RSA_WITH_AES_256_CBC_SHA256;
    public static int TLS_DH_DSS_WITH_AES_128_CBC_SHA256;
    public static int TLS_DH_RSA_WITH_AES_128_CBC_SHA256;
    public static int TLS_DHE_DSS_WITH_AES_128_CBC_SHA256;
    public static int TLS_DHE_RSA_WITH_AES_128_CBC_SHA256;
    public static int TLS_DH_DSS_WITH_AES_256_CBC_SHA256;
    public static int TLS_DH_RSA_WITH_AES_256_CBC_SHA256;
    public static int TLS_DHE_DSS_WITH_AES_256_CBC_SHA256;
    public static int TLS_DHE_RSA_WITH_AES_256_CBC_SHA256;
    public static int TLS_DH_anon_WITH_AES_128_CBC_SHA256;
    public static int TLS_DH_anon_WITH_AES_256_CBC_SHA256;
    public static int TLS_RSA_WITH_AES_128_GCM_SHA256;
    public static int TLS_RSA_WITH_AES_256_GCM_SHA384;
    public static int TLS_DHE_RSA_WITH_AES_128_GCM_SHA256;
    public static int TLS_DHE_RSA_WITH_AES_256_GCM_SHA384;
    public static int TLS_DH_RSA_WITH_AES_128_GCM_SHA256;
    public static int TLS_DH_RSA_WITH_AES_256_GCM_SHA384;
    public static int TLS_DHE_DSS_WITH_AES_128_GCM_SHA256;
    public static int TLS_DHE_DSS_WITH_AES_256_GCM_SHA384;
    public static int TLS_DH_DSS_WITH_AES_128_GCM_SHA256;
    public static int TLS_DH_DSS_WITH_AES_256_GCM_SHA384;
    public static int TLS_DH_anon_WITH_AES_128_GCM_SHA256;
    public static int TLS_DH_anon_WITH_AES_256_GCM_SHA384;
    public static int TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256;
    public static int TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384;
    public static int TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256;
    public static int TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384;
    public static int TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256;
    public static int TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384;
    public static int TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256;
    public static int TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384;
    public static int TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256;
    public static int TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384;
    public static int TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256;
    public static int TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384;
    public static int TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256;
    public static int TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384;
    public static int TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256;
    public static int TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384;
    public static int TLS_PSK_WITH_AES_128_GCM_SHA256;
    public static int TLS_PSK_WITH_AES_256_GCM_SHA384;
    public static int TLS_DHE_PSK_WITH_AES_128_GCM_SHA256;
    public static int TLS_DHE_PSK_WITH_AES_256_GCM_SHA384;
    public static int TLS_RSA_PSK_WITH_AES_128_GCM_SHA256;
    public static int TLS_RSA_PSK_WITH_AES_256_GCM_SHA384;
    public static int TLS_PSK_WITH_AES_128_CBC_SHA256;
    public static int TLS_PSK_WITH_AES_256_CBC_SHA384;
    public static int TLS_PSK_WITH_NULL_SHA256;
    public static int TLS_PSK_WITH_NULL_SHA384;
    public static int TLS_DHE_PSK_WITH_AES_128_CBC_SHA256;
    public static int TLS_DHE_PSK_WITH_AES_256_CBC_SHA384;
    public static int TLS_DHE_PSK_WITH_NULL_SHA256;
    public static int TLS_DHE_PSK_WITH_NULL_SHA384;
    public static int TLS_RSA_PSK_WITH_AES_128_CBC_SHA256;
    public static int TLS_RSA_PSK_WITH_AES_256_CBC_SHA384;
    public static int TLS_RSA_PSK_WITH_NULL_SHA256;
    public static int TLS_RSA_PSK_WITH_NULL_SHA384;
    public static int TLS_ECDHE_PSK_WITH_RC4_128_SHA;
    public static int TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA;
    public static int TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA;
    public static int TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA;
    public static int TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256;
    public static int TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384;
    public static int TLS_ECDHE_PSK_WITH_NULL_SHA;
    public static int TLS_ECDHE_PSK_WITH_NULL_SHA256;
    public static int TLS_ECDHE_PSK_WITH_NULL_SHA384;
    public static int TLS_EMPTY_RENEGOTIATION_INFO_SCSV;
    public static int TLS_RSA_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_RSA_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_DH_anon_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_DH_anon_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_RSA_WITH_ARIA_128_GCM_SHA256;
    public static int TLS_RSA_WITH_ARIA_256_GCM_SHA384;
    public static int TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256;
    public static int TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384;
    public static int TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256;
    public static int TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384;
    public static int TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256;
    public static int TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384;
    public static int TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256;
    public static int TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384;
    public static int TLS_DH_anon_WITH_ARIA_128_GCM_SHA256;
    public static int TLS_DH_anon_WITH_ARIA_256_GCM_SHA384;
    public static int TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256;
    public static int TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384;
    public static int TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256;
    public static int TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384;
    public static int TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256;
    public static int TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384;
    public static int TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256;
    public static int TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384;
    public static int TLS_PSK_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_PSK_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_PSK_WITH_ARIA_128_GCM_SHA256;
    public static int TLS_PSK_WITH_ARIA_256_GCM_SHA384;
    public static int TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256;
    public static int TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384;
    public static int TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256;
    public static int TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384;
    public static int TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256;
    public static int TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384;
    public static int TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384;
    public static int TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384;
    public static int TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384;
    public static int TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384;
    public static int TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256;
    public static int TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384;
    public static int TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384;
    public static int TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384;
    public static int TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384;
    public static int TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256;
    public static int TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384;
    public static int TLS_RSA_WITH_AES_128_CCM;
    public static int TLS_RSA_WITH_AES_256_CCM;
    public static int TLS_DHE_RSA_WITH_AES_128_CCM;
    public static int TLS_DHE_RSA_WITH_AES_256_CCM;
    public static int TLS_RSA_WITH_AES_128_CCM_8;
    public static int TLS_RSA_WITH_AES_256_CCM_8;
    public static int TLS_DHE_RSA_WITH_AES_128_CCM_8;
    public static int TLS_DHE_RSA_WITH_AES_256_CCM_8;
    public static int TLS_PSK_WITH_AES_128_CCM;
    public static int TLS_PSK_WITH_AES_256_CCM;
    public static int TLS_DHE_PSK_WITH_AES_128_CCM;
    public static int TLS_DHE_PSK_WITH_AES_256_CCM;
    public static int TLS_PSK_WITH_AES_128_CCM_8;
    public static int TLS_PSK_WITH_AES_256_CCM_8;
    public static int TLS_PSK_DHE_WITH_AES_128_CCM_8;
    public static int TLS_PSK_DHE_WITH_AES_256_CCM_8;
    public static int TLS_ECDHE_ECDSA_WITH_AES_128_CCM;
    public static int TLS_ECDHE_ECDSA_WITH_AES_256_CCM;
    public static int TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8;
    public static int TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8;
    public static int TLS_FALLBACK_SCSV;
    public static int TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256;
    public static int TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256;
    public static int TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256;
    public static int TLS_PSK_WITH_CHACHA20_POLY1305_SHA256;
    public static int TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256;
    public static int TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256;
    public static int TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256;
    public static int TLS_ECDHE_PSK_WITH_AES_128_GCM_SHA256;
    public static int TLS_ECDHE_PSK_WITH_AES_256_GCM_SHA384;
    public static int TLS_ECDHE_PSK_WITH_AES_128_CCM_8_SHA256;
    public static int TLS_ECDHE_PSK_WITH_AES_128_CCM_SHA256;
    public static int TLS_AES_128_GCM_SHA256;
    public static int TLS_AES_256_GCM_SHA384;
    public static int TLS_CHACHA20_POLY1305_SHA256;
    public static int TLS_AES_128_CCM_SHA256;
    public static int TLS_AES_128_CCM_8_SHA256;
    public static int TLS_SM4_GCM_SM3;
    public static int TLS_SM4_CCM_SM3;
    public static int TLS_GOSTR341112_256_WITH_KUZNYECHIK_CTR_OMAC;
    public static int TLS_GOSTR341112_256_WITH_MAGMA_CTR_OMAC;
    public static int TLS_GOSTR341112_256_WITH_28147_CNT_IMIT;
    public static bool IsScsv(int cipherSuite);
}
public abstract class Org.BouncyCastle.Tls.CipherType : object {
    public static int stream;
    public static int block;
    public static int aead;
}
public abstract class Org.BouncyCastle.Tls.ClientAuthenticationType : object {
    public static short anonymous;
    public static short certificate_based;
    public static short psk;
}
public abstract class Org.BouncyCastle.Tls.ClientCertificateType : object {
    public static short rsa_sign;
    public static short dss_sign;
    public static short rsa_fixed_dh;
    public static short dss_fixed_dh;
    public static short rsa_ephemeral_dh_RESERVED;
    public static short dss_ephemeral_dh_RESERVED;
    public static short fortezza_dms_RESERVED;
    public static short ecdsa_sign;
    public static short rsa_fixed_ecdh;
    public static short ecdsa_fixed_ecdh;
    public static short gost_sign256;
    public static short gost_sign512;
    public static string GetName(short clientCertificateType);
    public static string GetText(short clientCertificateType);
}
public class Org.BouncyCastle.Tls.ClientHello : object {
    private ProtocolVersion m_version;
    private Byte[] m_random;
    private Byte[] m_sessionID;
    private Byte[] m_cookie;
    private Int32[] m_cipherSuites;
    private IDictionary m_extensions;
    private int m_bindersSize;
    public int BindersSize { get; }
    public Int32[] CipherSuites { get; }
    public Byte[] Cookie { get; }
    public IDictionary Extensions { get; }
    public Byte[] Random { get; }
    public Byte[] SessionID { get; }
    public ProtocolVersion Version { get; }
    public ClientHello(ProtocolVersion version, Byte[] random, Byte[] sessionID, Byte[] cookie, Int32[] cipherSuites, IDictionary extensions, int bindersSize);
    public int get_BindersSize();
    public Int32[] get_CipherSuites();
    public Byte[] get_Cookie();
    public IDictionary get_Extensions();
    public Byte[] get_Random();
    public Byte[] get_SessionID();
    public ProtocolVersion get_Version();
    public void Encode(TlsContext context, Stream output);
    public static ClientHello Parse(MemoryStream messageInput, Stream dtlsOutput);
    private static ClientHello ImplParse(MemoryStream messageInput, Stream dtlsOutput);
}
public class Org.BouncyCastle.Tls.CombinedHash : object {
    protected TlsContext m_context;
    protected TlsCrypto m_crypto;
    protected TlsHash m_md5;
    protected TlsHash m_sha1;
    internal CombinedHash(TlsContext context, TlsHash md5, TlsHash sha1);
    public CombinedHash(TlsCrypto crypto);
    public CombinedHash(CombinedHash t);
    public virtual void Update(Byte[] input, int inOff, int len);
    public virtual Byte[] CalculateHash();
    public virtual TlsHash CloneHash();
    public virtual void Reset();
}
public abstract class Org.BouncyCastle.Tls.CompressionMethod : object {
    public static short cls_null;
    public static short DEFLATE;
}
public abstract class Org.BouncyCastle.Tls.ConnectionEnd : object {
    public static int server;
    public static int client;
}
public abstract class Org.BouncyCastle.Tls.ContentType : object {
    public static short change_cipher_spec;
    public static short alert;
    public static short handshake;
    public static short application_data;
    public static short heartbeat;
    public static string GetName(short contentType);
    public static string GetText(short contentType);
}
public abstract class Org.BouncyCastle.Tls.Crypto.CryptoHashAlgorithm : object {
    public static int md5;
    public static int sha1;
    public static int sha224;
    public static int sha256;
    public static int sha384;
    public static int sha512;
    public static int sm3;
}
public abstract class Org.BouncyCastle.Tls.Crypto.CryptoSignatureAlgorithm : object {
    public static int rsa;
    public static int dsa;
    public static int ecdsa;
    public static int rsa_pss_rsae_sha256;
    public static int rsa_pss_rsae_sha384;
    public static int rsa_pss_rsae_sha512;
    public static int ed25519;
    public static int ed448;
    public static int rsa_pss_pss_sha256;
    public static int rsa_pss_pss_sha384;
    public static int rsa_pss_pss_sha512;
    public static int gostr34102012_256;
    public static int gostr34102012_512;
    public static int sm2;
}
public class Org.BouncyCastle.Tls.Crypto.DHGroup : object {
    private BigInteger g;
    private BigInteger p;
    private BigInteger q;
    private int l;
    public BigInteger G { get; }
    public int L { get; }
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public DHGroup(BigInteger p, BigInteger q, BigInteger g, int l);
    public virtual BigInteger get_G();
    public virtual int get_L();
    public virtual BigInteger get_P();
    public virtual BigInteger get_Q();
}
public class Org.BouncyCastle.Tls.Crypto.DHStandardGroups : object {
    private static BigInteger Two;
    private static string rfc2409_768_p;
    public static DHGroup rfc2409_768;
    private static string rfc2409_1024_p;
    public static DHGroup rfc2409_1024;
    private static string rfc3526_1536_p;
    private static int rfc3526_1536_l;
    public static DHGroup rfc3526_1536;
    private static string rfc3526_2048_p;
    private static int rfc3526_2048_l;
    public static DHGroup rfc3526_2048;
    private static string rfc3526_3072_p;
    private static int rfc3526_3072_l;
    public static DHGroup rfc3526_3072;
    private static string rfc3526_4096_p;
    private static int rfc3526_4096_l;
    public static DHGroup rfc3526_4096;
    private static string rfc3526_6144_p;
    private static int rfc3526_6144_l;
    public static DHGroup rfc3526_6144;
    private static string rfc3526_8192_p;
    private static int rfc3526_8192_l;
    public static DHGroup rfc3526_8192;
    public static DHGroup rfc4306_768;
    public static DHGroup rfc4306_1024;
    public static DHGroup rfc5996_768;
    public static DHGroup rfc5996_1024;
    private static string rfc7919_ffdhe2048_p;
    private static int rfc7919_ffdhe2048_l;
    public static DHGroup rfc7919_ffdhe2048;
    private static string rfc7919_ffdhe3072_p;
    private static int rfc7919_ffdhe3072_l;
    public static DHGroup rfc7919_ffdhe3072;
    private static string rfc7919_ffdhe4096_p;
    private static int rfc7919_ffdhe4096_l;
    public static DHGroup rfc7919_ffdhe4096;
    private static string rfc7919_ffdhe6144_p;
    private static int rfc7919_ffdhe6144_l;
    public static DHGroup rfc7919_ffdhe6144;
    private static string rfc7919_ffdhe8192_p;
    private static int rfc7919_ffdhe8192_l;
    public static DHGroup rfc7919_ffdhe8192;
    private static DHStandardGroups();
    private static BigInteger FromHex(string hex);
    private static DHGroup SafePrimeGen2(string hexP);
    private static DHGroup SafePrimeGen2(string hexP, int l);
}
public abstract class Org.BouncyCastle.Tls.Crypto.Impl.AbstractTlsCrypto : object {
    public SecureRandom SecureRandom { get; }
    public abstract virtual bool HasAllRawSignatureAlgorithms();
    public abstract virtual bool HasDHAgreement();
    public abstract virtual bool HasECDHAgreement();
    public abstract virtual bool HasEncryptionAlgorithm(int encryptionAlgorithm);
    public abstract virtual bool HasCryptoHashAlgorithm(int cryptoHashAlgorithm);
    public abstract virtual bool HasCryptoSignatureAlgorithm(int cryptoSignatureAlgorithm);
    public abstract virtual bool HasMacAlgorithm(int macAlgorithm);
    public abstract virtual bool HasNamedGroup(int namedGroup);
    public abstract virtual bool HasRsaEncryption();
    public abstract virtual bool HasSignatureAlgorithm(short signatureAlgorithm);
    public abstract virtual bool HasSignatureAndHashAlgorithm(SignatureAndHashAlgorithm sigAndHashAlgorithm);
    public abstract virtual bool HasSignatureScheme(int signatureScheme);
    public abstract virtual bool HasSrpAuthentication();
    public abstract virtual TlsSecret CreateSecret(Byte[] data);
    public abstract virtual TlsSecret GenerateRsaPreMasterSecret(ProtocolVersion clientVersion);
    public abstract virtual SecureRandom get_SecureRandom();
    public abstract virtual TlsCertificate CreateCertificate(Byte[] encoding);
    public abstract virtual TlsCipher CreateCipher(TlsCryptoParameters cryptoParams, int encryptionAlgorithm, int macAlgorithm);
    public abstract virtual TlsDHDomain CreateDHDomain(TlsDHConfig dhConfig);
    public abstract virtual TlsECDomain CreateECDomain(TlsECConfig ecConfig);
    public virtual TlsSecret AdoptSecret(TlsSecret secret);
    public abstract virtual TlsHash CreateHash(int cryptoHashAlgorithm);
    public abstract virtual TlsHmac CreateHmac(int macAlgorithm);
    public abstract virtual TlsHmac CreateHmacForHash(int cryptoHashAlgorithm);
    public abstract virtual TlsNonceGenerator CreateNonceGenerator(Byte[] additionalSeedMaterial);
    public abstract virtual TlsSrp6Client CreateSrp6Client(TlsSrpConfig srpConfig);
    public abstract virtual TlsSrp6Server CreateSrp6Server(TlsSrpConfig srpConfig, BigInteger srpVerifier);
    public abstract virtual TlsSrp6VerifierGenerator CreateSrp6VerifierGenerator(TlsSrpConfig srpConfig);
    public abstract virtual TlsSecret HkdfInit(int cryptoHashAlgorithm);
}
public abstract class Org.BouncyCastle.Tls.Crypto.Impl.AbstractTlsSecret : object {
    protected Byte[] m_data;
    protected AbstractTlsCrypto Crypto { get; }
    protected AbstractTlsSecret(Byte[] data);
    protected static Byte[] CopyData(AbstractTlsSecret other);
    protected virtual void CheckAlive();
    protected abstract virtual AbstractTlsCrypto get_Crypto();
    public virtual Byte[] CalculateHmac(int cryptoHashAlgorithm, Byte[] buf, int off, int len);
    public abstract virtual TlsSecret DeriveUsingPrf(int prfAlgorithm, string label, Byte[] seed, int length);
    public virtual void Destroy();
    public virtual Byte[] Encrypt(TlsEncryptor encryptor);
    public virtual Byte[] Extract();
    public abstract virtual TlsSecret HkdfExpand(int cryptoHashAlgorithm, Byte[] info, int length);
    public abstract virtual TlsSecret HkdfExtract(int cryptoHashAlgorithm, TlsSecret ikm);
    public virtual bool IsAlive();
    internal virtual Byte[] CopyData();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcChaCha20Poly1305 : object {
    private static Byte[] Zeroes;
    private ChaCha7539Engine m_cipher;
    private Poly1305 m_mac;
    private bool m_isEncrypting;
    private int m_additionalDataLength;
    public BcChaCha20Poly1305(bool isEncrypting);
    private static BcChaCha20Poly1305();
    public sealed virtual int DoFinal(Byte[] input, int inputOffset, int inputLength, Byte[] output, int outputOffset);
    public sealed virtual int GetOutputSize(int inputLength);
    public sealed virtual void Init(Byte[] nonce, int macSize, Byte[] additionalData);
    public sealed virtual void SetKey(Byte[] key, int keyOff, int keyLen);
    private void InitMac();
    private void UpdateMac(Byte[] buf, int off, int len);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcDefaultTlsCredentialedAgreement : object {
    protected TlsCredentialedAgreement m_agreementCredentials;
    public Certificate Certificate { get; }
    public BcDefaultTlsCredentialedAgreement(BcTlsCrypto crypto, Certificate certificate, AsymmetricKeyParameter privateKey);
    public virtual Certificate get_Certificate();
    public virtual TlsSecret GenerateAgreement(TlsCertificate peerCertificate);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcDefaultTlsCredentialedDecryptor : object {
    protected BcTlsCrypto m_crypto;
    protected Certificate m_certificate;
    protected AsymmetricKeyParameter m_privateKey;
    public Certificate Certificate { get; }
    public BcDefaultTlsCredentialedDecryptor(BcTlsCrypto crypto, Certificate certificate, AsymmetricKeyParameter privateKey);
    public virtual Certificate get_Certificate();
    public virtual TlsSecret Decrypt(TlsCryptoParameters cryptoParams, Byte[] ciphertext);
    protected virtual TlsSecret SafeDecryptPreMasterSecret(TlsCryptoParameters cryptoParams, RsaKeyParameters rsaServerPrivateKey, Byte[] encryptedPreMasterSecret);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcDefaultTlsCredentialedSigner : DefaultTlsCredentialedSigner {
    public BcDefaultTlsCredentialedSigner(TlsCryptoParameters cryptoParams, BcTlsCrypto crypto, AsymmetricKeyParameter privateKey, Certificate certificate, SignatureAndHashAlgorithm signatureAndHashAlgorithm);
    private static BcTlsCertificate GetEndEntity(BcTlsCrypto crypto, Certificate certificate);
    private static TlsSigner MakeSigner(BcTlsCrypto crypto, AsymmetricKeyParameter privateKey, Certificate certificate, SignatureAndHashAlgorithm signatureAndHashAlgorithm);
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcSsl3Hmac : object {
    private static byte IPAD_BYTE;
    private static byte OPAD_BYTE;
    private static Byte[] IPAD;
    private static Byte[] OPAD;
    private IDigest m_digest;
    private int m_padLength;
    private Byte[] m_secret;
    public int InternalBlockSize { get; }
    public int MacLength { get; }
    internal BcSsl3Hmac(IDigest digest);
    private static BcSsl3Hmac();
    public virtual void SetKey(Byte[] key, int keyOff, int keyLen);
    public virtual void Update(Byte[] input, int inOff, int len);
    public virtual Byte[] CalculateMac();
    public virtual void CalculateMac(Byte[] output, int outOff);
    public virtual int get_InternalBlockSize();
    public virtual int get_MacLength();
    public virtual void Reset();
    private void DoFinal(Byte[] output, int outOff);
    private static Byte[] GenPad(byte b, int count);
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsAeadCipherImpl : object {
    private bool m_isEncrypting;
    private IAeadBlockCipher m_cipher;
    private KeyParameter key;
    internal BcTlsAeadCipherImpl(IAeadBlockCipher cipher, bool isEncrypting);
    public sealed virtual void SetKey(Byte[] key, int keyOff, int keyLen);
    public sealed virtual void Init(Byte[] nonce, int macSize, Byte[] additionalData);
    public sealed virtual int GetOutputSize(int inputLength);
    public sealed virtual int DoFinal(Byte[] input, int inputOffset, int inputLength, Byte[] output, int outputOffset);
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsBlockCipherImpl : object {
    private bool m_isEncrypting;
    private IBlockCipher m_cipher;
    private KeyParameter key;
    internal BcTlsBlockCipherImpl(IBlockCipher cipher, bool isEncrypting);
    public sealed virtual void SetKey(Byte[] key, int keyOff, int keyLen);
    public sealed virtual void Init(Byte[] iv, int ivOff, int ivLen);
    public sealed virtual int DoFinal(Byte[] input, int inputOffset, int inputLength, Byte[] output, int outputOffset);
    public sealed virtual int GetBlockSize();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate : object {
    protected BcTlsCrypto m_crypto;
    protected X509CertificateStructure m_certificate;
    protected DHPublicKeyParameters m_pubKeyDH;
    protected ECPublicKeyParameters m_pubKeyEC;
    protected Ed25519PublicKeyParameters m_pubKeyEd25519;
    protected Ed448PublicKeyParameters m_pubKeyEd448;
    protected RsaKeyParameters m_pubKeyRsa;
    public BigInteger SerialNumber { get; }
    public string SigAlgOid { get; }
    public BcTlsCertificate(BcTlsCrypto crypto, Byte[] encoding);
    public BcTlsCertificate(BcTlsCrypto crypto, X509CertificateStructure certificate);
    public static BcTlsCertificate Convert(BcTlsCrypto crypto, TlsCertificate certificate);
    public static X509CertificateStructure ParseCertificate(Byte[] encoding);
    public virtual TlsEncryptor CreateEncryptor(int tlsCertificateRole);
    public virtual TlsVerifier CreateVerifier(short signatureAlgorithm);
    public virtual TlsVerifier CreateVerifier(int signatureScheme);
    public virtual Byte[] GetEncoded();
    public virtual Byte[] GetExtension(DerObjectIdentifier extensionOid);
    public virtual BigInteger get_SerialNumber();
    public virtual string get_SigAlgOid();
    public virtual Asn1Encodable GetSigAlgParams();
    public virtual short GetLegacySignatureAlgorithm();
    public virtual DHPublicKeyParameters GetPubKeyDH();
    public virtual DsaPublicKeyParameters GetPubKeyDss();
    public virtual ECPublicKeyParameters GetPubKeyEC();
    public virtual Ed25519PublicKeyParameters GetPubKeyEd25519();
    public virtual Ed448PublicKeyParameters GetPubKeyEd448();
    public virtual RsaKeyParameters GetPubKeyRsa();
    public virtual bool SupportsSignatureAlgorithm(short signatureAlgorithm);
    public virtual bool SupportsSignatureAlgorithmCA(short signatureAlgorithm);
    public virtual TlsCertificate CheckUsageInRole(int tlsCertificateRole);
    protected virtual AsymmetricKeyParameter GetPublicKey();
    protected virtual bool SupportsKeyUsage(int keyUsageBits);
    protected virtual bool SupportsRsa_Pkcs1();
    protected virtual bool SupportsRsa_Pss_Pss(short signatureAlgorithm);
    protected virtual bool SupportsRsa_Pss_Rsae();
    protected virtual bool SupportsSignatureAlgorithm(short signatureAlgorithm, int keyUsage);
    public virtual void ValidateKeyUsage(int keyUsageBits);
    protected virtual void ValidateRsa_Pkcs1();
    protected virtual void ValidateRsa_Pss_Pss(short signatureAlgorithm);
    protected virtual void ValidateRsa_Pss_Rsae();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCrypto : AbstractTlsCrypto {
    private SecureRandom m_entropySource;
    public SecureRandom SecureRandom { get; }
    public BcTlsCrypto(SecureRandom entropySource);
    internal virtual BcTlsSecret AdoptLocalSecret(Byte[] data);
    public virtual SecureRandom get_SecureRandom();
    public virtual TlsCertificate CreateCertificate(Byte[] encoding);
    public virtual TlsCipher CreateCipher(TlsCryptoParameters cryptoParams, int encryptionAlgorithm, int macAlgorithm);
    public virtual TlsDHDomain CreateDHDomain(TlsDHConfig dhConfig);
    public virtual TlsECDomain CreateECDomain(TlsECConfig ecConfig);
    public virtual TlsNonceGenerator CreateNonceGenerator(Byte[] additionalSeedMaterial);
    public virtual bool HasAllRawSignatureAlgorithms();
    public virtual bool HasDHAgreement();
    public virtual bool HasECDHAgreement();
    public virtual bool HasEncryptionAlgorithm(int encryptionAlgorithm);
    public virtual bool HasCryptoHashAlgorithm(int cryptoHashAlgorithm);
    public virtual bool HasCryptoSignatureAlgorithm(int cryptoSignatureAlgorithm);
    public virtual bool HasMacAlgorithm(int macAlgorithm);
    public virtual bool HasNamedGroup(int namedGroup);
    public virtual bool HasRsaEncryption();
    public virtual bool HasSignatureAlgorithm(short signatureAlgorithm);
    public virtual bool HasSignatureAndHashAlgorithm(SignatureAndHashAlgorithm sigAndHashAlgorithm);
    public virtual bool HasSignatureScheme(int signatureScheme);
    public virtual bool HasSrpAuthentication();
    public virtual TlsSecret CreateSecret(Byte[] data);
    public virtual TlsSecret GenerateRsaPreMasterSecret(ProtocolVersion version);
    public virtual IDigest CloneDigest(int cryptoHashAlgorithm, IDigest digest);
    public virtual IDigest CreateDigest(int cryptoHashAlgorithm);
    public virtual TlsHash CreateHash(int cryptoHashAlgorithm);
    protected virtual IBlockCipher CreateBlockCipher(int encryptionAlgorithm);
    protected virtual IBlockCipher CreateCbcBlockCipher(IBlockCipher blockCipher);
    protected virtual IBlockCipher CreateCbcBlockCipher(int encryptionAlgorithm);
    protected virtual TlsCipher CreateChaCha20Poly1305(TlsCryptoParameters cryptoParams);
    protected virtual TlsAeadCipher CreateCipher_Aes_Ccm(TlsCryptoParameters cryptoParams, int cipherKeySize, int macSize);
    protected virtual TlsAeadCipher CreateCipher_Aes_Gcm(TlsCryptoParameters cryptoParams, int cipherKeySize, int macSize);
    protected virtual TlsAeadCipher CreateCipher_Aria_Gcm(TlsCryptoParameters cryptoParams, int cipherKeySize, int macSize);
    protected virtual TlsAeadCipher CreateCipher_Camellia_Gcm(TlsCryptoParameters cryptoParams, int cipherKeySize, int macSize);
    protected virtual TlsCipher CreateCipher_Cbc(TlsCryptoParameters cryptoParams, int encryptionAlgorithm, int cipherKeySize, int macAlgorithm);
    protected virtual TlsAeadCipher CreateCipher_SM4_Ccm(TlsCryptoParameters cryptoParams);
    protected virtual TlsAeadCipher CreateCipher_SM4_Gcm(TlsCryptoParameters cryptoParams);
    protected virtual TlsNullCipher CreateNullCipher(TlsCryptoParameters cryptoParams, int macAlgorithm);
    protected virtual IBlockCipher CreateAesEngine();
    protected virtual IBlockCipher CreateAriaEngine();
    protected virtual IBlockCipher CreateCamelliaEngine();
    protected virtual IBlockCipher CreateDesEdeEngine();
    protected virtual IBlockCipher CreateSeedEngine();
    protected virtual IBlockCipher CreateSM4Engine();
    protected virtual IAeadBlockCipher CreateCcmMode(IBlockCipher engine);
    protected virtual IAeadBlockCipher CreateGcmMode(IBlockCipher engine);
    protected virtual IAeadBlockCipher CreateAeadBlockCipher_Aes_Ccm();
    protected virtual IAeadBlockCipher CreateAeadBlockCipher_Aes_Gcm();
    protected virtual IAeadBlockCipher CreateAeadBlockCipher_Aria_Gcm();
    protected virtual IAeadBlockCipher CreateAeadBlockCipher_Camellia_Gcm();
    protected virtual IAeadBlockCipher CreateAeadBlockCipher_SM4_Ccm();
    protected virtual IAeadBlockCipher CreateAeadBlockCipher_SM4_Gcm();
    public virtual TlsHmac CreateHmac(int macAlgorithm);
    public virtual TlsHmac CreateHmacForHash(int cryptoHashAlgorithm);
    protected virtual TlsHmac CreateHmac_Ssl(int macAlgorithm);
    protected virtual TlsHmac CreateMac(TlsCryptoParameters cryptoParams, int macAlgorithm);
    public virtual TlsSrp6Client CreateSrp6Client(TlsSrpConfig srpConfig);
    public virtual TlsSrp6Server CreateSrp6Server(TlsSrpConfig srpConfig, BigInteger srpVerifier);
    public virtual TlsSrp6VerifierGenerator CreateSrp6VerifierGenerator(TlsSrpConfig srpConfig);
    public virtual TlsSecret HkdfInit(int cryptoHashAlgorithm);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsDH : object {
    protected BcTlsDHDomain m_domain;
    protected AsymmetricCipherKeyPair m_localKeyPair;
    protected DHPublicKeyParameters m_peerPublicKey;
    public BcTlsDH(BcTlsDHDomain domain);
    public virtual Byte[] GenerateEphemeral();
    public virtual void ReceivePeerValue(Byte[] peerValue);
    public virtual TlsSecret CalculateSecret();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsDHDomain : object {
    protected BcTlsCrypto crypto;
    protected TlsDHConfig dhConfig;
    protected DHParameters dhParameters;
    public BcTlsDHDomain(BcTlsCrypto crypto, TlsDHConfig dhConfig);
    private static Byte[] EncodeValue(DHParameters dh, bool padded, BigInteger x);
    private static int GetValueLength(DHParameters dh);
    public static BcTlsSecret CalculateDHAgreement(BcTlsCrypto crypto, DHPrivateKeyParameters privateKey, DHPublicKeyParameters publicKey, bool padded);
    public static DHParameters GetParameters(TlsDHConfig dhConfig);
    public virtual BcTlsSecret CalculateDHAgreement(DHPrivateKeyParameters privateKey, DHPublicKeyParameters publicKey);
    public virtual TlsAgreement CreateDH();
    public virtual BigInteger DecodeParameter(Byte[] encoding);
    public virtual DHPublicKeyParameters DecodePublicKey(Byte[] encoding);
    public virtual Byte[] EncodeParameter(BigInteger x);
    public virtual Byte[] EncodePublicKey(DHPublicKeyParameters publicKey);
    public virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsDsaSigner : BcTlsDssSigner {
    protected short SignatureAlgorithm { get; }
    public BcTlsDsaSigner(BcTlsCrypto crypto, DsaPrivateKeyParameters privateKey);
    protected virtual IDsa CreateDsaImpl(int cryptoHashAlgorithm);
    protected virtual short get_SignatureAlgorithm();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsDsaVerifier : BcTlsDssVerifier {
    protected short SignatureAlgorithm { get; }
    public BcTlsDsaVerifier(BcTlsCrypto crypto, DsaPublicKeyParameters publicKey);
    protected virtual IDsa CreateDsaImpl(int cryptoHashAlgorithm);
    protected virtual short get_SignatureAlgorithm();
}
public abstract class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsDssSigner : BcTlsSigner {
    protected short SignatureAlgorithm { get; }
    protected BcTlsDssSigner(BcTlsCrypto crypto, AsymmetricKeyParameter privateKey);
    protected abstract virtual IDsa CreateDsaImpl(int cryptoHashAlgorithm);
    protected abstract virtual short get_SignatureAlgorithm();
    public virtual Byte[] GenerateRawSignature(SignatureAndHashAlgorithm algorithm, Byte[] hash);
}
public abstract class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsDssVerifier : BcTlsVerifier {
    protected short SignatureAlgorithm { get; }
    protected BcTlsDssVerifier(BcTlsCrypto crypto, AsymmetricKeyParameter publicKey);
    protected abstract virtual IDsa CreateDsaImpl(int cryptoHashAlgorithm);
    protected abstract virtual short get_SignatureAlgorithm();
    public virtual bool VerifyRawSignature(DigitallySigned signedParams, Byte[] hash);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsECDH : object {
    protected BcTlsECDomain m_domain;
    protected AsymmetricCipherKeyPair m_localKeyPair;
    protected ECPublicKeyParameters m_peerPublicKey;
    public BcTlsECDH(BcTlsECDomain domain);
    public virtual Byte[] GenerateEphemeral();
    public virtual void ReceivePeerValue(Byte[] peerValue);
    public virtual TlsSecret CalculateSecret();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsECDomain : object {
    protected BcTlsCrypto m_crypto;
    protected TlsECConfig m_ecConfig;
    protected ECDomainParameters m_ecDomainParameters;
    public BcTlsECDomain(BcTlsCrypto crypto, TlsECConfig ecConfig);
    public static BcTlsSecret CalculateBasicAgreement(BcTlsCrypto crypto, ECPrivateKeyParameters privateKey, ECPublicKeyParameters publicKey);
    public static ECDomainParameters GetDomainParameters(TlsECConfig ecConfig);
    public static ECDomainParameters GetDomainParameters(int namedGroup);
    public virtual BcTlsSecret CalculateECDHAgreement(ECPrivateKeyParameters privateKey, ECPublicKeyParameters publicKey);
    public virtual TlsAgreement CreateECDH();
    public virtual ECPoint DecodePoint(Byte[] encoding);
    public virtual ECPublicKeyParameters DecodePublicKey(Byte[] encoding);
    public virtual Byte[] EncodePoint(ECPoint point);
    public virtual Byte[] EncodePublicKey(ECPublicKeyParameters publicKey);
    public virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsECDsa13Signer : BcTlsSigner {
    private int m_signatureScheme;
    public BcTlsECDsa13Signer(BcTlsCrypto crypto, ECPrivateKeyParameters privateKey, int signatureScheme);
    public virtual Byte[] GenerateRawSignature(SignatureAndHashAlgorithm algorithm, Byte[] hash);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsECDsa13Verifier : BcTlsVerifier {
    private int m_signatureScheme;
    public BcTlsECDsa13Verifier(BcTlsCrypto crypto, ECPublicKeyParameters publicKey, int signatureScheme);
    public virtual bool VerifyRawSignature(DigitallySigned signature, Byte[] hash);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsECDsaSigner : BcTlsDssSigner {
    protected short SignatureAlgorithm { get; }
    public BcTlsECDsaSigner(BcTlsCrypto crypto, ECPrivateKeyParameters privateKey);
    protected virtual IDsa CreateDsaImpl(int cryptoHashAlgorithm);
    protected virtual short get_SignatureAlgorithm();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsECDsaVerifier : BcTlsDssVerifier {
    protected short SignatureAlgorithm { get; }
    public BcTlsECDsaVerifier(BcTlsCrypto crypto, ECPublicKeyParameters publicKey);
    protected virtual IDsa CreateDsaImpl(int cryptoHashAlgorithm);
    protected virtual short get_SignatureAlgorithm();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsEd25519Signer : BcTlsSigner {
    public BcTlsEd25519Signer(BcTlsCrypto crypto, Ed25519PrivateKeyParameters privateKey);
    public virtual Byte[] GenerateRawSignature(SignatureAndHashAlgorithm algorithm, Byte[] hash);
    public virtual TlsStreamSigner GetStreamSigner(SignatureAndHashAlgorithm algorithm);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsEd25519Verifier : BcTlsVerifier {
    public BcTlsEd25519Verifier(BcTlsCrypto crypto, Ed25519PublicKeyParameters publicKey);
    public virtual bool VerifyRawSignature(DigitallySigned signature, Byte[] hash);
    public virtual TlsStreamVerifier GetStreamVerifier(DigitallySigned signature);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsEd448Signer : BcTlsSigner {
    public BcTlsEd448Signer(BcTlsCrypto crypto, Ed448PrivateKeyParameters privateKey);
    public virtual Byte[] GenerateRawSignature(SignatureAndHashAlgorithm algorithm, Byte[] hash);
    public virtual TlsStreamSigner GetStreamSigner(SignatureAndHashAlgorithm algorithm);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsEd448Verifier : BcTlsVerifier {
    public BcTlsEd448Verifier(BcTlsCrypto crypto, Ed448PublicKeyParameters publicKey);
    public virtual bool VerifyRawSignature(DigitallySigned signature, Byte[] hash);
    public virtual TlsStreamVerifier GetStreamVerifier(DigitallySigned signature);
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsHash : object {
    private BcTlsCrypto m_crypto;
    private int m_cryptoHashAlgorithm;
    private IDigest m_digest;
    internal BcTlsHash(BcTlsCrypto crypto, int cryptoHashAlgorithm);
    private BcTlsHash(BcTlsCrypto crypto, int cryptoHashAlgorithm, IDigest digest);
    public sealed virtual void Update(Byte[] data, int offSet, int length);
    public sealed virtual Byte[] CalculateHash();
    public sealed virtual TlsHash CloneHash();
    public sealed virtual void Reset();
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsHmac : object {
    private HMac m_hmac;
    public int InternalBlockSize { get; }
    public int MacLength { get; }
    internal BcTlsHmac(HMac hmac);
    public sealed virtual void SetKey(Byte[] key, int keyOff, int keyLen);
    public sealed virtual void Update(Byte[] input, int inOff, int length);
    public sealed virtual Byte[] CalculateMac();
    public sealed virtual void CalculateMac(Byte[] output, int outOff);
    public sealed virtual int get_InternalBlockSize();
    public sealed virtual int get_MacLength();
    public sealed virtual void Reset();
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsNonceGenerator : object {
    private IRandomGenerator m_randomGenerator;
    internal BcTlsNonceGenerator(IRandomGenerator randomGenerator);
    public sealed virtual Byte[] GenerateNonce(int size);
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRsaEncryptor : object {
    private BcTlsCrypto m_crypto;
    private RsaKeyParameters m_pubKeyRsa;
    internal BcTlsRsaEncryptor(BcTlsCrypto crypto, RsaKeyParameters pubKeyRsa);
    private static RsaKeyParameters CheckPublicKey(RsaKeyParameters pubKeyRsa);
    public sealed virtual Byte[] Encrypt(Byte[] input, int inOff, int length);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRsaPssSigner : BcTlsSigner {
    private int m_signatureScheme;
    public BcTlsRsaPssSigner(BcTlsCrypto crypto, RsaKeyParameters privateKey, int signatureScheme);
    public virtual Byte[] GenerateRawSignature(SignatureAndHashAlgorithm algorithm, Byte[] hash);
    public virtual TlsStreamSigner GetStreamSigner(SignatureAndHashAlgorithm algorithm);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRsaPssVerifier : BcTlsVerifier {
    private int m_signatureScheme;
    public BcTlsRsaPssVerifier(BcTlsCrypto crypto, RsaKeyParameters publicKey, int signatureScheme);
    public virtual bool VerifyRawSignature(DigitallySigned signature, Byte[] hash);
    public virtual TlsStreamVerifier GetStreamVerifier(DigitallySigned signature);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRsaSigner : BcTlsSigner {
    private RsaKeyParameters m_publicKey;
    public BcTlsRsaSigner(BcTlsCrypto crypto, RsaKeyParameters privateKey, RsaKeyParameters publicKey);
    public virtual Byte[] GenerateRawSignature(SignatureAndHashAlgorithm algorithm, Byte[] hash);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsRsaVerifier : BcTlsVerifier {
    public BcTlsRsaVerifier(BcTlsCrypto crypto, RsaKeyParameters publicKey);
    public virtual bool VerifyRawSignature(DigitallySigned signedParams, Byte[] hash);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsSecret : AbstractTlsSecret {
    private static Byte[] Ssl3Const;
    protected BcTlsCrypto m_crypto;
    protected AbstractTlsCrypto Crypto { get; }
    public BcTlsSecret(BcTlsCrypto crypto, Byte[] data);
    private static BcTlsSecret();
    public static BcTlsSecret Convert(BcTlsCrypto crypto, TlsSecret secret);
    private static Byte[] GenerateSsl3Constants();
    public virtual TlsSecret DeriveUsingPrf(int prfAlgorithm, string label, Byte[] seed, int length);
    public virtual TlsSecret HkdfExpand(int cryptoHashAlgorithm, Byte[] info, int length);
    public virtual TlsSecret HkdfExtract(int cryptoHashAlgorithm, TlsSecret ikm);
    protected virtual AbstractTlsCrypto get_Crypto();
    protected virtual void HmacHash(IDigest digest, Byte[] secret, int secretOff, int secretLen, Byte[] seed, Byte[] output);
    protected virtual Byte[] Prf(int prfAlgorithm, string label, Byte[] seed, int length);
    protected virtual Byte[] Prf_Ssl(Byte[] seed, int length);
    protected virtual Byte[] Prf_1_0(Byte[] labelSeed, int length);
    protected virtual Byte[] Prf_1_2(int prfAlgorithm, Byte[] labelSeed, int length);
    protected virtual void UpdateMac(IMac mac);
}
public abstract class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsSigner : object {
    protected BcTlsCrypto m_crypto;
    protected AsymmetricKeyParameter m_privateKey;
    protected BcTlsSigner(BcTlsCrypto crypto, AsymmetricKeyParameter privateKey);
    public abstract virtual Byte[] GenerateRawSignature(SignatureAndHashAlgorithm algorithm, Byte[] hash);
    public virtual TlsStreamSigner GetStreamSigner(SignatureAndHashAlgorithm algorithm);
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsSrp6Client : object {
    private Srp6Client m_srp6Client;
    internal BcTlsSrp6Client(Srp6Client srpClient);
    public sealed virtual BigInteger CalculateSecret(BigInteger serverB);
    public sealed virtual BigInteger GenerateClientCredentials(Byte[] srpSalt, Byte[] identity, Byte[] password);
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsSrp6Server : object {
    private Srp6Server m_srp6Server;
    internal BcTlsSrp6Server(Srp6Server srp6Server);
    public sealed virtual BigInteger GenerateServerCredentials();
    public sealed virtual BigInteger CalculateSecret(BigInteger clientA);
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsSrp6VerifierGenerator : object {
    private Srp6VerifierGenerator m_srp6VerifierGenerator;
    internal BcTlsSrp6VerifierGenerator(Srp6VerifierGenerator srp6VerifierGenerator);
    public sealed virtual BigInteger GenerateVerifier(Byte[] salt, Byte[] identity, Byte[] password);
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsStreamSigner : object {
    private SignerSink m_output;
    internal BcTlsStreamSigner(ISigner signer);
    public sealed virtual Stream GetOutputStream();
    public sealed virtual Byte[] GetSignature();
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsStreamVerifier : object {
    private SignerSink m_output;
    private Byte[] m_signature;
    internal BcTlsStreamVerifier(ISigner verifier, Byte[] signature);
    public sealed virtual Stream GetOutputStream();
    public sealed virtual bool IsVerified();
}
public abstract class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsVerifier : object {
    protected BcTlsCrypto m_crypto;
    protected AsymmetricKeyParameter m_publicKey;
    protected BcTlsVerifier(BcTlsCrypto crypto, AsymmetricKeyParameter publicKey);
    public virtual TlsStreamVerifier GetStreamVerifier(DigitallySigned signature);
    public abstract virtual bool VerifyRawSignature(DigitallySigned signature, Byte[] hash);
}
internal class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcVerifyingStreamSigner : object {
    private ISigner m_signer;
    private ISigner m_verifier;
    private TeeOutputStream m_output;
    internal BcVerifyingStreamSigner(ISigner signer, ISigner verifier);
    public sealed virtual Stream GetOutputStream();
    public sealed virtual Byte[] GetSignature();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcX25519 : object {
    protected BcTlsCrypto m_crypto;
    protected Byte[] m_privateKey;
    protected Byte[] m_peerPublicKey;
    public BcX25519(BcTlsCrypto crypto);
    public virtual Byte[] GenerateEphemeral();
    public virtual void ReceivePeerValue(Byte[] peerValue);
    public virtual TlsSecret CalculateSecret();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcX25519Domain : object {
    protected BcTlsCrypto m_crypto;
    public BcX25519Domain(BcTlsCrypto crypto);
    public virtual TlsAgreement CreateECDH();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcX448 : object {
    protected BcTlsCrypto m_crypto;
    protected Byte[] m_privateKey;
    protected Byte[] m_peerPublicKey;
    public BcX448(BcTlsCrypto crypto);
    public virtual Byte[] GenerateEphemeral();
    public virtual void ReceivePeerValue(Byte[] peerValue);
    public virtual TlsSecret CalculateSecret();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.BC.BcX448Domain : object {
    protected BcTlsCrypto m_crypto;
    public BcX448Domain(BcTlsCrypto crypto);
    public virtual TlsAgreement CreateECDH();
}
public abstract class Org.BouncyCastle.Tls.Crypto.Impl.RsaUtilities : object {
    private static Byte[] RSAPSSParams_256_A;
    private static Byte[] RSAPSSParams_384_A;
    private static Byte[] RSAPSSParams_512_A;
    private static Byte[] RSAPSSParams_256_B;
    private static Byte[] RSAPSSParams_384_B;
    private static Byte[] RSAPSSParams_512_B;
    private static RsaUtilities();
    public static bool SupportsPkcs1(AlgorithmIdentifier pubKeyAlgID);
    public static bool SupportsPss_Pss(short signatureAlgorithm, AlgorithmIdentifier pubKeyAlgID);
    public static bool SupportsPss_Rsae(AlgorithmIdentifier pubKeyAlgID);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.TlsAeadCipher : object {
    public static int AEAD_CCM;
    public static int AEAD_CHACHA20_POLY1305;
    public static int AEAD_GCM;
    private static int NONCE_RFC5288;
    private static int NONCE_RFC7905;
    protected TlsCryptoParameters m_cryptoParams;
    protected int m_keySize;
    protected int m_macSize;
    protected int m_fixed_iv_length;
    protected int m_record_iv_length;
    protected TlsAeadCipherImpl m_decryptCipher;
    protected TlsAeadCipherImpl m_encryptCipher;
    protected Byte[] m_decryptNonce;
    protected Byte[] m_encryptNonce;
    protected bool m_isTlsV13;
    protected int m_nonceMode;
    public bool UsesOpaqueRecordType { get; }
    public TlsAeadCipher(TlsCryptoParameters cryptoParams, TlsAeadCipherImpl encryptCipher, TlsAeadCipherImpl decryptCipher, int keySize, int macSize, int aeadType);
    public virtual int GetCiphertextDecodeLimit(int plaintextLimit);
    public virtual int GetCiphertextEncodeLimit(int plaintextLength, int plaintextLimit);
    public virtual int GetPlaintextLimit(int ciphertextLimit);
    public virtual TlsEncodeResult EncodePlaintext(long seqNo, short contentType, ProtocolVersion recordVersion, int headerAllocation, Byte[] plaintext, int plaintextOffset, int plaintextLength);
    public virtual TlsDecodeResult DecodeCiphertext(long seqNo, short recordType, ProtocolVersion recordVersion, Byte[] ciphertext, int ciphertextOffset, int ciphertextLength);
    public virtual void RekeyDecoder();
    public virtual void RekeyEncoder();
    public virtual bool get_UsesOpaqueRecordType();
    protected virtual Byte[] GetAdditionalData(long seqNo, short recordType, ProtocolVersion recordVersion, int ciphertextLength, int plaintextLength);
    protected virtual void RekeyCipher(SecurityParameters securityParameters, TlsAeadCipherImpl cipher, Byte[] nonce, bool serverSecret);
    protected virtual void Setup13Cipher(TlsAeadCipherImpl cipher, Byte[] nonce, TlsSecret secret, int cryptoHashAlgorithm);
    private static int GetNonceMode(bool isTLSv13, int aeadType);
}
public interface Org.BouncyCastle.Tls.Crypto.Impl.TlsAeadCipherImpl {
    public abstract virtual void SetKey(Byte[] key, int keyOff, int keyLen);
    public abstract virtual void Init(Byte[] nonce, int macSize, Byte[] additionalData);
    public abstract virtual int GetOutputSize(int inputLength);
    public abstract virtual int DoFinal(Byte[] input, int inputOffset, int inputLength, Byte[] output, int outputOffset);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.TlsBlockCipher : object {
    protected TlsCryptoParameters m_cryptoParams;
    protected Byte[] m_randomData;
    protected bool m_encryptThenMac;
    protected bool m_useExplicitIV;
    protected bool m_acceptExtraPadding;
    protected bool m_useExtraPadding;
    protected TlsBlockCipherImpl m_decryptCipher;
    protected TlsBlockCipherImpl m_encryptCipher;
    protected TlsSuiteMac m_readMac;
    protected TlsSuiteMac m_writeMac;
    public bool UsesOpaqueRecordType { get; }
    public TlsBlockCipher(TlsCryptoParameters cryptoParams, TlsBlockCipherImpl encryptCipher, TlsBlockCipherImpl decryptCipher, TlsHmac clientMac, TlsHmac serverMac, int cipherKeySize);
    public virtual int GetCiphertextDecodeLimit(int plaintextLimit);
    public virtual int GetCiphertextEncodeLimit(int plaintextLength, int plaintextLimit);
    public virtual int GetPlaintextLimit(int ciphertextLimit);
    public virtual TlsEncodeResult EncodePlaintext(long seqNo, short contentType, ProtocolVersion recordVersion, int headerAllocation, Byte[] plaintext, int offset, int len);
    public virtual TlsDecodeResult DecodeCiphertext(long seqNo, short recordType, ProtocolVersion recordVersion, Byte[] ciphertext, int offset, int len);
    public virtual void RekeyDecoder();
    public virtual void RekeyEncoder();
    public virtual bool get_UsesOpaqueRecordType();
    protected virtual int CheckPaddingConstantTime(Byte[] buf, int off, int len, int blockSize, int macSize);
    protected virtual int ChooseExtraPadBlocks(int max);
    protected virtual int GetCiphertextLength(int blockSize, int macSize, int maxPadding, int plaintextLength);
}
public interface Org.BouncyCastle.Tls.Crypto.Impl.TlsBlockCipherImpl {
    public abstract virtual void SetKey(Byte[] key, int keyOff, int keyLen);
    public abstract virtual void Init(Byte[] iv, int ivOff, int ivLen);
    public abstract virtual int DoFinal(Byte[] input, int inputOffset, int inputLength, Byte[] output, int outputOffset);
    public abstract virtual int GetBlockSize();
}
public abstract class Org.BouncyCastle.Tls.Crypto.Impl.TlsImplUtilities : object {
    public static bool IsSsl(TlsCryptoParameters cryptoParams);
    public static bool IsTlsV10(ProtocolVersion version);
    public static bool IsTlsV10(TlsCryptoParameters cryptoParams);
    public static bool IsTlsV11(ProtocolVersion version);
    public static bool IsTlsV11(TlsCryptoParameters cryptoParams);
    public static bool IsTlsV12(ProtocolVersion version);
    public static bool IsTlsV12(TlsCryptoParameters cryptoParams);
    public static bool IsTlsV13(ProtocolVersion version);
    public static bool IsTlsV13(TlsCryptoParameters cryptoParams);
    public static Byte[] CalculateKeyBlock(TlsCryptoParameters cryptoParams, int length);
    public static TlsSecret Prf(SecurityParameters securityParameters, TlsSecret secret, string asciiLabel, Byte[] seed, int length);
    public static TlsSecret Prf(TlsCryptoParameters cryptoParams, TlsSecret secret, string asciiLabel, Byte[] seed, int length);
}
public class Org.BouncyCastle.Tls.Crypto.Impl.TlsNullCipher : object {
    protected TlsCryptoParameters m_cryptoParams;
    protected TlsSuiteHmac m_readMac;
    protected TlsSuiteHmac m_writeMac;
    public bool UsesOpaqueRecordType { get; }
    public TlsNullCipher(TlsCryptoParameters cryptoParams, TlsHmac clientMac, TlsHmac serverMac);
    public virtual int GetCiphertextDecodeLimit(int plaintextLimit);
    public virtual int GetCiphertextEncodeLimit(int plaintextLength, int plaintextLimit);
    public virtual int GetPlaintextLimit(int ciphertextLimit);
    public virtual TlsEncodeResult EncodePlaintext(long seqNo, short contentType, ProtocolVersion recordVersion, int headerAllocation, Byte[] plaintext, int offset, int len);
    public virtual TlsDecodeResult DecodeCiphertext(long seqNo, short recordType, ProtocolVersion recordVersion, Byte[] ciphertext, int offset, int len);
    public virtual void RekeyDecoder();
    public virtual void RekeyEncoder();
    public virtual bool get_UsesOpaqueRecordType();
}
public class Org.BouncyCastle.Tls.Crypto.Impl.TlsSuiteHmac : object {
    protected TlsCryptoParameters m_cryptoParams;
    protected TlsHmac m_mac;
    protected int m_digestBlockSize;
    protected int m_digestOverhead;
    protected int m_macSize;
    public int Size { get; }
    public TlsSuiteHmac(TlsCryptoParameters cryptoParams, TlsHmac mac);
    protected static int GetMacSize(TlsCryptoParameters cryptoParams, TlsMac mac);
    public virtual int get_Size();
    public virtual Byte[] CalculateMac(long seqNo, short type, Byte[] msg, int msgOff, int msgLen);
    public virtual Byte[] CalculateMacConstantTime(long seqNo, short type, Byte[] msg, int msgOff, int msgLen, int fullLength, Byte[] dummyData);
    protected virtual int GetDigestBlockCount(int inputLength);
    protected virtual Byte[] Truncate(Byte[] bs);
}
public interface Org.BouncyCastle.Tls.Crypto.Impl.TlsSuiteMac {
    public int Size { get; }
    public abstract virtual int get_Size();
    public abstract virtual Byte[] CalculateMac(long seqNo, short type, Byte[] message, int offset, int length);
    public abstract virtual Byte[] CalculateMacConstantTime(long seqNo, short type, Byte[] message, int offset, int length, int expectedLength, Byte[] randomData);
}
public class Org.BouncyCastle.Tls.Crypto.Srp6Group : object {
    private BigInteger n;
    private BigInteger g;
    public BigInteger G { get; }
    public BigInteger N { get; }
    public Srp6Group(BigInteger n, BigInteger g);
    public virtual BigInteger get_G();
    public virtual BigInteger get_N();
}
public class Org.BouncyCastle.Tls.Crypto.Srp6StandardGroups : object {
    private static string rfc5054_1024_N;
    private static string rfc5054_1024_g;
    public static Srp6Group rfc5054_1024;
    private static string rfc5054_1536_N;
    private static string rfc5054_1536_g;
    public static Srp6Group rfc5054_1536;
    private static string rfc5054_2048_N;
    private static string rfc5054_2048_g;
    public static Srp6Group rfc5054_2048;
    private static string rfc5054_3072_N;
    private static string rfc5054_3072_g;
    public static Srp6Group rfc5054_3072;
    private static string rfc5054_4096_N;
    private static string rfc5054_4096_g;
    public static Srp6Group rfc5054_4096;
    private static string rfc5054_6144_N;
    private static string rfc5054_6144_g;
    public static Srp6Group rfc5054_6144;
    private static string rfc5054_8192_N;
    private static string rfc5054_8192_g;
    public static Srp6Group rfc5054_8192;
    private static Srp6StandardGroups();
    private static BigInteger FromHex(string hex);
    private static Srp6Group FromNG(string hexN, string hexG);
}
public interface Org.BouncyCastle.Tls.Crypto.TlsAgreement {
    public abstract virtual Byte[] GenerateEphemeral();
    public abstract virtual void ReceivePeerValue(Byte[] peerValue);
    public abstract virtual TlsSecret CalculateSecret();
}
public interface Org.BouncyCastle.Tls.Crypto.TlsCertificate {
    public BigInteger SerialNumber { get; }
    public string SigAlgOid { get; }
    public abstract virtual TlsEncryptor CreateEncryptor(int tlsCertificateRole);
    public abstract virtual TlsVerifier CreateVerifier(short signatureAlgorithm);
    public abstract virtual TlsVerifier CreateVerifier(int signatureScheme);
    public abstract virtual Byte[] GetEncoded();
    public abstract virtual Byte[] GetExtension(DerObjectIdentifier extensionOid);
    public abstract virtual BigInteger get_SerialNumber();
    public abstract virtual string get_SigAlgOid();
    public abstract virtual Asn1Encodable GetSigAlgParams();
    public abstract virtual short GetLegacySignatureAlgorithm();
    public abstract virtual bool SupportsSignatureAlgorithm(short signatureAlgorithm);
    public abstract virtual bool SupportsSignatureAlgorithmCA(short signatureAlgorithm);
    public abstract virtual TlsCertificate CheckUsageInRole(int tlsCertificateRole);
}
public abstract class Org.BouncyCastle.Tls.Crypto.TlsCertificateRole : object {
    public static int DH;
    public static int ECDH;
    public static int RsaEncryption;
    public static int Sm2Encryption;
}
public interface Org.BouncyCastle.Tls.Crypto.TlsCipher {
    public bool UsesOpaqueRecordType { get; }
    public abstract virtual int GetCiphertextDecodeLimit(int plaintextLimit);
    public abstract virtual int GetCiphertextEncodeLimit(int plaintextLength, int plaintextLimit);
    public abstract virtual int GetPlaintextLimit(int ciphertextLimit);
    public abstract virtual TlsEncodeResult EncodePlaintext(long seqNo, short contentType, ProtocolVersion recordVersion, int headerAllocation, Byte[] plaintext, int offset, int len);
    public abstract virtual TlsDecodeResult DecodeCiphertext(long seqNo, short recordType, ProtocolVersion recordVersion, Byte[] ciphertext, int offset, int len);
    public abstract virtual void RekeyDecoder();
    public abstract virtual void RekeyEncoder();
    public abstract virtual bool get_UsesOpaqueRecordType();
}
public interface Org.BouncyCastle.Tls.Crypto.TlsCrypto {
    public SecureRandom SecureRandom { get; }
    public abstract virtual bool HasAllRawSignatureAlgorithms();
    public abstract virtual bool HasDHAgreement();
    public abstract virtual bool HasECDHAgreement();
    public abstract virtual bool HasEncryptionAlgorithm(int encryptionAlgorithm);
    public abstract virtual bool HasCryptoHashAlgorithm(int cryptoHashAlgorithm);
    public abstract virtual bool HasCryptoSignatureAlgorithm(int cryptoSignatureAlgorithm);
    public abstract virtual bool HasMacAlgorithm(int macAlgorithm);
    public abstract virtual bool HasNamedGroup(int namedGroup);
    public abstract virtual bool HasRsaEncryption();
    public abstract virtual bool HasSignatureAlgorithm(short signatureAlgorithm);
    public abstract virtual bool HasSignatureAndHashAlgorithm(SignatureAndHashAlgorithm sigAndHashAlgorithm);
    public abstract virtual bool HasSignatureScheme(int signatureScheme);
    public abstract virtual bool HasSrpAuthentication();
    public abstract virtual TlsSecret CreateSecret(Byte[] data);
    public abstract virtual TlsSecret GenerateRsaPreMasterSecret(ProtocolVersion clientVersion);
    public abstract virtual SecureRandom get_SecureRandom();
    public abstract virtual TlsCertificate CreateCertificate(Byte[] encoding);
    public abstract virtual TlsCipher CreateCipher(TlsCryptoParameters cryptoParams, int encryptionAlgorithm, int macAlgorithm);
    public abstract virtual TlsDHDomain CreateDHDomain(TlsDHConfig dhConfig);
    public abstract virtual TlsECDomain CreateECDomain(TlsECConfig ecConfig);
    public abstract virtual TlsSecret AdoptSecret(TlsSecret secret);
    public abstract virtual TlsHash CreateHash(int cryptoHashAlgorithm);
    public abstract virtual TlsHmac CreateHmac(int macAlgorithm);
    public abstract virtual TlsHmac CreateHmacForHash(int cryptoHashAlgorithm);
    public abstract virtual TlsNonceGenerator CreateNonceGenerator(Byte[] additionalSeedMaterial);
    public abstract virtual TlsSrp6Client CreateSrp6Client(TlsSrpConfig srpConfig);
    public abstract virtual TlsSrp6Server CreateSrp6Server(TlsSrpConfig srpConfig, BigInteger srpVerifier);
    public abstract virtual TlsSrp6VerifierGenerator CreateSrp6VerifierGenerator(TlsSrpConfig srpConfig);
    public abstract virtual TlsSecret HkdfInit(int cryptoHashAlgorithm);
}
public class Org.BouncyCastle.Tls.Crypto.TlsCryptoException : TlsException {
    public TlsCryptoException(string msg);
    public TlsCryptoException(string msg, Exception cause);
}
public class Org.BouncyCastle.Tls.Crypto.TlsCryptoParameters : object {
    private TlsContext m_context;
    public SecurityParameters SecurityParameters { get; }
    public ProtocolVersion ClientVersion { get; }
    public ProtocolVersion RsaPreMasterSecretVersion { get; }
    public ProtocolVersion ServerVersion { get; }
    public bool IsServer { get; }
    public TlsNonceGenerator NonceGenerator { get; }
    public TlsCryptoParameters(TlsContext context);
    public SecurityParameters get_SecurityParameters();
    public ProtocolVersion get_ClientVersion();
    public ProtocolVersion get_RsaPreMasterSecretVersion();
    public virtual ProtocolVersion get_ServerVersion();
    public bool get_IsServer();
    public TlsNonceGenerator get_NonceGenerator();
}
public abstract class Org.BouncyCastle.Tls.Crypto.TlsCryptoUtilities : object {
    private static Byte[] Tls13Prefix;
    private static TlsCryptoUtilities();
    public static int GetHash(short hashAlgorithm);
    public static int GetHashForHmac(int macAlgorithm);
    public static int GetHashForPrf(int prfAlgorithm);
    public static int GetHashOutputSize(int cryptoHashAlgorithm);
    public static int GetSignature(short signatureAlgorithm);
    public static TlsSecret HkdfExpandLabel(TlsSecret secret, int cryptoHashAlgorithm, string label, Byte[] context, int length);
}
public class Org.BouncyCastle.Tls.Crypto.TlsDecodeResult : object {
    public Byte[] buf;
    public int off;
    public int len;
    public short contentType;
    public TlsDecodeResult(Byte[] buf, int off, int len, short contentType);
}
public class Org.BouncyCastle.Tls.Crypto.TlsDHConfig : object {
    protected DHGroup m_explicitGroup;
    protected int m_namedGroup;
    protected bool m_padded;
    public DHGroup ExplicitGroup { get; }
    public int NamedGroup { get; }
    public bool IsPadded { get; }
    public TlsDHConfig(DHGroup explicitGroup);
    public TlsDHConfig(int namedGroup, bool padded);
    public virtual DHGroup get_ExplicitGroup();
    public virtual int get_NamedGroup();
    public virtual bool get_IsPadded();
}
public interface Org.BouncyCastle.Tls.Crypto.TlsDHDomain {
    public abstract virtual TlsAgreement CreateDH();
}
public class Org.BouncyCastle.Tls.Crypto.TlsECConfig : object {
    protected int m_namedGroup;
    public int NamedGroup { get; }
    public TlsECConfig(int namedGroup);
    public virtual int get_NamedGroup();
}
public interface Org.BouncyCastle.Tls.Crypto.TlsECDomain {
    public abstract virtual TlsAgreement CreateECDH();
}
public class Org.BouncyCastle.Tls.Crypto.TlsEncodeResult : object {
    public Byte[] buf;
    public int off;
    public int len;
    public short recordType;
    public TlsEncodeResult(Byte[] buf, int off, int len, short recordType);
}
public interface Org.BouncyCastle.Tls.Crypto.TlsEncryptor {
    public abstract virtual Byte[] Encrypt(Byte[] input, int inOff, int length);
}
public interface Org.BouncyCastle.Tls.Crypto.TlsHash {
    public abstract virtual void Update(Byte[] input, int inOff, int length);
    public abstract virtual Byte[] CalculateHash();
    public abstract virtual TlsHash CloneHash();
    public abstract virtual void Reset();
}
public class Org.BouncyCastle.Tls.Crypto.TlsHashSink : BaseOutputStream {
    private TlsHash m_hash;
    public TlsHash Hash { get; }
    public TlsHashSink(TlsHash hash);
    public virtual TlsHash get_Hash();
    public virtual void WriteByte(byte b);
    public virtual void Write(Byte[] buf, int off, int len);
}
public interface Org.BouncyCastle.Tls.Crypto.TlsHmac {
    public int InternalBlockSize { get; }
    public abstract virtual int get_InternalBlockSize();
}
public interface Org.BouncyCastle.Tls.Crypto.TlsMac {
    public int MacLength { get; }
    public abstract virtual void SetKey(Byte[] key, int keyOff, int keyLen);
    public abstract virtual void Update(Byte[] input, int inOff, int length);
    public abstract virtual Byte[] CalculateMac();
    public abstract virtual void CalculateMac(Byte[] output, int outOff);
    public abstract virtual int get_MacLength();
    public abstract virtual void Reset();
}
public class Org.BouncyCastle.Tls.Crypto.TlsMacSink : BaseOutputStream {
    private TlsMac m_mac;
    public TlsMac Mac { get; }
    public TlsMacSink(TlsMac mac);
    public virtual TlsMac get_Mac();
    public virtual void WriteByte(byte b);
    public virtual void Write(Byte[] buf, int off, int len);
}
public interface Org.BouncyCastle.Tls.Crypto.TlsNonceGenerator {
    public abstract virtual Byte[] GenerateNonce(int size);
}
public class Org.BouncyCastle.Tls.Crypto.TlsNullNullCipher : object {
    public static TlsNullNullCipher Instance;
    public bool UsesOpaqueRecordType { get; }
    private static TlsNullNullCipher();
    public sealed virtual int GetCiphertextDecodeLimit(int plaintextLimit);
    public sealed virtual int GetCiphertextEncodeLimit(int plaintextLength, int plaintextLimit);
    public sealed virtual int GetPlaintextLimit(int ciphertextLimit);
    public sealed virtual TlsEncodeResult EncodePlaintext(long seqNo, short contentType, ProtocolVersion recordVersion, int headerAllocation, Byte[] plaintext, int offset, int len);
    public sealed virtual TlsDecodeResult DecodeCiphertext(long seqNo, short recordType, ProtocolVersion recordVersion, Byte[] ciphertext, int offset, int len);
    public sealed virtual void RekeyDecoder();
    public sealed virtual void RekeyEncoder();
    public sealed virtual bool get_UsesOpaqueRecordType();
}
public interface Org.BouncyCastle.Tls.Crypto.TlsSecret {
    public abstract virtual Byte[] CalculateHmac(int cryptoHashAlgorithm, Byte[] buf, int off, int len);
    public abstract virtual TlsSecret DeriveUsingPrf(int prfAlgorithm, string label, Byte[] seed, int length);
    public abstract virtual void Destroy();
    public abstract virtual Byte[] Encrypt(TlsEncryptor encryptor);
    public abstract virtual Byte[] Extract();
    public abstract virtual TlsSecret HkdfExpand(int cryptoHashAlgorithm, Byte[] info, int length);
    public abstract virtual TlsSecret HkdfExtract(int cryptoHashAlgorithm, TlsSecret ikm);
    public abstract virtual bool IsAlive();
}
public interface Org.BouncyCastle.Tls.Crypto.TlsSigner {
    public abstract virtual Byte[] GenerateRawSignature(SignatureAndHashAlgorithm algorithm, Byte[] hash);
    public abstract virtual TlsStreamSigner GetStreamSigner(SignatureAndHashAlgorithm algorithm);
}
public interface Org.BouncyCastle.Tls.Crypto.TlsSrp6Client {
    public abstract virtual BigInteger CalculateSecret(BigInteger serverB);
    public abstract virtual BigInteger GenerateClientCredentials(Byte[] salt, Byte[] identity, Byte[] password);
}
public interface Org.BouncyCastle.Tls.Crypto.TlsSrp6Server {
    public abstract virtual BigInteger GenerateServerCredentials();
    public abstract virtual BigInteger CalculateSecret(BigInteger clientA);
}
public interface Org.BouncyCastle.Tls.Crypto.TlsSrp6VerifierGenerator {
    public abstract virtual BigInteger GenerateVerifier(Byte[] salt, Byte[] identity, Byte[] password);
}
public class Org.BouncyCastle.Tls.Crypto.TlsSrpConfig : object {
    protected BigInteger[] m_explicitNG;
    public BigInteger[] GetExplicitNG();
    public void SetExplicitNG(BigInteger[] explicitNG);
}
public interface Org.BouncyCastle.Tls.Crypto.TlsStreamSigner {
    public abstract virtual Stream GetOutputStream();
    public abstract virtual Byte[] GetSignature();
}
public interface Org.BouncyCastle.Tls.Crypto.TlsStreamVerifier {
    public abstract virtual Stream GetOutputStream();
    public abstract virtual bool IsVerified();
}
public interface Org.BouncyCastle.Tls.Crypto.TlsVerifier {
    public abstract virtual TlsStreamVerifier GetStreamVerifier(DigitallySigned signature);
    public abstract virtual bool VerifyRawSignature(DigitallySigned signature, Byte[] hash);
}
public interface Org.BouncyCastle.Tls.DatagramReceiver {
    public abstract virtual int GetReceiveLimit();
    public abstract virtual int Receive(Byte[] buf, int off, int len, int waitMillis);
}
public interface Org.BouncyCastle.Tls.DatagramSender {
    public abstract virtual int GetSendLimit();
    public abstract virtual void Send(Byte[] buf, int off, int len);
}
public interface Org.BouncyCastle.Tls.DatagramTransport {
}
public abstract class Org.BouncyCastle.Tls.DefaultTlsClient : AbstractTlsClient {
    private static Int32[] DefaultCipherSuites;
    public DefaultTlsClient(TlsCrypto crypto);
    private static DefaultTlsClient();
    protected virtual Int32[] GetSupportedCipherSuites();
}
public class Org.BouncyCastle.Tls.DefaultTlsCredentialedSigner : object {
    protected TlsCryptoParameters m_cryptoParams;
    protected Certificate m_certificate;
    protected SignatureAndHashAlgorithm m_signatureAndHashAlgorithm;
    protected TlsSigner m_signer;
    public Certificate Certificate { get; }
    public SignatureAndHashAlgorithm SignatureAndHashAlgorithm { get; }
    public DefaultTlsCredentialedSigner(TlsCryptoParameters cryptoParams, TlsSigner signer, Certificate certificate, SignatureAndHashAlgorithm signatureAndHashAlgorithm);
    public virtual Certificate get_Certificate();
    public virtual Byte[] GenerateRawSignature(Byte[] hash);
    public virtual SignatureAndHashAlgorithm get_SignatureAndHashAlgorithm();
    public virtual TlsStreamSigner GetStreamSigner();
    protected virtual SignatureAndHashAlgorithm GetEffectiveAlgorithm();
}
public class Org.BouncyCastle.Tls.DefaultTlsDHGroupVerifier : object {
    public static int DefaultMinimumPrimeBits;
    private static IList DefaultGroups;
    protected IList m_groups;
    protected int m_minimumPrimeBits;
    public int MinimumPrimeBits { get; }
    private static DefaultTlsDHGroupVerifier();
    public DefaultTlsDHGroupVerifier(int minimumPrimeBits);
    public DefaultTlsDHGroupVerifier(IList groups, int minimumPrimeBits);
    private static void AddDefaultGroup(DHGroup dhGroup);
    public virtual bool Accept(DHGroup dhGroup);
    public virtual int get_MinimumPrimeBits();
    protected virtual bool AreGroupsEqual(DHGroup a, DHGroup b);
    protected virtual bool AreParametersEqual(BigInteger a, BigInteger b);
    protected virtual bool CheckGroup(DHGroup dhGroup);
    protected virtual bool CheckMinimumPrimeBits(DHGroup dhGroup);
}
public class Org.BouncyCastle.Tls.DefaultTlsHeartbeat : object {
    private int idleMillis;
    private int timeoutMillis;
    private UInt32 counter;
    public int IdleMillis { get; }
    public int TimeoutMillis { get; }
    public DefaultTlsHeartbeat(int idleMillis, int timeoutMillis);
    public virtual Byte[] GeneratePayload();
    public virtual int get_IdleMillis();
    public virtual int get_TimeoutMillis();
}
public class Org.BouncyCastle.Tls.DefaultTlsKeyExchangeFactory : AbstractTlsKeyExchangeFactory {
    public virtual TlsKeyExchange CreateDHKeyExchange(int keyExchange);
    public virtual TlsKeyExchange CreateDHanonKeyExchangeClient(int keyExchange, TlsDHGroupVerifier dhGroupVerifier);
    public virtual TlsKeyExchange CreateDHanonKeyExchangeServer(int keyExchange, TlsDHConfig dhConfig);
    public virtual TlsKeyExchange CreateDheKeyExchangeClient(int keyExchange, TlsDHGroupVerifier dhGroupVerifier);
    public virtual TlsKeyExchange CreateDheKeyExchangeServer(int keyExchange, TlsDHConfig dhConfig);
    public virtual TlsKeyExchange CreateECDHKeyExchange(int keyExchange);
    public virtual TlsKeyExchange CreateECDHanonKeyExchangeClient(int keyExchange);
    public virtual TlsKeyExchange CreateECDHanonKeyExchangeServer(int keyExchange, TlsECConfig ecConfig);
    public virtual TlsKeyExchange CreateECDheKeyExchangeClient(int keyExchange);
    public virtual TlsKeyExchange CreateECDheKeyExchangeServer(int keyExchange, TlsECConfig ecConfig);
    public virtual TlsKeyExchange CreatePskKeyExchangeClient(int keyExchange, TlsPskIdentity pskIdentity, TlsDHGroupVerifier dhGroupVerifier);
    public virtual TlsKeyExchange CreatePskKeyExchangeServer(int keyExchange, TlsPskIdentityManager pskIdentityManager, TlsDHConfig dhConfig, TlsECConfig ecConfig);
    public virtual TlsKeyExchange CreateRsaKeyExchange(int keyExchange);
    public virtual TlsKeyExchange CreateSrpKeyExchangeClient(int keyExchange, TlsSrpIdentity srpIdentity, TlsSrpConfigVerifier srpConfigVerifier);
    public virtual TlsKeyExchange CreateSrpKeyExchangeServer(int keyExchange, TlsSrpLoginParameters loginParameters);
}
public abstract class Org.BouncyCastle.Tls.DefaultTlsServer : AbstractTlsServer {
    private static Int32[] DefaultCipherSuites;
    public DefaultTlsServer(TlsCrypto crypto);
    private static DefaultTlsServer();
    protected virtual TlsCredentialedSigner GetDsaSignerCredentials();
    protected virtual TlsCredentialedSigner GetECDsaSignerCredentials();
    protected virtual TlsCredentialedDecryptor GetRsaEncryptionCredentials();
    protected virtual TlsCredentialedSigner GetRsaSignerCredentials();
    protected virtual Int32[] GetSupportedCipherSuites();
    public virtual TlsCredentials GetCredentials();
}
public class Org.BouncyCastle.Tls.DefaultTlsSrpConfigVerifier : object {
    private static IList DefaultGroups;
    protected IList m_groups;
    private static DefaultTlsSrpConfigVerifier();
    public DefaultTlsSrpConfigVerifier(IList groups);
    public virtual bool Accept(TlsSrpConfig srpConfig);
    protected virtual bool AreGroupsEqual(TlsSrpConfig a, Srp6Group b);
    protected virtual bool AreParametersEqual(BigInteger a, BigInteger b);
}
internal class Org.BouncyCastle.Tls.DeferredHash : object {
    private static int BufferingHashLimit;
    private TlsContext m_context;
    private DigestInputBuffer m_buf;
    private IDictionary m_hashes;
    private bool m_forceBuffering;
    private bool m_sealed;
    internal DeferredHash(TlsContext context);
    private DeferredHash(TlsContext context, IDictionary hashes);
    public sealed virtual void CopyBufferTo(Stream output);
    public sealed virtual void ForceBuffering();
    public sealed virtual void NotifyPrfDetermined();
    public sealed virtual void TrackHashAlgorithm(int cryptoHashAlgorithm);
    public sealed virtual void SealHashAlgorithms();
    public sealed virtual TlsHandshakeHash StopTracking();
    public sealed virtual TlsHash ForkPrfHash();
    public sealed virtual Byte[] GetFinalHash(int cryptoHashAlgorithm);
    public sealed virtual void Update(Byte[] input, int inOff, int len);
    public sealed virtual Byte[] CalculateHash();
    public sealed virtual TlsHash CloneHash();
    public sealed virtual void Reset();
    private void CheckStopBuffering();
    private void CheckTrackingHash(int cryptoHashAlgorithm);
    private TlsHash CloneHash(int cryptoHashAlgorithm);
    private void CloneHash(IDictionary newHashes, int cryptoHashAlgorithm);
}
internal class Org.BouncyCastle.Tls.DigestInputBuffer : MemoryStream {
    internal void UpdateDigest(TlsHash hash);
    internal void CopyTo(Stream output);
}
public class Org.BouncyCastle.Tls.DigitallySigned : object {
    private SignatureAndHashAlgorithm algorithm;
    private Byte[] signature;
    public SignatureAndHashAlgorithm Algorithm { get; }
    public Byte[] Signature { get; }
    public DigitallySigned(SignatureAndHashAlgorithm algorithm, Byte[] signature);
    public SignatureAndHashAlgorithm get_Algorithm();
    public Byte[] get_Signature();
    public void Encode(Stream output);
    public static DigitallySigned Parse(TlsContext context, Stream input);
}
public class Org.BouncyCastle.Tls.DtlsClientProtocol : DtlsProtocol {
    public virtual DtlsTransport Connect(TlsClient client, DatagramTransport transport);
    internal virtual void AbortClientHandshake(ClientHandshakeState state, DtlsRecordLayer recordLayer, short alertDescription);
    internal virtual DtlsTransport ClientHandshake(ClientHandshakeState state, DtlsRecordLayer recordLayer);
    protected virtual Byte[] GenerateCertificateVerify(ClientHandshakeState state, DigitallySigned certificateVerify);
    protected virtual Byte[] GenerateClientHello(ClientHandshakeState state);
    protected virtual Byte[] GenerateClientKeyExchange(ClientHandshakeState state);
    protected virtual void InvalidateSession(ClientHandshakeState state);
    protected virtual void ProcessCertificateRequest(ClientHandshakeState state, Byte[] body);
    protected virtual void ProcessCertificateStatus(ClientHandshakeState state, Byte[] body);
    protected virtual Byte[] ProcessHelloVerifyRequest(ClientHandshakeState state, Byte[] body);
    protected virtual void ProcessNewSessionTicket(ClientHandshakeState state, Byte[] body);
    protected virtual void ProcessServerCertificate(ClientHandshakeState state, Byte[] body);
    protected virtual void ProcessServerHello(ClientHandshakeState state, Byte[] body);
    protected virtual void ProcessServerKeyExchange(ClientHandshakeState state, Byte[] body);
    protected virtual void ProcessServerSupplementalData(ClientHandshakeState state, Byte[] body);
    protected virtual void ReportServerVersion(ClientHandshakeState state, ProtocolVersion server_version);
    protected static Byte[] PatchClientHelloWithCookie(Byte[] clientHelloBody, Byte[] cookie);
}
internal class Org.BouncyCastle.Tls.DtlsEpoch : object {
    private DtlsReplayWindow m_replayWindow;
    private int m_epoch;
    private TlsCipher m_cipher;
    private long m_sequenceNumber;
    internal TlsCipher Cipher { get; }
    internal int Epoch { get; }
    internal DtlsReplayWindow ReplayWindow { get; }
    internal long SequenceNumber { get; internal set; }
    internal DtlsEpoch(int epoch, TlsCipher cipher);
    internal long AllocateSequenceNumber();
    internal TlsCipher get_Cipher();
    internal int get_Epoch();
    internal DtlsReplayWindow get_ReplayWindow();
    internal long get_SequenceNumber();
    internal void set_SequenceNumber(long value);
}
internal interface Org.BouncyCastle.Tls.DtlsHandshakeRetransmit {
    public abstract virtual void ReceivedHandshakeRecord(int epoch, Byte[] buf, int off, int len);
}
public abstract class Org.BouncyCastle.Tls.DtlsProtocol : object {
    internal virtual void ProcessFinished(Byte[] body, Byte[] expected_verify_data);
    internal static void ApplyMaxFragmentLengthExtension(DtlsRecordLayer recordLayer, short maxFragmentLength);
    internal static short EvaluateMaxFragmentLengthExtension(bool resumedSession, IDictionary clientExtensions, IDictionary serverExtensions, short alertDescription);
    internal static Byte[] GenerateCertificate(TlsContext context, Certificate certificate, Stream endPointHash);
    internal static Byte[] GenerateSupplementalData(IList supplementalData);
    internal static void SendCertificateMessage(TlsContext context, DtlsReliableHandshake handshake, Certificate certificate, Stream endPointHash);
    internal static int ValidateSelectedCipherSuite(int selectedCipherSuite, short alertDescription);
}
internal class Org.BouncyCastle.Tls.DtlsReassembler : object {
    private short m_msg_type;
    private Byte[] m_body;
    private IList m_missing;
    internal short MsgType { get; }
    internal DtlsReassembler(short msg_type, int length);
    internal short get_MsgType();
    internal Byte[] GetBodyIfComplete();
    internal void ContributeFragment(short msg_type, int length, Byte[] buf, int off, int fragment_offset, int fragment_length);
    internal void Reset();
}
internal class Org.BouncyCastle.Tls.DtlsRecordLayer : object {
    private static int RECORD_HEADER_LENGTH;
    private static int MAX_FRAGMENT_LENGTH;
    private static long TCP_MSL;
    private static long RETRANSMIT_TIMEOUT;
    private TlsContext m_context;
    private TlsPeer m_peer;
    private DatagramTransport m_transport;
    private ByteQueue m_recordQueue;
    private object m_writeLock;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_closed;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_failed;
    private ProtocolVersion modreq(System.Runtime.CompilerServices.IsVolatile) m_readVersion;
    private ProtocolVersion modreq(System.Runtime.CompilerServices.IsVolatile) m_writeVersion;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_inConnection;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_inHandshake;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_plaintextLimit;
    private DtlsEpoch m_currentEpoch;
    private DtlsEpoch m_pendingEpoch;
    private DtlsEpoch m_readEpoch;
    private DtlsEpoch m_writeEpoch;
    private DtlsHandshakeRetransmit m_retransmit;
    private DtlsEpoch m_retransmitEpoch;
    private Timeout m_retransmitTimeout;
    private TlsHeartbeat m_heartbeat;
    private bool m_heartBeatResponder;
    private HeartbeatMessage m_heartbeatInFlight;
    private Timeout m_heartbeatTimeout;
    private int m_heartbeatResendMillis;
    private Timeout m_heartbeatResendTimeout;
    internal bool IsClosed { get; }
    internal int ReadEpoch { get; }
    internal ProtocolVersion ReadVersion { get; internal set; }
    internal DtlsRecordLayer(TlsContext context, TlsPeer peer, DatagramTransport transport);
    internal static Byte[] ReceiveClientHelloRecord(Byte[] data, int dataOff, int dataLen);
    internal static void SendHelloVerifyRequestRecord(DatagramSender sender, long recordSeq, Byte[] message);
    private static void SendDatagram(DatagramSender sender, Byte[] buf, int off, int len);
    internal virtual bool get_IsClosed();
    internal virtual void ResetAfterHelloVerifyRequestServer(long recordSeq);
    internal virtual void SetPlaintextLimit(int plaintextLimit);
    internal virtual int get_ReadEpoch();
    internal virtual ProtocolVersion get_ReadVersion();
    internal virtual void set_ReadVersion(ProtocolVersion value);
    internal virtual void SetWriteVersion(ProtocolVersion writeVersion);
    internal virtual void InitPendingEpoch(TlsCipher pendingCipher);
    internal virtual void HandshakeSuccessful(DtlsHandshakeRetransmit retransmit);
    internal virtual void InitHeartbeat(TlsHeartbeat heartbeat, bool heartbeatResponder);
    internal virtual void ResetWriteEpoch();
    public virtual int GetReceiveLimit();
    public virtual int GetSendLimit();
    public virtual int Receive(Byte[] buf, int off, int len, int waitMillis);
    public virtual void Send(Byte[] buf, int off, int len);
    public virtual void Close();
    internal virtual void Fail(short alertDescription);
    internal virtual void Failed();
    internal virtual void Warn(short alertDescription, string message);
    private void CloseTransport();
    private void RaiseAlert(short alertLevel, short alertDescription, string message, Exception cause);
    private int ReceiveDatagram(Byte[] buf, int off, int len, int waitMillis);
    private int ProcessRecord(int received, Byte[] record, Byte[] buf, int off);
    private int ReceiveRecord(Byte[] buf, int off, int len, int waitMillis);
    private void ResetHeartbeat();
    private void SendHeartbeatMessage(HeartbeatMessage heartbeatMessage);
    private void SendRecord(short contentType, Byte[] buf, int off, int len);
    private static long GetMacSequenceNumber(int epoch, long sequence_number);
}
internal class Org.BouncyCastle.Tls.DtlsReliableHandshake : object {
    private static int MAX_RECEIVE_AHEAD;
    private static int MESSAGE_HEADER_LENGTH;
    internal static int INITIAL_RESEND_MILLIS;
    private static int MAX_RESEND_MILLIS;
    private DtlsRecordLayer m_recordLayer;
    private Timeout m_handshakeTimeout;
    private TlsHandshakeHash m_handshakeHash;
    private IDictionary m_currentInboundFlight;
    private IDictionary m_previousInboundFlight;
    private IList m_outboundFlight;
    private int m_resendMillis;
    private Timeout m_resendTimeout;
    private int m_next_send_seq;
    private int m_next_receive_seq;
    internal TlsHandshakeHash HandshakeHash { get; }
    internal DtlsReliableHandshake(TlsContext context, DtlsRecordLayer transport, int timeoutMillis, DtlsRequest request);
    internal static DtlsRequest ReadClientRequest(Byte[] data, int dataOff, int dataLen, Stream dtlsOutput);
    internal static void SendHelloVerifyRequest(DatagramSender sender, long recordSeq, Byte[] cookie);
    internal void ResetAfterHelloVerifyRequestClient();
    internal TlsHandshakeHash get_HandshakeHash();
    internal TlsHandshakeHash PrepareToFinish();
    internal void SendMessage(short msg_type, Byte[] body);
    internal Byte[] ReceiveMessageBody(short msg_type);
    internal Message ReceiveMessage();
    internal void Finish();
    internal static int BackOff(int timeoutMillis);
    private void CheckInboundFlight();
    private Message GetPendingMessage();
    private void PrepareInboundFlight(IDictionary nextFlight);
    private void ProcessRecord(int windowSize, int epoch, Byte[] buf, int off, int len);
    private void ResendOutboundFlight();
    private Message UpdateHandshakeMessagesDigest(Message message);
    private void WriteMessage(Message message);
    private void WriteHandshakeFragment(Message message, int fragment_offset, int fragment_length);
    private static bool CheckAll(IDictionary inboundFlight);
    private static void ResetAll(IDictionary inboundFlight);
}
internal class Org.BouncyCastle.Tls.DtlsReplayWindow : object {
    private static long ValidSeqMask;
    private static long WindowSize;
    private long m_latestConfirmedSeq;
    private ulong m_bitmap;
    internal bool ShouldDiscard(long seq);
    internal void ReportAuthenticated(long seq);
    internal void Reset(long seq);
}
public class Org.BouncyCastle.Tls.DtlsRequest : object {
    private long m_recordSeq;
    private Byte[] m_message;
    private ClientHello m_clientHello;
    internal ClientHello ClientHello { get; }
    internal Byte[] Message { get; }
    internal int MessageSeq { get; }
    internal long RecordSeq { get; }
    internal DtlsRequest(long recordSeq, Byte[] message, ClientHello clientHello);
    internal ClientHello get_ClientHello();
    internal Byte[] get_Message();
    internal int get_MessageSeq();
    internal long get_RecordSeq();
}
public class Org.BouncyCastle.Tls.DtlsServerProtocol : DtlsProtocol {
    protected bool m_verifyRequests;
    public bool VerifyRequests { get; public set; }
    public virtual bool get_VerifyRequests();
    public virtual void set_VerifyRequests(bool value);
    public virtual DtlsTransport Accept(TlsServer server, DatagramTransport transport);
    public virtual DtlsTransport Accept(TlsServer server, DatagramTransport transport, DtlsRequest request);
    internal virtual void AbortServerHandshake(ServerHandshakeState state, DtlsRecordLayer recordLayer, short alertDescription);
    internal virtual DtlsTransport ServerHandshake(ServerHandshakeState state, DtlsRecordLayer recordLayer, DtlsRequest request);
    protected virtual Byte[] GenerateCertificateRequest(ServerHandshakeState state, CertificateRequest certificateRequest);
    protected virtual Byte[] GenerateCertificateStatus(ServerHandshakeState state, CertificateStatus certificateStatus);
    protected virtual Byte[] GenerateNewSessionTicket(ServerHandshakeState state, NewSessionTicket newSessionTicket);
    internal virtual Byte[] GenerateServerHello(ServerHandshakeState state, DtlsRecordLayer recordLayer);
    protected virtual void InvalidateSession(ServerHandshakeState state);
    protected virtual void NotifyClientCertificate(ServerHandshakeState state, Certificate clientCertificate);
    protected virtual void ProcessClientCertificate(ServerHandshakeState state, Byte[] body);
    protected virtual void ProcessCertificateVerify(ServerHandshakeState state, Byte[] body, TlsHandshakeHash handshakeHash);
    protected virtual void ProcessClientHello(ServerHandshakeState state, Byte[] body);
    protected virtual void ProcessClientHello(ServerHandshakeState state, ClientHello clientHello);
    protected virtual void ProcessClientKeyExchange(ServerHandshakeState state, Byte[] body);
    protected virtual void ProcessClientSupplementalData(ServerHandshakeState state, Byte[] body);
    protected virtual bool ExpectCertificateVerifyMessage(ServerHandshakeState state);
}
public class Org.BouncyCastle.Tls.DtlsTransport : object {
    private DtlsRecordLayer m_recordLayer;
    internal DtlsTransport(DtlsRecordLayer recordLayer);
    public virtual int GetReceiveLimit();
    public virtual int GetSendLimit();
    public virtual int Receive(Byte[] buf, int off, int len, int waitMillis);
    public virtual void Send(Byte[] buf, int off, int len);
    public virtual void Close();
}
public class Org.BouncyCastle.Tls.DtlsVerifier : object {
    private TlsMac m_cookieMac;
    private TlsMacSink m_cookieMacSink;
    public DtlsVerifier(TlsCrypto crypto);
    private static TlsMac CreateCookieMac(TlsCrypto crypto);
    public virtual DtlsRequest VerifyRequest(Byte[] clientID, Byte[] data, int dataOff, int dataLen, DatagramSender sender);
}
public abstract class Org.BouncyCastle.Tls.ECCurveType : object {
    public static short explicit_prime;
    public static short explicit_char2;
    public static short named_curve;
}
public abstract class Org.BouncyCastle.Tls.ECPointFormat : object {
    public static short uncompressed;
    public static short ansiX962_compressed_prime;
    public static short ansiX962_compressed_char2;
}
public abstract class Org.BouncyCastle.Tls.EncryptionAlgorithm : object {
    public static int NULL;
    public static int RC4_40;
    public static int RC4_128;
    public static int RC2_CBC_40;
    public static int IDEA_CBC;
    public static int DES40_CBC;
    public static int DES_CBC;
    public static int cls_3DES_EDE_CBC;
    public static int AES_128_CBC;
    public static int AES_256_CBC;
    public static int AES_128_GCM;
    public static int AES_256_GCM;
    public static int CAMELLIA_128_CBC;
    public static int CAMELLIA_256_CBC;
    public static int SEED_CBC;
    public static int AES_128_CCM;
    public static int AES_128_CCM_8;
    public static int AES_256_CCM;
    public static int AES_256_CCM_8;
    public static int CAMELLIA_128_GCM;
    public static int CAMELLIA_256_GCM;
    public static int CHACHA20_POLY1305;
    public static int ARIA_128_CBC;
    public static int ARIA_256_CBC;
    public static int ARIA_128_GCM;
    public static int ARIA_256_GCM;
    public static int SM4_CCM;
    public static int SM4_GCM;
    public static int SM4_CBC;
}
public abstract class Org.BouncyCastle.Tls.ExporterLabel : object {
    public static string client_finished;
    public static string server_finished;
    public static string master_secret;
    public static string key_expansion;
    public static string client_EAP_encryption;
    public static string ttls_keying_material;
    public static string ttls_challenge;
    public static string dtls_srtp;
    public static string extended_master_secret;
    public static string token_binding;
}
public abstract class Org.BouncyCastle.Tls.ExtensionType : object {
    public static int server_name;
    public static int max_fragment_length;
    public static int client_certificate_url;
    public static int trusted_ca_keys;
    public static int truncated_hmac;
    public static int status_request;
    public static int user_mapping;
    public static int client_authz;
    public static int server_authz;
    public static int cert_type;
    public static int supported_groups;
    public static int ec_point_formats;
    public static int srp;
    public static int signature_algorithms;
    public static int use_srtp;
    public static int heartbeat;
    public static int application_layer_protocol_negotiation;
    public static int status_request_v2;
    public static int signed_certificate_timestamp;
    public static int client_certificate_type;
    public static int server_certificate_type;
    public static int padding;
    public static int encrypt_then_mac;
    public static int extended_master_secret;
    public static int token_binding;
    public static int cached_info;
    public static int record_size_limit;
    public static int session_ticket;
    public static int pre_shared_key;
    public static int early_data;
    public static int supported_versions;
    public static int cookie;
    public static int psk_key_exchange_modes;
    public static int certificate_authorities;
    public static int oid_filters;
    public static int post_handshake_auth;
    public static int signature_algorithms_cert;
    public static int key_share;
    public static int renegotiation_info;
    public static string GetName(int extensionType);
    public static string GetText(int extensionType);
    public static bool IsRecognized(int extensionType);
}
public class Org.BouncyCastle.Tls.HandshakeMessageInput : MemoryStream {
    private int m_offset;
    internal HandshakeMessageInput(Byte[] buf, int offset, int length);
    public void UpdateHash(TlsHash hash);
    internal void UpdateHashPrefix(TlsHash hash, int bindersSize);
    internal void UpdateHashSuffix(TlsHash hash, int bindersSize);
}
internal class Org.BouncyCastle.Tls.HandshakeMessageOutput : MemoryStream {
    internal HandshakeMessageOutput(short handshakeType);
    internal HandshakeMessageOutput(short handshakeType, int bodyLength);
    internal static int GetLength(int bodyLength);
    internal static void Send(TlsProtocol protocol, short handshakeType, Byte[] body);
    internal void Send(TlsProtocol protocol);
    internal void PrepareClientHello(TlsHandshakeHash handshakeHash, int bindersSize);
    internal void SendClientHello(TlsClientProtocol clientProtocol, TlsHandshakeHash handshakeHash, int bindersSize);
}
public abstract class Org.BouncyCastle.Tls.HandshakeType : object {
    public static short hello_request;
    public static short client_hello;
    public static short server_hello;
    public static short certificate;
    public static short server_key_exchange;
    public static short certificate_request;
    public static short server_hello_done;
    public static short certificate_verify;
    public static short client_key_exchange;
    public static short finished;
    public static short certificate_url;
    public static short certificate_status;
    public static short hello_verify_request;
    public static short supplemental_data;
    public static short new_session_ticket;
    public static short end_of_early_data;
    public static short hello_retry_request;
    public static short encrypted_extensions;
    public static short key_update;
    public static short message_hash;
    public static string GetName(short handshakeType);
    public static string GetText(short handshakeType);
    public static bool IsRecognized(short handshakeType);
}
public abstract class Org.BouncyCastle.Tls.HashAlgorithm : object {
    public static short none;
    public static short md5;
    public static short sha1;
    public static short sha224;
    public static short sha256;
    public static short sha384;
    public static short sha512;
    public static short Intrinsic;
    public static string GetName(short hashAlgorithm);
    public static int GetOutputSize(short hashAlgorithm);
    public static string GetText(short hashAlgorithm);
    public static bool IsPrivate(short hashAlgorithm);
    public static bool IsRecognized(short hashAlgorithm);
}
public class Org.BouncyCastle.Tls.HeartbeatExtension : object {
    private short m_mode;
    public short Mode { get; }
    public HeartbeatExtension(short mode);
    public short get_Mode();
    public void Encode(Stream output);
    public static HeartbeatExtension Parse(Stream input);
}
public class Org.BouncyCastle.Tls.HeartbeatMessage : object {
    private short m_type;
    private Byte[] m_payload;
    private Byte[] m_padding;
    public int PaddingLength { get; }
    public Byte[] Payload { get; }
    public short Type { get; }
    public HeartbeatMessage(short type, Byte[] payload, Byte[] padding);
    public static HeartbeatMessage Create(TlsContext context, short type, Byte[] payload);
    public static HeartbeatMessage Create(TlsContext context, short type, Byte[] payload, int paddingLength);
    public int get_PaddingLength();
    public Byte[] get_Payload();
    public short get_Type();
    public void Encode(Stream output);
    public static HeartbeatMessage Parse(Stream input);
    private static Byte[] GetPayload(Byte[] payloadBuffer, int payloadLength);
    private static Byte[] GetPadding(Byte[] payloadBuffer, int payloadLength);
}
public abstract class Org.BouncyCastle.Tls.HeartbeatMessageType : object {
    public static short heartbeat_request;
    public static short heartbeat_response;
    public static string GetName(short heartbeatMessageType);
    public static string GetText(short heartbeatMessageType);
    public static bool IsValid(short heartbeatMessageType);
}
public abstract class Org.BouncyCastle.Tls.HeartbeatMode : object {
    public static short peer_allowed_to_send;
    public static short peer_not_allowed_to_send;
    public static string GetName(short heartbeatMode);
    public static string GetText(short heartbeatMode);
    public static bool IsValid(short heartbeatMode);
}
public abstract class Org.BouncyCastle.Tls.IdentifierType : object {
    public static short pre_agreed;
    public static short key_sha1_hash;
    public static short x509_name;
    public static short cert_sha1_hash;
    public static string GetName(short identifierType);
    public static string GetText(short identifierType);
}
public abstract class Org.BouncyCastle.Tls.KeyExchangeAlgorithm : object {
    public static int NULL;
    public static int RSA;
    public static int RSA_EXPORT;
    public static int DHE_DSS;
    public static int DHE_DSS_EXPORT;
    public static int DHE_RSA;
    public static int DHE_RSA_EXPORT;
    public static int DH_DSS;
    public static int DH_DSS_EXPORT;
    public static int DH_RSA;
    public static int DH_RSA_EXPORT;
    public static int DH_anon;
    public static int DH_anon_EXPORT;
    public static int PSK;
    public static int DHE_PSK;
    public static int RSA_PSK;
    public static int ECDH_ECDSA;
    public static int ECDHE_ECDSA;
    public static int ECDH_RSA;
    public static int ECDHE_RSA;
    public static int ECDH_anon;
    public static int SRP;
    public static int SRP_DSS;
    public static int SRP_RSA;
    public static int ECDHE_PSK;
    public static int SM2;
}
public class Org.BouncyCastle.Tls.KeyShareEntry : object {
    private int m_namedGroup;
    private Byte[] m_keyExchange;
    public int NamedGroup { get; }
    public Byte[] KeyExchange { get; }
    public KeyShareEntry(int namedGroup, Byte[] keyExchange);
    private static bool CheckKeyExchangeLength(int length);
    public int get_NamedGroup();
    public Byte[] get_KeyExchange();
    public void Encode(Stream output);
    public static KeyShareEntry Parse(Stream input);
}
public abstract class Org.BouncyCastle.Tls.KeyUpdateRequest : object {
    public static short update_not_requested;
    public static short update_requested;
    public static string GetName(short keyUpdateRequest);
    public static string GetText(short keyUpdateRequest);
    public static bool IsValid(short keyUpdateRequest);
}
public abstract class Org.BouncyCastle.Tls.MacAlgorithm : object {
    public static int cls_null;
    public static int md5;
    public static int sha;
    public static int hmac_md5;
    public static int hmac_sha1;
    public static int hmac_sha256;
    public static int hmac_sha384;
    public static int hmac_sha512;
    public static string GetName(int macAlgorithm);
    public static string GetText(int macAlgorithm);
    public static bool IsHmac(int macAlgorithm);
}
public abstract class Org.BouncyCastle.Tls.MaxFragmentLength : object {
    public static short pow2_9;
    public static short pow2_10;
    public static short pow2_11;
    public static short pow2_12;
    public static bool IsValid(short maxFragmentLength);
}
public abstract class Org.BouncyCastle.Tls.NamedGroup : object {
    public static int sect163k1;
    public static int sect163r1;
    public static int sect163r2;
    public static int sect193r1;
    public static int sect193r2;
    public static int sect233k1;
    public static int sect233r1;
    public static int sect239k1;
    public static int sect283k1;
    public static int sect283r1;
    public static int sect409k1;
    public static int sect409r1;
    public static int sect571k1;
    public static int sect571r1;
    public static int secp160k1;
    public static int secp160r1;
    public static int secp160r2;
    public static int secp192k1;
    public static int secp192r1;
    public static int secp224k1;
    public static int secp224r1;
    public static int secp256k1;
    public static int secp256r1;
    public static int secp384r1;
    public static int secp521r1;
    public static int brainpoolP256r1;
    public static int brainpoolP384r1;
    public static int brainpoolP512r1;
    public static int x25519;
    public static int x448;
    public static int brainpoolP256r1tls13;
    public static int brainpoolP384r1tls13;
    public static int brainpoolP512r1tls13;
    public static int GC256A;
    public static int GC256B;
    public static int GC256C;
    public static int GC256D;
    public static int GC512A;
    public static int GC512B;
    public static int GC512C;
    public static int curveSM2;
    public static int ffdhe2048;
    public static int ffdhe3072;
    public static int ffdhe4096;
    public static int ffdhe6144;
    public static int ffdhe8192;
    public static int arbitrary_explicit_prime_curves;
    public static int arbitrary_explicit_char2_curves;
    private static String[] CurveNames;
    private static String[] FiniteFieldNames;
    private static NamedGroup();
    public static bool CanBeNegotiated(int namedGroup, ProtocolVersion version);
    public static int GetCurveBits(int namedGroup);
    public static string GetCurveName(int namedGroup);
    public static int GetFiniteFieldBits(int namedGroup);
    public static string GetFiniteFieldName(int namedGroup);
    public static int GetMaximumChar2CurveBits();
    public static int GetMaximumCurveBits();
    public static int GetMaximumFiniteFieldBits();
    public static int GetMaximumPrimeCurveBits();
    public static string GetName(int namedGroup);
    public static string GetStandardName(int namedGroup);
    public static string GetText(int namedGroup);
    public static bool IsChar2Curve(int namedGroup);
    public static bool IsPrimeCurve(int namedGroup);
    public static bool IsPrivate(int namedGroup);
    public static bool IsValid(int namedGroup);
    public static bool RefersToAnECDHCurve(int namedGroup);
    public static bool RefersToAnECDSACurve(int namedGroup);
    public static bool RefersToAnXDHCurve(int namedGroup);
    public static bool RefersToASpecificCurve(int namedGroup);
    public static bool RefersToASpecificFiniteField(int namedGroup);
    public static bool RefersToASpecificGroup(int namedGroup);
}
public abstract class Org.BouncyCastle.Tls.NamedGroupRole : object {
    public static int dh;
    public static int ecdh;
    public static int ecdsa;
}
public abstract class Org.BouncyCastle.Tls.NameType : object {
    public static short host_name;
    public static string GetName(short nameType);
    public static string GetText(short nameType);
    public static bool IsRecognized(short nameType);
    public static bool IsValid(short nameType);
}
public class Org.BouncyCastle.Tls.NewSessionTicket : object {
    private long m_ticketLifetimeHint;
    private Byte[] m_ticket;
    public long TicketLifetimeHint { get; }
    public Byte[] Ticket { get; }
    public NewSessionTicket(long ticketLifetimeHint, Byte[] ticket);
    public long get_TicketLifetimeHint();
    public Byte[] get_Ticket();
    public void Encode(Stream output);
    public static NewSessionTicket Parse(Stream input);
}
public class Org.BouncyCastle.Tls.OcspStatusRequest : object {
    private IList m_responderIDList;
    private X509Extensions m_requestExtensions;
    public IList ResponderIDList { get; }
    public X509Extensions RequestExtensions { get; }
    public OcspStatusRequest(IList responderIDList, X509Extensions requestExtensions);
    public IList get_ResponderIDList();
    public X509Extensions get_RequestExtensions();
    public void Encode(Stream output);
    public static OcspStatusRequest Parse(Stream input);
}
public class Org.BouncyCastle.Tls.OfferedPsks : object {
    private IList m_identities;
    private IList m_binders;
    private int m_bindersSize;
    public IList Binders { get; }
    public int BindersSize { get; }
    public IList Identities { get; }
    public OfferedPsks(IList identities);
    private OfferedPsks(IList identities, IList binders, int bindersSize);
    public IList get_Binders();
    public int get_BindersSize();
    public IList get_Identities();
    public int GetIndexOfIdentity(PskIdentity pskIdentity);
    public void Encode(Stream output);
    internal static void EncodeBinders(Stream output, TlsCrypto crypto, TlsHandshakeHash handshakeHash, BindersConfig bindersConfig);
    internal static int GetBindersSize(TlsPsk[] psks);
    public static OfferedPsks Parse(Stream input);
}
public abstract class Org.BouncyCastle.Tls.PrfAlgorithm : object {
    public static int ssl_prf_legacy;
    public static int tls_prf_legacy;
    public static int tls_prf_sha256;
    public static int tls_prf_sha384;
    public static int tls13_hkdf_sha256;
    public static int tls13_hkdf_sha384;
    public static int tls13_hkdf_sm3;
    public static string GetName(int prfAlgorithm);
    public static string GetText(int prfAlgorithm);
}
public class Org.BouncyCastle.Tls.ProtocolName : object {
    public static ProtocolName Http_1_1;
    public static ProtocolName Spdy_1;
    public static ProtocolName Spdy_2;
    public static ProtocolName Spdy_3;
    public static ProtocolName Stun_Turn;
    public static ProtocolName Stun_Nat_Discovery;
    public static ProtocolName Http_2_Tls;
    public static ProtocolName Http_2_Tcp;
    public static ProtocolName WebRtc;
    public static ProtocolName WebRtc_Confidential;
    public static ProtocolName Ftp;
    public static ProtocolName Imap;
    public static ProtocolName Pop3;
    public static ProtocolName ManageSieve;
    public static ProtocolName Coap;
    public static ProtocolName Xmpp_Client;
    public static ProtocolName Xmpp_Server;
    private Byte[] m_bytes;
    private ProtocolName(Byte[] bytes);
    private static ProtocolName();
    public static ProtocolName AsRawBytes(Byte[] bytes);
    public static ProtocolName AsUtf8Encoding(string name);
    public Byte[] GetBytes();
    public string GetUtf8Decoding();
    public void Encode(Stream output);
    public static ProtocolName Parse(Stream input);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Tls.ProtocolVersion : object {
    public static ProtocolVersion SSLv3;
    public static ProtocolVersion TLSv10;
    public static ProtocolVersion TLSv11;
    public static ProtocolVersion TLSv12;
    public static ProtocolVersion TLSv13;
    public static ProtocolVersion DTLSv10;
    public static ProtocolVersion DTLSv12;
    internal static ProtocolVersion CLIENT_EARLIEST_SUPPORTED_DTLS;
    internal static ProtocolVersion CLIENT_EARLIEST_SUPPORTED_TLS;
    internal static ProtocolVersion CLIENT_LATEST_SUPPORTED_DTLS;
    internal static ProtocolVersion CLIENT_LATEST_SUPPORTED_TLS;
    internal static ProtocolVersion SERVER_EARLIEST_SUPPORTED_DTLS;
    internal static ProtocolVersion SERVER_EARLIEST_SUPPORTED_TLS;
    internal static ProtocolVersion SERVER_LATEST_SUPPORTED_DTLS;
    internal static ProtocolVersion SERVER_LATEST_SUPPORTED_TLS;
    private int version;
    private string name;
    public int FullVersion { get; }
    public int MajorVersion { get; }
    public int MinorVersion { get; }
    public string Name { get; }
    public bool IsDtls { get; }
    public bool IsSsl { get; }
    public bool IsTls { get; }
    private ProtocolVersion(int v, string name);
    private static ProtocolVersion();
    public static bool Contains(ProtocolVersion[] versions, ProtocolVersion version);
    public static ProtocolVersion GetEarliestDtls(ProtocolVersion[] versions);
    public static ProtocolVersion GetEarliestTls(ProtocolVersion[] versions);
    public static ProtocolVersion GetLatestDtls(ProtocolVersion[] versions);
    public static ProtocolVersion GetLatestTls(ProtocolVersion[] versions);
    internal static bool IsSupportedDtlsVersionClient(ProtocolVersion version);
    internal static bool IsSupportedDtlsVersionServer(ProtocolVersion version);
    internal static bool IsSupportedTlsVersionClient(ProtocolVersion version);
    internal static bool IsSupportedTlsVersionServer(ProtocolVersion version);
    public ProtocolVersion[] DownTo(ProtocolVersion min);
    public int get_FullVersion();
    public int get_MajorVersion();
    public int get_MinorVersion();
    public string get_Name();
    public bool get_IsDtls();
    public bool get_IsSsl();
    public bool get_IsTls();
    public ProtocolVersion GetEquivalentTlsVersion();
    public ProtocolVersion GetNextVersion();
    public ProtocolVersion GetPreviousVersion();
    public bool IsEarlierVersionOf(ProtocolVersion version);
    public bool IsEqualOrEarlierVersionOf(ProtocolVersion version);
    public bool IsEqualOrLaterVersionOf(ProtocolVersion version);
    public bool IsLaterVersionOf(ProtocolVersion version);
    public virtual bool Equals(object other);
    public bool Equals(ProtocolVersion other);
    public virtual int GetHashCode();
    public static ProtocolVersion Get(int major, int minor);
    public ProtocolVersion[] Only();
    public virtual string ToString();
    private static void CheckUint8(int versionOctet);
    private static ProtocolVersion GetUnknownVersion(int major, int minor, string prefix);
}
public class Org.BouncyCastle.Tls.PskIdentity : object {
    private Byte[] m_identity;
    private long m_obfuscatedTicketAge;
    public Byte[] Identity { get; }
    public long ObfuscatedTicketAge { get; }
    public PskIdentity(Byte[] identity, long obfuscatedTicketAge);
    public int GetEncodedLength();
    public Byte[] get_Identity();
    public long get_ObfuscatedTicketAge();
    public void Encode(Stream output);
    public static PskIdentity Parse(Stream input);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class Org.BouncyCastle.Tls.PskKeyExchangeMode : object {
    public static short psk_ke;
    public static short psk_dhe_ke;
    public static string GetName(short pskKeyExchangeMode);
    public static string GetText(short pskKeyExchangeMode);
}
public class Org.BouncyCastle.Tls.PskTlsClient : AbstractTlsClient {
    private static Int32[] DefaultCipherSuites;
    protected TlsPskIdentity m_pskIdentity;
    public PskTlsClient(TlsCrypto crypto, Byte[] identity, Byte[] psk);
    public PskTlsClient(TlsCrypto crypto, TlsPskIdentity pskIdentity);
    private static PskTlsClient();
    protected virtual ProtocolVersion[] GetSupportedVersions();
    protected virtual Int32[] GetSupportedCipherSuites();
    public virtual TlsPskIdentity GetPskIdentity();
    public virtual TlsAuthentication GetAuthentication();
}
public class Org.BouncyCastle.Tls.PskTlsServer : AbstractTlsServer {
    private static Int32[] DefaultCipherSuites;
    protected TlsPskIdentityManager m_pskIdentityManager;
    public PskTlsServer(TlsCrypto crypto, TlsPskIdentityManager pskIdentityManager);
    private static PskTlsServer();
    protected virtual TlsCredentialedDecryptor GetRsaEncryptionCredentials();
    protected virtual ProtocolVersion[] GetSupportedVersions();
    protected virtual Int32[] GetSupportedCipherSuites();
    public virtual TlsCredentials GetCredentials();
    public virtual TlsPskIdentityManager GetPskIdentityManager();
}
public abstract class Org.BouncyCastle.Tls.RecordFormat : object {
    public static int TypeOffset;
    public static int VersionOffset;
    public static int LengthOffset;
    public static int FragmentOffset;
}
public class Org.BouncyCastle.Tls.RecordPreview : object {
    private int recordSize;
    private int contentLimit;
    public int ContentLimit { get; }
    public int RecordSize { get; }
    internal RecordPreview(int recordSize, int contentLimit);
    internal static RecordPreview CombineAppData(RecordPreview a, RecordPreview b);
    internal static RecordPreview ExtendRecordSize(RecordPreview a, int recordSize);
    public int get_ContentLimit();
    public int get_RecordSize();
}
internal class Org.BouncyCastle.Tls.RecordStream : object {
    private static int DefaultPlaintextLimit;
    private Record m_inputRecord;
    private SequenceNumber m_readSeqNo;
    private SequenceNumber m_writeSeqNo;
    private TlsProtocol m_handler;
    private Stream m_input;
    private Stream m_output;
    private TlsCipher m_pendingCipher;
    private TlsCipher m_readCipher;
    private TlsCipher m_readCipherDeferred;
    private TlsCipher m_writeCipher;
    private ProtocolVersion m_writeVersion;
    private int m_plaintextLimit;
    private int m_ciphertextLimit;
    private bool m_ignoreChangeCipherSpec;
    internal int PlaintextLimit { get; }
    internal RecordStream(TlsProtocol handler, Stream input, Stream output);
    internal int get_PlaintextLimit();
    internal void SetPlaintextLimit(int plaintextLimit);
    internal void SetWriteVersion(ProtocolVersion writeVersion);
    internal void SetIgnoreChangeCipherSpec(bool ignoreChangeCipherSpec);
    internal void SetPendingCipher(TlsCipher tlsCipher);
    internal void NotifyChangeCipherSpecReceived();
    internal void EnablePendingCipherRead(bool deferred);
    internal void EnablePendingCipherWrite();
    internal void FinaliseHandshake();
    internal bool NeedsKeyUpdate();
    internal void NotifyKeyUpdateReceived();
    internal void NotifyKeyUpdateSent();
    internal RecordPreview PreviewRecordHeader(Byte[] recordHeader);
    internal RecordPreview PreviewOutputRecord(int contentLength);
    internal int PreviewOutputRecordSize(int contentLength);
    internal bool ReadFullRecord(Byte[] input, int inputOff, int inputLen);
    internal bool ReadRecord();
    internal TlsDecodeResult DecodeAndVerify(short recordType, ProtocolVersion recordVersion, Byte[] ciphertext, int off, int len);
    internal void WriteRecord(short contentType, Byte[] plaintext, int plaintextOffset, int plaintextLength);
    internal void Close();
    private void CheckChangeCipherSpec(Byte[] buf, int off, int len);
    private short CheckRecordType(Byte[] buf, int off);
    private static void CheckLength(int length, int limit, short alertDescription);
}
public class Org.BouncyCastle.Tls.SecurityParameters : object {
    internal int m_entity;
    internal bool m_secureRenegotiation;
    internal int m_cipherSuite;
    internal short m_maxFragmentLength;
    internal int m_prfAlgorithm;
    internal int m_prfCryptoHashAlgorithm;
    internal int m_prfHashLength;
    internal int m_verifyDataLength;
    internal TlsSecret m_baseKeyClient;
    internal TlsSecret m_baseKeyServer;
    internal TlsSecret m_earlyExporterMasterSecret;
    internal TlsSecret m_earlySecret;
    internal TlsSecret m_exporterMasterSecret;
    internal TlsSecret m_handshakeSecret;
    internal TlsSecret m_masterSecret;
    internal TlsSecret m_trafficSecretClient;
    internal TlsSecret m_trafficSecretServer;
    internal Byte[] m_clientRandom;
    internal Byte[] m_serverRandom;
    internal Byte[] m_sessionHash;
    internal Byte[] m_sessionID;
    internal Byte[] m_pskIdentity;
    internal Byte[] m_srpIdentity;
    internal Byte[] m_tlsServerEndPoint;
    internal Byte[] m_tlsUnique;
    internal bool m_encryptThenMac;
    internal bool m_extendedMasterSecret;
    internal bool m_extendedPadding;
    internal bool m_truncatedHmac;
    internal ProtocolName m_applicationProtocol;
    internal bool m_applicationProtocolSet;
    internal Int16[] m_clientCertTypes;
    internal IList m_clientServerNames;
    internal IList m_clientSigAlgs;
    internal IList m_clientSigAlgsCert;
    internal Int32[] m_clientSupportedGroups;
    internal IList m_serverSigAlgs;
    internal IList m_serverSigAlgsCert;
    internal Int32[] m_serverSupportedGroups;
    internal int m_keyExchangeAlgorithm;
    internal Certificate m_localCertificate;
    internal Certificate m_peerCertificate;
    internal ProtocolVersion m_negotiatedVersion;
    internal int m_statusRequestVersion;
    internal Byte[] m_localVerifyData;
    internal Byte[] m_peerVerifyData;
    public ProtocolName ApplicationProtocol { get; }
    public TlsSecret BaseKeyClient { get; }
    public TlsSecret BaseKeyServer { get; }
    public int CipherSuite { get; }
    public Int16[] ClientCertTypes { get; }
    public Byte[] ClientRandom { get; }
    public IList ClientServerNames { get; }
    public IList ClientSigAlgs { get; }
    public IList ClientSigAlgsCert { get; }
    public Int32[] ClientSupportedGroups { get; }
    public TlsSecret EarlyExporterMasterSecret { get; }
    public TlsSecret EarlySecret { get; }
    public TlsSecret ExporterMasterSecret { get; }
    public int Entity { get; }
    public TlsSecret HandshakeSecret { get; }
    public bool IsApplicationProtocolSet { get; }
    public bool IsEncryptThenMac { get; }
    public bool IsExtendedMasterSecret { get; }
    public bool IsExtendedPadding { get; }
    public bool IsSecureRenegotiation { get; }
    public bool IsTruncatedHmac { get; }
    public int KeyExchangeAlgorithm { get; }
    public Certificate LocalCertificate { get; }
    public Byte[] LocalVerifyData { get; }
    public TlsSecret MasterSecret { get; }
    public short MaxFragmentLength { get; }
    public ProtocolVersion NegotiatedVersion { get; }
    public Certificate PeerCertificate { get; }
    public Byte[] PeerVerifyData { get; }
    public int PrfAlgorithm { get; }
    public int PrfCryptoHashAlgorithm { get; }
    public int PrfHashLength { get; }
    public Byte[] PskIdentity { get; }
    public Byte[] ServerRandom { get; }
    public IList ServerSigAlgs { get; }
    public IList ServerSigAlgsCert { get; }
    public Int32[] ServerSupportedGroups { get; }
    public Byte[] SessionHash { get; }
    public Byte[] SessionID { get; }
    public Byte[] SrpIdentity { get; }
    public int StatusRequestVersion { get; }
    public Byte[] TlsServerEndPoint { get; }
    public Byte[] TlsUnique { get; }
    public TlsSecret TrafficSecretClient { get; }
    public TlsSecret TrafficSecretServer { get; }
    public int VerifyDataLength { get; }
    internal void Clear();
    public ProtocolName get_ApplicationProtocol();
    public TlsSecret get_BaseKeyClient();
    public TlsSecret get_BaseKeyServer();
    public int get_CipherSuite();
    public Int16[] get_ClientCertTypes();
    public Byte[] get_ClientRandom();
    public IList get_ClientServerNames();
    public IList get_ClientSigAlgs();
    public IList get_ClientSigAlgsCert();
    public Int32[] get_ClientSupportedGroups();
    public TlsSecret get_EarlyExporterMasterSecret();
    public TlsSecret get_EarlySecret();
    public TlsSecret get_ExporterMasterSecret();
    public int get_Entity();
    public TlsSecret get_HandshakeSecret();
    public bool get_IsApplicationProtocolSet();
    public bool get_IsEncryptThenMac();
    public bool get_IsExtendedMasterSecret();
    public bool get_IsExtendedPadding();
    public bool get_IsSecureRenegotiation();
    public bool get_IsTruncatedHmac();
    public int get_KeyExchangeAlgorithm();
    public Certificate get_LocalCertificate();
    public Byte[] get_LocalVerifyData();
    public TlsSecret get_MasterSecret();
    public short get_MaxFragmentLength();
    public ProtocolVersion get_NegotiatedVersion();
    public Certificate get_PeerCertificate();
    public Byte[] get_PeerVerifyData();
    public int get_PrfAlgorithm();
    public int get_PrfCryptoHashAlgorithm();
    public int get_PrfHashLength();
    public Byte[] get_PskIdentity();
    public Byte[] get_ServerRandom();
    public IList get_ServerSigAlgs();
    public IList get_ServerSigAlgsCert();
    public Int32[] get_ServerSupportedGroups();
    public Byte[] get_SessionHash();
    public Byte[] get_SessionID();
    public Byte[] get_SrpIdentity();
    public int get_StatusRequestVersion();
    public Byte[] get_TlsServerEndPoint();
    public Byte[] get_TlsUnique();
    public TlsSecret get_TrafficSecretClient();
    public TlsSecret get_TrafficSecretServer();
    public int get_VerifyDataLength();
    private static TlsSecret ClearSecret(TlsSecret secret);
}
public class Org.BouncyCastle.Tls.ServerHello : object {
    private static Byte[] HelloRetryRequestMagic;
    private ProtocolVersion m_version;
    private Byte[] m_random;
    private Byte[] m_sessionID;
    private int m_cipherSuite;
    private IDictionary m_extensions;
    public int CipherSuite { get; }
    public IDictionary Extensions { get; }
    public Byte[] Random { get; }
    public Byte[] SessionID { get; }
    public ProtocolVersion Version { get; }
    public ServerHello(Byte[] sessionID, int cipherSuite, IDictionary extensions);
    public ServerHello(ProtocolVersion version, Byte[] random, Byte[] sessionID, int cipherSuite, IDictionary extensions);
    private static ServerHello();
    public int get_CipherSuite();
    public IDictionary get_Extensions();
    public Byte[] get_Random();
    public Byte[] get_SessionID();
    public ProtocolVersion get_Version();
    public bool IsHelloRetryRequest();
    public void Encode(TlsContext context, Stream output);
    public static ServerHello Parse(MemoryStream input);
}
public class Org.BouncyCastle.Tls.ServerName : object {
    private short nameType;
    private Byte[] nameData;
    public Byte[] NameData { get; }
    public short NameType { get; }
    public ServerName(short nameType, Byte[] nameData);
    public Byte[] get_NameData();
    public short get_NameType();
    public void Encode(Stream output);
    public static ServerName Parse(Stream input);
}
public class Org.BouncyCastle.Tls.ServerNameList : object {
    private IList m_serverNameList;
    public IList ServerNames { get; }
    public ServerNameList(IList serverNameList);
    public IList get_ServerNames();
    public void Encode(Stream output);
    public static ServerNameList Parse(Stream input);
    private static Int16[] CheckNameType(Int16[] nameTypesSeen, short nameType);
}
public abstract class Org.BouncyCastle.Tls.ServerOnlyTlsAuthentication : object {
    public abstract virtual void NotifyServerCertificate(TlsServerCertificate serverCertificate);
    public sealed virtual TlsCredentials GetClientCredentials(CertificateRequest certificateRequest);
}
public class Org.BouncyCastle.Tls.ServerSrpParams : object {
    private BigInteger m_N;
    private BigInteger m_g;
    private BigInteger m_B;
    private Byte[] m_s;
    public BigInteger B { get; }
    public BigInteger G { get; }
    public BigInteger N { get; }
    public Byte[] S { get; }
    public ServerSrpParams(BigInteger N, BigInteger g, Byte[] s, BigInteger B);
    public BigInteger get_B();
    public BigInteger get_G();
    public BigInteger get_N();
    public Byte[] get_S();
    public void Encode(Stream output);
    public static ServerSrpParams Parse(Stream input);
}
public class Org.BouncyCastle.Tls.SessionParameters : object {
    private int m_cipherSuite;
    private Certificate m_localCertificate;
    private TlsSecret m_masterSecret;
    private ProtocolVersion m_negotiatedVersion;
    private Certificate m_peerCertificate;
    private Byte[] m_pskIdentity;
    private Byte[] m_srpIdentity;
    private Byte[] m_encodedServerExtensions;
    private bool m_extendedMasterSecret;
    public int CipherSuite { get; }
    public bool IsExtendedMasterSecret { get; }
    public Certificate LocalCertificate { get; }
    public TlsSecret MasterSecret { get; }
    public ProtocolVersion NegotiatedVersion { get; }
    public Certificate PeerCertificate { get; }
    public Byte[] PskIdentity { get; }
    public Byte[] SrpIdentity { get; }
    private SessionParameters(int cipherSuite, Certificate localCertificate, TlsSecret masterSecret, ProtocolVersion negotiatedVersion, Certificate peerCertificate, Byte[] pskIdentity, Byte[] srpIdentity, Byte[] encodedServerExtensions, bool extendedMasterSecret);
    public int get_CipherSuite();
    public void Clear();
    public SessionParameters Copy();
    public bool get_IsExtendedMasterSecret();
    public Certificate get_LocalCertificate();
    public TlsSecret get_MasterSecret();
    public ProtocolVersion get_NegotiatedVersion();
    public Certificate get_PeerCertificate();
    public Byte[] get_PskIdentity();
    public IDictionary ReadServerExtensions();
    public Byte[] get_SrpIdentity();
}
public class Org.BouncyCastle.Tls.SignatureAlgorithm : object {
    public static short anonymous;
    public static short rsa;
    public static short dsa;
    public static short ecdsa;
    public static short ed25519;
    public static short ed448;
    public static short rsa_pss_rsae_sha256;
    public static short rsa_pss_rsae_sha384;
    public static short rsa_pss_rsae_sha512;
    public static short rsa_pss_pss_sha256;
    public static short rsa_pss_pss_sha384;
    public static short rsa_pss_pss_sha512;
    public static short ecdsa_brainpoolP256r1tls13_sha256;
    public static short ecdsa_brainpoolP384r1tls13_sha384;
    public static short ecdsa_brainpoolP512r1tls13_sha512;
    public static short gostr34102012_256;
    public static short gostr34102012_512;
    public static short GetClientCertificateType(short signatureAlgorithm);
    public static string GetName(short signatureAlgorithm);
    public static string GetText(short signatureAlgorithm);
}
public class Org.BouncyCastle.Tls.SignatureAndHashAlgorithm : object {
    public static SignatureAndHashAlgorithm ecdsa_brainpoolP256r1tls13_sha256;
    public static SignatureAndHashAlgorithm ecdsa_brainpoolP384r1tls13_sha384;
    public static SignatureAndHashAlgorithm ecdsa_brainpoolP512r1tls13_sha512;
    public static SignatureAndHashAlgorithm ed25519;
    public static SignatureAndHashAlgorithm ed448;
    public static SignatureAndHashAlgorithm gostr34102012_256;
    public static SignatureAndHashAlgorithm gostr34102012_512;
    public static SignatureAndHashAlgorithm rsa_pss_rsae_sha256;
    public static SignatureAndHashAlgorithm rsa_pss_rsae_sha384;
    public static SignatureAndHashAlgorithm rsa_pss_rsae_sha512;
    public static SignatureAndHashAlgorithm rsa_pss_pss_sha256;
    public static SignatureAndHashAlgorithm rsa_pss_pss_sha384;
    public static SignatureAndHashAlgorithm rsa_pss_pss_sha512;
    private short m_hash;
    private short m_signature;
    public short Hash { get; }
    public short Signature { get; }
    public SignatureAndHashAlgorithm(short hash, short signature);
    private static SignatureAndHashAlgorithm();
    public static SignatureAndHashAlgorithm GetInstance(short hashAlgorithm, short signatureAlgorithm);
    private static SignatureAndHashAlgorithm GetInstanceIntrinsic(short signatureAlgorithm);
    private static SignatureAndHashAlgorithm Create(int signatureScheme);
    private static SignatureAndHashAlgorithm Create(short hashAlgorithm, short signatureAlgorithm);
    public short get_Hash();
    public short get_Signature();
    public void Encode(Stream output);
    public static SignatureAndHashAlgorithm Parse(Stream input);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public abstract class Org.BouncyCastle.Tls.SignatureScheme : object {
    public static int rsa_pkcs1_sha1;
    public static int ecdsa_sha1;
    public static int rsa_pkcs1_sha256;
    public static int rsa_pkcs1_sha384;
    public static int rsa_pkcs1_sha512;
    public static int ecdsa_secp256r1_sha256;
    public static int ecdsa_secp384r1_sha384;
    public static int ecdsa_secp521r1_sha512;
    public static int rsa_pss_rsae_sha256;
    public static int rsa_pss_rsae_sha384;
    public static int rsa_pss_rsae_sha512;
    public static int ed25519;
    public static int ed448;
    public static int rsa_pss_pss_sha256;
    public static int rsa_pss_pss_sha384;
    public static int rsa_pss_pss_sha512;
    public static int ecdsa_brainpoolP256r1tls13_sha256;
    public static int ecdsa_brainpoolP384r1tls13_sha384;
    public static int ecdsa_brainpoolP512r1tls13_sha512;
    public static int sm2sig_sm3;
    public static int From(SignatureAndHashAlgorithm sigAndHashAlg);
    public static int From(short hashAlgorithm, short signatureAlgorithm);
    public static int GetCryptoHashAlgorithm(int signatureScheme);
    public static string GetName(int signatureScheme);
    public static int GetNamedGroup(int signatureScheme);
    public static short GetHashAlgorithm(int signatureScheme);
    public static short GetSignatureAlgorithm(int signatureScheme);
    public static SignatureAndHashAlgorithm GetSignatureAndHashAlgorithm(int signatureScheme);
    public static string GetText(int signatureScheme);
    public static bool IsPrivate(int signatureScheme);
    public static bool IsECDsa(int signatureScheme);
    public static bool IsRsaPss(int signatureScheme);
}
public class Org.BouncyCastle.Tls.SimulatedTlsSrpIdentityManager : object {
    private static Byte[] PrefixPassword;
    private static Byte[] PrefixSalt;
    protected Srp6Group m_group;
    protected TlsSrp6VerifierGenerator m_verifierGenerator;
    protected TlsMac m_mac;
    public SimulatedTlsSrpIdentityManager(Srp6Group group, TlsSrp6VerifierGenerator verifierGenerator, TlsMac mac);
    private static SimulatedTlsSrpIdentityManager();
    public static SimulatedTlsSrpIdentityManager GetRfc5054Default(TlsCrypto crypto, Srp6Group group, Byte[] seedKey);
    public virtual TlsSrpLoginParameters GetLoginParameters(Byte[] identity);
}
public class Org.BouncyCastle.Tls.SrpTlsClient : AbstractTlsClient {
    private static Int32[] DefaultCipherSuites;
    protected TlsSrpIdentity m_srpIdentity;
    protected bool RequireSrpServerExtension { get; }
    public SrpTlsClient(TlsCrypto crypto, Byte[] identity, Byte[] password);
    public SrpTlsClient(TlsCrypto crypto, TlsSrpIdentity srpIdentity);
    private static SrpTlsClient();
    protected virtual Int32[] GetSupportedCipherSuites();
    protected virtual ProtocolVersion[] GetSupportedVersions();
    protected virtual bool get_RequireSrpServerExtension();
    public virtual IDictionary GetClientExtensions();
    public virtual void ProcessServerExtensions(IDictionary serverExtensions);
    public virtual TlsSrpIdentity GetSrpIdentity();
    public virtual TlsAuthentication GetAuthentication();
}
public class Org.BouncyCastle.Tls.SrpTlsServer : AbstractTlsServer {
    private static Int32[] DefaultCipherSuites;
    protected TlsSrpIdentityManager m_srpIdentityManager;
    protected Byte[] m_srpIdentity;
    protected TlsSrpLoginParameters m_srpLoginParameters;
    public SrpTlsServer(TlsCrypto crypto, TlsSrpIdentityManager srpIdentityManager);
    private static SrpTlsServer();
    protected virtual TlsCredentialedSigner GetDsaSignerCredentials();
    protected virtual TlsCredentialedSigner GetRsaSignerCredentials();
    protected virtual ProtocolVersion[] GetSupportedVersions();
    protected virtual Int32[] GetSupportedCipherSuites();
    public virtual void ProcessClientExtensions(IDictionary clientExtensions);
    public virtual int GetSelectedCipherSuite();
    public virtual TlsCredentials GetCredentials();
    public virtual TlsSrpLoginParameters GetSrpLoginParameters();
}
public abstract class Org.BouncyCastle.Tls.SrtpProtectionProfile : object {
    public static int SRTP_AES128_CM_HMAC_SHA1_80;
    public static int SRTP_AES128_CM_HMAC_SHA1_32;
    public static int SRTP_NULL_HMAC_SHA1_80;
    public static int SRTP_NULL_HMAC_SHA1_32;
    public static int SRTP_AEAD_AES_128_GCM;
    public static int SRTP_AEAD_AES_256_GCM;
}
internal abstract class Org.BouncyCastle.Tls.Ssl3Utilities : object {
    private static Byte[] SSL_CLIENT;
    private static Byte[] SSL_SERVER;
    private static byte IPAD_BYTE;
    private static byte OPAD_BYTE;
    private static Byte[] IPAD;
    private static Byte[] OPAD;
    private static Ssl3Utilities();
    internal static Byte[] CalculateVerifyData(TlsHandshakeHash handshakeHash, bool isServer);
    internal static void CompleteCombinedHash(TlsContext context, TlsHash md5, TlsHash sha1);
    private static void CompleteHash(Byte[] master_secret, TlsHash hash, int padLength);
    private static Byte[] GenPad(byte b, int count);
    internal static Byte[] ReadEncryptedPms(Stream input);
    internal static void WriteEncryptedPms(Byte[] encryptedPms, Stream output);
}
public class Org.BouncyCastle.Tls.SupplementalDataEntry : object {
    private int m_dataType;
    private Byte[] m_data;
    public int DataType { get; }
    public Byte[] Data { get; }
    public SupplementalDataEntry(int dataType, Byte[] data);
    public int get_DataType();
    public Byte[] get_Data();
}
public abstract class Org.BouncyCastle.Tls.SupplementalDataType : object {
    public static int user_mapping_data;
}
internal class Org.BouncyCastle.Tls.Timeout : object {
    private long durationMillis;
    private long startMillis;
    internal Timeout(long durationMillis);
    internal Timeout(long durationMillis, long currentTimeMillis);
    internal long RemainingMillis(long currentTimeMillis);
    internal static int ConstrainWaitMillis(int waitMillis, Timeout timeout, long currentTimeMillis);
    internal static Timeout ForWaitMillis(int waitMillis);
    internal static Timeout ForWaitMillis(int waitMillis, long currentTimeMillis);
    internal static int GetWaitMillis(Timeout timeout, long currentTimeMillis);
    internal static bool HasExpired(Timeout timeout);
    internal static bool HasExpired(Timeout timeout, long currentTimeMillis);
}
public interface Org.BouncyCastle.Tls.TlsAuthentication {
    public abstract virtual void NotifyServerCertificate(TlsServerCertificate serverCertificate);
    public abstract virtual TlsCredentials GetClientCredentials(CertificateRequest certificateRequest);
}
public interface Org.BouncyCastle.Tls.TlsClient {
    public abstract virtual void Init(TlsClientContext context);
    public abstract virtual TlsSession GetSessionToResume();
    public abstract virtual IList GetExternalPsks();
    public abstract virtual bool IsFallback();
    public abstract virtual IDictionary GetClientExtensions();
    public abstract virtual IList GetEarlyKeyShareGroups();
    public abstract virtual void NotifyServerVersion(ProtocolVersion selectedVersion);
    public abstract virtual void NotifySessionToResume(TlsSession session);
    public abstract virtual void NotifySessionID(Byte[] sessionID);
    public abstract virtual void NotifySelectedCipherSuite(int selectedCipherSuite);
    public abstract virtual void NotifySelectedPsk(TlsPsk selectedPsk);
    public abstract virtual void ProcessServerExtensions(IDictionary serverExtensions);
    public abstract virtual void ProcessServerSupplementalData(IList serverSupplementalData);
    public abstract virtual TlsPskIdentity GetPskIdentity();
    public abstract virtual TlsSrpIdentity GetSrpIdentity();
    public abstract virtual TlsDHGroupVerifier GetDHGroupVerifier();
    public abstract virtual TlsSrpConfigVerifier GetSrpConfigVerifier();
    public abstract virtual TlsAuthentication GetAuthentication();
    public abstract virtual IList GetClientSupplementalData();
    public abstract virtual void NotifyNewSessionTicket(NewSessionTicket newSessionTicket);
}
public interface Org.BouncyCastle.Tls.TlsClientContext {
}
internal class Org.BouncyCastle.Tls.TlsClientContextImpl : AbstractTlsContext {
    public bool IsServer { get; }
    internal TlsClientContextImpl(TlsCrypto crypto);
    public virtual bool get_IsServer();
}
public class Org.BouncyCastle.Tls.TlsClientProtocol : TlsProtocol {
    protected TlsClient m_tlsClient;
    internal TlsClientContextImpl m_tlsClientContext;
    protected IDictionary m_clientAgreements;
    internal BindersConfig m_clientBinders;
    protected ClientHello m_clientHello;
    protected TlsKeyExchange m_keyExchange;
    protected TlsAuthentication m_authentication;
    protected CertificateStatus m_certificateStatus;
    protected CertificateRequest m_certificateRequest;
    protected TlsContext Context { get; }
    internal AbstractTlsContext ContextAdmin { get; }
    protected TlsPeer Peer { get; }
    public TlsClientProtocol(Stream stream);
    public TlsClientProtocol(Stream input, Stream output);
    public virtual void Connect(TlsClient tlsClient);
    protected virtual void BeginHandshake();
    protected virtual void CleanupHandshake();
    protected virtual TlsContext get_Context();
    internal virtual AbstractTlsContext get_ContextAdmin();
    protected virtual TlsPeer get_Peer();
    protected virtual void Handle13HandshakeMessage(short type, HandshakeMessageInput buf);
    protected virtual void HandleHandshakeMessage(short type, HandshakeMessageInput buf);
    protected virtual void HandleServerCertificate();
    protected virtual void HandleSupplementalData(IList serverSupplementalData);
    protected virtual void Process13HelloRetryRequest(ServerHello helloRetryRequest);
    protected virtual void Process13ServerHello(ServerHello serverHello, bool afterHelloRetryRequest);
    protected virtual void Process13ServerHelloCoda(ServerHello serverHello, bool afterHelloRetryRequest);
    protected virtual void ProcessServerHello(ServerHello serverHello);
    protected virtual void Receive13CertificateRequest(MemoryStream buf, bool postHandshakeAuth);
    protected virtual void Receive13EncryptedExtensions(MemoryStream buf);
    protected virtual void Receive13NewSessionTicket(MemoryStream buf);
    protected virtual void Receive13ServerCertificate(MemoryStream buf);
    protected virtual void Receive13ServerCertificateVerify(MemoryStream buf);
    protected virtual void Receive13ServerFinished(MemoryStream buf);
    protected virtual void ReceiveCertificateRequest(MemoryStream buf);
    protected virtual void ReceiveNewSessionTicket(MemoryStream buf);
    protected virtual ServerHello ReceiveServerHelloMessage(MemoryStream buf);
    protected virtual void Send13ClientHelloRetry();
    protected virtual void SendCertificateVerifyMessage(DigitallySigned certificateVerify);
    protected virtual void SendClientHello();
    protected virtual void SendClientHelloMessage();
    protected virtual void SendClientKeyExchange();
    protected virtual void Skip13CertificateRequest();
    protected virtual void Skip13ServerCertificate();
}
public interface Org.BouncyCastle.Tls.TlsCloseable {
    public abstract virtual void Close();
}
public interface Org.BouncyCastle.Tls.TlsContext {
    public TlsCrypto Crypto { get; }
    public TlsNonceGenerator NonceGenerator { get; }
    public SecurityParameters SecurityParameters { get; }
    public bool IsServer { get; }
    public ProtocolVersion[] ClientSupportedVersions { get; }
    public ProtocolVersion ClientVersion { get; }
    public ProtocolVersion RsaPreMasterSecretVersion { get; }
    public ProtocolVersion ServerVersion { get; }
    public TlsSession ResumableSession { get; }
    public TlsSession Session { get; }
    public object UserObject { get; public set; }
    public abstract virtual TlsCrypto get_Crypto();
    public abstract virtual TlsNonceGenerator get_NonceGenerator();
    public abstract virtual SecurityParameters get_SecurityParameters();
    public abstract virtual bool get_IsServer();
    public abstract virtual ProtocolVersion[] get_ClientSupportedVersions();
    public abstract virtual ProtocolVersion get_ClientVersion();
    public abstract virtual ProtocolVersion get_RsaPreMasterSecretVersion();
    public abstract virtual ProtocolVersion get_ServerVersion();
    public abstract virtual TlsSession get_ResumableSession();
    public abstract virtual TlsSession get_Session();
    public abstract virtual object get_UserObject();
    public abstract virtual void set_UserObject(object value);
    public abstract virtual Byte[] ExportChannelBinding(int channelBinding);
    public abstract virtual Byte[] ExportEarlyKeyingMaterial(string asciiLabel, Byte[] context_value, int length);
    public abstract virtual Byte[] ExportKeyingMaterial(string asciiLabel, Byte[] context_value, int length);
}
public interface Org.BouncyCastle.Tls.TlsCredentialedAgreement {
    public abstract virtual TlsSecret GenerateAgreement(TlsCertificate peerCertificate);
}
public interface Org.BouncyCastle.Tls.TlsCredentialedDecryptor {
    public abstract virtual TlsSecret Decrypt(TlsCryptoParameters cryptoParams, Byte[] ciphertext);
}
public interface Org.BouncyCastle.Tls.TlsCredentialedSigner {
    public SignatureAndHashAlgorithm SignatureAndHashAlgorithm { get; }
    public abstract virtual Byte[] GenerateRawSignature(Byte[] hash);
    public abstract virtual SignatureAndHashAlgorithm get_SignatureAndHashAlgorithm();
    public abstract virtual TlsStreamSigner GetStreamSigner();
}
public interface Org.BouncyCastle.Tls.TlsCredentials {
    public Certificate Certificate { get; }
    public abstract virtual Certificate get_Certificate();
}
public class Org.BouncyCastle.Tls.TlsDHanonKeyExchange : AbstractTlsKeyExchange {
    protected TlsDHGroupVerifier m_dhGroupVerifier;
    protected TlsDHConfig m_dhConfig;
    protected TlsAgreement m_agreement;
    public bool RequiresServerKeyExchange { get; }
    public TlsDHanonKeyExchange(int keyExchange, TlsDHGroupVerifier dhGroupVerifier);
    public TlsDHanonKeyExchange(int keyExchange, TlsDHConfig dhConfig);
    private TlsDHanonKeyExchange(int keyExchange, TlsDHGroupVerifier dhGroupVerifier, TlsDHConfig dhConfig);
    private static int CheckKeyExchange(int keyExchange);
    public virtual void SkipServerCredentials();
    public virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual bool get_RequiresServerKeyExchange();
    public virtual Byte[] GenerateServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    public virtual Int16[] GetClientCertificateTypes();
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual void ProcessClientCertificate(Certificate clientCertificate);
    public virtual void ProcessClientKeyExchange(Stream input);
    public virtual TlsSecret GeneratePreMasterSecret();
}
public class Org.BouncyCastle.Tls.TlsDheKeyExchange : AbstractTlsKeyExchange {
    protected TlsDHGroupVerifier m_dhGroupVerifier;
    protected TlsDHConfig m_dhConfig;
    protected TlsCredentialedSigner m_serverCredentials;
    protected TlsCertificate m_serverCertificate;
    protected TlsAgreement m_agreement;
    public bool RequiresServerKeyExchange { get; }
    public TlsDheKeyExchange(int keyExchange, TlsDHGroupVerifier dhGroupVerifier);
    public TlsDheKeyExchange(int keyExchange, TlsDHConfig dhConfig);
    private TlsDheKeyExchange(int keyExchange, TlsDHGroupVerifier dhGroupVerifier, TlsDHConfig dhConfig);
    private static int CheckKeyExchange(int keyExchange);
    public virtual void SkipServerCredentials();
    public virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual bool get_RequiresServerKeyExchange();
    public virtual Byte[] GenerateServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    public virtual Int16[] GetClientCertificateTypes();
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual void ProcessClientKeyExchange(Stream input);
    public virtual TlsSecret GeneratePreMasterSecret();
}
public interface Org.BouncyCastle.Tls.TlsDHGroupVerifier {
    public abstract virtual bool Accept(DHGroup dhGroup);
}
public class Org.BouncyCastle.Tls.TlsDHKeyExchange : AbstractTlsKeyExchange {
    protected TlsCredentialedAgreement m_agreementCredentials;
    protected TlsCertificate m_dhPeerCertificate;
    public bool RequiresCertificateVerify { get; }
    public TlsDHKeyExchange(int keyExchange);
    private static int CheckKeyExchange(int keyExchange);
    public virtual void SkipServerCredentials();
    public virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual Int16[] GetClientCertificateTypes();
    public virtual void SkipClientCredentials();
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual void ProcessClientCertificate(Certificate clientCertificate);
    public virtual void ProcessClientKeyExchange(Stream input);
    public virtual bool get_RequiresCertificateVerify();
    public virtual TlsSecret GeneratePreMasterSecret();
}
public abstract class Org.BouncyCastle.Tls.TlsDHUtilities : object {
    public static TlsDHConfig CreateNamedDHConfig(TlsContext context, int namedGroup);
    public static DHGroup GetDHGroup(TlsDHConfig dhConfig);
    public static DHGroup GetNamedDHGroup(int namedGroup);
    public static int GetMinimumFiniteFieldBits(int cipherSuite);
    public static bool IsDHCipherSuite(int cipherSuite);
    public static int GetNamedGroupForDHParameters(BigInteger p, BigInteger g);
    public static DHGroup GetStandardGroupForDHParameters(BigInteger p, BigInteger g);
    public static TlsDHConfig ReceiveDHConfig(TlsContext context, TlsDHGroupVerifier dhGroupVerifier, Stream input);
    public static BigInteger ReadDHParameter(Stream input);
    public static void WriteDHConfig(TlsDHConfig dhConfig, Stream output);
    public static void WriteDHParameter(BigInteger x, Stream output);
}
public abstract class Org.BouncyCastle.Tls.TlsEccUtilities : object {
    public static TlsECConfig CreateNamedECConfig(TlsContext context, int namedGroup);
    public static int GetMinimumCurveBits(int cipherSuite);
    public static bool IsEccCipherSuite(int cipherSuite);
    public static void CheckPointEncoding(int namedGroup, Byte[] encoding);
    public static TlsECConfig ReceiveECDHConfig(TlsContext context, Stream input);
    public static void WriteECConfig(TlsECConfig ecConfig, Stream output);
    public static void WriteNamedECParameters(int namedGroup, Stream output);
}
public class Org.BouncyCastle.Tls.TlsECDHanonKeyExchange : AbstractTlsKeyExchange {
    protected TlsECConfig m_ecConfig;
    protected TlsAgreement m_agreement;
    public bool RequiresServerKeyExchange { get; }
    public TlsECDHanonKeyExchange(int keyExchange);
    public TlsECDHanonKeyExchange(int keyExchange, TlsECConfig ecConfig);
    private static int CheckKeyExchange(int keyExchange);
    public virtual void SkipServerCredentials();
    public virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual bool get_RequiresServerKeyExchange();
    public virtual Byte[] GenerateServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    public virtual Int16[] GetClientCertificateTypes();
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual void ProcessClientCertificate(Certificate clientCertificate);
    public virtual void ProcessClientKeyExchange(Stream input);
    public virtual TlsSecret GeneratePreMasterSecret();
    protected virtual void GenerateEphemeral(Stream output);
    protected virtual void ProcessEphemeral(Byte[] point);
}
public class Org.BouncyCastle.Tls.TlsECDheKeyExchange : AbstractTlsKeyExchange {
    protected TlsECConfig m_ecConfig;
    protected TlsCredentialedSigner m_serverCredentials;
    protected TlsCertificate m_serverCertificate;
    protected TlsAgreement m_agreement;
    public bool RequiresServerKeyExchange { get; }
    public TlsECDheKeyExchange(int keyExchange);
    public TlsECDheKeyExchange(int keyExchange, TlsECConfig ecConfig);
    private static int CheckKeyExchange(int keyExchange);
    public virtual void SkipServerCredentials();
    public virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual bool get_RequiresServerKeyExchange();
    public virtual Byte[] GenerateServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    public virtual Int16[] GetClientCertificateTypes();
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual void ProcessClientKeyExchange(Stream input);
    public virtual TlsSecret GeneratePreMasterSecret();
    protected virtual void GenerateEphemeral(Stream output);
    protected virtual void ProcessEphemeral(Byte[] point);
}
public class Org.BouncyCastle.Tls.TlsECDHKeyExchange : AbstractTlsKeyExchange {
    protected TlsCredentialedAgreement m_agreementCredentials;
    protected TlsCertificate m_ecdhPeerCertificate;
    public bool RequiresCertificateVerify { get; }
    public TlsECDHKeyExchange(int keyExchange);
    private static int CheckKeyExchange(int keyExchange);
    public virtual void SkipServerCredentials();
    public virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual Int16[] GetClientCertificateTypes();
    public virtual void SkipClientCredentials();
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual void ProcessClientCertificate(Certificate clientCertificate);
    public virtual void ProcessClientKeyExchange(Stream input);
    public virtual bool get_RequiresCertificateVerify();
    public virtual TlsSecret GeneratePreMasterSecret();
}
public class Org.BouncyCastle.Tls.TlsException : IOException {
    public TlsException(string message);
    public TlsException(string message, Exception cause);
}
public abstract class Org.BouncyCastle.Tls.TlsExtensionsUtilities : object {
    public static IDictionary EnsureExtensionsInitialised(IDictionary extensions);
    public static void AddAlpnExtensionClient(IDictionary extensions, IList protocolNameList);
    public static void AddAlpnExtensionServer(IDictionary extensions, ProtocolName protocolName);
    public static void AddCertificateAuthoritiesExtension(IDictionary extensions, IList authorities);
    public static void AddClientCertificateTypeExtensionClient(IDictionary extensions, Int16[] certificateTypes);
    public static void AddClientCertificateTypeExtensionServer(IDictionary extensions, short certificateType);
    public static void AddClientCertificateUrlExtension(IDictionary extensions);
    public static void AddCookieExtension(IDictionary extensions, Byte[] cookie);
    public static void AddEarlyDataIndication(IDictionary extensions);
    public static void AddEarlyDataMaxSize(IDictionary extensions, long maxSize);
    public static void AddEmptyExtensionData(IDictionary extensions, int extType);
    public static void AddEncryptThenMacExtension(IDictionary extensions);
    public static void AddExtendedMasterSecretExtension(IDictionary extensions);
    public static void AddHeartbeatExtension(IDictionary extensions, HeartbeatExtension heartbeatExtension);
    public static void AddKeyShareClientHello(IDictionary extensions, IList clientShares);
    public static void AddKeyShareHelloRetryRequest(IDictionary extensions, int namedGroup);
    public static void AddKeyShareServerHello(IDictionary extensions, KeyShareEntry serverShare);
    public static void AddMaxFragmentLengthExtension(IDictionary extensions, short maxFragmentLength);
    public static void AddOidFiltersExtension(IDictionary extensions, IDictionary filters);
    public static void AddPaddingExtension(IDictionary extensions, int dataLength);
    public static void AddPostHandshakeAuthExtension(IDictionary extensions);
    public static void AddPreSharedKeyClientHello(IDictionary extensions, OfferedPsks offeredPsks);
    public static void AddPreSharedKeyServerHello(IDictionary extensions, int selectedIdentity);
    public static void AddPskKeyExchangeModesExtension(IDictionary extensions, Int16[] modes);
    public static void AddRecordSizeLimitExtension(IDictionary extensions, int recordSizeLimit);
    public static void AddServerCertificateTypeExtensionClient(IDictionary extensions, Int16[] certificateTypes);
    public static void AddServerCertificateTypeExtensionServer(IDictionary extensions, short certificateType);
    public static void AddServerNameExtensionClient(IDictionary extensions, IList serverNameList);
    public static void AddServerNameExtensionServer(IDictionary extensions);
    public static void AddSignatureAlgorithmsExtension(IDictionary extensions, IList supportedSignatureAlgorithms);
    public static void AddSignatureAlgorithmsCertExtension(IDictionary extensions, IList supportedSignatureAlgorithms);
    public static void AddStatusRequestExtension(IDictionary extensions, CertificateStatusRequest statusRequest);
    public static void AddStatusRequestV2Extension(IDictionary extensions, IList statusRequestV2);
    public static void AddSupportedGroupsExtension(IDictionary extensions, IList namedGroups);
    public static void AddSupportedPointFormatsExtension(IDictionary extensions, Int16[] ecPointFormats);
    public static void AddSupportedVersionsExtensionClient(IDictionary extensions, ProtocolVersion[] versions);
    public static void AddSupportedVersionsExtensionServer(IDictionary extensions, ProtocolVersion selectedVersion);
    public static void AddTruncatedHmacExtension(IDictionary extensions);
    public static void AddTrustedCAKeysExtensionClient(IDictionary extensions, IList trustedAuthoritiesList);
    public static void AddTrustedCAKeysExtensionServer(IDictionary extensions);
    public static IList GetAlpnExtensionClient(IDictionary extensions);
    public static ProtocolName GetAlpnExtensionServer(IDictionary extensions);
    public static IList GetCertificateAuthoritiesExtension(IDictionary extensions);
    public static Int16[] GetClientCertificateTypeExtensionClient(IDictionary extensions);
    public static short GetClientCertificateTypeExtensionServer(IDictionary extensions);
    public static Byte[] GetCookieExtension(IDictionary extensions);
    public static long GetEarlyDataMaxSize(IDictionary extensions);
    public static HeartbeatExtension GetHeartbeatExtension(IDictionary extensions);
    public static IList GetKeyShareClientHello(IDictionary extensions);
    public static int GetKeyShareHelloRetryRequest(IDictionary extensions);
    public static KeyShareEntry GetKeyShareServerHello(IDictionary extensions);
    public static short GetMaxFragmentLengthExtension(IDictionary extensions);
    public static IDictionary GetOidFiltersExtension(IDictionary extensions);
    public static int GetPaddingExtension(IDictionary extensions);
    public static OfferedPsks GetPreSharedKeyClientHello(IDictionary extensions);
    public static int GetPreSharedKeyServerHello(IDictionary extensions);
    public static Int16[] GetPskKeyExchangeModesExtension(IDictionary extensions);
    public static int GetRecordSizeLimitExtension(IDictionary extensions);
    public static Int16[] GetServerCertificateTypeExtensionClient(IDictionary extensions);
    public static short GetServerCertificateTypeExtensionServer(IDictionary extensions);
    public static IList GetServerNameExtensionClient(IDictionary extensions);
    public static IList GetSignatureAlgorithmsExtension(IDictionary extensions);
    public static IList GetSignatureAlgorithmsCertExtension(IDictionary extensions);
    public static CertificateStatusRequest GetStatusRequestExtension(IDictionary extensions);
    public static IList GetStatusRequestV2Extension(IDictionary extensions);
    public static Int32[] GetSupportedGroupsExtension(IDictionary extensions);
    public static Int16[] GetSupportedPointFormatsExtension(IDictionary extensions);
    public static ProtocolVersion[] GetSupportedVersionsExtensionClient(IDictionary extensions);
    public static ProtocolVersion GetSupportedVersionsExtensionServer(IDictionary extensions);
    public static IList GetTrustedCAKeysExtensionClient(IDictionary extensions);
    public static bool HasClientCertificateUrlExtension(IDictionary extensions);
    public static bool HasEarlyDataIndication(IDictionary extensions);
    public static bool HasEncryptThenMacExtension(IDictionary extensions);
    public static bool HasExtendedMasterSecretExtension(IDictionary extensions);
    public static bool HasServerNameExtensionServer(IDictionary extensions);
    public static bool HasPostHandshakeAuthExtension(IDictionary extensions);
    public static bool HasTruncatedHmacExtension(IDictionary extensions);
    public static bool HasTrustedCAKeysExtensionServer(IDictionary extensions);
    public static Byte[] CreateAlpnExtensionClient(IList protocolNameList);
    public static Byte[] CreateAlpnExtensionServer(ProtocolName protocolName);
    public static Byte[] CreateCertificateAuthoritiesExtension(IList authorities);
    public static Byte[] CreateCertificateTypeExtensionClient(Int16[] certificateTypes);
    public static Byte[] CreateCertificateTypeExtensionServer(short certificateType);
    public static Byte[] CreateClientCertificateUrlExtension();
    public static Byte[] CreateCookieExtension(Byte[] cookie);
    public static Byte[] CreateEarlyDataIndication();
    public static Byte[] CreateEarlyDataMaxSize(long maxSize);
    public static Byte[] CreateEmptyExtensionData();
    public static Byte[] CreateEncryptThenMacExtension();
    public static Byte[] CreateExtendedMasterSecretExtension();
    public static Byte[] CreateHeartbeatExtension(HeartbeatExtension heartbeatExtension);
    public static Byte[] CreateKeyShareClientHello(IList clientShares);
    public static Byte[] CreateKeyShareHelloRetryRequest(int namedGroup);
    public static Byte[] CreateKeyShareServerHello(KeyShareEntry serverShare);
    public static Byte[] CreateMaxFragmentLengthExtension(short maxFragmentLength);
    public static Byte[] CreateOidFiltersExtension(IDictionary filters);
    public static Byte[] CreatePaddingExtension(int dataLength);
    public static Byte[] CreatePostHandshakeAuthExtension();
    public static Byte[] CreatePreSharedKeyClientHello(OfferedPsks offeredPsks);
    public static Byte[] CreatePreSharedKeyServerHello(int selectedIdentity);
    public static Byte[] CreatePskKeyExchangeModesExtension(Int16[] modes);
    public static Byte[] CreateRecordSizeLimitExtension(int recordSizeLimit);
    public static Byte[] CreateServerNameExtensionClient(IList serverNameList);
    public static Byte[] CreateServerNameExtensionServer();
    public static Byte[] CreateSignatureAlgorithmsExtension(IList supportedSignatureAlgorithms);
    public static Byte[] CreateSignatureAlgorithmsCertExtension(IList supportedSignatureAlgorithms);
    public static Byte[] CreateStatusRequestExtension(CertificateStatusRequest statusRequest);
    public static Byte[] CreateStatusRequestV2Extension(IList statusRequestV2);
    public static Byte[] CreateSupportedGroupsExtension(IList namedGroups);
    public static Byte[] CreateSupportedPointFormatsExtension(Int16[] ecPointFormats);
    public static Byte[] CreateSupportedVersionsExtensionClient(ProtocolVersion[] versions);
    public static Byte[] CreateSupportedVersionsExtensionServer(ProtocolVersion selectedVersion);
    public static Byte[] CreateTruncatedHmacExtension();
    public static Byte[] CreateTrustedCAKeysExtensionClient(IList trustedAuthoritiesList);
    public static Byte[] CreateTrustedCAKeysExtensionServer();
    private static bool ReadEmptyExtensionData(Byte[] extensionData);
    public static IList ReadAlpnExtensionClient(Byte[] extensionData);
    public static ProtocolName ReadAlpnExtensionServer(Byte[] extensionData);
    public static IList ReadCertificateAuthoritiesExtension(Byte[] extensionData);
    public static Int16[] ReadCertificateTypeExtensionClient(Byte[] extensionData);
    public static short ReadCertificateTypeExtensionServer(Byte[] extensionData);
    public static bool ReadClientCertificateUrlExtension(Byte[] extensionData);
    public static Byte[] ReadCookieExtension(Byte[] extensionData);
    public static bool ReadEarlyDataIndication(Byte[] extensionData);
    public static long ReadEarlyDataMaxSize(Byte[] extensionData);
    public static bool ReadEncryptThenMacExtension(Byte[] extensionData);
    public static bool ReadExtendedMasterSecretExtension(Byte[] extensionData);
    public static HeartbeatExtension ReadHeartbeatExtension(Byte[] extensionData);
    public static IList ReadKeyShareClientHello(Byte[] extensionData);
    public static int ReadKeyShareHelloRetryRequest(Byte[] extensionData);
    public static KeyShareEntry ReadKeyShareServerHello(Byte[] extensionData);
    public static short ReadMaxFragmentLengthExtension(Byte[] extensionData);
    public static IDictionary ReadOidFiltersExtension(Byte[] extensionData);
    public static int ReadPaddingExtension(Byte[] extensionData);
    public static bool ReadPostHandshakeAuthExtension(Byte[] extensionData);
    public static OfferedPsks ReadPreSharedKeyClientHello(Byte[] extensionData);
    public static int ReadPreSharedKeyServerHello(Byte[] extensionData);
    public static Int16[] ReadPskKeyExchangeModesExtension(Byte[] extensionData);
    public static int ReadRecordSizeLimitExtension(Byte[] extensionData);
    public static IList ReadServerNameExtensionClient(Byte[] extensionData);
    public static bool ReadServerNameExtensionServer(Byte[] extensionData);
    public static IList ReadSignatureAlgorithmsExtension(Byte[] extensionData);
    public static IList ReadSignatureAlgorithmsCertExtension(Byte[] extensionData);
    public static CertificateStatusRequest ReadStatusRequestExtension(Byte[] extensionData);
    public static IList ReadStatusRequestV2Extension(Byte[] extensionData);
    public static Int32[] ReadSupportedGroupsExtension(Byte[] extensionData);
    public static Int16[] ReadSupportedPointFormatsExtension(Byte[] extensionData);
    public static ProtocolVersion[] ReadSupportedVersionsExtensionClient(Byte[] extensionData);
    public static ProtocolVersion ReadSupportedVersionsExtensionServer(Byte[] extensionData);
    public static bool ReadTruncatedHmacExtension(Byte[] extensionData);
    public static IList ReadTrustedCAKeysExtensionClient(Byte[] extensionData);
    public static bool ReadTrustedCAKeysExtensionServer(Byte[] extensionData);
    private static Byte[] PatchOpaque16(MemoryStream buf);
}
public class Org.BouncyCastle.Tls.TlsFatalAlert : TlsException {
    protected short m_alertDescription;
    public short AlertDescription { get; }
    public TlsFatalAlert(short alertDescription);
    public TlsFatalAlert(short alertDescription, string detailMessage);
    public TlsFatalAlert(short alertDescription, Exception alertCause);
    public TlsFatalAlert(short alertDescription, string detailMessage, Exception alertCause);
    private static string GetMessage(short alertDescription, string detailMessage);
    public virtual short get_AlertDescription();
}
public class Org.BouncyCastle.Tls.TlsFatalAlertReceived : TlsException {
    protected short m_alertDescription;
    public short AlertDescription { get; }
    public TlsFatalAlertReceived(short alertDescription);
    public virtual short get_AlertDescription();
}
public interface Org.BouncyCastle.Tls.TlsHandshakeHash {
    public abstract virtual void CopyBufferTo(Stream output);
    public abstract virtual void ForceBuffering();
    public abstract virtual void NotifyPrfDetermined();
    public abstract virtual void TrackHashAlgorithm(int cryptoHashAlgorithm);
    public abstract virtual void SealHashAlgorithms();
    public abstract virtual TlsHandshakeHash StopTracking();
    public abstract virtual TlsHash ForkPrfHash();
    public abstract virtual Byte[] GetFinalHash(int cryptoHashAlgorithm);
}
public interface Org.BouncyCastle.Tls.TlsHeartbeat {
    public int IdleMillis { get; }
    public int TimeoutMillis { get; }
    public abstract virtual Byte[] GeneratePayload();
    public abstract virtual int get_IdleMillis();
    public abstract virtual int get_TimeoutMillis();
}
public interface Org.BouncyCastle.Tls.TlsKeyExchange {
    public bool RequiresServerKeyExchange { get; }
    public bool RequiresCertificateVerify { get; }
    public abstract virtual void Init(TlsContext context);
    public abstract virtual void SkipServerCredentials();
    public abstract virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public abstract virtual void ProcessServerCertificate(Certificate serverCertificate);
    public abstract virtual bool get_RequiresServerKeyExchange();
    public abstract virtual Byte[] GenerateServerKeyExchange();
    public abstract virtual void SkipServerKeyExchange();
    public abstract virtual void ProcessServerKeyExchange(Stream input);
    public abstract virtual Int16[] GetClientCertificateTypes();
    public abstract virtual void SkipClientCredentials();
    public abstract virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public abstract virtual void ProcessClientCertificate(Certificate clientCertificate);
    public abstract virtual void GenerateClientKeyExchange(Stream output);
    public abstract virtual void ProcessClientKeyExchange(Stream input);
    public abstract virtual bool get_RequiresCertificateVerify();
    public abstract virtual TlsSecret GeneratePreMasterSecret();
}
public interface Org.BouncyCastle.Tls.TlsKeyExchangeFactory {
    public abstract virtual TlsKeyExchange CreateDHKeyExchange(int keyExchange);
    public abstract virtual TlsKeyExchange CreateDHanonKeyExchangeClient(int keyExchange, TlsDHGroupVerifier dhGroupVerifier);
    public abstract virtual TlsKeyExchange CreateDHanonKeyExchangeServer(int keyExchange, TlsDHConfig dhConfig);
    public abstract virtual TlsKeyExchange CreateDheKeyExchangeClient(int keyExchange, TlsDHGroupVerifier dhGroupVerifier);
    public abstract virtual TlsKeyExchange CreateDheKeyExchangeServer(int keyExchange, TlsDHConfig dhConfig);
    public abstract virtual TlsKeyExchange CreateECDHKeyExchange(int keyExchange);
    public abstract virtual TlsKeyExchange CreateECDHanonKeyExchangeClient(int keyExchange);
    public abstract virtual TlsKeyExchange CreateECDHanonKeyExchangeServer(int keyExchange, TlsECConfig ecConfig);
    public abstract virtual TlsKeyExchange CreateECDheKeyExchangeClient(int keyExchange);
    public abstract virtual TlsKeyExchange CreateECDheKeyExchangeServer(int keyExchange, TlsECConfig ecConfig);
    public abstract virtual TlsKeyExchange CreatePskKeyExchangeClient(int keyExchange, TlsPskIdentity pskIdentity, TlsDHGroupVerifier dhGroupVerifier);
    public abstract virtual TlsKeyExchange CreatePskKeyExchangeServer(int keyExchange, TlsPskIdentityManager pskIdentityManager, TlsDHConfig dhConfig, TlsECConfig ecConfig);
    public abstract virtual TlsKeyExchange CreateRsaKeyExchange(int keyExchange);
    public abstract virtual TlsKeyExchange CreateSrpKeyExchangeClient(int keyExchange, TlsSrpIdentity srpIdentity, TlsSrpConfigVerifier srpConfigVerifier);
    public abstract virtual TlsKeyExchange CreateSrpKeyExchangeServer(int keyExchange, TlsSrpLoginParameters loginParameters);
}
public class Org.BouncyCastle.Tls.TlsNoCloseNotifyException : EndOfStreamException {
}
public abstract class Org.BouncyCastle.Tls.TlsObjectIdentifiers : object {
    public static DerObjectIdentifier id_pe_tlsfeature;
    private static TlsObjectIdentifiers();
}
public interface Org.BouncyCastle.Tls.TlsPeer {
    public TlsCrypto Crypto { get; }
    public abstract virtual TlsCrypto get_Crypto();
    public abstract virtual void NotifyCloseHandle(TlsCloseable closehandle);
    public abstract virtual void Cancel();
    public abstract virtual ProtocolVersion[] GetProtocolVersions();
    public abstract virtual Int32[] GetCipherSuites();
    public abstract virtual void NotifyHandshakeBeginning();
    public abstract virtual int GetHandshakeTimeoutMillis();
    public abstract virtual bool AllowLegacyResumption();
    public abstract virtual int GetMaxCertificateChainLength();
    public abstract virtual int GetMaxHandshakeMessageSize();
    public abstract virtual Int16[] GetPskKeyExchangeModes();
    public abstract virtual bool RequiresCloseNotify();
    public abstract virtual bool RequiresExtendedMasterSecret();
    public abstract virtual bool ShouldUseExtendedMasterSecret();
    public abstract virtual bool ShouldUseExtendedPadding();
    public abstract virtual bool ShouldUseGmtUnixTime();
    public abstract virtual void NotifySecureRenegotiation(bool secureRenegotiation);
    public abstract virtual TlsKeyExchangeFactory GetKeyExchangeFactory();
    public abstract virtual void NotifyAlertRaised(short alertLevel, short alertDescription, string message, Exception cause);
    public abstract virtual void NotifyAlertReceived(short alertLevel, short alertDescription);
    public abstract virtual void NotifyHandshakeComplete();
    public abstract virtual TlsHeartbeat GetHeartbeat();
    public abstract virtual short GetHeartbeatPolicy();
}
public abstract class Org.BouncyCastle.Tls.TlsProtocol : object {
    protected static short CS_START;
    protected static short CS_CLIENT_HELLO;
    protected static short CS_SERVER_HELLO_RETRY_REQUEST;
    protected static short CS_CLIENT_HELLO_RETRY;
    protected static short CS_SERVER_HELLO;
    protected static short CS_SERVER_ENCRYPTED_EXTENSIONS;
    protected static short CS_SERVER_SUPPLEMENTAL_DATA;
    protected static short CS_SERVER_CERTIFICATE;
    protected static short CS_SERVER_CERTIFICATE_STATUS;
    protected static short CS_SERVER_CERTIFICATE_VERIFY;
    protected static short CS_SERVER_KEY_EXCHANGE;
    protected static short CS_SERVER_CERTIFICATE_REQUEST;
    protected static short CS_SERVER_HELLO_DONE;
    protected static short CS_CLIENT_END_OF_EARLY_DATA;
    protected static short CS_CLIENT_SUPPLEMENTAL_DATA;
    protected static short CS_CLIENT_CERTIFICATE;
    protected static short CS_CLIENT_KEY_EXCHANGE;
    protected static short CS_CLIENT_CERTIFICATE_VERIFY;
    protected static short CS_CLIENT_FINISHED;
    protected static short CS_SERVER_SESSION_TICKET;
    protected static short CS_SERVER_FINISHED;
    protected static short CS_END;
    protected static short ADS_MODE_1_Nsub1;
    protected static short ADS_MODE_0_N;
    protected static short ADS_MODE_0_N_FIRSTONLY;
    private ByteQueue m_applicationDataQueue;
    private ByteQueue m_alertQueue;
    private ByteQueue m_handshakeQueue;
    internal RecordStream m_recordStream;
    internal object m_recordWriteLock;
    private int m_maxHandshakeMessageSize;
    internal TlsHandshakeHash m_handshakeHash;
    private TlsStream m_tlsStream;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_closed;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_failedWithError;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_appDataReady;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_appDataSplitEnabled;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_keyUpdateEnabled;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_keyUpdatePendingSend;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_resumableHandshake;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_appDataSplitMode;
    protected TlsSession m_tlsSession;
    protected SessionParameters m_sessionParameters;
    protected TlsSecret m_sessionMasterSecret;
    protected Byte[] m_retryCookie;
    protected int m_retryGroup;
    protected IDictionary m_clientExtensions;
    protected IDictionary m_serverExtensions;
    protected short m_connectionState;
    protected bool m_resumedSession;
    protected bool m_selectedPsk13;
    protected bool m_receivedChangeCipherSpec;
    protected bool m_expectSessionTicket;
    protected bool m_blocking;
    protected ByteQueueInputStream m_inputBuffers;
    protected ByteQueueOutputStream m_outputBuffer;
    protected TlsContext Context { get; }
    internal AbstractTlsContext ContextAdmin { get; }
    protected TlsPeer Peer { get; }
    public int ApplicationDataAvailable { get; }
    public int AppDataSplitMode { get; public set; }
    public bool IsResumableHandshake { get; public set; }
    public Stream Stream { get; }
    public int ApplicationDataLimit { get; }
    internal bool IsApplicationDataReady { get; }
    public bool IsClosed { get; }
    public bool IsConnected { get; }
    public bool IsHandshaking { get; }
    public TlsProtocol(Stream stream);
    public TlsProtocol(Stream input, Stream output);
    protected bool IsLegacyConnectionState();
    protected bool IsTlsV13ConnectionState();
    public virtual void ResumeHandshake();
    protected virtual void CloseConnection();
    protected abstract virtual TlsContext get_Context();
    internal abstract virtual AbstractTlsContext get_ContextAdmin();
    protected abstract virtual TlsPeer get_Peer();
    protected virtual void HandleAlertMessage(short alertLevel, short alertDescription);
    protected virtual void HandleAlertWarningMessage(short alertDescription);
    protected virtual void HandleChangeCipherSpecMessage();
    protected virtual void HandleClose(bool user_canceled);
    protected virtual void HandleException(short alertDescription, string message, Exception e);
    protected virtual void HandleFailure();
    protected abstract virtual void HandleHandshakeMessage(short type, HandshakeMessageInput buf);
    protected virtual void ApplyMaxFragmentLengthExtension(short maxFragmentLength);
    protected virtual void CheckReceivedChangeCipherSpec(bool expected);
    protected virtual void BlockForHandshake();
    protected virtual void BeginHandshake();
    protected virtual void CleanupHandshake();
    protected virtual void CompleteHandshake();
    internal void ProcessRecord(short protocol, Byte[] buf, int off, int len);
    private void ProcessHandshakeQueue(ByteQueue queue);
    private void ProcessApplicationDataQueue();
    private void ProcessAlertQueue();
    private void ProcessChangeCipherSpec(Byte[] buf, int off, int len);
    public virtual int get_ApplicationDataAvailable();
    public virtual int ReadApplicationData(Byte[] buf, int off, int len);
    protected virtual RecordPreview SafePreviewRecordHeader(Byte[] recordHeader);
    protected virtual void SafeReadRecord();
    protected virtual bool SafeReadFullRecord(Byte[] input, int inputOff, int inputLen);
    protected virtual void SafeWriteRecord(short type, Byte[] buf, int offset, int len);
    public virtual void WriteApplicationData(Byte[] buf, int off, int len);
    public virtual int get_AppDataSplitMode();
    public virtual void set_AppDataSplitMode(int value);
    public virtual bool get_IsResumableHandshake();
    public virtual void set_IsResumableHandshake(bool value);
    internal void WriteHandshakeMessage(Byte[] buf, int off, int len);
    public virtual Stream get_Stream();
    public virtual void CloseInput();
    public virtual RecordPreview PreviewInputRecord(Byte[] recordHeader);
    public virtual RecordPreview PreviewOutputRecord(int applicationDataSize);
    public virtual void OfferInput(Byte[] input);
    public virtual void OfferInput(Byte[] input, int inputOff, int inputLen);
    public virtual int get_ApplicationDataLimit();
    public virtual int GetAvailableInputBytes();
    public virtual int ReadInput(Byte[] buf, int off, int len);
    public virtual int GetAvailableOutputBytes();
    public virtual int ReadOutput(Byte[] buffer, int offset, int length);
    protected virtual bool EstablishSession(TlsSession sessionToResume);
    protected virtual void InvalidateSession();
    protected virtual void ProcessFinishedMessage(MemoryStream buf);
    protected virtual void Process13FinishedMessage(MemoryStream buf);
    protected virtual void RaiseAlertFatal(short alertDescription, string message, Exception cause);
    protected virtual void RaiseAlertWarning(short alertDescription, string message);
    protected virtual void Receive13KeyUpdate(MemoryStream buf);
    protected virtual void SendCertificateMessage(Certificate certificate, Stream endPointHash);
    protected virtual void Send13CertificateMessage(Certificate certificate);
    protected virtual void Send13CertificateVerifyMessage(DigitallySigned certificateVerify);
    protected virtual void SendChangeCipherSpec();
    protected virtual void SendChangeCipherSpecMessage();
    protected virtual void SendFinishedMessage();
    protected virtual void Send13FinishedMessage();
    protected virtual void Send13KeyUpdate(bool updateRequested);
    protected virtual void SendSupplementalDataMessage(IList supplementalData);
    public virtual void Close();
    public virtual void Flush();
    internal bool get_IsApplicationDataReady();
    public virtual bool get_IsClosed();
    public virtual bool get_IsConnected();
    public virtual bool get_IsHandshaking();
    protected virtual short ProcessMaxFragmentLengthExtension(IDictionary clientExtensions, IDictionary serverExtensions, short alertDescription);
    protected virtual void RefuseRenegotiation();
    internal static void AssertEmpty(MemoryStream buf);
    internal static Byte[] CreateRandomBlock(bool useGmtUnixTime, TlsContext context);
    internal static Byte[] CreateRenegotiationInfo(Byte[] renegotiated_connection);
    internal static void EstablishMasterSecret(TlsContext context, TlsKeyExchange keyExchange);
    internal static IDictionary ReadExtensions(MemoryStream input);
    internal static IDictionary ReadExtensionsData(Byte[] extBytes);
    internal static IDictionary ReadExtensionsData13(int handshakeType, Byte[] extBytes);
    internal static IDictionary ReadExtensionsDataClientHello(Byte[] extBytes);
    internal static IList ReadSupplementalDataMessage(MemoryStream input);
    internal static void WriteExtensions(Stream output, IDictionary extensions);
    internal static void WriteExtensions(Stream output, IDictionary extensions, int bindersSize);
    internal static Byte[] WriteExtensionsData(IDictionary extensions);
    internal static Byte[] WriteExtensionsData(IDictionary extensions, int bindersSize);
    internal static void WriteExtensionsData(IDictionary extensions, MemoryStream buf);
    internal static void WriteExtensionsData(IDictionary extensions, MemoryStream buf, int bindersSize);
    internal static void WritePreSharedKeyExtension(MemoryStream buf, IDictionary extensions, int bindersSize);
    internal static void WriteSelectedExtensions(Stream output, IDictionary extensions, bool selectEmpty);
    internal static void WriteSupplementalData(Stream output, IList supplementalData);
}
public interface Org.BouncyCastle.Tls.TlsPsk {
    public Byte[] Identity { get; }
    public TlsSecret Key { get; }
    public int PrfAlgorithm { get; }
    public abstract virtual Byte[] get_Identity();
    public abstract virtual TlsSecret get_Key();
    public abstract virtual int get_PrfAlgorithm();
}
public interface Org.BouncyCastle.Tls.TlsPskExternal {
}
public interface Org.BouncyCastle.Tls.TlsPskIdentity {
    public abstract virtual void SkipIdentityHint();
    public abstract virtual void NotifyIdentityHint(Byte[] psk_identity_hint);
    public abstract virtual Byte[] GetPskIdentity();
    public abstract virtual Byte[] GetPsk();
}
public interface Org.BouncyCastle.Tls.TlsPskIdentityManager {
    public abstract virtual Byte[] GetHint();
    public abstract virtual Byte[] GetPsk(Byte[] identity);
}
public class Org.BouncyCastle.Tls.TlsPskKeyExchange : AbstractTlsKeyExchange {
    protected TlsPskIdentity m_pskIdentity;
    protected TlsPskIdentityManager m_pskIdentityManager;
    protected TlsDHGroupVerifier m_dhGroupVerifier;
    protected Byte[] m_psk_identity_hint;
    protected Byte[] m_psk;
    protected TlsDHConfig m_dhConfig;
    protected TlsECConfig m_ecConfig;
    protected TlsAgreement m_agreement;
    protected TlsCredentialedDecryptor m_serverCredentials;
    protected TlsEncryptor m_serverEncryptor;
    protected TlsSecret m_preMasterSecret;
    public bool RequiresServerKeyExchange { get; }
    public TlsPskKeyExchange(int keyExchange, TlsPskIdentity pskIdentity, TlsDHGroupVerifier dhGroupVerifier);
    public TlsPskKeyExchange(int keyExchange, TlsPskIdentityManager pskIdentityManager, TlsDHConfig dhConfig, TlsECConfig ecConfig);
    private TlsPskKeyExchange(int keyExchange, TlsPskIdentity pskIdentity, TlsPskIdentityManager pskIdentityManager, TlsDHGroupVerifier dhGroupVerifier, TlsDHConfig dhConfig, TlsECConfig ecConfig);
    private static int CheckKeyExchange(int keyExchange);
    public virtual void SkipServerCredentials();
    public virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual Byte[] GenerateServerKeyExchange();
    public virtual bool get_RequiresServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual void ProcessClientKeyExchange(Stream input);
    public virtual TlsSecret GeneratePreMasterSecret();
    protected virtual void GenerateEphemeralDH(Stream output);
    protected virtual void GenerateEphemeralECDH(Stream output);
    protected virtual Byte[] GenerateOtherSecret(int pskLength);
    protected virtual void ProcessEphemeralDH(Byte[] y);
    protected virtual void ProcessEphemeralECDH(Byte[] point);
}
public class Org.BouncyCastle.Tls.TlsRsaKeyExchange : AbstractTlsKeyExchange {
    protected TlsCredentialedDecryptor m_serverCredentials;
    protected TlsEncryptor m_serverEncryptor;
    protected TlsSecret m_preMasterSecret;
    public TlsRsaKeyExchange(int keyExchange);
    private static int CheckKeyExchange(int keyExchange);
    public virtual void SkipServerCredentials();
    public virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual Int16[] GetClientCertificateTypes();
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual void ProcessClientKeyExchange(Stream input);
    public virtual TlsSecret GeneratePreMasterSecret();
}
public interface Org.BouncyCastle.Tls.TlsServer {
    public abstract virtual void Init(TlsServerContext context);
    public abstract virtual TlsSession GetSessionToResume(Byte[] sessionID);
    public abstract virtual Byte[] GetNewSessionID();
    public abstract virtual TlsPskExternal GetExternalPsk(IList identities);
    public abstract virtual void NotifySession(TlsSession session);
    public abstract virtual void NotifyClientVersion(ProtocolVersion clientVersion);
    public abstract virtual void NotifyFallback(bool isFallback);
    public abstract virtual void NotifyOfferedCipherSuites(Int32[] offeredCipherSuites);
    public abstract virtual void ProcessClientExtensions(IDictionary clientExtensions);
    public abstract virtual ProtocolVersion GetServerVersion();
    public abstract virtual Int32[] GetSupportedGroups();
    public abstract virtual int GetSelectedCipherSuite();
    public abstract virtual IDictionary GetServerExtensions();
    public abstract virtual void GetServerExtensionsForConnection(IDictionary serverExtensions);
    public abstract virtual IList GetServerSupplementalData();
    public abstract virtual TlsCredentials GetCredentials();
    public abstract virtual CertificateStatus GetCertificateStatus();
    public abstract virtual CertificateRequest GetCertificateRequest();
    public abstract virtual TlsPskIdentityManager GetPskIdentityManager();
    public abstract virtual TlsSrpLoginParameters GetSrpLoginParameters();
    public abstract virtual TlsDHConfig GetDHConfig();
    public abstract virtual TlsECConfig GetECDHConfig();
    public abstract virtual void ProcessClientSupplementalData(IList clientSupplementalData);
    public abstract virtual void NotifyClientCertificate(Certificate clientCertificate);
    public abstract virtual NewSessionTicket GetNewSessionTicket();
}
public interface Org.BouncyCastle.Tls.TlsServerCertificate {
    public Certificate Certificate { get; }
    public CertificateStatus CertificateStatus { get; }
    public abstract virtual Certificate get_Certificate();
    public abstract virtual CertificateStatus get_CertificateStatus();
}
internal class Org.BouncyCastle.Tls.TlsServerCertificateImpl : object {
    private Certificate m_certificate;
    private CertificateStatus m_certificateStatus;
    public Certificate Certificate { get; }
    public CertificateStatus CertificateStatus { get; }
    internal TlsServerCertificateImpl(Certificate certificate, CertificateStatus certificateStatus);
    public sealed virtual Certificate get_Certificate();
    public sealed virtual CertificateStatus get_CertificateStatus();
}
public interface Org.BouncyCastle.Tls.TlsServerContext {
}
internal class Org.BouncyCastle.Tls.TlsServerContextImpl : AbstractTlsContext {
    public bool IsServer { get; }
    internal TlsServerContextImpl(TlsCrypto crypto);
    public virtual bool get_IsServer();
}
public class Org.BouncyCastle.Tls.TlsServerProtocol : TlsProtocol {
    protected TlsServer m_tlsServer;
    internal TlsServerContextImpl m_tlsServerContext;
    protected Int32[] m_offeredCipherSuites;
    protected TlsKeyExchange m_keyExchange;
    protected CertificateRequest m_certificateRequest;
    protected TlsContext Context { get; }
    internal AbstractTlsContext ContextAdmin { get; }
    protected TlsPeer Peer { get; }
    public TlsServerProtocol(Stream stream);
    public TlsServerProtocol(Stream input, Stream output);
    public void Accept(TlsServer tlsServer);
    protected virtual void CleanupHandshake();
    protected virtual bool ExpectCertificateVerifyMessage();
    protected virtual ServerHello Generate13HelloRetryRequest(ClientHello clientHello);
    protected virtual ServerHello Generate13ServerHello(ClientHello clientHello, HandshakeMessageInput clientHelloMessage, bool afterHelloRetryRequest);
    protected virtual ServerHello GenerateServerHello(ClientHello clientHello, HandshakeMessageInput clientHelloMessage);
    protected virtual TlsContext get_Context();
    internal virtual AbstractTlsContext get_ContextAdmin();
    protected virtual TlsPeer get_Peer();
    protected virtual void Handle13HandshakeMessage(short type, HandshakeMessageInput buf);
    protected virtual void HandleHandshakeMessage(short type, HandshakeMessageInput buf);
    protected virtual void HandleAlertWarningMessage(short alertDescription);
    protected virtual void NotifyClientCertificate(Certificate clientCertificate);
    protected virtual void Receive13ClientCertificate(MemoryStream buf);
    protected void Receive13ClientCertificateVerify(MemoryStream buf);
    protected virtual void Receive13ClientFinished(MemoryStream buf);
    protected virtual void ReceiveCertificateMessage(MemoryStream buf);
    protected virtual void ReceiveCertificateVerifyMessage(MemoryStream buf);
    protected virtual ClientHello ReceiveClientHelloMessage(MemoryStream buf);
    protected virtual void ReceiveClientKeyExchangeMessage(MemoryStream buf);
    protected virtual void Send13EncryptedExtensionsMessage(IDictionary serverExtensions);
    protected virtual void Send13ServerHelloCoda(ServerHello serverHello, bool afterHelloRetryRequest);
    protected virtual void SendCertificateRequestMessage(CertificateRequest certificateRequest);
    protected virtual void SendCertificateStatusMessage(CertificateStatus certificateStatus);
    protected virtual void SendHelloRequestMessage();
    protected virtual void SendNewSessionTicketMessage(NewSessionTicket newSessionTicket);
    protected virtual void SendServerHelloDoneMessage();
    protected virtual void SendServerHelloMessage(ServerHello serverHello);
    protected virtual void SendServerKeyExchangeMessage(Byte[] serverKeyExchange);
    protected virtual void Skip13ClientCertificate();
    protected virtual void Skip13ClientCertificateVerify();
}
public interface Org.BouncyCastle.Tls.TlsSession {
    public Byte[] SessionID { get; }
    public bool IsResumable { get; }
    public abstract virtual SessionParameters ExportSessionParameters();
    public abstract virtual Byte[] get_SessionID();
    public abstract virtual void Invalidate();
    public abstract virtual bool get_IsResumable();
}
internal class Org.BouncyCastle.Tls.TlsSessionImpl : object {
    private Byte[] m_sessionID;
    private SessionParameters m_sessionParameters;
    private bool m_resumable;
    public Byte[] SessionID { get; }
    public bool IsResumable { get; }
    internal TlsSessionImpl(Byte[] sessionID, SessionParameters sessionParameters);
    public sealed virtual SessionParameters ExportSessionParameters();
    public sealed virtual Byte[] get_SessionID();
    public sealed virtual void Invalidate();
    public sealed virtual bool get_IsResumable();
}
public interface Org.BouncyCastle.Tls.TlsSrpConfigVerifier {
    public abstract virtual bool Accept(TlsSrpConfig srpConfig);
}
public interface Org.BouncyCastle.Tls.TlsSrpIdentity {
    public abstract virtual Byte[] GetSrpIdentity();
    public abstract virtual Byte[] GetSrpPassword();
}
public interface Org.BouncyCastle.Tls.TlsSrpIdentityManager {
    public abstract virtual TlsSrpLoginParameters GetLoginParameters(Byte[] identity);
}
public class Org.BouncyCastle.Tls.TlsSrpKeyExchange : AbstractTlsKeyExchange {
    protected TlsSrpIdentity m_srpIdentity;
    protected TlsSrpConfigVerifier m_srpConfigVerifier;
    protected TlsCertificate m_serverCertificate;
    protected Byte[] m_srpSalt;
    protected TlsSrp6Client m_srpClient;
    protected TlsSrpLoginParameters m_srpLoginParameters;
    protected TlsCredentialedSigner m_serverCredentials;
    protected TlsSrp6Server m_srpServer;
    protected BigInteger m_srpPeerCredentials;
    public bool RequiresServerKeyExchange { get; }
    public TlsSrpKeyExchange(int keyExchange, TlsSrpIdentity srpIdentity, TlsSrpConfigVerifier srpConfigVerifier);
    public TlsSrpKeyExchange(int keyExchange, TlsSrpLoginParameters srpLoginParameters);
    private static int CheckKeyExchange(int keyExchange);
    public virtual void SkipServerCredentials();
    public virtual void ProcessServerCredentials(TlsCredentials serverCredentials);
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual bool get_RequiresServerKeyExchange();
    public virtual Byte[] GenerateServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual void ProcessClientKeyExchange(Stream input);
    public virtual TlsSecret GeneratePreMasterSecret();
    protected static BigInteger ValidatePublicValue(BigInteger N, BigInteger val);
}
public class Org.BouncyCastle.Tls.TlsSrpLoginParameters : object {
    protected Byte[] m_identity;
    protected TlsSrpConfig m_srpConfig;
    protected BigInteger m_verifier;
    protected Byte[] m_salt;
    public TlsSrpConfig Config { get; }
    public Byte[] Identity { get; }
    public Byte[] Salt { get; }
    public BigInteger Verifier { get; }
    public TlsSrpLoginParameters(Byte[] identity, TlsSrpConfig srpConfig, BigInteger verifier, Byte[] salt);
    public virtual TlsSrpConfig get_Config();
    public virtual Byte[] get_Identity();
    public virtual Byte[] get_Salt();
    public virtual BigInteger get_Verifier();
}
public abstract class Org.BouncyCastle.Tls.TlsSrpUtilities : object {
    public static void AddSrpExtension(IDictionary extensions, Byte[] identity);
    public static Byte[] GetSrpExtension(IDictionary extensions);
    public static Byte[] CreateSrpExtension(Byte[] identity);
    public static Byte[] ReadSrpExtension(Byte[] extensionData);
    public static BigInteger ReadSrpParameter(Stream input);
    public static void WriteSrpParameter(BigInteger x, Stream output);
    public static bool IsSrpCipherSuite(int cipherSuite);
}
public abstract class Org.BouncyCastle.Tls.TlsSrtpUtilities : object {
    public static void AddUseSrtpExtension(IDictionary extensions, UseSrtpData useSrtpData);
    public static UseSrtpData GetUseSrtpExtension(IDictionary extensions);
    public static Byte[] CreateUseSrtpExtension(UseSrtpData useSrtpData);
    public static UseSrtpData ReadUseSrtpExtension(Byte[] extensionData);
}
internal class Org.BouncyCastle.Tls.TlsStream : Stream {
    private TlsProtocol m_handler;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal TlsStream(TlsProtocol handler);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Close();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buf, int off, int len);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buf, int off, int len);
    public virtual void WriteByte(byte b);
}
public class Org.BouncyCastle.Tls.TlsTimeoutException : IOException {
    public TlsTimeoutException(string message);
    public TlsTimeoutException(string message, Exception cause);
}
public abstract class Org.BouncyCastle.Tls.TlsUtilities : object {
    private static Byte[] DowngradeTlsV11;
    private static Byte[] DowngradeTlsV12;
    private static IDictionary CertSigAlgOids;
    private static IList DefaultSupportedSigAlgs;
    public static Byte[] EmptyBytes;
    public static Int16[] EmptyShorts;
    public static Int32[] EmptyInts;
    public static Int64[] EmptyLongs;
    public static String[] EmptyStrings;
    internal static short MinimumHashStrict;
    internal static short MinimumHashPreferred;
    private static TlsUtilities();
    private static void AddCertSigAlgOid(IDictionary d, DerObjectIdentifier oid, SignatureAndHashAlgorithm sigAndHash);
    private static void AddCertSigAlgOid(IDictionary d, DerObjectIdentifier oid, short hashAlgorithm, short signatureAlgorithm);
    private static IDictionary CreateCertSigAlgOids();
    private static IList CreateDefaultSupportedSigAlgs();
    public static void CheckUint8(short i);
    public static void CheckUint8(int i);
    public static void CheckUint8(long i);
    public static void CheckUint16(int i);
    public static void CheckUint16(long i);
    public static void CheckUint24(int i);
    public static void CheckUint24(long i);
    public static void CheckUint32(long i);
    public static void CheckUint48(long i);
    public static void CheckUint64(long i);
    public static bool IsValidUint8(short i);
    public static bool IsValidUint8(int i);
    public static bool IsValidUint8(long i);
    public static bool IsValidUint16(int i);
    public static bool IsValidUint16(long i);
    public static bool IsValidUint24(int i);
    public static bool IsValidUint24(long i);
    public static bool IsValidUint32(long i);
    public static bool IsValidUint48(long i);
    public static bool IsValidUint64(long i);
    public static bool IsSsl(TlsContext context);
    public static bool IsTlsV10(ProtocolVersion version);
    public static bool IsTlsV10(TlsContext context);
    public static bool IsTlsV11(ProtocolVersion version);
    public static bool IsTlsV11(TlsContext context);
    public static bool IsTlsV12(ProtocolVersion version);
    public static bool IsTlsV12(TlsContext context);
    public static bool IsTlsV13(ProtocolVersion version);
    public static bool IsTlsV13(TlsContext context);
    public static void WriteUint8(short i, Stream output);
    public static void WriteUint8(int i, Stream output);
    public static void WriteUint8(short i, Byte[] buf, int offset);
    public static void WriteUint8(int i, Byte[] buf, int offset);
    public static void WriteUint16(int i, Stream output);
    public static void WriteUint16(int i, Byte[] buf, int offset);
    public static void WriteUint24(int i, Stream output);
    public static void WriteUint24(int i, Byte[] buf, int offset);
    public static void WriteUint32(long i, Stream output);
    public static void WriteUint32(long i, Byte[] buf, int offset);
    public static void WriteUint48(long i, Stream output);
    public static void WriteUint48(long i, Byte[] buf, int offset);
    public static void WriteUint64(long i, Stream output);
    public static void WriteUint64(long i, Byte[] buf, int offset);
    public static void WriteOpaque8(Byte[] buf, Stream output);
    public static void WriteOpaque8(Byte[] data, Byte[] buf, int off);
    public static void WriteOpaque16(Byte[] buf, Stream output);
    public static void WriteOpaque16(Byte[] data, Byte[] buf, int off);
    public static void WriteOpaque24(Byte[] buf, Stream output);
    public static void WriteOpaque24(Byte[] data, Byte[] buf, int off);
    public static void WriteUint8Array(Int16[] u8s, Stream output);
    public static void WriteUint8Array(Int16[] u8s, Byte[] buf, int offset);
    public static void WriteUint8ArrayWithUint8Length(Int16[] u8s, Stream output);
    public static void WriteUint8ArrayWithUint8Length(Int16[] u8s, Byte[] buf, int offset);
    public static void WriteUint16Array(Int32[] u16s, Stream output);
    public static void WriteUint16Array(Int32[] u16s, Byte[] buf, int offset);
    public static void WriteUint16ArrayWithUint16Length(Int32[] u16s, Stream output);
    public static void WriteUint16ArrayWithUint16Length(Int32[] u16s, Byte[] buf, int offset);
    public static Byte[] DecodeOpaque8(Byte[] buf);
    public static Byte[] DecodeOpaque8(Byte[] buf, int minLength);
    public static Byte[] DecodeOpaque16(Byte[] buf);
    public static Byte[] DecodeOpaque16(Byte[] buf, int minLength);
    public static short DecodeUint8(Byte[] buf);
    public static Int16[] DecodeUint8ArrayWithUint8Length(Byte[] buf);
    public static int DecodeUint16(Byte[] buf);
    public static long DecodeUint32(Byte[] buf);
    public static Byte[] EncodeOpaque8(Byte[] buf);
    public static Byte[] EncodeOpaque16(Byte[] buf);
    public static Byte[] EncodeOpaque24(Byte[] buf);
    public static Byte[] EncodeUint8(short u8);
    public static Byte[] EncodeUint8ArrayWithUint8Length(Int16[] u8s);
    public static Byte[] EncodeUint16(int u16);
    public static Byte[] EncodeUint16ArrayWithUint16Length(Int32[] u16s);
    public static Byte[] EncodeUint24(int u24);
    public static Byte[] EncodeUint32(long u32);
    public static Byte[] EncodeVersion(ProtocolVersion version);
    public static int ReadInt32(Byte[] buf, int offset);
    public static short ReadUint8(Stream input);
    public static short ReadUint8(Byte[] buf, int offset);
    public static int ReadUint16(Stream input);
    public static int ReadUint16(Byte[] buf, int offset);
    public static int ReadUint24(Stream input);
    public static int ReadUint24(Byte[] buf, int offset);
    public static long ReadUint32(Stream input);
    public static long ReadUint32(Byte[] buf, int offset);
    public static long ReadUint48(Stream input);
    public static long ReadUint48(Byte[] buf, int offset);
    public static Byte[] ReadAllOrNothing(int length, Stream input);
    public static Byte[] ReadFully(int length, Stream input);
    public static void ReadFully(Byte[] buf, Stream input);
    public static Byte[] ReadOpaque8(Stream input);
    public static Byte[] ReadOpaque8(Stream input, int minLength);
    public static Byte[] ReadOpaque8(Stream input, int minLength, int maxLength);
    public static Byte[] ReadOpaque16(Stream input);
    public static Byte[] ReadOpaque16(Stream input, int minLength);
    public static Byte[] ReadOpaque24(Stream input);
    public static Byte[] ReadOpaque24(Stream input, int minLength);
    public static Int16[] ReadUint8Array(int count, Stream input);
    public static Int16[] ReadUint8ArrayWithUint8Length(Stream input, int minLength);
    public static Int32[] ReadUint16Array(int count, Stream input);
    public static ProtocolVersion ReadVersion(Byte[] buf, int offset);
    public static ProtocolVersion ReadVersion(Stream input);
    public static Asn1Object ReadAsn1Object(Byte[] encoding);
    public static Asn1Object ReadDerObject(Byte[] encoding);
    public static void WriteGmtUnixTime(Byte[] buf, int offset);
    public static void WriteVersion(ProtocolVersion version, Stream output);
    public static void WriteVersion(ProtocolVersion version, Byte[] buf, int offset);
    public static void AddIfSupported(IList supportedAlgs, TlsCrypto crypto, SignatureAndHashAlgorithm alg);
    public static void AddIfSupported(IList supportedGroups, TlsCrypto crypto, int namedGroup);
    public static void AddIfSupported(IList supportedGroups, TlsCrypto crypto, Int32[] namedGroups);
    public static bool AddToSet(IList s, int i);
    public static IList GetDefaultDssSignatureAlgorithms();
    public static IList GetDefaultECDsaSignatureAlgorithms();
    public static IList GetDefaultRsaSignatureAlgorithms();
    public static SignatureAndHashAlgorithm GetDefaultSignatureAlgorithm(short signatureAlgorithm);
    public static IList GetDefaultSignatureAlgorithms(short signatureAlgorithm);
    public static IList GetDefaultSupportedSignatureAlgorithms(TlsContext context);
    public static SignatureAndHashAlgorithm GetSignatureAndHashAlgorithm(TlsContext context, TlsCredentialedSigner signerCredentials);
    internal static SignatureAndHashAlgorithm GetSignatureAndHashAlgorithm(ProtocolVersion negotiatedVersion, TlsCredentialedSigner signerCredentials);
    public static Byte[] GetExtensionData(IDictionary extensions, int extensionType);
    public static bool HasExpectedEmptyExtensionData(IDictionary extensions, int extensionType, short alertDescription);
    public static TlsSession ImportSession(Byte[] sessionID, SessionParameters sessionParameters);
    internal static bool IsExtendedMasterSecretOptionalDtls(ProtocolVersion[] activeProtocolVersions);
    internal static bool IsExtendedMasterSecretOptionalTls(ProtocolVersion[] activeProtocolVersions);
    public static bool IsNullOrContainsNull(Object[] array);
    public static bool IsNullOrEmpty(Byte[] array);
    public static bool IsNullOrEmpty(Int16[] array);
    public static bool IsNullOrEmpty(Int32[] array);
    public static bool IsNullOrEmpty(Object[] array);
    public static bool IsNullOrEmpty(string s);
    public static bool IsNullOrEmpty(IList v);
    public static bool IsSignatureAlgorithmsExtensionAllowed(ProtocolVersion version);
    public static short GetLegacyClientCertType(short signatureAlgorithm);
    public static short GetLegacySignatureAlgorithmClient(short clientCertificateType);
    public static short GetLegacySignatureAlgorithmClientCert(short clientCertificateType);
    public static short GetLegacySignatureAlgorithmServer(int keyExchangeAlgorithm);
    public static short GetLegacySignatureAlgorithmServerCert(int keyExchangeAlgorithm);
    public static IList GetLegacySupportedSignatureAlgorithms();
    public static void EncodeSupportedSignatureAlgorithms(IList supportedSignatureAlgorithms, Stream output);
    public static IList ParseSupportedSignatureAlgorithms(Stream input);
    public static void VerifySupportedSignatureAlgorithm(IList supportedSignatureAlgorithms, SignatureAndHashAlgorithm signatureAlgorithm);
    public static bool ContainsSignatureAlgorithm(IList supportedSignatureAlgorithms, SignatureAndHashAlgorithm signatureAlgorithm);
    public static bool ContainsAnySignatureAlgorithm(IList supportedSignatureAlgorithms, short signatureAlgorithm);
    public static TlsSecret Prf(SecurityParameters securityParameters, TlsSecret secret, string asciiLabel, Byte[] seed, int length);
    public static Byte[] Clone(Byte[] data);
    public static String[] Clone(String[] s);
    public static bool ConstantTimeAreEqual(int len, Byte[] a, int aOff, Byte[] b, int bOff);
    public static Byte[] CopyOfRangeExact(Byte[] original, int from, int to);
    internal static Byte[] Concat(Byte[] a, Byte[] b);
    internal static Byte[] CalculateEndPointHash(TlsContext context, TlsCertificate certificate, Byte[] enc);
    internal static Byte[] CalculateEndPointHash(TlsContext context, TlsCertificate certificate, Byte[] enc, int encOff, int encLen);
    public static Byte[] CalculateExporterSeed(SecurityParameters securityParameters, Byte[] context);
    private static Byte[] CalculateFinishedHmac(SecurityParameters securityParameters, TlsSecret baseKey, Byte[] transcriptHash);
    private static Byte[] CalculateFinishedHmac(int prfCryptoHashAlgorithm, int prfHashLength, TlsSecret baseKey, Byte[] transcriptHash);
    internal static TlsSecret CalculateMasterSecret(TlsContext context, TlsSecret preMasterSecret);
    internal static Byte[] CalculatePskBinder(TlsCrypto crypto, bool isExternalPsk, int pskCryptoHashAlgorithm, TlsSecret earlySecret, Byte[] transcriptHash);
    internal static Byte[] CalculateVerifyData(TlsContext context, TlsHandshakeHash handshakeHash, bool isServer);
    internal static void Establish13PhaseSecrets(TlsContext context, TlsSecret pskEarlySecret, TlsSecret sharedSecret);
    private static void Establish13TrafficSecrets(TlsContext context, Byte[] transcriptHash, TlsSecret phaseSecret, string clientLabel, string serverLabel, RecordStream recordStream);
    internal static void Establish13PhaseApplication(TlsContext context, Byte[] serverFinishedTranscriptHash, RecordStream recordStream);
    internal static void Establish13PhaseEarly(TlsContext context, Byte[] clientHelloTranscriptHash, RecordStream recordStream);
    internal static void Establish13PhaseHandshake(TlsContext context, Byte[] serverHelloTranscriptHash, RecordStream recordStream);
    internal static void Update13TrafficSecretLocal(TlsContext context);
    internal static void Update13TrafficSecretPeer(TlsContext context);
    private static void Update13TrafficSecret(TlsContext context, bool forServer);
    private static TlsSecret Update13TrafficSecret(SecurityParameters securityParameters, TlsSecret secret);
    public static DerObjectIdentifier GetOidForHashAlgorithm(short hashAlgorithm);
    internal static int GetPrfAlgorithm(SecurityParameters securityParameters, int cipherSuite);
    internal static int GetPrfAlgorithm13(int cipherSuite);
    internal static Int32[] GetPrfAlgorithms13(Int32[] cipherSuites);
    internal static Byte[] CalculateSignatureHash(TlsContext context, SignatureAndHashAlgorithm algorithm, Byte[] extraSignatureInput, DigestInputBuffer buf);
    internal static void SendSignatureInput(TlsContext context, Byte[] extraSignatureInput, DigestInputBuffer buf, Stream output);
    internal static DigitallySigned GenerateCertificateVerifyClient(TlsClientContext clientContext, TlsCredentialedSigner credentialedSigner, TlsStreamSigner streamSigner, TlsHandshakeHash handshakeHash);
    internal static DigitallySigned Generate13CertificateVerify(TlsContext context, TlsCredentialedSigner credentialedSigner, TlsHandshakeHash handshakeHash);
    private static Byte[] Generate13CertificateVerify(TlsCrypto crypto, TlsCredentialedSigner credentialedSigner, string contextString, TlsHandshakeHash handshakeHash, SignatureAndHashAlgorithm signatureAndHashAlgorithm);
    internal static void VerifyCertificateVerifyClient(TlsServerContext serverContext, CertificateRequest certificateRequest, DigitallySigned certificateVerify, TlsHandshakeHash handshakeHash);
    internal static void Verify13CertificateVerifyClient(TlsServerContext serverContext, CertificateRequest certificateRequest, DigitallySigned certificateVerify, TlsHandshakeHash handshakeHash);
    internal static void Verify13CertificateVerifyServer(TlsClientContext clientContext, DigitallySigned certificateVerify, TlsHandshakeHash handshakeHash);
    private static bool Verify13CertificateVerify(TlsCrypto crypto, DigitallySigned certificateVerify, TlsVerifier verifier, string contextString, TlsHandshakeHash handshakeHash);
    private static Byte[] GetCertificateVerifyHeader(string contextString);
    internal static void GenerateServerKeyExchangeSignature(TlsContext context, TlsCredentialedSigner credentials, Byte[] extraSignatureInput, DigestInputBuffer digestBuffer);
    internal static void VerifyServerKeyExchangeSignature(TlsContext context, Stream signatureInput, TlsCertificate serverCertificate, Byte[] extraSignatureInput, DigestInputBuffer digestBuffer);
    internal static void TrackHashAlgorithms(TlsHandshakeHash handshakeHash, IList supportedSignatureAlgorithms);
    public static bool HasSigningCapability(short clientCertificateType);
    public static IList VectorOfOne(object obj);
    public static int GetCipherType(int cipherSuite);
    public static int GetEncryptionAlgorithm(int cipherSuite);
    public static int GetEncryptionAlgorithmType(int encryptionAlgorithm);
    public static int GetKeyExchangeAlgorithm(int cipherSuite);
    public static IList GetKeyExchangeAlgorithms(Int32[] cipherSuites);
    public static int GetMacAlgorithm(int cipherSuite);
    public static ProtocolVersion GetMinimumVersion(int cipherSuite);
    public static IList GetNamedGroupRoles(Int32[] cipherSuites);
    public static IList GetNamedGroupRoles(IList keyExchangeAlgorithms);
    public static bool IsAeadCipherSuite(int cipherSuite);
    public static bool IsBlockCipherSuite(int cipherSuite);
    public static bool IsStreamCipherSuite(int cipherSuite);
    public static bool IsValidCipherSuiteForSignatureAlgorithms(int cipherSuite, IList sigAlgs);
    internal static bool IsValidCipherSuiteSelection(Int32[] offeredCipherSuites, int cipherSuite);
    internal static bool IsValidKeyShareSelection(ProtocolVersion negotiatedVersion, Int32[] clientSupportedGroups, IDictionary clientAgreements, int keyShareGroup);
    internal static bool IsValidSignatureAlgorithmForCertificateVerify(short signatureAlgorithm, Int16[] clientCertificateTypes);
    internal static bool IsValidSignatureAlgorithmForServerKeyExchange(short signatureAlgorithm, int keyExchangeAlgorithm);
    public static bool IsValidSignatureSchemeForServerKeyExchange(int signatureScheme, int keyExchangeAlgorithm);
    public static bool IsValidVersionForCipherSuite(int cipherSuite, ProtocolVersion version);
    public static SignatureAndHashAlgorithm ChooseSignatureAndHashAlgorithm(TlsContext context, IList sigHashAlgs, short signatureAlgorithm);
    public static SignatureAndHashAlgorithm ChooseSignatureAndHashAlgorithm(ProtocolVersion negotiatedVersion, IList sigHashAlgs, short signatureAlgorithm);
    public static IList GetUsableSignatureAlgorithms(IList sigHashAlgs);
    public static int GetCommonCipherSuite13(ProtocolVersion negotiatedVersion, Int32[] peerCipherSuites, Int32[] localCipherSuites, bool useLocalOrder);
    public static Int32[] GetCommonCipherSuites(Int32[] peerCipherSuites, Int32[] localCipherSuites, bool useLocalOrder);
    public static Int32[] GetSupportedCipherSuites(TlsCrypto crypto, Int32[] suites);
    public static Int32[] GetSupportedCipherSuites(TlsCrypto crypto, Int32[] suites, int suitesOff, int suitesCount);
    public static bool IsSupportedCipherSuite(TlsCrypto crypto, int cipherSuite);
    public static bool IsSupportedKeyExchange(TlsCrypto crypto, int keyExchangeAlgorithm);
    internal static bool HasAnyRsaSigAlgs(TlsCrypto crypto);
    internal static Byte[] GetCurrentPrfHash(TlsHandshakeHash handshakeHash);
    internal static void SealHandshakeHash(TlsContext context, TlsHandshakeHash handshakeHash, bool forceBuffering);
    private static TlsHash CreateHash(TlsCrypto crypto, short hashAlgorithm);
    private static TlsKeyExchange CreateKeyExchangeClient(TlsClient client, int keyExchange);
    private static TlsKeyExchange CreateKeyExchangeServer(TlsServer server, int keyExchange);
    internal static TlsKeyExchange InitKeyExchangeClient(TlsClientContext clientContext, TlsClient client);
    internal static TlsKeyExchange InitKeyExchangeServer(TlsServerContext serverContext, TlsServer server);
    internal static TlsCipher InitCipher(TlsContext context);
    public static void CheckPeerSigAlgs(TlsContext context, TlsCertificate[] peerCertPath);
    private static void CheckSigAlgOfClientCerts(TlsContext context, TlsCertificate[] clientCertPath);
    private static void CheckSigAlgOfServerCerts(TlsContext context, TlsCertificate[] serverCertPath);
    internal static void CheckTlsFeatures(Certificate serverCertificate, IDictionary clientExtensions, IDictionary serverExtensions);
    internal static void ProcessClientCertificate(TlsServerContext serverContext, Certificate clientCertificate, TlsKeyExchange keyExchange, TlsServer server);
    internal static void ProcessServerCertificate(TlsClientContext clientContext, CertificateStatus serverCertificateStatus, TlsKeyExchange keyExchange, TlsAuthentication clientAuthentication, IDictionary clientExtensions, IDictionary serverExtensions);
    internal static SignatureAndHashAlgorithm GetCertSigAndHashAlg(TlsCertificate subjectCert, TlsCertificate issuerCert);
    internal static CertificateRequest ValidateCertificateRequest(CertificateRequest certificateRequest, TlsKeyExchange keyExchange);
    internal static CertificateRequest NormalizeCertificateRequest(CertificateRequest certificateRequest, Int16[] validClientCertificateTypes);
    internal static bool Contains(Int32[] buf, int off, int len, int value);
    internal static bool ContainsAll(Int16[] container, Int16[] elements);
    internal static Int16[] RetainAll(Int16[] retainer, Int16[] elements);
    internal static Int16[] Truncate(Int16[] a, int n);
    internal static Int32[] Truncate(Int32[] a, int n);
    internal static TlsCredentialedAgreement RequireAgreementCredentials(TlsCredentials credentials);
    internal static TlsCredentialedDecryptor RequireDecryptorCredentials(TlsCredentials credentials);
    internal static TlsCredentialedSigner RequireSignerCredentials(TlsCredentials credentials);
    private static void CheckDowngradeMarker(Byte[] randomBlock, Byte[] downgradeMarker);
    internal static void CheckDowngradeMarker(ProtocolVersion version, Byte[] randomBlock);
    internal static void WriteDowngradeMarker(ProtocolVersion version, Byte[] randomBlock);
    internal static TlsAuthentication ReceiveServerCertificate(TlsClientContext clientContext, TlsClient client, MemoryStream buf);
    internal static TlsAuthentication Receive13ServerCertificate(TlsClientContext clientContext, TlsClient client, MemoryStream buf);
    internal static TlsAuthentication Skip13ServerCertificate(TlsClientContext clientContext);
    public static bool ContainsNonAscii(Byte[] bs);
    public static bool ContainsNonAscii(string s);
    internal static IDictionary AddKeyShareToClientHello(TlsClientContext clientContext, TlsClient client, IDictionary clientExtensions);
    internal static IDictionary AddKeyShareToClientHelloRetry(TlsClientContext clientContext, IDictionary clientExtensions, int keyShareGroup);
    private static void CollectKeyShares(TlsCrypto crypto, Int32[] supportedGroups, IList keyShareGroups, IDictionary clientAgreements, IList clientShares);
    internal static KeyShareEntry SelectKeyShare(IList clientShares, int keyShareGroup);
    internal static KeyShareEntry SelectKeyShare(TlsCrypto crypto, ProtocolVersion negotiatedVersion, IList clientShares, Int32[] clientSupportedGroups, Int32[] serverSupportedGroups);
    internal static int SelectKeyShareGroup(TlsCrypto crypto, ProtocolVersion negotiatedVersion, Int32[] clientSupportedGroups, Int32[] serverSupportedGroups);
    internal static Byte[] ReadEncryptedPms(TlsContext context, Stream input);
    internal static void WriteEncryptedPms(TlsContext context, Byte[] encryptedPms, Stream output);
    internal static Byte[] GetSessionID(TlsSession tlsSession);
    internal static void AdjustTranscriptForRetry(TlsHandshakeHash handshakeHash);
    internal static TlsCredentials EstablishClientCredentials(TlsAuthentication clientAuthentication, CertificateRequest certificateRequest);
    internal static TlsCredentialedSigner Establish13ClientCredentials(TlsAuthentication clientAuthentication, CertificateRequest certificateRequest);
    internal static void EstablishClientSigAlgs(SecurityParameters securityParameters, IDictionary clientExtensions);
    internal static TlsCredentials EstablishServerCredentials(TlsServer server);
    internal static TlsCredentialedSigner Establish13ServerCredentials(TlsServer server);
    internal static void EstablishServerSigAlgs(SecurityParameters securityParameters, CertificateRequest certificateRequest);
    internal static TlsCredentials ValidateCredentials(TlsCredentials credentials);
    internal static TlsCredentialedSigner Validate13Credentials(TlsCredentials credentials);
    internal static void NegotiatedCipherSuite(SecurityParameters securityParameters, int cipherSuite);
    internal static void NegotiatedVersion(SecurityParameters securityParameters);
    internal static void NegotiatedVersionDtlsClient(TlsClientContext clientContext, TlsClient client);
    internal static void NegotiatedVersionDtlsServer(TlsServerContext serverContext);
    internal static void NegotiatedVersionTlsClient(TlsClientContext clientContext, TlsClient client);
    internal static void NegotiatedVersionTlsServer(TlsServerContext serverContext);
    internal static TlsSecret DeriveSecret(SecurityParameters securityParameters, TlsSecret secret, string label, Byte[] transcriptHash);
    internal static TlsSecret DeriveSecret(int prfCryptoHashAlgorithm, int prfHashLength, TlsSecret secret, string label, Byte[] transcriptHash);
    internal static TlsSecret GetSessionMasterSecret(TlsCrypto crypto, TlsSecret masterSecret);
    internal static bool IsPermittedExtensionType13(int handshakeType, int extensionType);
    internal static void CheckExtensionData13(IDictionary extensions, int handshakeType, short alertDescription);
    public static TlsSecret GenerateEncryptedPreMasterSecret(TlsContext context, TlsEncryptor encryptor, Stream output);
    public static bool IsTimeout(SocketException e);
    internal static void AddPreSharedKeyToClientExtensions(TlsPsk[] psks, IDictionary clientExtensions);
    internal static BindersConfig AddPreSharedKeyToClientHello(TlsClientContext clientContext, TlsClient client, IDictionary clientExtensions, Int32[] offeredCipherSuites);
    internal static BindersConfig AddPreSharedKeyToClientHelloRetry(TlsClientContext clientContext, BindersConfig clientBinders, IDictionary clientExtensions);
    internal static SelectedConfig SelectPreSharedKey(TlsServerContext serverContext, TlsServer server, IDictionary clientHelloExtensions, HandshakeMessageInput clientHelloMessage, TlsHandshakeHash handshakeHash, bool afterHelloRetryRequest);
    internal static TlsSecret GetPskEarlySecret(TlsCrypto crypto, TlsPsk psk);
    internal static TlsSecret[] GetPskEarlySecrets(TlsCrypto crypto, TlsPsk[] psks);
    internal static TlsPskExternal[] GetPskExternalsClient(TlsClient client, Int32[] offeredCipherSuites);
    internal static IList GetPskIndices(TlsPsk[] psks, int prfAlgorithm);
}
public class Org.BouncyCastle.Tls.TrustedAuthority : object {
    private short m_identifierType;
    private object m_identifier;
    public short IdentifierType { get; }
    public object Identifier { get; }
    public X509Name X509Name { get; }
    public TrustedAuthority(short identifierType, object identifier);
    public short get_IdentifierType();
    public object get_Identifier();
    public Byte[] GetCertSha1Hash();
    public Byte[] GetKeySha1Hash();
    public X509Name get_X509Name();
    public void Encode(Stream output);
    public static TrustedAuthority Parse(Stream input);
    private void CheckCorrectType(short expectedIdentifierType);
    private static bool IsCorrectType(short identifierType, object identifier);
    private static bool IsSha1Hash(object identifier);
}
public class Org.BouncyCastle.Tls.UrlAndHash : object {
    private string m_url;
    private Byte[] m_sha1Hash;
    public string Url { get; }
    public Byte[] Sha1Hash { get; }
    public UrlAndHash(string url, Byte[] sha1Hash);
    public string get_Url();
    public Byte[] get_Sha1Hash();
    public void Encode(Stream output);
    public static UrlAndHash Parse(TlsContext context, Stream input);
}
public abstract class Org.BouncyCastle.Tls.UserMappingType : object {
    public static short upn_domain_hint;
}
public class Org.BouncyCastle.Tls.UseSrtpData : object {
    private Int32[] m_protectionProfiles;
    private Byte[] m_mki;
    public Int32[] ProtectionProfiles { get; }
    public Byte[] Mki { get; }
    public UseSrtpData(Int32[] protectionProfiles, Byte[] mki);
    public Int32[] get_ProtectionProfiles();
    public Byte[] get_Mki();
}
public class Org.BouncyCastle.Tsp.GenTimeAccuracy : object {
    private Accuracy accuracy;
    public int Seconds { get; }
    public int Millis { get; }
    public int Micros { get; }
    public GenTimeAccuracy(Accuracy accuracy);
    public int get_Seconds();
    public int get_Millis();
    public int get_Micros();
    private int GetTimeComponent(DerInteger time);
    public virtual string ToString();
}
public enum Org.BouncyCastle.Tsp.Resolution : Enum {
    public int value__;
    public static Resolution R_SECONDS;
    public static Resolution R_TENTHS_OF_SECONDS;
    public static Resolution R_HUNDREDTHS_OF_SECONDS;
    public static Resolution R_MILLISECONDS;
}
public class Org.BouncyCastle.Tsp.TimeStampRequest : X509ExtensionBase {
    private TimeStampReq req;
    private X509Extensions extensions;
    public int Version { get; }
    public string MessageImprintAlgOid { get; }
    public string ReqPolicy { get; }
    public BigInteger Nonce { get; }
    public bool CertReq { get; }
    internal X509Extensions Extensions { get; }
    public bool HasExtensions { get; }
    public TimeStampRequest(TimeStampReq req);
    public TimeStampRequest(Byte[] req);
    public TimeStampRequest(Stream input);
    private TimeStampRequest(Asn1InputStream str);
    public int get_Version();
    public string get_MessageImprintAlgOid();
    public Byte[] GetMessageImprintDigest();
    public string get_ReqPolicy();
    public BigInteger get_Nonce();
    public bool get_CertReq();
    public void Validate(IList algorithms, IList policies, IList extensions);
    public Byte[] GetEncoded();
    internal X509Extensions get_Extensions();
    public virtual bool get_HasExtensions();
    public virtual X509Extension GetExtension(DerObjectIdentifier oid);
    public virtual IList GetExtensionOids();
    protected virtual X509Extensions GetX509Extensions();
}
public class Org.BouncyCastle.Tsp.TimeStampRequestGenerator : object {
    private DerObjectIdentifier reqPolicy;
    private DerBoolean certReq;
    private IDictionary extensions;
    private IList extOrdering;
    public void SetReqPolicy(string reqPolicy);
    public void SetCertReq(bool certReq);
    [ObsoleteAttribute("Use method taking DerObjectIdentifier")]
public void AddExtension(string oid, bool critical, Asn1Encodable value);
    [ObsoleteAttribute("Use method taking DerObjectIdentifier")]
public void AddExtension(string oid, bool critical, Byte[] value);
    public virtual void AddExtension(DerObjectIdentifier oid, bool critical, Asn1Encodable extValue);
    public virtual void AddExtension(DerObjectIdentifier oid, bool critical, Byte[] extValue);
    public TimeStampRequest Generate(string digestAlgorithm, Byte[] digest);
    public TimeStampRequest Generate(string digestAlgorithmOid, Byte[] digest, BigInteger nonce);
    public virtual TimeStampRequest Generate(DerObjectIdentifier digestAlgorithm, Byte[] digest);
    public virtual TimeStampRequest Generate(DerObjectIdentifier digestAlgorithm, Byte[] digest, BigInteger nonce);
}
public class Org.BouncyCastle.Tsp.TimeStampResponse : object {
    private TimeStampResp resp;
    private TimeStampToken timeStampToken;
    public int Status { get; }
    public TimeStampToken TimeStampToken { get; }
    public TimeStampResponse(TimeStampResp resp);
    public TimeStampResponse(Byte[] resp);
    public TimeStampResponse(Stream input);
    private static TimeStampResp readTimeStampResp(Asn1InputStream input);
    public int get_Status();
    public string GetStatusString();
    public PkiFailureInfo GetFailInfo();
    public TimeStampToken get_TimeStampToken();
    public void Validate(TimeStampRequest request);
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Tsp.TimeStampResponseGenerator : object {
    private PkiStatus status;
    private Asn1EncodableVector statusStrings;
    private int failInfo;
    private TimeStampTokenGenerator tokenGenerator;
    private IList acceptedAlgorithms;
    private IList acceptedPolicies;
    private IList acceptedExtensions;
    public TimeStampResponseGenerator(TimeStampTokenGenerator tokenGenerator, IList acceptedAlgorithms);
    public TimeStampResponseGenerator(TimeStampTokenGenerator tokenGenerator, IList acceptedAlgorithms, IList acceptedPolicy);
    public TimeStampResponseGenerator(TimeStampTokenGenerator tokenGenerator, IList acceptedAlgorithms, IList acceptedPolicies, IList acceptedExtensions);
    private void AddStatusString(string statusString);
    private void SetFailInfoField(int field);
    private PkiStatusInfo GetPkiStatusInfo();
    public TimeStampResponse Generate(TimeStampRequest request, BigInteger serialNumber, DateTime genTime);
    public TimeStampResponse Generate(TimeStampRequest request, BigInteger serialNumber, DateTimeObject genTime);
    public TimeStampResponse GenerateGrantedResponse(TimeStampRequest request, BigInteger serialNumber, DateTimeObject genTime, string statusString, X509Extensions additionalExtensions);
    public TimeStampResponse GenerateFailResponse(PkiStatus status, int failInfoField, string statusString);
}
public class Org.BouncyCastle.Tsp.TimeStampToken : object {
    private CmsSignedData tsToken;
    private SignerInformation tsaSignerInfo;
    private TimeStampTokenInfo tstInfo;
    private CertID certID;
    public TimeStampTokenInfo TimeStampInfo { get; }
    public SignerID SignerID { get; }
    public AttributeTable SignedAttributes { get; }
    public AttributeTable UnsignedAttributes { get; }
    public TimeStampToken(ContentInfo contentInfo);
    public TimeStampToken(CmsSignedData signedData);
    public TimeStampTokenInfo get_TimeStampInfo();
    public SignerID get_SignerID();
    public AttributeTable get_SignedAttributes();
    public AttributeTable get_UnsignedAttributes();
    public IX509Store GetCertificates(string type);
    public IX509Store GetCrls(string type);
    public IX509Store GetCertificates();
    public IX509Store GetAttributeCertificates(string type);
    public void Validate(X509Certificate cert);
    public CmsSignedData ToCmsSignedData();
    public Byte[] GetEncoded();
    public Byte[] GetEncoded(string encoding);
}
public class Org.BouncyCastle.Tsp.TimeStampTokenGenerator : object {
    private int accuracySeconds;
    private int accuracyMillis;
    private int accuracyMicros;
    private bool ordering;
    private GeneralName tsa;
    private DerObjectIdentifier tsaPolicyOID;
    private IX509Store x509Certs;
    private IX509Store x509Crls;
    private SignerInfoGenerator signerInfoGenerator;
    private IDigestFactory digestCalculator;
    private Resolution resolution;
    public Resolution Resolution { get; public set; }
    public TimeStampTokenGenerator(AsymmetricKeyParameter key, X509Certificate cert, string digestOID, string tsaPolicyOID);
    public TimeStampTokenGenerator(SignerInfoGenerator signerInfoGen, IDigestFactory digestCalculator, DerObjectIdentifier tsaPolicy, bool isIssuerSerialIncluded);
    public TimeStampTokenGenerator(AsymmetricKeyParameter key, X509Certificate cert, string digestOID, string tsaPolicyOID, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public Resolution get_Resolution();
    public void set_Resolution(Resolution value);
    internal static SignerInfoGenerator makeInfoGenerator(AsymmetricKeyParameter key, X509Certificate cert, string digestOID, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void SetCertificates(IX509Store certificates);
    public void SetCrls(IX509Store crls);
    public void SetAccuracySeconds(int accuracySeconds);
    public void SetAccuracyMillis(int accuracyMillis);
    public void SetAccuracyMicros(int accuracyMicros);
    public void SetOrdering(bool ordering);
    public void SetTsa(GeneralName tsa);
    public TimeStampToken Generate(TimeStampRequest request, BigInteger serialNumber, DateTime genTime);
    public TimeStampToken Generate(TimeStampRequest request, BigInteger serialNumber, DateTime genTime, X509Extensions additionalExtensions);
    private string createGeneralizedTime(DateTime genTime);
}
public class Org.BouncyCastle.Tsp.TimeStampTokenInfo : object {
    private TstInfo tstInfo;
    private DateTime genTime;
    public bool IsOrdered { get; }
    public Accuracy Accuracy { get; }
    public DateTime GenTime { get; }
    public GenTimeAccuracy GenTimeAccuracy { get; }
    public string Policy { get; }
    public BigInteger SerialNumber { get; }
    public GeneralName Tsa { get; }
    public BigInteger Nonce { get; }
    public AlgorithmIdentifier HashAlgorithm { get; }
    public string MessageImprintAlgOid { get; }
    public TstInfo TstInfo { get; }
    public TimeStampTokenInfo(TstInfo tstInfo);
    public bool get_IsOrdered();
    public Accuracy get_Accuracy();
    public DateTime get_GenTime();
    public GenTimeAccuracy get_GenTimeAccuracy();
    public string get_Policy();
    public BigInteger get_SerialNumber();
    public GeneralName get_Tsa();
    public BigInteger get_Nonce();
    public AlgorithmIdentifier get_HashAlgorithm();
    public string get_MessageImprintAlgOid();
    public Byte[] GetMessageImprintDigest();
    public Byte[] GetEncoded();
    public TstInfo get_TstInfo();
}
public abstract class Org.BouncyCastle.Tsp.TspAlgorithms : object {
    public static string MD5;
    public static string Sha1;
    public static string Sha224;
    public static string Sha256;
    public static string Sha384;
    public static string Sha512;
    public static string RipeMD128;
    public static string RipeMD160;
    public static string RipeMD256;
    public static string Gost3411;
    public static string Gost3411_2012_256;
    public static string Gost3411_2012_512;
    public static string SM3;
    public static IList Allowed;
    private static TspAlgorithms();
}
public class Org.BouncyCastle.Tsp.TspException : Exception {
    public TspException(string message);
    public TspException(string message, Exception e);
}
public class Org.BouncyCastle.Tsp.TspUtil : object {
    private static ISet EmptySet;
    private static IList EmptyList;
    private static IDictionary digestLengths;
    private static IDictionary digestNames;
    private static TspUtil();
    public static ICollection GetSignatureTimestamps(SignerInformation signerInfo);
    public static void ValidateCertificate(X509Certificate cert);
    internal static string GetDigestAlgName(string digestAlgOID);
    internal static int GetDigestLength(string digestAlgOID);
    internal static IDigest CreateDigestInstance(string digestAlgOID);
    internal static ISet GetCriticalExtensionOids(X509Extensions extensions);
    internal static ISet GetNonCriticalExtensionOids(X509Extensions extensions);
    internal static IList GetExtensionOids(X509Extensions extensions);
}
public class Org.BouncyCastle.Tsp.TspValidationException : TspException {
    private int failureCode;
    public int FailureCode { get; }
    public TspValidationException(string message);
    public TspValidationException(string message, int failureCode);
    public int get_FailureCode();
}
public abstract class Org.BouncyCastle.Utilities.Arrays : object {
    public static Byte[] EmptyBytes;
    public static Int32[] EmptyInts;
    private static Arrays();
    public static bool AreAllZeroes(Byte[] buf, int off, int len);
    public static bool AreEqual(Boolean[] a, Boolean[] b);
    public static bool AreEqual(Char[] a, Char[] b);
    public static bool AreEqual(Byte[] a, Byte[] b);
    public static bool AreEqual(Byte[] a, int aFromIndex, int aToIndex, Byte[] b, int bFromIndex, int bToIndex);
    [ObsoleteAttribute("Use 'AreEqual' method instead")]
public static bool AreSame(Byte[] a, Byte[] b);
    public static bool ConstantTimeAreEqual(Byte[] a, Byte[] b);
    public static bool ConstantTimeAreEqual(int len, Byte[] a, int aOff, Byte[] b, int bOff);
    public static bool AreEqual(Int32[] a, Int32[] b);
    [CLSCompliantAttribute("False")]
public static bool AreEqual(UInt32[] a, UInt32[] b);
    public static bool AreEqual(Int64[] a, Int64[] b);
    [CLSCompliantAttribute("False")]
public static bool AreEqual(UInt64[] a, UInt64[] b);
    private static bool HaveSameContents(Boolean[] a, Boolean[] b);
    private static bool HaveSameContents(Char[] a, Char[] b);
    private static bool HaveSameContents(Byte[] a, Byte[] b);
    private static bool HaveSameContents(Int32[] a, Int32[] b);
    private static bool HaveSameContents(UInt32[] a, UInt32[] b);
    private static bool HaveSameContents(Int64[] a, Int64[] b);
    private static bool HaveSameContents(UInt64[] a, UInt64[] b);
    public static string ToString(Object[] a);
    public static int GetHashCode(Byte[] data);
    public static int GetHashCode(Byte[] data, int off, int len);
    public static int GetHashCode(Int32[] data);
    [CLSCompliantAttribute("False")]
public static int GetHashCode(UInt16[] data);
    public static int GetHashCode(Int32[] data, int off, int len);
    [CLSCompliantAttribute("False")]
public static int GetHashCode(UInt32[] data);
    [CLSCompliantAttribute("False")]
public static int GetHashCode(UInt32[] data, int off, int len);
    [CLSCompliantAttribute("False")]
public static int GetHashCode(UInt64[] data);
    [CLSCompliantAttribute("False")]
public static int GetHashCode(UInt64[] data, int off, int len);
    public static Boolean[] Clone(Boolean[] data);
    public static Byte[] Clone(Byte[] data);
    public static Int16[] Clone(Int16[] data);
    [CLSCompliantAttribute("False")]
public static UInt16[] Clone(UInt16[] data);
    public static Int32[] Clone(Int32[] data);
    [CLSCompliantAttribute("False")]
public static UInt32[] Clone(UInt32[] data);
    public static Int64[] Clone(Int64[] data);
    [CLSCompliantAttribute("False")]
public static UInt64[] Clone(UInt64[] data);
    public static Byte[] Clone(Byte[] data, Byte[] existing);
    [CLSCompliantAttribute("False")]
public static UInt64[] Clone(UInt64[] data, UInt64[] existing);
    public static bool Contains(Byte[] a, byte n);
    public static bool Contains(Int16[] a, short n);
    public static bool Contains(Int32[] a, int n);
    public static void Fill(Byte[] buf, byte b);
    public static void Fill(Byte[] buf, int from, int to, byte b);
    public static Byte[] CopyOf(Byte[] data, int newLength);
    public static Char[] CopyOf(Char[] data, int newLength);
    public static Int32[] CopyOf(Int32[] data, int newLength);
    public static Int64[] CopyOf(Int64[] data, int newLength);
    public static BigInteger[] CopyOf(BigInteger[] data, int newLength);
    public static Byte[] CopyOfRange(Byte[] data, int from, int to);
    public static Int32[] CopyOfRange(Int32[] data, int from, int to);
    public static Int64[] CopyOfRange(Int64[] data, int from, int to);
    public static BigInteger[] CopyOfRange(BigInteger[] data, int from, int to);
    private static int GetLength(int from, int to);
    public static Byte[] Append(Byte[] a, byte b);
    public static Int16[] Append(Int16[] a, short b);
    public static Int32[] Append(Int32[] a, int b);
    public static Byte[] Concatenate(Byte[] a, Byte[] b);
    [CLSCompliantAttribute("False")]
public static UInt16[] Concatenate(UInt16[] a, UInt16[] b);
    public static Byte[] ConcatenateAll(Byte[][] vs);
    public static Int32[] Concatenate(Int32[] a, Int32[] b);
    public static Byte[] Prepend(Byte[] a, byte b);
    public static Int16[] Prepend(Int16[] a, short b);
    public static Int32[] Prepend(Int32[] a, int b);
    public static Byte[] Reverse(Byte[] a);
    public static Int32[] Reverse(Int32[] a);
    public static Byte[] ReverseInPlace(Byte[] a);
    public static Int32[] ReverseInPlace(Int32[] a);
    public static void Clear(Byte[] data);
    public static void Clear(Int32[] data);
    public static bool IsNullOrContainsNull(Object[] array);
    public static bool IsNullOrEmpty(Byte[] array);
    public static bool IsNullOrEmpty(Object[] array);
}
public abstract class Org.BouncyCastle.Utilities.BigIntegers : object {
    public static BigInteger Zero;
    public static BigInteger One;
    private static int MaxIterations;
    private static BigIntegers();
    public static Byte[] AsUnsignedByteArray(BigInteger n);
    public static Byte[] AsUnsignedByteArray(int length, BigInteger n);
    public static void AsUnsignedByteArray(BigInteger value, Byte[] buf, int off, int len);
    public static BigInteger CreateRandomBigInteger(int bitLength, SecureRandom secureRandom);
    public static BigInteger CreateRandomInRange(BigInteger min, BigInteger max, SecureRandom random);
    public static BigInteger ModOddInverse(BigInteger M, BigInteger X);
    public static BigInteger ModOddInverseVar(BigInteger M, BigInteger X);
    public static int GetUnsignedByteLength(BigInteger n);
}
public abstract class Org.BouncyCastle.Utilities.Bytes : object {
    public static int NumBits;
    public static int NumBytes;
}
public abstract class Org.BouncyCastle.Utilities.Collections.CollectionUtilities : object {
    public static void AddRange(IList to, IEnumerable range);
    public static bool CheckElementsAreOfType(IEnumerable e, Type t);
    public static IDictionary ReadOnly(IDictionary d);
    public static IList ReadOnly(IList l);
    public static ISet ReadOnly(ISet s);
    public static object RequireNext(IEnumerator e);
    public static string ToString(IEnumerable c);
}
public class Org.BouncyCastle.Utilities.Collections.EmptyEnumerable : object {
    public static IEnumerable Instance;
    private static EmptyEnumerable();
    public sealed virtual IEnumerator GetEnumerator();
}
public class Org.BouncyCastle.Utilities.Collections.EmptyEnumerator : object {
    public static IEnumerator Instance;
    public object Current { get; }
    private static EmptyEnumerator();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual object get_Current();
}
public class Org.BouncyCastle.Utilities.Collections.EnumerableProxy : object {
    private IEnumerable inner;
    public EnumerableProxy(IEnumerable inner);
    public sealed virtual IEnumerator GetEnumerator();
}
public class Org.BouncyCastle.Utilities.Collections.HashSet : object {
    private IDictionary impl;
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public HashSet(IEnumerable s);
    public virtual void Add(object o);
    public virtual void AddAll(IEnumerable e);
    public virtual void Clear();
    public virtual bool Contains(object o);
    public virtual void CopyTo(Array array, int index);
    public virtual int get_Count();
    public virtual IEnumerator GetEnumerator();
    public virtual bool get_IsEmpty();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    public virtual void Remove(object o);
    public virtual void RemoveAll(IEnumerable e);
    public virtual object get_SyncRoot();
}
public interface Org.BouncyCastle.Utilities.Collections.ISet {
    public bool IsEmpty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public abstract virtual void Add(object o);
    public abstract virtual void AddAll(IEnumerable e);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(object o);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual bool get_IsFixedSize();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual void Remove(object o);
    public abstract virtual void RemoveAll(IEnumerable e);
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Utilities.Collections.LinkedDictionary : object {
    internal IDictionary hash;
    internal IList keys;
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public object Item { get; public set; }
    public virtual void Add(object k, object v);
    public virtual void Clear();
    public virtual bool Contains(object k);
    public virtual void CopyTo(Array array, int index);
    public virtual int get_Count();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual IDictionaryEnumerator GetEnumerator();
    public virtual void Remove(object k);
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    public virtual ICollection get_Keys();
    public virtual ICollection get_Values();
    public virtual object get_Item(object k);
    public virtual void set_Item(object k, object value);
}
internal class Org.BouncyCastle.Utilities.Collections.LinkedDictionaryEnumerator : object {
    private LinkedDictionary parent;
    private int pos;
    public object Current { get; }
    public DictionaryEntry Entry { get; }
    public object Key { get; }
    public object Value { get; }
    private object CurrentKey { get; }
    internal LinkedDictionaryEnumerator(LinkedDictionary parent);
    public virtual object get_Current();
    public virtual DictionaryEntry get_Entry();
    public virtual object get_Key();
    public virtual bool MoveNext();
    public virtual void Reset();
    public virtual object get_Value();
    private object get_CurrentKey();
}
[DefaultMemberAttribute("Item")]
public abstract class Org.BouncyCastle.Utilities.Collections.UnmodifiableDictionary : object {
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public object Item { get; public set; }
    public virtual void Add(object k, object v);
    public virtual void Clear();
    public abstract virtual bool Contains(object k);
    public abstract virtual void CopyTo(Array array, int index);
    public abstract virtual int get_Count();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public abstract virtual IDictionaryEnumerator GetEnumerator();
    public virtual void Remove(object k);
    public abstract virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsSynchronized();
    public abstract virtual object get_SyncRoot();
    public abstract virtual ICollection get_Keys();
    public abstract virtual ICollection get_Values();
    public virtual object get_Item(object k);
    public virtual void set_Item(object k, object value);
    protected abstract virtual object GetValue(object k);
}
public class Org.BouncyCastle.Utilities.Collections.UnmodifiableDictionaryProxy : UnmodifiableDictionary {
    private IDictionary d;
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public UnmodifiableDictionaryProxy(IDictionary d);
    public virtual bool Contains(object k);
    public virtual void CopyTo(Array array, int index);
    public virtual int get_Count();
    public virtual IDictionaryEnumerator GetEnumerator();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    public virtual ICollection get_Keys();
    public virtual ICollection get_Values();
    protected virtual object GetValue(object k);
}
[DefaultMemberAttribute("Item")]
public abstract class Org.BouncyCastle.Utilities.Collections.UnmodifiableList : object {
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public object Item { get; public set; }
    public virtual int Add(object o);
    public virtual void Clear();
    public abstract virtual bool Contains(object o);
    public abstract virtual void CopyTo(Array array, int index);
    public abstract virtual int get_Count();
    public abstract virtual IEnumerator GetEnumerator();
    public abstract virtual int IndexOf(object o);
    public virtual void Insert(int i, object o);
    public abstract virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsSynchronized();
    public virtual void Remove(object o);
    public virtual void RemoveAt(int i);
    public abstract virtual object get_SyncRoot();
    public virtual object get_Item(int i);
    public virtual void set_Item(int i, object value);
    protected abstract virtual object GetValue(int i);
}
public class Org.BouncyCastle.Utilities.Collections.UnmodifiableListProxy : UnmodifiableList {
    private IList l;
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public UnmodifiableListProxy(IList l);
    public virtual bool Contains(object o);
    public virtual void CopyTo(Array array, int index);
    public virtual int get_Count();
    public virtual IEnumerator GetEnumerator();
    public virtual int IndexOf(object o);
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    protected virtual object GetValue(int i);
}
public abstract class Org.BouncyCastle.Utilities.Collections.UnmodifiableSet : object {
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public virtual void Add(object o);
    public virtual void AddAll(IEnumerable e);
    public virtual void Clear();
    public abstract virtual bool Contains(object o);
    public abstract virtual void CopyTo(Array array, int index);
    public abstract virtual int get_Count();
    public abstract virtual IEnumerator GetEnumerator();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsSynchronized();
    public abstract virtual object get_SyncRoot();
    public virtual void Remove(object o);
    public virtual void RemoveAll(IEnumerable e);
}
public class Org.BouncyCastle.Utilities.Collections.UnmodifiableSetProxy : UnmodifiableSet {
    private ISet s;
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public UnmodifiableSetProxy(ISet s);
    public virtual bool Contains(object o);
    public virtual void CopyTo(Array array, int index);
    public virtual int get_Count();
    public virtual IEnumerator GetEnumerator();
    public virtual bool get_IsEmpty();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
}
public class Org.BouncyCastle.Utilities.Date.DateTimeObject : object {
    private DateTime dt;
    public DateTime Value { get; }
    public DateTimeObject(DateTime dt);
    public DateTime get_Value();
    public virtual string ToString();
}
public class Org.BouncyCastle.Utilities.Date.DateTimeUtilities : object {
    public static DateTime UnixEpoch;
    private static DateTimeUtilities();
    public static long DateTimeToUnixMs(DateTime dateTime);
    public static DateTime UnixMsToDateTime(long unixMs);
    public static long CurrentUnixMs();
}
public class Org.BouncyCastle.Utilities.Encoders.Base64 : object {
    public static string ToBase64String(Byte[] data);
    public static string ToBase64String(Byte[] data, int off, int length);
    public static Byte[] Encode(Byte[] data);
    public static Byte[] Encode(Byte[] data, int off, int length);
    public static int Encode(Byte[] data, Stream outStream);
    public static int Encode(Byte[] data, int off, int length, Stream outStream);
    public static Byte[] Decode(Byte[] data);
    public static Byte[] Decode(string data);
    public static int Decode(string data, Stream outStream);
}
public class Org.BouncyCastle.Utilities.Encoders.Base64Encoder : object {
    protected Byte[] encodingTable;
    protected byte padding;
    protected Byte[] decodingTable;
    protected void InitialiseDecodingTable();
    public int Encode(Byte[] inBuf, int inOff, int inLen, Byte[] outBuf, int outOff);
    public sealed virtual int Encode(Byte[] buf, int off, int len, Stream outStream);
    private bool Ignore(char c);
    public sealed virtual int Decode(Byte[] data, int off, int length, Stream outStream);
    private int NextI(Byte[] data, int i, int finish);
    public sealed virtual int DecodeString(string data, Stream outStream);
    private int DecodeLastBlock(Stream outStream, char c1, char c2, char c3, char c4);
    private int NextI(string data, int i, int finish);
}
public class Org.BouncyCastle.Utilities.Encoders.BufferedDecoder : object {
    internal Byte[] buffer;
    internal int bufOff;
    internal ITranslator translator;
    public BufferedDecoder(ITranslator translator, int bufferSize);
    public int ProcessByte(byte input, Byte[] output, int outOff);
    public int ProcessBytes(Byte[] input, int inOff, int len, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Utilities.Encoders.BufferedEncoder : object {
    internal Byte[] Buffer;
    internal int bufOff;
    internal ITranslator translator;
    public BufferedEncoder(ITranslator translator, int bufferSize);
    public int ProcessByte(byte input, Byte[] outBytes, int outOff);
    public int ProcessBytes(Byte[] input, int inOff, int len, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Utilities.Encoders.Hex : object {
    private static HexEncoder encoder;
    private static Hex();
    public static string ToHexString(Byte[] data);
    public static string ToHexString(Byte[] data, int off, int length);
    public static Byte[] Encode(Byte[] data);
    public static Byte[] Encode(Byte[] data, int off, int length);
    public static int Encode(Byte[] data, Stream outStream);
    public static int Encode(Byte[] data, int off, int length, Stream outStream);
    public static Byte[] Decode(Byte[] data);
    public static Byte[] Decode(string data);
    public static int Decode(string data, Stream outStream);
    public static Byte[] DecodeStrict(string str);
    public static Byte[] DecodeStrict(string str, int off, int len);
}
public class Org.BouncyCastle.Utilities.Encoders.HexEncoder : object {
    protected Byte[] encodingTable;
    protected Byte[] decodingTable;
    protected void InitialiseDecodingTable();
    public int Encode(Byte[] inBuf, int inOff, int inLen, Byte[] outBuf, int outOff);
    public sealed virtual int Encode(Byte[] buf, int off, int len, Stream outStream);
    private static bool Ignore(char c);
    public sealed virtual int Decode(Byte[] data, int off, int length, Stream outStream);
    public sealed virtual int DecodeString(string data, Stream outStream);
    internal Byte[] DecodeStrict(string str, int off, int len);
}
public class Org.BouncyCastle.Utilities.Encoders.HexTranslator : object {
    private static Byte[] hexTable;
    private static HexTranslator();
    public sealed virtual int GetEncodedBlockSize();
    public sealed virtual int Encode(Byte[] input, int inOff, int length, Byte[] outBytes, int outOff);
    public sealed virtual int GetDecodedBlockSize();
    public sealed virtual int Decode(Byte[] input, int inOff, int length, Byte[] outBytes, int outOff);
}
public interface Org.BouncyCastle.Utilities.Encoders.IEncoder {
    public abstract virtual int Encode(Byte[] data, int off, int length, Stream outStream);
    public abstract virtual int Decode(Byte[] data, int off, int length, Stream outStream);
    public abstract virtual int DecodeString(string data, Stream outStream);
}
public interface Org.BouncyCastle.Utilities.Encoders.ITranslator {
    public abstract virtual int GetEncodedBlockSize();
    public abstract virtual int Encode(Byte[] input, int inOff, int length, Byte[] outBytes, int outOff);
    public abstract virtual int GetDecodedBlockSize();
    public abstract virtual int Decode(Byte[] input, int inOff, int length, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Utilities.Encoders.UrlBase64 : object {
    private static IEncoder encoder;
    private static UrlBase64();
    public static Byte[] Encode(Byte[] data);
    public static int Encode(Byte[] data, Stream outStr);
    public static Byte[] Decode(Byte[] data);
    public static int Decode(Byte[] data, Stream outStr);
    public static Byte[] Decode(string data);
    public static int Decode(string data, Stream outStr);
}
public class Org.BouncyCastle.Utilities.Encoders.UrlBase64Encoder : Base64Encoder {
}
internal abstract class Org.BouncyCastle.Utilities.Enums : object {
    internal static Enum GetEnumValue(Type enumType, string s);
    internal static Array GetEnumValues(Type enumType);
    internal static Enum GetArbitraryValue(Type enumType);
    internal static bool IsEnumType(Type t);
}
public interface Org.BouncyCastle.Utilities.IMemoable {
    public abstract virtual IMemoable Copy();
    public abstract virtual void Reset(IMemoable other);
}
public abstract class Org.BouncyCastle.Utilities.Integers : object {
    public static int NumBits;
    public static int NumBytes;
    private static Byte[] DeBruijnTZ;
    private static Integers();
    public static int NumberOfLeadingZeros(int i);
    public static int NumberOfTrailingZeros(int i);
    public static int Reverse(int i);
    [CLSCompliantAttribute("False")]
public static UInt32 Reverse(UInt32 i);
    public static int ReverseBytes(int i);
    [CLSCompliantAttribute("False")]
public static UInt32 ReverseBytes(UInt32 i);
    public static int RotateLeft(int i, int distance);
    [CLSCompliantAttribute("False")]
public static UInt32 RotateLeft(UInt32 i, int distance);
    public static int RotateRight(int i, int distance);
    [CLSCompliantAttribute("False")]
public static UInt32 RotateRight(UInt32 i, int distance);
}
public abstract class Org.BouncyCastle.Utilities.IO.BaseInputStream : Stream {
    private bool closed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanSeek();
    public sealed virtual bool get_CanWrite();
    public virtual void Close();
    public sealed virtual void Flush();
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public sealed virtual long Seek(long offset, SeekOrigin origin);
    public sealed virtual void SetLength(long value);
    public sealed virtual void Write(Byte[] buffer, int offset, int count);
}
public abstract class Org.BouncyCastle.Utilities.IO.BaseOutputStream : Stream {
    private bool closed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanSeek();
    public sealed virtual bool get_CanWrite();
    public virtual void Close();
    public virtual void Flush();
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public sealed virtual int Read(Byte[] buffer, int offset, int count);
    public sealed virtual long Seek(long offset, SeekOrigin origin);
    public sealed virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer);
    public virtual void WriteByte(byte b);
}
public class Org.BouncyCastle.Utilities.IO.FilterStream : Stream {
    protected Stream s;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public FilterStream(Stream s);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public class Org.BouncyCastle.Utilities.IO.MemoryInputStream : MemoryStream {
    public bool CanWrite { get; }
    public MemoryInputStream(Byte[] buffer);
    public sealed virtual bool get_CanWrite();
}
public class Org.BouncyCastle.Utilities.IO.MemoryOutputStream : MemoryStream {
    public bool CanRead { get; }
    public sealed virtual bool get_CanRead();
}
internal class Org.BouncyCastle.Utilities.IO.NullOutputStream : BaseOutputStream {
    public virtual void WriteByte(byte b);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
public class Org.BouncyCastle.Utilities.IO.Pem.PemGenerationException : Exception {
    public PemGenerationException(string message);
    public PemGenerationException(string message, Exception exception);
}
public class Org.BouncyCastle.Utilities.IO.Pem.PemHeader : object {
    private string name;
    private string val;
    public string Name { get; }
    public string Value { get; }
    public PemHeader(string name, string val);
    public virtual string get_Name();
    public virtual string get_Value();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private int GetHashCode(string s);
    public virtual string ToString();
}
public class Org.BouncyCastle.Utilities.IO.Pem.PemObject : object {
    private string type;
    private IList headers;
    private Byte[] content;
    public string Type { get; }
    public IList Headers { get; }
    public Byte[] Content { get; }
    public PemObject(string type, Byte[] content);
    public PemObject(string type, IList headers, Byte[] content);
    public string get_Type();
    public IList get_Headers();
    public Byte[] get_Content();
    public sealed virtual PemObject Generate();
}
public interface Org.BouncyCastle.Utilities.IO.Pem.PemObjectGenerator {
    public abstract virtual PemObject Generate();
}
public interface Org.BouncyCastle.Utilities.IO.Pem.PemObjectParser {
    public abstract virtual object ParseObject(PemObject obj);
}
public class Org.BouncyCastle.Utilities.IO.Pem.PemReader : object {
    private TextReader reader;
    private MemoryStream buffer;
    private StreamWriter textBuffer;
    private IList pushback;
    private int c;
    public TextReader Reader { get; }
    public PemReader(TextReader reader);
    public TextReader get_Reader();
    public PemObject ReadPemObject();
    private string bufferedString();
    private bool seekDash();
    private bool seekColon(int upTo);
    private bool consumeDash();
    private void skipWhiteSpace();
    private bool expect(string value);
    private bool bufferUntilStopChar(char stopChar, bool skipWhiteSpace);
    private void PushBack(int value);
    private int Read();
}
public class Org.BouncyCastle.Utilities.IO.Pem.PemWriter : object {
    private static int LineLength;
    private TextWriter writer;
    private int nlLength;
    private Char[] buf;
    public TextWriter Writer { get; }
    public PemWriter(TextWriter writer);
    public TextWriter get_Writer();
    public int GetOutputSize(PemObject obj);
    public void WriteObject(PemObjectGenerator objGen);
    private void WriteEncoded(Byte[] bytes);
    private void WritePreEncapsulationBoundary(string type);
    private void WritePostEncapsulationBoundary(string type);
}
public class Org.BouncyCastle.Utilities.IO.PushbackStream : FilterStream {
    private int buf;
    public PushbackStream(Stream s);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Unread(int b);
}
public class Org.BouncyCastle.Utilities.IO.StreamOverflowException : IOException {
    public StreamOverflowException(string message);
    public StreamOverflowException(string message, Exception exception);
}
public class Org.BouncyCastle.Utilities.IO.Streams : object {
    private static int BufferSize;
    public static void Drain(Stream inStr);
    public static Byte[] ReadAll(Stream inStr);
    public static Byte[] ReadAllLimited(Stream inStr, int limit);
    public static int ReadFully(Stream inStr, Byte[] buf);
    public static int ReadFully(Stream inStr, Byte[] buf, int off, int len);
    public static void PipeAll(Stream inStr, Stream outStr);
    public static void PipeAll(Stream inStr, Stream outStr, int bufferSize);
    public static long PipeAllLimited(Stream inStr, long limit, Stream outStr);
    public static void WriteBufTo(MemoryStream buf, Stream output);
    public static int WriteBufTo(MemoryStream buf, Byte[] output, int offset);
    public static void WriteZeroes(Stream outStr, long count);
}
public class Org.BouncyCastle.Utilities.IO.TeeInputStream : BaseInputStream {
    private Stream input;
    private Stream tee;
    public TeeInputStream(Stream input, Stream tee);
    public virtual void Close();
    public virtual int Read(Byte[] buf, int off, int len);
    public virtual int ReadByte();
}
public class Org.BouncyCastle.Utilities.IO.TeeOutputStream : BaseOutputStream {
    private Stream output;
    private Stream tee;
    public TeeOutputStream(Stream output, Stream tee);
    public virtual void Close();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte b);
}
public abstract class Org.BouncyCastle.Utilities.Longs : object {
    public static int NumBits;
    public static int NumBytes;
    private static Byte[] DeBruijnTZ;
    private static Longs();
    public static int NumberOfLeadingZeros(long i);
    public static int NumberOfTrailingZeros(long i);
    public static long Reverse(long i);
    [CLSCompliantAttribute("False")]
public static ulong Reverse(ulong i);
    public static long ReverseBytes(long i);
    [CLSCompliantAttribute("False")]
public static ulong ReverseBytes(ulong i);
    public static long RotateLeft(long i, int distance);
    [CLSCompliantAttribute("False")]
public static ulong RotateLeft(ulong i, int distance);
    public static long RotateRight(long i, int distance);
    [CLSCompliantAttribute("False")]
public static ulong RotateRight(ulong i, int distance);
}
public class Org.BouncyCastle.Utilities.MemoableResetException : InvalidCastException {
    public MemoableResetException(string msg);
}
public class Org.BouncyCastle.Utilities.Net.IPAddress : object {
    public static bool IsValid(string address);
    public static bool IsValidWithNetMask(string address);
    public static bool IsValidIPv4(string address);
    private static bool unsafeIsValidIPv4(string address);
    public static bool IsValidIPv4WithNetmask(string address);
    public static bool IsValidIPv6WithNetmask(string address);
    private static bool IsMaskValue(string component, int size);
    public static bool IsValidIPv6(string address);
    private static bool unsafeIsValidIPv6(string address);
}
internal abstract class Org.BouncyCastle.Utilities.Platform : object {
    private static CompareInfo InvariantCompareInfo;
    internal static string NewLine;
    private static Platform();
    private static string GetNewLine();
    internal static bool EqualsIgnoreCase(string a, string b);
    internal static string GetEnvironmentVariable(string variable);
    internal static Exception CreateNotImplementedException(string message);
    internal static IList CreateArrayList();
    internal static IList CreateArrayList(int capacity);
    internal static IList CreateArrayList(ICollection collection);
    internal static IList CreateArrayList(IEnumerable collection);
    internal static IDictionary CreateHashtable();
    internal static IDictionary CreateHashtable(int capacity);
    internal static IDictionary CreateHashtable(IDictionary dictionary);
    internal static string ToLowerInvariant(string s);
    internal static string ToUpperInvariant(string s);
    internal static void Dispose(Stream s);
    internal static void Dispose(TextWriter t);
    internal static int IndexOf(string source, string value);
    internal static int LastIndexOf(string source, string value);
    internal static bool StartsWith(string source, string prefix);
    internal static bool EndsWith(string source, string suffix);
    internal static string GetTypeName(object obj);
}
public abstract class Org.BouncyCastle.Utilities.Strings : object {
    public static string ToUpperCase(string original);
    internal static bool IsOneOf(string s, String[] candidates);
    public static string FromByteArray(Byte[] bs);
    public static Byte[] ToByteArray(Char[] cs);
    public static Byte[] ToByteArray(string s);
    public static string FromAsciiByteArray(Byte[] bytes);
    public static Byte[] ToAsciiByteArray(Char[] cs);
    public static Byte[] ToAsciiByteArray(string s);
    public static string FromUtf8ByteArray(Byte[] bytes);
    public static Byte[] ToUtf8ByteArray(Char[] cs);
    public static Byte[] ToUtf8ByteArray(string s);
}
public class Org.BouncyCastle.Utilities.Times : object {
    private static long NanosecondsPerTick;
    private static Times();
    public static long NanoTime();
}
internal class Org.BouncyCastle.Utilities.Zlib.Adler32 : object {
    private static int BASE;
    private static int NMAX;
    internal long adler32(long adler, Byte[] buf, int index, int len);
}
public class Org.BouncyCastle.Utilities.Zlib.Deflate : object {
    private static int MAX_MEM_LEVEL;
    private static int Z_DEFAULT_COMPRESSION;
    private static int MAX_WBITS;
    private static int DEF_MEM_LEVEL;
    private static int STORED;
    private static int FAST;
    private static int SLOW;
    private static Config[] config_table;
    private static String[] z_errmsg;
    private static int NeedMore;
    private static int BlockDone;
    private static int FinishStarted;
    private static int FinishDone;
    private static int PRESET_DICT;
    private static int Z_FILTERED;
    private static int Z_HUFFMAN_ONLY;
    private static int Z_DEFAULT_STRATEGY;
    private static int Z_NO_FLUSH;
    private static int Z_PARTIAL_FLUSH;
    private static int Z_SYNC_FLUSH;
    private static int Z_FULL_FLUSH;
    private static int Z_FINISH;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int INIT_STATE;
    private static int BUSY_STATE;
    private static int FINISH_STATE;
    private static int Z_DEFLATED;
    private static int STORED_BLOCK;
    private static int STATIC_TREES;
    private static int DYN_TREES;
    private static int Z_BINARY;
    private static int Z_ASCII;
    private static int Z_UNKNOWN;
    private static int Buf_size;
    private static int REP_3_6;
    private static int REPZ_3_10;
    private static int REPZ_11_138;
    private static int MIN_MATCH;
    private static int MAX_MATCH;
    private static int MIN_LOOKAHEAD;
    private static int MAX_BITS;
    private static int D_CODES;
    private static int BL_CODES;
    private static int LENGTH_CODES;
    private static int LITERALS;
    private static int L_CODES;
    private static int HEAP_SIZE;
    private static int END_BLOCK;
    internal ZStream strm;
    internal int status;
    internal Byte[] pending_buf;
    internal int pending_out;
    internal int pending;
    internal int noheader;
    internal byte data_type;
    internal byte method;
    internal int last_flush;
    internal int w_size;
    internal int w_bits;
    internal int w_mask;
    internal Byte[] window;
    internal int window_size;
    internal Int16[] prev;
    internal Int16[] head;
    internal int ins_h;
    internal int hash_size;
    internal int hash_bits;
    internal int hash_mask;
    internal int hash_shift;
    internal int block_start;
    internal int match_length;
    internal int prev_match;
    internal int match_available;
    internal int strstart;
    internal int match_start;
    internal int lookahead;
    internal int prev_length;
    internal int max_chain_length;
    internal int max_lazy_match;
    internal int level;
    internal int strategy;
    internal int good_match;
    internal int nice_match;
    internal Int16[] dyn_ltree;
    internal Int16[] dyn_dtree;
    internal Int16[] bl_tree;
    internal Tree l_desc;
    internal Tree d_desc;
    internal Tree bl_desc;
    internal Int16[] bl_count;
    internal Int32[] heap;
    internal int heap_len;
    internal int heap_max;
    internal Byte[] depth;
    internal int l_buf;
    internal int lit_bufsize;
    internal int last_lit;
    internal int d_buf;
    internal int opt_len;
    internal int static_len;
    internal int matches;
    internal int last_eob_len;
    internal UInt32 bi_buf;
    internal int bi_valid;
    private static Deflate();
    internal void lm_init();
    internal void tr_init();
    internal void init_block();
    internal void pqdownheap(Int16[] tree, int k);
    internal static bool smaller(Int16[] tree, int n, int m, Byte[] depth);
    internal void scan_tree(Int16[] tree, int max_code);
    internal int build_bl_tree();
    internal void send_all_trees(int lcodes, int dcodes, int blcodes);
    internal void send_tree(Int16[] tree, int max_code);
    internal void put_byte(Byte[] p, int start, int len);
    internal void put_byte(byte c);
    internal void put_short(int w);
    internal void putShortMSB(int b);
    internal void send_code(int c, Int16[] tree);
    internal void send_bits(int val, int length);
    internal void _tr_align();
    internal bool _tr_tally(int dist, int lc);
    internal void compress_block(Int16[] ltree, Int16[] dtree);
    internal void set_data_type();
    internal void bi_flush();
    internal void bi_windup();
    internal void copy_block(int buf, int len, bool header);
    internal void flush_block_only(bool eof);
    internal int deflate_stored(int flush);
    internal void _tr_stored_block(int buf, int stored_len, bool eof);
    internal void _tr_flush_block(int buf, int stored_len, bool eof);
    internal void fill_window();
    internal int deflate_fast(int flush);
    internal int deflate_slow(int flush);
    internal int longest_match(int cur_match);
    internal int deflateInit(ZStream strm, int level, int bits);
    internal int deflateInit(ZStream strm, int level);
    internal int deflateInit2(ZStream strm, int level, int method, int windowBits, int memLevel, int strategy);
    internal int deflateReset(ZStream strm);
    internal int deflateEnd();
    internal int deflateParams(ZStream strm, int _level, int _strategy);
    internal int deflateSetDictionary(ZStream strm, Byte[] dictionary, int dictLength);
    internal int deflate(ZStream strm, int flush);
}
internal class Org.BouncyCastle.Utilities.Zlib.InfBlocks : object {
    private static int MANY;
    private static Int32[] inflate_mask;
    private static Int32[] border;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int TYPE;
    private static int LENS;
    private static int STORED;
    private static int TABLE;
    private static int BTREE;
    private static int DTREE;
    private static int CODES;
    private static int DRY;
    private static int DONE;
    private static int BAD;
    internal int mode;
    internal int left;
    internal int table;
    internal int index;
    internal Int32[] blens;
    internal Int32[] bb;
    internal Int32[] tb;
    internal InfCodes codes;
    private int last;
    internal int bitk;
    internal int bitb;
    internal Int32[] hufts;
    internal Byte[] window;
    internal int end;
    internal int read;
    internal int write;
    internal object checkfn;
    internal long check;
    internal InfTree inftree;
    internal InfBlocks(ZStream z, object checkfn, int w);
    private static InfBlocks();
    internal void reset(ZStream z, Int64[] c);
    internal int proc(ZStream z, int r);
    internal void free(ZStream z);
    internal void set_dictionary(Byte[] d, int start, int n);
    internal int sync_point();
    internal int inflate_flush(ZStream z, int r);
}
internal class Org.BouncyCastle.Utilities.Zlib.InfCodes : object {
    private static Int32[] inflate_mask;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int START;
    private static int LEN;
    private static int LENEXT;
    private static int DIST;
    private static int DISTEXT;
    private static int COPY;
    private static int LIT;
    private static int WASH;
    private static int END;
    private static int BADCODE;
    private int mode;
    private int len;
    private Int32[] tree;
    private int tree_index;
    private int need;
    private int lit;
    private int get;
    private int dist;
    private byte lbits;
    private byte dbits;
    private Int32[] ltree;
    private int ltree_index;
    private Int32[] dtree;
    private int dtree_index;
    private static InfCodes();
    internal void init(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, ZStream z);
    internal int proc(InfBlocks s, ZStream z, int r);
    internal void free(ZStream z);
    internal int inflate_fast(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, InfBlocks s, ZStream z);
}
internal class Org.BouncyCastle.Utilities.Zlib.Inflate : object {
    private static int MAX_WBITS;
    private static int PRESET_DICT;
    internal static int Z_NO_FLUSH;
    internal static int Z_PARTIAL_FLUSH;
    internal static int Z_SYNC_FLUSH;
    internal static int Z_FULL_FLUSH;
    internal static int Z_FINISH;
    private static int Z_DEFLATED;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int METHOD;
    private static int FLAG;
    private static int DICT4;
    private static int DICT3;
    private static int DICT2;
    private static int DICT1;
    private static int DICT0;
    private static int BLOCKS;
    private static int CHECK4;
    private static int CHECK3;
    private static int CHECK2;
    private static int CHECK1;
    private static int DONE;
    private static int BAD;
    internal int mode;
    internal int method;
    internal Int64[] was;
    internal long need;
    internal int marker;
    internal int nowrap;
    internal int wbits;
    internal InfBlocks blocks;
    private static Byte[] mark;
    private static Inflate();
    internal int inflateReset(ZStream z);
    internal int inflateEnd(ZStream z);
    internal int inflateInit(ZStream z, int w);
    internal int inflate(ZStream z, int f);
    internal int inflateSetDictionary(ZStream z, Byte[] dictionary, int dictLength);
    internal int inflateSync(ZStream z);
    internal int inflateSyncPoint(ZStream z);
}
internal class Org.BouncyCastle.Utilities.Zlib.InfTree : object {
    private static int MANY;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int fixed_bl;
    private static int fixed_bd;
    private static Int32[] fixed_tl;
    private static Int32[] fixed_td;
    private static Int32[] cplens;
    private static Int32[] cplext;
    private static Int32[] cpdist;
    private static Int32[] cpdext;
    private static int BMAX;
    private Int32[] hn;
    private Int32[] v;
    private Int32[] c;
    private Int32[] r;
    private Int32[] u;
    private Int32[] x;
    private static InfTree();
    private int huft_build(Int32[] b, int bindex, int n, int s, Int32[] d, Int32[] e, Int32[] t, Int32[] m, Int32[] hp, Int32[] hn, Int32[] v);
    internal int inflate_trees_bits(Int32[] c, Int32[] bb, Int32[] tb, Int32[] hp, ZStream z);
    internal int inflate_trees_dynamic(int nl, int nd, Int32[] c, Int32[] bl, Int32[] bd, Int32[] tl, Int32[] td, Int32[] hp, ZStream z);
    internal static int inflate_trees_fixed(Int32[] bl, Int32[] bd, Int32[][] tl, Int32[][] td, ZStream z);
    private void initWorkArea(int vsize);
}
public class Org.BouncyCastle.Utilities.Zlib.JZlib : object {
    private static string _version;
    public static int Z_NO_COMPRESSION;
    public static int Z_BEST_SPEED;
    public static int Z_BEST_COMPRESSION;
    public static int Z_DEFAULT_COMPRESSION;
    public static int Z_FILTERED;
    public static int Z_HUFFMAN_ONLY;
    public static int Z_DEFAULT_STRATEGY;
    public static int Z_NO_FLUSH;
    public static int Z_PARTIAL_FLUSH;
    public static int Z_SYNC_FLUSH;
    public static int Z_FULL_FLUSH;
    public static int Z_FINISH;
    public static int Z_OK;
    public static int Z_STREAM_END;
    public static int Z_NEED_DICT;
    public static int Z_ERRNO;
    public static int Z_STREAM_ERROR;
    public static int Z_DATA_ERROR;
    public static int Z_MEM_ERROR;
    public static int Z_BUF_ERROR;
    public static int Z_VERSION_ERROR;
    public static string version();
}
internal class Org.BouncyCastle.Utilities.Zlib.StaticTree : object {
    private static int MAX_BITS;
    private static int BL_CODES;
    private static int D_CODES;
    private static int LITERALS;
    private static int LENGTH_CODES;
    private static int L_CODES;
    internal static int MAX_BL_BITS;
    internal static Int16[] static_ltree;
    internal static Int16[] static_dtree;
    internal static StaticTree static_l_desc;
    internal static StaticTree static_d_desc;
    internal static StaticTree static_bl_desc;
    internal Int16[] static_tree;
    internal Int32[] extra_bits;
    internal int extra_base;
    internal int elems;
    internal int max_length;
    internal StaticTree(Int16[] static_tree, Int32[] extra_bits, int extra_base, int elems, int max_length);
    private static StaticTree();
}
internal class Org.BouncyCastle.Utilities.Zlib.Tree : object {
    private static int MAX_BITS;
    private static int BL_CODES;
    private static int D_CODES;
    private static int LITERALS;
    private static int LENGTH_CODES;
    private static int L_CODES;
    private static int HEAP_SIZE;
    internal static int MAX_BL_BITS;
    internal static int END_BLOCK;
    internal static int REP_3_6;
    internal static int REPZ_3_10;
    internal static int REPZ_11_138;
    internal static Int32[] extra_lbits;
    internal static Int32[] extra_dbits;
    internal static Int32[] extra_blbits;
    internal static Byte[] bl_order;
    internal static int Buf_size;
    internal static int DIST_CODE_LEN;
    internal static Byte[] _dist_code;
    internal static Byte[] _length_code;
    internal static Int32[] base_length;
    internal static Int32[] base_dist;
    internal Int16[] dyn_tree;
    internal int max_code;
    internal StaticTree stat_desc;
    private static Tree();
    internal static int d_code(int dist);
    internal void gen_bitlen(Deflate s);
    internal void build_tree(Deflate s);
    internal static void gen_codes(Int16[] tree, int max_code, Int16[] bl_count);
    internal static int bi_reverse(int code, int len);
}
[ObsoleteAttribute("Use 'ZOutputStream' instead")]
public class Org.BouncyCastle.Utilities.Zlib.ZDeflaterOutputStream : Stream {
    protected ZStream z;
    protected int flushLevel;
    private static int BUFSIZE;
    protected Byte[] buf;
    private Byte[] buf1;
    protected Stream outp;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZDeflaterOutputStream(Stream outp);
    public ZDeflaterOutputStream(Stream outp, int level);
    public ZDeflaterOutputStream(Stream outp, int level, bool nowrap);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Write(Byte[] b, int off, int len);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual void WriteByte(byte b);
    public void Finish();
    public void End();
    public virtual void Close();
}
[ObsoleteAttribute("Use 'ZInputStream' instead")]
public class Org.BouncyCastle.Utilities.Zlib.ZInflaterInputStream : Stream {
    protected ZStream z;
    protected int flushLevel;
    private static int BUFSIZE;
    protected Byte[] buf;
    private Byte[] buf1;
    protected Stream inp;
    private bool nomoreinput;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZInflaterInputStream(Stream inp);
    public ZInflaterInputStream(Stream inp, bool nowrap);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Write(Byte[] b, int off, int len);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] b, int off, int len);
    public virtual void Flush();
    public virtual void WriteByte(byte b);
    public virtual void Close();
    public virtual int ReadByte();
}
public class Org.BouncyCastle.Utilities.Zlib.ZInputStream : Stream {
    private static int BufferSize;
    protected ZStream z;
    protected int flushLevel;
    protected Byte[] buf;
    protected Byte[] buf1;
    protected bool compress;
    protected Stream input;
    protected bool closed;
    private bool nomoreinput;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public int FlushMode { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public long TotalIn { get; }
    public long TotalOut { get; }
    public ZInputStream(Stream input);
    public ZInputStream(Stream input, bool nowrap);
    public ZInputStream(Stream input, ZStream z);
    public ZInputStream(Stream input, int level);
    public ZInputStream(Stream input, int level, bool nowrap);
    private static ZStream GetDefaultZStream(bool nowrap);
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanSeek();
    public sealed virtual bool get_CanWrite();
    public virtual void Close();
    public sealed virtual void Flush();
    public virtual int get_FlushMode();
    public virtual void set_FlushMode(int value);
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public virtual int Read(Byte[] b, int off, int len);
    public virtual int ReadByte();
    public sealed virtual long Seek(long offset, SeekOrigin origin);
    public sealed virtual void SetLength(long value);
    public virtual long get_TotalIn();
    public virtual long get_TotalOut();
    public sealed virtual void Write(Byte[] buffer, int offset, int count);
}
public class Org.BouncyCastle.Utilities.Zlib.ZOutputStream : Stream {
    private static int BufferSize;
    protected ZStream z;
    protected int flushLevel;
    protected Byte[] buf;
    protected Byte[] buf1;
    protected bool compress;
    protected Stream output;
    protected bool closed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public int FlushMode { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public long TotalIn { get; }
    public long TotalOut { get; }
    public ZOutputStream(Stream output);
    public ZOutputStream(Stream output, bool nowrap);
    public ZOutputStream(Stream output, ZStream z);
    public ZOutputStream(Stream output, int level);
    public ZOutputStream(Stream output, int level, bool nowrap);
    private static ZStream GetDefaultZStream(bool nowrap);
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanSeek();
    public sealed virtual bool get_CanWrite();
    public virtual void Close();
    private void DoClose();
    public virtual void End();
    public virtual void Finish();
    public virtual void Flush();
    public virtual int get_FlushMode();
    public virtual void set_FlushMode(int value);
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public sealed virtual int Read(Byte[] buffer, int offset, int count);
    public sealed virtual long Seek(long offset, SeekOrigin origin);
    public sealed virtual void SetLength(long value);
    public virtual long get_TotalIn();
    public virtual long get_TotalOut();
    public virtual void Write(Byte[] b, int off, int len);
    public virtual void WriteByte(byte b);
}
public class Org.BouncyCastle.Utilities.Zlib.ZStream : object {
    private static int MAX_WBITS;
    private static int DEF_WBITS;
    private static int Z_NO_FLUSH;
    private static int Z_PARTIAL_FLUSH;
    private static int Z_SYNC_FLUSH;
    private static int Z_FULL_FLUSH;
    private static int Z_FINISH;
    private static int MAX_MEM_LEVEL;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    public Byte[] next_in;
    public int next_in_index;
    public int avail_in;
    public long total_in;
    public Byte[] next_out;
    public int next_out_index;
    public int avail_out;
    public long total_out;
    public string msg;
    internal Deflate dstate;
    internal Inflate istate;
    internal int data_type;
    public long adler;
    internal Adler32 _adler;
    public int inflateInit();
    public int inflateInit(bool nowrap);
    public int inflateInit(int w);
    public int inflateInit(int w, bool nowrap);
    public int inflate(int f);
    public int inflateEnd();
    public int inflateSync();
    public int inflateSetDictionary(Byte[] dictionary, int dictLength);
    public int deflateInit(int level);
    public int deflateInit(int level, bool nowrap);
    public int deflateInit(int level, int bits);
    public int deflateInit(int level, int bits, bool nowrap);
    public int deflate(int flush);
    public int deflateEnd();
    public int deflateParams(int level, int strategy);
    public int deflateSetDictionary(Byte[] dictionary, int dictLength);
    internal void flush_pending();
    internal int read_buf(Byte[] buf, int start, int size);
    public void free();
}
public class Org.BouncyCastle.X509.AttributeCertificateHolder : object {
    internal Holder holder;
    public int DigestedObjectType { get; }
    public string DigestAlgorithm { get; }
    public string OtherObjectTypeID { get; }
    public BigInteger SerialNumber { get; }
    internal AttributeCertificateHolder(Asn1Sequence seq);
    public AttributeCertificateHolder(X509Name issuerName, BigInteger serialNumber);
    public AttributeCertificateHolder(X509Certificate cert);
    public AttributeCertificateHolder(X509Name principal);
    public AttributeCertificateHolder(int digestedObjectType, string digestAlgorithm, string otherObjectTypeID, Byte[] objectDigest);
    public int get_DigestedObjectType();
    public string get_DigestAlgorithm();
    public Byte[] GetObjectDigest();
    public string get_OtherObjectTypeID();
    private GeneralNames GenerateGeneralNames(X509Name principal);
    private bool MatchesDN(X509Name subject, GeneralNames targets);
    private Object[] GetNames(GeneralName[] names);
    private X509Name[] GetPrincipals(GeneralNames names);
    public X509Name[] GetEntityNames();
    public X509Name[] GetIssuer();
    public BigInteger get_SerialNumber();
    public sealed virtual object Clone();
    public bool Match(X509Certificate x509Cert);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Match(object obj);
}
public class Org.BouncyCastle.X509.AttributeCertificateIssuer : object {
    internal Asn1Encodable form;
    public AttributeCertificateIssuer(AttCertIssuer issuer);
    public AttributeCertificateIssuer(X509Name principal);
    private Object[] GetNames();
    public X509Name[] GetPrincipals();
    private bool MatchesDN(X509Name subject, GeneralNames targets);
    public sealed virtual object Clone();
    public bool Match(X509Certificate x509Cert);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Match(object obj);
}
public class Org.BouncyCastle.X509.Extension.AuthorityKeyIdentifierStructure : AuthorityKeyIdentifier {
    public AuthorityKeyIdentifierStructure(Asn1OctetString encodedValue);
    public AuthorityKeyIdentifierStructure(X509Certificate certificate);
    public AuthorityKeyIdentifierStructure(AsymmetricKeyParameter pubKey);
    private static Asn1Sequence FromCertificate(X509Certificate certificate);
    private static Asn1Sequence FromKey(AsymmetricKeyParameter pubKey);
}
public class Org.BouncyCastle.X509.Extension.SubjectKeyIdentifierStructure : SubjectKeyIdentifier {
    public SubjectKeyIdentifierStructure(Asn1OctetString encodedValue);
    public SubjectKeyIdentifierStructure(AsymmetricKeyParameter pubKey);
    private static Asn1OctetString FromPublicKey(AsymmetricKeyParameter pubKey);
}
public class Org.BouncyCastle.X509.Extension.X509ExtensionUtilities : object {
    public static Asn1Object FromExtensionValue(Asn1OctetString extensionValue);
    public static ICollection GetIssuerAlternativeNames(X509Certificate cert);
    public static ICollection GetSubjectAlternativeNames(X509Certificate cert);
    private static ICollection GetAlternativeName(Asn1OctetString extVal);
}
public interface Org.BouncyCastle.X509.IX509AttributeCertificate {
    public int Version { get; }
    public BigInteger SerialNumber { get; }
    public DateTime NotBefore { get; }
    public DateTime NotAfter { get; }
    public AttributeCertificateHolder Holder { get; }
    public AttributeCertificateIssuer Issuer { get; }
    public bool IsValidNow { get; }
    public abstract virtual int get_Version();
    public abstract virtual BigInteger get_SerialNumber();
    public abstract virtual DateTime get_NotBefore();
    public abstract virtual DateTime get_NotAfter();
    public abstract virtual AttributeCertificateHolder get_Holder();
    public abstract virtual AttributeCertificateIssuer get_Issuer();
    public abstract virtual X509Attribute[] GetAttributes();
    public abstract virtual X509Attribute[] GetAttributes(string oid);
    public abstract virtual Boolean[] GetIssuerUniqueID();
    public abstract virtual bool get_IsValidNow();
    public abstract virtual bool IsValid(DateTime date);
    public abstract virtual void CheckValidity();
    public abstract virtual void CheckValidity(DateTime date);
    public abstract virtual Byte[] GetSignature();
    public abstract virtual void Verify(AsymmetricKeyParameter publicKey);
    public abstract virtual Byte[] GetEncoded();
}
public interface Org.BouncyCastle.X509.IX509Extension {
    public abstract virtual ISet GetCriticalExtensionOids();
    public abstract virtual ISet GetNonCriticalExtensionOids();
    [ObsoleteAttribute("Use version taking a DerObjectIdentifier instead")]
public abstract virtual Asn1OctetString GetExtensionValue(string oid);
    public abstract virtual Asn1OctetString GetExtensionValue(DerObjectIdentifier oid);
}
internal class Org.BouncyCastle.X509.PemParser : object {
    private string _header1;
    private string _header2;
    private string _footer1;
    private string _footer2;
    internal PemParser(string type);
    private string ReadLine(Stream inStream);
    internal Asn1Sequence ReadPemObject(Stream inStream);
}
public class Org.BouncyCastle.X509.PrincipalUtilities : object {
    public static X509Name GetIssuerX509Principal(X509Certificate cert);
    public static X509Name GetSubjectX509Principal(X509Certificate cert);
    public static X509Name GetIssuerX509Principal(X509Crl crl);
}
public interface Org.BouncyCastle.X509.Store.IX509Selector {
    public abstract virtual bool Match(object obj);
}
public interface Org.BouncyCastle.X509.Store.IX509Store {
    public abstract virtual ICollection GetMatches(IX509Selector selector);
}
public interface Org.BouncyCastle.X509.Store.IX509StoreParameters {
}
public class Org.BouncyCastle.X509.Store.NoSuchStoreException : X509StoreException {
    public NoSuchStoreException(string message);
    public NoSuchStoreException(string message, Exception e);
}
public class Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector : object {
    private IX509AttributeCertificate attributeCert;
    private DateTimeObject attributeCertificateValid;
    private AttributeCertificateHolder holder;
    private AttributeCertificateIssuer issuer;
    private BigInteger serialNumber;
    private ISet targetNames;
    private ISet targetGroups;
    public IX509AttributeCertificate AttributeCert { get; public set; }
    [ObsoleteAttribute("Use AttributeCertificateValid instead")]
public DateTimeObject AttribueCertificateValid { get; public set; }
    public DateTimeObject AttributeCertificateValid { get; public set; }
    public AttributeCertificateHolder Holder { get; public set; }
    public AttributeCertificateIssuer Issuer { get; public set; }
    public BigInteger SerialNumber { get; public set; }
    private X509AttrCertStoreSelector(X509AttrCertStoreSelector o);
    public sealed virtual bool Match(object obj);
    public sealed virtual object Clone();
    public IX509AttributeCertificate get_AttributeCert();
    public void set_AttributeCert(IX509AttributeCertificate value);
    public DateTimeObject get_AttribueCertificateValid();
    public void set_AttribueCertificateValid(DateTimeObject value);
    public DateTimeObject get_AttributeCertificateValid();
    public void set_AttributeCertificateValid(DateTimeObject value);
    public AttributeCertificateHolder get_Holder();
    public void set_Holder(AttributeCertificateHolder value);
    public AttributeCertificateIssuer get_Issuer();
    public void set_Issuer(AttributeCertificateIssuer value);
    public BigInteger get_SerialNumber();
    public void set_SerialNumber(BigInteger value);
    public void AddTargetName(GeneralName name);
    public void AddTargetName(Byte[] name);
    public void SetTargetNames(IEnumerable names);
    public IEnumerable GetTargetNames();
    public void AddTargetGroup(GeneralName group);
    public void AddTargetGroup(Byte[] name);
    public void SetTargetGroups(IEnumerable names);
    public IEnumerable GetTargetGroups();
    private ISet ExtractGeneralNames(IEnumerable names);
}
public class Org.BouncyCastle.X509.Store.X509CertPairStoreSelector : object {
    private X509CertificatePair certPair;
    private X509CertStoreSelector forwardSelector;
    private X509CertStoreSelector reverseSelector;
    public X509CertificatePair CertPair { get; public set; }
    public X509CertStoreSelector ForwardSelector { get; public set; }
    public X509CertStoreSelector ReverseSelector { get; public set; }
    private X509CertPairStoreSelector(X509CertPairStoreSelector o);
    private static X509CertStoreSelector CloneSelector(X509CertStoreSelector s);
    public X509CertificatePair get_CertPair();
    public void set_CertPair(X509CertificatePair value);
    public X509CertStoreSelector get_ForwardSelector();
    public void set_ForwardSelector(X509CertStoreSelector value);
    public X509CertStoreSelector get_ReverseSelector();
    public void set_ReverseSelector(X509CertStoreSelector value);
    public sealed virtual bool Match(object obj);
    public sealed virtual object Clone();
}
public class Org.BouncyCastle.X509.Store.X509CertStoreSelector : object {
    private Byte[] authorityKeyIdentifier;
    private int basicConstraints;
    private X509Certificate certificate;
    private DateTimeObject certificateValid;
    private ISet extendedKeyUsage;
    private bool ignoreX509NameOrdering;
    private X509Name issuer;
    private Boolean[] keyUsage;
    private ISet policy;
    private DateTimeObject privateKeyValid;
    private BigInteger serialNumber;
    private X509Name subject;
    private Byte[] subjectKeyIdentifier;
    private SubjectPublicKeyInfo subjectPublicKey;
    private DerObjectIdentifier subjectPublicKeyAlgID;
    public Byte[] AuthorityKeyIdentifier { get; public set; }
    public int BasicConstraints { get; public set; }
    public X509Certificate Certificate { get; public set; }
    public DateTimeObject CertificateValid { get; public set; }
    public ISet ExtendedKeyUsage { get; public set; }
    public bool IgnoreX509NameOrdering { get; public set; }
    public X509Name Issuer { get; public set; }
    [ObsoleteAttribute("Avoid working with X509Name objects in string form")]
public string IssuerAsString { get; }
    public Boolean[] KeyUsage { get; public set; }
    public ISet Policy { get; public set; }
    public DateTimeObject PrivateKeyValid { get; public set; }
    public BigInteger SerialNumber { get; public set; }
    public X509Name Subject { get; public set; }
    [ObsoleteAttribute("Avoid working with X509Name objects in string form")]
public string SubjectAsString { get; }
    public Byte[] SubjectKeyIdentifier { get; public set; }
    public SubjectPublicKeyInfo SubjectPublicKey { get; public set; }
    public DerObjectIdentifier SubjectPublicKeyAlgID { get; public set; }
    public X509CertStoreSelector(X509CertStoreSelector o);
    public virtual object Clone();
    public Byte[] get_AuthorityKeyIdentifier();
    public void set_AuthorityKeyIdentifier(Byte[] value);
    public int get_BasicConstraints();
    public void set_BasicConstraints(int value);
    public X509Certificate get_Certificate();
    public void set_Certificate(X509Certificate value);
    public DateTimeObject get_CertificateValid();
    public void set_CertificateValid(DateTimeObject value);
    public ISet get_ExtendedKeyUsage();
    public void set_ExtendedKeyUsage(ISet value);
    public bool get_IgnoreX509NameOrdering();
    public void set_IgnoreX509NameOrdering(bool value);
    public X509Name get_Issuer();
    public void set_Issuer(X509Name value);
    public string get_IssuerAsString();
    public Boolean[] get_KeyUsage();
    public void set_KeyUsage(Boolean[] value);
    public ISet get_Policy();
    public void set_Policy(ISet value);
    public DateTimeObject get_PrivateKeyValid();
    public void set_PrivateKeyValid(DateTimeObject value);
    public BigInteger get_SerialNumber();
    public void set_SerialNumber(BigInteger value);
    public X509Name get_Subject();
    public void set_Subject(X509Name value);
    public string get_SubjectAsString();
    public Byte[] get_SubjectKeyIdentifier();
    public void set_SubjectKeyIdentifier(Byte[] value);
    public SubjectPublicKeyInfo get_SubjectPublicKey();
    public void set_SubjectPublicKey(SubjectPublicKeyInfo value);
    public DerObjectIdentifier get_SubjectPublicKeyAlgID();
    public void set_SubjectPublicKeyAlgID(DerObjectIdentifier value);
    public virtual bool Match(object obj);
    internal static bool IssuersMatch(X509Name a, X509Name b);
    private static Boolean[] CopyBoolArray(Boolean[] b);
    private static ISet CopySet(ISet s);
    private static SubjectPublicKeyInfo GetSubjectPublicKey(X509Certificate c);
    private static bool MatchExtension(Byte[] b, X509Certificate c, DerObjectIdentifier oid);
}
internal class Org.BouncyCastle.X509.Store.X509CollectionStore : object {
    private ICollection _local;
    internal X509CollectionStore(ICollection collection);
    public sealed virtual ICollection GetMatches(IX509Selector selector);
}
public class Org.BouncyCastle.X509.Store.X509CollectionStoreParameters : object {
    private IList collection;
    public X509CollectionStoreParameters(ICollection collection);
    public ICollection GetCollection();
    public virtual string ToString();
}
public class Org.BouncyCastle.X509.Store.X509CrlStoreSelector : object {
    private X509Certificate certificateChecking;
    private DateTimeObject dateAndTime;
    private ICollection issuers;
    private BigInteger maxCrlNumber;
    private BigInteger minCrlNumber;
    private IX509AttributeCertificate attrCertChecking;
    private bool completeCrlEnabled;
    private bool deltaCrlIndicatorEnabled;
    private Byte[] issuingDistributionPoint;
    private bool issuingDistributionPointEnabled;
    private BigInteger maxBaseCrlNumber;
    public X509Certificate CertificateChecking { get; public set; }
    public DateTimeObject DateAndTime { get; public set; }
    public ICollection Issuers { get; public set; }
    public BigInteger MaxCrlNumber { get; public set; }
    public BigInteger MinCrlNumber { get; public set; }
    public IX509AttributeCertificate AttrCertChecking { get; public set; }
    public bool CompleteCrlEnabled { get; public set; }
    public bool DeltaCrlIndicatorEnabled { get; public set; }
    public Byte[] IssuingDistributionPoint { get; public set; }
    public bool IssuingDistributionPointEnabled { get; public set; }
    public BigInteger MaxBaseCrlNumber { get; public set; }
    public X509CrlStoreSelector(X509CrlStoreSelector o);
    public virtual object Clone();
    public X509Certificate get_CertificateChecking();
    public void set_CertificateChecking(X509Certificate value);
    public DateTimeObject get_DateAndTime();
    public void set_DateAndTime(DateTimeObject value);
    public ICollection get_Issuers();
    public void set_Issuers(ICollection value);
    public BigInteger get_MaxCrlNumber();
    public void set_MaxCrlNumber(BigInteger value);
    public BigInteger get_MinCrlNumber();
    public void set_MinCrlNumber(BigInteger value);
    public IX509AttributeCertificate get_AttrCertChecking();
    public void set_AttrCertChecking(IX509AttributeCertificate value);
    public bool get_CompleteCrlEnabled();
    public void set_CompleteCrlEnabled(bool value);
    public bool get_DeltaCrlIndicatorEnabled();
    public void set_DeltaCrlIndicatorEnabled(bool value);
    public Byte[] get_IssuingDistributionPoint();
    public void set_IssuingDistributionPoint(Byte[] value);
    public bool get_IssuingDistributionPointEnabled();
    public void set_IssuingDistributionPointEnabled(bool value);
    public BigInteger get_MaxBaseCrlNumber();
    public void set_MaxBaseCrlNumber(BigInteger value);
    public virtual bool Match(object obj);
}
public class Org.BouncyCastle.X509.Store.X509StoreException : Exception {
    public X509StoreException(string message);
    public X509StoreException(string message, Exception e);
}
public class Org.BouncyCastle.X509.Store.X509StoreFactory : object {
    public static IX509Store Create(string type, IX509StoreParameters parameters);
    private static void checkCorrectType(ICollection coll, Type t);
}
public class Org.BouncyCastle.X509.SubjectPublicKeyInfoFactory : object {
    public static SubjectPublicKeyInfo CreateSubjectPublicKeyInfo(AsymmetricKeyParameter publicKey);
    private static void ExtractBytes(Byte[] encKey, int offset, BigInteger bI);
    private static void ExtractBytes(Byte[] encKey, int size, int offSet, BigInteger bI);
}
public class Org.BouncyCastle.X509.X509AttrCertParser : object {
    private static PemParser PemAttrCertParser;
    private Asn1Set sData;
    private int sDataObjectCount;
    private Stream currentStream;
    private static X509AttrCertParser();
    private IX509AttributeCertificate ReadDerCertificate(Asn1InputStream dIn);
    private IX509AttributeCertificate GetCertificate();
    private IX509AttributeCertificate ReadPemCertificate(Stream inStream);
    public IX509AttributeCertificate ReadAttrCert(Byte[] input);
    public ICollection ReadAttrCerts(Byte[] input);
    public IX509AttributeCertificate ReadAttrCert(Stream inStream);
    public ICollection ReadAttrCerts(Stream inStream);
}
public class Org.BouncyCastle.X509.X509Attribute : Asn1Encodable {
    private AttributeX509 attr;
    public string Oid { get; }
    internal X509Attribute(Asn1Encodable at);
    public X509Attribute(string oid, Asn1Encodable value);
    public X509Attribute(string oid, Asn1EncodableVector value);
    public string get_Oid();
    public Asn1Encodable[] GetValues();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.X509.X509Certificate : X509ExtensionBase {
    private X509CertificateStructure c;
    private string sigAlgName;
    private Byte[] sigAlgParams;
    private BasicConstraints basicConstraints;
    private Boolean[] keyUsage;
    private object cacheLock;
    private AsymmetricKeyParameter publicKeyValue;
    private CachedEncoding cachedEncoding;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) hashValueSet;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) hashValue;
    public X509CertificateStructure CertificateStructure { get; }
    public bool IsValidNow { get; }
    public int Version { get; }
    public BigInteger SerialNumber { get; }
    public X509Name IssuerDN { get; }
    public X509Name SubjectDN { get; }
    public DateTime NotBefore { get; }
    public DateTime NotAfter { get; }
    public string SigAlgName { get; }
    public string SigAlgOid { get; }
    public DerBitString IssuerUniqueID { get; }
    public DerBitString SubjectUniqueID { get; }
    public X509Certificate(Byte[] certData);
    public X509Certificate(X509CertificateStructure c);
    public virtual X509CertificateStructure get_CertificateStructure();
    public virtual bool get_IsValidNow();
    public virtual bool IsValid(DateTime time);
    public virtual void CheckValidity();
    public virtual void CheckValidity(DateTime time);
    public virtual int get_Version();
    public virtual BigInteger get_SerialNumber();
    public virtual X509Name get_IssuerDN();
    public virtual X509Name get_SubjectDN();
    public virtual DateTime get_NotBefore();
    public virtual DateTime get_NotAfter();
    public virtual Byte[] GetTbsCertificate();
    public virtual Byte[] GetSignature();
    public virtual string get_SigAlgName();
    public virtual string get_SigAlgOid();
    public virtual Byte[] GetSigAlgParams();
    public virtual DerBitString get_IssuerUniqueID();
    public virtual DerBitString get_SubjectUniqueID();
    public virtual Boolean[] GetKeyUsage();
    public virtual IList GetExtendedKeyUsage();
    public virtual int GetBasicConstraints();
    public virtual ICollection GetSubjectAlternativeNames();
    public virtual ICollection GetIssuerAlternativeNames();
    protected virtual ICollection GetAlternativeNames(string oid);
    protected virtual X509Extensions GetX509Extensions();
    public virtual AsymmetricKeyParameter GetPublicKey();
    public virtual Byte[] GetEncoded();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual void Verify(AsymmetricKeyParameter key);
    public virtual void Verify(IVerifierFactoryProvider verifierProvider);
    protected virtual void CheckSignature(IVerifierFactory verifier);
    private CachedEncoding GetCachedEncoding();
    private static bool IsAlgIDEqual(AlgorithmIdentifier id1, AlgorithmIdentifier id2);
}
public class Org.BouncyCastle.X509.X509CertificatePair : object {
    private X509Certificate forward;
    private X509Certificate reverse;
    public X509Certificate Forward { get; }
    public X509Certificate Reverse { get; }
    public X509CertificatePair(X509Certificate forward, X509Certificate reverse);
    public X509CertificatePair(CertificatePair pair);
    public Byte[] GetEncoded();
    public X509Certificate get_Forward();
    public X509Certificate get_Reverse();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.X509.X509CertificateParser : object {
    private static PemParser PemCertParser;
    private Asn1Set sData;
    private int sDataObjectCount;
    private Stream currentStream;
    private static X509CertificateParser();
    private X509Certificate ReadDerCertificate(Asn1InputStream dIn);
    private X509Certificate GetCertificate();
    private X509Certificate ReadPemCertificate(Stream inStream);
    protected virtual X509Certificate CreateX509Certificate(X509CertificateStructure c);
    public X509Certificate ReadCertificate(Byte[] input);
    public ICollection ReadCertificates(Byte[] input);
    public X509Certificate ReadCertificate(Stream inStream);
    public ICollection ReadCertificates(Stream inStream);
}
public class Org.BouncyCastle.X509.X509CertPairParser : object {
    private Stream currentStream;
    private X509CertificatePair ReadDerCrossCertificatePair(Stream inStream);
    public X509CertificatePair ReadCertPair(Byte[] input);
    public ICollection ReadCertPairs(Byte[] input);
    public X509CertificatePair ReadCertPair(Stream inStream);
    public ICollection ReadCertPairs(Stream inStream);
}
public class Org.BouncyCastle.X509.X509Crl : X509ExtensionBase {
    private CertificateList c;
    private string sigAlgName;
    private Byte[] sigAlgParams;
    private bool isIndirect;
    private object cacheLock;
    private CachedEncoding cachedEncoding;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) hashValueSet;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) hashValue;
    public CertificateList CertificateList { get; }
    public int Version { get; }
    public X509Name IssuerDN { get; }
    public DateTime ThisUpdate { get; }
    public DateTimeObject NextUpdate { get; }
    public string SigAlgName { get; }
    public string SigAlgOid { get; }
    protected bool IsIndirectCrl { get; }
    public X509Crl(Byte[] encoding);
    public X509Crl(CertificateList c);
    public virtual CertificateList get_CertificateList();
    protected virtual X509Extensions GetX509Extensions();
    public virtual void Verify(AsymmetricKeyParameter publicKey);
    public virtual void Verify(IVerifierFactoryProvider verifierProvider);
    protected virtual void CheckSignature(IVerifierFactory verifier);
    public virtual int get_Version();
    public virtual X509Name get_IssuerDN();
    public virtual DateTime get_ThisUpdate();
    public virtual DateTimeObject get_NextUpdate();
    private ISet LoadCrlEntries();
    public virtual X509CrlEntry GetRevokedCertificate(BigInteger serialNumber);
    public virtual ISet GetRevokedCertificates();
    public virtual Byte[] GetTbsCertList();
    public virtual Byte[] GetSignature();
    public virtual string get_SigAlgName();
    public virtual string get_SigAlgOid();
    public virtual Byte[] GetSigAlgParams();
    public virtual Byte[] GetEncoded();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual bool IsRevoked(X509Certificate cert);
    protected virtual bool get_IsIndirectCrl();
    private CachedEncoding GetCachedEncoding();
}
public class Org.BouncyCastle.X509.X509CrlEntry : X509ExtensionBase {
    private CrlEntry c;
    private bool isIndirect;
    private X509Name previousCertificateIssuer;
    private X509Name certificateIssuer;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) hashValueSet;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) hashValue;
    public BigInteger SerialNumber { get; }
    public DateTime RevocationDate { get; }
    public bool HasExtensions { get; }
    public X509CrlEntry(CrlEntry c);
    public X509CrlEntry(CrlEntry c, bool isIndirect, X509Name previousCertificateIssuer);
    private X509Name loadCertificateIssuer();
    public X509Name GetCertificateIssuer();
    protected virtual X509Extensions GetX509Extensions();
    public Byte[] GetEncoded();
    public BigInteger get_SerialNumber();
    public DateTime get_RevocationDate();
    public bool get_HasExtensions();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Org.BouncyCastle.X509.X509CrlParser : object {
    private static PemParser PemCrlParser;
    private bool lazyAsn1;
    private Asn1Set sCrlData;
    private int sCrlDataObjectCount;
    private Stream currentCrlStream;
    public X509CrlParser(bool lazyAsn1);
    private static X509CrlParser();
    private X509Crl ReadPemCrl(Stream inStream);
    private X509Crl ReadDerCrl(Asn1InputStream dIn);
    private X509Crl GetCrl();
    protected virtual X509Crl CreateX509Crl(CertificateList c);
    public X509Crl ReadCrl(Byte[] input);
    public ICollection ReadCrls(Byte[] input);
    public X509Crl ReadCrl(Stream inStream);
    public ICollection ReadCrls(Stream inStream);
}
public abstract class Org.BouncyCastle.X509.X509ExtensionBase : object {
    protected abstract virtual X509Extensions GetX509Extensions();
    protected virtual ISet GetExtensionOids(bool critical);
    public virtual ISet GetNonCriticalExtensionOids();
    public virtual ISet GetCriticalExtensionOids();
    [ObsoleteAttribute("Use version taking a DerObjectIdentifier instead")]
public sealed virtual Asn1OctetString GetExtensionValue(string oid);
    public virtual Asn1OctetString GetExtensionValue(DerObjectIdentifier oid);
}
public class Org.BouncyCastle.X509.X509KeyUsage : Asn1Encodable {
    public static int DigitalSignature;
    public static int NonRepudiation;
    public static int KeyEncipherment;
    public static int DataEncipherment;
    public static int KeyAgreement;
    public static int KeyCertSign;
    public static int CrlSign;
    public static int EncipherOnly;
    public static int DecipherOnly;
    private int usage;
    public X509KeyUsage(int usage);
    public virtual Asn1Object ToAsn1Object();
}
internal class Org.BouncyCastle.X509.X509SignatureUtilities : object {
    private static Asn1Null derNull;
    private static X509SignatureUtilities();
    internal static void SetSignatureParameters(ISigner signature, Asn1Encodable parameters);
    internal static string GetSignatureName(AlgorithmIdentifier sigAlgId);
    private static string GetDigestAlgName(DerObjectIdentifier digestAlgOID);
}
internal class Org.BouncyCastle.X509.X509Utilities : object {
    private static IDictionary algorithms;
    private static IDictionary exParams;
    private static ISet noParams;
    private static X509Utilities();
    private static RsassaPssParameters CreatePssParams(AlgorithmIdentifier hashAlgId, int saltSize);
    internal static DerObjectIdentifier GetAlgorithmOid(string algorithmName);
    internal static AlgorithmIdentifier GetSigAlgID(DerObjectIdentifier sigOid, string algorithmName);
    internal static IEnumerable GetAlgNames();
    internal static Byte[] GetSignatureForObject(DerObjectIdentifier sigOid, string sigName, AsymmetricKeyParameter privateKey, SecureRandom random, Asn1Encodable ae);
}
public class Org.BouncyCastle.X509.X509V1CertificateGenerator : object {
    private V1TbsCertificateGenerator tbsGen;
    private DerObjectIdentifier sigOID;
    private AlgorithmIdentifier sigAlgId;
    private string signatureAlgorithm;
    public IEnumerable SignatureAlgNames { get; }
    public void Reset();
    public void SetSerialNumber(BigInteger serialNumber);
    public void SetIssuerDN(X509Name issuer);
    public void SetNotBefore(DateTime date);
    public void SetNotAfter(DateTime date);
    public void SetSubjectDN(X509Name subject);
    public void SetPublicKey(AsymmetricKeyParameter publicKey);
    [ObsoleteAttribute("Not needed if Generate used with an ISignatureFactory")]
public void SetSignatureAlgorithm(string signatureAlgorithm);
    [ObsoleteAttribute("Use Generate with an ISignatureFactory")]
public X509Certificate Generate(AsymmetricKeyParameter privateKey);
    [ObsoleteAttribute("Use Generate with an ISignatureFactory")]
public X509Certificate Generate(AsymmetricKeyParameter privateKey, SecureRandom random);
    public X509Certificate Generate(ISignatureFactory signatureCalculatorFactory);
    private X509Certificate GenerateJcaObject(TbsCertificateStructure tbsCert, AlgorithmIdentifier sigAlg, Byte[] signature);
    public IEnumerable get_SignatureAlgNames();
}
public class Org.BouncyCastle.X509.X509V2AttributeCertificate : X509ExtensionBase {
    private AttributeCertificate cert;
    private DateTime notBefore;
    private DateTime notAfter;
    public int Version { get; }
    public BigInteger SerialNumber { get; }
    public AttributeCertificateHolder Holder { get; }
    public AttributeCertificateIssuer Issuer { get; }
    public DateTime NotBefore { get; }
    public DateTime NotAfter { get; }
    public bool IsValidNow { get; }
    public AlgorithmIdentifier SignatureAlgorithm { get; }
    public X509V2AttributeCertificate(Stream encIn);
    public X509V2AttributeCertificate(Byte[] encoded);
    internal X509V2AttributeCertificate(AttributeCertificate cert);
    private static AttributeCertificate GetObject(Stream input);
    public virtual int get_Version();
    public virtual BigInteger get_SerialNumber();
    public virtual AttributeCertificateHolder get_Holder();
    public virtual AttributeCertificateIssuer get_Issuer();
    public virtual DateTime get_NotBefore();
    public virtual DateTime get_NotAfter();
    public virtual Boolean[] GetIssuerUniqueID();
    public virtual bool get_IsValidNow();
    public virtual bool IsValid(DateTime date);
    public virtual void CheckValidity();
    public virtual void CheckValidity(DateTime date);
    public virtual AlgorithmIdentifier get_SignatureAlgorithm();
    public virtual Byte[] GetSignature();
    public virtual void Verify(AsymmetricKeyParameter key);
    public virtual void Verify(IVerifierFactoryProvider verifierProvider);
    protected virtual void CheckSignature(IVerifierFactory verifier);
    public virtual Byte[] GetEncoded();
    protected virtual X509Extensions GetX509Extensions();
    public virtual X509Attribute[] GetAttributes();
    public virtual X509Attribute[] GetAttributes(string oid);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator : object {
    private X509ExtensionsGenerator extGenerator;
    private V2AttributeCertificateInfoGenerator acInfoGen;
    private DerObjectIdentifier sigOID;
    private AlgorithmIdentifier sigAlgId;
    private string signatureAlgorithm;
    public IEnumerable SignatureAlgNames { get; }
    public void Reset();
    public void SetHolder(AttributeCertificateHolder holder);
    public void SetIssuer(AttributeCertificateIssuer issuer);
    public void SetSerialNumber(BigInteger serialNumber);
    public void SetNotBefore(DateTime date);
    public void SetNotAfter(DateTime date);
    [ObsoleteAttribute("Not needed if Generate used with an ISignatureFactory")]
public void SetSignatureAlgorithm(string signatureAlgorithm);
    public void AddAttribute(X509Attribute attribute);
    public void SetIssuerUniqueId(Boolean[] iui);
    public void AddExtension(string oid, bool critical, Asn1Encodable extensionValue);
    public void AddExtension(string oid, bool critical, Byte[] extensionValue);
    [ObsoleteAttribute("Use Generate with an ISignatureFactory")]
public IX509AttributeCertificate Generate(AsymmetricKeyParameter privateKey);
    [ObsoleteAttribute("Use Generate with an ISignatureFactory")]
public IX509AttributeCertificate Generate(AsymmetricKeyParameter privateKey, SecureRandom random);
    public IX509AttributeCertificate Generate(ISignatureFactory signatureCalculatorFactory);
    public IEnumerable get_SignatureAlgNames();
}
public class Org.BouncyCastle.X509.X509V2CrlGenerator : object {
    private X509ExtensionsGenerator extGenerator;
    private V2TbsCertListGenerator tbsGen;
    private DerObjectIdentifier sigOID;
    private AlgorithmIdentifier sigAlgId;
    private string signatureAlgorithm;
    public IEnumerable SignatureAlgNames { get; }
    public void Reset();
    public void SetIssuerDN(X509Name issuer);
    public void SetThisUpdate(DateTime date);
    public void SetNextUpdate(DateTime date);
    public void AddCrlEntry(BigInteger userCertificate, DateTime revocationDate, int reason);
    public void AddCrlEntry(BigInteger userCertificate, DateTime revocationDate, int reason, DateTime invalidityDate);
    public void AddCrlEntry(BigInteger userCertificate, DateTime revocationDate, X509Extensions extensions);
    public void AddCrl(X509Crl other);
    [ObsoleteAttribute("Not needed if Generate used with an ISignatureFactory")]
public void SetSignatureAlgorithm(string signatureAlgorithm);
    public void AddExtension(string oid, bool critical, Asn1Encodable extensionValue);
    public void AddExtension(DerObjectIdentifier oid, bool critical, Asn1Encodable extensionValue);
    public void AddExtension(string oid, bool critical, Byte[] extensionValue);
    public void AddExtension(DerObjectIdentifier oid, bool critical, Byte[] extensionValue);
    [ObsoleteAttribute("Use Generate with an ISignatureFactory")]
public X509Crl Generate(AsymmetricKeyParameter privateKey);
    [ObsoleteAttribute("Use Generate with an ISignatureFactory")]
public X509Crl Generate(AsymmetricKeyParameter privateKey, SecureRandom random);
    public X509Crl Generate(ISignatureFactory signatureCalculatorFactory);
    private TbsCertificateList GenerateCertList();
    private X509Crl GenerateJcaObject(TbsCertificateList tbsCrl, AlgorithmIdentifier algId, Byte[] signature);
    public IEnumerable get_SignatureAlgNames();
}
public class Org.BouncyCastle.X509.X509V3CertificateGenerator : object {
    private X509ExtensionsGenerator extGenerator;
    private V3TbsCertificateGenerator tbsGen;
    private DerObjectIdentifier sigOid;
    private AlgorithmIdentifier sigAlgId;
    private string signatureAlgorithm;
    public IEnumerable SignatureAlgNames { get; }
    public void Reset();
    public void SetSerialNumber(BigInteger serialNumber);
    public void SetIssuerDN(X509Name issuer);
    public void SetNotBefore(DateTime date);
    public void SetNotAfter(DateTime date);
    public void SetSubjectDN(X509Name subject);
    public void SetPublicKey(AsymmetricKeyParameter publicKey);
    [ObsoleteAttribute("Not needed if Generate used with an ISignatureFactory")]
public void SetSignatureAlgorithm(string signatureAlgorithm);
    public void SetSubjectUniqueID(Boolean[] uniqueID);
    public void SetIssuerUniqueID(Boolean[] uniqueID);
    private DerBitString booleanToBitString(Boolean[] id);
    public void AddExtension(string oid, bool critical, Asn1Encodable extensionValue);
    public void AddExtension(DerObjectIdentifier oid, bool critical, Asn1Encodable extensionValue);
    public void AddExtension(string oid, bool critical, Byte[] extensionValue);
    public void AddExtension(DerObjectIdentifier oid, bool critical, Byte[] extensionValue);
    public void CopyAndAddExtension(string oid, bool critical, X509Certificate cert);
    public void CopyAndAddExtension(DerObjectIdentifier oid, bool critical, X509Certificate cert);
    [ObsoleteAttribute("Use Generate with an ISignatureFactory")]
public X509Certificate Generate(AsymmetricKeyParameter privateKey);
    [ObsoleteAttribute("Use Generate with an ISignatureFactory")]
public X509Certificate Generate(AsymmetricKeyParameter privateKey, SecureRandom random);
    public X509Certificate Generate(ISignatureFactory signatureCalculatorFactory);
    private X509Certificate GenerateJcaObject(TbsCertificateStructure tbsCert, AlgorithmIdentifier sigAlg, Byte[] signature);
    public IEnumerable get_SignatureAlgNames();
}
[AttributeUsageAttribute("1")]
internal class System.Reflection.AssemblyMetadataAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Key { get; }
    public string Value { get; }
    public AssemblyMetadataAttribute(string key, string value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public string get_Value();
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.4.240.38484")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
    private static ThisAssembly();
}
