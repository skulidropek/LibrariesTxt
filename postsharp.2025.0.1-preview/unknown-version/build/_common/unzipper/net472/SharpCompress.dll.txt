[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal static class SharpCompress.Algorithms.Adler32 : object {
    public static UInt32 SeedValue;
    private static UInt32 BASE;
    private static UInt32 NMAX;
    public static UInt32 Calculate(ReadOnlySpan`1<byte> buffer);
    public static UInt32 Calculate(UInt32 adler, ReadOnlySpan`1<byte> buffer);
    private static UInt32 CalculateScalar(UInt32 adler, ReadOnlySpan`1<byte> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class SharpCompress.Archives.AbstractArchive`2 : object {
    private LazyReadOnlyCollection`1<TVolume> lazyVolumes;
    private LazyReadOnlyCollection`1<TEntry> lazyEntries;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ArchiveExtractionEventArgs`1<IArchiveEntry>> EntryExtractionBegin;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ArchiveExtractionEventArgs`1<IArchiveEntry>> EntryExtractionEnd;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<CompressedBytesReadEventArgs> CompressedBytesRead;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<FilePartExtractionBeginEventArgs> FilePartExtractionBegin;
    [CompilerGeneratedAttribute]
private ReaderOptions <ReaderOptions>k__BackingField;
    private bool disposed;
    protected SourceStream SrcStream;
    [CompilerGeneratedAttribute]
private ArchiveType <Type>k__BackingField;
    protected ReaderOptions ReaderOptions { get; }
    public ArchiveType Type { get; }
    public ICollection`1<TEntry> Entries { get; }
    public ICollection`1<TVolume> Volumes { get; }
    public long TotalSize { get; }
    public long TotalUncompressSize { get; }
    private IEnumerable`1<IArchiveEntry> SharpCompress.Archives.IArchive.Entries { get; }
    private IEnumerable`1<IVolume> SharpCompress.Archives.IArchive.Volumes { get; }
    public bool IsSolid { get; }
    public bool IsComplete { get; }
    internal AbstractArchive`2(ArchiveType type, SourceStream srcStream);
    internal AbstractArchive`2(ArchiveType type);
    [CompilerGeneratedAttribute]
public sealed virtual void add_EntryExtractionBegin(EventHandler`1<ArchiveExtractionEventArgs`1<IArchiveEntry>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_EntryExtractionBegin(EventHandler`1<ArchiveExtractionEventArgs`1<IArchiveEntry>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_EntryExtractionEnd(EventHandler`1<ArchiveExtractionEventArgs`1<IArchiveEntry>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_EntryExtractionEnd(EventHandler`1<ArchiveExtractionEventArgs`1<IArchiveEntry>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CompressedBytesRead(EventHandler`1<CompressedBytesReadEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CompressedBytesRead(EventHandler`1<CompressedBytesReadEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_FilePartExtractionBegin(EventHandler`1<FilePartExtractionBeginEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_FilePartExtractionBegin(EventHandler`1<FilePartExtractionBeginEventArgs> value);
    [CompilerGeneratedAttribute]
protected ReaderOptions get_ReaderOptions();
    [CompilerGeneratedAttribute]
public sealed virtual ArchiveType get_Type();
    private sealed virtual override void SharpCompress.Archives.IArchiveExtractionListener.FireEntryExtractionBegin(IArchiveEntry entry);
    private sealed virtual override void SharpCompress.Archives.IArchiveExtractionListener.FireEntryExtractionEnd(IArchiveEntry entry);
    private static Stream CheckStreams(Stream stream);
    public virtual ICollection`1<TEntry> get_Entries();
    public ICollection`1<TVolume> get_Volumes();
    public virtual long get_TotalSize();
    public virtual long get_TotalUncompressSize();
    protected abstract virtual IEnumerable`1<TVolume> LoadVolumes(SourceStream srcStream);
    protected abstract virtual IEnumerable`1<TEntry> LoadEntries(IEnumerable`1<TVolume> volumes);
    private sealed virtual override IEnumerable`1<IArchiveEntry> SharpCompress.Archives.IArchive.get_Entries();
    private sealed virtual override IEnumerable`1<IVolume> SharpCompress.Archives.IArchive.get_Volumes();
    public virtual void Dispose();
    private sealed virtual override void SharpCompress.Archives.IArchiveExtractionListener.EnsureEntriesLoaded();
    private sealed virtual override void SharpCompress.Common.IExtractionListener.FireCompressedBytesRead(long currentPartCompressedBytes, long compressedReadBytes);
    private sealed virtual override void SharpCompress.Common.IExtractionListener.FireFilePartExtractionBegin(string name, long size, long compressedSize);
    public sealed virtual IReader ExtractAllEntries();
    protected abstract virtual IReader CreateReaderForSolidExtraction();
    public virtual bool get_IsSolid();
    public sealed virtual bool get_IsComplete();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class SharpCompress.Archives.AbstractWritableArchive`2 : AbstractArchive`2<TEntry, TVolume> {
    private List`1<TEntry> newEntries;
    private List`1<TEntry> removedEntries;
    private List`1<TEntry> modifiedEntries;
    private bool hasModifications;
    private bool pauseRebuilding;
    public ICollection`1<TEntry> Entries { get; }
    private IEnumerable`1<TEntry> OldEntries { get; }
    internal AbstractWritableArchive`2(ArchiveType type);
    internal AbstractWritableArchive`2(ArchiveType type, SourceStream srcStream);
    public virtual ICollection`1<TEntry> get_Entries();
    public sealed virtual IDisposable PauseEntryRebuilding();
    private void RebuildModifiedCollection();
    private IEnumerable`1<TEntry> get_OldEntries();
    public void RemoveEntry(TEntry entry);
    private sealed virtual override void SharpCompress.Archives.IWritableArchive.RemoveEntry(IArchiveEntry entry);
    public TEntry AddEntry(string key, Stream source, long size, Nullable`1<DateTime> modified);
    private sealed virtual override IArchiveEntry SharpCompress.Archives.IWritableArchive.AddEntry(string key, Stream source, bool closeStream, long size, Nullable`1<DateTime> modified);
    public TEntry AddEntry(string key, Stream source, bool closeStream, long size, Nullable`1<DateTime> modified);
    private bool DoesKeyMatchExisting(string key);
    public sealed virtual void SaveTo(Stream stream, WriterOptions options);
    protected TEntry CreateEntry(string key, Stream source, long size, Nullable`1<DateTime> modified, bool closeStream);
    protected abstract virtual TEntry CreateEntryInternal(string key, Stream source, long size, Nullable`1<DateTime> modified, bool closeStream);
    protected abstract virtual void SaveTo(Stream stream, WriterOptions options, IEnumerable`1<TEntry> oldEntries, IEnumerable`1<TEntry> newEntries);
    public virtual void Dispose();
    [CompilerGeneratedAttribute]
private bool <RebuildModifiedCollection>b__11_0(TEntry v);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <get_OldEntries>b__13_0(TEntry x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class SharpCompress.Archives.ArchiveFactory : object {
    public static IArchive Open(Stream stream, ReaderOptions readerOptions);
    public static IWritableArchive Create(ArchiveType type);
    public static IArchive Open(string filePath, ReaderOptions options);
    public static IArchive Open(FileInfo fileInfo, ReaderOptions options);
    public static IArchive Open(IEnumerable`1<FileInfo> fileInfos, ReaderOptions options);
    public static IArchive Open(IEnumerable`1<Stream> streams, ReaderOptions options);
    public static void WriteToDirectory(string sourceArchive, string destinationDirectory, ExtractionOptions options);
    private static T FindFactory(FileInfo finfo);
    private static T FindFactory(Stream stream);
    public static bool IsArchive(string filePath, Nullable`1& type);
    public static bool IsArchive(Stream stream, Nullable`1& type);
    public static IEnumerable`1<string> GetFileParts(string part1);
    [IteratorStateMachineAttribute("SharpCompress.Archives.ArchiveFactory/<GetFileParts>d__12")]
public static IEnumerable`1<FileInfo> GetFileParts(FileInfo part1);
}
internal abstract class SharpCompress.Archives.ArchiveVolumeFactory : object {
    [NullableContextAttribute("1")]
internal static FileInfo GetFilePart(int index, FileInfo part1);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class SharpCompress.Archives.GZip.GZipArchive : AbstractWritableArchive`2<GZipArchiveEntry, GZipVolume> {
    internal GZipArchive(SourceStream srcStream);
    public static GZipArchive Open(string filePath, ReaderOptions readerOptions);
    public static GZipArchive Open(FileInfo fileInfo, ReaderOptions readerOptions);
    public static GZipArchive Open(IEnumerable`1<FileInfo> fileInfos, ReaderOptions readerOptions);
    public static GZipArchive Open(IEnumerable`1<Stream> streams, ReaderOptions readerOptions);
    public static GZipArchive Open(Stream stream, ReaderOptions readerOptions);
    public static GZipArchive Create();
    protected virtual IEnumerable`1<GZipVolume> LoadVolumes(SourceStream srcStream);
    public static bool IsGZipFile(string filePath);
    public static bool IsGZipFile(FileInfo fileInfo);
    public void SaveTo(string filePath);
    public void SaveTo(FileInfo fileInfo);
    public static bool IsGZipFile(Stream stream);
    protected virtual GZipArchiveEntry CreateEntryInternal(string filePath, Stream source, long size, Nullable`1<DateTime> modified, bool closeStream);
    protected virtual void SaveTo(Stream stream, WriterOptions options, IEnumerable`1<GZipArchiveEntry> oldEntries, IEnumerable`1<GZipArchiveEntry> newEntries);
    [IteratorStateMachineAttribute("SharpCompress.Archives.GZip.GZipArchive/<LoadEntries>d__16")]
protected virtual IEnumerable`1<GZipArchiveEntry> LoadEntries(IEnumerable`1<GZipVolume> volumes);
    protected virtual IReader CreateReaderForSolidExtraction();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Archives.GZip.GZipArchiveEntry : GZipEntry {
    [CompilerGeneratedAttribute]
private IArchive <Archive>k__BackingField;
    public IArchive Archive { get; }
    public bool IsComplete { get; }
    internal GZipArchiveEntry(GZipArchive archive, GZipFilePart part);
    public virtual Stream OpenEntryStream();
    [CompilerGeneratedAttribute]
public sealed virtual IArchive get_Archive();
    public sealed virtual bool get_IsComplete();
}
internal class SharpCompress.Archives.GZip.GZipWritableArchiveEntry : GZipArchiveEntry {
    private bool closeStream;
    private Stream stream;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastModifiedTime>k__BackingField;
    public long Crc { get; }
    public string Key { get; }
    public long CompressedSize { get; }
    public long Size { get; }
    public Nullable`1<DateTime> LastModifiedTime { get; }
    public Nullable`1<DateTime> CreatedTime { get; }
    public Nullable`1<DateTime> LastAccessedTime { get; }
    public Nullable`1<DateTime> ArchivedTime { get; }
    public bool IsEncrypted { get; }
    public bool IsDirectory { get; }
    public bool IsSplitAfter { get; }
    internal IEnumerable`1<FilePart> Parts { get; }
    private Stream SharpCompress.Archives.IWritableArchiveEntry.Stream { get; }
    internal GZipWritableArchiveEntry(GZipArchive archive, Stream stream, string path, long size, Nullable`1<DateTime> lastModified, bool closeStream);
    public virtual long get_Crc();
    [CompilerGeneratedAttribute]
public virtual string get_Key();
    public virtual long get_CompressedSize();
    [CompilerGeneratedAttribute]
public virtual long get_Size();
    [CompilerGeneratedAttribute]
public virtual Nullable`1<DateTime> get_LastModifiedTime();
    public virtual Nullable`1<DateTime> get_CreatedTime();
    public virtual Nullable`1<DateTime> get_LastAccessedTime();
    public virtual Nullable`1<DateTime> get_ArchivedTime();
    public virtual bool get_IsEncrypted();
    public virtual bool get_IsDirectory();
    public virtual bool get_IsSplitAfter();
    internal virtual IEnumerable`1<FilePart> get_Parts();
    private sealed virtual override Stream SharpCompress.Archives.IWritableArchiveEntry.get_Stream();
    public virtual Stream OpenEntryStream();
    internal virtual void Close();
}
[NullableContextAttribute("1")]
public interface SharpCompress.Archives.IArchive {
    public IEnumerable`1<IArchiveEntry> Entries { get; }
    public IEnumerable`1<IVolume> Volumes { get; }
    public ArchiveType Type { get; }
    public bool IsSolid { get; }
    public bool IsComplete { get; }
    public long TotalSize { get; }
    public long TotalUncompressSize { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_EntryExtractionBegin(EventHandler`1<ArchiveExtractionEventArgs`1<IArchiveEntry>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_EntryExtractionBegin(EventHandler`1<ArchiveExtractionEventArgs`1<IArchiveEntry>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_EntryExtractionEnd(EventHandler`1<ArchiveExtractionEventArgs`1<IArchiveEntry>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_EntryExtractionEnd(EventHandler`1<ArchiveExtractionEventArgs`1<IArchiveEntry>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CompressedBytesRead(EventHandler`1<CompressedBytesReadEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CompressedBytesRead(EventHandler`1<CompressedBytesReadEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_FilePartExtractionBegin(EventHandler`1<FilePartExtractionBeginEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_FilePartExtractionBegin(EventHandler`1<FilePartExtractionBeginEventArgs> value);
    public abstract virtual IEnumerable`1<IArchiveEntry> get_Entries();
    public abstract virtual IEnumerable`1<IVolume> get_Volumes();
    public abstract virtual ArchiveType get_Type();
    public abstract virtual IReader ExtractAllEntries();
    public abstract virtual bool get_IsSolid();
    public abstract virtual bool get_IsComplete();
    public abstract virtual long get_TotalSize();
    public abstract virtual long get_TotalUncompressSize();
}
[NullableContextAttribute("1")]
public interface SharpCompress.Archives.IArchiveEntry {
    public bool IsComplete { get; }
    public IArchive Archive { get; }
    public abstract virtual Stream OpenEntryStream();
    public abstract virtual bool get_IsComplete();
    public abstract virtual IArchive get_Archive();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SharpCompress.Archives.IArchiveEntryExtensions : object {
    [ExtensionAttribute]
public static void WriteTo(IArchiveEntry archiveEntry, Stream streamToWriteTo);
    [ExtensionAttribute]
public static void WriteToDirectory(IArchiveEntry entry, string destinationDirectory, ExtractionOptions options);
    [ExtensionAttribute]
public static void WriteToFile(IArchiveEntry entry, string destinationFileName, ExtractionOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SharpCompress.Archives.IArchiveExtensions : object {
    [ExtensionAttribute]
public static void WriteToDirectory(IArchive archive, string destinationDirectory, ExtractionOptions options);
    [ExtensionAttribute]
public static void ExtractToDirectory(IArchive archive, string destination, Action`1<double> progressReport, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface SharpCompress.Archives.IArchiveExtractionListener {
    public abstract virtual void EnsureEntriesLoaded();
    public abstract virtual void FireEntryExtractionBegin(IArchiveEntry entry);
    public abstract virtual void FireEntryExtractionEnd(IArchiveEntry entry);
}
[NullableContextAttribute("1")]
public interface SharpCompress.Archives.IArchiveFactory {
    public abstract virtual IArchive Open(Stream stream, ReaderOptions readerOptions);
    public abstract virtual IArchive Open(FileInfo fileInfo, ReaderOptions readerOptions);
}
[NullableContextAttribute("1")]
public interface SharpCompress.Archives.IMultiArchiveFactory {
    public abstract virtual IArchive Open(IReadOnlyList`1<Stream> streams, ReaderOptions readerOptions);
    public abstract virtual IArchive Open(IReadOnlyList`1<FileInfo> fileInfos, ReaderOptions readerOptions);
}
[NullableContextAttribute("1")]
public interface SharpCompress.Archives.IWritableArchive {
    public abstract virtual void RemoveEntry(IArchiveEntry entry);
    public abstract virtual IArchiveEntry AddEntry(string key, Stream source, bool closeStream, long size, Nullable`1<DateTime> modified);
    public abstract virtual void SaveTo(Stream stream, WriterOptions options);
    public abstract virtual IDisposable PauseEntryRebuilding();
}
[NullableContextAttribute("1")]
internal interface SharpCompress.Archives.IWritableArchiveEntry {
    public Stream Stream { get; }
    public abstract virtual Stream get_Stream();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SharpCompress.Archives.IWritableArchiveExtensions : object {
    [ExtensionAttribute]
public static void AddEntry(IWritableArchive writableArchive, string entryPath, string filePath);
    [ExtensionAttribute]
public static void SaveTo(IWritableArchive writableArchive, string filePath, WriterOptions options);
    [ExtensionAttribute]
public static void SaveTo(IWritableArchive writableArchive, FileInfo fileInfo, WriterOptions options);
    [ExtensionAttribute]
public static void AddAllFromDirectory(IWritableArchive writableArchive, string filePath, string searchPattern, SearchOption searchOption);
    [ExtensionAttribute]
public static IArchiveEntry AddEntry(IWritableArchive writableArchive, string key, FileInfo fileInfo);
}
public interface SharpCompress.Archives.IWriteableArchiveFactory {
    [NullableContextAttribute("1")]
public abstract virtual IWritableArchive CreateWriteableArchive();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Archives.Rar.FileInfoRarArchiveVolume : RarVolume {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<RarFilePart> <FileParts>k__BackingField;
    [CompilerGeneratedAttribute]
private FileInfo <FileInfo>k__BackingField;
    internal ReadOnlyCollection`1<RarFilePart> FileParts { get; }
    internal FileInfo FileInfo { get; }
    internal FileInfoRarArchiveVolume(FileInfo fileInfo, ReaderOptions options, int index);
    private static ReaderOptions FixOptions(ReaderOptions options);
    [CompilerGeneratedAttribute]
internal ReadOnlyCollection`1<RarFilePart> get_FileParts();
    [CompilerGeneratedAttribute]
internal FileInfo get_FileInfo();
    internal virtual RarFilePart CreateFilePart(MarkHeader markHeader, FileHeader fileHeader);
    internal virtual IEnumerable`1<RarFilePart> ReadFileParts();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Archives.Rar.FileInfoRarFilePart : SeekableFilePart {
    [CompilerGeneratedAttribute]
private FileInfo <FileInfo>k__BackingField;
    internal FileInfo FileInfo { get; }
    internal string FilePartName { get; }
    internal FileInfoRarFilePart(FileInfoRarArchiveVolume volume, string password, MarkHeader mh, FileHeader fh, FileInfo fi);
    [CompilerGeneratedAttribute]
internal FileInfo get_FileInfo();
    internal virtual string get_FilePartName();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class SharpCompress.Archives.Rar.RarArchive : AbstractArchive`2<RarArchiveEntry, RarVolume> {
    [CompilerGeneratedAttribute]
private Lazy`1<IRarUnpack> <UnpackV2017>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<IRarUnpack> <UnpackV1>k__BackingField;
    internal Lazy`1<IRarUnpack> UnpackV2017 { get; }
    internal Lazy`1<IRarUnpack> UnpackV1 { get; }
    public bool IsSolid { get; }
    public int MinVersion { get; }
    public int MaxVersion { get; }
    internal RarArchive(SourceStream srcStream);
    [CompilerGeneratedAttribute]
internal Lazy`1<IRarUnpack> get_UnpackV2017();
    [CompilerGeneratedAttribute]
internal Lazy`1<IRarUnpack> get_UnpackV1();
    protected virtual IEnumerable`1<RarArchiveEntry> LoadEntries(IEnumerable`1<RarVolume> volumes);
    protected virtual IEnumerable`1<RarVolume> LoadVolumes(SourceStream srcStream);
    protected virtual IReader CreateReaderForSolidExtraction();
    public virtual bool get_IsSolid();
    public virtual int get_MinVersion();
    public virtual int get_MaxVersion();
    public static RarArchive Open(string filePath, ReaderOptions options);
    public static RarArchive Open(FileInfo fileInfo, ReaderOptions options);
    public static RarArchive Open(Stream stream, ReaderOptions options);
    public static RarArchive Open(IEnumerable`1<FileInfo> fileInfos, ReaderOptions readerOptions);
    public static RarArchive Open(IEnumerable`1<Stream> streams, ReaderOptions readerOptions);
    public static bool IsRarFile(string filePath);
    public static bool IsRarFile(FileInfo fileInfo);
    public static bool IsRarFile(Stream stream, ReaderOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Archives.Rar.RarArchiveEntry : RarEntry {
    private ICollection`1<RarFilePart> parts;
    private RarArchive archive;
    private ReaderOptions readerOptions;
    public CompressionType CompressionType { get; }
    public IArchive Archive { get; }
    internal IEnumerable`1<FilePart> Parts { get; }
    internal FileHeader FileHeader { get; }
    public long Crc { get; }
    public long Size { get; }
    public long CompressedSize { get; }
    public bool IsComplete { get; }
    internal RarArchiveEntry(RarArchive archive, IEnumerable`1<RarFilePart> parts, ReaderOptions readerOptions);
    public virtual CompressionType get_CompressionType();
    public sealed virtual IArchive get_Archive();
    internal virtual IEnumerable`1<FilePart> get_Parts();
    internal virtual FileHeader get_FileHeader();
    public virtual long get_Crc();
    public virtual long get_Size();
    public virtual long get_CompressedSize();
    public sealed virtual Stream OpenEntryStream();
    public sealed virtual bool get_IsComplete();
    private void CheckIncomplete();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SharpCompress.Archives.Rar.RarArchiveEntryFactory : object {
    [IteratorStateMachineAttribute("SharpCompress.Archives.Rar.RarArchiveEntryFactory/<GetFileParts>d__0")]
private static IEnumerable`1<RarFilePart> GetFileParts(IEnumerable`1<RarVolume> parts);
    [IteratorStateMachineAttribute("SharpCompress.Archives.Rar.RarArchiveEntryFactory/<GetMatchedFileParts>d__1")]
private static IEnumerable`1<IEnumerable`1<RarFilePart>> GetMatchedFileParts(IEnumerable`1<RarVolume> parts);
    [IteratorStateMachineAttribute("SharpCompress.Archives.Rar.RarArchiveEntryFactory/<GetEntries>d__2")]
internal static IEnumerable`1<RarArchiveEntry> GetEntries(RarArchive archive, IEnumerable`1<RarVolume> rarParts, ReaderOptions readerOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SharpCompress.Archives.Rar.RarArchiveExtensions : object {
    [ExtensionAttribute]
public static bool IsFirstVolume(RarArchive archive);
    [ExtensionAttribute]
public static bool IsMultipartVolume(RarArchive archive);
}
internal static class SharpCompress.Archives.Rar.RarArchiveVolumeFactory : object {
    [NullableContextAttribute("1")]
internal static FileInfo GetFilePart(int index, FileInfo part1);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Archives.Rar.SeekableFilePart : RarFilePart {
    private Stream stream;
    [NullableAttribute("2")]
private string password;
    internal string FilePartName { get; }
    internal SeekableFilePart(MarkHeader mh, FileHeader fh, int index, Stream stream, string password);
    internal virtual Stream GetCompressedStream();
    internal virtual string get_FilePartName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Archives.Rar.StreamRarArchiveVolume : RarVolume {
    internal StreamRarArchiveVolume(Stream stream, ReaderOptions options, int index);
    internal virtual IEnumerable`1<RarFilePart> ReadFileParts();
    internal virtual RarFilePart CreateFilePart(MarkHeader markHeader, FileHeader fileHeader);
}
public class SharpCompress.Archives.SevenZip.SevenZipArchive : AbstractArchive`2<SevenZipArchiveEntry, SevenZipVolume> {
    private ArchiveDatabase database;
    private static ReadOnlySpan`1<byte> SIGNATURE { get; }
    public bool IsSolid { get; }
    public long TotalSize { get; }
    internal SevenZipArchive(SourceStream srcStream);
    public static SevenZipArchive Open(string filePath, ReaderOptions readerOptions);
    public static SevenZipArchive Open(FileInfo fileInfo, ReaderOptions readerOptions);
    public static SevenZipArchive Open(IEnumerable`1<FileInfo> fileInfos, ReaderOptions readerOptions);
    public static SevenZipArchive Open(IEnumerable`1<Stream> streams, ReaderOptions readerOptions);
    public static SevenZipArchive Open(Stream stream, ReaderOptions readerOptions);
    protected virtual IEnumerable`1<SevenZipVolume> LoadVolumes(SourceStream srcStream);
    public static bool IsSevenZipFile(string filePath);
    public static bool IsSevenZipFile(FileInfo fileInfo);
    protected virtual IEnumerable`1<SevenZipArchiveEntry> LoadEntries(IEnumerable`1<SevenZipVolume> volumes);
    private void LoadFactory(Stream stream);
    public static bool IsSevenZipFile(Stream stream);
    private static ReadOnlySpan`1<byte> get_SIGNATURE();
    private static bool SignatureMatch(Stream stream);
    protected virtual IReader CreateReaderForSolidExtraction();
    public virtual bool get_IsSolid();
    public virtual long get_TotalSize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Archives.SevenZip.SevenZipArchiveEntry : SevenZipEntry {
    [CompilerGeneratedAttribute]
private IArchive <Archive>k__BackingField;
    public IArchive Archive { get; }
    public bool IsComplete { get; }
    public bool IsAnti { get; }
    internal SevenZipArchiveEntry(SevenZipArchive archive, SevenZipFilePart part);
    public sealed virtual Stream OpenEntryStream();
    [CompilerGeneratedAttribute]
public sealed virtual IArchive get_Archive();
    public sealed virtual bool get_IsComplete();
    public bool get_IsAnti();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class SharpCompress.Archives.Tar.TarArchive : AbstractWritableArchive`2<TarArchiveEntry, TarVolume> {
    internal TarArchive(SourceStream srcStream);
    public static TarArchive Open(string filePath, ReaderOptions readerOptions);
    public static TarArchive Open(FileInfo fileInfo, ReaderOptions readerOptions);
    public static TarArchive Open(IEnumerable`1<FileInfo> fileInfos, ReaderOptions readerOptions);
    public static TarArchive Open(IEnumerable`1<Stream> streams, ReaderOptions readerOptions);
    public static TarArchive Open(Stream stream, ReaderOptions readerOptions);
    public static bool IsTarFile(string filePath);
    public static bool IsTarFile(FileInfo fileInfo);
    public static bool IsTarFile(Stream stream);
    protected virtual IEnumerable`1<TarVolume> LoadVolumes(SourceStream srcStream);
    [IteratorStateMachineAttribute("SharpCompress.Archives.Tar.TarArchive/<LoadEntries>d__11")]
protected virtual IEnumerable`1<TarArchiveEntry> LoadEntries(IEnumerable`1<TarVolume> volumes);
    public static TarArchive Create();
    protected virtual TarArchiveEntry CreateEntryInternal(string filePath, Stream source, long size, Nullable`1<DateTime> modified, bool closeStream);
    protected virtual void SaveTo(Stream stream, WriterOptions options, IEnumerable`1<TarArchiveEntry> oldEntries, IEnumerable`1<TarArchiveEntry> newEntries);
    protected virtual IReader CreateReaderForSolidExtraction();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Archives.Tar.TarArchiveEntry : TarEntry {
    [CompilerGeneratedAttribute]
private IArchive <Archive>k__BackingField;
    public IArchive Archive { get; }
    public bool IsComplete { get; }
    internal TarArchiveEntry(TarArchive archive, TarFilePart part, CompressionType compressionType);
    public virtual Stream OpenEntryStream();
    [CompilerGeneratedAttribute]
public sealed virtual IArchive get_Archive();
    public sealed virtual bool get_IsComplete();
}
internal class SharpCompress.Archives.Tar.TarWritableArchiveEntry : TarArchiveEntry {
    private bool closeStream;
    private Stream stream;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastModifiedTime>k__BackingField;
    public long Crc { get; }
    public string Key { get; }
    public long CompressedSize { get; }
    public long Size { get; }
    public Nullable`1<DateTime> LastModifiedTime { get; }
    public Nullable`1<DateTime> CreatedTime { get; }
    public Nullable`1<DateTime> LastAccessedTime { get; }
    public Nullable`1<DateTime> ArchivedTime { get; }
    public bool IsEncrypted { get; }
    public bool IsDirectory { get; }
    public bool IsSplitAfter { get; }
    internal IEnumerable`1<FilePart> Parts { get; }
    private Stream SharpCompress.Archives.IWritableArchiveEntry.Stream { get; }
    internal TarWritableArchiveEntry(TarArchive archive, Stream stream, CompressionType compressionType, string path, long size, Nullable`1<DateTime> lastModified, bool closeStream);
    public virtual long get_Crc();
    [CompilerGeneratedAttribute]
public virtual string get_Key();
    public virtual long get_CompressedSize();
    [CompilerGeneratedAttribute]
public virtual long get_Size();
    [CompilerGeneratedAttribute]
public virtual Nullable`1<DateTime> get_LastModifiedTime();
    public virtual Nullable`1<DateTime> get_CreatedTime();
    public virtual Nullable`1<DateTime> get_LastAccessedTime();
    public virtual Nullable`1<DateTime> get_ArchivedTime();
    public virtual bool get_IsEncrypted();
    public virtual bool get_IsDirectory();
    public virtual bool get_IsSplitAfter();
    internal virtual IEnumerable`1<FilePart> get_Parts();
    private sealed virtual override Stream SharpCompress.Archives.IWritableArchiveEntry.get_Stream();
    public virtual Stream OpenEntryStream();
    internal virtual void Close();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class SharpCompress.Archives.Zip.ZipArchive : AbstractWritableArchive`2<ZipArchiveEntry, ZipVolume> {
    [NullableAttribute("0")]
private SeekableZipHeaderFactory headerFactory;
    [CompilerGeneratedAttribute]
private CompressionLevel <DeflateCompressionLevel>k__BackingField;
    public CompressionLevel DeflateCompressionLevel { get; public set; }
    internal ZipArchive(SourceStream srcStream);
    [CompilerGeneratedAttribute]
public CompressionLevel get_DeflateCompressionLevel();
    [CompilerGeneratedAttribute]
public void set_DeflateCompressionLevel(CompressionLevel value);
    public static ZipArchive Open(string filePath, ReaderOptions readerOptions);
    public static ZipArchive Open(FileInfo fileInfo, ReaderOptions readerOptions);
    public static ZipArchive Open(IEnumerable`1<FileInfo> fileInfos, ReaderOptions readerOptions);
    public static ZipArchive Open(IEnumerable`1<Stream> streams, ReaderOptions readerOptions);
    public static ZipArchive Open(Stream stream, ReaderOptions readerOptions);
    public static bool IsZipFile(string filePath, string password);
    public static bool IsZipFile(FileInfo fileInfo, string password);
    public static bool IsZipFile(Stream stream, string password);
    public static bool IsZipMulti(Stream stream, string password);
    protected virtual IEnumerable`1<ZipVolume> LoadVolumes(SourceStream srcStream);
    [IteratorStateMachineAttribute("SharpCompress.Archives.Zip.ZipArchive/<LoadEntries>d__17")]
protected virtual IEnumerable`1<ZipArchiveEntry> LoadEntries(IEnumerable`1<ZipVolume> volumes);
    public void SaveTo(Stream stream);
    protected virtual void SaveTo(Stream stream, WriterOptions options, IEnumerable`1<ZipArchiveEntry> oldEntries, IEnumerable`1<ZipArchiveEntry> newEntries);
    protected virtual ZipArchiveEntry CreateEntryInternal(string filePath, Stream source, long size, Nullable`1<DateTime> modified, bool closeStream);
    public static ZipArchive Create();
    protected virtual IReader CreateReaderForSolidExtraction();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Archives.Zip.ZipArchiveEntry : ZipEntry {
    [CompilerGeneratedAttribute]
private IArchive <Archive>k__BackingField;
    public IArchive Archive { get; }
    public bool IsComplete { get; }
    [NullableAttribute("2")]
public string Comment { get; }
    internal ZipArchiveEntry(ZipArchive archive, SeekableZipFilePart part);
    public virtual Stream OpenEntryStream();
    [CompilerGeneratedAttribute]
public sealed virtual IArchive get_Archive();
    public sealed virtual bool get_IsComplete();
    [NullableContextAttribute("2")]
public string get_Comment();
}
internal static class SharpCompress.Archives.Zip.ZipArchiveVolumeFactory : object {
    [NullableContextAttribute("1")]
internal static FileInfo GetFilePart(int index, FileInfo part1);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Archives.Zip.ZipWritableArchiveEntry : ZipArchiveEntry {
    private bool closeStream;
    private Stream stream;
    private bool isDisposed;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastModifiedTime>k__BackingField;
    public long Crc { get; }
    public string Key { get; }
    public long CompressedSize { get; }
    public long Size { get; }
    public Nullable`1<DateTime> LastModifiedTime { get; }
    public Nullable`1<DateTime> CreatedTime { get; }
    public Nullable`1<DateTime> LastAccessedTime { get; }
    public Nullable`1<DateTime> ArchivedTime { get; }
    public bool IsEncrypted { get; }
    public bool IsDirectory { get; }
    public bool IsSplitAfter { get; }
    internal IEnumerable`1<FilePart> Parts { get; }
    private Stream SharpCompress.Archives.IWritableArchiveEntry.Stream { get; }
    internal ZipWritableArchiveEntry(ZipArchive archive, Stream stream, string path, long size, Nullable`1<DateTime> lastModified, bool closeStream);
    public virtual long get_Crc();
    [CompilerGeneratedAttribute]
public virtual string get_Key();
    public virtual long get_CompressedSize();
    [CompilerGeneratedAttribute]
public virtual long get_Size();
    [CompilerGeneratedAttribute]
public virtual Nullable`1<DateTime> get_LastModifiedTime();
    public virtual Nullable`1<DateTime> get_CreatedTime();
    public virtual Nullable`1<DateTime> get_LastAccessedTime();
    public virtual Nullable`1<DateTime> get_ArchivedTime();
    public virtual bool get_IsEncrypted();
    public virtual bool get_IsDirectory();
    public virtual bool get_IsSplitAfter();
    internal virtual IEnumerable`1<FilePart> get_Parts();
    private sealed virtual override Stream SharpCompress.Archives.IWritableArchiveEntry.get_Stream();
    public virtual Stream OpenEntryStream();
    internal virtual void Close();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Common.ArchiveEncoding : object {
    [CompilerGeneratedAttribute]
private Encoding <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Password>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Encoding <Forced>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`4<Byte[], int, int, string> <CustomDecoder>k__BackingField;
    public Encoding Default { get; public set; }
    public Encoding Password { get; public set; }
    [NullableAttribute("2")]
public Encoding Forced { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`4<Byte[], int, int, string> CustomDecoder { get; public set; }
    public ArchiveEncoding(Encoding def, Encoding password);
    [CompilerGeneratedAttribute]
public Encoding get_Default();
    [CompilerGeneratedAttribute]
public void set_Default(Encoding value);
    [CompilerGeneratedAttribute]
public Encoding get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(Encoding value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Encoding get_Forced();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Forced(Encoding value);
    [CompilerGeneratedAttribute]
public Func`4<Byte[], int, int, string> get_CustomDecoder();
    [CompilerGeneratedAttribute]
public void set_CustomDecoder(Func`4<Byte[], int, int, string> value);
    public string Decode(Byte[] bytes);
    public string Decode(Byte[] bytes, int start, int length);
    public string DecodeUTF8(Byte[] bytes);
    public Byte[] Encode(string str);
    public Encoding GetEncoding();
    public Func`4<Byte[], int, int, string> GetDecoder();
    [CompilerGeneratedAttribute]
private string <GetDecoder>b__23_0(Byte[] bytes, int index, int count);
}
public class SharpCompress.Common.ArchiveException : Exception {
    [NullableContextAttribute("1")]
public ArchiveException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Common.ArchiveExtractionEventArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
private T <Item>k__BackingField;
    public T Item { get; }
    internal ArchiveExtractionEventArgs`1(T entry);
    [CompilerGeneratedAttribute]
public T get_Item();
}
public enum SharpCompress.Common.ArchiveType : Enum {
    public int value__;
    public static ArchiveType Rar;
    public static ArchiveType Zip;
    public static ArchiveType Tar;
    public static ArchiveType SevenZip;
    public static ArchiveType GZip;
}
public class SharpCompress.Common.CompressedBytesReadEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private long <CompressedBytesRead>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CurrentFilePartCompressedBytesRead>k__BackingField;
    public long CompressedBytesRead { get; }
    public long CurrentFilePartCompressedBytesRead { get; }
    public CompressedBytesReadEventArgs(long compressedBytesRead, long currentFilePartCompressedBytesRead);
    [CompilerGeneratedAttribute]
public long get_CompressedBytesRead();
    [CompilerGeneratedAttribute]
public long get_CurrentFilePartCompressedBytesRead();
}
public enum SharpCompress.Common.CompressionType : Enum {
    public int value__;
    public static CompressionType None;
    public static CompressionType GZip;
    public static CompressionType BZip2;
    public static CompressionType PPMd;
    public static CompressionType Deflate;
    public static CompressionType Rar;
    public static CompressionType LZMA;
    public static CompressionType BCJ;
    public static CompressionType BCJ2;
    public static CompressionType LZip;
    public static CompressionType Xz;
    public static CompressionType Unknown;
    public static CompressionType Deflate64;
}
public class SharpCompress.Common.CryptographicException : Exception {
    [NullableContextAttribute("1")]
public CryptographicException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class SharpCompress.Common.Entry : object {
    [CompilerGeneratedAttribute]
private bool <IsSolid>k__BackingField;
    public long Crc { get; }
    public string Key { get; }
    [NullableAttribute("2")]
public string LinkTarget { get; }
    public long CompressedSize { get; }
    public CompressionType CompressionType { get; }
    public long Size { get; }
    public Nullable`1<DateTime> LastModifiedTime { get; }
    public Nullable`1<DateTime> CreatedTime { get; }
    public Nullable`1<DateTime> LastAccessedTime { get; }
    public Nullable`1<DateTime> ArchivedTime { get; }
    public bool IsEncrypted { get; }
    public bool IsDirectory { get; }
    public bool IsSplitAfter { get; }
    public int VolumeIndexFirst { get; }
    public int VolumeIndexLast { get; }
    internal IEnumerable`1<FilePart> Parts { get; }
    public bool IsSolid { get; public set; }
    public Nullable`1<int> Attrib { get; }
    public abstract virtual long get_Crc();
    public abstract virtual string get_Key();
    [NullableContextAttribute("2")]
public abstract virtual string get_LinkTarget();
    public abstract virtual long get_CompressedSize();
    public abstract virtual CompressionType get_CompressionType();
    public abstract virtual long get_Size();
    public abstract virtual Nullable`1<DateTime> get_LastModifiedTime();
    public abstract virtual Nullable`1<DateTime> get_CreatedTime();
    public abstract virtual Nullable`1<DateTime> get_LastAccessedTime();
    public abstract virtual Nullable`1<DateTime> get_ArchivedTime();
    public abstract virtual bool get_IsEncrypted();
    public abstract virtual bool get_IsDirectory();
    public abstract virtual bool get_IsSplitAfter();
    public sealed virtual int get_VolumeIndexFirst();
    public sealed virtual int get_VolumeIndexLast();
    public virtual string ToString();
    internal abstract virtual IEnumerable`1<FilePart> get_Parts();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsSolid();
    [CompilerGeneratedAttribute]
public void set_IsSolid(bool value);
    internal virtual void Close();
    public virtual Nullable`1<int> get_Attrib();
}
[ExtensionAttribute]
internal static class SharpCompress.Common.EntryExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static void PreserveExtractionOptions(IEntry entry, string destinationFileName, ExtractionOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Common.EntryStream : Stream {
    private IReader _reader;
    private Stream _stream;
    private bool _completed;
    private bool _isDisposed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal EntryStream(IReader reader, Stream stream);
    public void SkipEntry();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Common.ExtractionException : Exception {
    public ExtractionException(string message);
    public ExtractionException(string message, Exception inner);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SharpCompress.Common.ExtractionMethods : object {
    public static void WriteEntryToDirectory(IEntry entry, string destinationDirectory, ExtractionOptions options, Action`2<string, ExtractionOptions> write);
    public static void WriteEntryToFile(IEntry entry, string destinationFileName, ExtractionOptions options, Action`2<string, FileMode> openAndWrite);
}
public class SharpCompress.Common.ExtractionOptions : object {
    [CompilerGeneratedAttribute]
private bool <Overwrite>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExtractFullPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveFileTime>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveAttributes>k__BackingField;
    [NullableAttribute("1")]
public SymbolicLinkWriterDelegate WriteSymbolicLink;
    public bool Overwrite { get; public set; }
    public bool ExtractFullPath { get; public set; }
    public bool PreserveFileTime { get; public set; }
    public bool PreserveAttributes { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Overwrite();
    [CompilerGeneratedAttribute]
public void set_Overwrite(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExtractFullPath();
    [CompilerGeneratedAttribute]
public void set_ExtractFullPath(bool value);
    [CompilerGeneratedAttribute]
public bool get_PreserveFileTime();
    [CompilerGeneratedAttribute]
public void set_PreserveFileTime(bool value);
    [CompilerGeneratedAttribute]
public bool get_PreserveAttributes();
    [CompilerGeneratedAttribute]
public void set_PreserveAttributes(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class SharpCompress.Common.FilePart : object {
    [CompilerGeneratedAttribute]
private ArchiveEncoding <ArchiveEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Skipped>k__BackingField;
    internal ArchiveEncoding ArchiveEncoding { get; }
    internal string FilePartName { get; }
    public int Index { get; public set; }
    internal bool Skipped { get; internal set; }
    protected FilePart(ArchiveEncoding archiveEncoding);
    [CompilerGeneratedAttribute]
internal ArchiveEncoding get_ArchiveEncoding();
    internal abstract virtual string get_FilePartName();
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    internal abstract virtual Stream GetCompressedStream();
    [NullableContextAttribute("2")]
internal abstract virtual Stream GetRawStream();
    [CompilerGeneratedAttribute]
internal bool get_Skipped();
    [CompilerGeneratedAttribute]
internal void set_Skipped(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Common.FilePartExtractionBeginEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CompressedSize>k__BackingField;
    public string Name { get; }
    public long Size { get; }
    public long CompressedSize { get; }
    public FilePartExtractionBeginEventArgs(string name, long size, long compressedSize);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public long get_Size();
    [CompilerGeneratedAttribute]
public long get_CompressedSize();
}
internal static class SharpCompress.Common.FlagUtility : object {
    public static bool HasFlag(long bitField, T flag);
    public static bool HasFlag(ulong bitField, T flag);
    public static bool HasFlag(ulong bitField, ulong flag);
    public static bool HasFlag(short bitField, short flag);
    public static bool HasFlag(T bitField, T flag);
    public static bool HasFlag(long bitField, long flag);
    public static long SetFlag(long bitField, long flag, bool on);
    public static long SetFlag(T bitField, T flag, bool on);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Common.GZip.GZipEntry : Entry {
    private GZipFilePart _filePart;
    public CompressionType CompressionType { get; }
    public long Crc { get; }
    public string Key { get; }
    [NullableAttribute("2")]
public string LinkTarget { get; }
    public long CompressedSize { get; }
    public long Size { get; }
    public Nullable`1<DateTime> LastModifiedTime { get; }
    public Nullable`1<DateTime> CreatedTime { get; }
    public Nullable`1<DateTime> LastAccessedTime { get; }
    public Nullable`1<DateTime> ArchivedTime { get; }
    public bool IsEncrypted { get; }
    public bool IsDirectory { get; }
    public bool IsSplitAfter { get; }
    internal IEnumerable`1<FilePart> Parts { get; }
    internal GZipEntry(GZipFilePart filePart);
    public virtual CompressionType get_CompressionType();
    public virtual long get_Crc();
    public virtual string get_Key();
    [NullableContextAttribute("2")]
public virtual string get_LinkTarget();
    public virtual long get_CompressedSize();
    public virtual long get_Size();
    public virtual Nullable`1<DateTime> get_LastModifiedTime();
    public virtual Nullable`1<DateTime> get_CreatedTime();
    public virtual Nullable`1<DateTime> get_LastAccessedTime();
    public virtual Nullable`1<DateTime> get_ArchivedTime();
    public virtual bool get_IsEncrypted();
    public virtual bool get_IsDirectory();
    public virtual bool get_IsSplitAfter();
    internal virtual IEnumerable`1<FilePart> get_Parts();
    [IteratorStateMachineAttribute("SharpCompress.Common.GZip.GZipEntry/<GetEntries>d__30")]
internal static IEnumerable`1<GZipEntry> GetEntries(Stream stream, OptionsBase options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.GZip.GZipFilePart : FilePart {
    [NullableAttribute("2")]
private string _name;
    private Stream _stream;
    [CompilerGeneratedAttribute]
private long <EntryStartPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <DateModified>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <Crc>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <UncompressedSize>k__BackingField;
    internal long EntryStartPosition { get; }
    internal Nullable`1<DateTime> DateModified { get; private set; }
    internal Nullable`1<UInt32> Crc { get; private set; }
    internal Nullable`1<UInt32> UncompressedSize { get; private set; }
    internal string FilePartName { get; }
    internal GZipFilePart(Stream stream, ArchiveEncoding archiveEncoding);
    [CompilerGeneratedAttribute]
internal long get_EntryStartPosition();
    [CompilerGeneratedAttribute]
internal Nullable`1<DateTime> get_DateModified();
    [CompilerGeneratedAttribute]
private void set_DateModified(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<UInt32> get_Crc();
    [CompilerGeneratedAttribute]
private void set_Crc(Nullable`1<UInt32> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<UInt32> get_UncompressedSize();
    [CompilerGeneratedAttribute]
private void set_UncompressedSize(Nullable`1<UInt32> value);
    internal virtual string get_FilePartName();
    internal virtual Stream GetCompressedStream();
    internal virtual Stream GetRawStream();
    private void ReadTrailer();
    private void ReadAndValidateGzipHeader();
    private string ReadZeroTerminatedString(Stream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Common.GZip.GZipVolume : Volume {
    public bool IsFirstVolume { get; }
    public bool IsMultiVolume { get; }
    public GZipVolume(Stream stream, ReaderOptions options, int index);
    public GZipVolume(FileInfo fileInfo, ReaderOptions options);
    public virtual bool get_IsFirstVolume();
    public virtual bool get_IsMultiVolume();
}
[NullableContextAttribute("1")]
public interface SharpCompress.Common.IEntry {
    public CompressionType CompressionType { get; }
    public Nullable`1<DateTime> ArchivedTime { get; }
    public long CompressedSize { get; }
    public long Crc { get; }
    public Nullable`1<DateTime> CreatedTime { get; }
    public string Key { get; }
    [NullableAttribute("2")]
public string LinkTarget { get; }
    public bool IsDirectory { get; }
    public bool IsEncrypted { get; }
    public bool IsSplitAfter { get; }
    public bool IsSolid { get; }
    public int VolumeIndexFirst { get; }
    public int VolumeIndexLast { get; }
    public Nullable`1<DateTime> LastAccessedTime { get; }
    public Nullable`1<DateTime> LastModifiedTime { get; }
    public long Size { get; }
    public Nullable`1<int> Attrib { get; }
    public abstract virtual CompressionType get_CompressionType();
    public abstract virtual Nullable`1<DateTime> get_ArchivedTime();
    public abstract virtual long get_CompressedSize();
    public abstract virtual long get_Crc();
    public abstract virtual Nullable`1<DateTime> get_CreatedTime();
    public abstract virtual string get_Key();
    [NullableContextAttribute("2")]
public abstract virtual string get_LinkTarget();
    public abstract virtual bool get_IsDirectory();
    public abstract virtual bool get_IsEncrypted();
    public abstract virtual bool get_IsSplitAfter();
    public abstract virtual bool get_IsSolid();
    public abstract virtual int get_VolumeIndexFirst();
    public abstract virtual int get_VolumeIndexLast();
    public abstract virtual Nullable`1<DateTime> get_LastAccessedTime();
    public abstract virtual Nullable`1<DateTime> get_LastModifiedTime();
    public abstract virtual long get_Size();
    public abstract virtual Nullable`1<int> get_Attrib();
}
[NullableContextAttribute("1")]
public interface SharpCompress.Common.IExtractionListener {
    public abstract virtual void FireFilePartExtractionBegin(string name, long size, long compressedSize);
    public abstract virtual void FireCompressedBytesRead(long currentPartCompressedBytes, long compressedReadBytes);
}
public class SharpCompress.Common.IncompleteArchiveException : ArchiveException {
    [NullableContextAttribute("1")]
public IncompleteArchiveException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Common.InvalidFormatException : ExtractionException {
    public InvalidFormatException(string message);
    public InvalidFormatException(string message, Exception inner);
}
[NullableContextAttribute("1")]
public interface SharpCompress.Common.IVolume {
    public int Index { get; }
    public string FileName { get; }
    public abstract virtual int get_Index();
    public abstract virtual string get_FileName();
}
public class SharpCompress.Common.MultipartStreamRequiredException : ExtractionException {
    [NullableContextAttribute("1")]
public MultipartStreamRequiredException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Common.MultiVolumeExtractionException : ExtractionException {
    public MultiVolumeExtractionException(string message);
    public MultiVolumeExtractionException(string message, Exception inner);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Common.OptionsBase : object {
    [CompilerGeneratedAttribute]
private bool <LeaveStreamOpen>k__BackingField;
    [CompilerGeneratedAttribute]
private ArchiveEncoding <ArchiveEncoding>k__BackingField;
    public bool LeaveStreamOpen { get; public set; }
    public ArchiveEncoding ArchiveEncoding { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_LeaveStreamOpen();
    [CompilerGeneratedAttribute]
public void set_LeaveStreamOpen(bool value);
    [CompilerGeneratedAttribute]
public ArchiveEncoding get_ArchiveEncoding();
    [CompilerGeneratedAttribute]
public void set_ArchiveEncoding(ArchiveEncoding value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Common.PasswordProtectedException : ExtractionException {
    public PasswordProtectedException(string message);
    public PasswordProtectedException(string message, Exception inner);
}
internal class SharpCompress.Common.Rar.Headers.ArchiveCryptHeader : RarHeader {
    private static int CRYPT_VERSION;
    private static int SIZE_SALT50;
    private static int SIZE_PSWCHECK;
    private static int SIZE_PSWCHECK_CSUM;
    private static int CRYPT5_KDF_LG2_COUNT_MAX;
    private bool _usePswCheck;
    private UInt32 _lg2Count;
    private Byte[] _salt;
    private Byte[] _pswCheck;
    private Byte[] _pswCheckCsm;
    public ArchiveCryptHeader(RarHeader header, RarCrcBinaryReader reader);
    protected virtual void ReadFinish(MarkingBinaryReader reader);
}
internal static class SharpCompress.Common.Rar.Headers.ArchiveFlagsV4 : object {
    public static ushort VOLUME;
    public static ushort COMMENT;
    public static ushort LOCK;
    public static ushort SOLID;
    public static ushort NEW_NUMBERING;
    public static ushort AV;
    public static ushort PROTECT;
    public static ushort PASSWORD;
    public static ushort FIRST_VOLUME;
    public static ushort ENCRYPT_VER;
}
internal static class SharpCompress.Common.Rar.Headers.ArchiveFlagsV5 : object {
    public static ushort VOLUME;
    public static ushort HAS_VOLUME_NUMBER;
    public static ushort SOLID;
    public static ushort PROTECT;
    public static ushort LOCK;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.Rar.Headers.ArchiveHeader : RarHeader {
    [CompilerGeneratedAttribute]
private ushort <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <VolumeNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<short> <HighPosAv>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <PosAv>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<byte> <EncryptionVersion>k__BackingField;
    private ushort Flags { get; private set; }
    internal Nullable`1<int> VolumeNumber { get; private set; }
    internal Nullable`1<short> HighPosAv { get; private set; }
    internal Nullable`1<int> PosAv { get; private set; }
    private Nullable`1<byte> EncryptionVersion { get; private set; }
    public Nullable`1<bool> IsEncrypted { get; }
    public bool OldNumberingFormat { get; }
    public bool IsVolume { get; }
    public bool IsFirstVolume { get; }
    public bool IsSolid { get; }
    public ArchiveHeader(RarHeader header, RarCrcBinaryReader reader);
    protected virtual void ReadFinish(MarkingBinaryReader reader);
    [CompilerGeneratedAttribute]
private ushort get_Flags();
    [CompilerGeneratedAttribute]
private void set_Flags(ushort value);
    private bool HasFlag(ushort flag);
    [CompilerGeneratedAttribute]
internal Nullable`1<int> get_VolumeNumber();
    [CompilerGeneratedAttribute]
private void set_VolumeNumber(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<short> get_HighPosAv();
    [CompilerGeneratedAttribute]
private void set_HighPosAv(Nullable`1<short> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<int> get_PosAv();
    [CompilerGeneratedAttribute]
private void set_PosAv(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
private Nullable`1<byte> get_EncryptionVersion();
    [CompilerGeneratedAttribute]
private void set_EncryptionVersion(Nullable`1<byte> value);
    public Nullable`1<bool> get_IsEncrypted();
    public bool get_OldNumberingFormat();
    public bool get_IsVolume();
    public bool get_IsFirstVolume();
    public bool get_IsSolid();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.Rar.Headers.AvHeader : RarHeader {
    [CompilerGeneratedAttribute]
private int <AvInfoCrc>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <UnpackVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <AvVersion>k__BackingField;
    internal int AvInfoCrc { get; private set; }
    internal byte UnpackVersion { get; private set; }
    internal byte Method { get; private set; }
    internal byte AvVersion { get; private set; }
    public AvHeader(RarHeader header, RarCrcBinaryReader reader);
    protected virtual void ReadFinish(MarkingBinaryReader reader);
    [CompilerGeneratedAttribute]
internal int get_AvInfoCrc();
    [CompilerGeneratedAttribute]
private void set_AvInfoCrc(int value);
    [CompilerGeneratedAttribute]
internal byte get_UnpackVersion();
    [CompilerGeneratedAttribute]
private void set_UnpackVersion(byte value);
    [CompilerGeneratedAttribute]
internal byte get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(byte value);
    [CompilerGeneratedAttribute]
internal byte get_AvVersion();
    [CompilerGeneratedAttribute]
private void set_AvVersion(byte value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.Rar.Headers.CommentHeader : RarHeader {
    [CompilerGeneratedAttribute]
private short <UnpSize>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <UnpVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <UnpMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private short <CommCrc>k__BackingField;
    internal short UnpSize { get; private set; }
    internal byte UnpVersion { get; private set; }
    internal byte UnpMethod { get; private set; }
    internal short CommCrc { get; private set; }
    protected CommentHeader(RarHeader header, RarCrcBinaryReader reader);
    protected virtual void ReadFinish(MarkingBinaryReader reader);
    [CompilerGeneratedAttribute]
internal short get_UnpSize();
    [CompilerGeneratedAttribute]
private void set_UnpSize(short value);
    [CompilerGeneratedAttribute]
internal byte get_UnpVersion();
    [CompilerGeneratedAttribute]
private void set_UnpVersion(byte value);
    [CompilerGeneratedAttribute]
internal byte get_UnpMethod();
    [CompilerGeneratedAttribute]
private void set_UnpMethod(byte value);
    [CompilerGeneratedAttribute]
internal short get_CommCrc();
    [CompilerGeneratedAttribute]
private void set_CommCrc(short value);
}
internal static class SharpCompress.Common.Rar.Headers.EncryptionFlagsV5 : object {
    public static UInt32 CHFL_CRYPT_PSWCHECK;
    public static UInt32 FHEXTRA_CRYPT_PSWCHECK;
    public static UInt32 FHEXTRA_CRYPT_HASHMAC;
}
internal static class SharpCompress.Common.Rar.Headers.EndArchiveFlagsV4 : object {
    public static ushort NEXT_VOLUME;
    public static ushort DATA_CRC;
    public static ushort REV_SPACE;
    public static ushort VOLUME_NUMBER;
}
internal static class SharpCompress.Common.Rar.Headers.EndArchiveFlagsV5 : object {
    public static ushort HAS_NEXT_VOLUME;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.Rar.Headers.EndArchiveHeader : RarHeader {
    [CompilerGeneratedAttribute]
private ushort <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ArchiveCrc>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<short> <VolumeNumber>k__BackingField;
    private ushort Flags { get; private set; }
    internal Nullable`1<int> ArchiveCrc { get; private set; }
    internal Nullable`1<short> VolumeNumber { get; private set; }
    public EndArchiveHeader(RarHeader header, RarCrcBinaryReader reader);
    protected virtual void ReadFinish(MarkingBinaryReader reader);
    [CompilerGeneratedAttribute]
private ushort get_Flags();
    [CompilerGeneratedAttribute]
private void set_Flags(ushort value);
    private bool HasFlag(ushort flag);
    [CompilerGeneratedAttribute]
internal Nullable`1<int> get_ArchiveCrc();
    [CompilerGeneratedAttribute]
private void set_ArchiveCrc(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<short> get_VolumeNumber();
    [CompilerGeneratedAttribute]
private void set_VolumeNumber(Nullable`1<short> value);
}
internal static class SharpCompress.Common.Rar.Headers.FileFlagsV4 : object {
    public static ushort SPLIT_BEFORE;
    public static ushort SPLIT_AFTER;
    public static ushort PASSWORD;
    public static ushort COMMENT;
    public static ushort SOLID;
    public static ushort WINDOW_MASK;
    public static ushort WINDOW64;
    public static ushort WINDOW128;
    public static ushort WINDOW256;
    public static ushort WINDOW512;
    public static ushort WINDOW1024;
    public static ushort WINDOW2048;
    public static ushort WINDOW4096;
    public static ushort DIRECTORY;
    public static ushort LARGE;
    public static ushort UNICODE;
    public static ushort SALT;
    public static ushort VERSION;
    public static ushort EXT_TIME;
    public static ushort EXT_FLAGS;
}
internal static class SharpCompress.Common.Rar.Headers.FileFlagsV5 : object {
    public static ushort DIRECTORY;
    public static ushort HAS_MOD_TIME;
    public static ushort HAS_CRC32;
    public static ushort UNPACKED_SIZE_UNKNOWN;
}
internal class SharpCompress.Common.Rar.Headers.FileHeader : RarHeader {
    private UInt32 _fileCrc;
    [CompilerGeneratedAttribute]
private ushort <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <CompressionMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <CompressionAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSolid>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <WindowSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <R4Salt>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <HostOs>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <FileAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <UncompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <SubData>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RecoverySectors>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DataStartPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <PackedStream>k__BackingField;
    private bool isEncryptedRar5;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <FileLastModifiedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <FileCreatedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <FileLastAccessedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <FileArchivedTime>k__BackingField;
    private ushort Flags { get; private set; }
    internal UInt32 FileCrc { get; private set; }
    internal byte CompressionMethod { get; private set; }
    internal bool IsStored { get; }
    internal byte CompressionAlgorithm { get; private set; }
    public bool IsSolid { get; private set; }
    internal UInt32 WindowSize { get; private set; }
    internal Byte[] R4Salt { get; private set; }
    private byte HostOs { get; private set; }
    internal UInt32 FileAttributes { get; private set; }
    internal long CompressedSize { get; private set; }
    internal long UncompressedSize { get; private set; }
    internal string FileName { get; private set; }
    internal Byte[] SubData { get; private set; }
    internal int RecoverySectors { get; private set; }
    internal long DataStartPosition { get; internal set; }
    public Stream PackedStream { get; public set; }
    public bool IsSplitBefore { get; }
    public bool IsSplitAfter { get; }
    public bool IsDirectory { get; }
    public bool IsEncrypted { get; }
    internal Nullable`1<DateTime> FileLastModifiedTime { get; private set; }
    internal Nullable`1<DateTime> FileCreatedTime { get; private set; }
    internal Nullable`1<DateTime> FileLastAccessedTime { get; private set; }
    internal Nullable`1<DateTime> FileArchivedTime { get; private set; }
    public FileHeader(RarHeader header, RarCrcBinaryReader reader, HeaderType headerType);
    protected virtual void ReadFinish(MarkingBinaryReader reader);
    private void ReadFromReaderV5(MarkingBinaryReader reader);
    private static DateTime ReadExtendedTimeV5(MarkingBinaryReader reader, bool isWindowsTime);
    private static string ConvertPathV5(string path);
    private void ReadFromReaderV4(MarkingBinaryReader reader);
    private static long UInt32To64(UInt32 x, UInt32 y);
    private static Nullable`1<DateTime> ProcessExtendedTimeV4(ushort extendedFlags, Nullable`1<DateTime> time, MarkingBinaryReader reader, int i);
    private static string ConvertPathV4(string path);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private ushort get_Flags();
    [CompilerGeneratedAttribute]
private void set_Flags(ushort value);
    private bool HasFlag(ushort flag);
    internal UInt32 get_FileCrc();
    private void set_FileCrc(UInt32 value);
    [CompilerGeneratedAttribute]
internal byte get_CompressionMethod();
    [CompilerGeneratedAttribute]
private void set_CompressionMethod(byte value);
    internal bool get_IsStored();
    [CompilerGeneratedAttribute]
internal byte get_CompressionAlgorithm();
    [CompilerGeneratedAttribute]
private void set_CompressionAlgorithm(byte value);
    [CompilerGeneratedAttribute]
public bool get_IsSolid();
    [CompilerGeneratedAttribute]
private void set_IsSolid(bool value);
    [CompilerGeneratedAttribute]
internal UInt32 get_WindowSize();
    [CompilerGeneratedAttribute]
private void set_WindowSize(UInt32 value);
    [CompilerGeneratedAttribute]
internal Byte[] get_R4Salt();
    [CompilerGeneratedAttribute]
private void set_R4Salt(Byte[] value);
    [CompilerGeneratedAttribute]
private byte get_HostOs();
    [CompilerGeneratedAttribute]
private void set_HostOs(byte value);
    [CompilerGeneratedAttribute]
internal UInt32 get_FileAttributes();
    [CompilerGeneratedAttribute]
private void set_FileAttributes(UInt32 value);
    [CompilerGeneratedAttribute]
internal long get_CompressedSize();
    [CompilerGeneratedAttribute]
private void set_CompressedSize(long value);
    [CompilerGeneratedAttribute]
internal long get_UncompressedSize();
    [CompilerGeneratedAttribute]
private void set_UncompressedSize(long value);
    [CompilerGeneratedAttribute]
internal string get_FileName();
    [CompilerGeneratedAttribute]
private void set_FileName(string value);
    [CompilerGeneratedAttribute]
internal Byte[] get_SubData();
    [CompilerGeneratedAttribute]
private void set_SubData(Byte[] value);
    [CompilerGeneratedAttribute]
internal int get_RecoverySectors();
    [CompilerGeneratedAttribute]
private void set_RecoverySectors(int value);
    [CompilerGeneratedAttribute]
internal long get_DataStartPosition();
    [CompilerGeneratedAttribute]
internal void set_DataStartPosition(long value);
    [CompilerGeneratedAttribute]
public Stream get_PackedStream();
    [CompilerGeneratedAttribute]
public void set_PackedStream(Stream value);
    public bool get_IsSplitBefore();
    public bool get_IsSplitAfter();
    public bool get_IsDirectory();
    public bool get_IsEncrypted();
    [CompilerGeneratedAttribute]
internal Nullable`1<DateTime> get_FileLastModifiedTime();
    [CompilerGeneratedAttribute]
private void set_FileLastModifiedTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<DateTime> get_FileCreatedTime();
    [CompilerGeneratedAttribute]
private void set_FileCreatedTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<DateTime> get_FileLastAccessedTime();
    [CompilerGeneratedAttribute]
private void set_FileLastAccessedTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<DateTime> get_FileArchivedTime();
    [CompilerGeneratedAttribute]
private void set_FileArchivedTime(Nullable`1<DateTime> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SharpCompress.Common.Rar.Headers.FileNameDecoder : object {
    internal static int GetChar(Byte[] name, int pos);
    internal static string Decode(Byte[] name, int encPos);
}
internal static class SharpCompress.Common.Rar.Headers.HeaderCodeV : object {
    public static byte RAR4_MARK_HEADER;
    public static byte RAR4_ARCHIVE_HEADER;
    public static byte RAR4_FILE_HEADER;
    public static byte RAR4_COMMENT_HEADER;
    public static byte RAR4_AV_HEADER;
    public static byte RAR4_SUB_HEADER;
    public static byte RAR4_PROTECT_HEADER;
    public static byte RAR4_SIGN_HEADER;
    public static byte RAR4_NEW_SUB_HEADER;
    public static byte RAR4_END_ARCHIVE_HEADER;
    public static byte RAR5_ARCHIVE_HEADER;
    public static byte RAR5_FILE_HEADER;
    public static byte RAR5_SERVICE_HEADER;
    public static byte RAR5_ARCHIVE_ENCRYPTION_HEADER;
    public static byte RAR5_END_ARCHIVE_HEADER;
}
internal static class SharpCompress.Common.Rar.Headers.HeaderFlagsV4 : object {
    public static ushort HAS_DATA;
}
internal static class SharpCompress.Common.Rar.Headers.HeaderFlagsV5 : object {
    public static ushort HAS_EXTRA;
    public static ushort HAS_DATA;
    public static ushort KEEP;
    public static ushort SPLIT_BEFORE;
    public static ushort SPLIT_AFTER;
    public static ushort CHILD;
    public static ushort PRESERVE_CHILD;
}
public enum SharpCompress.Common.Rar.Headers.HeaderType : Enum {
    public byte value__;
    public static HeaderType Null;
    public static HeaderType Mark;
    public static HeaderType Archive;
    public static HeaderType File;
    public static HeaderType Service;
    public static HeaderType Comment;
    public static HeaderType Av;
    public static HeaderType Protect;
    public static HeaderType Sign;
    public static HeaderType NewSub;
    public static HeaderType EndArchive;
    public static HeaderType Crypt;
}
internal static class SharpCompress.Common.Rar.Headers.HostOsV4 : object {
    public static byte MS_DOS;
    public static byte OS2;
    public static byte WIN32;
    public static byte UNIX;
    public static byte MAC_OS;
    public static byte BE_OS;
}
internal static class SharpCompress.Common.Rar.Headers.HostOsV5 : object {
    public static byte WINDOWS;
    public static byte UNIX;
}
public interface SharpCompress.Common.Rar.Headers.IRarHeader {
    public HeaderType HeaderType { get; }
    public abstract virtual HeaderType get_HeaderType();
}
internal class SharpCompress.Common.Rar.Headers.MarkHeader : object {
    private static int MAX_SFX_SIZE;
    [CompilerGeneratedAttribute]
private bool <OldNumberingFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRar5>k__BackingField;
    internal bool OldNumberingFormat { get; private set; }
    public bool IsRar5 { get; }
    public HeaderType HeaderType { get; }
    private MarkHeader(bool isRar5);
    [CompilerGeneratedAttribute]
internal bool get_OldNumberingFormat();
    [CompilerGeneratedAttribute]
private void set_OldNumberingFormat(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsRar5();
    public sealed virtual HeaderType get_HeaderType();
    [NullableContextAttribute("1")]
private static byte GetByte(Stream stream);
    [NullableContextAttribute("1")]
public static MarkHeader Read(Stream stream, bool leaveStreamOpen, bool lookForHeader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.Rar.Headers.NewSubHeaderType : object {
    internal static NewSubHeaderType SUBHEAD_TYPE_CMT;
    internal static NewSubHeaderType SUBHEAD_TYPE_RR;
    private Byte[] _bytes;
    private NewSubHeaderType(Char[] chars);
    private static NewSubHeaderType();
    internal bool Equals(Byte[] bytes);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(NewSubHeaderType other);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class SharpCompress.Common.Rar.Headers.ProtectHeader : RarHeader {
    [CompilerGeneratedAttribute]
private byte <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <RecSectors>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <TotalBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Mark>k__BackingField;
    internal UInt32 DataSize { get; }
    internal byte Version { get; private set; }
    internal ushort RecSectors { get; private set; }
    internal UInt32 TotalBlocks { get; private set; }
    internal Byte[] Mark { get; private set; }
    [NullableContextAttribute("1")]
public ProtectHeader(RarHeader header, RarCrcBinaryReader reader);
    [NullableContextAttribute("1")]
protected virtual void ReadFinish(MarkingBinaryReader reader);
    internal UInt32 get_DataSize();
    [CompilerGeneratedAttribute]
internal byte get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(byte value);
    [CompilerGeneratedAttribute]
internal ushort get_RecSectors();
    [CompilerGeneratedAttribute]
private void set_RecSectors(ushort value);
    [CompilerGeneratedAttribute]
internal UInt32 get_TotalBlocks();
    [CompilerGeneratedAttribute]
private void set_TotalBlocks(UInt32 value);
    [CompilerGeneratedAttribute]
internal Byte[] get_Mark();
    [CompilerGeneratedAttribute]
private void set_Mark(Byte[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.Rar.Headers.RarHeader : object {
    private HeaderType _headerType;
    private bool _isRar5;
    [CompilerGeneratedAttribute]
private UInt32 <HeaderCrc>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <HeaderCode>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <HeaderFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HeaderSize>k__BackingField;
    [CompilerGeneratedAttribute]
private ArchiveEncoding <ArchiveEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ExtraSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <AdditionalDataSize>k__BackingField;
    public HeaderType HeaderType { get; }
    protected bool IsRar5 { get; }
    protected UInt32 HeaderCrc { get; }
    internal byte HeaderCode { get; }
    protected ushort HeaderFlags { get; }
    protected int HeaderSize { get; }
    internal ArchiveEncoding ArchiveEncoding { get; }
    protected UInt32 ExtraSize { get; }
    protected long AdditionalDataSize { get; }
    private RarHeader(RarCrcBinaryReader reader, bool isRar5, ArchiveEncoding archiveEncoding);
    protected RarHeader(RarHeader header, RarCrcBinaryReader reader, HeaderType headerType);
    internal static RarHeader TryReadBase(RarCrcBinaryReader reader, bool isRar5, ArchiveEncoding archiveEncoding);
    protected int RemainingHeaderBytes(MarkingBinaryReader reader);
    protected virtual void ReadFinish(MarkingBinaryReader reader);
    private void VerifyHeaderCrc(UInt32 crc32);
    public sealed virtual HeaderType get_HeaderType();
    protected bool get_IsRar5();
    [CompilerGeneratedAttribute]
protected UInt32 get_HeaderCrc();
    [CompilerGeneratedAttribute]
internal byte get_HeaderCode();
    [CompilerGeneratedAttribute]
protected ushort get_HeaderFlags();
    protected bool HasHeaderFlag(ushort flag);
    [CompilerGeneratedAttribute]
protected int get_HeaderSize();
    [CompilerGeneratedAttribute]
internal ArchiveEncoding get_ArchiveEncoding();
    [CompilerGeneratedAttribute]
protected UInt32 get_ExtraSize();
    [CompilerGeneratedAttribute]
protected long get_AdditionalDataSize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Common.Rar.Headers.RarHeaderFactory : object {
    private bool _isRar5;
    [CompilerGeneratedAttribute]
private ReaderOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamingMode <StreamingMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEncrypted>k__BackingField;
    public ReaderOptions Options { get; }
    public StreamingMode StreamingMode { get; }
    public bool IsEncrypted { get; private set; }
    public RarHeaderFactory(StreamingMode mode, ReaderOptions options);
    [CompilerGeneratedAttribute]
public ReaderOptions get_Options();
    [CompilerGeneratedAttribute]
public StreamingMode get_StreamingMode();
    [CompilerGeneratedAttribute]
public bool get_IsEncrypted();
    [CompilerGeneratedAttribute]
private void set_IsEncrypted(bool value);
    [IteratorStateMachineAttribute("SharpCompress.Common.Rar.Headers.RarHeaderFactory/<ReadHeaders>d__12")]
public IEnumerable`1<IRarHeader> ReadHeaders(Stream stream);
    private RarHeader TryReadNextHeader(Stream stream);
    private void SkipData(FileHeader fh, RarCrcBinaryReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.Rar.Headers.SignHeader : RarHeader {
    [CompilerGeneratedAttribute]
private int <CreationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private short <ArcNameSize>k__BackingField;
    [CompilerGeneratedAttribute]
private short <UserNameSize>k__BackingField;
    internal int CreationTime { get; private set; }
    internal short ArcNameSize { get; private set; }
    internal short UserNameSize { get; private set; }
    protected SignHeader(RarHeader header, RarCrcBinaryReader reader);
    protected virtual void ReadFinish(MarkingBinaryReader reader);
    [CompilerGeneratedAttribute]
internal int get_CreationTime();
    [CompilerGeneratedAttribute]
private void set_CreationTime(int value);
    [CompilerGeneratedAttribute]
internal short get_ArcNameSize();
    [CompilerGeneratedAttribute]
private void set_ArcNameSize(short value);
    [CompilerGeneratedAttribute]
internal short get_UserNameSize();
    [CompilerGeneratedAttribute]
private void set_UserNameSize(short value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.Rar.RarCrcBinaryReader : MarkingBinaryReader {
    private UInt32 _currentCrc;
    public RarCrcBinaryReader(Stream stream);
    public UInt32 GetCrc32();
    public void ResetCrc();
    protected void UpdateCrc(byte b);
    protected Byte[] ReadBytesNoCrc(int count);
    public virtual byte ReadByte();
    public virtual Byte[] ReadBytes(int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.Rar.RarCryptoBinaryReader : RarCrcBinaryReader {
    private RarRijndael _rijndael;
    private Byte[] _salt;
    private string _password;
    private Queue`1<byte> _data;
    private long _readCount;
    public long CurrentReadByteCount { get; protected set; }
    private bool UseEncryption { get; }
    public RarCryptoBinaryReader(Stream stream, string password);
    public virtual long get_CurrentReadByteCount();
    protected virtual void set_CurrentReadByteCount(long value);
    public virtual void Mark();
    private bool get_UseEncryption();
    public virtual byte ReadByte();
    public virtual Byte[] ReadBytes(int count);
    private Byte[] ReadAndDecryptBytes(int count);
    public void ClearQueue();
    public void SkipQueue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.Rar.RarCryptoWrapper : Stream {
    private Stream _actualStream;
    private Byte[] _salt;
    private RarRijndael _rijndael;
    private Queue`1<byte> _data;
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public RarCryptoWrapper(Stream actualStream, string password, Byte[] salt);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public int ReadAndDecrypt(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    [CompilerGeneratedAttribute]
public virtual long get_Position();
    [CompilerGeneratedAttribute]
public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class SharpCompress.Common.Rar.RarEntry : Entry {
    internal FileHeader FileHeader { get; }
    internal bool IsRarV3 { get; }
    public long Crc { get; }
    public string Key { get; }
    [NullableAttribute("2")]
public string LinkTarget { get; }
    public Nullable`1<DateTime> LastModifiedTime { get; }
    public Nullable`1<DateTime> CreatedTime { get; }
    public Nullable`1<DateTime> LastAccessedTime { get; }
    public Nullable`1<DateTime> ArchivedTime { get; }
    public bool IsEncrypted { get; }
    public bool IsDirectory { get; }
    public bool IsSplitAfter { get; }
    internal abstract virtual FileHeader get_FileHeader();
    internal bool get_IsRarV3();
    public virtual long get_Crc();
    public virtual string get_Key();
    [NullableContextAttribute("2")]
public virtual string get_LinkTarget();
    public virtual Nullable`1<DateTime> get_LastModifiedTime();
    public virtual Nullable`1<DateTime> get_CreatedTime();
    public virtual Nullable`1<DateTime> get_LastAccessedTime();
    public virtual Nullable`1<DateTime> get_ArchivedTime();
    public virtual bool get_IsEncrypted();
    public virtual bool get_IsDirectory();
    public virtual bool get_IsSplitAfter();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class SharpCompress.Common.Rar.RarFilePart : FilePart {
    [CompilerGeneratedAttribute]
private MarkHeader <MarkHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private FileHeader <FileHeader>k__BackingField;
    internal MarkHeader MarkHeader { get; }
    internal FileHeader FileHeader { get; }
    internal RarFilePart(MarkHeader mh, FileHeader fh, int index);
    [CompilerGeneratedAttribute]
internal MarkHeader get_MarkHeader();
    [CompilerGeneratedAttribute]
internal FileHeader get_FileHeader();
    [NullableContextAttribute("2")]
internal virtual Stream GetRawStream();
}
internal class SharpCompress.Common.Rar.RarRijndael : object {
    internal static int CRYPTO_BLOCK_SIZE;
    private string _password;
    private Byte[] _salt;
    private Byte[] _aesInitializationVector;
    private RijndaelEngine _rijndael;
    private RarRijndael(string password, Byte[] salt);
    private void Initialize();
    public static RarRijndael InitializeFrom(string password, Byte[] salt);
    public Byte[] ProcessBlock(ReadOnlySpan`1<byte> cipherText);
    public sealed virtual void Dispose();
}
public abstract class SharpCompress.Common.Rar.RarVolume : Volume {
    [NullableAttribute("1")]
private RarHeaderFactory _headerFactory;
    internal int _maxCompressionAlgorithm;
    [CompilerGeneratedAttribute]
private ArchiveHeader <ArchiveHeader>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    internal ArchiveHeader ArchiveHeader { get; private set; }
    internal StreamingMode Mode { get; }
    public bool IsFirstVolume { get; }
    public bool IsMultiVolume { get; }
    public bool IsSolidArchive { get; }
    public int MinVersion { get; }
    public int MaxVersion { get; }
    [NullableAttribute("2")]
public string Comment { get; internal set; }
    [NullableContextAttribute("1")]
internal RarVolume(StreamingMode mode, Stream stream, ReaderOptions options, int index);
    [CompilerGeneratedAttribute]
internal ArchiveHeader get_ArchiveHeader();
    [CompilerGeneratedAttribute]
private void set_ArchiveHeader(ArchiveHeader value);
    internal StreamingMode get_Mode();
    [NullableContextAttribute("1")]
internal abstract virtual IEnumerable`1<RarFilePart> ReadFileParts();
    [NullableContextAttribute("1")]
internal abstract virtual RarFilePart CreateFilePart(MarkHeader markHeader, FileHeader fileHeader);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("SharpCompress.Common.Rar.RarVolume/<GetVolumeFileParts>d__11")]
internal IEnumerable`1<RarFilePart> GetVolumeFileParts();
    private void EnsureArchiveHeaderLoaded();
    public virtual bool get_IsFirstVolume();
    public virtual bool get_IsMultiVolume();
    public bool get_IsSolidArchive();
    public int get_MinVersion();
    public int get_MaxVersion();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Comment();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_Comment(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Common.ReaderExtractionEventArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
private T <Item>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ReaderProgress <ReaderProgress>k__BackingField;
    public T Item { get; }
    [NullableAttribute("2")]
public ReaderProgress ReaderProgress { get; }
    internal ReaderExtractionEventArgs`1(T entry, ReaderProgress readerProgress);
    [CompilerGeneratedAttribute]
public T get_Item();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ReaderProgress get_ReaderProgress();
}
internal class SharpCompress.Common.SevenZip.ArchiveDatabase : object {
    internal byte _majorVersion;
    internal byte _minorVersion;
    internal long _startPositionAfterHeader;
    internal long _dataStartPosition;
    internal List`1<long> _packSizes;
    internal List`1<Nullable`1<UInt32>> _packCrCs;
    internal List`1<CFolder> _folders;
    internal List`1<int> _numUnpackStreamsVector;
    internal List`1<CFileItem> _files;
    internal List`1<long> _packStreamStartPositions;
    internal List`1<int> _folderStartFileIndex;
    internal List`1<int> _fileIndexToFolderIndexMap;
    [CompilerGeneratedAttribute]
private IPasswordProvider <PasswordProvider>k__BackingField;
    internal IPasswordProvider PasswordProvider { get; }
    public ArchiveDatabase(IPasswordProvider passwordProvider);
    [CompilerGeneratedAttribute]
internal IPasswordProvider get_PasswordProvider();
    internal void Clear();
    internal bool IsEmpty();
    private void FillStartPos();
    private void FillFolderStartFileIndex();
    public void Fill();
    internal long GetFolderStreamPos(CFolder folder, int indexInFolder);
    internal long GetFolderFullPackSize(int folderIndex);
    internal Stream GetFolderStream(Stream stream, CFolder folder, IPasswordProvider pw);
}
internal class SharpCompress.Common.SevenZip.ArchiveReader : object {
    internal Stream _stream;
    internal Stack`1<DataReader> _readerStack;
    internal DataReader _currentReader;
    internal long _streamOrigin;
    internal long _streamEnding;
    internal Byte[] _header;
    private Dictionary`2<int, Stream> _cachedStreams;
    internal void AddByteStream(Byte[] buffer, int offset, int length);
    internal void DeleteByteStream();
    internal byte ReadByte();
    private void ReadBytes(Byte[] buffer, int offset, int length);
    private ulong ReadNumber();
    internal int ReadNum();
    private UInt32 ReadUInt32();
    private ulong ReadUInt64();
    private Nullable`1<BlockType> ReadId();
    private void SkipData(long size);
    private void SkipData();
    private void WaitAttribute(BlockType attribute);
    private void ReadArchiveProperties();
    private BitVector ReadBitVector(int length);
    private BitVector ReadOptionalBitVector(int length);
    private void ReadNumberVector(List`1<Byte[]> dataVector, int numFiles, Action`2<int, Nullable`1<long>> action);
    private DateTime TranslateTime(long time);
    private Nullable`1<DateTime> TranslateTime(Nullable`1<long> time);
    private void ReadDateTimeVector(List`1<Byte[]> dataVector, int numFiles, Action`2<int, Nullable`1<DateTime>> action);
    private void ReadAttributeVector(List`1<Byte[]> dataVector, int numFiles, Action`2<int, Nullable`1<UInt32>> action);
    private void GetNextFolderItem(CFolder folder);
    private List`1<Nullable`1<UInt32>> ReadHashDigests(int count);
    private void ReadPackInfo(Int64& dataOffset, List`1& packSizes, List`1& packCrCs);
    private void ReadUnpackInfo(List`1<Byte[]> dataVector, List`1& folders);
    private void ReadSubStreamsInfo(List`1<CFolder> folders, List`1& numUnpackStreamsInFolders, List`1& unpackSizes, List`1& digests);
    private void ReadStreamsInfo(List`1<Byte[]> dataVector, Int64& dataOffset, List`1& packSizes, List`1& packCrCs, List`1& folders, List`1& numUnpackStreamsInFolders, List`1& unpackSizes, List`1& digests);
    private List`1<Byte[]> ReadAndDecodePackedStreams(long baseOffset, IPasswordProvider pass);
    private void ReadHeader(ArchiveDatabase db, IPasswordProvider getTextPassword);
    public void Open(Stream stream);
    public void Close();
    public ArchiveDatabase ReadDatabase(IPasswordProvider pass);
    private Stream GetCachedDecoderStream(ArchiveDatabase db, int folderIndex);
    public Stream OpenStream(ArchiveDatabase db, int fileIndex);
    public void Extract(ArchiveDatabase db, Int32[] indices);
    public IEnumerable`1<CFileItem> GetFiles(ArchiveDatabase db);
    public int GetFileIndex(ArchiveDatabase db, CFileItem item);
}
internal class SharpCompress.Common.SevenZip.CBindPair : object {
    internal int _inIndex;
    internal int _outIndex;
}
internal class SharpCompress.Common.SevenZip.CCoderInfo : object {
    internal CMethodId _methodId;
    internal Byte[] _props;
    internal int _numInStreams;
    internal int _numOutStreams;
}
internal class SharpCompress.Common.SevenZip.CFileItem : object {
    [CompilerGeneratedAttribute]
private long <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <Attrib>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <Crc>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasStream>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDir>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <CTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ATime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <MTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <StartPos>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAnti>k__BackingField;
    public long Size { get; internal set; }
    public Nullable`1<UInt32> Attrib { get; internal set; }
    public Nullable`1<UInt32> Crc { get; internal set; }
    public string Name { get; internal set; }
    public bool HasStream { get; internal set; }
    public bool IsDir { get; internal set; }
    public bool CrcDefined { get; }
    public bool AttribDefined { get; }
    public Nullable`1<DateTime> CTime { get; internal set; }
    public Nullable`1<DateTime> ATime { get; internal set; }
    public Nullable`1<DateTime> MTime { get; internal set; }
    public Nullable`1<long> StartPos { get; internal set; }
    public bool IsAnti { get; internal set; }
    [CompilerGeneratedAttribute]
public long get_Size();
    [CompilerGeneratedAttribute]
internal void set_Size(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<UInt32> get_Attrib();
    [CompilerGeneratedAttribute]
internal void set_Attrib(Nullable`1<UInt32> value);
    [CompilerGeneratedAttribute]
public Nullable`1<UInt32> get_Crc();
    [CompilerGeneratedAttribute]
internal void set_Crc(Nullable`1<UInt32> value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_HasStream();
    [CompilerGeneratedAttribute]
internal void set_HasStream(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsDir();
    [CompilerGeneratedAttribute]
internal void set_IsDir(bool value);
    public bool get_CrcDefined();
    public bool get_AttribDefined();
    public void SetAttrib(UInt32 attrib);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_CTime();
    [CompilerGeneratedAttribute]
internal void set_CTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ATime();
    [CompilerGeneratedAttribute]
internal void set_ATime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_MTime();
    [CompilerGeneratedAttribute]
internal void set_MTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_StartPos();
    [CompilerGeneratedAttribute]
internal void set_StartPos(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public bool get_IsAnti();
    [CompilerGeneratedAttribute]
internal void set_IsAnti(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.SevenZip.CFolder : object {
    internal List`1<CCoderInfo> _coders;
    internal List`1<CBindPair> _bindPairs;
    internal List`1<int> _packStreams;
    internal int _firstPackStreamId;
    internal List`1<long> _unpackSizes;
    internal Nullable`1<UInt32> _unpackCrc;
    internal bool UnpackCrcDefined { get; }
    internal bool get_UnpackCrcDefined();
    public long GetUnpackSize();
    public int GetNumOutStreams();
    public int FindBindPairForInStream(int inStreamIndex);
    public int FindBindPairForOutStream(int outStreamIndex);
    public int FindPackStreamArrayIndex(int inStreamIndex);
    public bool IsEncrypted();
    public bool CheckStructure();
}
[IsReadOnlyAttribute]
internal class SharpCompress.Common.SevenZip.CMethodId : ValueType {
    public static ulong K_COPY_ID;
    public static ulong K_LZMA_ID;
    public static ulong K_LZMA2_ID;
    public static ulong K_AES_ID;
    public static CMethodId K_COPY;
    public static CMethodId K_LZMA;
    public static CMethodId K_LZMA2;
    public static CMethodId K_AES;
    public ulong _id;
    public CMethodId(ulong id);
    private static CMethodId();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public bool Equals(CMethodId other);
    public static bool op_Equality(CMethodId left, CMethodId right);
    public static bool op_Inequality(CMethodId left, CMethodId right);
    public int GetLength();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.SevenZip.CStreamSwitch : ValueType {
    private ArchiveReader _archive;
    private bool _needRemove;
    private bool _active;
    public sealed virtual void Dispose();
    public void Set(ArchiveReader archive, Byte[] dataVector);
    public void Set(ArchiveReader archive, List`1<Byte[]> dataVector);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.SevenZip.DataReader : object {
    private Byte[] _buffer;
    private int _ending;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    public int Offset { get; private set; }
    public DataReader(Byte[] buffer, int offset, int length);
    public static UInt32 Get32(Byte[] buffer, int offset);
    public static ulong Get64(Byte[] buffer, int offset);
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
private void set_Offset(int value);
    public byte ReadByte();
    public void ReadBytes(Byte[] buffer, int offset, int length);
    public void SkipData(long size);
    public void SkipData();
    public ulong ReadNumber();
    public int ReadNum();
    public UInt32 ReadUInt32();
    public ulong ReadUInt64();
    public string ReadString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Common.SevenZip.SevenZipEntry : Entry {
    [CompilerGeneratedAttribute]
private SevenZipFilePart <FilePart>k__BackingField;
    internal SevenZipFilePart FilePart { get; }
    public CompressionType CompressionType { get; }
    public long Crc { get; }
    public string Key { get; }
    [NullableAttribute("2")]
public string LinkTarget { get; }
    public long CompressedSize { get; }
    public long Size { get; }
    public Nullable`1<DateTime> LastModifiedTime { get; }
    public Nullable`1<DateTime> CreatedTime { get; }
    public Nullable`1<DateTime> LastAccessedTime { get; }
    public Nullable`1<DateTime> ArchivedTime { get; }
    public bool IsEncrypted { get; }
    public bool IsDirectory { get; }
    public bool IsSplitAfter { get; }
    public Nullable`1<int> Attrib { get; }
    internal IEnumerable`1<FilePart> Parts { get; }
    internal SevenZipEntry(SevenZipFilePart filePart);
    [CompilerGeneratedAttribute]
internal SevenZipFilePart get_FilePart();
    public virtual CompressionType get_CompressionType();
    public virtual long get_Crc();
    public virtual string get_Key();
    [NullableContextAttribute("2")]
public virtual string get_LinkTarget();
    public virtual long get_CompressedSize();
    public virtual long get_Size();
    public virtual Nullable`1<DateTime> get_LastModifiedTime();
    public virtual Nullable`1<DateTime> get_CreatedTime();
    public virtual Nullable`1<DateTime> get_LastAccessedTime();
    public virtual Nullable`1<DateTime> get_ArchivedTime();
    public virtual bool get_IsEncrypted();
    public virtual bool get_IsDirectory();
    public virtual bool get_IsSplitAfter();
    public virtual Nullable`1<int> get_Attrib();
    internal virtual IEnumerable`1<FilePart> get_Parts();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.SevenZip.SevenZipFilePart : FilePart {
    private Nullable`1<CompressionType> _type;
    private Stream _stream;
    private ArchiveDatabase _database;
    [CompilerGeneratedAttribute]
private CFileItem <Header>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private CFolder <Folder>k__BackingField;
    private static UInt32 K_LZMA2;
    private static UInt32 K_LZMA;
    private static UInt32 K_PPMD;
    private static UInt32 K_B_ZIP2;
    internal CFileItem Header { get; }
    [NullableAttribute("2")]
internal CFolder Folder { get; }
    internal string FilePartName { get; }
    public CompressionType CompressionType { get; }
    internal bool IsEncrypted { get; }
    internal SevenZipFilePart(Stream stream, ArchiveDatabase database, int index, CFileItem fileEntry, ArchiveEncoding archiveEncoding);
    [CompilerGeneratedAttribute]
internal CFileItem get_Header();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal CFolder get_Folder();
    internal virtual string get_FilePartName();
    [NullableContextAttribute("2")]
internal virtual Stream GetRawStream();
    internal virtual Stream GetCompressedStream();
    public CompressionType get_CompressionType();
    internal CompressionType GetCompression();
    internal bool get_IsEncrypted();
}
public class SharpCompress.Common.SevenZip.SevenZipVolume : Volume {
    [NullableContextAttribute("1")]
public SevenZipVolume(Stream stream, ReaderOptions readerFactoryOptions, int index);
}
internal enum SharpCompress.Common.Tar.Headers.EntryType : Enum {
    public byte value__;
    public static EntryType File;
    public static EntryType OldFile;
    public static EntryType HardLink;
    public static EntryType SymLink;
    public static EntryType CharDevice;
    public static EntryType BlockDevice;
    public static EntryType Directory;
    public static EntryType Fifo;
    public static EntryType LongLink;
    public static EntryType LongName;
    public static EntryType SparseFile;
    public static EntryType VolumeHeader;
    public static EntryType GlobalExtendedHeader;
}
internal class SharpCompress.Common.Tar.Headers.TarHeader : object {
    internal static DateTime EPOCH;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LinkName>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private long <UserId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <GroupId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastModifiedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private EntryType <EntryType>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <PackedStream>k__BackingField;
    [CompilerGeneratedAttribute]
private ArchiveEncoding <ArchiveEncoding>k__BackingField;
    internal static int BLOCK_SIZE;
    private static Byte[] eightSpaces;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <DataStartPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Magic>k__BackingField;
    internal string Name { get; internal set; }
    internal string LinkName { get; internal set; }
    internal long Mode { get; internal set; }
    internal long UserId { get; internal set; }
    internal long GroupId { get; internal set; }
    internal long Size { get; internal set; }
    internal DateTime LastModifiedTime { get; internal set; }
    internal EntryType EntryType { get; internal set; }
    internal Stream PackedStream { get; internal set; }
    internal ArchiveEncoding ArchiveEncoding { get; }
    public Nullable`1<long> DataStartPosition { get; public set; }
    public string Magic { get; public set; }
    public TarHeader(ArchiveEncoding archiveEncoding);
    private static TarHeader();
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
internal string get_LinkName();
    [CompilerGeneratedAttribute]
internal void set_LinkName(string value);
    [CompilerGeneratedAttribute]
internal long get_Mode();
    [CompilerGeneratedAttribute]
internal void set_Mode(long value);
    [CompilerGeneratedAttribute]
internal long get_UserId();
    [CompilerGeneratedAttribute]
internal void set_UserId(long value);
    [CompilerGeneratedAttribute]
internal long get_GroupId();
    [CompilerGeneratedAttribute]
internal void set_GroupId(long value);
    [CompilerGeneratedAttribute]
internal long get_Size();
    [CompilerGeneratedAttribute]
internal void set_Size(long value);
    [CompilerGeneratedAttribute]
internal DateTime get_LastModifiedTime();
    [CompilerGeneratedAttribute]
internal void set_LastModifiedTime(DateTime value);
    [CompilerGeneratedAttribute]
internal EntryType get_EntryType();
    [CompilerGeneratedAttribute]
internal void set_EntryType(EntryType value);
    [CompilerGeneratedAttribute]
internal Stream get_PackedStream();
    [CompilerGeneratedAttribute]
internal void set_PackedStream(Stream value);
    [CompilerGeneratedAttribute]
internal ArchiveEncoding get_ArchiveEncoding();
    internal void Write(Stream output);
    private void WriteLongFilenameHeader(Stream output);
    internal bool Read(BinaryReader reader);
    private string ReadLongName(BinaryReader reader, Byte[] buffer);
    private static EntryType ReadEntryType(Byte[] buffer);
    private long ReadSize(Byte[] buffer);
    private static Byte[] ReadBlock(BinaryReader reader);
    private static void WriteStringBytes(ReadOnlySpan`1<byte> name, Span`1<byte> buffer, int length);
    private static void WriteStringBytes(string name, Byte[] buffer, int offset, int length);
    private static void WriteOctalBytes(long value, Byte[] buffer, int offset, int length);
    private static int ReadAsciiInt32Base8(Byte[] buffer, int offset, int count);
    private static long ReadAsciiInt64Base8(Byte[] buffer, int offset, int count);
    private static long ReadAsciiInt64(Byte[] buffer, int offset, int count);
    internal static int RecalculateChecksum(Byte[] buf);
    internal static int RecalculateAltChecksum(Byte[] buf);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_DataStartPosition();
    [CompilerGeneratedAttribute]
public void set_DataStartPosition(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public string get_Magic();
    [CompilerGeneratedAttribute]
public void set_Magic(string value);
}
public class SharpCompress.Common.Tar.TarEntry : Entry {
    private TarFilePart _filePart;
    [CompilerGeneratedAttribute]
private CompressionType <CompressionType>k__BackingField;
    public CompressionType CompressionType { get; }
    public long Crc { get; }
    public string Key { get; }
    public string LinkTarget { get; }
    public long CompressedSize { get; }
    public long Size { get; }
    public Nullable`1<DateTime> LastModifiedTime { get; }
    public Nullable`1<DateTime> CreatedTime { get; }
    public Nullable`1<DateTime> LastAccessedTime { get; }
    public Nullable`1<DateTime> ArchivedTime { get; }
    public bool IsEncrypted { get; }
    public bool IsDirectory { get; }
    public bool IsSplitAfter { get; }
    public long Mode { get; }
    public long UserID { get; }
    public long GroupId { get; }
    internal IEnumerable`1<FilePart> Parts { get; }
    internal TarEntry(TarFilePart filePart, CompressionType type);
    [CompilerGeneratedAttribute]
public virtual CompressionType get_CompressionType();
    public virtual long get_Crc();
    public virtual string get_Key();
    public virtual string get_LinkTarget();
    public virtual long get_CompressedSize();
    public virtual long get_Size();
    public virtual Nullable`1<DateTime> get_LastModifiedTime();
    public virtual Nullable`1<DateTime> get_CreatedTime();
    public virtual Nullable`1<DateTime> get_LastAccessedTime();
    public virtual Nullable`1<DateTime> get_ArchivedTime();
    public virtual bool get_IsEncrypted();
    public virtual bool get_IsDirectory();
    public virtual bool get_IsSplitAfter();
    public long get_Mode();
    public long get_UserID();
    public long get_GroupId();
    internal virtual IEnumerable`1<FilePart> get_Parts();
    [IteratorStateMachineAttribute("SharpCompress.Common.Tar.TarEntry/<GetEntries>d__37")]
internal static IEnumerable`1<TarEntry> GetEntries(StreamingMode mode, Stream stream, CompressionType compressionType, ArchiveEncoding archiveEncoding);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.Tar.TarFilePart : FilePart {
    private Stream _seekableStream;
    [CompilerGeneratedAttribute]
private TarHeader <Header>k__BackingField;
    internal TarHeader Header { get; }
    internal string FilePartName { get; }
    internal TarFilePart(TarHeader header, Stream seekableStream);
    [CompilerGeneratedAttribute]
internal TarHeader get_Header();
    internal virtual string get_FilePartName();
    internal virtual Stream GetCompressedStream();
    [NullableContextAttribute("2")]
internal virtual Stream GetRawStream();
}
internal static class SharpCompress.Common.Tar.TarHeaderFactory : object {
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("SharpCompress.Common.Tar.TarHeaderFactory/<ReadHeader>d__0")]
internal static IEnumerable`1<TarHeader> ReadHeader(StreamingMode mode, Stream stream, ArchiveEncoding archiveEncoding);
    private static long PadTo512(long size);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.Tar.TarReadOnlySubStream : NonDisposingStream {
    private bool _isDisposed;
    private long _amountRead;
    [CompilerGeneratedAttribute]
private long <BytesLeftToRead>k__BackingField;
    private long BytesLeftToRead { get; private set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public TarReadOnlySubStream(Stream stream, long bytesToRead);
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private long get_BytesLeftToRead();
    [CompilerGeneratedAttribute]
private void set_BytesLeftToRead(long value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
public class SharpCompress.Common.Tar.TarVolume : Volume {
    [NullableContextAttribute("1")]
public TarVolume(Stream stream, ReaderOptions readerOptions, int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class SharpCompress.Common.Volume : object {
    private Stream _actualStream;
    [CompilerGeneratedAttribute]
private ReaderOptions <ReaderOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    internal Stream Stream { get; }
    protected ReaderOptions ReaderOptions { get; }
    public bool IsFirstVolume { get; }
    public int Index { get; internal set; }
    public string FileName { get; }
    public bool IsMultiVolume { get; }
    internal Volume(Stream stream, ReaderOptions readerOptions, int index);
    internal Stream get_Stream();
    [CompilerGeneratedAttribute]
protected ReaderOptions get_ReaderOptions();
    public virtual bool get_IsFirstVolume();
    [CompilerGeneratedAttribute]
public virtual int get_Index();
    [CompilerGeneratedAttribute]
internal virtual void set_Index(int value);
    public sealed virtual string get_FileName();
    public virtual bool get_IsMultiVolume();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
internal enum SharpCompress.Common.Zip.CryptoMode : Enum {
    public int value__;
    public static CryptoMode Encrypt;
    public static CryptoMode Decrypt;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class SharpCompress.Common.Zip.Headers.DirectoryEndHeader : ZipHeader {
    [CompilerGeneratedAttribute]
private ushort <VolumeNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <FirstVolumeWithDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <TotalNumberOfEntriesInDisk>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <DirectorySize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <DirectoryStartOffsetRelativeToDisk>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <CommentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Comment>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <TotalNumberOfEntries>k__BackingField;
    public ushort VolumeNumber { get; private set; }
    public ushort FirstVolumeWithDirectory { get; private set; }
    public ushort TotalNumberOfEntriesInDisk { get; private set; }
    public UInt32 DirectorySize { get; private set; }
    public UInt32 DirectoryStartOffsetRelativeToDisk { get; private set; }
    public ushort CommentLength { get; private set; }
    public Byte[] Comment { get; private set; }
    public ushort TotalNumberOfEntries { get; private set; }
    public bool IsZip64 { get; }
    [NullableContextAttribute("1")]
internal virtual void Read(BinaryReader reader);
    [CompilerGeneratedAttribute]
public ushort get_VolumeNumber();
    [CompilerGeneratedAttribute]
private void set_VolumeNumber(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_FirstVolumeWithDirectory();
    [CompilerGeneratedAttribute]
private void set_FirstVolumeWithDirectory(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_TotalNumberOfEntriesInDisk();
    [CompilerGeneratedAttribute]
private void set_TotalNumberOfEntriesInDisk(ushort value);
    [CompilerGeneratedAttribute]
public UInt32 get_DirectorySize();
    [CompilerGeneratedAttribute]
private void set_DirectorySize(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_DirectoryStartOffsetRelativeToDisk();
    [CompilerGeneratedAttribute]
private void set_DirectoryStartOffsetRelativeToDisk(UInt32 value);
    [CompilerGeneratedAttribute]
public ushort get_CommentLength();
    [CompilerGeneratedAttribute]
private void set_CommentLength(ushort value);
    [CompilerGeneratedAttribute]
public Byte[] get_Comment();
    [CompilerGeneratedAttribute]
private void set_Comment(Byte[] value);
    [CompilerGeneratedAttribute]
public ushort get_TotalNumberOfEntries();
    [CompilerGeneratedAttribute]
private void set_TotalNumberOfEntries(ushort value);
    public bool get_IsZip64();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class SharpCompress.Common.Zip.Headers.DirectoryEntryHeader : ZipFileEntry {
    [CompilerGeneratedAttribute]
private ushort <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <VersionNeededToExtract>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RelativeOffsetOfEntryHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ExternalFileAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <InternalFileAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <DiskNumberStart>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    internal ushort Version { get; private set; }
    public ushort VersionNeededToExtract { get; public set; }
    public long RelativeOffsetOfEntryHeader { get; public set; }
    public UInt32 ExternalFileAttributes { get; public set; }
    public ushort InternalFileAttributes { get; public set; }
    public ushort DiskNumberStart { get; public set; }
    public string Comment { get; private set; }
    [NullableContextAttribute("1")]
public DirectoryEntryHeader(ArchiveEncoding archiveEncoding);
    [NullableContextAttribute("1")]
internal virtual void Read(BinaryReader reader);
    [CompilerGeneratedAttribute]
internal ushort get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_VersionNeededToExtract();
    [CompilerGeneratedAttribute]
public void set_VersionNeededToExtract(ushort value);
    [CompilerGeneratedAttribute]
public long get_RelativeOffsetOfEntryHeader();
    [CompilerGeneratedAttribute]
public void set_RelativeOffsetOfEntryHeader(long value);
    [CompilerGeneratedAttribute]
public UInt32 get_ExternalFileAttributes();
    [CompilerGeneratedAttribute]
public void set_ExternalFileAttributes(UInt32 value);
    [CompilerGeneratedAttribute]
public ushort get_InternalFileAttributes();
    [CompilerGeneratedAttribute]
public void set_InternalFileAttributes(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_DiskNumberStart();
    [CompilerGeneratedAttribute]
public void set_DiskNumberStart(ushort value);
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
private void set_Comment(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.Zip.Headers.ExtraData : object {
    [CompilerGeneratedAttribute]
private ExtraDataType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <DataBytes>k__BackingField;
    internal ExtraDataType Type { get; }
    internal ushort Length { get; }
    internal Byte[] DataBytes { get; }
    public ExtraData(ExtraDataType type, ushort length, Byte[] dataBytes);
    [CompilerGeneratedAttribute]
internal ExtraDataType get_Type();
    [CompilerGeneratedAttribute]
internal ushort get_Length();
    [CompilerGeneratedAttribute]
internal Byte[] get_DataBytes();
}
internal enum SharpCompress.Common.Zip.Headers.ExtraDataType : Enum {
    public ushort value__;
    public static ExtraDataType WinZipAes;
    public static ExtraDataType NotImplementedExtraData;
    public static ExtraDataType UnicodePathExtraField;
    public static ExtraDataType Zip64ExtendedInformationExtraField;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.Zip.Headers.ExtraUnicodePathExtraField : ExtraData {
    internal byte Version { get; }
    internal Byte[] NameCrc32 { get; }
    internal string UnicodeName { get; }
    public ExtraUnicodePathExtraField(ExtraDataType type, ushort length, Byte[] dataBytes);
    internal byte get_Version();
    internal Byte[] get_NameCrc32();
    internal string get_UnicodeName();
}
[FlagsAttribute]
internal enum SharpCompress.Common.Zip.Headers.HeaderFlags : Enum {
    public ushort value__;
    public static HeaderFlags None;
    public static HeaderFlags Encrypted;
    public static HeaderFlags Bit1;
    public static HeaderFlags Bit2;
    public static HeaderFlags UsePostDataDescriptor;
    public static HeaderFlags EnhancedDeflate;
    public static HeaderFlags Efs;
}
internal class SharpCompress.Common.Zip.Headers.IgnoreHeader : ZipHeader {
    public IgnoreHeader(ZipHeaderType type);
    [NullableContextAttribute("1")]
internal virtual void Read(BinaryReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.Zip.Headers.LocalEntryHeader : ZipFileEntry {
    [CompilerGeneratedAttribute]
private ushort <Version>k__BackingField;
    internal ushort Version { get; private set; }
    public LocalEntryHeader(ArchiveEncoding archiveEncoding);
    internal virtual void Read(BinaryReader reader);
    [CompilerGeneratedAttribute]
internal ushort get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(ushort value);
}
internal static class SharpCompress.Common.Zip.Headers.LocalEntryHeaderExtraFactory : object {
    [NullableContextAttribute("1")]
internal static ExtraData Create(ExtraDataType type, ushort length, Byte[] extraData);
}
internal class SharpCompress.Common.Zip.Headers.SplitHeader : ZipHeader {
    [NullableContextAttribute("1")]
internal virtual void Read(BinaryReader reader);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class SharpCompress.Common.Zip.Headers.Zip64DirectoryEndHeader : ZipHeader {
    private static int SIZE_OF_FIXED_HEADER_DATA_EXCEPT_SIGNATURE_AND_SIZE_FIELDS;
    [CompilerGeneratedAttribute]
private long <SizeOfDirectoryEndRecord>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <VersionMadeBy>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <VersionNeededToExtract>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <VolumeNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <FirstVolumeWithDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalNumberOfEntriesInDisk>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalNumberOfEntries>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DirectorySize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DirectoryStartOffsetRelativeToDisk>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <DataSector>k__BackingField;
    public long SizeOfDirectoryEndRecord { get; private set; }
    public ushort VersionMadeBy { get; private set; }
    public ushort VersionNeededToExtract { get; private set; }
    public UInt32 VolumeNumber { get; private set; }
    public UInt32 FirstVolumeWithDirectory { get; private set; }
    public long TotalNumberOfEntriesInDisk { get; private set; }
    public long TotalNumberOfEntries { get; private set; }
    public long DirectorySize { get; private set; }
    public long DirectoryStartOffsetRelativeToDisk { get; private set; }
    public Byte[] DataSector { get; private set; }
    [NullableContextAttribute("1")]
internal virtual void Read(BinaryReader reader);
    [CompilerGeneratedAttribute]
public long get_SizeOfDirectoryEndRecord();
    [CompilerGeneratedAttribute]
private void set_SizeOfDirectoryEndRecord(long value);
    [CompilerGeneratedAttribute]
public ushort get_VersionMadeBy();
    [CompilerGeneratedAttribute]
private void set_VersionMadeBy(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_VersionNeededToExtract();
    [CompilerGeneratedAttribute]
private void set_VersionNeededToExtract(ushort value);
    [CompilerGeneratedAttribute]
public UInt32 get_VolumeNumber();
    [CompilerGeneratedAttribute]
private void set_VolumeNumber(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_FirstVolumeWithDirectory();
    [CompilerGeneratedAttribute]
private void set_FirstVolumeWithDirectory(UInt32 value);
    [CompilerGeneratedAttribute]
public long get_TotalNumberOfEntriesInDisk();
    [CompilerGeneratedAttribute]
private void set_TotalNumberOfEntriesInDisk(long value);
    [CompilerGeneratedAttribute]
public long get_TotalNumberOfEntries();
    [CompilerGeneratedAttribute]
private void set_TotalNumberOfEntries(long value);
    [CompilerGeneratedAttribute]
public long get_DirectorySize();
    [CompilerGeneratedAttribute]
private void set_DirectorySize(long value);
    [CompilerGeneratedAttribute]
public long get_DirectoryStartOffsetRelativeToDisk();
    [CompilerGeneratedAttribute]
private void set_DirectoryStartOffsetRelativeToDisk(long value);
    [CompilerGeneratedAttribute]
public Byte[] get_DataSector();
    [CompilerGeneratedAttribute]
private void set_DataSector(Byte[] value);
}
internal class SharpCompress.Common.Zip.Headers.Zip64DirectoryEndLocatorHeader : ZipHeader {
    [CompilerGeneratedAttribute]
private UInt32 <FirstVolumeWithDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RelativeOffsetOfTheEndOfDirectoryRecord>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <TotalNumberOfVolumes>k__BackingField;
    public UInt32 FirstVolumeWithDirectory { get; private set; }
    public long RelativeOffsetOfTheEndOfDirectoryRecord { get; private set; }
    public UInt32 TotalNumberOfVolumes { get; private set; }
    [NullableContextAttribute("1")]
internal virtual void Read(BinaryReader reader);
    [CompilerGeneratedAttribute]
public UInt32 get_FirstVolumeWithDirectory();
    [CompilerGeneratedAttribute]
private void set_FirstVolumeWithDirectory(UInt32 value);
    [CompilerGeneratedAttribute]
public long get_RelativeOffsetOfTheEndOfDirectoryRecord();
    [CompilerGeneratedAttribute]
private void set_RelativeOffsetOfTheEndOfDirectoryRecord(long value);
    [CompilerGeneratedAttribute]
public UInt32 get_TotalNumberOfVolumes();
    [CompilerGeneratedAttribute]
private void set_TotalNumberOfVolumes(UInt32 value);
}
internal class SharpCompress.Common.Zip.Headers.Zip64ExtendedInformationExtraField : ExtraData {
    [CompilerGeneratedAttribute]
private long <UncompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RelativeOffsetOfEntryHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <VolumeNumber>k__BackingField;
    public long UncompressedSize { get; private set; }
    public long CompressedSize { get; private set; }
    public long RelativeOffsetOfEntryHeader { get; private set; }
    public UInt32 VolumeNumber { get; private set; }
    [NullableContextAttribute("1")]
public Zip64ExtendedInformationExtraField(ExtraDataType type, ushort length, Byte[] dataBytes);
    public void Process(long uncompressedFileSize, long compressedFileSize, long relativeHeaderOffset, ushort diskNumber);
    [CompilerGeneratedAttribute]
public long get_UncompressedSize();
    [CompilerGeneratedAttribute]
private void set_UncompressedSize(long value);
    [CompilerGeneratedAttribute]
public long get_CompressedSize();
    [CompilerGeneratedAttribute]
private void set_CompressedSize(long value);
    [CompilerGeneratedAttribute]
public long get_RelativeOffsetOfEntryHeader();
    [CompilerGeneratedAttribute]
private void set_RelativeOffsetOfEntryHeader(long value);
    [CompilerGeneratedAttribute]
public UInt32 get_VolumeNumber();
    [CompilerGeneratedAttribute]
private void set_VolumeNumber(UInt32 value);
}
internal abstract class SharpCompress.Common.Zip.Headers.ZipFileEntry : ZipHeader {
    [CompilerGeneratedAttribute]
private Stream <PackedStream>k__BackingField;
    [CompilerGeneratedAttribute]
private ArchiveEncoding <ArchiveEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private HeaderFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private ZipCompressionMethod <CompressionMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <DataStartPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private long <UncompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ExtraData> <Extra>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private WinzipAesEncryptionData <WinzipAesEncryptionData>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <LastModifiedDate>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <LastModifiedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Crc>k__BackingField;
    [CompilerGeneratedAttribute]
private ZipFilePart <Part>k__BackingField;
    internal bool IsDirectory { get; }
    internal Stream PackedStream { get; internal set; }
    internal ArchiveEncoding ArchiveEncoding { get; }
    internal string Name { get; internal set; }
    internal HeaderFlags Flags { get; internal set; }
    internal ZipCompressionMethod CompressionMethod { get; internal set; }
    internal long CompressedSize { get; internal set; }
    internal Nullable`1<long> DataStartPosition { get; internal set; }
    internal long UncompressedSize { get; internal set; }
    internal List`1<ExtraData> Extra { get; internal set; }
    public string Password { get; public set; }
    internal WinzipAesEncryptionData WinzipAesEncryptionData { get; internal set; }
    internal ushort LastModifiedDate { get; internal set; }
    internal ushort LastModifiedTime { get; internal set; }
    internal UInt32 Crc { get; internal set; }
    internal ZipFilePart Part { get; internal set; }
    internal bool IsZip64 { get; }
    protected ZipFileEntry(ZipHeaderType type, ArchiveEncoding archiveEncoding);
    internal bool get_IsDirectory();
    [CompilerGeneratedAttribute]
internal Stream get_PackedStream();
    [CompilerGeneratedAttribute]
internal void set_PackedStream(Stream value);
    [CompilerGeneratedAttribute]
internal ArchiveEncoding get_ArchiveEncoding();
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
internal HeaderFlags get_Flags();
    [CompilerGeneratedAttribute]
internal void set_Flags(HeaderFlags value);
    [CompilerGeneratedAttribute]
internal ZipCompressionMethod get_CompressionMethod();
    [CompilerGeneratedAttribute]
internal void set_CompressionMethod(ZipCompressionMethod value);
    [CompilerGeneratedAttribute]
internal long get_CompressedSize();
    [CompilerGeneratedAttribute]
internal void set_CompressedSize(long value);
    [CompilerGeneratedAttribute]
internal Nullable`1<long> get_DataStartPosition();
    [CompilerGeneratedAttribute]
internal void set_DataStartPosition(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
internal long get_UncompressedSize();
    [CompilerGeneratedAttribute]
internal void set_UncompressedSize(long value);
    [CompilerGeneratedAttribute]
internal List`1<ExtraData> get_Extra();
    [CompilerGeneratedAttribute]
internal void set_Extra(List`1<ExtraData> value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    internal PkwareTraditionalEncryptionData ComposeEncryptionData(Stream archiveStream);
    [CompilerGeneratedAttribute]
internal WinzipAesEncryptionData get_WinzipAesEncryptionData();
    [CompilerGeneratedAttribute]
internal void set_WinzipAesEncryptionData(WinzipAesEncryptionData value);
    [CompilerGeneratedAttribute]
internal ushort get_LastModifiedDate();
    [CompilerGeneratedAttribute]
internal void set_LastModifiedDate(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_LastModifiedTime();
    [CompilerGeneratedAttribute]
internal void set_LastModifiedTime(ushort value);
    [CompilerGeneratedAttribute]
internal UInt32 get_Crc();
    [CompilerGeneratedAttribute]
internal void set_Crc(UInt32 value);
    protected void LoadExtra(Byte[] extra);
    [CompilerGeneratedAttribute]
internal ZipFilePart get_Part();
    [CompilerGeneratedAttribute]
internal void set_Part(ZipFilePart value);
    internal bool get_IsZip64();
}
internal abstract class SharpCompress.Common.Zip.Headers.ZipHeader : object {
    [CompilerGeneratedAttribute]
private ZipHeaderType <ZipHeaderType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasData>k__BackingField;
    internal ZipHeaderType ZipHeaderType { get; }
    internal bool HasData { get; internal set; }
    protected ZipHeader(ZipHeaderType type);
    [CompilerGeneratedAttribute]
internal ZipHeaderType get_ZipHeaderType();
    [NullableContextAttribute("1")]
internal abstract virtual void Read(BinaryReader reader);
    [CompilerGeneratedAttribute]
internal bool get_HasData();
    [CompilerGeneratedAttribute]
internal void set_HasData(bool value);
}
internal enum SharpCompress.Common.Zip.Headers.ZipHeaderType : Enum {
    public int value__;
    public static ZipHeaderType Ignore;
    public static ZipHeaderType LocalEntry;
    public static ZipHeaderType DirectoryEntry;
    public static ZipHeaderType DirectoryEnd;
    public static ZipHeaderType Split;
    public static ZipHeaderType Zip64DirectoryEnd;
    public static ZipHeaderType Zip64DirectoryEndLocator;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.Zip.PkwareTraditionalCryptoStream : Stream {
    private PkwareTraditionalEncryptionData _encryptor;
    private CryptoMode _mode;
    private Stream _stream;
    private bool _isDisposed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public PkwareTraditionalCryptoStream(Stream stream, PkwareTraditionalEncryptionData encryptor, CryptoMode mode);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.Zip.PkwareTraditionalEncryptionData : object {
    private static CRC32 CRC32;
    private UInt32[] _keys;
    private ArchiveEncoding _archiveEncoding;
    private byte MagicByte { get; }
    private PkwareTraditionalEncryptionData(string password, ArchiveEncoding archiveEncoding);
    private static PkwareTraditionalEncryptionData();
    private byte get_MagicByte();
    public static PkwareTraditionalEncryptionData ForRead(string password, ZipFileEntry header, Byte[] encryptionHeader);
    public Byte[] Decrypt(Byte[] cipherText, int length);
    public Byte[] Encrypt(Byte[] plainText, int length);
    private void Initialize(string password);
    internal Byte[] StringToByteArray(string value);
    private void UpdateKeys(byte byteValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.Zip.SeekableZipFilePart : ZipFilePart {
    private bool _isLocalHeaderLoaded;
    private SeekableZipHeaderFactory _headerFactory;
    private DirectoryEntryHeader _directoryEntryHeader;
    [NullableAttribute("2")]
internal string Comment { get; }
    internal SeekableZipFilePart(SeekableZipHeaderFactory headerFactory, DirectoryEntryHeader header, Stream stream);
    internal virtual Stream GetCompressedStream();
    [NullableContextAttribute("2")]
internal string get_Comment();
    private void LoadLocalHeader();
    protected virtual Stream CreateBaseStream();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.Zip.SeekableZipHeaderFactory : ZipHeaderFactory {
    private static int MINIMUM_EOCD_LENGTH;
    private static int ZIP64_EOCD_LENGTH;
    private static int MAX_SEARCH_LENGTH_FOR_EOCD;
    private bool _zip64;
    internal SeekableZipHeaderFactory(string password, ArchiveEncoding archiveEncoding);
    [IteratorStateMachineAttribute("SharpCompress.Common.Zip.SeekableZipHeaderFactory/<ReadSeekableHeader>d__5")]
internal IEnumerable`1<ZipHeader> ReadSeekableHeader(Stream stream);
    private static bool IsMatch(Byte[] haystack, int position, Byte[] needle);
    private static void SeekBackToHeader(Stream stream, BinaryReader reader);
    internal LocalEntryHeader GetLocalHeader(Stream stream, DirectoryEntryHeader directoryEntryHeader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.Zip.StreamingZipFilePart : ZipFilePart {
    [NullableAttribute("2")]
private Stream _decompressionStream;
    internal StreamingZipFilePart(ZipFileEntry header, Stream stream);
    protected virtual Stream CreateBaseStream();
    internal virtual Stream GetCompressedStream();
    internal BinaryReader FixStreamedFileLocation(RewindableStream& rewindableStream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.Zip.StreamingZipHeaderFactory : ZipHeaderFactory {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumerable`1<ZipEntry> _entries;
    internal StreamingZipHeaderFactory(string password, ArchiveEncoding archiveEncoding, IEnumerable`1<ZipEntry> entries);
    [IteratorStateMachineAttribute("SharpCompress.Common.Zip.StreamingZipHeaderFactory/<ReadStreamHeader>d__2")]
internal IEnumerable`1<ZipHeader> ReadStreamHeader(Stream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.Zip.WinzipAesCryptoStream : Stream {
    private static int BLOCK_SIZE_IN_BYTES;
    private SymmetricAlgorithm _cipher;
    private Byte[] _counter;
    private Stream _stream;
    private ICryptoTransform _transform;
    private int _nonce;
    private Byte[] _counterOut;
    private bool _isFinalBlock;
    private long _totalBytesLeftToRead;
    private bool _isDisposed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal WinzipAesCryptoStream(Stream stream, WinzipAesEncryptionData winzipAesEncryptionData, long length);
    private SymmetricAlgorithm CreateCipher(WinzipAesEncryptionData winzipAesEncryptionData);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    private int ReadTransformOneBlock(Byte[] buffer, int offset, int last);
    private void XorInPlace(Byte[] buffer, int offset, int count);
    private void ReadTransformBlocks(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal class SharpCompress.Common.Zip.WinzipAesEncryptionData : object {
    private static int RFC2898_ITERATIONS;
    private Byte[] _salt;
    private WinzipAesKeySize _keySize;
    private Byte[] _passwordVerifyValue;
    private string _password;
    private Byte[] _generatedVerifyValue;
    [CompilerGeneratedAttribute]
private Byte[] <IvBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <KeyBytes>k__BackingField;
    internal Byte[] IvBytes { get; internal set; }
    internal Byte[] KeyBytes { get; internal set; }
    private int KeySizeInBytes { get; }
    internal WinzipAesEncryptionData(WinzipAesKeySize keySize, Byte[] salt, Byte[] passwordVerifyValue, string password);
    [CompilerGeneratedAttribute]
internal Byte[] get_IvBytes();
    [CompilerGeneratedAttribute]
internal void set_IvBytes(Byte[] value);
    [CompilerGeneratedAttribute]
internal Byte[] get_KeyBytes();
    [CompilerGeneratedAttribute]
internal void set_KeyBytes(Byte[] value);
    private int get_KeySizeInBytes();
    internal static int KeyLengthInBytes(WinzipAesKeySize keySize);
    private void Initialize();
}
internal enum SharpCompress.Common.Zip.WinzipAesKeySize : Enum {
    public int value__;
    public static WinzipAesKeySize KeySize128;
    public static WinzipAesKeySize KeySize192;
    public static WinzipAesKeySize KeySize256;
}
internal enum SharpCompress.Common.Zip.ZipCompressionMethod : Enum {
    public int value__;
    public static ZipCompressionMethod None;
    public static ZipCompressionMethod Deflate;
    public static ZipCompressionMethod Deflate64;
    public static ZipCompressionMethod BZip2;
    public static ZipCompressionMethod LZMA;
    public static ZipCompressionMethod ZStd;
    public static ZipCompressionMethod Xz;
    public static ZipCompressionMethod PPMd;
    public static ZipCompressionMethod WinzipAes;
}
public class SharpCompress.Common.Zip.ZipEntry : Entry {
    private ZipFilePart _filePart;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastModifiedTime>k__BackingField;
    public CompressionType CompressionType { get; }
    public long Crc { get; }
    public string Key { get; }
    public string LinkTarget { get; }
    public long CompressedSize { get; }
    public long Size { get; }
    public Nullable`1<DateTime> LastModifiedTime { get; }
    public Nullable`1<DateTime> CreatedTime { get; }
    public Nullable`1<DateTime> LastAccessedTime { get; }
    public Nullable`1<DateTime> ArchivedTime { get; }
    public bool IsEncrypted { get; }
    public bool IsDirectory { get; }
    public bool IsSplitAfter { get; }
    internal IEnumerable`1<FilePart> Parts { get; }
    internal ZipEntry(ZipFilePart filePart);
    public virtual CompressionType get_CompressionType();
    public virtual long get_Crc();
    public virtual string get_Key();
    public virtual string get_LinkTarget();
    public virtual long get_CompressedSize();
    public virtual long get_Size();
    [CompilerGeneratedAttribute]
public virtual Nullable`1<DateTime> get_LastModifiedTime();
    public virtual Nullable`1<DateTime> get_CreatedTime();
    public virtual Nullable`1<DateTime> get_LastAccessedTime();
    public virtual Nullable`1<DateTime> get_ArchivedTime();
    public virtual bool get_IsEncrypted();
    public virtual bool get_IsDirectory();
    public virtual bool get_IsSplitAfter();
    internal virtual IEnumerable`1<FilePart> get_Parts();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class SharpCompress.Common.Zip.ZipFilePart : FilePart {
    [CompilerGeneratedAttribute]
private Stream <BaseStream>k__BackingField;
    [CompilerGeneratedAttribute]
private ZipFileEntry <Header>k__BackingField;
    internal Stream BaseStream { get; }
    internal ZipFileEntry Header { get; internal set; }
    internal string FilePartName { get; }
    protected bool LeaveStreamOpen { get; }
    internal ZipFilePart(ZipFileEntry header, Stream stream);
    [CompilerGeneratedAttribute]
internal Stream get_BaseStream();
    [CompilerGeneratedAttribute]
internal ZipFileEntry get_Header();
    [CompilerGeneratedAttribute]
internal void set_Header(ZipFileEntry value);
    internal virtual string get_FilePartName();
    internal virtual Stream GetCompressedStream();
    internal virtual Stream GetRawStream();
    protected abstract virtual Stream CreateBaseStream();
    protected bool get_LeaveStreamOpen();
    protected Stream CreateDecompressionStream(Stream stream, ZipCompressionMethod method);
    protected Stream GetCryptoStream(Stream plainStream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Common.Zip.ZipHeaderFactory : object {
    internal static UInt32 ENTRY_HEADER_BYTES;
    internal static UInt32 POST_DATA_DESCRIPTOR;
    internal static UInt32 DIRECTORY_START_HEADER_BYTES;
    internal static UInt32 DIRECTORY_END_HEADER_BYTES;
    internal static UInt32 DIGITAL_SIGNATURE;
    internal static UInt32 SPLIT_ARCHIVE_HEADER_BYTES;
    internal static UInt32 ZIP64_END_OF_CENTRAL_DIRECTORY;
    internal static UInt32 ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR;
    [NullableAttribute("2")]
protected LocalEntryHeader _lastEntryHeader;
    [NullableAttribute("2")]
private string _password;
    private StreamingMode _mode;
    private ArchiveEncoding _archiveEncoding;
    protected ZipHeaderFactory(StreamingMode mode, string password, ArchiveEncoding archiveEncoding);
    protected ZipHeader ReadHeader(UInt32 headerBytes, BinaryReader reader, bool zip64);
    internal static bool IsHeader(UInt32 headerBytes);
    private void LoadHeader(ZipFileEntry entryHeader, Stream stream);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class SharpCompress.Common.Zip.ZipVolume : Volume {
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    public string Comment { get; internal set; }
    [NullableContextAttribute("1")]
public ZipVolume(Stream stream, ReaderOptions readerOptions, int index);
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
internal void set_Comment(string value);
}
public static class SharpCompress.Compressors.ADC.ADCBase : object {
    private static int PLAIN;
    private static int TWO_BYTE;
    private static int THREE_BYTE;
    private static int GetChunkType(byte byt);
    private static int GetChunkSize(byte byt);
    private static int GetOffset(ReadOnlySpan`1<byte> chunk);
    [NullableContextAttribute("1")]
public static int Decompress(Byte[] input, Byte[]& output, int bufferSize);
    [NullableContextAttribute("1")]
public static int Decompress(Stream input, Byte[]& output, int bufferSize);
}
public class SharpCompress.Compressors.ADC.ADCStream : Stream {
    private Stream _stream;
    private bool _isDisposed;
    private long _position;
    private Byte[] _outBuffer;
    private int _outPosition;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ADCStream(Stream stream, CompressionMode compressionMode);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal class SharpCompress.Compressors.BZip2.BZip2Constants : object {
    public static int baseBlockSize;
    public static int MAX_ALPHA_SIZE;
    public static int MAX_CODE_LEN;
    public static int RUNA;
    public static int RUNB;
    public static int N_GROUPS;
    public static int G_SIZE;
    public static int N_ITERS;
    public static int MAX_SELECTORS;
    public static int NUM_OVERSHOOT_BYTES;
    [NullableAttribute("1")]
public static Int32[] rNums;
    private static BZip2Constants();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Compressors.BZip2.BZip2Stream : Stream {
    private Stream stream;
    private bool isDisposed;
    [CompilerGeneratedAttribute]
private CompressionMode <Mode>k__BackingField;
    public CompressionMode Mode { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BZip2Stream(Stream stream, CompressionMode compressionMode, bool decompressConcatenated);
    public void Finish();
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
public CompressionMode get_Mode();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public static bool IsBZip2(Stream stream);
}
internal class SharpCompress.Compressors.BZip2.CBZip2InputStream : Stream {
    private int last;
    private int origPtr;
    private int blockSize100k;
    private bool blockRandomised;
    private int bsBuff;
    private int bsLive;
    private CRC mCrc;
    private Boolean[] inUse;
    private int nInUse;
    private Char[] seqToUnseq;
    private Char[] unseqToSeq;
    private Char[] selector;
    private Char[] selectorMtf;
    private Int32[] tt;
    private Char[] ll8;
    private Int32[] unzftab;
    private Int32[][] limit;
    private Int32[][] basev;
    private Int32[][] perm;
    private Int32[] minLens;
    private Stream bsStream;
    private bool streamEnd;
    private int currentChar;
    private static int START_BLOCK_STATE;
    private static int RAND_PART_A_STATE;
    private static int RAND_PART_B_STATE;
    private static int RAND_PART_C_STATE;
    private static int NO_RAND_PART_A_STATE;
    private static int NO_RAND_PART_B_STATE;
    private static int NO_RAND_PART_C_STATE;
    private int currentState;
    private int storedBlockCRC;
    private int storedCombinedCRC;
    private int computedBlockCRC;
    private int computedCombinedCRC;
    private bool decompressConcatenated;
    private int i2;
    private int count;
    private int chPrev;
    private int ch2;
    private int i;
    private int tPos;
    private int rNToGo;
    private int rTPos;
    private int j2;
    private char z;
    private bool isDisposed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CBZip2InputStream(Stream zStream, bool decompressConcatenated);
    private static void Cadvise();
    private static void BadBGLengths();
    private static void BitStreamEOF();
    private static void CompressedStreamEOF();
    private void MakeMaps();
    protected virtual void Dispose(bool disposing);
    internal static Int32[][] InitIntArray(int n1, int n2);
    internal static Char[][] InitCharArray(int n1, int n2);
    public virtual int ReadByte();
    private bool Initialize(bool isFirstStream);
    private void InitBlock();
    private void EndBlock();
    private bool Complete();
    private static void BlockOverrun();
    private static void BadBlockHeader();
    private static void CrcError();
    private void BsFinishedWithStream();
    private void BsSetStream(Stream f);
    private int BsR(int n);
    private char BsGetUChar();
    private int BsGetint();
    private int BsGetIntVS(int numBits);
    private int BsGetInt32();
    private void HbCreateDecodeTables(Int32[] limit, Int32[] basev, Int32[] perm, Char[] length, int minLen, int maxLen, int alphaSize);
    private void RecvDecodingTables();
    private void GetAndMoveToFrontDecode();
    private void SetupBlock();
    private void SetupRandPartA();
    private void SetupNoRandPartA();
    private void SetupRandPartB();
    private void SetupRandPartC();
    private void SetupNoRandPartB();
    private void SetupNoRandPartC();
    private void SetDecompressStructureSizes(int newSize100k);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
internal class SharpCompress.Compressors.BZip2.CBZip2OutputStream : Stream {
    private static int SETMASK;
    private static int CLEARMASK;
    private static int GREATER_ICOST;
    private static int LESSER_ICOST;
    private static int SMALL_THRESH;
    private static int DEPTH_THRESH;
    private static int QSORT_STACK_SIZE;
    private bool finished;
    private int last;
    private int origPtr;
    private int blockSize100k;
    private bool blockRandomised;
    private int bytesOut;
    private int bsBuff;
    private int bsLive;
    private CRC mCrc;
    private Boolean[] inUse;
    private int nInUse;
    private Char[] seqToUnseq;
    private Char[] unseqToSeq;
    private Char[] selector;
    private Char[] selectorMtf;
    private Char[] block;
    private Int32[] quadrant;
    private Int32[] zptr;
    private Int16[] szptr;
    private Int32[] ftab;
    private int nMTF;
    private Int32[] mtfFreq;
    private int workFactor;
    private int workDone;
    private int workLimit;
    private bool firstAttempt;
    private int nBlocksRandomised;
    private int currentChar;
    private int runLength;
    private bool disposed;
    private int blockCRC;
    private int combinedCRC;
    private int allowableBlockSize;
    private Stream bsStream;
    private Int32[] incs;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CBZip2OutputStream(Stream inStream);
    public CBZip2OutputStream(Stream inStream, int inBlockSize);
    private static void Panic();
    private void MakeMaps();
    private static void HbMakeCodeLengths(Char[] len, Int32[] freq, int alphaSize, int maxLen);
    public virtual void WriteByte(byte bv);
    private void WriteRun();
    protected virtual void Dispose(bool disposing);
    public void Finish();
    public virtual void Flush();
    private void Initialize();
    private void InitBlock();
    private void EndBlock();
    private void EndCompression();
    private void HbAssignCodes(Int32[] code, Char[] length, int minLen, int maxLen, int alphaSize);
    private void BsSetStream(Stream f);
    private void BsFinishedWithStream();
    private void BsW(int n, int v);
    private void BsPutUChar(int c);
    private void BsPutint(int u);
    private void BsPutIntVS(int numBits, int c);
    private void SendMTFValues();
    private void MoveToFrontCodeAndSend();
    private void SimpleSort(int lo, int hi, int d);
    private void Vswap(int p1, int p2, int n);
    private char Med3(char a, char b, char c);
    private void QSort3(int loSt, int hiSt, int dSt);
    private void MainSort();
    private void RandomiseBlock();
    private void DoReversibleTransformation();
    private bool FullGtU(int i1, int i2);
    private void AllocateCompressStructures();
    private void GenerateMTFValues();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
internal class SharpCompress.Compressors.BZip2.CRC : object {
    [NullableAttribute("1")]
public static Int32[] crc32Table;
    internal int globalCrc;
    private static CRC();
    internal void InitialiseCRC();
    internal int GetFinalCRC();
    internal int GetGlobalCRC();
    internal void SetGlobalCRC(int newCrc);
    internal void UpdateCRC(int inCh);
}
public enum SharpCompress.Compressors.CompressionMode : Enum {
    public int value__;
    public static CompressionMode Compress;
    public static CompressionMode Decompress;
}
public enum SharpCompress.Compressors.Deflate.CompressionLevel : Enum {
    public int value__;
    public static CompressionLevel None;
    public static CompressionLevel Level0;
    public static CompressionLevel BestSpeed;
    public static CompressionLevel Level1;
    public static CompressionLevel Level2;
    public static CompressionLevel Level3;
    public static CompressionLevel Level4;
    public static CompressionLevel Level5;
    public static CompressionLevel Default;
    public static CompressionLevel Level6;
    public static CompressionLevel Level7;
    public static CompressionLevel Level8;
    public static CompressionLevel BestCompression;
    public static CompressionLevel Level9;
}
public enum SharpCompress.Compressors.Deflate.CompressionStrategy : Enum {
    public int value__;
    public static CompressionStrategy Default;
    public static CompressionStrategy Filtered;
    public static CompressionStrategy HuffmanOnly;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[CLSCompliantAttribute("False")]
public class SharpCompress.Compressors.Deflate.CRC32 : object {
    private static int BUFFER_SIZE;
    private static UInt32[] crc32Table;
    private UInt32 runningCrc32Result;
    [CompilerGeneratedAttribute]
private long <TotalBytesRead>k__BackingField;
    public long TotalBytesRead { get; private set; }
    public int Crc32Result { get; }
    private static CRC32();
    [CompilerGeneratedAttribute]
public long get_TotalBytesRead();
    [CompilerGeneratedAttribute]
private void set_TotalBytesRead(long value);
    public int get_Crc32Result();
    public UInt32 GetCrc32(Stream input);
    public UInt32 GetCrc32AndCopy(Stream input, Stream output);
    public int ComputeCrc32(int W, byte B);
    internal int _InternalComputeCrc32(UInt32 W, byte B);
    public void SlurpBlock(Byte[] block, int offset, int count);
    [NullableContextAttribute("0")]
private UInt32 gf2_matrix_times(ReadOnlySpan`1<UInt32> matrix, UInt32 vec);
    [NullableContextAttribute("0")]
private void gf2_matrix_square(Span`1<UInt32> square, Span`1<UInt32> mat);
    public void Combine(int crc, int length);
}
internal class SharpCompress.Compressors.Deflate.DeflateManager : object {
    internal static Int32[] ExtraLengthBits;
    internal static Int32[] ExtraDistanceBits;
    private static int MEM_LEVEL_MAX;
    private static int MEM_LEVEL_DEFAULT;
    private CompressFunc DeflateFunction;
    private static String[] _ErrorMessage;
    private static int PRESET_DICT;
    private static int INIT_STATE;
    private static int BUSY_STATE;
    private static int FINISH_STATE;
    private static int Z_DEFLATED;
    private static int STORED_BLOCK;
    private static int STATIC_TREES;
    private static int DYN_TREES;
    private static int Z_BINARY;
    private static int Z_ASCII;
    private static int Z_UNKNOWN;
    private static int Buf_size;
    private static int MIN_MATCH;
    private static int MAX_MATCH;
    private static int MIN_LOOKAHEAD;
    private static int HEAP_SIZE;
    private static int END_BLOCK;
    internal ZlibCodec _codec;
    internal int status;
    internal Byte[] pending;
    internal int nextPending;
    internal int pendingCount;
    internal sbyte data_type;
    internal int last_flush;
    internal int w_size;
    internal int w_bits;
    internal int w_mask;
    internal Byte[] window;
    internal int window_size;
    internal Int16[] prev;
    private Int16[] head;
    private int ins_h;
    private int hash_size;
    private int hash_bits;
    private int hash_mask;
    private int hash_shift;
    private int blockStart;
    private Config config;
    private int match_length;
    private int prev_match;
    private int match_available;
    private int strstart;
    private int match_start;
    private int lookahead;
    private int prev_length;
    private CompressionLevel compressionLevel;
    private CompressionStrategy compressionStrategy;
    private Int16[] dyn_ltree;
    private Int16[] dyn_dtree;
    private Int16[] bl_tree;
    private Tree treeLiterals;
    private Tree treeDistances;
    private Tree treeBitLengths;
    private Int16[] bl_count;
    private Int32[] heap;
    private int heap_len;
    private int heap_max;
    private SByte[] depth;
    private int _lengthOffset;
    internal int lit_bufsize;
    internal int last_lit;
    internal int _distanceOffset;
    internal int opt_len;
    internal int static_len;
    internal int matches;
    internal int last_eob_len;
    internal short bi_buf;
    internal int bi_valid;
    private bool Rfc1950BytesEmitted;
    [CompilerGeneratedAttribute]
private bool <WantRfc1950HeaderBytes>k__BackingField;
    internal bool WantRfc1950HeaderBytes { get; internal set; }
    private static DeflateManager();
    private void _InitializeLazyMatch();
    private void _InitializeTreeData();
    internal void _InitializeBlocks();
    internal void pqdownheap(Int16[] tree, int k);
    internal static bool IsSmaller(Int16[] tree, int n, int m, SByte[] depth);
    internal void ScanTree(Int16[] tree, int maxCode);
    internal int BuildBlTree();
    internal void send_all_trees(int lcodes, int dcodes, int blcodes);
    internal void send_tree(Int16[] tree, int max_code);
    private void put_bytes(Byte[] p, int start, int len);
    internal void send_code(int c, Int16[] tree);
    internal void send_bits(int value, int length);
    internal void _tr_align();
    internal bool _tr_tally(int dist, int lc);
    internal void send_compressed_block(Int16[] ltree, Int16[] dtree);
    internal void set_data_type();
    internal void bi_flush();
    internal void bi_windup();
    internal void copy_block(int buf, int len, bool header);
    internal void flush_block_only(bool eof);
    internal BlockState DeflateNone(FlushType flush);
    internal void _tr_stored_block(int buf, int stored_len, bool eof);
    internal void _tr_flush_block(int buf, int stored_len, bool eof);
    private void _fillWindow();
    internal BlockState DeflateFast(FlushType flush);
    internal BlockState DeflateSlow(FlushType flush);
    internal int longest_match(int cur_match);
    [CompilerGeneratedAttribute]
internal bool get_WantRfc1950HeaderBytes();
    [CompilerGeneratedAttribute]
internal void set_WantRfc1950HeaderBytes(bool value);
    internal int Initialize(ZlibCodec codec, CompressionLevel level);
    internal int Initialize(ZlibCodec codec, CompressionLevel level, int bits);
    internal int Initialize(ZlibCodec codec, CompressionLevel level, int bits, CompressionStrategy compressionStrategy);
    internal int Initialize(ZlibCodec codec, CompressionLevel level, int windowBits, int memLevel, CompressionStrategy strategy);
    internal void Reset();
    internal int End();
    private void SetDeflater();
    internal int SetParams(CompressionLevel level, CompressionStrategy strategy);
    internal int SetDictionary(Byte[] dictionary);
    internal int Deflate(FlushType flush);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Compressors.Deflate.DeflateStream : Stream {
    private ZlibBaseStream _baseStream;
    private bool _disposed;
    public FlushType FlushMode { get; public set; }
    public int BufferSize { get; public set; }
    public CompressionStrategy Strategy { get; public set; }
    public long TotalIn { get; }
    public long TotalOut { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public MemoryStream InputBuffer { get; }
    public DeflateStream(Stream stream, CompressionMode mode, CompressionLevel level, Encoding forceEncoding);
    public virtual FlushType get_FlushMode();
    public virtual void set_FlushMode(FlushType value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    public CompressionStrategy get_Strategy();
    public void set_Strategy(CompressionStrategy value);
    public virtual long get_TotalIn();
    public virtual long get_TotalOut();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public MemoryStream get_InputBuffer();
}
public enum SharpCompress.Compressors.Deflate.FlushType : Enum {
    public int value__;
    public static FlushType None;
    public static FlushType Partial;
    public static FlushType Sync;
    public static FlushType Full;
    public static FlushType Finish;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class SharpCompress.Compressors.Deflate.GZipStream : Stream {
    internal static DateTime UNIX_EPOCH;
    private string _comment;
    private string _fileName;
    private Nullable`1<DateTime> _lastModified;
    [NullableAttribute("1")]
internal ZlibBaseStream BaseStream;
    private bool _disposed;
    private bool _firstReadDone;
    private int _headerByteCount;
    [NullableAttribute("1")]
private Encoding _encoding;
    [CompilerGeneratedAttribute]
private int <Crc32>k__BackingField;
    public FlushType FlushMode { get; public set; }
    public int BufferSize { get; public set; }
    internal long TotalIn { get; }
    internal long TotalOut { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public string Comment { get; public set; }
    public Nullable`1<DateTime> LastModified { get; public set; }
    public string FileName { get; public set; }
    public int Crc32 { get; private set; }
    [NullableContextAttribute("1")]
public GZipStream(Stream stream, CompressionMode mode);
    [NullableContextAttribute("1")]
public GZipStream(Stream stream, CompressionMode mode, CompressionLevel level);
    [NullableContextAttribute("1")]
public GZipStream(Stream stream, CompressionMode mode, CompressionLevel level, Encoding encoding);
    private static GZipStream();
    public virtual FlushType get_FlushMode();
    public virtual void set_FlushMode(FlushType value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    internal virtual long get_TotalIn();
    internal virtual long get_TotalOut();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    [NullableContextAttribute("1")]
public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    [NullableContextAttribute("1")]
public virtual void Write(Byte[] buffer, int offset, int count);
    public string get_Comment();
    public void set_Comment(string value);
    public Nullable`1<DateTime> get_LastModified();
    public void set_LastModified(Nullable`1<DateTime> value);
    public string get_FileName();
    public void set_FileName(string value);
    [CompilerGeneratedAttribute]
public int get_Crc32();
    [CompilerGeneratedAttribute]
private void set_Crc32(int value);
    private int EmitHeader();
}
internal class SharpCompress.Compressors.Deflate.InflateBlocks : object {
    private static int MANY;
    internal static Int32[] border;
    internal ZlibCodec _codec;
    internal Int32[] bb;
    internal int bitb;
    internal int bitk;
    internal Int32[] blens;
    internal UInt32 check;
    internal object checkfn;
    internal InflateCodes codes;
    internal int end;
    internal Int32[] hufts;
    internal int index;
    internal InfTree inftree;
    internal int last;
    internal int left;
    private InflateBlockMode mode;
    internal int readAt;
    internal int table;
    internal Int32[] tb;
    internal Byte[] window;
    internal int writeAt;
    internal InflateBlocks(ZlibCodec codec, object checkfn, int w);
    private static InflateBlocks();
    internal UInt32 Reset();
    internal int Process(int r);
    internal void Free();
    internal void SetDictionary(Byte[] d, int start, int n);
    internal int SyncPoint();
    internal int Flush(int r);
}
internal class SharpCompress.Compressors.Deflate.InflateCodes : object {
    private static int START;
    private static int LEN;
    private static int LENEXT;
    private static int DIST;
    private static int DISTEXT;
    private static int COPY;
    private static int LIT;
    private static int WASH;
    private static int END;
    private static int BADCODE;
    internal int bitsToGet;
    internal byte dbits;
    internal int dist;
    internal Int32[] dtree;
    internal int dtree_index;
    internal byte lbits;
    internal int len;
    internal int lit;
    internal Int32[] ltree;
    internal int ltree_index;
    internal int mode;
    internal int need;
    internal Int32[] tree;
    internal int tree_index;
    internal void Init(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index);
    internal int Process(InflateBlocks blocks, int r);
    internal int InflateFast(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, InflateBlocks s, ZlibCodec z);
}
internal class SharpCompress.Compressors.Deflate.InflateManager : object {
    private static int PRESET_DICT;
    private static int Z_DEFLATED;
    private static Byte[] mark;
    internal ZlibCodec _codec;
    internal InflateBlocks blocks;
    internal UInt32 computedCheck;
    internal UInt32 expectedCheck;
    internal int marker;
    internal int method;
    private InflateManagerMode mode;
    internal int wbits;
    [CompilerGeneratedAttribute]
private bool <HandleRfc1950HeaderBytes>k__BackingField;
    internal bool HandleRfc1950HeaderBytes { get; internal set; }
    public InflateManager(bool expectRfc1950HeaderBytes);
    private static InflateManager();
    [CompilerGeneratedAttribute]
internal bool get_HandleRfc1950HeaderBytes();
    [CompilerGeneratedAttribute]
internal void set_HandleRfc1950HeaderBytes(bool value);
    internal int Reset();
    internal int End();
    internal int Initialize(ZlibCodec codec, int w);
    internal int Inflate(FlushType flush);
    internal int SetDictionary(Byte[] dictionary);
    internal int Sync();
    internal int SyncPoint(ZlibCodec z);
}
internal class SharpCompress.Compressors.Deflate.InfTree : object {
    private static int MANY;
    private static int Z_OK;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    internal static int fixed_bl;
    internal static int fixed_bd;
    internal static int BMAX;
    internal static Int32[] fixed_tl;
    internal static Int32[] fixed_td;
    internal static Int32[] cplens;
    internal static Int32[] cplext;
    internal static Int32[] cpdist;
    internal static Int32[] cpdext;
    internal Int32[] c;
    internal Int32[] hn;
    internal Int32[] r;
    internal Int32[] u;
    internal Int32[] v;
    internal Int32[] x;
    private static InfTree();
    private int huft_build(Int32[] b, int bindex, int n, int s, Int32[] d, Int32[] e, Int32[] t, Int32[] m, Int32[] hp, Int32[] hn, Int32[] v);
    internal int inflate_trees_bits(Int32[] c, Int32[] bb, Int32[] tb, Int32[] hp, ZlibCodec z);
    internal int inflate_trees_dynamic(int nl, int nd, Int32[] c, Int32[] bl, Int32[] bd, Int32[] tl, Int32[] td, Int32[] hp, ZlibCodec z);
    internal static int inflate_trees_fixed(Int32[] bl, Int32[] bd, Int32[][] tl, Int32[][] td, ZlibCodec z);
    private void initWorkArea(int vsize);
}
internal static class SharpCompress.Compressors.Deflate.InternalConstants : object {
    internal static int MAX_BITS;
    internal static int BL_CODES;
    internal static int D_CODES;
    internal static int LITERALS;
    internal static int LENGTH_CODES;
    internal static int L_CODES;
    internal static int MAX_BL_BITS;
    internal static int REP_3_6;
    internal static int REPZ_3_10;
    internal static int REPZ_11_138;
    private static InternalConstants();
}
internal static class SharpCompress.Compressors.Deflate.InternalInflateConstants : object {
    internal static Int32[] InflateMask;
    private static InternalInflateConstants();
}
internal class SharpCompress.Compressors.Deflate.SharedUtils : object {
    public static int URShift(int number, int bits);
    [NullableContextAttribute("1")]
public static int ReadInput(TextReader sourceTextReader, Byte[] target, int start, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.Deflate.StaticTree : object {
    internal static Int16[] lengthAndLiteralsTreeCodes;
    internal static Int16[] distTreeCodes;
    internal static Int32[] extra_blbits;
    internal static StaticTree Literals;
    internal static StaticTree Distances;
    internal static StaticTree BitLengths;
    [NullableAttribute("2")]
internal Int16[] treeCodes;
    [NullableAttribute("2")]
internal Int32[] extraBits;
    internal int extraBase;
    internal int elems;
    internal int maxLength;
    [NullableContextAttribute("2")]
private StaticTree(Int16[] treeCodes, Int32[] extraBits, int extraBase, int elems, int maxLength);
    private static StaticTree();
}
internal class SharpCompress.Compressors.Deflate.ZlibBaseStream : Stream {
    protected internal ZlibCodec _z;
    protected internal StreamMode _streamMode;
    protected internal FlushType _flushMode;
    protected internal ZlibStreamFlavor _flavor;
    protected internal CompressionMode _compressionMode;
    protected internal CompressionLevel _level;
    protected internal Byte[] _workingBuffer;
    protected internal int _bufferSize;
    protected internal Byte[] _buf1;
    protected internal Stream _stream;
    protected internal CompressionStrategy Strategy;
    private CRC32 crc;
    protected internal string _GzipFileName;
    protected internal string _GzipComment;
    protected internal DateTime _GzipMtime;
    protected internal int _gzipHeaderByteCount;
    private Encoding _encoding;
    private bool nomoreinput;
    private bool isDisposed;
    internal int Crc32 { get; }
    protected internal bool _wantCompress { get; }
    private ZlibCodec z { get; }
    private Byte[] workingBuffer { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZlibBaseStream(Stream stream, CompressionMode compressionMode, CompressionLevel level, ZlibStreamFlavor flavor, Encoding encoding);
    internal int get_Crc32();
    protected internal bool get__wantCompress();
    private ZlibCodec get_z();
    private Byte[] get_workingBuffer();
    public virtual void Write(Byte[] buffer, int offset, int count);
    private void finish();
    private void end();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    private string ReadZeroTerminatedString();
    private int _ReadAndValidateGzipHeader();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
internal class SharpCompress.Compressors.Deflate.ZlibCodec : object {
    public Byte[] InputBuffer;
    public int NextIn;
    public int AvailableBytesIn;
    public long TotalBytesIn;
    public Byte[] OutputBuffer;
    public int NextOut;
    public int AvailableBytesOut;
    public long TotalBytesOut;
    public string Message;
    internal DeflateManager dstate;
    internal InflateManager istate;
    internal UInt32 _adler32;
    public CompressionLevel CompressLevel;
    public int WindowBits;
    public CompressionStrategy Strategy;
    public int Adler32 { get; }
    public ZlibCodec(CompressionMode mode);
    public int get_Adler32();
    public int InitializeInflate();
    public int InitializeInflate(bool expectRfc1950Header);
    public int InitializeInflate(int windowBits);
    public int InitializeInflate(int windowBits, bool expectRfc1950Header);
    public int Inflate(FlushType flush);
    public int EndInflate();
    public int SyncInflate();
    public int InitializeDeflate();
    public int InitializeDeflate(CompressionLevel level);
    public int InitializeDeflate(CompressionLevel level, bool wantRfc1950Header);
    public int InitializeDeflate(CompressionLevel level, int bits);
    public int InitializeDeflate(CompressionLevel level, int bits, bool wantRfc1950Header);
    private int _InternalInitializeDeflate(bool wantRfc1950Header);
    public int Deflate(FlushType flush);
    public int EndDeflate();
    public void ResetDeflate();
    public int SetDeflateParams(CompressionLevel level, CompressionStrategy strategy);
    public int SetDictionary(Byte[] dictionary);
    internal void flush_pending();
    internal int read_buf(Byte[] buf, int start, int size);
}
internal static class SharpCompress.Compressors.Deflate.ZlibConstants : object {
    public static int WindowBitsMax;
    public static int WindowBitsDefault;
    public static int Z_OK;
    public static int Z_STREAM_END;
    public static int Z_NEED_DICT;
    public static int Z_STREAM_ERROR;
    public static int Z_DATA_ERROR;
    public static int Z_BUF_ERROR;
    public static int WorkingBufferSizeDefault;
    public static int WorkingBufferSizeMin;
}
public class SharpCompress.Compressors.Deflate.ZlibException : Exception {
    [NullableContextAttribute("1")]
public ZlibException(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Compressors.Deflate.ZlibStream : Stream {
    private ZlibBaseStream _baseStream;
    private bool _disposed;
    public FlushType FlushMode { get; public set; }
    public int BufferSize { get; public set; }
    public long TotalIn { get; }
    public long TotalOut { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZlibStream(Stream stream, CompressionMode mode);
    public ZlibStream(Stream stream, CompressionMode mode, CompressionLevel level);
    public ZlibStream(Stream stream, CompressionMode mode, CompressionLevel level, Encoding encoding);
    public virtual FlushType get_FlushMode();
    public virtual void set_FlushMode(FlushType value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    public virtual long get_TotalIn();
    public virtual long get_TotalOut();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
internal enum SharpCompress.Compressors.Deflate.ZlibStreamFlavor : Enum {
    public int value__;
    public static ZlibStreamFlavor ZLIB;
    public static ZlibStreamFlavor DEFLATE;
    public static ZlibStreamFlavor GZIP;
}
internal enum SharpCompress.Compressors.Deflate64.BlockType : Enum {
    public int value__;
    public static BlockType Uncompressed;
    public static BlockType Static;
    public static BlockType Dynamic;
}
public class SharpCompress.Compressors.Deflate64.Deflate64Stream : Stream {
    private static int DEFAULT_BUFFER_SIZE;
    private Stream _stream;
    private CompressionMode _mode;
    private InflaterManaged _inflater;
    private Byte[] _buffer;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public Deflate64Stream(Stream stream, CompressionMode mode);
    private void InitializeInflater(Stream stream, ZipCompressionMethod method);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] array, int offset, int count);
    private void ValidateParameters(Byte[] array, int offset, int count);
    private void EnsureNotDisposed();
    private static void ThrowStreamClosedException();
    private void EnsureDecompressionMode();
    private static void ThrowCannotReadFromDeflateManagedStreamException();
    private void EnsureCompressionMode();
    private static void ThrowCannotWriteToDeflateManagedStreamException();
    public virtual void Write(Byte[] array, int offset, int count);
    private void PurgeBuffers(bool disposing);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.Deflate64.DeflateInput : object {
    [CompilerGeneratedAttribute]
private Byte[] <Buffer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartIndex>k__BackingField;
    public Byte[] Buffer { get; }
    public int Count { get; public set; }
    public int StartIndex { get; public set; }
    public DeflateInput(Byte[] buffer);
    [CompilerGeneratedAttribute]
public Byte[] get_Buffer();
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(int value);
    [CompilerGeneratedAttribute]
public int get_StartIndex();
    [CompilerGeneratedAttribute]
public void set_StartIndex(int value);
    internal void ConsumeBytes(int n);
    internal InputState DumpState();
    internal void RestoreState(InputState state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SharpCompress.Compressors.Deflate64.FastEncoderStatics : object {
    internal static UInt32[] FAST_ENCODER_LITERAL_CODE_INFO;
    internal static UInt32[] FAST_ENCODER_DISTANCE_CODE_INFO;
    internal static UInt32[] BIT_MASK;
    internal static Byte[] EXTRA_LENGTH_BITS;
    internal static Byte[] EXTRA_DISTANCE_BITS;
    internal static int NUM_CHARS;
    internal static int NUM_LENGTH_BASE_CODES;
    internal static int NUM_DIST_BASE_CODES;
    internal static UInt32 FAST_ENCODER_POST_TREE_BIT_BUF;
    internal static int FAST_ENCODER_POST_TREE_BIT_COUNT;
    internal static UInt32 NO_COMPRESSION_HEADER;
    internal static int NO_COMPRESSION_HEADER_BIT_COUNT;
    internal static UInt32 B_FINAL_NO_COMPRESSION_HEADER;
    internal static int B_FINAL_NO_COMPRESSION_HEADER_BIT_COUNT;
    internal static int MAX_CODE_LEN;
    private static Byte[] S_DIST_LOOKUP;
    [NullableAttribute("0")]
internal static ReadOnlySpan`1<byte> FAST_ENCODER_TREE_STRUCTURE_DATA { get; }
    [NullableAttribute("0")]
internal static ReadOnlySpan`1<byte> B_FINAL_FAST_ENCODER_TREE_STRUCTURE_DATA { get; }
    private static FastEncoderStatics();
    [NullableContextAttribute("0")]
internal static ReadOnlySpan`1<byte> get_FAST_ENCODER_TREE_STRUCTURE_DATA();
    [NullableContextAttribute("0")]
internal static ReadOnlySpan`1<byte> get_B_FINAL_FAST_ENCODER_TREE_STRUCTURE_DATA();
    private static Byte[] CreateDistanceLookup();
    internal static int GetSlot(int pos);
    public static UInt32 BitReverse(UInt32 code, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.Deflate64.HuffmanTree : object {
    internal static int MAX_LITERAL_TREE_ELEMENTS;
    internal static int MAX_DIST_TREE_ELEMENTS;
    internal static int END_OF_BLOCK_CODE;
    internal static int NUMBER_OF_CODE_LENGTH_TREE_ELEMENTS;
    private int _tableBits;
    private Int16[] _table;
    private Int16[] _left;
    private Int16[] _right;
    private Byte[] _codeLengthArray;
    private int _tableMask;
    [CompilerGeneratedAttribute]
private static HuffmanTree <StaticLiteralLengthTree>k__BackingField;
    [CompilerGeneratedAttribute]
private static HuffmanTree <StaticDistanceTree>k__BackingField;
    public static HuffmanTree StaticLiteralLengthTree { get; }
    public static HuffmanTree StaticDistanceTree { get; }
    public HuffmanTree(Byte[] codeLengths);
    private static HuffmanTree();
    [CompilerGeneratedAttribute]
public static HuffmanTree get_StaticLiteralLengthTree();
    [CompilerGeneratedAttribute]
public static HuffmanTree get_StaticDistanceTree();
    private static Byte[] GetStaticLiteralTreeLength();
    private static Byte[] GetStaticDistanceTreeLength();
    private UInt32[] CalculateHuffmanCode();
    private void CreateTable();
    public int GetNextSymbol(InputBuffer input);
}
internal class SharpCompress.Compressors.Deflate64.InflaterManaged : object {
    private static Int32[] S_LENGTH_BASE;
    private static Int32[] S_DISTANCE_BASE_POSITION;
    private OutputWindow _output;
    private InputBuffer _input;
    private HuffmanTree _literalLengthTree;
    private HuffmanTree _distanceTree;
    private InflaterState _state;
    private int _bfinal;
    private BlockType _blockType;
    private Byte[] _blockLengthBuffer;
    private int _blockLength;
    private int _length;
    private int _distanceCode;
    private int _extraBits;
    private int _loopCounter;
    private int _literalLengthCodeCount;
    private int _distanceCodeCount;
    private int _codeLengthCodeCount;
    private int _codeArraySize;
    private int _lengthCode;
    private Byte[] _codeList;
    private Byte[] _codeLengthTreeCodeLength;
    private bool _deflate64;
    private HuffmanTree _codeLengthTree;
    private static ReadOnlySpan`1<byte> S_EXTRA_LENGTH_BITS { get; }
    private static ReadOnlySpan`1<byte> S_CODE_ORDER { get; }
    private static ReadOnlySpan`1<byte> S_STATIC_DISTANCE_TREE_TABLE { get; }
    public int AvailableOutput { get; }
    internal InflaterManaged(bool deflate64);
    private static InflaterManaged();
    private static ReadOnlySpan`1<byte> get_S_EXTRA_LENGTH_BITS();
    private static ReadOnlySpan`1<byte> get_S_CODE_ORDER();
    private static ReadOnlySpan`1<byte> get_S_STATIC_DISTANCE_TREE_TABLE();
    private void Reset();
    public void SetInput(Byte[] inputBytes, int offset, int length);
    public bool Finished();
    public int get_AvailableOutput();
    public int Inflate(Byte[] bytes, int offset, int length);
    private bool Decode();
    private bool DecodeUncompressedBlock(Boolean& endOfBlock);
    private bool DecodeBlock(Boolean& endOfBlockCodeSeen);
    private bool DecodeDynamicBlockHeader();
    public void Dispose();
}
internal enum SharpCompress.Compressors.Deflate64.InflaterState : Enum {
    public int value__;
    public static InflaterState ReadingHeader;
    public static InflaterState ReadingBFinal;
    public static InflaterState ReadingBType;
    public static InflaterState ReadingNumLitCodes;
    public static InflaterState ReadingNumDistCodes;
    public static InflaterState ReadingNumCodeLengthCodes;
    public static InflaterState ReadingCodeLengthCodes;
    public static InflaterState ReadingTreeCodesBefore;
    public static InflaterState ReadingTreeCodesAfter;
    public static InflaterState DecodeTop;
    public static InflaterState HaveInitialLength;
    public static InflaterState HaveFullLength;
    public static InflaterState HaveDistCode;
    public static InflaterState UncompressedAligning;
    public static InflaterState UncompressedByte1;
    public static InflaterState UncompressedByte2;
    public static InflaterState UncompressedByte3;
    public static InflaterState UncompressedByte4;
    public static InflaterState DecodingUncompressed;
    public static InflaterState StartReadingFooter;
    public static InflaterState ReadingFooter;
    public static InflaterState VerifyingFooter;
    public static InflaterState Done;
}
internal class SharpCompress.Compressors.Deflate64.InputBuffer : object {
    private Byte[] _buffer;
    private int _start;
    private int _end;
    private UInt32 _bitBuffer;
    private int _bitsInBuffer;
    public int AvailableBits { get; }
    public int AvailableBytes { get; }
    public int get_AvailableBits();
    public int get_AvailableBytes();
    public bool EnsureBitsAvailable(int count);
    public UInt32 TryLoad16Bits();
    private UInt32 GetBitMask(int count);
    public int GetBits(int count);
    public int CopyTo(Byte[] output, int offset, int length);
    public bool NeedsInput();
    public void SetInput(Byte[] buffer, int offset, int length);
    public void SkipBits(int n);
    public void SkipToByteBoundary();
}
internal class SharpCompress.Compressors.Deflate64.Match : object {
    [CompilerGeneratedAttribute]
private MatchState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Symbol>k__BackingField;
    internal MatchState State { get; internal set; }
    internal int Position { get; internal set; }
    internal int Length { get; internal set; }
    internal byte Symbol { get; internal set; }
    [CompilerGeneratedAttribute]
internal MatchState get_State();
    [CompilerGeneratedAttribute]
internal void set_State(MatchState value);
    [CompilerGeneratedAttribute]
internal int get_Position();
    [CompilerGeneratedAttribute]
internal void set_Position(int value);
    [CompilerGeneratedAttribute]
internal int get_Length();
    [CompilerGeneratedAttribute]
internal void set_Length(int value);
    [CompilerGeneratedAttribute]
internal byte get_Symbol();
    [CompilerGeneratedAttribute]
internal void set_Symbol(byte value);
}
internal enum SharpCompress.Compressors.Deflate64.MatchState : Enum {
    public int value__;
    public static MatchState HasSymbol;
    public static MatchState HasMatch;
    public static MatchState HasSymbolAndMatch;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.Deflate64.OutputWindow : object {
    private static int WINDOW_SIZE;
    private static int WINDOW_MASK;
    private Byte[] _window;
    private int _end;
    private int _bytesUsed;
    public int FreeBytes { get; }
    public int AvailableBytes { get; }
    public void Write(byte b);
    public void WriteLengthDistance(int length, int distance);
    public int CopyFrom(InputBuffer input, int length);
    public int get_FreeBytes();
    public int get_AvailableBytes();
    public int CopyTo(Byte[] output, int offset, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.Filters.BCJ2Filter : Stream {
    private Stream _baseStream;
    private Byte[] _input;
    private int _inputOffset;
    private int _inputCount;
    private bool _endReached;
    private long _position;
    private Byte[] _output;
    private int _outputOffset;
    private int _outputCount;
    private Byte[] _control;
    private Byte[] _data1;
    private Byte[] _data2;
    private int _controlPos;
    private int _data1Pos;
    private int _data2Pos;
    private UInt16[] _p;
    private UInt32 _range;
    private UInt32 _code;
    private byte _prevByte;
    private bool _isDisposed;
    private static int K_NUM_TOP_BITS;
    private static int K_TOP_VALUE;
    private static int K_NUM_BIT_MODEL_TOTAL_BITS;
    private static int K_BIT_MODEL_TOTAL;
    private static int K_NUM_MOVE_BITS;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BCJ2Filter(Byte[] control, Byte[] data1, Byte[] data2, Stream baseStream);
    private static bool IsJ(byte b0, byte b1);
    private static bool IsJcc(byte b0, byte b1);
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.Filters.BCJFilter : Filter {
    private static Boolean[] MASK_TO_ALLOWED_STATUS;
    private static Int32[] MASK_TO_BIT_NUMBER;
    private int _pos;
    private int _prevMask;
    public BCJFilter(bool isEncoder, Stream baseStream);
    private static BCJFilter();
    private static bool Test86MsByte(byte b);
    protected virtual int Transform(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.Filters.BCJFilterARM : Filter {
    private int _pos;
    public BCJFilterARM(bool isEncoder, Stream baseStream);
    protected virtual int Transform(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.Filters.BCJFilterARMT : Filter {
    private int _pos;
    public BCJFilterARMT(bool isEncoder, Stream baseStream);
    protected virtual int Transform(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.Filters.BCJFilterIA64 : Filter {
    private int _pos;
    private static Int32[] BRANCH_TABLE;
    public BCJFilterIA64(bool isEncoder, Stream baseStream);
    private static BCJFilterIA64();
    protected virtual int Transform(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.Filters.BCJFilterPPC : Filter {
    private int _pos;
    public BCJFilterPPC(bool isEncoder, Stream baseStream);
    protected virtual int Transform(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.Filters.BCJFilterSPARC : Filter {
    private int _pos;
    public BCJFilterSPARC(bool isEncoder, Stream baseStream);
    protected virtual int Transform(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[CLSCompliantAttribute("False")]
public class SharpCompress.Compressors.Filters.BranchExecFilter : object {
    private static bool X86TestByte(byte b);
    public static void X86Converter(Byte[] buf, UInt32 ip, UInt32& state);
    public static void PowerPCConverter(Byte[] data, UInt32 ip);
    public static void ARMConverter(Byte[] data, UInt32 ip);
    public static void ARMTConverter(Byte[] data, UInt32 ip);
    public static void IA64Converter(Byte[] data, UInt32 ip);
    public static void SPARCConverter(Byte[] data, UInt32 ip);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.Filters.DeltaFilter : Filter {
    private static int DISTANCE_MIN;
    private static int DISTANCE_MAX;
    private static int DISTANCE_MASK;
    private int _distance;
    private Byte[] _history;
    private int _position;
    public DeltaFilter(bool isEncoder, Stream baseStream, Byte[] info);
    protected virtual int Transform(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class SharpCompress.Compressors.Filters.Filter : Stream {
    protected bool _isEncoder;
    protected Stream _baseStream;
    private Byte[] _tail;
    private Byte[] _window;
    private int _transformed;
    private int _read;
    private bool _endReached;
    private bool _isDisposed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    protected Filter(bool isEncoder, Stream baseStream, int lookahead);
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected abstract virtual int Transform(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.LZMA.AesDecoderStream : DecoderStream2 {
    private Stream mStream;
    private ICryptoTransform mDecoder;
    private Byte[] mBuffer;
    private long mWritten;
    private long mLimit;
    private int mOffset;
    private int mEnding;
    private int mUnderflow;
    private bool isDisposed;
    public long Position { get; }
    public long Length { get; }
    public AesDecoderStream(Stream input, Byte[] info, IPasswordProvider pass, long limit);
    protected virtual void Dispose(bool disposing);
    public virtual long get_Position();
    public virtual long get_Length();
    public virtual int Read(Byte[] buffer, int offset, int count);
    private void Init(Byte[] info, Int32& numCyclesPower, Byte[]& salt, Byte[]& iv);
    private Byte[] InitKey(int mNumCyclesPower, Byte[] salt, Byte[] pass);
    private int HandleUnderflow(Byte[] buffer, int offset, int count);
}
internal abstract class SharpCompress.Compressors.LZMA.Base : object {
    public static UInt32 K_NUM_REP_DISTANCES;
    public static UInt32 K_NUM_STATES;
    public static int K_NUM_POS_SLOT_BITS;
    public static int K_DIC_LOG_SIZE_MIN;
    public static int K_NUM_LEN_TO_POS_STATES_BITS;
    public static UInt32 K_NUM_LEN_TO_POS_STATES;
    public static UInt32 K_MATCH_MIN_LEN;
    public static int K_NUM_ALIGN_BITS;
    public static UInt32 K_ALIGN_TABLE_SIZE;
    public static UInt32 K_ALIGN_MASK;
    public static UInt32 K_START_POS_MODEL_INDEX;
    public static UInt32 K_END_POS_MODEL_INDEX;
    public static UInt32 K_NUM_POS_MODELS;
    public static UInt32 K_NUM_FULL_DISTANCES;
    public static UInt32 K_NUM_LIT_POS_STATES_BITS_ENCODING_MAX;
    public static UInt32 K_NUM_LIT_CONTEXT_BITS_MAX;
    public static int K_NUM_POS_STATES_BITS_MAX;
    public static UInt32 K_NUM_POS_STATES_MAX;
    public static int K_NUM_POS_STATES_BITS_ENCODING_MAX;
    public static UInt32 K_NUM_POS_STATES_ENCODING_MAX;
    public static int K_NUM_LOW_LEN_BITS;
    public static int K_NUM_MID_LEN_BITS;
    public static int K_NUM_HIGH_LEN_BITS;
    public static UInt32 K_NUM_LOW_LEN_SYMBOLS;
    public static UInt32 K_NUM_MID_LEN_SYMBOLS;
    public static UInt32 K_NUM_LEN_SYMBOLS;
    public static UInt32 K_MATCH_MAX_LEN;
    public static UInt32 GetLenToPosState(UInt32 len);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.LZMA.Bcj2DecoderStream : DecoderStream2 {
    private static int K_NUM_TOP_BITS;
    private static UInt32 K_TOP_VALUE;
    private Stream _mMainStream;
    private Stream _mCallStream;
    private Stream _mJumpStream;
    private RangeDecoder _mRangeDecoder;
    private StatusDecoder[] _mStatusDecoder;
    private long _mWritten;
    private IEnumerator`1<byte> _mIter;
    private bool _mFinished;
    private bool _isDisposed;
    public Bcj2DecoderStream(Stream[] streams, Byte[] info, long limit);
    protected virtual void Dispose(bool disposing);
    private static bool IsJcc(byte b0, byte b1);
    private static bool IsJ(byte b0, byte b1);
    private static int GetIndex(byte b0, byte b1);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    [IteratorStateMachineAttribute("SharpCompress.Compressors.LZMA.Bcj2DecoderStream/<Run>d__20")]
public IEnumerable`1<byte> Run();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class SharpCompress.Compressors.LZMA.BitVector : object {
    private UInt32[] _mBits;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public int Length { get; }
    public bool Item { get; }
    public BitVector(int length);
    public BitVector(int length, bool initValue);
    public BitVector(List`1<bool> bits);
    public Boolean[] ToArray();
    [CompilerGeneratedAttribute]
public int get_Length();
    public bool get_Item(int index);
    public void SetBit(int index);
    internal bool GetAndSet(int index);
    public virtual string ToString();
}
internal enum SharpCompress.Compressors.LZMA.CoderPropId : Enum {
    public int value__;
    public static CoderPropId DefaultProp;
    public static CoderPropId DictionarySize;
    public static CoderPropId UsedMemorySize;
    public static CoderPropId Order;
    public static CoderPropId BlockSize;
    public static CoderPropId PosStateBits;
    public static CoderPropId LitContextBits;
    public static CoderPropId LitPosBits;
    public static CoderPropId NumFastBytes;
    public static CoderPropId MatchFinder;
    public static CoderPropId MatchFinderCycles;
    public static CoderPropId NumPasses;
    public static CoderPropId Algorithm;
    public static CoderPropId NumThreads;
    public static CoderPropId EndMarker;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SharpCompress.Compressors.LZMA.Crc : object {
    internal static UInt32 INIT_CRC;
    internal static UInt32[] TABLE;
    private static Crc();
    public static UInt32 From(Stream stream, long length);
    public static UInt32 Finish(UInt32 crc);
    public static UInt32 Update(UInt32 crc, byte bt);
    public static UInt32 Update(UInt32 crc, UInt32 value);
    public static UInt32 Update(UInt32 crc, ulong value);
    public static UInt32 Update(UInt32 crc, long value);
    public static UInt32 Update(UInt32 crc, Byte[] buffer, int offset, int length);
}
internal class SharpCompress.Compressors.LZMA.DataErrorException : Exception {
}
public class SharpCompress.Compressors.LZMA.Decoder : object {
    private OutWindow _outWindow;
    private BitDecoder[] _isMatchDecoders;
    private BitDecoder[] _isRepDecoders;
    private BitDecoder[] _isRepG0Decoders;
    private BitDecoder[] _isRepG1Decoders;
    private BitDecoder[] _isRepG2Decoders;
    private BitDecoder[] _isRep0LongDecoders;
    private BitTreeDecoder[] _posSlotDecoder;
    private BitDecoder[] _posDecoders;
    private BitTreeDecoder _posAlignDecoder;
    private LenDecoder _lenDecoder;
    private LenDecoder _repLenDecoder;
    private LiteralDecoder _literalDecoder;
    private int _dictionarySize;
    private UInt32 _posStateMask;
    private State _state;
    private UInt32 _rep0;
    private UInt32 _rep1;
    private UInt32 _rep2;
    private UInt32 _rep3;
    private void CreateDictionary();
    private void SetLiteralProperties(int lp, int lc);
    private void SetPosBitsProperties(int pb);
    private void Init();
    public sealed virtual void Code(Stream inStream, Stream outStream, long inSize, long outSize, ICodeProgress progress);
    internal bool Code(int dictionarySize, OutWindow outWindow, Decoder rangeDecoder);
    public sealed virtual void SetDecoderProperties(Byte[] properties);
    public void Train(Stream stream);
}
internal static class SharpCompress.Compressors.LZMA.DecoderRegistry : object {
    private static UInt32 K_COPY;
    private static UInt32 K_DELTA;
    private static UInt32 K_LZMA2;
    private static UInt32 K_LZMA;
    private static UInt32 K_PPMD;
    private static UInt32 K_BCJ;
    private static UInt32 K_BCJ2;
    private static UInt32 K_PPC;
    private static UInt32 K_IA64;
    private static UInt32 K_ARM;
    private static UInt32 K_ARMT;
    private static UInt32 K_SPARC;
    private static UInt32 K_DEFLATE;
    private static UInt32 K_B_ZIP2;
    private static UInt32 K_ZSTD;
    [NullableContextAttribute("1")]
internal static Stream CreateDecoderStream(CMethodId id, Stream[] inStreams, Byte[] info, IPasswordProvider pass, long limit);
}
internal abstract class SharpCompress.Compressors.LZMA.DecoderStream2 : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    [NullableContextAttribute("1")]
public virtual void Write(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SharpCompress.Compressors.LZMA.DecoderStreamHelper : object {
    private static int FindCoderIndexForOutStreamIndex(CFolder folderInfo, int outStreamIndex);
    private static void FindPrimaryOutStreamIndex(CFolder folderInfo, Int32& primaryCoderIndex, Int32& primaryOutStreamIndex);
    private static Stream CreateDecoderStream(Stream[] packStreams, Int64[] packSizes, Stream[] outStreams, CFolder folderInfo, int coderIndex, IPasswordProvider pass);
    internal static Stream CreateDecoderStream(Stream inStream, long startPos, Int64[] packSizes, CFolder folderInfo, IPasswordProvider pass);
}
internal class SharpCompress.Compressors.LZMA.Encoder : object {
    private static UInt32 K_IFINITY_PRICE;
    private static Byte[] G_FAST_POS;
    private State _state;
    private byte _previousByte;
    private UInt32[] _repDistances;
    private static int K_DEFAULT_DICTIONARY_LOG_SIZE;
    private static UInt32 K_NUM_FAST_BYTES_DEFAULT;
    private static UInt32 K_NUM_LEN_SPEC_SYMBOLS;
    private static UInt32 K_NUM_OPTS;
    private Optimal[] _optimum;
    private BinTree _matchFinder;
    private Encoder _rangeEncoder;
    private BitEncoder[] _isMatch;
    private BitEncoder[] _isRep;
    private BitEncoder[] _isRepG0;
    private BitEncoder[] _isRepG1;
    private BitEncoder[] _isRepG2;
    private BitEncoder[] _isRep0Long;
    private BitTreeEncoder[] _posSlotEncoder;
    private BitEncoder[] _posEncoders;
    private BitTreeEncoder _posAlignEncoder;
    private LenPriceTableEncoder _lenEncoder;
    private LenPriceTableEncoder _repMatchLenEncoder;
    private LiteralEncoder _literalEncoder;
    private UInt32[] _matchDistances;
    private UInt32 _numFastBytes;
    private UInt32 _longestMatchLength;
    private UInt32 _numDistancePairs;
    private UInt32 _additionalOffset;
    private UInt32 _optimumEndIndex;
    private UInt32 _optimumCurrentIndex;
    private bool _longestMatchWasFound;
    private UInt32[] _posSlotPrices;
    private UInt32[] _distancesPrices;
    private UInt32[] _alignPrices;
    private UInt32 _alignPriceCount;
    private UInt32 _distTableSize;
    private int _posStateBits;
    private UInt32 _posStateMask;
    private int _numLiteralPosStateBits;
    private int _numLiteralContextBits;
    private UInt32 _dictionarySize;
    private UInt32 _dictionarySizePrev;
    private UInt32 _numFastBytesPrev;
    private long _nowPos64;
    private bool _finished;
    private Stream _inStream;
    private EMatchFinderType _matchFinderType;
    private bool _writeEndMark;
    private bool _needReleaseMfStream;
    private bool _processingMode;
    private UInt32[] _reps;
    private UInt32[] _repLens;
    private static int K_PROP_SIZE;
    private Byte[] _properties;
    private UInt32[] _tempPrices;
    private UInt32 _matchPriceCount;
    private static String[] K_MATCH_FINDER_I_DS;
    private UInt32 _trainSize;
    private static Encoder();
    private static UInt32 GetPosSlot(UInt32 pos);
    private static UInt32 GetPosSlot2(UInt32 pos);
    private void BaseInit();
    private void Create();
    private void SetWriteEndMarkerMode(bool writeEndMarker);
    private void Init();
    private void ReadMatchDistances(UInt32& lenRes, UInt32& numDistancePairs);
    private void MovePos(UInt32 num);
    private UInt32 GetRepLen1Price(State state, UInt32 posState);
    private UInt32 GetPureRepPrice(UInt32 repIndex, State state, UInt32 posState);
    private UInt32 GetRepPrice(UInt32 repIndex, UInt32 len, State state, UInt32 posState);
    private UInt32 GetPosLenPrice(UInt32 pos, UInt32 len, UInt32 posState);
    private UInt32 Backward(UInt32& backRes, UInt32 cur);
    private UInt32 GetOptimum(UInt32 position, UInt32& backRes);
    private bool ChangePair(UInt32 smallDist, UInt32 bigDist);
    private void WriteEndMarker(UInt32 posState);
    private void Flush(UInt32 nowPos);
    public void CodeOneBlock(Int64& inSize, Int64& outSize, Boolean& finished);
    private void ReleaseMfStream();
    private void SetOutStream(Stream outStream);
    private void ReleaseOutStream();
    private void ReleaseStreams();
    public void SetStreams(Stream inStream, Stream outStream, long inSize, long outSize);
    public sealed virtual void Code(Stream inStream, Stream outStream, long inSize, long outSize, ICodeProgress progress);
    public long Code(Stream inStream, bool final);
    public void Train(Stream trainStream);
    public sealed virtual void WriteCoderProperties(Stream outStream);
    public void WriteCoderProperties(Span`1<byte> span);
    private void FillDistancesPrices();
    private void FillAlignPrices();
    private static int FindMatchFinder(string s);
    public sealed virtual void SetCoderProperties(ReadOnlySpan`1<CoderPropId> propIDs, ReadOnlySpan`1<object> properties);
    public void SetTrainSize(UInt32 trainSize);
}
public interface SharpCompress.Compressors.LZMA.ICodeProgress {
    public abstract virtual void SetProgress(long inSize, long outSize);
}
[NullableContextAttribute("1")]
internal interface SharpCompress.Compressors.LZMA.ICoder {
    public abstract virtual void Code(Stream inStream, Stream outStream, long inSize, long outSize, ICodeProgress progress);
}
internal class SharpCompress.Compressors.LZMA.InvalidParamException : Exception {
}
internal interface SharpCompress.Compressors.LZMA.ISetCoderProperties {
    public abstract virtual void SetCoderProperties(ReadOnlySpan`1<CoderPropId> propIDs, ReadOnlySpan`1<object> properties);
}
[NullableContextAttribute("1")]
internal interface SharpCompress.Compressors.LZMA.ISetDecoderProperties {
    public abstract virtual void SetDecoderProperties(Byte[] properties);
}
[NullableContextAttribute("1")]
internal interface SharpCompress.Compressors.LZMA.IWriteCoderProperties {
    public abstract virtual void WriteCoderProperties(Stream outStream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SharpCompress.Compressors.LZMA.Log : object {
    private static Stack`1<string> INDENT;
    private static bool NEEDS_INDENT;
    private static Log();
    public static void PushIndent(string indent);
    public static void PopIndent();
    private static void EnsureIndent();
    public static void Write(object value);
    public static void Write(string text);
    public static void Write(string format, Object[] args);
    public static void WriteLine();
    public static void WriteLine(object value);
    public static void WriteLine(string text);
    public static void WriteLine(string format, Object[] args);
}
internal class SharpCompress.Compressors.LZMA.LZ.BinTree : InWindow {
    private UInt32 _cyclicBufferPos;
    private UInt32 _cyclicBufferSize;
    private UInt32 _matchMaxLen;
    private UInt32[] _son;
    private UInt32[] _hash;
    private UInt32 _cutValue;
    private UInt32 _hashMask;
    private UInt32 _hashSizeSum;
    private bool _hashArray;
    private static UInt32 K_HASH2_SIZE;
    private static UInt32 K_HASH3_SIZE;
    private static UInt32 K_BT2_HASH_SIZE;
    private static UInt32 K_START_MAX_LEN;
    private static UInt32 K_HASH3_OFFSET;
    private static UInt32 K_EMPTY_HASH_VALUE;
    private static UInt32 K_MAX_VAL_FOR_NORMALIZE;
    private UInt32 _kNumHashDirectBytes;
    private UInt32 _kMinMatchCheck;
    private UInt32 _kFixHashSize;
    public void SetType(int numHashBytes);
    public void SetStream(Stream stream);
    public void ReleaseStream();
    public void Init();
    public void MovePos();
    public byte GetIndexByte(int index);
    public UInt32 GetMatchLen(int index, UInt32 distance, UInt32 limit);
    public UInt32 GetNumAvailableBytes();
    public void Create(UInt32 historySize, UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter);
    public UInt32 GetMatches(UInt32[] distances);
    public void Skip(UInt32 num);
    private void NormalizeLinks(UInt32[] items, UInt32 numItems, UInt32 subValue);
    private void Normalize();
    public void SetCutValue(UInt32 cutValue);
}
internal class SharpCompress.Compressors.LZMA.LZ.InWindow : object {
    public Byte[] _bufferBase;
    private Stream _stream;
    private UInt32 _posLimit;
    private bool _streamEndWasReached;
    private UInt32 _pointerToLastSafePosition;
    public UInt32 _bufferOffset;
    public UInt32 _blockSize;
    public UInt32 _pos;
    private UInt32 _keepSizeBefore;
    private UInt32 _keepSizeAfter;
    public UInt32 _streamPos;
    public bool IsDataStarved { get; }
    public void MoveBlock();
    public virtual void ReadBlock();
    private void Free();
    public void Create(UInt32 keepSizeBefore, UInt32 keepSizeAfter, UInt32 keepSizeReserv);
    public void SetStream(Stream stream);
    public void ReleaseStream();
    public void Init();
    public void MovePos();
    public byte GetIndexByte(int index);
    public UInt32 GetMatchLen(int index, UInt32 distance, UInt32 limit);
    public UInt32 GetNumAvailableBytes();
    public void ReduceOffsets(int subValue);
    public bool get_IsDataStarved();
}
internal class SharpCompress.Compressors.LZMA.LZ.OutWindow : object {
    private Byte[] _buffer;
    private int _windowSize;
    private int _pos;
    private int _streamPos;
    private int _pendingLen;
    private int _pendingDist;
    private Stream _stream;
    public long _total;
    public long _limit;
    public bool HasSpace { get; }
    public bool HasPending { get; }
    public int AvailableBytes { get; }
    public void Create(int windowSize);
    public void Reset();
    public void Init(Stream stream);
    public void Train(Stream stream);
    public void ReleaseStream();
    public void Flush();
    public void CopyBlock(int distance, int len);
    public void PutByte(byte b);
    public byte GetByte(int distance);
    public int CopyStream(Stream stream, int len);
    public void SetLimit(long size);
    public bool get_HasSpace();
    public bool get_HasPending();
    public int Read(Byte[] buffer, int offset, int count);
    public void CopyPending();
    public int get_AvailableBytes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Compressors.LZMA.LZipStream : Stream {
    private Stream _stream;
    [NullableAttribute("2")]
private CountingWritableSubStream _countingWritableSubStream;
    private bool _disposed;
    private bool _finished;
    private long _writeCount;
    [CompilerGeneratedAttribute]
private CompressionMode <Mode>k__BackingField;
    private static Byte[] headerBytes;
    public CompressionMode Mode { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public LZipStream(Stream stream, CompressionMode mode);
    private static LZipStream();
    public void Finish();
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
public CompressionMode get_Mode();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public static bool IsLZipFile(Stream stream);
    public static int ValidateAndReadSize(Stream stream);
    public static void WriteHeaderSize(Stream stream);
    private static Byte[] GetProperties(int dictionarySize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Compressors.LZMA.LzmaEncoderProperties : object {
    [CompilerGeneratedAttribute]
private static LzmaEncoderProperties <Default>k__BackingField;
    private CoderPropId[] _propIDs;
    private Object[] _properties;
    public static LzmaEncoderProperties Default { get; }
    [NullableAttribute("0")]
internal ReadOnlySpan`1<CoderPropId> PropIDs { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ReadOnlySpan`1<object> Properties { get; }
    public LzmaEncoderProperties(bool eos);
    public LzmaEncoderProperties(bool eos, int dictionary);
    public LzmaEncoderProperties(bool eos, int dictionary, int numFastBytes);
    private static LzmaEncoderProperties();
    [CompilerGeneratedAttribute]
public static LzmaEncoderProperties get_Default();
    [NullableContextAttribute("0")]
internal ReadOnlySpan`1<CoderPropId> get_PropIDs();
    internal ReadOnlySpan`1<object> get_Properties();
}
public class SharpCompress.Compressors.LZMA.LzmaStream : Stream {
    private Stream _inputStream;
    private long _inputSize;
    private long _outputSize;
    private int _dictionarySize;
    private OutWindow _outWindow;
    private Decoder _rangeDecoder;
    private Decoder _decoder;
    private long _position;
    private bool _endReached;
    private long _availableBytes;
    private long _rangeDecoderLimit;
    private long _inputPosition;
    private bool _isLzma2;
    private bool _uncompressedChunk;
    private bool _needDictReset;
    private bool _needProps;
    private Encoder _encoder;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private Byte[] <Properties>k__BackingField;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public Byte[] Properties { get; }
    public LzmaStream(Byte[] properties, Stream inputStream);
    public LzmaStream(Byte[] properties, Stream inputStream, long inputSize);
    public LzmaStream(Byte[] properties, Stream inputStream, long inputSize, long outputSize);
    public LzmaStream(Byte[] properties, Stream inputStream, long inputSize, long outputSize, Stream presetDictionary, bool isLzma2);
    public LzmaStream(LzmaEncoderProperties properties, bool isLzma2, Stream outputStream);
    public LzmaStream(LzmaEncoderProperties properties, bool isLzma2, Stream presetDictionary, Stream outputStream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    private void DecodeChunkHeader();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [CompilerGeneratedAttribute]
public Byte[] get_Properties();
}
internal class SharpCompress.Compressors.LZMA.RangeCoder.BitDecoder : ValueType {
    public static int K_NUM_BIT_MODEL_TOTAL_BITS;
    public static UInt32 K_BIT_MODEL_TOTAL;
    private static int K_NUM_MOVE_BITS;
    private UInt32 _prob;
    public void UpdateModel(int numMoveBits, UInt32 symbol);
    public void Init();
    [NullableContextAttribute("1")]
public UInt32 Decode(Decoder rangeDecoder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.LZMA.RangeCoder.BitEncoder : ValueType {
    public static int K_NUM_BIT_MODEL_TOTAL_BITS;
    public static UInt32 K_BIT_MODEL_TOTAL;
    private static int K_NUM_MOVE_BITS;
    private static int K_NUM_MOVE_REDUCING_BITS;
    public static int K_NUM_BIT_PRICE_SHIFT_BITS;
    private UInt32 _prob;
    private static UInt32[] PROB_PRICES;
    private static BitEncoder();
    public void Init();
    public void UpdateModel(UInt32 symbol);
    public void Encode(Encoder encoder, UInt32 symbol);
    public UInt32 GetPrice(UInt32 symbol);
    public UInt32 GetPrice0();
    public UInt32 GetPrice1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class SharpCompress.Compressors.LZMA.RangeCoder.BitTreeDecoder : ValueType {
    private BitDecoder[] _models;
    private int _numBitLevels;
    public BitTreeDecoder(int numBitLevels);
    public void Init();
    public UInt32 Decode(Decoder rangeDecoder);
    public UInt32 ReverseDecode(Decoder rangeDecoder);
    public static UInt32 ReverseDecode(BitDecoder[] models, UInt32 startIndex, Decoder rangeDecoder, int numBitLevels);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class SharpCompress.Compressors.LZMA.RangeCoder.BitTreeEncoder : ValueType {
    private BitEncoder[] _models;
    private int _numBitLevels;
    public BitTreeEncoder(int numBitLevels);
    public void Init();
    public void Encode(Encoder rangeEncoder, UInt32 symbol);
    public void ReverseEncode(Encoder rangeEncoder, UInt32 symbol);
    public UInt32 GetPrice(UInt32 symbol);
    public UInt32 ReverseGetPrice(UInt32 symbol);
    public static UInt32 ReverseGetPrice(BitEncoder[] models, UInt32 startIndex, int numBitLevels, UInt32 symbol);
    public static void ReverseEncode(BitEncoder[] models, UInt32 startIndex, Encoder rangeEncoder, int numBitLevels, UInt32 symbol);
}
internal class SharpCompress.Compressors.LZMA.RangeCoder.Decoder : object {
    public static UInt32 K_TOP_VALUE;
    public UInt32 _range;
    public UInt32 _code;
    public Stream _stream;
    public long _total;
    public bool IsFinished { get; }
    public void Init(Stream stream);
    public void ReleaseStream();
    public void CloseStream();
    public void Normalize();
    public void Normalize2();
    public UInt32 GetThreshold(UInt32 total);
    public void Decode(UInt32 start, UInt32 size);
    public UInt32 DecodeDirectBits(int numTotalBits);
    public UInt32 DecodeBit(UInt32 size0, int numTotalBits);
    public bool get_IsFinished();
}
internal class SharpCompress.Compressors.LZMA.RangeCoder.Encoder : object {
    public static UInt32 K_TOP_VALUE;
    private Stream _stream;
    public ulong _low;
    public UInt32 _range;
    private UInt32 _cacheSize;
    private byte _cache;
    public void SetStream(Stream stream);
    public void ReleaseStream();
    public void Init();
    public void FlushData();
    public void FlushStream();
    public void CloseStream();
    public void Encode(UInt32 start, UInt32 size, UInt32 total);
    public void ShiftLow();
    public void EncodeDirectBits(UInt32 v, int numTotalBits);
    public void EncodeBit(UInt32 size0, int numTotalBits, UInt32 symbol);
    public long GetProcessedSizeAdd();
}
internal enum SharpCompress.Compressors.LZMA.Utilites.BlockType : Enum {
    public byte value__;
    public static BlockType End;
    public static BlockType Header;
    public static BlockType ArchiveProperties;
    public static BlockType AdditionalStreamsInfo;
    public static BlockType MainStreamsInfo;
    public static BlockType FilesInfo;
    public static BlockType PackInfo;
    public static BlockType UnpackInfo;
    public static BlockType SubStreamsInfo;
    public static BlockType Size;
    public static BlockType Crc;
    public static BlockType Folder;
    public static BlockType CodersUnpackSize;
    public static BlockType NumUnpackStream;
    public static BlockType EmptyStream;
    public static BlockType EmptyFile;
    public static BlockType Anti;
    public static BlockType Name;
    public static BlockType CTime;
    public static BlockType ATime;
    public static BlockType MTime;
    public static BlockType WinAttributes;
    public static BlockType Comment;
    public static BlockType EncodedHeader;
    public static BlockType StartPos;
    public static BlockType Dummy;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.LZMA.Utilites.CrcBuilderStream : Stream {
    private Stream _mTarget;
    private UInt32 _mCrc;
    private bool _mFinished;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private long <Processed>k__BackingField;
    public long Processed { get; private set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CrcBuilderStream(Stream target);
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
public long get_Processed();
    [CompilerGeneratedAttribute]
private void set_Processed(long value);
    public UInt32 Finish();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[CLSCompliantAttribute("False")]
public class SharpCompress.Compressors.LZMA.Utilites.CrcCheckStream : Stream {
    private UInt32 _mExpectedCrc;
    private UInt32 _mCurrentCrc;
    private bool _mClosed;
    private Int64[] _mBytes;
    private long _mLength;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CrcCheckStream(UInt32 crc);
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
internal interface SharpCompress.Compressors.LZMA.Utilites.IPasswordProvider {
    public abstract virtual string CryptoGetTextPassword();
}
[ExtensionAttribute]
internal static class SharpCompress.Compressors.LZMA.Utilites.Utils : object {
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool expression);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void ReadExact(Stream stream, Byte[] buffer, int offset, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.PPMd.H.FreqData : Pointer {
    internal static int SIZE;
    internal int SummFreq { get; internal set; }
    internal FreqData(Byte[] memory);
    internal int get_SummFreq();
    internal void set_SummFreq(int value);
    internal FreqData Initialize(Byte[] mem);
    internal void IncrementSummFreq(int dSummFreq);
    internal int GetStats();
    internal virtual void SetStats(State state);
    internal void SetStats(int state);
    public virtual string ToString();
}
internal class SharpCompress.Compressors.PPMd.H.ModelPpm : object {
    [CompilerGeneratedAttribute]
private SubAllocator <SubAlloc>k__BackingField;
    [CompilerGeneratedAttribute]
private RangeCoder <Coder>k__BackingField;
    [CompilerGeneratedAttribute]
private State <FoundState>k__BackingField;
    public static int MAX_O;
    public static int INT_BITS;
    public static int PERIOD_BITS;
    public static int TOT_BITS;
    public static int INTERVAL;
    public static int BIN_SCALE;
    public static int MAX_FREQ;
    private See2Context[][] _see2Cont;
    private See2Context _dummySee2Cont;
    private PpmContext _minContext;
    private PpmContext _maxContext;
    private int _numMasked;
    private int _initEsc;
    private int _orderFall;
    private int _maxOrder;
    private int _runLength;
    private int _initRl;
    private Int32[] _charMask;
    private Int32[] _ns2Indx;
    private Int32[] _ns2BsIndx;
    private Int32[] _hb2Flag;
    private int _escCount;
    private int _prevSuccess;
    private int _hiBitsFlag;
    private Int32[][] _binSumm;
    private static Int32[] INIT_BIN_ESC;
    private State _tempState1;
    private State _tempState2;
    private State _tempState3;
    private State _tempState4;
    private StateRef _tempStateRef1;
    private StateRef _tempStateRef2;
    private PpmContext _tempPpmContext1;
    private PpmContext _tempPpmContext2;
    private PpmContext _tempPpmContext3;
    private PpmContext _tempPpmContext4;
    private Int32[] _ps;
    public SubAllocator SubAlloc { get; }
    public See2Context DummySee2Cont { get; }
    public int InitRl { get; }
    public int EscCount { get; public set; }
    public Int32[] CharMask { get; }
    public int NumMasked { get; public set; }
    public int PrevSuccess { get; public set; }
    public int InitEsc { get; public set; }
    public int RunLength { get; public set; }
    public int HiBitsFlag { get; public set; }
    public Int32[][] BinSumm { get; }
    internal RangeCoder Coder { get; private set; }
    internal State FoundState { get; private set; }
    public Byte[] Heap { get; }
    public int OrderFall { get; }
    private static ModelPpm();
    private void InitBlock();
    [CompilerGeneratedAttribute]
public SubAllocator get_SubAlloc();
    public virtual See2Context get_DummySee2Cont();
    public virtual int get_InitRl();
    public virtual int get_EscCount();
    public virtual void set_EscCount(int value);
    public virtual Int32[] get_CharMask();
    public virtual int get_NumMasked();
    public virtual void set_NumMasked(int value);
    public virtual int get_PrevSuccess();
    public virtual void set_PrevSuccess(int value);
    public virtual int get_InitEsc();
    public virtual void set_InitEsc(int value);
    public virtual int get_RunLength();
    public virtual void set_RunLength(int value);
    public virtual int get_HiBitsFlag();
    public virtual void set_HiBitsFlag(int value);
    public virtual Int32[][] get_BinSumm();
    [CompilerGeneratedAttribute]
internal RangeCoder get_Coder();
    [CompilerGeneratedAttribute]
private void set_Coder(RangeCoder value);
    [CompilerGeneratedAttribute]
internal State get_FoundState();
    [CompilerGeneratedAttribute]
private void set_FoundState(State value);
    public virtual Byte[] get_Heap();
    public virtual int get_OrderFall();
    private void RestartModelRare();
    private void StartModelRare(int maxOrder);
    private void ClearMask();
    internal bool DecodeInit(IRarUnpack unpackRead, int escChar);
    public virtual int DecodeChar();
    public virtual See2Context[][] GetSee2Cont();
    public virtual void IncEscCount(int dEscCount);
    public virtual void IncRunLength(int dRunLength);
    public virtual Int32[] GetHb2Flag();
    public virtual Int32[] GetNs2BsIndx();
    public virtual Int32[] GetNs2Indx();
    private int CreateSuccessors(bool skip, State p1);
    private void UpdateModelRestart();
    private void UpdateModel();
    public virtual string ToString();
    internal bool DecodeInit(Stream stream, int maxOrder, int maxMemory);
    internal void NextContext();
    public int DecodeChar(Decoder decoder);
}
internal abstract class SharpCompress.Compressors.PPMd.H.Pointer : object {
    [CompilerGeneratedAttribute]
private Byte[] <Memory>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Address>k__BackingField;
    internal Byte[] Memory { get; private set; }
    internal int Address { get; internal set; }
    internal Pointer(Byte[] mem);
    [CompilerGeneratedAttribute]
internal Byte[] get_Memory();
    [CompilerGeneratedAttribute]
private void set_Memory(Byte[] value);
    [CompilerGeneratedAttribute]
internal virtual int get_Address();
    [CompilerGeneratedAttribute]
internal virtual void set_Address(int value);
    protected T Initialize(Byte[] mem);
}
internal class SharpCompress.Compressors.PPMd.H.PpmContext : Pointer {
    private static int UNION_SIZE;
    public static int SIZE;
    private int _numStats;
    private FreqData _freqData;
    private State _oneState;
    private int _suffix;
    public static Int32[] EXP_ESCAPE;
    private State _tempState1;
    private State _tempState2;
    private State _tempState3;
    private State _tempState4;
    private State _tempState5;
    private PpmContext _tempPpmContext;
    internal Int32[] _ps;
    internal FreqData FreqData { get; internal set; }
    public int NumStats { get; public set; }
    internal int Address { get; internal set; }
    public PpmContext(Byte[] memory);
    private static PpmContext();
    internal FreqData get_FreqData();
    internal void set_FreqData(FreqData value);
    public virtual int get_NumStats();
    public virtual void set_NumStats(int value);
    internal PpmContext Initialize(Byte[] mem);
    internal State GetOneState();
    internal void SetOneState(StateRef oneState);
    internal int GetSuffix();
    internal void SetSuffix(PpmContext suffix);
    internal void SetSuffix(int suffix);
    internal virtual int get_Address();
    internal virtual void set_Address(int value);
    private PpmContext GetTempPpmContext(Byte[] memory);
    internal int CreateChild(ModelPpm model, State pStats, StateRef firstState);
    internal void Rescale(ModelPpm model);
    internal int GetArrayIndex(ModelPpm model, State rs);
    internal int GetMean(int summ, int shift, int round);
    internal void DecodeBinSymbol(ModelPpm model);
    internal void Update1(ModelPpm model, int p);
    internal void update1_0(ModelPpm model, int p);
    internal bool DecodeSymbol2(ModelPpm model);
    internal void Update2(ModelPpm model, int p);
    private See2Context MakeEscFreq2(ModelPpm model, int diff);
    internal See2Context MakeEscFreq(ModelPpm model, int numMasked, Int32& escFreq);
    internal bool DecodeSymbol1(ModelPpm model);
    public virtual string ToString();
}
internal class SharpCompress.Compressors.PPMd.H.RangeCoder : object {
    internal static int TOP;
    internal static int BOT;
    internal static long UINT_MASK;
    private long _low;
    private long _code;
    private long _range;
    private IRarUnpack _unpackRead;
    private Stream _stream;
    [CompilerGeneratedAttribute]
private SubRange <SubRange>k__BackingField;
    internal int CurrentCount { get; }
    private long Char { get; }
    internal SubRange SubRange { get; private set; }
    internal RangeCoder(IRarUnpack unpackRead);
    internal RangeCoder(Stream stream);
    private void Init();
    internal int get_CurrentCount();
    private long get_Char();
    [CompilerGeneratedAttribute]
internal SubRange get_SubRange();
    [CompilerGeneratedAttribute]
private void set_SubRange(SubRange value);
    internal long GetCurrentShiftCount(int shift);
    internal void Decode();
    internal void AriDecNormalize();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.PPMd.H.RarMemBlock : Pointer {
    public static int SIZE;
    private int _stamp;
    private int _nu;
    private int _next;
    private int _prev;
    internal int Stamp { get; internal set; }
    public RarMemBlock(Byte[] memory);
    internal int get_Stamp();
    internal void set_Stamp(int value);
    internal void InsertAt(RarMemBlock p);
    internal void Remove();
    internal int GetNext();
    internal void SetNext(RarMemBlock next);
    internal void SetNext(int next);
    internal int GetNu();
    internal void SetNu(int nu);
    internal int GetPrev();
    internal void SetPrev(RarMemBlock prev);
    internal void SetPrev(int prev);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.PPMd.H.RarNode : Pointer {
    private int _next;
    public static int SIZE;
    public RarNode(Byte[] memory);
    internal int GetNext();
    internal void SetNext(RarNode next);
    internal void SetNext(int next);
    public virtual string ToString();
}
internal class SharpCompress.Compressors.PPMd.H.See2Context : object {
    public static int SIZE;
    private int _summ;
    private int _shift;
    private int _count;
    public int Mean { get; }
    public int Count { get; public set; }
    public int Shift { get; public set; }
    public int Summ { get; public set; }
    public virtual int get_Mean();
    public virtual int get_Count();
    public virtual void set_Count(int value);
    public virtual int get_Shift();
    public virtual void set_Shift(int value);
    public virtual int get_Summ();
    public virtual void set_Summ(int value);
    public void Initialize(int initVal);
    public virtual void Update();
    public virtual void IncSumm(int dSumm);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.PPMd.H.State : Pointer {
    internal static int SIZE;
    internal int Symbol { get; internal set; }
    internal int Freq { get; internal set; }
    [NullableContextAttribute("2")]
internal State(Byte[] memory);
    internal int get_Symbol();
    internal void set_Symbol(int value);
    internal int get_Freq();
    internal void set_Freq(int value);
    internal State Initialize(Byte[] mem);
    internal void IncrementFreq(int dFreq);
    internal int GetSuccessor();
    internal void SetSuccessor(PpmContext successor);
    internal void SetSuccessor(int successor);
    internal void SetValues(StateRef state);
    internal void SetValues(State ptr);
    internal State DecrementAddress();
    internal State IncrementAddress();
    internal static void PpmdSwap(State ptr1, State ptr2);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.PPMd.H.StateRef : object {
    private int _symbol;
    private int _freq;
    private int _successor;
    internal int Symbol { get; internal set; }
    internal int Freq { get; internal set; }
    unknown State Values {internal set; }
    internal int get_Symbol();
    internal void set_Symbol(int value);
    internal int get_Freq();
    internal void set_Freq(int value);
    internal void set_Values(State value);
    public virtual void IncrementFreq(int dFreq);
    public virtual void DecrementFreq(int dFreq);
    public virtual int GetSuccessor();
    public virtual void SetSuccessor(PpmContext successor);
    public virtual void SetSuccessor(int successor);
    public virtual string ToString();
}
internal class SharpCompress.Compressors.PPMd.H.SubAllocator : object {
    public static int N1;
    public static int N2;
    public static int N3;
    public static int N4;
    public static int N_INDEXES;
    public static int UNIT_SIZE;
    public static int FIXED_UNIT_SIZE;
    private int _subAllocatorSize;
    private Int32[] _indx2Units;
    private Int32[] _units2Indx;
    private int _glueCount;
    private int _heapStart;
    private int _loUnit;
    private int _hiUnit;
    private RarNode[] _freeList;
    private int _pText;
    private int _unitsStart;
    private int _heapEnd;
    private int _fakeUnitsStart;
    private Byte[] _heap;
    private int _freeListPos;
    private int _tempMemBlockPos;
    private RarNode _tempRarNode;
    private RarMemBlock _tempRarMemBlock1;
    private RarMemBlock _tempRarMemBlock2;
    private RarMemBlock _tempRarMemBlock3;
    public int FakeUnitsStart { get; public set; }
    public int HeapEnd { get; }
    public int PText { get; public set; }
    public int UnitsStart { get; public set; }
    public Byte[] Heap { get; }
    private static SubAllocator();
    public virtual int get_FakeUnitsStart();
    public virtual void set_FakeUnitsStart(int value);
    public virtual int get_HeapEnd();
    public virtual int get_PText();
    public virtual void set_PText(int value);
    public virtual int get_UnitsStart();
    public virtual void set_UnitsStart(int value);
    public virtual Byte[] get_Heap();
    public virtual void Clean();
    private void InsertNode(int p, int indx);
    public virtual void IncPText();
    private int RemoveNode(int indx);
    private int U2B(int nu);
    private int MbPtr(int basePtr, int items);
    private void SplitBlock(int pv, int oldIndx, int newIndx);
    public virtual void StopSubAllocator();
    public virtual int GetAllocatedMemory();
    public virtual bool StartSubAllocator(int saSize);
    private void GlueFreeBlocks();
    private int AllocUnitsRare(int indx);
    public virtual int AllocUnits(int nu);
    public virtual int AllocContext();
    public virtual int ExpandUnits(int oldPtr, int oldNu);
    public virtual int ShrinkUnits(int oldPtr, int oldNu, int newNu);
    public virtual void FreeUnits(int ptr, int oldNu);
    public virtual void DecPText(int dPText);
    public virtual void InitSubAllocator();
    private int SizeOfFreeList();
    public virtual string ToString();
}
internal class SharpCompress.Compressors.PPMd.H.SubRange : object {
    private long _lowCount;
    private long _highCount;
    private long _scale;
    internal long HighCount { get; internal set; }
    internal long LowCount { get; internal set; }
    internal long Scale { get; internal set; }
    internal void IncScale(int dScale);
    internal long get_HighCount();
    internal void set_HighCount(long value);
    internal long get_LowCount();
    internal void set_LowCount(long value);
    internal long get_Scale();
    internal void set_Scale(long value);
    public virtual string ToString();
}
internal class SharpCompress.Compressors.PPMd.I1.Allocator : object {
    private static UInt32 UNIT_SIZE;
    private static UInt32 LOCAL_OFFSET;
    private static UInt32 NODE_OFFSET;
    private static UInt32 HEAP_OFFSET;
    private static UInt32 N1;
    private static UInt32 N2;
    private static UInt32 N3;
    private static UInt32 N4;
    private static UInt32 INDEX_COUNT;
    private static Byte[] INDEX_TO_UNITS;
    private static Byte[] UNITS_TO_INDEX;
    public UInt32 _allocatorSize;
    public UInt32 _glueCount;
    public Pointer _baseUnit;
    public Pointer _lowUnit;
    public Pointer _highUnit;
    public Pointer _text;
    public Pointer _heap;
    public MemoryNode[] _memoryNodes;
    public Byte[] _memory;
    private static Allocator();
    public void Initialize();
    public void Start(int allocatorSize);
    public void Stop();
    public UInt32 GetMemoryUsed();
    public Pointer AllocateUnits(UInt32 unitCount);
    public Pointer AllocateContext();
    public Pointer ExpandUnits(Pointer oldPointer, UInt32 oldUnitCount);
    public Pointer ShrinkUnits(Pointer oldPointer, UInt32 oldUnitCount, UInt32 newUnitCount);
    public void FreeUnits(Pointer pointer, UInt32 unitCount);
    public void SpecialFreeUnits(Pointer pointer);
    public Pointer MoveUnitsUp(Pointer oldPointer, UInt32 unitCount);
    public void ExpandText();
    private Pointer AllocateUnitsRare(UInt32 index);
    private void SplitBlock(Pointer pointer, UInt32 oldIndex, UInt32 newIndex);
    private void GlueFreeBlocks();
    private void CopyUnits(Pointer target, Pointer source, UInt32 unitCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.PPMd.I1.Coder : object {
    private static UInt32 RANGE_TOP;
    private static UInt32 RANGE_BOTTOM;
    private UInt32 _low;
    private UInt32 _code;
    private UInt32 _range;
    public UInt32 _lowCount;
    public UInt32 _highCount;
    public UInt32 _scale;
    public void RangeEncoderInitialize();
    public void RangeEncoderNormalize(Stream stream);
    public void RangeEncodeSymbol();
    public void RangeShiftEncodeSymbol(int rangeShift);
    public void RangeEncoderFlush(Stream stream);
    public void RangeDecoderInitialize(Stream stream);
    public void RangeDecoderNormalize(Stream stream);
    public UInt32 RangeGetCurrentCount();
    public UInt32 RangeGetCurrentShiftCount(int rangeShift);
    public void RangeRemoveSubrange();
}
internal class SharpCompress.Compressors.PPMd.I1.MemoryNode : ValueType {
    public UInt32 _address;
    public Byte[] _memory;
    public static MemoryNode ZERO;
    public static int SIZE;
    public UInt32 Stamp { get; public set; }
    public MemoryNode Next { get; public set; }
    public UInt32 UnitCount { get; public set; }
    public bool Available { get; }
    public MemoryNode(UInt32 address, Byte[] memory);
    private static MemoryNode();
    public UInt32 get_Stamp();
    public void set_Stamp(UInt32 value);
    public MemoryNode get_Next();
    public void set_Next(MemoryNode value);
    public UInt32 get_UnitCount();
    public void set_UnitCount(UInt32 value);
    public bool get_Available();
    public void Link(MemoryNode memoryNode);
    public void Unlink();
    public void Insert(MemoryNode memoryNode, UInt32 unitCount);
    public MemoryNode Remove();
    public static MemoryNode op_Implicit(Pointer pointer);
    public static MemoryNode op_Addition(MemoryNode memoryNode, int offset);
    public static MemoryNode op_Addition(MemoryNode memoryNode, UInt32 offset);
    public static MemoryNode op_Subtraction(MemoryNode memoryNode, int offset);
    public static MemoryNode op_Subtraction(MemoryNode memoryNode, UInt32 offset);
    public static bool op_Equality(MemoryNode memoryNode1, MemoryNode memoryNode2);
    public static bool op_Inequality(MemoryNode memoryNode1, MemoryNode memoryNode2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class SharpCompress.Compressors.PPMd.I1.Model : object {
    public static UInt32 SIGNATURE;
    public static char VARIANT;
    public static int MAXIMUM_ORDER;
    private static byte UPPER_FREQUENCY;
    private static byte INTERVAL_BIT_COUNT;
    private static byte PERIOD_BIT_COUNT;
    private static byte TOTAL_BIT_COUNT;
    private static UInt32 INTERVAL;
    private static UInt32 BINARY_SCALE;
    private static UInt32 MAXIMUM_FREQUENCY;
    private static UInt32 ORDER_BOUND;
    private See2Context[0...,0...] _see2Contexts;
    private See2Context _emptySee2Context;
    private PpmContext _maximumContext;
    private UInt16[0...,0...] _binarySummary;
    private Byte[] _numberStatisticsToBinarySummaryIndex;
    private Byte[] _probabilities;
    private Byte[] _characterMask;
    private byte _escapeCount;
    private int _modelOrder;
    private int _orderFall;
    private int _initialEscape;
    private int _initialRunLength;
    private int _runLength;
    private byte _previousSuccess;
    private byte _numberMasked;
    private ModelRestorationMethod _method;
    private PpmState _foundState;
    private Allocator _allocator;
    private Coder _coder;
    private PpmContext _minimumContext;
    private byte _numberStatistics;
    private PpmState[] _decodeStates;
    private static UInt16[] INITIAL_BINARY_ESCAPES;
    private static ReadOnlySpan`1<byte> EXPONENTIAL_ESCAPES { get; }
    private static Model();
    private static ReadOnlySpan`1<byte> get_EXPONENTIAL_ESCAPES();
    public void Encode(Stream target, Stream source, PpmdProperties properties);
    internal Coder EncodeStart(PpmdProperties properties);
    internal void EncodeBlock(Stream target, Stream source, bool final);
    public void Decode(Stream target, Stream source, PpmdProperties properties);
    internal Coder DecodeStart(Stream source, PpmdProperties properties);
    internal int DecodeBlock(Stream source, Byte[] buffer, int offset, int count);
    private void StartModel(int modelOrder, ModelRestorationMethod modelRestorationMethod);
    private void UpdateModel(PpmContext minimumContext);
    private PpmContext CreateSuccessors(bool skip, PpmState state, PpmContext context);
    private PpmContext ReduceOrder(PpmState state, PpmContext context);
    private void RestoreModel(PpmContext context, PpmContext minimumContext, PpmContext foundStateSuccessor);
    private static void Swap(PpmState state1, PpmState state2);
    private static void Copy(PpmState state1, PpmState state2);
    private static int Mean(int sum, int shift, int round);
    private void ClearMask();
    private void EncodeBinarySymbol(int symbol, PpmContext context);
    private void EncodeSymbol1(int symbol, PpmContext context);
    private void EncodeSymbol2(int symbol, PpmContext context);
    private void DecodeBinarySymbol(PpmContext context);
    private void DecodeSymbol1(PpmContext context);
    private void DecodeSymbol2(PpmContext context);
    private void Update1(PpmState state, PpmContext context);
    private void Update2(PpmState state, PpmContext context);
    private See2Context MakeEscapeFrequency(PpmContext context);
    private void Rescale(PpmContext context);
    private void Refresh(UInt32 oldUnitCount, bool scale, PpmContext context);
    private PpmContext CutOff(int order, PpmContext context);
    private PpmContext RemoveBinaryContexts(int order, PpmContext context);
}
internal enum SharpCompress.Compressors.PPMd.I1.ModelRestorationMethod : Enum {
    public int value__;
    public static ModelRestorationMethod Restart;
    public static ModelRestorationMethod CutOff;
    public static ModelRestorationMethod Freeze;
}
[DefaultMemberAttribute("Item")]
internal class SharpCompress.Compressors.PPMd.I1.Pointer : ValueType {
    public UInt32 _address;
    public Byte[] _memory;
    public static Pointer ZERO;
    public static int SIZE;
    public byte Item { get; public set; }
    public Pointer(UInt32 address, Byte[] memory);
    private static Pointer();
    public byte get_Item(int offset);
    public void set_Item(int offset, byte value);
    public static Pointer op_Implicit(MemoryNode memoryNode);
    public static Pointer op_Implicit(PpmContext context);
    public static Pointer op_Implicit(PpmState state);
    public static Pointer op_Addition(Pointer pointer, int offset);
    public static Pointer op_Addition(Pointer pointer, UInt32 offset);
    public static Pointer op_Increment(Pointer pointer);
    public static Pointer op_Subtraction(Pointer pointer, int offset);
    public static Pointer op_Subtraction(Pointer pointer, UInt32 offset);
    public static Pointer op_Decrement(Pointer pointer);
    public static UInt32 op_Subtraction(Pointer pointer1, Pointer pointer2);
    public static bool op_LessThan(Pointer pointer1, Pointer pointer2);
    public static bool op_LessThanOrEqual(Pointer pointer1, Pointer pointer2);
    public static bool op_GreaterThan(Pointer pointer1, Pointer pointer2);
    public static bool op_GreaterThanOrEqual(Pointer pointer1, Pointer pointer2);
    public static bool op_Equality(Pointer pointer1, Pointer pointer2);
    public static bool op_Inequality(Pointer pointer1, Pointer pointer2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
internal class SharpCompress.Compressors.PPMd.I1.PpmState : ValueType {
    public UInt32 _address;
    public Byte[] _memory;
    public static PpmState ZERO;
    public static int SIZE;
    public byte Symbol { get; public set; }
    public byte Frequency { get; public set; }
    public PpmContext Successor { get; public set; }
    public PpmState Item { get; }
    public PpmState(UInt32 address, Byte[] memory);
    private static PpmState();
    public byte get_Symbol();
    public void set_Symbol(byte value);
    public byte get_Frequency();
    public void set_Frequency(byte value);
    public PpmContext get_Successor();
    public void set_Successor(PpmContext value);
    public PpmState get_Item(int offset);
    public static PpmState op_Implicit(Pointer pointer);
    public static PpmState op_Addition(PpmState state, int offset);
    public static PpmState op_Increment(PpmState state);
    public static PpmState op_Subtraction(PpmState state, int offset);
    public static PpmState op_Decrement(PpmState state);
    public static bool op_LessThanOrEqual(PpmState state1, PpmState state2);
    public static bool op_GreaterThanOrEqual(PpmState state1, PpmState state2);
    public static bool op_Equality(PpmState state1, PpmState state2);
    public static bool op_Inequality(PpmState state1, PpmState state2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class SharpCompress.Compressors.PPMd.I1.See2Context : object {
    private static byte PERIOD_BIT_COUNT;
    public ushort _summary;
    public byte _shift;
    public byte _count;
    public void Initialize(UInt32 initialValue);
    public UInt32 Mean();
    public void Update();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Compressors.PPMd.PpmdProperties : object {
    private int _allocatorSize;
    [NullableAttribute("2")]
internal Allocator _allocator;
    [CompilerGeneratedAttribute]
private int <ModelOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private PpmdVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private ModelRestorationMethod <RestorationMethod>k__BackingField;
    public int ModelOrder { get; }
    public PpmdVersion Version { get; }
    internal ModelRestorationMethod RestorationMethod { get; }
    public int AllocatorSize { get; public set; }
    public Byte[] Properties { get; }
    public PpmdProperties(int allocatorSize, int modelOrder);
    internal PpmdProperties(int allocatorSize, int modelOrder, ModelRestorationMethod modelRestorationMethod);
    public PpmdProperties(Byte[] properties);
    [NullableContextAttribute("0")]
public PpmdProperties(ReadOnlySpan`1<byte> properties);
    [CompilerGeneratedAttribute]
public int get_ModelOrder();
    [CompilerGeneratedAttribute]
public PpmdVersion get_Version();
    [CompilerGeneratedAttribute]
internal ModelRestorationMethod get_RestorationMethod();
    public int get_AllocatorSize();
    public void set_AllocatorSize(int value);
    public Byte[] get_Properties();
}
public class SharpCompress.Compressors.PPMd.PpmdStream : Stream {
    private PpmdProperties _properties;
    private Stream _stream;
    private bool _compress;
    private Model _model;
    private ModelPpm _modelH;
    private Decoder _decoder;
    private long _position;
    private bool _isDisposed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public PpmdStream(PpmdProperties properties, Stream stream, bool compress);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    protected virtual void Dispose(bool isDisposing);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
public enum SharpCompress.Compressors.PPMd.PpmdVersion : Enum {
    public int value__;
    public static PpmdVersion H;
    public static PpmdVersion H7Z;
    public static PpmdVersion I1;
}
[NullableContextAttribute("1")]
internal interface SharpCompress.Compressors.Rar.IRarUnpack {
    public bool Suspended { get; public set; }
    public long DestSize { get; }
    public int Char { get; }
    public int PpmEscChar { get; public set; }
    public abstract virtual void DoUnpack(FileHeader fileHeader, Stream readStream, Stream writeStream);
    public abstract virtual void DoUnpack();
    public abstract virtual bool get_Suspended();
    public abstract virtual void set_Suspended(bool value);
    public abstract virtual long get_DestSize();
    public abstract virtual int get_Char();
    public abstract virtual int get_PpmEscChar();
    public abstract virtual void set_PpmEscChar(int value);
}
internal class SharpCompress.Compressors.Rar.MultiVolumeReadOnlyStream : Stream {
    private long currentPosition;
    private long maxPosition;
    private IEnumerator`1<RarFilePart> filePartEnumerator;
    private Stream currentStream;
    private IExtractionListener streamListener;
    private long currentPartTotalReadBytes;
    private long currentEntryTotalReadBytes;
    [CompilerGeneratedAttribute]
private UInt32 <CurrentCrc>k__BackingField;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public UInt32 CurrentCrc { get; private set; }
    public long Length { get; }
    public long Position { get; public set; }
    internal MultiVolumeReadOnlyStream(IEnumerable`1<RarFilePart> parts, IExtractionListener streamListener);
    protected virtual void Dispose(bool disposing);
    private void InitializeNextFilePart();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    [CompilerGeneratedAttribute]
public UInt32 get_CurrentCrc();
    [CompilerGeneratedAttribute]
private void set_CurrentCrc(UInt32 value);
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SharpCompress.Compressors.Rar.RarCRC : object {
    private static UInt32[] crcTab;
    private static RarCRC();
    public static UInt32 CheckCrc(UInt32 startCrc, byte b);
    public static UInt32 CheckCrc(UInt32 startCrc, Byte[] data, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.Rar.RarCrcStream : RarStream {
    private MultiVolumeReadOnlyStream readStream;
    private UInt32 currentCrc;
    public RarCrcStream(IRarUnpack unpack, FileHeader fileHeader, MultiVolumeReadOnlyStream readStream);
    public UInt32 GetCrc();
    public void ResetCrc();
    public virtual int Read(Byte[] buffer, int offset, int count);
}
internal class SharpCompress.Compressors.Rar.RarStream : Stream {
    private IRarUnpack unpack;
    private FileHeader fileHeader;
    private Stream readStream;
    private bool fetch;
    private Byte[] tmpBuffer;
    private int tmpOffset;
    private int tmpCount;
    private Byte[] outBuffer;
    private int outOffset;
    private int outCount;
    private int outTotal;
    private bool isDisposed;
    private long _position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public RarStream(IRarUnpack unpack, FileHeader fileHeader, Stream readStream);
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.Rar.UnpackV1.Decode.AudioVariables : object {
    [CompilerGeneratedAttribute]
private Int32[] <Dif>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ByteCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <D1>k__BackingField;
    [CompilerGeneratedAttribute]
private int <D2>k__BackingField;
    [CompilerGeneratedAttribute]
private int <D3>k__BackingField;
    [CompilerGeneratedAttribute]
private int <D4>k__BackingField;
    [CompilerGeneratedAttribute]
private int <K1>k__BackingField;
    [CompilerGeneratedAttribute]
private int <K2>k__BackingField;
    [CompilerGeneratedAttribute]
private int <K3>k__BackingField;
    [CompilerGeneratedAttribute]
private int <K4>k__BackingField;
    [CompilerGeneratedAttribute]
private int <K5>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LastChar>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LastDelta>k__BackingField;
    internal Int32[] Dif { get; }
    internal int ByteCount { get; internal set; }
    internal int D1 { get; internal set; }
    internal int D2 { get; internal set; }
    internal int D3 { get; internal set; }
    internal int D4 { get; internal set; }
    internal int K1 { get; internal set; }
    internal int K2 { get; internal set; }
    internal int K3 { get; internal set; }
    internal int K4 { get; internal set; }
    internal int K5 { get; internal set; }
    internal int LastChar { get; internal set; }
    internal int LastDelta { get; internal set; }
    [CompilerGeneratedAttribute]
internal Int32[] get_Dif();
    [CompilerGeneratedAttribute]
internal int get_ByteCount();
    [CompilerGeneratedAttribute]
internal void set_ByteCount(int value);
    [CompilerGeneratedAttribute]
internal int get_D1();
    [CompilerGeneratedAttribute]
internal void set_D1(int value);
    [CompilerGeneratedAttribute]
internal int get_D2();
    [CompilerGeneratedAttribute]
internal void set_D2(int value);
    [CompilerGeneratedAttribute]
internal int get_D3();
    [CompilerGeneratedAttribute]
internal void set_D3(int value);
    [CompilerGeneratedAttribute]
internal int get_D4();
    [CompilerGeneratedAttribute]
internal void set_D4(int value);
    [CompilerGeneratedAttribute]
internal int get_K1();
    [CompilerGeneratedAttribute]
internal void set_K1(int value);
    [CompilerGeneratedAttribute]
internal int get_K2();
    [CompilerGeneratedAttribute]
internal void set_K2(int value);
    [CompilerGeneratedAttribute]
internal int get_K3();
    [CompilerGeneratedAttribute]
internal void set_K3(int value);
    [CompilerGeneratedAttribute]
internal int get_K4();
    [CompilerGeneratedAttribute]
internal void set_K4(int value);
    [CompilerGeneratedAttribute]
internal int get_K5();
    [CompilerGeneratedAttribute]
internal void set_K5(int value);
    [CompilerGeneratedAttribute]
internal int get_LastChar();
    [CompilerGeneratedAttribute]
internal void set_LastChar(int value);
    [CompilerGeneratedAttribute]
internal int get_LastDelta();
    [CompilerGeneratedAttribute]
internal void set_LastDelta(int value);
}
internal class SharpCompress.Compressors.Rar.UnpackV1.Decode.BitDecode : Decode {
}
internal enum SharpCompress.Compressors.Rar.UnpackV1.Decode.CodeType : Enum {
    public int value__;
    public static CodeType CODE_HUFFMAN;
    public static CodeType CODE_LZ;
    public static CodeType CODE_LZ2;
    public static CodeType CODE_REPEATLZ;
    public static CodeType CODE_CACHELZ;
    public static CodeType CODE_STARTFILE;
    public static CodeType CODE_ENDFILE;
    public static CodeType CODE_VM;
    public static CodeType CODE_VMDATA;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.Rar.UnpackV1.Decode.Decode : object {
    [CompilerGeneratedAttribute]
private Int32[] <DecodeLen>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <DecodeNum>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <DecodePos>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxNum>k__BackingField;
    internal Int32[] DecodeLen { get; }
    internal Int32[] DecodeNum { get; }
    internal Int32[] DecodePos { get; }
    internal int MaxNum { get; internal set; }
    protected Decode(Int32[] customDecodeNum);
    [CompilerGeneratedAttribute]
internal Int32[] get_DecodeLen();
    [CompilerGeneratedAttribute]
internal Int32[] get_DecodeNum();
    [CompilerGeneratedAttribute]
internal Int32[] get_DecodePos();
    [CompilerGeneratedAttribute]
internal int get_MaxNum();
    [CompilerGeneratedAttribute]
internal void set_MaxNum(int value);
}
internal class SharpCompress.Compressors.Rar.UnpackV1.Decode.DistDecode : Decode {
}
internal enum SharpCompress.Compressors.Rar.UnpackV1.Decode.FilterType : Enum {
    public byte value__;
    public static FilterType FILTER_DELTA;
    public static FilterType FILTER_E8;
    public static FilterType FILTER_E8E9;
    public static FilterType FILTER_ARM;
    public static FilterType FILTER_AUDIO;
    public static FilterType FILTER_RGB;
    public static FilterType FILTER_ITANIUM;
    public static FilterType FILTER_PPM;
    public static FilterType FILTER_NONE;
}
internal class SharpCompress.Compressors.Rar.UnpackV1.Decode.LitDecode : Decode {
}
internal class SharpCompress.Compressors.Rar.UnpackV1.Decode.LowDistDecode : Decode {
}
internal class SharpCompress.Compressors.Rar.UnpackV1.Decode.MultDecode : Decode {
}
internal static class SharpCompress.Compressors.Rar.UnpackV1.Decode.PackDef : object {
    public static int MAXWINSIZE;
    public static int MAXWINMASK;
    public static UInt32 MAX_LZ_MATCH;
    public static UInt32 MAX3_LZ_MATCH;
    public static int LOW_DIST_REP_COUNT;
    public static int NC;
    public static int DC;
    public static int LDC;
    public static int RC;
    public static int HUFF_TABLE_SIZE;
    public static int BC;
    public static UInt32 NC30;
    public static UInt32 DC30;
    public static UInt32 LDC30;
    public static UInt32 RC30;
    public static UInt32 BC30;
    public static UInt32 HUFF_TABLE_SIZE30;
    public static int NC20;
    public static int DC20;
    public static int RC20;
    public static int BC20;
    public static int MC20;
    public static UInt32 LARGEST_TABLE_SIZE;
}
internal class SharpCompress.Compressors.Rar.UnpackV1.Decode.RepDecode : Decode {
}
internal enum SharpCompress.Compressors.Rar.UnpackV1.PPM.BlockTypes : Enum {
    public int value__;
    public static BlockTypes BLOCK_LZ;
    public static BlockTypes BLOCK_PPM;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.Rar.UnpackV1.Unpack : BitInput {
    [NullableAttribute("0")]
private BitInput Inp;
    [CompilerGeneratedAttribute]
private bool <FileExtracted>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PpmEscChar>k__BackingField;
    [NullableAttribute("0")]
private ModelPpm ppm;
    [NullableAttribute("0")]
private RarVM rarVM;
    [NullableAttribute("0")]
private List`1<UnpackFilter> filters;
    [NullableAttribute("0")]
private List`1<UnpackFilter> prgStack;
    [NullableAttribute("0")]
private List`1<int> oldFilterLengths;
    private int lastFilter;
    private bool tablesRead;
    [NullableAttribute("0")]
private Byte[] unpOldTable;
    private BlockTypes unpBlockType;
    private long writtenFileSize;
    private bool ppmError;
    private int prevLowDist;
    private int lowDistRepCount;
    [NullableAttribute("0")]
private static Int32[] DBitLengthCounts;
    [NullableAttribute("0")]
private FileHeader fileHeader;
    private int readBorder;
    private bool suspended;
    internal bool unpAllBuf;
    private Stream readStream;
    private Stream writeStream;
    internal bool unpSomeRead;
    private int readTop;
    private long destUnpSize;
    private Byte[] window;
    private Int32[] oldDist;
    private int unpPtr;
    private int wrPtr;
    private int oldDistPtr;
    private Int32[] ChSet;
    private Int32[] ChSetA;
    private Int32[] ChSetB;
    private Int32[] ChSetC;
    private Int32[] Place;
    private Int32[] PlaceA;
    private Int32[] PlaceB;
    private Int32[] PlaceC;
    private Int32[] NToPl;
    private Int32[] NToPlB;
    private Int32[] NToPlC;
    private int FlagBuf;
    private int AvrPlc;
    private int AvrPlcB;
    private int AvrLn1;
    private int AvrLn2;
    private int AvrLn3;
    private int Buf60;
    private int NumHuf;
    private int StMode;
    private int LCount;
    private int FlagsCnt;
    private int Nhfb;
    private int Nlzb;
    private int MaxDist3;
    private int lastDist;
    private int lastLength;
    private static int STARTL1;
    private static Int32[] DecL1;
    private static Int32[] PosL1;
    private static int STARTL2;
    private static Int32[] DecL2;
    private static Int32[] PosL2;
    private static int STARTHF0;
    private static Int32[] DecHf0;
    private static Int32[] PosHf0;
    private static int STARTHF1;
    private static Int32[] DecHf1;
    private static Int32[] PosHf1;
    private static int STARTHF2;
    private static Int32[] DecHf2;
    private static Int32[] PosHf2;
    private static int STARTHF3;
    private static Int32[] DecHf3;
    private static Int32[] PosHf3;
    private static int STARTHF4;
    private static Int32[] DecHf4;
    private static Int32[] PosHf4;
    private static Int32[] ShortLen1;
    private static Int32[] ShortXor1;
    private static Int32[] ShortLen2;
    private static Int32[] ShortXor2;
    private MultDecode[] MD;
    private Byte[] UnpOldTable20;
    private int UnpAudioBlock;
    private int UnpChannels;
    private int UnpCurChannel;
    private int UnpChannelDelta;
    private AudioVariables[] AudV;
    private LitDecode LD;
    private DistDecode DD;
    private LowDistDecode LDD;
    private RepDecode RD;
    private BitDecode BD;
    private static Int32[] LDecode;
    private static Int32[] DDecode;
    private static Int32[] DBits;
    private static Int32[] SDDecode;
    private static Int32[] SDBits;
    private static int MAX_QUICK_DECODE_BITS;
    private static int MAX_UNPACK_FILTERS;
    private static int MAX3_UNPACK_FILTERS;
    private static int MAX3_UNPACK_CHANNELS;
    private static int MAX_FILTER_BLOCK_SIZE;
    private static int UNPACK_MAX_WRITE;
    private bool TablesRead5;
    private int WriteBorder;
    private static int MaxWinSize;
    private static int MaxWinMask;
    public int BlockSize;
    public int BlockBitSize;
    public int BlockStart;
    public int HeaderSize;
    public bool LastBlockInFile;
    public bool TablePresent;
    public bool FileExtracted { get; private set; }
    public long DestSize { get; public set; }
    public bool Suspended { get; public set; }
    public int Char { get; }
    public int PpmEscChar { get; public set; }
    [NullableAttribute("0")]
private static ReadOnlySpan`1<byte> LBits { get; }
    private int UnpPtr { get; private set; }
    private int ReadBorder { get; private set; }
    private long DestUnpSize { get; private set; }
    private long WrittenFileSize { get; private set; }
    private Byte[] Window { get; }
    private UInt32 LastLength { get; private set; }
    private int WrPtr { get; private set; }
    private Unpack BlockHeader { get; }
    private Unpack Header { get; }
    private int ReadTop { get; private set; }
    private List`1<UnpackFilter> Filters { get; }
    private static Unpack();
    [CompilerGeneratedAttribute]
public bool get_FileExtracted();
    [CompilerGeneratedAttribute]
private void set_FileExtracted(bool value);
    public sealed virtual long get_DestSize();
    public void set_DestSize(long value);
    public sealed virtual bool get_Suspended();
    public sealed virtual void set_Suspended(bool value);
    public sealed virtual int get_Char();
    [CompilerGeneratedAttribute]
public sealed virtual int get_PpmEscChar();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PpmEscChar(int value);
    [NullableContextAttribute("0")]
private void Init(Byte[] window);
    [NullableContextAttribute("0")]
public sealed virtual void DoUnpack(FileHeader fileHeader, Stream readStream, Stream writeStream);
    public sealed virtual void DoUnpack();
    private void UnstoreFile();
    private void Unpack29(bool solid);
    private void UnpWriteBuf();
    private void UnpWriteArea(int startPtr, int endPtr);
    [NullableContextAttribute("0")]
private void UnpWriteData(Byte[] data, int offset, int size);
    private void InsertOldDist(UInt32 distance);
    private void InsertOldDist(int distance);
    private void InsertLastMatch(int length, int distance);
    private void CopyString(UInt32 length, UInt32 distance);
    private void CopyString(int length, int distance);
    private void UnpInitData(bool solid);
    private void InitFilters();
    private bool ReadEndOfBlock();
    private bool ReadTables();
    private bool ReadVMCode();
    private bool ReadVMCodePPM();
    [NullableContextAttribute("0")]
private bool AddVMCode(int firstByte, List`1<byte> vmCode, int length);
    [NullableContextAttribute("0")]
private void ExecuteCode(VMPreparedProgram Prg);
    private void CleanUp();
    private void unpack15(bool solid);
    private bool unpReadBuf();
    private int getShortLen1(int pos);
    private int getShortLen2(int pos);
    private void shortLZ();
    private void longLZ();
    private void huffDecode();
    private void getFlagsBuf();
    private void oldUnpInitData(bool Solid);
    private void initHuff();
    private void corrHuff(Int32[] CharSet, Int32[] NumToPlace);
    private void oldCopyString(int Distance, int Length);
    private int decodeNum(int Num, int StartPos, Int32[] DecTab, Int32[] PosTab);
    private void oldUnpWriteBuf();
    [NullableContextAttribute("0")]
private static ReadOnlySpan`1<byte> get_LBits();
    private void unpack20(bool solid);
    private void CopyString20(int Length, int Distance);
    private bool ReadTables20();
    private void unpInitData20(bool Solid);
    private void ReadLastTables();
    private byte DecodeAudio(int Delta);
    private int get_UnpPtr();
    private void set_UnpPtr(int value);
    private int get_ReadBorder();
    private void set_ReadBorder(int value);
    private long get_DestUnpSize();
    private void set_DestUnpSize(long value);
    private long get_WrittenFileSize();
    private void set_WrittenFileSize(long value);
    private Byte[] get_Window();
    private UInt32 get_LastLength();
    private void set_LastLength(UInt32 value);
    private UInt32 OldDistN(int i);
    private void SetOldDistN(int i, UInt32 value);
    private int get_WrPtr();
    private void set_WrPtr(int value);
    private Unpack get_BlockHeader();
    private Unpack get_Header();
    private int get_ReadTop();
    private void set_ReadTop(int value);
    private List`1<UnpackFilter> get_Filters();
    public void Unpack5(bool Solid);
    private UInt32 ReadFilterData();
    private bool ReadFilter(UnpackFilter Filter);
    private bool AddFilter(UnpackFilter Filter);
    private bool UnpReadBuf();
    private void UnpInitData50(bool Solid);
    private bool ReadBlockHeader();
    private UInt32 SlotToLength(UInt32 Slot);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.Rar.UnpackV1.UnpackFilter : object {
    public byte Type;
    public byte Channels;
    [CompilerGeneratedAttribute]
private int <BlockStart>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BlockLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExecCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NextWindow>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ParentFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private VMPreparedProgram <Program>k__BackingField;
    internal UInt32 uBlockStart { get; internal set; }
    internal UInt32 uBlockLength { get; internal set; }
    internal int BlockStart { get; internal set; }
    internal int BlockLength { get; internal set; }
    internal int ExecCount { get; internal set; }
    internal bool NextWindow { get; internal set; }
    internal int ParentFilter { get; internal set; }
    internal VMPreparedProgram Program { get; internal set; }
    internal UInt32 get_uBlockStart();
    internal void set_uBlockStart(UInt32 value);
    internal UInt32 get_uBlockLength();
    internal void set_uBlockLength(UInt32 value);
    [CompilerGeneratedAttribute]
internal int get_BlockStart();
    [CompilerGeneratedAttribute]
internal void set_BlockStart(int value);
    [CompilerGeneratedAttribute]
internal int get_BlockLength();
    [CompilerGeneratedAttribute]
internal void set_BlockLength(int value);
    [CompilerGeneratedAttribute]
internal int get_ExecCount();
    [CompilerGeneratedAttribute]
internal void set_ExecCount(int value);
    [CompilerGeneratedAttribute]
internal bool get_NextWindow();
    [CompilerGeneratedAttribute]
internal void set_NextWindow(bool value);
    [CompilerGeneratedAttribute]
internal int get_ParentFilter();
    [CompilerGeneratedAttribute]
internal void set_ParentFilter(int value);
    [CompilerGeneratedAttribute]
internal VMPreparedProgram get_Program();
    [CompilerGeneratedAttribute]
internal void set_Program(VMPreparedProgram value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class SharpCompress.Compressors.Rar.UnpackV1.UnpackUtility : object {
    [ExtensionAttribute]
internal static UInt32 DecodeNumber(BitInput input, Decode dec);
    [ExtensionAttribute]
internal static int decodeNumber(BitInput input, Decode dec);
    internal static void makeDecodeTables(Byte[] lenTab, int offset, Decode dec, int size);
}
internal class SharpCompress.Compressors.Rar.UnpackV2017.AudioVariables : object {
    public int K1;
    public int K2;
    public int K3;
    public int K4;
    public int K5;
    public int D1;
    public int D2;
    public int D3;
    public int D4;
    public int LastDelta;
    [NullableAttribute("1")]
public UInt32[] Dif;
    public UInt32 ByteCount;
    public int LastChar;
}
internal class SharpCompress.Compressors.Rar.UnpackV2017.BitInput : object {
    public static int MAX_SIZE;
    public int InAddr;
    public int InBit;
    public bool ExternalBuffer;
    [NullableAttribute("1")]
public Byte[] InBuf;
    public BitInput(bool AllocBuffer);
    public void faddbits(UInt32 Bits);
    public UInt32 fgetbits();
    public void InitBitInput();
    public void addbits(UInt32 _Bits);
    public UInt32 getbits();
    public UInt32 getbits32();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.Rar.UnpackV2017.DecodeTable : object {
    public UInt32 MaxNum;
    public UInt32[] DecodeLen;
    public UInt32[] DecodePos;
    public UInt32 QuickBits;
    public Byte[] QuickLen;
    public UInt16[] QuickNum;
    public UInt16[] DecodeNum;
}
[DefaultMemberAttribute("Item")]
internal class SharpCompress.Compressors.Rar.UnpackV2017.FragmentedWindow : object {
    private static int MAX_MEM_BLOCKS;
    [NullableAttribute("1")]
private Byte[][] Mem;
    [NullableAttribute("1")]
private UInt32[] MemSize;
    public byte Item { get; public set; }
    private void Reset();
    public void Init(UInt32 WinSize);
    public byte get_Item(UInt32 Item);
    public void set_Item(UInt32 Item, byte value);
    public void GetBuffer(UInt32 Item, Byte[]& buf, UInt32& offset);
    public void CopyString(UInt32 Length, UInt32 Distance, UInt32& UnpPtr, UInt32 MaxWinMask);
    public void CopyData(Byte[] Dest, UInt32 destOffset, UInt32 WinPos, UInt32 Size);
    public UInt32 GetBlockSize(UInt32 StartPos, UInt32 RequiredSize);
}
internal static class SharpCompress.Compressors.Rar.UnpackV2017.PackDef : object {
    public static UInt32 MAX_LZ_MATCH;
    public static UInt32 MAX3_LZ_MATCH;
    public static UInt32 LOW_DIST_REP_COUNT;
    public static UInt32 NC;
    public static UInt32 DC;
    public static UInt32 LDC;
    public static UInt32 RC;
    public static UInt32 HUFF_TABLE_SIZE;
    public static UInt32 BC;
    public static UInt32 NC30;
    public static UInt32 DC30;
    public static UInt32 LDC30;
    public static UInt32 RC30;
    public static UInt32 BC30;
    public static UInt32 HUFF_TABLE_SIZE30;
    public static UInt32 NC20;
    public static UInt32 DC20;
    public static UInt32 RC20;
    public static UInt32 BC20;
    public static UInt32 MC20;
    public static UInt32 LARGEST_TABLE_SIZE;
    public static int FILTER_DELTA;
    public static int FILTER_E8;
    public static int FILTER_E8E9;
    public static int FILTER_ARM;
    public static int FILTER_AUDIO;
    public static int FILTER_RGB;
    public static int FILTER_ITANIUM;
    public static int FILTER_PPM;
    public static int FILTER_NONE;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.Rar.UnpackV2017.Unpack : BitInput {
    private FileHeader fileHeader;
    private Stream readStream;
    private Stream writeStream;
    [CompilerGeneratedAttribute]
private bool <Suspended>k__BackingField;
    private static int STARTL1;
    private static UInt32[] DecL1;
    private static UInt32[] PosL1;
    private static int STARTL2;
    private static UInt32[] DecL2;
    private static UInt32[] PosL2;
    private static int STARTHF0;
    private static UInt32[] DecHf0;
    private static UInt32[] PosHf0;
    private static int STARTHF1;
    private static UInt32[] DecHf1;
    private static UInt32[] PosHf1;
    private static int STARTHF2;
    private static UInt32[] DecHf2;
    private static UInt32[] PosHf2;
    private static int STARTHF3;
    private static UInt32[] DecHf3;
    private static UInt32[] PosHf3;
    private static int STARTHF4;
    private static UInt32[] DecHf4;
    private static UInt32[] PosHf4;
    private Byte[] FilterSrcMemory;
    private Byte[] FilterDstMemory;
    private List`1<UnpackFilter> Filters;
    private UInt32[] OldDist;
    private UInt32 OldDistPtr;
    private UInt32 LastLength;
    private UInt32 LastDist;
    private UInt32 UnpPtr;
    private UInt32 WrPtr;
    private int ReadTop;
    private int ReadBorder;
    private UnpackBlockHeader BlockHeader;
    private UnpackBlockTables BlockTables;
    private UInt32 WriteBorder;
    private Byte[] Window;
    private FragmentedWindow FragWindow;
    private bool Fragmented;
    private long DestUnpSize;
    private bool UnpAllBuf;
    private bool UnpSomeRead;
    private long WrittenFileSize;
    private bool FileExtracted;
    private UInt16[] ChSet;
    private UInt16[] ChSetA;
    private UInt16[] ChSetB;
    private UInt16[] ChSetC;
    private Byte[] NToPl;
    private Byte[] NToPlB;
    private Byte[] NToPlC;
    private UInt32 FlagBuf;
    private UInt32 AvrPlc;
    private UInt32 AvrPlcB;
    private UInt32 AvrLn1;
    private UInt32 AvrLn2;
    private UInt32 AvrLn3;
    private int Buf60;
    private int NumHuf;
    private int StMode;
    private int LCount;
    private int FlagsCnt;
    private UInt32 Nhfb;
    private UInt32 Nlzb;
    private UInt32 MaxDist3;
    private DecodeTable[] MD;
    private Byte[] UnpOldTable20;
    private bool UnpAudioBlock;
    private UInt32 UnpChannels;
    private UInt32 UnpCurChannel;
    private int UnpChannelDelta;
    private AudioVariables[] AudV;
    public static int BLOCK_LZ;
    public static int BLOCK_PPM;
    private int PPMEscChar;
    private Byte[] UnpOldTable;
    private bool TablesRead2;
    private bool TablesRead5;
    private BitInput VMCodeInp;
    private List`1<UnpackFilter30> Filters30;
    private List`1<UnpackFilter30> PrgStack;
    private List`1<int> OldFilterLengths;
    private UInt32 MaxWinSize;
    private UInt32 MaxWinMask;
    public bool Suspended { get; public set; }
    public long DestSize { get; }
    public int Char { get; }
    public int PpmEscChar { get; public set; }
    private BitInput Inp { get; }
    private static Unpack();
    private void _UnpackCtor();
    private int UnpIO_UnpRead(Byte[] buf, int offset, int count);
    private void UnpIO_UnpWrite(Byte[] buf, UInt32 offset, UInt32 count);
    public sealed virtual void DoUnpack(FileHeader fileHeader, Stream readStream, Stream writeStream);
    public sealed virtual void DoUnpack();
    private void UnstoreFile();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Suspended();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Suspended(bool value);
    public sealed virtual long get_DestSize();
    public sealed virtual int get_Char();
    public sealed virtual int get_PpmEscChar();
    public sealed virtual void set_PpmEscChar(int value);
    public static Byte[] EnsureCapacity(Byte[] array, int length);
    private UInt32 RawGet4(Byte[] D, int offset);
    private void RawPut4(UInt32 Field, Byte[] D, int offset);
    private void Unpack15(bool Solid);
    private UInt32 GetShortLen1(UInt32 pos);
    private UInt32 GetShortLen2(UInt32 pos);
    private void ShortLZ();
    private void LongLZ();
    private void HuffDecode();
    private void GetFlagsBuf();
    private void UnpInitData15(bool Solid);
    private void InitHuff();
    private void CorrHuff(UInt16[] CharSet, Byte[] NumToPlace);
    private void CopyString15(UInt32 Distance, UInt32 Length);
    private UInt32 DecodeNum(UInt32 Num, UInt32 StartPos, UInt32[] DecTab, UInt32[] PosTab);
    private void CopyString20(UInt32 Length, UInt32 Distance);
    private void Unpack20(bool Solid);
    private void UnpWriteBuf20();
    private bool ReadTables20();
    private void ReadLastTables();
    private void UnpInitData20(bool Solid);
    private byte DecodeAudio(int Delta);
    private void Unpack5(bool Solid);
    [NullableContextAttribute("0")]
private UInt32 ReadFilterData(BitInput Inp);
    [NullableContextAttribute("0")]
private bool ReadFilter(BitInput Inp, UnpackFilter Filter);
    [NullableContextAttribute("0")]
private bool AddFilter(UnpackFilter Filter);
    private bool UnpReadBuf();
    private void UnpWriteBuf();
    [NullableContextAttribute("0")]
private Byte[] ApplyFilter(Byte[] __d, UInt32 DataSize, UnpackFilter Flt);
    private void UnpWriteArea(UInt32 StartPtr, UInt32 EndPtr);
    [NullableContextAttribute("0")]
private void UnpWriteData(Byte[] Data, UInt32 offset, UInt32 Size);
    private void UnpInitData50(bool Solid);
    [NullableContextAttribute("0")]
private bool ReadBlockHeader(BitInput Inp, UnpackBlockHeader& Header);
    [NullableContextAttribute("0")]
private bool ReadTables(BitInput Inp, UnpackBlockHeader& Header, UnpackBlockTables& Tables);
    private void InitFilters();
    private void InsertOldDist(UInt32 Distance);
    private void CopyString(UInt32 Length, UInt32 Distance);
    private UInt32 DecodeNumber(BitInput Inp, DecodeTable Dec);
    private UInt32 SlotToLength(BitInput Inp, UInt32 Slot);
    private void Init(UInt32 WinSize, bool Solid);
    private void DoUnpack(UInt32 Method, bool Solid);
    private void UnpInitData(bool Solid);
    [NullableContextAttribute("0")]
private void MakeDecodeTables(Byte[] LengthTable, int offset, DecodeTable Dec, UInt32 Size);
    private BitInput get_Inp();
}
internal class SharpCompress.Compressors.Rar.UnpackV2017.UnpackBlockHeader : ValueType {
    public int BlockSize;
    public int BlockBitSize;
    public int BlockStart;
    public int HeaderSize;
    public bool LastBlockInFile;
    public bool TablePresent;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.Rar.UnpackV2017.UnpackBlockTables : ValueType {
    public DecodeTable LD;
    public DecodeTable DD;
    public DecodeTable LDD;
    public DecodeTable RD;
    public DecodeTable BD;
    public void Init();
}
internal class SharpCompress.Compressors.Rar.UnpackV2017.UnpackFilter : object {
    public byte Type;
    public UInt32 BlockStart;
    public UInt32 BlockLength;
    public byte Channels;
    public bool NextWindow;
}
internal class SharpCompress.Compressors.Rar.UnpackV2017.UnpackFilter30 : object {
    public UInt32 BlockStart;
    public UInt32 BlockLength;
    public bool NextWindow;
    public UInt32 ParentFilter;
}
internal static class SharpCompress.Compressors.Rar.UnpackV2017.UnpackGlobal : object {
    public static int MAX_QUICK_DECODE_BITS;
    public static int MAX_UNPACK_FILTERS;
    public static int MAX3_UNPACK_FILTERS;
    public static int MAX_FILTER_BLOCK_SIZE;
    public static int UNPACK_MAX_WRITE;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.Rar.VM.BitInput : object {
    internal static int MAX_SIZE;
    public int inAddr;
    public int inBit;
    public bool ExternalBuffer;
    [CompilerGeneratedAttribute]
private Byte[] <InBuf>k__BackingField;
    public int InAddr { get; public set; }
    public int InBit { get; public set; }
    internal Byte[] InBuf { get; }
    public int get_InAddr();
    public void set_InAddr(int value);
    public int get_InBit();
    public void set_InBit(int value);
    [CompilerGeneratedAttribute]
internal Byte[] get_InBuf();
    internal void InitBitInput();
    internal void faddbits(UInt32 bits);
    internal void AddBits(int bits);
    internal UInt32 fgetbits();
    internal UInt32 getbits();
    internal int GetBits();
    internal bool Overflow(int IncPtr);
}
internal class SharpCompress.Compressors.Rar.VM.RarVM : BitInput {
    [CompilerGeneratedAttribute]
private Byte[] <Mem>k__BackingField;
    public static int VM_MEMSIZE;
    public static int VM_MEMMASK;
    public static int VM_GLOBALMEMADDR;
    public static int VM_GLOBALMEMSIZE;
    public static int VM_FIXEDGLOBALSIZE;
    private static int regCount;
    private Int32[] R;
    private VMFlags flags;
    private int maxOpCount;
    private int codeSize;
    private int IP;
    internal Byte[] Mem { get; private set; }
    private static RarVM();
    [CompilerGeneratedAttribute]
internal Byte[] get_Mem();
    [CompilerGeneratedAttribute]
private void set_Mem(Byte[] value);
    internal void init();
    private bool IsVMMem(Byte[] mem);
    private int GetValue(bool byteMode, Byte[] mem, int offset);
    private void SetValue(bool byteMode, Byte[] mem, int offset, int value);
    internal void SetLowEndianValue(List`1<byte> mem, int offset, int value);
    private int GetOperand(VMPreparedOperand cmdOp);
    public void execute(VMPreparedProgram prg);
    private bool setIP(int ip);
    private bool ExecuteCode(List`1<VMPreparedCommand> preparedCode, int cmdCount);
    public void prepare(Byte[] code, int codeSize, VMPreparedProgram prg);
    private void decodeArg(VMPreparedOperand op, bool byteMode);
    private void optimize(VMPreparedProgram prg);
    internal static int ReadData(BitInput rarVM);
    private VMStandardFilters IsStandardFilter(Byte[] code, int codeSize);
    private void ExecuteStandardFilter(VMStandardFilters filterType);
    private void filterItanium_SetBits(int curPos, int bitField, int bitPos, int bitCount);
    private int filterItanium_GetBits(int curPos, int bitPos, int bitCount);
    public void setMemory(int pos, Byte[] data, int offset, int dataSize);
}
internal class SharpCompress.Compressors.Rar.VM.VMCmdFlags : object {
    public static byte VMCF_OP0;
    public static byte VMCF_OP1;
    public static byte VMCF_OP2;
    public static byte VMCF_OPMASK;
    public static byte VMCF_BYTEMODE;
    public static byte VMCF_JUMP;
    public static byte VMCF_PROC;
    public static byte VMCF_USEFLAGS;
    public static byte VMCF_CHFLAGS;
    [NullableAttribute("1")]
public static Byte[] VM_CmdFlags;
    private static VMCmdFlags();
}
internal enum SharpCompress.Compressors.Rar.VM.VMCommands : Enum {
    public int value__;
    public static VMCommands VM_MOV;
    public static VMCommands VM_CMP;
    public static VMCommands VM_ADD;
    public static VMCommands VM_SUB;
    public static VMCommands VM_JZ;
    public static VMCommands VM_JNZ;
    public static VMCommands VM_INC;
    public static VMCommands VM_DEC;
    public static VMCommands VM_JMP;
    public static VMCommands VM_XOR;
    public static VMCommands VM_AND;
    public static VMCommands VM_OR;
    public static VMCommands VM_TEST;
    public static VMCommands VM_JS;
    public static VMCommands VM_JNS;
    public static VMCommands VM_JB;
    public static VMCommands VM_JBE;
    public static VMCommands VM_JA;
    public static VMCommands VM_JAE;
    public static VMCommands VM_PUSH;
    public static VMCommands VM_POP;
    public static VMCommands VM_CALL;
    public static VMCommands VM_RET;
    public static VMCommands VM_NOT;
    public static VMCommands VM_SHL;
    public static VMCommands VM_SHR;
    public static VMCommands VM_SAR;
    public static VMCommands VM_NEG;
    public static VMCommands VM_PUSHA;
    public static VMCommands VM_POPA;
    public static VMCommands VM_PUSHF;
    public static VMCommands VM_POPF;
    public static VMCommands VM_MOVZX;
    public static VMCommands VM_MOVSX;
    public static VMCommands VM_XCHG;
    public static VMCommands VM_MUL;
    public static VMCommands VM_DIV;
    public static VMCommands VM_ADC;
    public static VMCommands VM_SBB;
    public static VMCommands VM_PRINT;
    public static VMCommands VM_MOVB;
    public static VMCommands VM_MOVD;
    public static VMCommands VM_CMPB;
    public static VMCommands VM_CMPD;
    public static VMCommands VM_ADDB;
    public static VMCommands VM_ADDD;
    public static VMCommands VM_SUBB;
    public static VMCommands VM_SUBD;
    public static VMCommands VM_INCB;
    public static VMCommands VM_INCD;
    public static VMCommands VM_DECB;
    public static VMCommands VM_DECD;
    public static VMCommands VM_NEGB;
    public static VMCommands VM_NEGD;
    public static VMCommands VM_STANDARD;
}
internal enum SharpCompress.Compressors.Rar.VM.VMFlags : Enum {
    public int value__;
    public static VMFlags None;
    public static VMFlags VM_FC;
    public static VMFlags VM_FZ;
    public static VMFlags VM_FS;
}
internal enum SharpCompress.Compressors.Rar.VM.VMOpType : Enum {
    public int value__;
    public static VMOpType VM_OPREG;
    public static VMOpType VM_OPINT;
    public static VMOpType VM_OPREGMEM;
    public static VMOpType VM_OPNONE;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.Rar.VM.VMPreparedCommand : object {
    [CompilerGeneratedAttribute]
private VMCommands <OpCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsByteMode>k__BackingField;
    [CompilerGeneratedAttribute]
private VMPreparedOperand <Op1>k__BackingField;
    [CompilerGeneratedAttribute]
private VMPreparedOperand <Op2>k__BackingField;
    internal VMCommands OpCode { get; internal set; }
    internal bool IsByteMode { get; internal set; }
    internal VMPreparedOperand Op1 { get; }
    internal VMPreparedOperand Op2 { get; }
    [CompilerGeneratedAttribute]
internal VMCommands get_OpCode();
    [CompilerGeneratedAttribute]
internal void set_OpCode(VMCommands value);
    [CompilerGeneratedAttribute]
internal bool get_IsByteMode();
    [CompilerGeneratedAttribute]
internal void set_IsByteMode(bool value);
    [CompilerGeneratedAttribute]
internal VMPreparedOperand get_Op1();
    [CompilerGeneratedAttribute]
internal VMPreparedOperand get_Op2();
}
internal class SharpCompress.Compressors.Rar.VM.VMPreparedOperand : object {
    [CompilerGeneratedAttribute]
private VMOpType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Base>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    internal VMOpType Type { get; internal set; }
    internal int Data { get; internal set; }
    internal int Base { get; internal set; }
    internal int Offset { get; internal set; }
    [CompilerGeneratedAttribute]
internal VMOpType get_Type();
    [CompilerGeneratedAttribute]
internal void set_Type(VMOpType value);
    [CompilerGeneratedAttribute]
internal int get_Data();
    [CompilerGeneratedAttribute]
internal void set_Data(int value);
    [CompilerGeneratedAttribute]
internal int get_Base();
    [CompilerGeneratedAttribute]
internal void set_Base(int value);
    [CompilerGeneratedAttribute]
internal int get_Offset();
    [CompilerGeneratedAttribute]
internal void set_Offset(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Compressors.Rar.VM.VMPreparedProgram : object {
    internal List`1<VMPreparedCommand> Commands;
    internal List`1<VMPreparedCommand> AltCommands;
    [CompilerGeneratedAttribute]
private int <CommandCount>k__BackingField;
    internal List`1<byte> GlobalData;
    internal List`1<byte> StaticData;
    internal Int32[] InitR;
    [CompilerGeneratedAttribute]
private int <FilteredDataOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FilteredDataSize>k__BackingField;
    public int CommandCount { get; public set; }
    internal int FilteredDataOffset { get; internal set; }
    internal int FilteredDataSize { get; internal set; }
    [CompilerGeneratedAttribute]
public int get_CommandCount();
    [CompilerGeneratedAttribute]
public void set_CommandCount(int value);
    [CompilerGeneratedAttribute]
internal int get_FilteredDataOffset();
    [CompilerGeneratedAttribute]
internal void set_FilteredDataOffset(int value);
    [CompilerGeneratedAttribute]
internal int get_FilteredDataSize();
    [CompilerGeneratedAttribute]
internal void set_FilteredDataSize(int value);
}
internal enum SharpCompress.Compressors.Rar.VM.VMStandardFilters : Enum {
    public int value__;
    public static VMStandardFilters VMSF_NONE;
    public static VMStandardFilters VMSF_E8;
    public static VMStandardFilters VMSF_E8E9;
    public static VMStandardFilters VMSF_ITANIUM;
    public static VMStandardFilters VMSF_RGB;
    public static VMStandardFilters VMSF_AUDIO;
    public static VMStandardFilters VMSF_DELTA;
    public static VMStandardFilters VMSF_UPCASE;
}
internal class SharpCompress.Compressors.Rar.VM.VMStandardFilterSignature : object {
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CRC>k__BackingField;
    [CompilerGeneratedAttribute]
private VMStandardFilters <Type>k__BackingField;
    internal int Length { get; }
    internal UInt32 CRC { get; }
    internal VMStandardFilters Type { get; }
    internal VMStandardFilterSignature(int length, UInt32 crc, VMStandardFilters type);
    [CompilerGeneratedAttribute]
internal int get_Length();
    [CompilerGeneratedAttribute]
internal UInt32 get_CRC();
    [CompilerGeneratedAttribute]
internal VMStandardFilters get_Type();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static class SharpCompress.Compressors.Xz.BinaryUtils : object {
    [ExtensionAttribute]
public static int ReadLittleEndianInt32(BinaryReader reader);
    [ExtensionAttribute]
internal static UInt32 ReadLittleEndianUInt32(BinaryReader reader);
    [ExtensionAttribute]
public static int ReadLittleEndianInt32(Stream stream);
    [ExtensionAttribute]
internal static UInt32 ReadLittleEndianUInt32(Stream stream);
    [ExtensionAttribute]
internal static Byte[] ToBigEndianBytes(UInt32 uint32);
    [ExtensionAttribute]
public static Byte[] ToLittleEndianBytes(UInt32 uint32);
}
public enum SharpCompress.Compressors.Xz.CheckType : Enum {
    public byte value__;
    public static CheckType NONE;
    public static CheckType CRC32;
    public static CheckType CRC64;
    public static CheckType SHA256;
}
[CLSCompliantAttribute("False")]
public static class SharpCompress.Compressors.Xz.Crc32 : object {
    public static UInt32 DefaultPolynomial;
    public static UInt32 DefaultSeed;
    private static UInt32[] defaultTable;
    public static UInt32 Compute(Byte[] buffer);
    public static UInt32 Compute(UInt32 seed, Byte[] buffer);
    public static UInt32 Compute(UInt32 polynomial, UInt32 seed, Byte[] buffer);
    private static UInt32[] InitializeTable(UInt32 polynomial);
    private static UInt32 CalculateHash(UInt32[] table, UInt32 seed, ReadOnlySpan`1<byte> buffer);
}
[CLSCompliantAttribute("False")]
public static class SharpCompress.Compressors.Xz.Crc64 : object {
    public static ulong DefaultSeed;
    internal static UInt64[] Table;
    public static ulong Iso3309Polynomial;
    public static ulong Compute(Byte[] buffer);
    public static ulong Compute(ulong seed, Byte[] buffer);
    public static ulong CalculateHash(ulong seed, UInt64[] table, ReadOnlySpan`1<byte> buffer);
    public static UInt64[] CreateTable(ulong polynomial);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Compressors.Xz.Filters.ArmFilter : BlockFilter {
    private UInt32 _ip;
    public bool AllowAsLast { get; }
    public bool AllowAsNonLast { get; }
    public bool ChangesDataSize { get; }
    public virtual bool get_AllowAsLast();
    public virtual bool get_AllowAsNonLast();
    public virtual bool get_ChangesDataSize();
    public virtual void Init(Byte[] properties);
    public virtual void ValidateFilter();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void SetBaseStream(Stream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Compressors.Xz.Filters.ArmThumbFilter : BlockFilter {
    private UInt32 _ip;
    public bool AllowAsLast { get; }
    public bool AllowAsNonLast { get; }
    public bool ChangesDataSize { get; }
    public virtual bool get_AllowAsLast();
    public virtual bool get_AllowAsNonLast();
    public virtual bool get_ChangesDataSize();
    public virtual void Init(Byte[] properties);
    public virtual void ValidateFilter();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void SetBaseStream(Stream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class SharpCompress.Compressors.Xz.Filters.BlockFilter : ReadOnlyStream {
    private static Dictionary`2<FilterTypes, Func`1<BlockFilter>> FILTER_MAP;
    public bool AllowAsLast { get; }
    public bool AllowAsNonLast { get; }
    public bool ChangesDataSize { get; }
    private static BlockFilter();
    public abstract virtual bool get_AllowAsLast();
    public abstract virtual bool get_AllowAsNonLast();
    public abstract virtual bool get_ChangesDataSize();
    public abstract virtual void Init(Byte[] properties);
    public abstract virtual void ValidateFilter();
    public static BlockFilter Read(BinaryReader reader);
    public abstract virtual void SetBaseStream(Stream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Compressors.Xz.Filters.IA64Filter : BlockFilter {
    private UInt32 _ip;
    public bool AllowAsLast { get; }
    public bool AllowAsNonLast { get; }
    public bool ChangesDataSize { get; }
    public virtual bool get_AllowAsLast();
    public virtual bool get_AllowAsNonLast();
    public virtual bool get_ChangesDataSize();
    public virtual void Init(Byte[] properties);
    public virtual void ValidateFilter();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void SetBaseStream(Stream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[CLSCompliantAttribute("False")]
public class SharpCompress.Compressors.Xz.Filters.Lzma2Filter : BlockFilter {
    private byte _dictionarySize;
    public bool AllowAsLast { get; }
    public bool AllowAsNonLast { get; }
    public bool ChangesDataSize { get; }
    public UInt32 DictionarySize { get; }
    public virtual bool get_AllowAsLast();
    public virtual bool get_AllowAsNonLast();
    public virtual bool get_ChangesDataSize();
    public UInt32 get_DictionarySize();
    public virtual void Init(Byte[] properties);
    public virtual void ValidateFilter();
    public virtual void SetBaseStream(Stream stream);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Compressors.Xz.Filters.PowerPCFilter : BlockFilter {
    private UInt32 _ip;
    public bool AllowAsLast { get; }
    public bool AllowAsNonLast { get; }
    public bool ChangesDataSize { get; }
    public virtual bool get_AllowAsLast();
    public virtual bool get_AllowAsNonLast();
    public virtual bool get_ChangesDataSize();
    public virtual void Init(Byte[] properties);
    public virtual void ValidateFilter();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void SetBaseStream(Stream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Compressors.Xz.Filters.SparcFilter : BlockFilter {
    private UInt32 _ip;
    public bool AllowAsLast { get; }
    public bool AllowAsNonLast { get; }
    public bool ChangesDataSize { get; }
    public virtual bool get_AllowAsLast();
    public virtual bool get_AllowAsNonLast();
    public virtual bool get_ChangesDataSize();
    public virtual void Init(Byte[] properties);
    public virtual void ValidateFilter();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void SetBaseStream(Stream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Compressors.Xz.Filters.X86Filter : BlockFilter {
    private UInt32 _ip;
    private UInt32 _state;
    public bool AllowAsLast { get; }
    public bool AllowAsNonLast { get; }
    public bool ChangesDataSize { get; }
    public virtual bool get_AllowAsLast();
    public virtual bool get_AllowAsNonLast();
    public virtual bool get_ChangesDataSize();
    public virtual void Init(Byte[] properties);
    public virtual void ValidateFilter();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void SetBaseStream(Stream stream);
}
[ExtensionAttribute]
internal static class SharpCompress.Compressors.Xz.MultiByteIntegers : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ulong ReadXZInteger(BinaryReader reader, int MaxBytes);
}
public abstract class SharpCompress.Compressors.Xz.ReadOnlyStream : Stream {
    [CompilerGeneratedAttribute]
private Stream <BaseStream>k__BackingField;
    public Stream BaseStream { get; protected set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    [CompilerGeneratedAttribute]
public Stream get_BaseStream();
    [CompilerGeneratedAttribute]
protected void set_BaseStream(Stream value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[CLSCompliantAttribute("False")]
public class SharpCompress.Compressors.Xz.XZBlock : XZReadOnlyStream {
    [CompilerGeneratedAttribute]
private Nullable`1<ulong> <CompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ulong> <UncompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Stack`1<BlockFilter> <Filters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HeaderIsLoaded>k__BackingField;
    private CheckType _checkType;
    private int _checkSize;
    private bool _streamConnected;
    private int _numFilters;
    private byte _blockHeaderSizeByte;
    private Stream _decomStream;
    private bool _endOfStream;
    private bool _paddingSkipped;
    private bool _crcChecked;
    private ulong _bytesRead;
    public int BlockHeaderSize { get; }
    public Nullable`1<ulong> CompressedSize { get; private set; }
    public Nullable`1<ulong> UncompressedSize { get; private set; }
    public Stack`1<BlockFilter> Filters { get; private set; }
    public bool HeaderIsLoaded { get; private set; }
    public XZBlock(Stream stream, CheckType checkType, int checkSize);
    public int get_BlockHeaderSize();
    [CompilerGeneratedAttribute]
public Nullable`1<ulong> get_CompressedSize();
    [CompilerGeneratedAttribute]
private void set_CompressedSize(Nullable`1<ulong> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ulong> get_UncompressedSize();
    [CompilerGeneratedAttribute]
private void set_UncompressedSize(Nullable`1<ulong> value);
    [CompilerGeneratedAttribute]
public Stack`1<BlockFilter> get_Filters();
    [CompilerGeneratedAttribute]
private void set_Filters(Stack`1<BlockFilter> value);
    [CompilerGeneratedAttribute]
public bool get_HeaderIsLoaded();
    [CompilerGeneratedAttribute]
private void set_HeaderIsLoaded(bool value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    private void SkipPadding();
    private void CheckCrc();
    private void ConnectStream();
    private void LoadHeader();
    private void ReadHeaderSize();
    private Byte[] CacheHeader();
    private void ReadBlockFlags(BinaryReader reader);
    private void ReadFilters(BinaryReader reader, long baseStreamOffset);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class SharpCompress.Compressors.Xz.XZFooter : object {
    [NullableAttribute("1")]
private BinaryReader _reader;
    [CompilerGeneratedAttribute]
private long <StreamStartPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BackwardSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <StreamFlags>k__BackingField;
    [NullableAttribute("0")]
private static ReadOnlySpan`1<byte> _magicBytes { get; }
    public long StreamStartPosition { get; private set; }
    public long BackwardSize { get; private set; }
    public Byte[] StreamFlags { get; private set; }
    [NullableContextAttribute("1")]
public XZFooter(BinaryReader reader);
    [NullableContextAttribute("0")]
private static ReadOnlySpan`1<byte> get__magicBytes();
    [CompilerGeneratedAttribute]
public long get_StreamStartPosition();
    [CompilerGeneratedAttribute]
private void set_StreamStartPosition(long value);
    [CompilerGeneratedAttribute]
public long get_BackwardSize();
    [CompilerGeneratedAttribute]
private void set_BackwardSize(long value);
    [CompilerGeneratedAttribute]
public Byte[] get_StreamFlags();
    [CompilerGeneratedAttribute]
private void set_StreamFlags(Byte[] value);
    [NullableContextAttribute("1")]
public static XZFooter FromStream(Stream stream);
    public void Process();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Compressors.Xz.XZHeader : object {
    private BinaryReader _reader;
    private Byte[] MagicHeader;
    [CompilerGeneratedAttribute]
private CheckType <BlockCheckType>k__BackingField;
    public CheckType BlockCheckType { get; private set; }
    public int BlockCheckSize { get; }
    public XZHeader(BinaryReader reader);
    [CompilerGeneratedAttribute]
public CheckType get_BlockCheckType();
    [CompilerGeneratedAttribute]
private void set_BlockCheckType(CheckType value);
    public int get_BlockCheckSize();
    public static XZHeader FromStream(Stream stream);
    public void Process();
    private void ProcessStreamFlags();
    private void CheckMagicBytes(Byte[] header);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[CLSCompliantAttribute("False")]
public class SharpCompress.Compressors.Xz.XZIndex : object {
    private BinaryReader _reader;
    [CompilerGeneratedAttribute]
private long <StreamStartPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <NumberOfRecords>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<XZIndexRecord> <Records>k__BackingField;
    private bool _indexMarkerAlreadyVerified;
    public long StreamStartPosition { get; private set; }
    public ulong NumberOfRecords { get; private set; }
    public List`1<XZIndexRecord> Records { get; }
    public XZIndex(BinaryReader reader, bool indexMarkerAlreadyVerified);
    [CompilerGeneratedAttribute]
public long get_StreamStartPosition();
    [CompilerGeneratedAttribute]
private void set_StreamStartPosition(long value);
    [CompilerGeneratedAttribute]
public ulong get_NumberOfRecords();
    [CompilerGeneratedAttribute]
private void set_NumberOfRecords(ulong value);
    [CompilerGeneratedAttribute]
public List`1<XZIndexRecord> get_Records();
    public static XZIndex FromStream(Stream stream, bool indexMarkerAlreadyVerified);
    public void Process();
    private void VerifyIndexMarker();
    private void SkipPadding();
    private void VerifyCrc32();
}
public class SharpCompress.Compressors.Xz.XZIndexMarkerReachedException : Exception {
}
[CLSCompliantAttribute("False")]
public class SharpCompress.Compressors.Xz.XZIndexRecord : object {
    [CompilerGeneratedAttribute]
private ulong <UnpaddedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <UncompressedSize>k__BackingField;
    public ulong UnpaddedSize { get; private set; }
    public ulong UncompressedSize { get; private set; }
    [CompilerGeneratedAttribute]
public ulong get_UnpaddedSize();
    [CompilerGeneratedAttribute]
private void set_UnpaddedSize(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_UncompressedSize();
    [CompilerGeneratedAttribute]
private void set_UncompressedSize(ulong value);
    [NullableContextAttribute("1")]
public static XZIndexRecord FromBinaryReader(BinaryReader br);
}
public abstract class SharpCompress.Compressors.Xz.XZReadOnlyStream : ReadOnlyStream {
    [NullableContextAttribute("1")]
public XZReadOnlyStream(Stream stream);
}
[CLSCompliantAttribute("False")]
public class SharpCompress.Compressors.Xz.XZStream : XZReadOnlyStream {
    [CompilerGeneratedAttribute]
private XZHeader <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private XZIndex <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private XZFooter <Footer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HeaderIsRead>k__BackingField;
    private XZBlock _currentBlock;
    private bool _endOfStream;
    public XZHeader Header { get; private set; }
    public XZIndex Index { get; private set; }
    public XZFooter Footer { get; private set; }
    public bool HeaderIsRead { get; private set; }
    public XZStream(Stream stream);
    public static bool IsXZStream(Stream stream);
    private void AssertBlockCheckTypeIsSupported();
    [CompilerGeneratedAttribute]
public XZHeader get_Header();
    [CompilerGeneratedAttribute]
private void set_Header(XZHeader value);
    [CompilerGeneratedAttribute]
public XZIndex get_Index();
    [CompilerGeneratedAttribute]
private void set_Index(XZIndex value);
    [CompilerGeneratedAttribute]
public XZFooter get_Footer();
    [CompilerGeneratedAttribute]
private void set_Footer(XZFooter value);
    [CompilerGeneratedAttribute]
public bool get_HeaderIsRead();
    [CompilerGeneratedAttribute]
private void set_HeaderIsRead(bool value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    private void ReadHeader();
    private void ReadIndex();
    private void ReadFooter();
    private int ReadBlocks(Byte[] buffer, int offset, int count);
    private void NextBlock();
}
[CLSCompliantAttribute("False")]
public class SharpCompress.Crypto.Crc32Stream : Stream {
    public static UInt32 DefaultPolynomial;
    public static UInt32 DefaultSeed;
    private static UInt32[] defaultTable;
    private UInt32[] table;
    private UInt32 hash;
    private Stream stream;
    public Stream WrappedStream { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public UInt32 Crc { get; }
    public Crc32Stream(Stream stream);
    public Crc32Stream(Stream stream, UInt32 polynomial, UInt32 seed);
    public Stream get_WrappedStream();
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public UInt32 get_Crc();
    public static UInt32 Compute(Byte[] buffer);
    public static UInt32 Compute(UInt32 seed, Byte[] buffer);
    public static UInt32 Compute(UInt32 polynomial, UInt32 seed, ReadOnlySpan`1<byte> buffer);
    private static UInt32[] InitializeTable(UInt32 polynomial);
    private static UInt32 CalculateCrc(UInt32[] table, UInt32 crc, ReadOnlySpan`1<byte> buffer);
    private static UInt32 CalculateCrc(UInt32[] table, UInt32 crc, byte b);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Crypto.CryptoException : Exception {
    public CryptoException(string message);
    public CryptoException(string message, Exception exception);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Crypto.DataLengthException : CryptoException {
    public DataLengthException(string message);
    public DataLengthException(string message, Exception exception);
}
[NullableContextAttribute("1")]
public interface SharpCompress.Crypto.IBlockCipher {
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual int GetBlockSize();
    public abstract virtual bool get_IsPartialBlockOkay();
    [NullableContextAttribute("0")]
public abstract virtual int ProcessBlock(ReadOnlySpan`1<byte> inBuf, Span`1<byte> outBuf);
    public abstract virtual void Reset();
}
public interface SharpCompress.Crypto.ICipherParameters {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Crypto.KeyParameter : object {
    private Byte[] key;
    public KeyParameter(Byte[] key);
    public KeyParameter(Byte[] key, int keyOff, int keyLen);
    public Byte[] GetKey();
}
public class SharpCompress.Crypto.RijndaelEngine : object {
    private static int MAXROUNDS;
    private static int MAXKC;
    [NullableAttribute("1")]
private static Byte[][] shifts0;
    [NullableAttribute("1")]
private static Byte[][] shifts1;
    private int BC;
    private long BC_MASK;
    private int ROUNDS;
    private int blockBits;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Int64[][] workingKey;
    private long A0;
    private long A1;
    private long A2;
    private long A3;
    private bool forEncryption;
    [NullableAttribute("1")]
private Byte[] shifts0SC;
    [NullableAttribute("1")]
private Byte[] shifts1SC;
    private static ReadOnlySpan`1<byte> Logtable { get; }
    private static ReadOnlySpan`1<byte> Alogtable { get; }
    private static ReadOnlySpan`1<byte> S { get; }
    private static ReadOnlySpan`1<byte> Si { get; }
    private static ReadOnlySpan`1<byte> rcon { get; }
    [NullableAttribute("1")]
public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public RijndaelEngine(int blockBits);
    private static RijndaelEngine();
    private static ReadOnlySpan`1<byte> get_Logtable();
    private static ReadOnlySpan`1<byte> get_Alogtable();
    private static ReadOnlySpan`1<byte> get_S();
    private static ReadOnlySpan`1<byte> get_Si();
    private static ReadOnlySpan`1<byte> get_rcon();
    private byte Mul0x2(int b);
    private byte Mul0x3(int b);
    private byte Mul0x9(int b);
    private byte Mul0xb(int b);
    private byte Mul0xd(int b);
    private byte Mul0xe(int b);
    [NullableContextAttribute("1")]
private void KeyAddition(Int64[] rk);
    private long Shift(long r, int shift);
    [NullableContextAttribute("1")]
private void ShiftRow(Byte[] shiftsSC);
    private long ApplyS(long r, ReadOnlySpan`1<byte> box);
    private void Substitution(ReadOnlySpan`1<byte> box);
    private void MixColumn();
    private void InvMixColumn();
    [NullableContextAttribute("1")]
private Int64[][] GenerateWorkingKey(Byte[] key);
    [NullableContextAttribute("1")]
public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    [NullableContextAttribute("1")]
public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    public sealed virtual void Reset();
    private void UnPackBlock(ReadOnlySpan`1<byte> bytes);
    private void PackBlock(Span`1<byte> bytes);
    [NullableContextAttribute("1")]
private void EncryptBlock(Int64[][] rk);
    [NullableContextAttribute("1")]
private void DecryptBlock(Int64[][] rk);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class SharpCompress.Factories.Factory : object {
    private static HashSet`1<Factory> _factories;
    public static IEnumerable`1<IFactory> Factories { get; }
    public string Name { get; }
    public Nullable`1<ArchiveType> KnownArchiveType { get; }
    private static Factory();
    public static IEnumerable`1<IFactory> get_Factories();
    public static void RegisterFactory(Factory factory);
    public abstract virtual string get_Name();
    public virtual Nullable`1<ArchiveType> get_KnownArchiveType();
    public abstract virtual IEnumerable`1<string> GetSupportedExtensions();
    public abstract virtual bool IsArchive(Stream stream, string password);
    public virtual FileInfo GetFilePart(int index, FileInfo part1);
    internal virtual bool TryOpenReader(RewindableStream rewindableStream, ReaderOptions options, IReader& reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Factories.GZipFactory : Factory {
    public string Name { get; }
    public Nullable`1<ArchiveType> KnownArchiveType { get; }
    public virtual string get_Name();
    public virtual Nullable`1<ArchiveType> get_KnownArchiveType();
    [IteratorStateMachineAttribute("SharpCompress.Factories.GZipFactory/<GetSupportedExtensions>d__4")]
public virtual IEnumerable`1<string> GetSupportedExtensions();
    public virtual bool IsArchive(Stream stream, string password);
    public sealed virtual IArchive Open(Stream stream, ReaderOptions readerOptions);
    public sealed virtual IArchive Open(FileInfo fileInfo, ReaderOptions readerOptions);
    public sealed virtual IArchive Open(IReadOnlyList`1<Stream> streams, ReaderOptions readerOptions);
    public sealed virtual IArchive Open(IReadOnlyList`1<FileInfo> fileInfos, ReaderOptions readerOptions);
    internal virtual bool TryOpenReader(RewindableStream rewindableStream, ReaderOptions options, IReader& reader);
    public sealed virtual IReader OpenReader(Stream stream, ReaderOptions options);
    public sealed virtual IWriter Open(Stream stream, WriterOptions writerOptions);
    public sealed virtual IWritableArchive CreateWriteableArchive();
}
[NullableContextAttribute("1")]
public interface SharpCompress.Factories.IFactory {
    public string Name { get; }
    public Nullable`1<ArchiveType> KnownArchiveType { get; }
    public abstract virtual string get_Name();
    public abstract virtual Nullable`1<ArchiveType> get_KnownArchiveType();
    public abstract virtual IEnumerable`1<string> GetSupportedExtensions();
    public abstract virtual bool IsArchive(Stream stream, string password);
    public abstract virtual FileInfo GetFilePart(int index, FileInfo part1);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Factories.RarFactory : Factory {
    public string Name { get; }
    public Nullable`1<ArchiveType> KnownArchiveType { get; }
    public virtual string get_Name();
    public virtual Nullable`1<ArchiveType> get_KnownArchiveType();
    [IteratorStateMachineAttribute("SharpCompress.Factories.RarFactory/<GetSupportedExtensions>d__4")]
public virtual IEnumerable`1<string> GetSupportedExtensions();
    public virtual bool IsArchive(Stream stream, string password);
    public virtual FileInfo GetFilePart(int index, FileInfo part1);
    public sealed virtual IArchive Open(Stream stream, ReaderOptions readerOptions);
    public sealed virtual IArchive Open(FileInfo fileInfo, ReaderOptions readerOptions);
    public sealed virtual IArchive Open(IReadOnlyList`1<Stream> streams, ReaderOptions readerOptions);
    public sealed virtual IArchive Open(IReadOnlyList`1<FileInfo> fileInfos, ReaderOptions readerOptions);
    public sealed virtual IReader OpenReader(Stream stream, ReaderOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Factories.SevenZipFactory : Factory {
    public string Name { get; }
    public Nullable`1<ArchiveType> KnownArchiveType { get; }
    public virtual string get_Name();
    public virtual Nullable`1<ArchiveType> get_KnownArchiveType();
    [IteratorStateMachineAttribute("SharpCompress.Factories.SevenZipFactory/<GetSupportedExtensions>d__4")]
public virtual IEnumerable`1<string> GetSupportedExtensions();
    public virtual bool IsArchive(Stream stream, string password);
    public sealed virtual IArchive Open(Stream stream, ReaderOptions readerOptions);
    public sealed virtual IArchive Open(FileInfo fileInfo, ReaderOptions readerOptions);
    public sealed virtual IArchive Open(IReadOnlyList`1<Stream> streams, ReaderOptions readerOptions);
    public sealed virtual IArchive Open(IReadOnlyList`1<FileInfo> fileInfos, ReaderOptions readerOptions);
    internal virtual bool TryOpenReader(RewindableStream rewindableStream, ReaderOptions options, IReader& reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Factories.TarFactory : Factory {
    public string Name { get; }
    public Nullable`1<ArchiveType> KnownArchiveType { get; }
    public virtual string get_Name();
    public virtual Nullable`1<ArchiveType> get_KnownArchiveType();
    [IteratorStateMachineAttribute("SharpCompress.Factories.TarFactory/<GetSupportedExtensions>d__4")]
public virtual IEnumerable`1<string> GetSupportedExtensions();
    public virtual bool IsArchive(Stream stream, string password);
    public sealed virtual IArchive Open(Stream stream, ReaderOptions readerOptions);
    public sealed virtual IArchive Open(FileInfo fileInfo, ReaderOptions readerOptions);
    public sealed virtual IArchive Open(IReadOnlyList`1<Stream> streams, ReaderOptions readerOptions);
    public sealed virtual IArchive Open(IReadOnlyList`1<FileInfo> fileInfos, ReaderOptions readerOptions);
    internal virtual bool TryOpenReader(RewindableStream rewindableStream, ReaderOptions options, IReader& reader);
    public sealed virtual IReader OpenReader(Stream stream, ReaderOptions options);
    public sealed virtual IWriter Open(Stream stream, WriterOptions writerOptions);
    public sealed virtual IWritableArchive CreateWriteableArchive();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Factories.ZipFactory : Factory {
    public string Name { get; }
    public Nullable`1<ArchiveType> KnownArchiveType { get; }
    public virtual string get_Name();
    public virtual Nullable`1<ArchiveType> get_KnownArchiveType();
    [IteratorStateMachineAttribute("SharpCompress.Factories.ZipFactory/<GetSupportedExtensions>d__4")]
public virtual IEnumerable`1<string> GetSupportedExtensions();
    public virtual bool IsArchive(Stream stream, string password);
    public virtual FileInfo GetFilePart(int index, FileInfo part1);
    public sealed virtual IArchive Open(Stream stream, ReaderOptions readerOptions);
    public sealed virtual IArchive Open(FileInfo fileInfo, ReaderOptions readerOptions);
    public sealed virtual IArchive Open(IReadOnlyList`1<Stream> streams, ReaderOptions readerOptions);
    public sealed virtual IArchive Open(IReadOnlyList`1<FileInfo> fileInfos, ReaderOptions readerOptions);
    public sealed virtual IReader OpenReader(Stream stream, ReaderOptions options);
    public sealed virtual IWriter Open(Stream stream, WriterOptions writerOptions);
    public sealed virtual IWritableArchive CreateWriteableArchive();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.IO.BufferedSubStream : NonDisposingStream {
    private long position;
    private int cacheOffset;
    private int cacheLength;
    private Byte[] cache;
    [CompilerGeneratedAttribute]
private long <BytesLeftToRead>k__BackingField;
    private long BytesLeftToRead { get; private set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BufferedSubStream(Stream stream, long origin, long bytesToRead);
    [CompilerGeneratedAttribute]
private long get_BytesLeftToRead();
    [CompilerGeneratedAttribute]
private void set_BytesLeftToRead(long value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.IO.CountingWritableSubStream : NonDisposingStream {
    [CompilerGeneratedAttribute]
private ulong <Count>k__BackingField;
    public ulong Count { get; private set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal CountingWritableSubStream(Stream stream);
    [CompilerGeneratedAttribute]
public ulong get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(ulong value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.IO.DataDescriptorStream : Stream {
    private Stream _stream;
    private long _start;
    private int _search_position;
    private bool _isDisposed;
    private bool _done;
    private static Byte[] DataDescriptorMarker;
    private static long DataDescriptorSize;
    [CompilerGeneratedAttribute]
private bool <IsRecording>k__BackingField;
    internal bool IsRecording { get; private set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public DataDescriptorStream(Stream stream);
    private static DataDescriptorStream();
    [CompilerGeneratedAttribute]
internal bool get_IsRecording();
    [CompilerGeneratedAttribute]
private void set_IsRecording(bool value);
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    private bool validate_data_descriptor(Stream stream, long size);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.IO.ListeningStream : Stream {
    private long currentEntryTotalReadBytes;
    private IExtractionListener listener;
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    public Stream Stream { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ListeningStream(IExtractionListener listener, Stream stream);
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
public Stream get_Stream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.IO.MarkingBinaryReader : BinaryReader {
    [CompilerGeneratedAttribute]
private long <CurrentReadByteCount>k__BackingField;
    public long CurrentReadByteCount { get; protected set; }
    public MarkingBinaryReader(Stream stream);
    [CompilerGeneratedAttribute]
public virtual long get_CurrentReadByteCount();
    [CompilerGeneratedAttribute]
protected virtual void set_CurrentReadByteCount(long value);
    public virtual void Mark();
    public virtual int Read();
    public virtual int Read(Byte[] buffer, int index, int count);
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual bool ReadBoolean();
    public virtual byte ReadByte();
    public virtual Byte[] ReadBytes(int count);
    public virtual char ReadChar();
    public virtual Char[] ReadChars(int count);
    public virtual double ReadDouble();
    public virtual short ReadInt16();
    public virtual int ReadInt32();
    public virtual long ReadInt64();
    public virtual sbyte ReadSByte();
    public virtual float ReadSingle();
    public virtual string ReadString();
    public virtual ushort ReadUInt16();
    public virtual UInt32 ReadUInt32();
    public virtual ulong ReadUInt64();
    public ulong ReadRarVInt(int maxBytes);
    private ulong DoReadRarVInt(int maxShift);
    public UInt32 ReadRarVIntUInt32(int maxBytes);
    public ushort ReadRarVIntUInt16(int maxBytes);
    public byte ReadRarVIntByte(int maxBytes);
    private UInt32 DoReadRarVIntUInt32(int maxShift);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.IO.NonDisposingStream : Stream {
    [CompilerGeneratedAttribute]
private bool <ThrowOnDispose>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    public bool ThrowOnDispose { get; public set; }
    protected Stream Stream { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    protected NonDisposingStream(Stream stream, bool throwOnDispose);
    public static NonDisposingStream Create(Stream stream, bool throwOnDispose);
    [CompilerGeneratedAttribute]
public bool get_ThrowOnDispose();
    [CompilerGeneratedAttribute]
public void set_ThrowOnDispose(bool value);
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
protected Stream get_Stream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.IO.ReadOnlySubStream : NonDisposingStream {
    private long _position;
    [CompilerGeneratedAttribute]
private long <BytesLeftToRead>k__BackingField;
    private long BytesLeftToRead { get; private set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ReadOnlySubStream(Stream stream, long bytesToRead);
    public ReadOnlySubStream(Stream stream, Nullable`1<long> origin, long bytesToRead);
    [CompilerGeneratedAttribute]
private long get_BytesLeftToRead();
    [CompilerGeneratedAttribute]
private void set_BytesLeftToRead(long value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.IO.RewindableStream : Stream {
    private Stream stream;
    private MemoryStream bufferStream;
    private bool isRewound;
    private bool isDisposed;
    [CompilerGeneratedAttribute]
private bool <IsRecording>k__BackingField;
    internal bool IsRecording { get; private set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public RewindableStream(Stream stream);
    [CompilerGeneratedAttribute]
internal bool get_IsRecording();
    [CompilerGeneratedAttribute]
private void set_IsRecording(bool value);
    protected virtual void Dispose(bool disposing);
    public void Rewind(bool stopRecording);
    public void Rewind(MemoryStream buffer);
    public void StartRecording();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.IO.SourceStream : Stream {
    private long _prevSize;
    private List`1<FileInfo> _files;
    private List`1<Stream> _streams;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<int, FileInfo> _getFilePart;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<int, Stream> _getStreamPart;
    private int _stream;
    [CompilerGeneratedAttribute]
private bool <IsVolumes>k__BackingField;
    [CompilerGeneratedAttribute]
private ReaderOptions <ReaderOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFileMode>k__BackingField;
    public bool IsVolumes { get; public set; }
    public ReaderOptions ReaderOptions { get; }
    public bool IsFileMode { get; }
    public IEnumerable`1<FileInfo> Files { get; }
    public IEnumerable`1<Stream> Streams { get; }
    private Stream Current { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public SourceStream(FileInfo file, Func`2<int, FileInfo> getPart, ReaderOptions options);
    public SourceStream(Stream stream, Func`2<int, Stream> getPart, ReaderOptions options);
    [NullableContextAttribute("2")]
private SourceStream(Stream stream, Func`2<int, Stream> getStreamPart, FileInfo file, Func`2<int, FileInfo> getFilePart, ReaderOptions options);
    public void LoadAllParts();
    [CompilerGeneratedAttribute]
public bool get_IsVolumes();
    [CompilerGeneratedAttribute]
public void set_IsVolumes(bool value);
    [CompilerGeneratedAttribute]
public ReaderOptions get_ReaderOptions();
    [CompilerGeneratedAttribute]
public bool get_IsFileMode();
    public IEnumerable`1<FileInfo> get_Files();
    public IEnumerable`1<Stream> get_Streams();
    private Stream get_Current();
    public bool LoadStream(int index);
    public bool SetStream(int idx);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
}
public enum SharpCompress.IO.StreamingMode : Enum {
    public int value__;
    public static StreamingMode Streaming;
    public static StreamingMode Seekable;
}
public class SharpCompress.Lazy`1 : object {
    private Func`1<T> _lazyFunc;
    private bool _evaluated;
    private T _value;
    public T Value { get; }
    public Lazy`1(Func`1<T> lazyFunc);
    public T get_Value();
}
internal class SharpCompress.LazyReadOnlyCollection`1 : object {
    private List`1<T> backing;
    private IEnumerator`1<T> source;
    private bool fullyLoaded;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public LazyReadOnlyCollection`1(IEnumerable`1<T> source);
    internal void EnsureFullyLoaded();
    internal IEnumerable`1<T> GetLoaded();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class SharpCompress.Readers.AbstractReader`2 : object {
    private bool completed;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumerator`1<TEntry> entriesForCurrentReadStream;
    private bool wroteCurrentEntry;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ReaderExtractionEventArgs`1<IEntry>> EntryExtractionProgress;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<CompressedBytesReadEventArgs> CompressedBytesRead;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<FilePartExtractionBeginEventArgs> FilePartExtractionBegin;
    [CompilerGeneratedAttribute]
private ReaderOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private ArchiveType <ArchiveType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Cancelled>k__BackingField;
    internal ReaderOptions Options { get; }
    public ArchiveType ArchiveType { get; }
    public TVolume Volume { get; }
    public TEntry Entry { get; }
    public bool Cancelled { get; private set; }
    private IEntry SharpCompress.Readers.IReader.Entry { get; }
    internal AbstractReader`2(ReaderOptions options, ArchiveType archiveType);
    [CompilerGeneratedAttribute]
public sealed virtual void add_EntryExtractionProgress(EventHandler`1<ReaderExtractionEventArgs`1<IEntry>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_EntryExtractionProgress(EventHandler`1<ReaderExtractionEventArgs`1<IEntry>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CompressedBytesRead(EventHandler`1<CompressedBytesReadEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CompressedBytesRead(EventHandler`1<CompressedBytesReadEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_FilePartExtractionBegin(EventHandler`1<FilePartExtractionBeginEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_FilePartExtractionBegin(EventHandler`1<FilePartExtractionBeginEventArgs> value);
    [CompilerGeneratedAttribute]
internal ReaderOptions get_Options();
    [CompilerGeneratedAttribute]
public sealed virtual ArchiveType get_ArchiveType();
    public abstract virtual TVolume get_Volume();
    public TEntry get_Entry();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Cancelled();
    [CompilerGeneratedAttribute]
private void set_Cancelled(bool value);
    public sealed virtual void Cancel();
    public sealed virtual bool MoveToNextEntry();
    protected bool LoadStreamForReading(Stream stream);
    protected virtual Stream RequestInitialStream();
    internal virtual bool NextEntryForCurrentStream();
    protected abstract virtual IEnumerable`1<TEntry> GetEntries(Stream stream);
    private void SkipEntry();
    private void Skip();
    public sealed virtual void WriteEntryTo(Stream writableStream);
    internal void Write(Stream writeStream);
    public sealed virtual EntryStream OpenEntryStream();
    protected EntryStream CreateEntryStream(Stream decompressed);
    protected virtual EntryStream GetEntryStream();
    private sealed virtual override IEntry SharpCompress.Readers.IReader.get_Entry();
    private sealed virtual override void SharpCompress.Common.IExtractionListener.FireCompressedBytesRead(long currentPartCompressedBytes, long compressedReadBytes);
    private sealed virtual override void SharpCompress.Common.IExtractionListener.FireFilePartExtractionBegin(string name, long size, long compressedSize);
    private sealed virtual override void SharpCompress.Readers.IReaderExtractionListener.FireEntryExtractionProgress(Entry entry, long bytesTransferred, int iterations);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class SharpCompress.Readers.GZip.GZipReader : AbstractReader`2<GZipEntry, GZipVolume> {
    [CompilerGeneratedAttribute]
private GZipVolume <Volume>k__BackingField;
    public GZipVolume Volume { get; }
    internal GZipReader(Stream stream, ReaderOptions options);
    [CompilerGeneratedAttribute]
public virtual GZipVolume get_Volume();
    public static GZipReader Open(Stream stream, ReaderOptions options);
    protected virtual IEnumerable`1<GZipEntry> GetEntries(Stream stream);
}
[NullableContextAttribute("1")]
public interface SharpCompress.Readers.IReader {
    public ArchiveType ArchiveType { get; }
    public IEntry Entry { get; }
    public bool Cancelled { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_EntryExtractionProgress(EventHandler`1<ReaderExtractionEventArgs`1<IEntry>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_EntryExtractionProgress(EventHandler`1<ReaderExtractionEventArgs`1<IEntry>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CompressedBytesRead(EventHandler`1<CompressedBytesReadEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CompressedBytesRead(EventHandler`1<CompressedBytesReadEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_FilePartExtractionBegin(EventHandler`1<FilePartExtractionBeginEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_FilePartExtractionBegin(EventHandler`1<FilePartExtractionBeginEventArgs> value);
    public abstract virtual ArchiveType get_ArchiveType();
    public abstract virtual IEntry get_Entry();
    public abstract virtual void WriteEntryTo(Stream writableStream);
    public abstract virtual bool get_Cancelled();
    public abstract virtual void Cancel();
    public abstract virtual bool MoveToNextEntry();
    public abstract virtual EntryStream OpenEntryStream();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SharpCompress.Readers.IReaderExtensions : object {
    [ExtensionAttribute]
public static void WriteEntryTo(IReader reader, string filePath);
    [ExtensionAttribute]
public static void WriteEntryTo(IReader reader, FileInfo filePath);
    [ExtensionAttribute]
public static void WriteAllToDirectory(IReader reader, string destinationDirectory, ExtractionOptions options);
    [ExtensionAttribute]
public static void WriteEntryToDirectory(IReader reader, string destinationDirectory, ExtractionOptions options);
    [ExtensionAttribute]
public static void WriteEntryToFile(IReader reader, string destinationFileName, ExtractionOptions options);
}
public interface SharpCompress.Readers.IReaderExtractionListener {
    [NullableContextAttribute("1")]
public abstract virtual void FireEntryExtractionProgress(Entry entry, long sizeTransferred, int iterations);
}
public interface SharpCompress.Readers.IReaderFactory {
    [NullableContextAttribute("1")]
public abstract virtual IReader OpenReader(Stream stream, ReaderOptions options);
}
internal class SharpCompress.Readers.Rar.MultiVolumeRarReader : RarReader {
    private IEnumerator`1<Stream> streams;
    private Stream tempStream;
    internal MultiVolumeRarReader(IEnumerable`1<Stream> streams, ReaderOptions options);
    internal virtual void ValidateArchive(RarVolume archive);
    protected virtual Stream RequestInitialStream();
    internal virtual bool NextEntryForCurrentStream();
    protected virtual IEnumerable`1<FilePart> CreateFilePartEnumerableForCurrentEntry();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Readers.Rar.NonSeekableStreamFilePart : RarFilePart {
    internal string FilePartName { get; }
    internal NonSeekableStreamFilePart(MarkHeader mh, FileHeader fh, int index);
    internal virtual Stream GetCompressedStream();
    [NullableContextAttribute("2")]
internal virtual Stream GetRawStream();
    internal virtual string get_FilePartName();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class SharpCompress.Readers.Rar.RarReader : AbstractReader`2<RarReaderEntry, RarVolume> {
    [NullableAttribute("2")]
private RarVolume volume;
    [CompilerGeneratedAttribute]
private Lazy`1<IRarUnpack> <UnpackV2017>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<IRarUnpack> <UnpackV1>k__BackingField;
    internal Lazy`1<IRarUnpack> UnpackV2017 { get; }
    internal Lazy`1<IRarUnpack> UnpackV1 { get; }
    public RarVolume Volume { get; }
    internal RarReader(ReaderOptions options);
    [CompilerGeneratedAttribute]
internal Lazy`1<IRarUnpack> get_UnpackV2017();
    [CompilerGeneratedAttribute]
internal Lazy`1<IRarUnpack> get_UnpackV1();
    internal abstract virtual void ValidateArchive(RarVolume archive);
    public virtual RarVolume get_Volume();
    public static RarReader Open(Stream stream, ReaderOptions options);
    public static RarReader Open(IEnumerable`1<Stream> streams, ReaderOptions options);
    [IteratorStateMachineAttribute("SharpCompress.Readers.Rar.RarReader/<GetEntries>d__13")]
protected virtual IEnumerable`1<RarReaderEntry> GetEntries(Stream stream);
    protected virtual IEnumerable`1<FilePart> CreateFilePartEnumerableForCurrentEntry();
    protected virtual EntryStream GetEntryStream();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Readers.Rar.RarReaderEntry : RarEntry {
    [CompilerGeneratedAttribute]
private RarFilePart <Part>k__BackingField;
    internal RarFilePart Part { get; }
    internal IEnumerable`1<FilePart> Parts { get; }
    internal FileHeader FileHeader { get; }
    public CompressionType CompressionType { get; }
    public long CompressedSize { get; }
    public long Size { get; }
    internal RarReaderEntry(bool solid, RarFilePart part);
    [CompilerGeneratedAttribute]
internal RarFilePart get_Part();
    internal virtual IEnumerable`1<FilePart> get_Parts();
    internal virtual FileHeader get_FileHeader();
    public virtual CompressionType get_CompressionType();
    public virtual long get_CompressedSize();
    public virtual long get_Size();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Readers.Rar.RarReaderVolume : RarVolume {
    internal RarReaderVolume(Stream stream, ReaderOptions options, int index);
    internal virtual RarFilePart CreateFilePart(MarkHeader markHeader, FileHeader fileHeader);
    internal virtual IEnumerable`1<RarFilePart> ReadFileParts();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Readers.Rar.SingleVolumeRarReader : RarReader {
    private Stream stream;
    internal SingleVolumeRarReader(Stream stream, ReaderOptions options);
    internal virtual void ValidateArchive(RarVolume archive);
    protected virtual Stream RequestInitialStream();
}
public static class SharpCompress.Readers.ReaderFactory : object {
    [NullableContextAttribute("1")]
public static IReader Open(Stream stream, ReaderOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class SharpCompress.Readers.ReaderOptions : OptionsBase {
    [CompilerGeneratedAttribute]
private bool <LookForHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableCheckIncomplete>k__BackingField;
    public bool LookForHeader { get; public set; }
    public string Password { get; public set; }
    public bool DisableCheckIncomplete { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_LookForHeader();
    [CompilerGeneratedAttribute]
public void set_LookForHeader(bool value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public bool get_DisableCheckIncomplete();
    [CompilerGeneratedAttribute]
public void set_DisableCheckIncomplete(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Readers.ReaderProgress : object {
    private IEntry _entry;
    [CompilerGeneratedAttribute]
private long <BytesTransferred>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Iterations>k__BackingField;
    public long BytesTransferred { get; }
    public int Iterations { get; }
    public int PercentageRead { get; }
    public double PercentageReadExact { get; }
    public ReaderProgress(IEntry entry, long bytesTransferred, int iterations);
    [CompilerGeneratedAttribute]
public long get_BytesTransferred();
    [CompilerGeneratedAttribute]
public int get_Iterations();
    public int get_PercentageRead();
    public double get_PercentageReadExact();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class SharpCompress.Readers.Tar.TarReader : AbstractReader`2<TarEntry, TarVolume> {
    private CompressionType compressionType;
    [CompilerGeneratedAttribute]
private TarVolume <Volume>k__BackingField;
    public TarVolume Volume { get; }
    internal TarReader(Stream stream, ReaderOptions options, CompressionType compressionType);
    [CompilerGeneratedAttribute]
public virtual TarVolume get_Volume();
    protected virtual Stream RequestInitialStream();
    public static TarReader Open(Stream stream, ReaderOptions options);
    protected virtual IEnumerable`1<TarEntry> GetEntries(Stream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class SharpCompress.Readers.Zip.ZipReader : AbstractReader`2<ZipEntry, ZipVolume> {
    private StreamingZipHeaderFactory _headerFactory;
    [CompilerGeneratedAttribute]
private ZipVolume <Volume>k__BackingField;
    public ZipVolume Volume { get; }
    private ZipReader(Stream stream, ReaderOptions options);
    private ZipReader(Stream stream, ReaderOptions options, IEnumerable`1<ZipEntry> entries);
    [CompilerGeneratedAttribute]
public virtual ZipVolume get_Volume();
    public static ZipReader Open(Stream stream, ReaderOptions options);
    public static ZipReader Open(Stream stream, ReaderOptions options, IEnumerable`1<ZipEntry> entries);
    [IteratorStateMachineAttribute("SharpCompress.Readers.Zip.ZipReader/<GetEntries>d__8")]
protected virtual IEnumerable`1<ZipEntry> GetEntries(Stream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.ReadOnlyCollection`1 : object {
    private ICollection`1<T> collection;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ReadOnlyCollection`1(ICollection`1<T> collection);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
internal static class SharpCompress.StreamExtensions : object {
    [ExtensionAttribute]
internal static int Read(Stream stream, Span`1<byte> buffer);
    [ExtensionAttribute]
internal static void Write(Stream stream, ReadOnlySpan`1<byte> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class SharpCompress.StringExtensions : object {
    [ExtensionAttribute]
internal static bool EndsWith(string text, char value);
    [ExtensionAttribute]
internal static bool Contains(string text, char value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static class SharpCompress.Utility : object {
    [ExtensionAttribute]
public static ReadOnlyCollection`1<T> ToReadOnly(ICollection`1<T> items);
    public static int URShift(int number, int bits);
    public static long URShift(long number, int bits);
    [ExtensionAttribute]
public static void SetSize(List`1<byte> list, int count);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> items, Action`1<T> action);
    public static void Copy(Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);
    [IteratorStateMachineAttribute("SharpCompress.Utility/<AsEnumerable>d__6`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> AsEnumerable(T item);
    [ExtensionAttribute]
public static void CheckNotNull(object obj, string name);
    [ExtensionAttribute]
public static void CheckNotNullOrEmpty(string obj, string name);
    [ExtensionAttribute]
public static void Skip(Stream source, long advanceAmount);
    [ExtensionAttribute]
public static void Skip(Stream source);
    [ExtensionAttribute]
public static bool Find(Stream source, Byte[] array);
    public static DateTime DosDateToDateTime(ushort iDate, ushort iTime);
    [ExtensionAttribute]
public static UInt32 DateTimeToDosTime(Nullable`1<DateTime> dateTime);
    public static DateTime DosDateToDateTime(UInt32 iTime);
    public static DateTime UnixTimeToDateTime(long unixtime);
    [ExtensionAttribute]
public static long TransferTo(Stream source, Stream destination);
    [ExtensionAttribute]
public static long TransferTo(Stream source, Stream destination, Entry entry, IReaderExtractionListener readerExtractionListener);
    private static bool ReadTransferBlock(Stream source, Byte[] array, Int32& count);
    private static Byte[] GetTransferByteArray();
    [ExtensionAttribute]
public static bool ReadFully(Stream stream, Byte[] buffer);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool ReadFully(Stream stream, Span`1<byte> buffer);
    [ExtensionAttribute]
public static string TrimNulls(string source);
    public static UInt32 SwapUINT32(UInt32 number);
    public static void SetLittleUInt32(Byte[]& buffer, UInt32 number, long offset);
    public static void SetBigUInt32(Byte[]& buffer, UInt32 number, long offset);
}
public abstract class SharpCompress.Writers.AbstractWriter : object {
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private Stream <OutputStream>k__BackingField;
    [CompilerGeneratedAttribute]
private ArchiveType <WriterType>k__BackingField;
    [CompilerGeneratedAttribute]
private WriterOptions <WriterOptions>k__BackingField;
    protected Stream OutputStream { get; private set; }
    public ArchiveType WriterType { get; }
    protected WriterOptions WriterOptions { get; }
    protected AbstractWriter(ArchiveType type, WriterOptions writerOptions);
    protected void InitalizeStream(Stream stream);
    [CompilerGeneratedAttribute]
protected Stream get_OutputStream();
    [CompilerGeneratedAttribute]
private void set_OutputStream(Stream value);
    [CompilerGeneratedAttribute]
public sealed virtual ArchiveType get_WriterType();
    [CompilerGeneratedAttribute]
protected WriterOptions get_WriterOptions();
    public abstract virtual void Write(string filename, Stream source, Nullable`1<DateTime> modificationTime);
    protected virtual void Dispose(bool isDisposing);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Writers.GZip.GZipWriter : AbstractWriter {
    private bool _wroteToStream;
    public GZipWriter(Stream destination, GZipWriterOptions options);
    protected virtual void Dispose(bool isDisposing);
    public virtual void Write(string filename, Stream source, Nullable`1<DateTime> modificationTime);
}
public class SharpCompress.Writers.GZip.GZipWriterOptions : WriterOptions {
    [CompilerGeneratedAttribute]
private CompressionLevel <CompressionLevel>k__BackingField;
    public CompressionLevel CompressionLevel { get; public set; }
    [NullableContextAttribute("1")]
internal GZipWriterOptions(WriterOptions options);
    [CompilerGeneratedAttribute]
public CompressionLevel get_CompressionLevel();
    [CompilerGeneratedAttribute]
public void set_CompressionLevel(CompressionLevel value);
}
public interface SharpCompress.Writers.IWriter {
    public ArchiveType WriterType { get; }
    public abstract virtual ArchiveType get_WriterType();
    [NullableContextAttribute("1")]
public abstract virtual void Write(string filename, Stream source, Nullable`1<DateTime> modificationTime);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SharpCompress.Writers.IWriterExtensions : object {
    [ExtensionAttribute]
public static void Write(IWriter writer, string entryPath, Stream source);
    [ExtensionAttribute]
public static void Write(IWriter writer, string entryPath, FileInfo source);
    [ExtensionAttribute]
public static void Write(IWriter writer, string entryPath, string source);
    [ExtensionAttribute]
public static void WriteAll(IWriter writer, string directory, string searchPattern, SearchOption option);
    [ExtensionAttribute]
public static void WriteAll(IWriter writer, string directory, string searchPattern, Func`2<string, bool> fileSearchFunc, SearchOption option);
}
public interface SharpCompress.Writers.IWriterFactory {
    [NullableContextAttribute("1")]
public abstract virtual IWriter Open(Stream stream, WriterOptions writerOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Writers.Tar.TarWriter : AbstractWriter {
    private bool finalizeArchiveOnClose;
    public TarWriter(Stream destination, TarWriterOptions options);
    public virtual void Write(string filename, Stream source, Nullable`1<DateTime> modificationTime);
    private string NormalizeFilename(string filename);
    public void Write(string filename, Stream source, Nullable`1<DateTime> modificationTime, Nullable`1<long> size);
    private void PadTo512(long size);
    protected virtual void Dispose(bool isDisposing);
}
public class SharpCompress.Writers.Tar.TarWriterOptions : WriterOptions {
    [CompilerGeneratedAttribute]
private bool <FinalizeArchiveOnClose>k__BackingField;
    public bool FinalizeArchiveOnClose { get; }
    public TarWriterOptions(CompressionType compressionType, bool finalizeArchiveOnClose);
    [NullableContextAttribute("1")]
internal TarWriterOptions(WriterOptions options);
    [CompilerGeneratedAttribute]
public bool get_FinalizeArchiveOnClose();
}
public static class SharpCompress.Writers.WriterFactory : object {
    [NullableContextAttribute("1")]
public static IWriter Open(Stream stream, ArchiveType archiveType, WriterOptions writerOptions);
}
public class SharpCompress.Writers.WriterOptions : OptionsBase {
    [CompilerGeneratedAttribute]
private CompressionType <CompressionType>k__BackingField;
    public CompressionType CompressionType { get; public set; }
    public WriterOptions(CompressionType compressionType);
    [CompilerGeneratedAttribute]
public CompressionType get_CompressionType();
    [CompilerGeneratedAttribute]
public void set_CompressionType(CompressionType value);
    [NullableContextAttribute("1")]
public static WriterOptions op_Implicit(CompressionType compressionType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SharpCompress.Writers.Zip.ZipCentralDirectoryEntry : object {
    private ZipCompressionMethod compression;
    private string fileName;
    private ArchiveEncoding archiveEncoding;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ModificationTime>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Crc>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Compressed>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Decompressed>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Zip64HeaderOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <HeaderOffset>k__BackingField;
    internal Nullable`1<DateTime> ModificationTime { get; internal set; }
    [NullableAttribute("2")]
internal string Comment { get; internal set; }
    internal UInt32 Crc { get; internal set; }
    internal ulong Compressed { get; internal set; }
    internal ulong Decompressed { get; internal set; }
    internal ushort Zip64HeaderOffset { get; internal set; }
    internal ulong HeaderOffset { get; }
    public ZipCentralDirectoryEntry(ZipCompressionMethod compression, string fileName, ulong headerOffset, ArchiveEncoding archiveEncoding);
    [CompilerGeneratedAttribute]
internal Nullable`1<DateTime> get_ModificationTime();
    [CompilerGeneratedAttribute]
internal void set_ModificationTime(Nullable`1<DateTime> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal string get_Comment();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_Comment(string value);
    [CompilerGeneratedAttribute]
internal UInt32 get_Crc();
    [CompilerGeneratedAttribute]
internal void set_Crc(UInt32 value);
    [CompilerGeneratedAttribute]
internal ulong get_Compressed();
    [CompilerGeneratedAttribute]
internal void set_Compressed(ulong value);
    [CompilerGeneratedAttribute]
internal ulong get_Decompressed();
    [CompilerGeneratedAttribute]
internal void set_Decompressed(ulong value);
    [CompilerGeneratedAttribute]
internal ushort get_Zip64HeaderOffset();
    [CompilerGeneratedAttribute]
internal void set_Zip64HeaderOffset(ushort value);
    [CompilerGeneratedAttribute]
internal ulong get_HeaderOffset();
    internal UInt32 Write(Stream outputStream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SharpCompress.Writers.Zip.ZipWriter : AbstractWriter {
    private CompressionType compressionType;
    private CompressionLevel compressionLevel;
    private List`1<ZipCentralDirectoryEntry> entries;
    private string zipComment;
    private long streamPosition;
    [NullableAttribute("2")]
private PpmdProperties ppmdProps;
    private bool isZip64;
    private PpmdProperties PpmdProperties { get; }
    public ZipWriter(Stream destination, ZipWriterOptions zipWriterOptions);
    private PpmdProperties get_PpmdProperties();
    protected virtual void Dispose(bool isDisposing);
    private static ZipCompressionMethod ToZipCompressionMethod(CompressionType compressionType);
    public virtual void Write(string entryPath, Stream source, Nullable`1<DateTime> modificationTime);
    public void Write(string entryPath, Stream source, ZipWriterEntryOptions zipWriterEntryOptions);
    public Stream WriteToStream(string entryPath, ZipWriterEntryOptions options);
    private string NormalizeFilename(string filename);
    private int WriteHeader(string filename, ZipWriterEntryOptions zipWriterEntryOptions, ZipCentralDirectoryEntry entry, bool useZip64);
    private void WriteFooter(UInt32 crc, UInt32 compressed, UInt32 uncompressed);
    private void WriteEndRecord(ulong size);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class SharpCompress.Writers.Zip.ZipWriterEntryOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<CompressionType> <CompressionType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<CompressionLevel> <DeflateCompressionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EntryComment>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ModificationDateTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EnableZip64>k__BackingField;
    public Nullable`1<CompressionType> CompressionType { get; public set; }
    public Nullable`1<CompressionLevel> DeflateCompressionLevel { get; public set; }
    public string EntryComment { get; public set; }
    public Nullable`1<DateTime> ModificationDateTime { get; public set; }
    public Nullable`1<bool> EnableZip64 { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<CompressionType> get_CompressionType();
    [CompilerGeneratedAttribute]
public void set_CompressionType(Nullable`1<CompressionType> value);
    [CompilerGeneratedAttribute]
public Nullable`1<CompressionLevel> get_DeflateCompressionLevel();
    [CompilerGeneratedAttribute]
public void set_DeflateCompressionLevel(Nullable`1<CompressionLevel> value);
    [CompilerGeneratedAttribute]
public string get_EntryComment();
    [CompilerGeneratedAttribute]
public void set_EntryComment(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ModificationDateTime();
    [CompilerGeneratedAttribute]
public void set_ModificationDateTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EnableZip64();
    [CompilerGeneratedAttribute]
public void set_EnableZip64(Nullable`1<bool> value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class SharpCompress.Writers.Zip.ZipWriterOptions : WriterOptions {
    [CompilerGeneratedAttribute]
private CompressionLevel <DeflateCompressionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ArchiveComment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseZip64>k__BackingField;
    public CompressionLevel DeflateCompressionLevel { get; public set; }
    public string ArchiveComment { get; public set; }
    public bool UseZip64 { get; public set; }
    public ZipWriterOptions(CompressionType compressionType);
    [NullableContextAttribute("1")]
internal ZipWriterOptions(WriterOptions options);
    [CompilerGeneratedAttribute]
public CompressionLevel get_DeflateCompressionLevel();
    [CompilerGeneratedAttribute]
public void set_DeflateCompressionLevel(CompressionLevel value);
    [CompilerGeneratedAttribute]
public string get_ArchiveComment();
    [CompilerGeneratedAttribute]
public void set_ArchiveComment(string value);
    [CompilerGeneratedAttribute]
public bool get_UseZip64();
    [CompilerGeneratedAttribute]
public void set_UseZip64(bool value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
