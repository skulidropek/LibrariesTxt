internal static class BuildInfo : object {
    public static string VersionString;
    public static string Commit;
    public static string Maturity;
    public static string Build;
    public static DateTime BuildDate { get; }
    public static DateTime get_BuildDate();
}
internal class EnumerableAsync`1 : object {
    private SearchFilter _filter;
    private ILogger _logger;
    private string _searchTerm;
    private int _skip;
    private int _take;
    private CancellationToken _token;
    private IV2FeedParser _feedParser;
    private bool _isSearchAvailable;
    private bool _allVersions;
    public EnumerableAsync`1(IV2FeedParser feedParser, string searchTerm, SearchFilter filter, int skip, int take, bool isSearchAvailable, bool allVersions, ILogger logger, CancellationToken token);
    public sealed virtual IEnumeratorAsync`1<T> GetEnumeratorAsync();
}
internal class EnumeratorAsync : object {
    private SearchFilter _filter;
    private ILogger _logger;
    private string _searchTerm;
    private int _skip;
    private int _take;
    private CancellationToken _token;
    private IV2FeedParser _feedParser;
    private bool _isSearchAvailable;
    private bool _allVersions;
    private IEnumerator`1<IPackageSearchMetadata> _currentEnumerator;
    private V2FeedPage _currentPage;
    public IPackageSearchMetadata Current { get; }
    public EnumeratorAsync(IV2FeedParser feedParser, string searchTerm, SearchFilter filter, int skip, int take, bool isSearchAvailable, bool allVersions, ILogger logger, CancellationToken token);
    public sealed virtual IPackageSearchMetadata get_Current();
    [AsyncStateMachineAttribute("EnumeratorAsync/<MoveNextAsync>d__14")]
public sealed virtual Task`1<bool> MoveNextAsync();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class Newtonsoft.Json.Bson.BsonArray : BsonToken {
    private List`1<BsonToken> _children;
    public BsonType Type { get; }
    public void Add(BsonToken token);
    public virtual BsonType get_Type();
    public sealed virtual IEnumerator`1<BsonToken> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Newtonsoft.Json.Bson.BsonBinary : BsonValue {
    [CompilerGeneratedAttribute]
private BsonBinaryType <BinaryType>k__BackingField;
    public BsonBinaryType BinaryType { get; public set; }
    public BsonBinary(Byte[] value, BsonBinaryType binaryType);
    [CompilerGeneratedAttribute]
public BsonBinaryType get_BinaryType();
    [CompilerGeneratedAttribute]
public void set_BinaryType(BsonBinaryType value);
}
internal enum Newtonsoft.Json.Bson.BsonBinaryType : Enum {
    public byte value__;
    public static BsonBinaryType Binary;
    public static BsonBinaryType Function;
    [ObsoleteAttribute("This type has been deprecated in the BSON specification. Use Binary instead.")]
public static BsonBinaryType BinaryOld;
    [ObsoleteAttribute("This type has been deprecated in the BSON specification. Use Uuid instead.")]
public static BsonBinaryType UuidOld;
    public static BsonBinaryType Uuid;
    public static BsonBinaryType Md5;
    public static BsonBinaryType UserDefined;
}
internal class Newtonsoft.Json.Bson.BsonBinaryWriter : object {
    private static Encoding Encoding;
    private BinaryWriter _writer;
    private Byte[] _largeByteBuffer;
    [CompilerGeneratedAttribute]
private DateTimeKind <DateTimeKindHandling>k__BackingField;
    public DateTimeKind DateTimeKindHandling { get; public set; }
    public BsonBinaryWriter(BinaryWriter writer);
    private static BsonBinaryWriter();
    [CompilerGeneratedAttribute]
public DateTimeKind get_DateTimeKindHandling();
    [CompilerGeneratedAttribute]
public void set_DateTimeKindHandling(DateTimeKind value);
    public void Flush();
    public void Close();
    public void WriteToken(BsonToken t);
    private void WriteTokenInternal(BsonToken t);
    private void WriteString(string s, int byteCount, Nullable`1<int> calculatedlengthPrefix);
    public void WriteUtf8Bytes(string s, int byteCount);
    private int CalculateSize(int stringByteCount);
    private int CalculateSizeWithLength(int stringByteCount, bool includeSize);
    private int CalculateSize(BsonToken t);
}
internal class Newtonsoft.Json.Bson.BsonBoolean : BsonValue {
    public static BsonBoolean False;
    public static BsonBoolean True;
    private BsonBoolean(bool value);
    private static BsonBoolean();
}
internal class Newtonsoft.Json.Bson.BsonEmpty : BsonToken {
    public static BsonToken Null;
    public static BsonToken Undefined;
    [CompilerGeneratedAttribute]
private BsonType <Type>k__BackingField;
    public BsonType Type { get; }
    private BsonEmpty(BsonType type);
    private static BsonEmpty();
    [CompilerGeneratedAttribute]
public virtual BsonType get_Type();
}
internal class Newtonsoft.Json.Bson.BsonObject : BsonToken {
    private List`1<BsonProperty> _children;
    public BsonType Type { get; }
    public void Add(string name, BsonToken token);
    public virtual BsonType get_Type();
    public sealed virtual IEnumerator`1<BsonProperty> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ObsoleteAttribute("BSON reading and writing has been moved to its own package. See https://www.nuget.org/packages/Newtonsoft.Json.Bson for more details.")]
public class Newtonsoft.Json.Bson.BsonObjectId : object {
    [CompilerGeneratedAttribute]
private Byte[] <Value>k__BackingField;
    public Byte[] Value { get; }
    public BsonObjectId(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_Value();
}
internal class Newtonsoft.Json.Bson.BsonProperty : object {
    [CompilerGeneratedAttribute]
private BsonString <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonToken <Value>k__BackingField;
    public BsonString Name { get; public set; }
    public BsonToken Value { get; public set; }
    [CompilerGeneratedAttribute]
public BsonString get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(BsonString value);
    [CompilerGeneratedAttribute]
public BsonToken get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(BsonToken value);
}
[ObsoleteAttribute("BSON reading and writing has been moved to its own package. See https://www.nuget.org/packages/Newtonsoft.Json.Bson for more details.")]
public class Newtonsoft.Json.Bson.BsonReader : JsonReader {
    private static int MaxCharBytesSize;
    private static Byte[] SeqRange1;
    private static Byte[] SeqRange2;
    private static Byte[] SeqRange3;
    private static Byte[] SeqRange4;
    private BinaryReader _reader;
    private List`1<ContainerContext> _stack;
    private Byte[] _byteBuffer;
    private Char[] _charBuffer;
    private BsonType _currentElementType;
    private BsonReaderState _bsonReaderState;
    private ContainerContext _currentContext;
    private bool _readRootValueAsArray;
    private bool _jsonNet35BinaryCompatibility;
    private DateTimeKind _dateTimeKindHandling;
    [ObsoleteAttribute("JsonNet35BinaryCompatibility will be removed in a future version of Json.NET.")]
public bool JsonNet35BinaryCompatibility { get; public set; }
    public bool ReadRootValueAsArray { get; public set; }
    public DateTimeKind DateTimeKindHandling { get; public set; }
    public BsonReader(Stream stream);
    public BsonReader(BinaryReader reader);
    public BsonReader(Stream stream, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling);
    public BsonReader(BinaryReader reader, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling);
    private static BsonReader();
    public bool get_JsonNet35BinaryCompatibility();
    public void set_JsonNet35BinaryCompatibility(bool value);
    public bool get_ReadRootValueAsArray();
    public void set_ReadRootValueAsArray(bool value);
    public DateTimeKind get_DateTimeKindHandling();
    public void set_DateTimeKindHandling(DateTimeKind value);
    private string ReadElement();
    public virtual bool Read();
    public virtual void Close();
    private bool ReadCodeWScope();
    private bool ReadReference();
    private bool ReadNormal();
    private void PopContext();
    private void PushContext(ContainerContext newContext);
    private byte ReadByte();
    private void ReadType(BsonType type);
    private Byte[] ReadBinary(BsonBinaryType& binaryType);
    private string ReadString();
    private string ReadLengthString();
    private string GetString(int length);
    private int GetLastFullCharStop(int start);
    private int BytesInSequence(byte b);
    private void EnsureBuffers();
    private double ReadDouble();
    private int ReadInt32();
    private long ReadInt64();
    private BsonType ReadType();
    private void MovePosition(int count);
    private Byte[] ReadBytes(int count);
}
internal class Newtonsoft.Json.Bson.BsonRegex : BsonToken {
    [CompilerGeneratedAttribute]
private BsonString <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonString <Options>k__BackingField;
    public BsonString Pattern { get; public set; }
    public BsonString Options { get; public set; }
    public BsonType Type { get; }
    public BsonRegex(string pattern, string options);
    [CompilerGeneratedAttribute]
public BsonString get_Pattern();
    [CompilerGeneratedAttribute]
public void set_Pattern(BsonString value);
    [CompilerGeneratedAttribute]
public BsonString get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(BsonString value);
    public virtual BsonType get_Type();
}
internal class Newtonsoft.Json.Bson.BsonString : BsonValue {
    [CompilerGeneratedAttribute]
private int <ByteCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeLength>k__BackingField;
    public int ByteCount { get; public set; }
    public bool IncludeLength { get; }
    public BsonString(object value, bool includeLength);
    [CompilerGeneratedAttribute]
public int get_ByteCount();
    [CompilerGeneratedAttribute]
public void set_ByteCount(int value);
    [CompilerGeneratedAttribute]
public bool get_IncludeLength();
}
internal abstract class Newtonsoft.Json.Bson.BsonToken : object {
    [CompilerGeneratedAttribute]
private BsonToken <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CalculatedSize>k__BackingField;
    public BsonType Type { get; }
    public BsonToken Parent { get; public set; }
    public int CalculatedSize { get; public set; }
    public abstract virtual BsonType get_Type();
    [CompilerGeneratedAttribute]
public BsonToken get_Parent();
    [CompilerGeneratedAttribute]
public void set_Parent(BsonToken value);
    [CompilerGeneratedAttribute]
public int get_CalculatedSize();
    [CompilerGeneratedAttribute]
public void set_CalculatedSize(int value);
}
internal enum Newtonsoft.Json.Bson.BsonType : Enum {
    public sbyte value__;
    public static BsonType Number;
    public static BsonType String;
    public static BsonType Object;
    public static BsonType Array;
    public static BsonType Binary;
    public static BsonType Undefined;
    public static BsonType Oid;
    public static BsonType Boolean;
    public static BsonType Date;
    public static BsonType Null;
    public static BsonType Regex;
    public static BsonType Reference;
    public static BsonType Code;
    public static BsonType Symbol;
    public static BsonType CodeWScope;
    public static BsonType Integer;
    public static BsonType TimeStamp;
    public static BsonType Long;
    public static BsonType MinKey;
    public static BsonType MaxKey;
}
internal class Newtonsoft.Json.Bson.BsonValue : BsonToken {
    private object _value;
    private BsonType _type;
    public object Value { get; }
    public BsonType Type { get; }
    public BsonValue(object value, BsonType type);
    public object get_Value();
    public virtual BsonType get_Type();
}
[ObsoleteAttribute("BSON reading and writing has been moved to its own package. See https://www.nuget.org/packages/Newtonsoft.Json.Bson for more details.")]
public class Newtonsoft.Json.Bson.BsonWriter : JsonWriter {
    private BsonBinaryWriter _writer;
    private BsonToken _root;
    private BsonToken _parent;
    private string _propertyName;
    public DateTimeKind DateTimeKindHandling { get; public set; }
    public BsonWriter(Stream stream);
    public BsonWriter(BinaryWriter writer);
    public DateTimeKind get_DateTimeKindHandling();
    public void set_DateTimeKindHandling(DateTimeKind value);
    public virtual void Flush();
    protected virtual void WriteEnd(JsonToken token);
    public virtual void WriteComment(string text);
    public virtual void WriteStartConstructor(string name);
    public virtual void WriteRaw(string json);
    public virtual void WriteRawValue(string json);
    public virtual void WriteStartArray();
    public virtual void WriteStartObject();
    public virtual void WritePropertyName(string name);
    public virtual void Close();
    private void AddParent(BsonToken container);
    private void RemoveParent();
    private void AddValue(object value, BsonType type);
    internal void AddToken(BsonToken token);
    public virtual void WriteValue(object value);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Uri value);
    public void WriteObjectId(Byte[] value);
    public void WriteRegex(string pattern, string options);
}
public enum Newtonsoft.Json.ConstructorHandling : Enum {
    public int value__;
    public static ConstructorHandling Default;
    public static ConstructorHandling AllowNonPublicDefaultConstructor;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Converters.BinaryConverter : JsonConverter {
    private static string BinaryTypeName;
    private static string BinaryToArrayName;
    [NullableAttribute("2")]
private static ReflectionObject _reflectionObject;
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private Byte[] GetByteArray(object value);
    private static void EnsureReflectionObject(Type t);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private Byte[] ReadByteArray(JsonReader reader);
    public virtual bool CanConvert(Type objectType);
}
[ObsoleteAttribute("BSON reading and writing has been moved to its own package. See https://www.nuget.org/packages/Newtonsoft.Json.Bson for more details.")]
public class Newtonsoft.Json.Converters.BsonObjectIdConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Newtonsoft.Json.Converters.CustomCreationConverter`1 : JsonConverter {
    public bool CanWrite { get; }
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public abstract virtual T Create(Type objectType);
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Converters.DataSetConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type valueType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Converters.DataTableConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private static void CreateRow(JsonReader reader, DataTable dt, JsonSerializer serializer);
    private static Type GetColumnDataType(JsonReader reader);
    public virtual bool CanConvert(Type valueType);
}
public abstract class Newtonsoft.Json.Converters.DateTimeConverterBase : JsonConverter {
    [NullableContextAttribute("1")]
public virtual bool CanConvert(Type objectType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Converters.DiscriminatedUnionConverter : JsonConverter {
    private static string CasePropertyName;
    private static string FieldsPropertyName;
    private static ThreadSafeStore`2<Type, Union> UnionCache;
    private static ThreadSafeStore`2<Type, Type> UnionTypeLookupCache;
    private static DiscriminatedUnionConverter();
    private static Type CreateUnionTypeLookup(Type t);
    private static Union CreateUnion(Type t);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Converters.EntityKeyMemberConverter : JsonConverter {
    private static string EntityKeyMemberFullTypeName;
    private static string KeyPropertyName;
    private static string TypePropertyName;
    private static string ValuePropertyName;
    [NullableAttribute("2")]
private static ReflectionObject _reflectionObject;
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private static void ReadAndAssertProperty(JsonReader reader, string propertyName);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private static void EnsureReflectionObject(Type objectType);
    public virtual bool CanConvert(Type objectType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Converters.ExpandoObjectConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private object ReadValue(JsonReader reader);
    private object ReadList(JsonReader reader);
    private object ReadObject(JsonReader reader);
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Converters.IsoDateTimeConverter : DateTimeConverterBase {
    private static string DefaultDateTimeFormat;
    private DateTimeStyles _dateTimeStyles;
    [NullableAttribute("2")]
private string _dateTimeFormat;
    [NullableAttribute("2")]
private CultureInfo _culture;
    public DateTimeStyles DateTimeStyles { get; public set; }
    [NullableAttribute("2")]
public string DateTimeFormat { get; public set; }
    public CultureInfo Culture { get; public set; }
    public DateTimeStyles get_DateTimeStyles();
    public void set_DateTimeStyles(DateTimeStyles value);
    [NullableContextAttribute("2")]
public string get_DateTimeFormat();
    [NullableContextAttribute("2")]
public void set_DateTimeFormat(string value);
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
}
[NullableContextAttribute("2")]
internal interface Newtonsoft.Json.Converters.IXmlDeclaration {
    public string Version { get; }
    public string Encoding { get; public set; }
    public string Standalone { get; public set; }
    public abstract virtual string get_Version();
    public abstract virtual string get_Encoding();
    public abstract virtual void set_Encoding(string value);
    public abstract virtual string get_Standalone();
    public abstract virtual void set_Standalone(string value);
}
[NullableContextAttribute("1")]
internal interface Newtonsoft.Json.Converters.IXmlDocument {
    [NullableAttribute("2")]
public IXmlElement DocumentElement { get; }
    public abstract virtual IXmlNode CreateComment(string text);
    public abstract virtual IXmlNode CreateTextNode(string text);
    public abstract virtual IXmlNode CreateCDataSection(string data);
    public abstract virtual IXmlNode CreateWhitespace(string text);
    public abstract virtual IXmlNode CreateSignificantWhitespace(string text);
    public abstract virtual IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
    [NullableContextAttribute("2")]
public abstract virtual IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset);
    public abstract virtual IXmlNode CreateProcessingInstruction(string target, string data);
    public abstract virtual IXmlElement CreateElement(string elementName);
    public abstract virtual IXmlElement CreateElement(string qualifiedName, string namespaceUri);
    public abstract virtual IXmlNode CreateAttribute(string name, string value);
    public abstract virtual IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);
    [NullableContextAttribute("2")]
public abstract virtual IXmlElement get_DocumentElement();
}
[NullableContextAttribute("2")]
internal interface Newtonsoft.Json.Converters.IXmlDocumentType {
    [NullableAttribute("1")]
public string Name { get; }
    public string System { get; }
    public string Public { get; }
    public string InternalSubset { get; }
    [NullableContextAttribute("1")]
public abstract virtual string get_Name();
    public abstract virtual string get_System();
    public abstract virtual string get_Public();
    public abstract virtual string get_InternalSubset();
}
[NullableContextAttribute("1")]
internal interface Newtonsoft.Json.Converters.IXmlElement {
    public bool IsEmpty { get; }
    public abstract virtual void SetAttributeNode(IXmlNode attribute);
    public abstract virtual string GetPrefixOfNamespace(string namespaceUri);
    public abstract virtual bool get_IsEmpty();
}
[NullableContextAttribute("2")]
internal interface Newtonsoft.Json.Converters.IXmlNode {
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    [NullableAttribute("1")]
public List`1<IXmlNode> ChildNodes { get; }
    [NullableAttribute("1")]
public List`1<IXmlNode> Attributes { get; }
    public IXmlNode ParentNode { get; }
    public string Value { get; public set; }
    public string NamespaceUri { get; }
    public object WrappedNode { get; }
    public abstract virtual XmlNodeType get_NodeType();
    public abstract virtual string get_LocalName();
    [NullableContextAttribute("1")]
public abstract virtual List`1<IXmlNode> get_ChildNodes();
    [NullableContextAttribute("1")]
public abstract virtual List`1<IXmlNode> get_Attributes();
    public abstract virtual IXmlNode get_ParentNode();
    public abstract virtual string get_Value();
    public abstract virtual void set_Value(string value);
    [NullableContextAttribute("1")]
public abstract virtual IXmlNode AppendChild(IXmlNode newChild);
    public abstract virtual string get_NamespaceUri();
    public abstract virtual object get_WrappedNode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Converters.JavaScriptDateTimeConverter : DateTimeConverterBase {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Converters.KeyValuePairConverter : JsonConverter {
    private static string KeyName;
    private static string ValueName;
    private static ThreadSafeStore`2<Type, ReflectionObject> ReflectionObjectPerType;
    private static KeyValuePairConverter();
    private static ReflectionObject InitializeReflectionObject(Type t);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Converters.RegexConverter : JsonConverter {
    private static string PatternName;
    private static string OptionsName;
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private bool HasFlag(RegexOptions options, RegexOptions flag);
    private void WriteBson(BsonWriter writer, Regex regex);
    private void WriteJson(JsonWriter writer, Regex regex, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private object ReadRegexString(JsonReader reader);
    private Regex ReadRegexObject(JsonReader reader, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    private bool IsRegex(Type objectType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Converters.StringEnumConverter : JsonConverter {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private NamingStrategy <NamingStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowIntegerValues>k__BackingField;
    [ObsoleteAttribute("StringEnumConverter.CamelCaseText is obsolete. Set StringEnumConverter.NamingStrategy with CamelCaseNamingStrategy instead.")]
public bool CamelCaseText { get; public set; }
    [NullableAttribute("2")]
public NamingStrategy NamingStrategy { get; public set; }
    public bool AllowIntegerValues { get; public set; }
    [ObsoleteAttribute("StringEnumConverter(bool) is obsolete. Create a converter with StringEnumConverter(NamingStrategy, bool) instead.")]
public StringEnumConverter(bool camelCaseText);
    public StringEnumConverter(NamingStrategy namingStrategy, bool allowIntegerValues);
    public StringEnumConverter(Type namingStrategyType);
    public StringEnumConverter(Type namingStrategyType, Object[] namingStrategyParameters);
    public StringEnumConverter(Type namingStrategyType, Object[] namingStrategyParameters, bool allowIntegerValues);
    public bool get_CamelCaseText();
    public void set_CamelCaseText(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public NamingStrategy get_NamingStrategy();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_NamingStrategy(NamingStrategy value);
    [CompilerGeneratedAttribute]
public bool get_AllowIntegerValues();
    [CompilerGeneratedAttribute]
public void set_AllowIntegerValues(bool value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Converters.UnixDateTimeConverter : DateTimeConverterBase {
    internal static DateTime UnixEpoch;
    [CompilerGeneratedAttribute]
private bool <AllowPreEpoch>k__BackingField;
    public bool AllowPreEpoch { get; public set; }
    public UnixDateTimeConverter(bool allowPreEpoch);
    private static UnixDateTimeConverter();
    [CompilerGeneratedAttribute]
public bool get_AllowPreEpoch();
    [CompilerGeneratedAttribute]
public void set_AllowPreEpoch(bool value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Converters.VersionConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XAttributeWrapper : XObjectWrapper {
    [NullableAttribute("1")]
private XAttribute Attribute { get; }
    public string Value { get; public set; }
    public string LocalName { get; }
    public string NamespaceUri { get; }
    public IXmlNode ParentNode { get; }
    [NullableContextAttribute("1")]
public XAttributeWrapper(XAttribute attribute);
    [NullableContextAttribute("1")]
private XAttribute get_Attribute();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual string get_LocalName();
    public virtual string get_NamespaceUri();
    public virtual IXmlNode get_ParentNode();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XCommentWrapper : XObjectWrapper {
    [NullableAttribute("1")]
private XComment Text { get; }
    public string Value { get; public set; }
    public IXmlNode ParentNode { get; }
    [NullableContextAttribute("1")]
public XCommentWrapper(XComment text);
    [NullableContextAttribute("1")]
private XComment get_Text();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual IXmlNode get_ParentNode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XContainerWrapper : XObjectWrapper {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IXmlNode> _childNodes;
    private XContainer Container { get; }
    public List`1<IXmlNode> ChildNodes { get; }
    protected bool HasChildNodes { get; }
    [NullableAttribute("2")]
public IXmlNode ParentNode { get; }
    public XContainerWrapper(XContainer container);
    private XContainer get_Container();
    public virtual List`1<IXmlNode> get_ChildNodes();
    protected virtual bool get_HasChildNodes();
    [NullableContextAttribute("2")]
public virtual IXmlNode get_ParentNode();
    internal static IXmlNode WrapNode(XObject node);
    public virtual IXmlNode AppendChild(IXmlNode newChild);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XDeclarationWrapper : XObjectWrapper {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private XDeclaration <Declaration>k__BackingField;
    [NullableAttribute("1")]
internal XDeclaration Declaration { get; }
    public XmlNodeType NodeType { get; }
    public string Version { get; }
    public string Encoding { get; public set; }
    public string Standalone { get; public set; }
    [NullableContextAttribute("1")]
public XDeclarationWrapper(XDeclaration declaration);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal XDeclaration get_Declaration();
    public virtual XmlNodeType get_NodeType();
    public sealed virtual string get_Version();
    public sealed virtual string get_Encoding();
    public sealed virtual void set_Encoding(string value);
    public sealed virtual string get_Standalone();
    public sealed virtual void set_Standalone(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XDocumentTypeWrapper : XObjectWrapper {
    [NullableAttribute("1")]
private XDocumentType _documentType;
    [NullableAttribute("1")]
public string Name { get; }
    public string System { get; }
    public string Public { get; }
    public string InternalSubset { get; }
    public string LocalName { get; }
    [NullableContextAttribute("1")]
public XDocumentTypeWrapper(XDocumentType documentType);
    [NullableContextAttribute("1")]
public sealed virtual string get_Name();
    public sealed virtual string get_System();
    public sealed virtual string get_Public();
    public sealed virtual string get_InternalSubset();
    public virtual string get_LocalName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XDocumentWrapper : XContainerWrapper {
    private XDocument Document { get; }
    public List`1<IXmlNode> ChildNodes { get; }
    protected bool HasChildNodes { get; }
    [NullableAttribute("2")]
public IXmlElement DocumentElement { get; }
    public XDocumentWrapper(XDocument document);
    private XDocument get_Document();
    public virtual List`1<IXmlNode> get_ChildNodes();
    protected virtual bool get_HasChildNodes();
    public sealed virtual IXmlNode CreateComment(string text);
    public sealed virtual IXmlNode CreateTextNode(string text);
    public sealed virtual IXmlNode CreateCDataSection(string data);
    public sealed virtual IXmlNode CreateWhitespace(string text);
    public sealed virtual IXmlNode CreateSignificantWhitespace(string text);
    public sealed virtual IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
    [NullableContextAttribute("2")]
public sealed virtual IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset);
    public sealed virtual IXmlNode CreateProcessingInstruction(string target, string data);
    public sealed virtual IXmlElement CreateElement(string elementName);
    public sealed virtual IXmlElement CreateElement(string qualifiedName, string namespaceUri);
    public sealed virtual IXmlNode CreateAttribute(string name, string value);
    public sealed virtual IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);
    [NullableContextAttribute("2")]
public sealed virtual IXmlElement get_DocumentElement();
    public virtual IXmlNode AppendChild(IXmlNode newChild);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XElementWrapper : XContainerWrapper {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IXmlNode> _attributes;
    private XElement Element { get; }
    public List`1<IXmlNode> Attributes { get; }
    [NullableAttribute("2")]
public string Value { get; public set; }
    [NullableAttribute("2")]
public string LocalName { get; }
    [NullableAttribute("2")]
public string NamespaceUri { get; }
    public bool IsEmpty { get; }
    public XElementWrapper(XElement element);
    private XElement get_Element();
    public sealed virtual void SetAttributeNode(IXmlNode attribute);
    public virtual List`1<IXmlNode> get_Attributes();
    private bool HasImplicitNamespaceAttribute(string namespaceUri);
    public virtual IXmlNode AppendChild(IXmlNode newChild);
    [NullableContextAttribute("2")]
public virtual string get_Value();
    [NullableContextAttribute("2")]
public virtual void set_Value(string value);
    [NullableContextAttribute("2")]
public virtual string get_LocalName();
    [NullableContextAttribute("2")]
public virtual string get_NamespaceUri();
    public sealed virtual string GetPrefixOfNamespace(string namespaceUri);
    public sealed virtual bool get_IsEmpty();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XmlDeclarationWrapper : XmlNodeWrapper {
    [NullableAttribute("1")]
private XmlDeclaration _declaration;
    public string Version { get; }
    public string Encoding { get; public set; }
    public string Standalone { get; public set; }
    [NullableContextAttribute("1")]
public XmlDeclarationWrapper(XmlDeclaration declaration);
    public sealed virtual string get_Version();
    public sealed virtual string get_Encoding();
    public sealed virtual void set_Encoding(string value);
    public sealed virtual string get_Standalone();
    public sealed virtual void set_Standalone(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XmlDocumentTypeWrapper : XmlNodeWrapper {
    [NullableAttribute("1")]
private XmlDocumentType _documentType;
    [NullableAttribute("1")]
public string Name { get; }
    public string System { get; }
    public string Public { get; }
    public string InternalSubset { get; }
    public string LocalName { get; }
    [NullableContextAttribute("1")]
public XmlDocumentTypeWrapper(XmlDocumentType documentType);
    [NullableContextAttribute("1")]
public sealed virtual string get_Name();
    public sealed virtual string get_System();
    public sealed virtual string get_Public();
    public sealed virtual string get_InternalSubset();
    public virtual string get_LocalName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XmlDocumentWrapper : XmlNodeWrapper {
    private XmlDocument _document;
    [NullableAttribute("2")]
public IXmlElement DocumentElement { get; }
    public XmlDocumentWrapper(XmlDocument document);
    public sealed virtual IXmlNode CreateComment(string data);
    public sealed virtual IXmlNode CreateTextNode(string text);
    public sealed virtual IXmlNode CreateCDataSection(string data);
    public sealed virtual IXmlNode CreateWhitespace(string text);
    public sealed virtual IXmlNode CreateSignificantWhitespace(string text);
    public sealed virtual IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
    [NullableContextAttribute("2")]
public sealed virtual IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset);
    public sealed virtual IXmlNode CreateProcessingInstruction(string target, string data);
    public sealed virtual IXmlElement CreateElement(string elementName);
    public sealed virtual IXmlElement CreateElement(string qualifiedName, string namespaceUri);
    public sealed virtual IXmlNode CreateAttribute(string name, string value);
    public sealed virtual IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);
    [NullableContextAttribute("2")]
public sealed virtual IXmlElement get_DocumentElement();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XmlElementWrapper : XmlNodeWrapper {
    private XmlElement _element;
    public bool IsEmpty { get; }
    public XmlElementWrapper(XmlElement element);
    public sealed virtual void SetAttributeNode(IXmlNode attribute);
    public sealed virtual string GetPrefixOfNamespace(string namespaceUri);
    public sealed virtual bool get_IsEmpty();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Converters.XmlNodeConverter : JsonConverter {
    internal static List`1<IXmlNode> EmptyChildNodes;
    private static string TextName;
    private static string CommentName;
    private static string CDataName;
    private static string WhitespaceName;
    private static string SignificantWhitespaceName;
    private static string DeclarationName;
    private static string JsonNamespaceUri;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <DeserializeRootElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WriteArrayAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OmitRootObject>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EncodeSpecialCharacters>k__BackingField;
    [NullableAttribute("2")]
public string DeserializeRootElementName { get; public set; }
    public bool WriteArrayAttribute { get; public set; }
    public bool OmitRootObject { get; public set; }
    public bool EncodeSpecialCharacters { get; public set; }
    private static XmlNodeConverter();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_DeserializeRootElementName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_DeserializeRootElementName(string value);
    [CompilerGeneratedAttribute]
public bool get_WriteArrayAttribute();
    [CompilerGeneratedAttribute]
public void set_WriteArrayAttribute(bool value);
    [CompilerGeneratedAttribute]
public bool get_OmitRootObject();
    [CompilerGeneratedAttribute]
public void set_OmitRootObject(bool value);
    [CompilerGeneratedAttribute]
public bool get_EncodeSpecialCharacters();
    [CompilerGeneratedAttribute]
public void set_EncodeSpecialCharacters(bool value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private IXmlNode WrapXml(object value);
    private void PushParentNamespaces(IXmlNode node, XmlNamespaceManager manager);
    private string ResolveFullName(IXmlNode node, XmlNamespaceManager manager);
    private string GetPropertyName(IXmlNode node, XmlNamespaceManager manager);
    private bool IsArray(IXmlNode node);
    private void SerializeGroupedNodes(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName);
    private void WriteGroupedNodes(JsonWriter writer, XmlNamespaceManager manager, bool writePropertyName, List`1<IXmlNode> groupedNodes, string elementNames);
    private void WriteGroupedNodes(JsonWriter writer, XmlNamespaceManager manager, bool writePropertyName, IXmlNode node, string elementNames);
    private void SerializeNode(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName);
    private static bool AllSameName(IXmlNode node);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private void DeserializeValue(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, string propertyName, IXmlNode currentNode);
    private void ReadElement(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName, XmlNamespaceManager manager);
    private void CreateElement(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string elementName, XmlNamespaceManager manager, string elementPrefix, Dictionary`2<string, string> attributeNameValues);
    private static void AddAttribute(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName, string attributeName, XmlNamespaceManager manager, string attributePrefix);
    private static string ConvertTokenToXmlValue(JsonReader reader);
    private void ReadArrayElements(JsonReader reader, IXmlDocument document, string propertyName, IXmlNode currentNode, XmlNamespaceManager manager);
    private void AddJsonArrayAttribute(IXmlElement element, IXmlDocument document);
    private bool ShouldReadInto(JsonReader reader);
    private Dictionary`2<string, string> ReadAttributeElements(JsonReader reader, XmlNamespaceManager manager);
    private void CreateInstruction(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName);
    private void CreateDocumentType(JsonReader reader, IXmlDocument document, IXmlNode currentNode);
    private IXmlElement CreateElement(string elementName, IXmlDocument document, string elementPrefix, XmlNamespaceManager manager);
    private void DeserializeNode(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, IXmlNode currentNode);
    private bool IsNamespaceAttribute(string attributeName, String& prefix);
    private bool ValueAttributes(List`1<IXmlNode> c);
    public virtual bool CanConvert(Type valueType);
    private bool IsXObject(Type valueType);
    private bool IsXmlNode(Type valueType);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XmlNodeWrapper : object {
    [NullableAttribute("1")]
private XmlNode _node;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IXmlNode> _childNodes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IXmlNode> _attributes;
    public object WrappedNode { get; }
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    [NullableAttribute("1")]
public List`1<IXmlNode> ChildNodes { get; }
    protected bool HasChildNodes { get; }
    [NullableAttribute("1")]
public List`1<IXmlNode> Attributes { get; }
    private bool HasAttributes { get; }
    public IXmlNode ParentNode { get; }
    public string Value { get; public set; }
    public string NamespaceUri { get; }
    [NullableContextAttribute("1")]
public XmlNodeWrapper(XmlNode node);
    public sealed virtual object get_WrappedNode();
    public sealed virtual XmlNodeType get_NodeType();
    public virtual string get_LocalName();
    [NullableContextAttribute("1")]
public sealed virtual List`1<IXmlNode> get_ChildNodes();
    protected virtual bool get_HasChildNodes();
    [NullableContextAttribute("1")]
internal static IXmlNode WrapNode(XmlNode node);
    [NullableContextAttribute("1")]
public sealed virtual List`1<IXmlNode> get_Attributes();
    private bool get_HasAttributes();
    public sealed virtual IXmlNode get_ParentNode();
    public sealed virtual string get_Value();
    public sealed virtual void set_Value(string value);
    [NullableContextAttribute("1")]
public sealed virtual IXmlNode AppendChild(IXmlNode newChild);
    public sealed virtual string get_NamespaceUri();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XObjectWrapper : object {
    private XObject _xmlObject;
    public object WrappedNode { get; }
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    [NullableAttribute("1")]
public List`1<IXmlNode> ChildNodes { get; }
    [NullableAttribute("1")]
public List`1<IXmlNode> Attributes { get; }
    public IXmlNode ParentNode { get; }
    public string Value { get; public set; }
    public string NamespaceUri { get; }
    public XObjectWrapper(XObject xmlObject);
    public sealed virtual object get_WrappedNode();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_LocalName();
    [NullableContextAttribute("1")]
public virtual List`1<IXmlNode> get_ChildNodes();
    [NullableContextAttribute("1")]
public virtual List`1<IXmlNode> get_Attributes();
    public virtual IXmlNode get_ParentNode();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    [NullableContextAttribute("1")]
public virtual IXmlNode AppendChild(IXmlNode newChild);
    public virtual string get_NamespaceUri();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XProcessingInstructionWrapper : XObjectWrapper {
    [NullableAttribute("1")]
private XProcessingInstruction ProcessingInstruction { get; }
    public string LocalName { get; }
    public string Value { get; public set; }
    [NullableContextAttribute("1")]
public XProcessingInstructionWrapper(XProcessingInstruction processingInstruction);
    [NullableContextAttribute("1")]
private XProcessingInstruction get_ProcessingInstruction();
    public virtual string get_LocalName();
    public virtual string get_Value();
    public virtual void set_Value(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XTextWrapper : XObjectWrapper {
    [NullableAttribute("1")]
private XText Text { get; }
    public string Value { get; public set; }
    public IXmlNode ParentNode { get; }
    [NullableContextAttribute("1")]
public XTextWrapper(XText text);
    [NullableContextAttribute("1")]
private XText get_Text();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual IXmlNode get_ParentNode();
}
public enum Newtonsoft.Json.DateFormatHandling : Enum {
    public int value__;
    public static DateFormatHandling IsoDateFormat;
    public static DateFormatHandling MicrosoftDateFormat;
}
public enum Newtonsoft.Json.DateParseHandling : Enum {
    public int value__;
    public static DateParseHandling None;
    public static DateParseHandling DateTime;
    public static DateParseHandling DateTimeOffset;
}
public enum Newtonsoft.Json.DateTimeZoneHandling : Enum {
    public int value__;
    public static DateTimeZoneHandling Local;
    public static DateTimeZoneHandling Utc;
    public static DateTimeZoneHandling Unspecified;
    public static DateTimeZoneHandling RoundtripKind;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.DefaultJsonNameTable : JsonNameTable {
    private static int HashCodeRandomizer;
    private int _count;
    private Entry[] _entries;
    private int _mask;
    private static DefaultJsonNameTable();
    public virtual string Get(Char[] key, int start, int length);
    public string Add(string key);
    private string AddEntry(string str, int hashCode);
    private void Grow();
    private static bool TextEquals(string str1, Char[] str2, int str2Start, int str2Length);
}
[FlagsAttribute]
public enum Newtonsoft.Json.DefaultValueHandling : Enum {
    public int value__;
    public static DefaultValueHandling Include;
    public static DefaultValueHandling Ignore;
    public static DefaultValueHandling Populate;
    public static DefaultValueHandling IgnoreAndPopulate;
}
public enum Newtonsoft.Json.FloatFormatHandling : Enum {
    public int value__;
    public static FloatFormatHandling String;
    public static FloatFormatHandling Symbol;
    public static FloatFormatHandling DefaultValue;
}
public enum Newtonsoft.Json.FloatParseHandling : Enum {
    public int value__;
    public static FloatParseHandling Double;
    public static FloatParseHandling Decimal;
}
public enum Newtonsoft.Json.Formatting : Enum {
    public int value__;
    public static Formatting None;
    public static Formatting Indented;
}
[NullableContextAttribute("1")]
public interface Newtonsoft.Json.IArrayPool`1 {
    public abstract virtual T[] Rent(int minimumLength);
    public abstract virtual void Return(T[] array);
}
public interface Newtonsoft.Json.IJsonLineInfo {
    public int LineNumber { get; }
    public int LinePosition { get; }
    public abstract virtual bool HasLineInfo();
    public abstract virtual int get_LineNumber();
    public abstract virtual int get_LinePosition();
}
[AttributeUsageAttribute("1028")]
public class Newtonsoft.Json.JsonArrayAttribute : JsonContainerAttribute {
    private bool _allowNullItems;
    public bool AllowNullItems { get; public set; }
    public JsonArrayAttribute(bool allowNullItems);
    [NullableContextAttribute("1")]
public JsonArrayAttribute(string id);
    public bool get_AllowNullItems();
    public void set_AllowNullItems(bool value);
}
[AttributeUsageAttribute("32")]
public class Newtonsoft.Json.JsonConstructorAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1028")]
public abstract class Newtonsoft.Json.JsonContainerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ItemConverterType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Object[] <ItemConverterParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private NamingStrategy <NamingStrategyInstance>k__BackingField;
    internal Nullable`1<bool> _isReference;
    internal Nullable`1<bool> _itemIsReference;
    internal Nullable`1<ReferenceLoopHandling> _itemReferenceLoopHandling;
    internal Nullable`1<TypeNameHandling> _itemTypeNameHandling;
    private Type _namingStrategyType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Object[] _namingStrategyParameters;
    public string Id { get; public set; }
    public string Title { get; public set; }
    public string Description { get; public set; }
    public Type ItemConverterType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] ItemConverterParameters { get; public set; }
    public Type NamingStrategyType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] NamingStrategyParameters { get; public set; }
    internal NamingStrategy NamingStrategyInstance { get; internal set; }
    public bool IsReference { get; public set; }
    public bool ItemIsReference { get; public set; }
    public ReferenceLoopHandling ItemReferenceLoopHandling { get; public set; }
    public TypeNameHandling ItemTypeNameHandling { get; public set; }
    [NullableContextAttribute("1")]
protected JsonContainerAttribute(string id);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public Type get_ItemConverterType();
    [CompilerGeneratedAttribute]
public void set_ItemConverterType(Type value);
    [CompilerGeneratedAttribute]
public Object[] get_ItemConverterParameters();
    [CompilerGeneratedAttribute]
public void set_ItemConverterParameters(Object[] value);
    public Type get_NamingStrategyType();
    public void set_NamingStrategyType(Type value);
    public Object[] get_NamingStrategyParameters();
    public void set_NamingStrategyParameters(Object[] value);
    [CompilerGeneratedAttribute]
internal NamingStrategy get_NamingStrategyInstance();
    [CompilerGeneratedAttribute]
internal void set_NamingStrategyInstance(NamingStrategy value);
    public bool get_IsReference();
    public void set_IsReference(bool value);
    public bool get_ItemIsReference();
    public void set_ItemIsReference(bool value);
    public ReferenceLoopHandling get_ItemReferenceLoopHandling();
    public void set_ItemReferenceLoopHandling(ReferenceLoopHandling value);
    public TypeNameHandling get_ItemTypeNameHandling();
    public void set_ItemTypeNameHandling(TypeNameHandling value);
}
internal enum Newtonsoft.Json.JsonContainerType : Enum {
    public int value__;
    public static JsonContainerType None;
    public static JsonContainerType Object;
    public static JsonContainerType Array;
    public static JsonContainerType Constructor;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Newtonsoft.Json.JsonConvert : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static Func`1<JsonSerializerSettings> <DefaultSettings>k__BackingField;
    public static string True;
    public static string False;
    public static string Null;
    public static string Undefined;
    public static string PositiveInfinity;
    public static string NegativeInfinity;
    public static string NaN;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Func`1<JsonSerializerSettings> DefaultSettings { get; public set; }
    private static JsonConvert();
    [CompilerGeneratedAttribute]
public static Func`1<JsonSerializerSettings> get_DefaultSettings();
    [CompilerGeneratedAttribute]
public static void set_DefaultSettings(Func`1<JsonSerializerSettings> value);
    public static string ToString(DateTime value);
    public static string ToString(DateTime value, DateFormatHandling format, DateTimeZoneHandling timeZoneHandling);
    public static string ToString(DateTimeOffset value);
    public static string ToString(DateTimeOffset value, DateFormatHandling format);
    public static string ToString(bool value);
    public static string ToString(char value);
    public static string ToString(Enum value);
    public static string ToString(int value);
    public static string ToString(short value);
    [CLSCompliantAttribute("False")]
public static string ToString(ushort value);
    [CLSCompliantAttribute("False")]
public static string ToString(UInt32 value);
    public static string ToString(long value);
    private static string ToStringInternal(BigInteger value);
    [CLSCompliantAttribute("False")]
public static string ToString(ulong value);
    public static string ToString(float value);
    internal static string ToString(float value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable);
    private static string EnsureFloatFormat(double value, string text, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable);
    public static string ToString(double value);
    internal static string ToString(double value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable);
    private static string EnsureDecimalPlace(double value, string text);
    private static string EnsureDecimalPlace(string text);
    public static string ToString(byte value);
    [CLSCompliantAttribute("False")]
public static string ToString(sbyte value);
    public static string ToString(decimal value);
    public static string ToString(Guid value);
    internal static string ToString(Guid value, char quoteChar);
    public static string ToString(TimeSpan value);
    internal static string ToString(TimeSpan value, char quoteChar);
    public static string ToString(Uri value);
    internal static string ToString(Uri value, char quoteChar);
    public static string ToString(string value);
    public static string ToString(string value, char delimiter);
    public static string ToString(string value, char delimiter, StringEscapeHandling stringEscapeHandling);
    public static string ToString(object value);
    [DebuggerStepThroughAttribute]
public static string SerializeObject(object value);
    [DebuggerStepThroughAttribute]
public static string SerializeObject(object value, Formatting formatting);
    [DebuggerStepThroughAttribute]
public static string SerializeObject(object value, JsonConverter[] converters);
    [DebuggerStepThroughAttribute]
public static string SerializeObject(object value, Formatting formatting, JsonConverter[] converters);
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public static string SerializeObject(object value, JsonSerializerSettings settings);
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public static string SerializeObject(object value, Type type, JsonSerializerSettings settings);
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public static string SerializeObject(object value, Formatting formatting, JsonSerializerSettings settings);
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public static string SerializeObject(object value, Type type, Formatting formatting, JsonSerializerSettings settings);
    private static string SerializeObjectInternal(object value, Type type, JsonSerializer jsonSerializer);
    [DebuggerStepThroughAttribute]
public static object DeserializeObject(string value);
    [DebuggerStepThroughAttribute]
public static object DeserializeObject(string value, JsonSerializerSettings settings);
    [DebuggerStepThroughAttribute]
public static object DeserializeObject(string value, Type type);
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public static T DeserializeObject(string value);
    [DebuggerStepThroughAttribute]
public static T DeserializeAnonymousType(string value, T anonymousTypeObject);
    [DebuggerStepThroughAttribute]
public static T DeserializeAnonymousType(string value, T anonymousTypeObject, JsonSerializerSettings settings);
    [DebuggerStepThroughAttribute]
public static T DeserializeObject(string value, JsonConverter[] converters);
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public static T DeserializeObject(string value, JsonSerializerSettings settings);
    [DebuggerStepThroughAttribute]
public static object DeserializeObject(string value, Type type, JsonConverter[] converters);
    [NullableContextAttribute("2")]
public static object DeserializeObject(string value, Type type, JsonSerializerSettings settings);
    [DebuggerStepThroughAttribute]
public static void PopulateObject(string value, object target);
    public static void PopulateObject(string value, object target, JsonSerializerSettings settings);
    public static string SerializeXmlNode(XmlNode node);
    public static string SerializeXmlNode(XmlNode node, Formatting formatting);
    public static string SerializeXmlNode(XmlNode node, Formatting formatting, bool omitRootObject);
    public static XmlDocument DeserializeXmlNode(string value);
    [NullableContextAttribute("2")]
public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName);
    [NullableContextAttribute("2")]
public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName, bool writeArrayAttribute);
    [NullableContextAttribute("2")]
public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName, bool writeArrayAttribute, bool encodeSpecialCharacters);
    public static string SerializeXNode(XObject node);
    public static string SerializeXNode(XObject node, Formatting formatting);
    public static string SerializeXNode(XObject node, Formatting formatting, bool omitRootObject);
    public static XDocument DeserializeXNode(string value);
    [NullableContextAttribute("2")]
public static XDocument DeserializeXNode(string value, string deserializeRootElementName);
    [NullableContextAttribute("2")]
public static XDocument DeserializeXNode(string value, string deserializeRootElementName, bool writeArrayAttribute);
    [NullableContextAttribute("2")]
public static XDocument DeserializeXNode(string value, string deserializeRootElementName, bool writeArrayAttribute, bool encodeSpecialCharacters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Newtonsoft.Json.JsonConverter : object {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public abstract virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public abstract virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public abstract virtual bool CanConvert(Type objectType);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Newtonsoft.Json.JsonConverter`1 : JsonConverter {
    public sealed virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public abstract virtual void WriteJson(JsonWriter writer, T value, JsonSerializer serializer);
    public sealed virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public abstract virtual T ReadJson(JsonReader reader, Type objectType, T existingValue, bool hasExistingValue, JsonSerializer serializer);
    public sealed virtual bool CanConvert(Type objectType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("3484")]
public class Newtonsoft.Json.JsonConverterAttribute : Attribute {
    private Type _converterType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Object[] <ConverterParameters>k__BackingField;
    public Type ConverterType { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] ConverterParameters { get; }
    public JsonConverterAttribute(Type converterType);
    public JsonConverterAttribute(Type converterType, Object[] converterParameters);
    public Type get_ConverterType();
    [CompilerGeneratedAttribute]
public Object[] get_ConverterParameters();
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Newtonsoft.Json.JsonConverterCollection : Collection`1<JsonConverter> {
}
[AttributeUsageAttribute("1028")]
public class Newtonsoft.Json.JsonDictionaryAttribute : JsonContainerAttribute {
    [NullableContextAttribute("1")]
public JsonDictionaryAttribute(string id);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.JsonException : Exception {
    public JsonException(string message);
    public JsonException(string message, Exception innerException);
    public JsonException(SerializationInfo info, StreamingContext context);
    internal static JsonException Create(IJsonLineInfo lineInfo, string path, string message);
}
[AttributeUsageAttribute("384")]
public class Newtonsoft.Json.JsonExtensionDataAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <WriteData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReadData>k__BackingField;
    public bool WriteData { get; public set; }
    public bool ReadData { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_WriteData();
    [CompilerGeneratedAttribute]
public void set_WriteData(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReadData();
    [CompilerGeneratedAttribute]
public void set_ReadData(bool value);
}
[AttributeUsageAttribute("384")]
public class Newtonsoft.Json.JsonIgnoreAttribute : Attribute {
}
public abstract class Newtonsoft.Json.JsonNameTable : object {
    [NullableContextAttribute("1")]
public abstract virtual string Get(Char[] key, int start, int length);
}
[AttributeUsageAttribute("1036")]
public class Newtonsoft.Json.JsonObjectAttribute : JsonContainerAttribute {
    private MemberSerialization _memberSerialization;
    internal Nullable`1<MissingMemberHandling> _missingMemberHandling;
    internal Nullable`1<Required> _itemRequired;
    internal Nullable`1<NullValueHandling> _itemNullValueHandling;
    public MemberSerialization MemberSerialization { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public NullValueHandling ItemNullValueHandling { get; public set; }
    public Required ItemRequired { get; public set; }
    public JsonObjectAttribute(MemberSerialization memberSerialization);
    [NullableContextAttribute("1")]
public JsonObjectAttribute(string id);
    public MemberSerialization get_MemberSerialization();
    public void set_MemberSerialization(MemberSerialization value);
    public MissingMemberHandling get_MissingMemberHandling();
    public void set_MissingMemberHandling(MissingMemberHandling value);
    public NullValueHandling get_ItemNullValueHandling();
    public void set_ItemNullValueHandling(NullValueHandling value);
    public Required get_ItemRequired();
    public void set_ItemRequired(Required value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.JsonPosition : ValueType {
    private static Char[] SpecialCharacters;
    internal JsonContainerType Type;
    internal int Position;
    [NullableAttribute("2")]
internal string PropertyName;
    internal bool HasIndex;
    public JsonPosition(JsonContainerType type);
    private static JsonPosition();
    internal int CalculateLength();
    [NullableContextAttribute("2")]
internal void WriteTo(StringBuilder sb, StringWriter& writer, Char[]& buffer);
    internal static bool TypeHasIndex(JsonContainerType type);
    internal static string BuildPath(List`1<JsonPosition> positions, Nullable`1<JsonPosition> currentPosition);
    internal static string FormatMessage(IJsonLineInfo lineInfo, string path, string message);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2432")]
public class Newtonsoft.Json.JsonPropertyAttribute : Attribute {
    internal Nullable`1<NullValueHandling> _nullValueHandling;
    internal Nullable`1<DefaultValueHandling> _defaultValueHandling;
    internal Nullable`1<ReferenceLoopHandling> _referenceLoopHandling;
    internal Nullable`1<ObjectCreationHandling> _objectCreationHandling;
    internal Nullable`1<TypeNameHandling> _typeNameHandling;
    internal Nullable`1<bool> _isReference;
    internal Nullable`1<int> _order;
    internal Nullable`1<Required> _required;
    internal Nullable`1<bool> _itemIsReference;
    internal Nullable`1<ReferenceLoopHandling> _itemReferenceLoopHandling;
    internal Nullable`1<TypeNameHandling> _itemTypeNameHandling;
    [CompilerGeneratedAttribute]
private Type <ItemConverterType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Object[] <ItemConverterParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <NamingStrategyType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Object[] <NamingStrategyParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    public Type ItemConverterType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] ItemConverterParameters { get; public set; }
    public Type NamingStrategyType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] NamingStrategyParameters { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public bool IsReference { get; public set; }
    public int Order { get; public set; }
    public Required Required { get; public set; }
    public string PropertyName { get; public set; }
    public ReferenceLoopHandling ItemReferenceLoopHandling { get; public set; }
    public TypeNameHandling ItemTypeNameHandling { get; public set; }
    public bool ItemIsReference { get; public set; }
    [NullableContextAttribute("1")]
public JsonPropertyAttribute(string propertyName);
    [CompilerGeneratedAttribute]
public Type get_ItemConverterType();
    [CompilerGeneratedAttribute]
public void set_ItemConverterType(Type value);
    [CompilerGeneratedAttribute]
public Object[] get_ItemConverterParameters();
    [CompilerGeneratedAttribute]
public void set_ItemConverterParameters(Object[] value);
    [CompilerGeneratedAttribute]
public Type get_NamingStrategyType();
    [CompilerGeneratedAttribute]
public void set_NamingStrategyType(Type value);
    [CompilerGeneratedAttribute]
public Object[] get_NamingStrategyParameters();
    [CompilerGeneratedAttribute]
public void set_NamingStrategyParameters(Object[] value);
    public NullValueHandling get_NullValueHandling();
    public void set_NullValueHandling(NullValueHandling value);
    public DefaultValueHandling get_DefaultValueHandling();
    public void set_DefaultValueHandling(DefaultValueHandling value);
    public ReferenceLoopHandling get_ReferenceLoopHandling();
    public void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public ObjectCreationHandling get_ObjectCreationHandling();
    public void set_ObjectCreationHandling(ObjectCreationHandling value);
    public TypeNameHandling get_TypeNameHandling();
    public void set_TypeNameHandling(TypeNameHandling value);
    public bool get_IsReference();
    public void set_IsReference(bool value);
    public int get_Order();
    public void set_Order(int value);
    public Required get_Required();
    public void set_Required(Required value);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(string value);
    public ReferenceLoopHandling get_ItemReferenceLoopHandling();
    public void set_ItemReferenceLoopHandling(ReferenceLoopHandling value);
    public TypeNameHandling get_ItemTypeNameHandling();
    public void set_ItemTypeNameHandling(TypeNameHandling value);
    public bool get_ItemIsReference();
    public void set_ItemIsReference(bool value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class Newtonsoft.Json.JsonReader : object {
    private JsonToken _tokenType;
    private object _value;
    internal char _quoteChar;
    internal State _currentState;
    private JsonPosition _currentPosition;
    private CultureInfo _culture;
    private DateTimeZoneHandling _dateTimeZoneHandling;
    private Nullable`1<int> _maxDepth;
    private bool _hasExceededMaxDepth;
    internal DateParseHandling _dateParseHandling;
    internal FloatParseHandling _floatParseHandling;
    private string _dateFormatString;
    private List`1<JsonPosition> _stack;
    [CompilerGeneratedAttribute]
private bool <CloseInput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportMultipleContent>k__BackingField;
    protected State CurrentState { get; }
    public bool CloseInput { get; public set; }
    public bool SupportMultipleContent { get; public set; }
    public char QuoteChar { get; protected internal set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    public string DateFormatString { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public JsonToken TokenType { get; }
    public object Value { get; }
    public Type ValueType { get; }
    public int Depth { get; }
    [NullableAttribute("1")]
public string Path { get; }
    [NullableAttribute("1")]
public CultureInfo Culture { get; public set; }
    [NullableContextAttribute("1")]
public virtual Task`1<bool> ReadAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Newtonsoft.Json.JsonReader/<SkipAsync>d__1")]
public Task SkipAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Newtonsoft.Json.JsonReader/<ReaderReadAndAssertAsync>d__2")]
internal Task ReaderReadAndAssertAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public virtual Task`1<Nullable`1<bool>> ReadAsBooleanAsync(CancellationToken cancellationToken);
    public virtual Task`1<Byte[]> ReadAsBytesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonReader/<ReadArrayIntoByteArrayAsync>d__5")]
internal Task`1<Byte[]> ReadArrayIntoByteArrayAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public virtual Task`1<Nullable`1<DateTime>> ReadAsDateTimeAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public virtual Task`1<Nullable`1<DateTimeOffset>> ReadAsDateTimeOffsetAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public virtual Task`1<Nullable`1<decimal>> ReadAsDecimalAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public virtual Task`1<Nullable`1<double>> ReadAsDoubleAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public virtual Task`1<Nullable`1<int>> ReadAsInt32Async(CancellationToken cancellationToken);
    public virtual Task`1<string> ReadAsStringAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Newtonsoft.Json.JsonReader/<ReadAndMoveToContentAsync>d__12")]
internal Task`1<bool> ReadAndMoveToContentAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
internal Task`1<bool> MoveToContentAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Newtonsoft.Json.JsonReader/<MoveToContentFromNonContentAsync>d__14")]
private Task`1<bool> MoveToContentFromNonContentAsync(CancellationToken cancellationToken);
    protected State get_CurrentState();
    [CompilerGeneratedAttribute]
public bool get_CloseInput();
    [CompilerGeneratedAttribute]
public void set_CloseInput(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportMultipleContent();
    [CompilerGeneratedAttribute]
public void set_SupportMultipleContent(bool value);
    public virtual char get_QuoteChar();
    protected internal virtual void set_QuoteChar(char value);
    public DateTimeZoneHandling get_DateTimeZoneHandling();
    public void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public DateParseHandling get_DateParseHandling();
    public void set_DateParseHandling(DateParseHandling value);
    public FloatParseHandling get_FloatParseHandling();
    public void set_FloatParseHandling(FloatParseHandling value);
    public string get_DateFormatString();
    public void set_DateFormatString(string value);
    public Nullable`1<int> get_MaxDepth();
    public void set_MaxDepth(Nullable`1<int> value);
    public virtual JsonToken get_TokenType();
    public virtual object get_Value();
    public virtual Type get_ValueType();
    public virtual int get_Depth();
    [NullableContextAttribute("1")]
public virtual string get_Path();
    [NullableContextAttribute("1")]
public CultureInfo get_Culture();
    [NullableContextAttribute("1")]
public void set_Culture(CultureInfo value);
    internal JsonPosition GetPosition(int depth);
    private void Push(JsonContainerType value);
    private JsonContainerType Pop();
    private JsonContainerType Peek();
    public abstract virtual bool Read();
    public virtual Nullable`1<int> ReadAsInt32();
    internal Nullable`1<int> ReadInt32String(string s);
    public virtual string ReadAsString();
    public virtual Byte[] ReadAsBytes();
    [NullableContextAttribute("1")]
internal Byte[] ReadArrayIntoByteArray();
    [NullableContextAttribute("1")]
private bool ReadArrayElementIntoByteArrayReportDone(List`1<byte> buffer);
    public virtual Nullable`1<double> ReadAsDouble();
    internal Nullable`1<double> ReadDoubleString(string s);
    public virtual Nullable`1<bool> ReadAsBoolean();
    internal Nullable`1<bool> ReadBooleanString(string s);
    public virtual Nullable`1<decimal> ReadAsDecimal();
    internal Nullable`1<decimal> ReadDecimalString(string s);
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    internal Nullable`1<DateTime> ReadDateTimeString(string s);
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    internal Nullable`1<DateTimeOffset> ReadDateTimeOffsetString(string s);
    internal void ReaderReadAndAssert();
    [NullableContextAttribute("1")]
internal JsonReaderException CreateUnexpectedEndException();
    internal void ReadIntoWrappedTypeObject();
    public void Skip();
    protected void SetToken(JsonToken newToken);
    protected void SetToken(JsonToken newToken, object value);
    protected void SetToken(JsonToken newToken, object value, bool updateIndex);
    internal void SetPostValueState(bool updateIndex);
    private void UpdateScopeWithFinishedValue();
    private void ValidateEnd(JsonToken endToken);
    protected void SetStateBasedOnCurrent();
    private void SetFinished();
    private JsonContainerType GetTypeForCloseToken(JsonToken token);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    internal void ReadAndAssert();
    internal void ReadForTypeAndAssert(JsonContract contract, bool hasConverter);
    internal bool ReadForType(JsonContract contract, bool hasConverter);
    internal bool ReadAndMoveToContent();
    internal bool MoveToContent();
    private JsonToken GetContentToken();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.JsonReaderException : JsonException {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public int LineNumber { get; }
    public int LinePosition { get; }
    [NullableAttribute("2")]
public string Path { get; }
    public JsonReaderException(string message);
    public JsonReaderException(string message, Exception innerException);
    public JsonReaderException(SerializationInfo info, StreamingContext context);
    public JsonReaderException(string message, string path, int lineNumber, int linePosition, Exception innerException);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Path();
    internal static JsonReaderException Create(JsonReader reader, string message);
    internal static JsonReaderException Create(JsonReader reader, string message, Exception ex);
    internal static JsonReaderException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex);
}
[AttributeUsageAttribute("384")]
public class Newtonsoft.Json.JsonRequiredAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.JsonSerializationException : JsonException {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public int LineNumber { get; }
    public int LinePosition { get; }
    [NullableAttribute("2")]
public string Path { get; }
    public JsonSerializationException(string message);
    public JsonSerializationException(string message, Exception innerException);
    public JsonSerializationException(SerializationInfo info, StreamingContext context);
    public JsonSerializationException(string message, string path, int lineNumber, int linePosition, Exception innerException);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Path();
    internal static JsonSerializationException Create(JsonReader reader, string message);
    internal static JsonSerializationException Create(JsonReader reader, string message, Exception ex);
    internal static JsonSerializationException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.JsonSerializer : object {
    internal TypeNameHandling _typeNameHandling;
    internal TypeNameAssemblyFormatHandling _typeNameAssemblyFormatHandling;
    internal PreserveReferencesHandling _preserveReferencesHandling;
    internal ReferenceLoopHandling _referenceLoopHandling;
    internal MissingMemberHandling _missingMemberHandling;
    internal ObjectCreationHandling _objectCreationHandling;
    internal NullValueHandling _nullValueHandling;
    internal DefaultValueHandling _defaultValueHandling;
    internal ConstructorHandling _constructorHandling;
    internal MetadataPropertyHandling _metadataPropertyHandling;
    [NullableAttribute("2")]
internal JsonConverterCollection _converters;
    internal IContractResolver _contractResolver;
    [NullableAttribute("2")]
internal ITraceWriter _traceWriter;
    [NullableAttribute("2")]
internal IEqualityComparer _equalityComparer;
    internal ISerializationBinder _serializationBinder;
    internal StreamingContext _context;
    [NullableAttribute("2")]
private IReferenceResolver _referenceResolver;
    private Nullable`1<Formatting> _formatting;
    private Nullable`1<DateFormatHandling> _dateFormatHandling;
    private Nullable`1<DateTimeZoneHandling> _dateTimeZoneHandling;
    private Nullable`1<DateParseHandling> _dateParseHandling;
    private Nullable`1<FloatFormatHandling> _floatFormatHandling;
    private Nullable`1<FloatParseHandling> _floatParseHandling;
    private Nullable`1<StringEscapeHandling> _stringEscapeHandling;
    private CultureInfo _culture;
    private Nullable`1<int> _maxDepth;
    private bool _maxDepthSet;
    private Nullable`1<bool> _checkAdditionalContent;
    [NullableAttribute("2")]
private string _dateFormatString;
    private bool _dateFormatStringSet;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ErrorEventArgs> Error;
    [NullableAttribute("2")]
public IReferenceResolver ReferenceResolver { get; public set; }
    [ObsoleteAttribute("Binder is obsolete. Use SerializationBinder instead.")]
public SerializationBinder Binder { get; public set; }
    public ISerializationBinder SerializationBinder { get; public set; }
    [NullableAttribute("2")]
public ITraceWriter TraceWriter { get; public set; }
    [NullableAttribute("2")]
public IEqualityComparer EqualityComparer { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    [ObsoleteAttribute("TypeNameAssemblyFormat is obsolete. Use TypeNameAssemblyFormatHandling instead.")]
public FormatterAssemblyStyle TypeNameAssemblyFormat { get; public set; }
    public TypeNameAssemblyFormatHandling TypeNameAssemblyFormatHandling { get; public set; }
    public PreserveReferencesHandling PreserveReferencesHandling { get; public set; }
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public ConstructorHandling ConstructorHandling { get; public set; }
    public MetadataPropertyHandling MetadataPropertyHandling { get; public set; }
    public JsonConverterCollection Converters { get; }
    public IContractResolver ContractResolver { get; public set; }
    public StreamingContext Context { get; public set; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    public string DateFormatString { get; public set; }
    public CultureInfo Culture { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public bool CheckAdditionalContent { get; public set; }
    [CompilerGeneratedAttribute]
public virtual void add_Error(EventHandler`1<ErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public virtual void remove_Error(EventHandler`1<ErrorEventArgs> value);
    [NullableContextAttribute("2")]
public virtual IReferenceResolver get_ReferenceResolver();
    [NullableContextAttribute("2")]
public virtual void set_ReferenceResolver(IReferenceResolver value);
    public virtual SerializationBinder get_Binder();
    public virtual void set_Binder(SerializationBinder value);
    public virtual ISerializationBinder get_SerializationBinder();
    public virtual void set_SerializationBinder(ISerializationBinder value);
    [NullableContextAttribute("2")]
public virtual ITraceWriter get_TraceWriter();
    [NullableContextAttribute("2")]
public virtual void set_TraceWriter(ITraceWriter value);
    [NullableContextAttribute("2")]
public virtual IEqualityComparer get_EqualityComparer();
    [NullableContextAttribute("2")]
public virtual void set_EqualityComparer(IEqualityComparer value);
    public virtual TypeNameHandling get_TypeNameHandling();
    public virtual void set_TypeNameHandling(TypeNameHandling value);
    public virtual FormatterAssemblyStyle get_TypeNameAssemblyFormat();
    public virtual void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value);
    public virtual TypeNameAssemblyFormatHandling get_TypeNameAssemblyFormatHandling();
    public virtual void set_TypeNameAssemblyFormatHandling(TypeNameAssemblyFormatHandling value);
    public virtual PreserveReferencesHandling get_PreserveReferencesHandling();
    public virtual void set_PreserveReferencesHandling(PreserveReferencesHandling value);
    public virtual ReferenceLoopHandling get_ReferenceLoopHandling();
    public virtual void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public virtual MissingMemberHandling get_MissingMemberHandling();
    public virtual void set_MissingMemberHandling(MissingMemberHandling value);
    public virtual NullValueHandling get_NullValueHandling();
    public virtual void set_NullValueHandling(NullValueHandling value);
    public virtual DefaultValueHandling get_DefaultValueHandling();
    public virtual void set_DefaultValueHandling(DefaultValueHandling value);
    public virtual ObjectCreationHandling get_ObjectCreationHandling();
    public virtual void set_ObjectCreationHandling(ObjectCreationHandling value);
    public virtual ConstructorHandling get_ConstructorHandling();
    public virtual void set_ConstructorHandling(ConstructorHandling value);
    public virtual MetadataPropertyHandling get_MetadataPropertyHandling();
    public virtual void set_MetadataPropertyHandling(MetadataPropertyHandling value);
    public virtual JsonConverterCollection get_Converters();
    public virtual IContractResolver get_ContractResolver();
    public virtual void set_ContractResolver(IContractResolver value);
    public virtual StreamingContext get_Context();
    public virtual void set_Context(StreamingContext value);
    public virtual Formatting get_Formatting();
    public virtual void set_Formatting(Formatting value);
    public virtual DateFormatHandling get_DateFormatHandling();
    public virtual void set_DateFormatHandling(DateFormatHandling value);
    public virtual DateTimeZoneHandling get_DateTimeZoneHandling();
    public virtual void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public virtual DateParseHandling get_DateParseHandling();
    public virtual void set_DateParseHandling(DateParseHandling value);
    public virtual FloatParseHandling get_FloatParseHandling();
    public virtual void set_FloatParseHandling(FloatParseHandling value);
    public virtual FloatFormatHandling get_FloatFormatHandling();
    public virtual void set_FloatFormatHandling(FloatFormatHandling value);
    public virtual StringEscapeHandling get_StringEscapeHandling();
    public virtual void set_StringEscapeHandling(StringEscapeHandling value);
    public virtual string get_DateFormatString();
    public virtual void set_DateFormatString(string value);
    public virtual CultureInfo get_Culture();
    public virtual void set_Culture(CultureInfo value);
    public virtual Nullable`1<int> get_MaxDepth();
    public virtual void set_MaxDepth(Nullable`1<int> value);
    public virtual bool get_CheckAdditionalContent();
    public virtual void set_CheckAdditionalContent(bool value);
    internal bool IsCheckAdditionalContentSet();
    public static JsonSerializer Create();
    public static JsonSerializer Create(JsonSerializerSettings settings);
    public static JsonSerializer CreateDefault();
    public static JsonSerializer CreateDefault(JsonSerializerSettings settings);
    private static void ApplySerializerSettings(JsonSerializer serializer, JsonSerializerSettings settings);
    [DebuggerStepThroughAttribute]
public void Populate(TextReader reader, object target);
    [DebuggerStepThroughAttribute]
public void Populate(JsonReader reader, object target);
    internal virtual void PopulateInternal(JsonReader reader, object target);
    [DebuggerStepThroughAttribute]
public object Deserialize(JsonReader reader);
    [DebuggerStepThroughAttribute]
public object Deserialize(TextReader reader, Type objectType);
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public T Deserialize(JsonReader reader);
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public object Deserialize(JsonReader reader, Type objectType);
    [NullableContextAttribute("2")]
internal virtual object DeserializeInternal(JsonReader reader, Type objectType);
    [NullableContextAttribute("2")]
internal void SetupReader(JsonReader reader, CultureInfo& previousCulture, Nullable`1& previousDateTimeZoneHandling, Nullable`1& previousDateParseHandling, Nullable`1& previousFloatParseHandling, Nullable`1& previousMaxDepth, String& previousDateFormatString);
    [NullableContextAttribute("2")]
private void ResetReader(JsonReader reader, CultureInfo previousCulture, Nullable`1<DateTimeZoneHandling> previousDateTimeZoneHandling, Nullable`1<DateParseHandling> previousDateParseHandling, Nullable`1<FloatParseHandling> previousFloatParseHandling, Nullable`1<int> previousMaxDepth, string previousDateFormatString);
    public void Serialize(TextWriter textWriter, object value);
    [NullableContextAttribute("2")]
public void Serialize(JsonWriter jsonWriter, object value, Type objectType);
    public void Serialize(TextWriter textWriter, object value, Type objectType);
    public void Serialize(JsonWriter jsonWriter, object value);
    private TraceJsonReader CreateTraceJsonReader(JsonReader reader);
    [NullableContextAttribute("2")]
internal virtual void SerializeInternal(JsonWriter jsonWriter, object value, Type objectType);
    internal IReferenceResolver GetReferenceResolver();
    internal JsonConverter GetMatchingConverter(Type type);
    internal static JsonConverter GetMatchingConverter(IList`1<JsonConverter> converters, Type objectType);
    internal void OnError(ErrorEventArgs e);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Newtonsoft.Json.JsonSerializerSettings : object {
    internal static ReferenceLoopHandling DefaultReferenceLoopHandling;
    internal static MissingMemberHandling DefaultMissingMemberHandling;
    internal static NullValueHandling DefaultNullValueHandling;
    internal static DefaultValueHandling DefaultDefaultValueHandling;
    internal static ObjectCreationHandling DefaultObjectCreationHandling;
    internal static PreserveReferencesHandling DefaultPreserveReferencesHandling;
    internal static ConstructorHandling DefaultConstructorHandling;
    internal static TypeNameHandling DefaultTypeNameHandling;
    internal static MetadataPropertyHandling DefaultMetadataPropertyHandling;
    internal static StreamingContext DefaultContext;
    internal static Formatting DefaultFormatting;
    internal static DateFormatHandling DefaultDateFormatHandling;
    internal static DateTimeZoneHandling DefaultDateTimeZoneHandling;
    internal static DateParseHandling DefaultDateParseHandling;
    internal static FloatParseHandling DefaultFloatParseHandling;
    internal static FloatFormatHandling DefaultFloatFormatHandling;
    internal static StringEscapeHandling DefaultStringEscapeHandling;
    internal static TypeNameAssemblyFormatHandling DefaultTypeNameAssemblyFormatHandling;
    [NullableAttribute("1")]
internal static CultureInfo DefaultCulture;
    internal static bool DefaultCheckAdditionalContent;
    [NullableAttribute("1")]
internal static string DefaultDateFormatString;
    internal static int DefaultMaxDepth;
    internal Nullable`1<Formatting> _formatting;
    internal Nullable`1<DateFormatHandling> _dateFormatHandling;
    internal Nullable`1<DateTimeZoneHandling> _dateTimeZoneHandling;
    internal Nullable`1<DateParseHandling> _dateParseHandling;
    internal Nullable`1<FloatFormatHandling> _floatFormatHandling;
    internal Nullable`1<FloatParseHandling> _floatParseHandling;
    internal Nullable`1<StringEscapeHandling> _stringEscapeHandling;
    internal CultureInfo _culture;
    internal Nullable`1<bool> _checkAdditionalContent;
    internal Nullable`1<int> _maxDepth;
    internal bool _maxDepthSet;
    internal string _dateFormatString;
    internal bool _dateFormatStringSet;
    internal Nullable`1<TypeNameAssemblyFormatHandling> _typeNameAssemblyFormatHandling;
    internal Nullable`1<DefaultValueHandling> _defaultValueHandling;
    internal Nullable`1<PreserveReferencesHandling> _preserveReferencesHandling;
    internal Nullable`1<NullValueHandling> _nullValueHandling;
    internal Nullable`1<ObjectCreationHandling> _objectCreationHandling;
    internal Nullable`1<MissingMemberHandling> _missingMemberHandling;
    internal Nullable`1<ReferenceLoopHandling> _referenceLoopHandling;
    internal Nullable`1<StreamingContext> _context;
    internal Nullable`1<ConstructorHandling> _constructorHandling;
    internal Nullable`1<TypeNameHandling> _typeNameHandling;
    internal Nullable`1<MetadataPropertyHandling> _metadataPropertyHandling;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IList`1<JsonConverter> <Converters>k__BackingField;
    [CompilerGeneratedAttribute]
private IContractResolver <ContractResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private IEqualityComparer <EqualityComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<IReferenceResolver> <ReferenceResolverProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ITraceWriter <TraceWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private ISerializationBinder <SerializationBinder>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ErrorEventArgs> <Error>k__BackingField;
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    [NullableAttribute("1")]
public IList`1<JsonConverter> Converters { get; public set; }
    public PreserveReferencesHandling PreserveReferencesHandling { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public MetadataPropertyHandling MetadataPropertyHandling { get; public set; }
    [ObsoleteAttribute("TypeNameAssemblyFormat is obsolete. Use TypeNameAssemblyFormatHandling instead.")]
public FormatterAssemblyStyle TypeNameAssemblyFormat { get; public set; }
    public TypeNameAssemblyFormatHandling TypeNameAssemblyFormatHandling { get; public set; }
    public ConstructorHandling ConstructorHandling { get; public set; }
    public IContractResolver ContractResolver { get; public set; }
    public IEqualityComparer EqualityComparer { get; public set; }
    [ObsoleteAttribute("ReferenceResolver property is obsolete. Use the ReferenceResolverProvider property to set the IReferenceResolver: settings.ReferenceResolverProvider = () => resolver")]
public IReferenceResolver ReferenceResolver { get; public set; }
    public Func`1<IReferenceResolver> ReferenceResolverProvider { get; public set; }
    public ITraceWriter TraceWriter { get; public set; }
    [ObsoleteAttribute("Binder is obsolete. Use SerializationBinder instead.")]
public SerializationBinder Binder { get; public set; }
    public ISerializationBinder SerializationBinder { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public EventHandler`1<ErrorEventArgs> Error { get; public set; }
    public StreamingContext Context { get; public set; }
    [NullableAttribute("1")]
public string DateFormatString { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    [NullableAttribute("1")]
public CultureInfo Culture { get; public set; }
    public bool CheckAdditionalContent { get; public set; }
    private static JsonSerializerSettings();
    [NullableContextAttribute("1")]
public JsonSerializerSettings(JsonSerializerSettings original);
    public ReferenceLoopHandling get_ReferenceLoopHandling();
    public void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public MissingMemberHandling get_MissingMemberHandling();
    public void set_MissingMemberHandling(MissingMemberHandling value);
    public ObjectCreationHandling get_ObjectCreationHandling();
    public void set_ObjectCreationHandling(ObjectCreationHandling value);
    public NullValueHandling get_NullValueHandling();
    public void set_NullValueHandling(NullValueHandling value);
    public DefaultValueHandling get_DefaultValueHandling();
    public void set_DefaultValueHandling(DefaultValueHandling value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IList`1<JsonConverter> get_Converters();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_Converters(IList`1<JsonConverter> value);
    public PreserveReferencesHandling get_PreserveReferencesHandling();
    public void set_PreserveReferencesHandling(PreserveReferencesHandling value);
    public TypeNameHandling get_TypeNameHandling();
    public void set_TypeNameHandling(TypeNameHandling value);
    public MetadataPropertyHandling get_MetadataPropertyHandling();
    public void set_MetadataPropertyHandling(MetadataPropertyHandling value);
    public FormatterAssemblyStyle get_TypeNameAssemblyFormat();
    public void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value);
    public TypeNameAssemblyFormatHandling get_TypeNameAssemblyFormatHandling();
    public void set_TypeNameAssemblyFormatHandling(TypeNameAssemblyFormatHandling value);
    public ConstructorHandling get_ConstructorHandling();
    public void set_ConstructorHandling(ConstructorHandling value);
    [CompilerGeneratedAttribute]
public IContractResolver get_ContractResolver();
    [CompilerGeneratedAttribute]
public void set_ContractResolver(IContractResolver value);
    [CompilerGeneratedAttribute]
public IEqualityComparer get_EqualityComparer();
    [CompilerGeneratedAttribute]
public void set_EqualityComparer(IEqualityComparer value);
    public IReferenceResolver get_ReferenceResolver();
    public void set_ReferenceResolver(IReferenceResolver value);
    [CompilerGeneratedAttribute]
public Func`1<IReferenceResolver> get_ReferenceResolverProvider();
    [CompilerGeneratedAttribute]
public void set_ReferenceResolverProvider(Func`1<IReferenceResolver> value);
    [CompilerGeneratedAttribute]
public ITraceWriter get_TraceWriter();
    [CompilerGeneratedAttribute]
public void set_TraceWriter(ITraceWriter value);
    public SerializationBinder get_Binder();
    public void set_Binder(SerializationBinder value);
    [CompilerGeneratedAttribute]
public ISerializationBinder get_SerializationBinder();
    [CompilerGeneratedAttribute]
public void set_SerializationBinder(ISerializationBinder value);
    [CompilerGeneratedAttribute]
public EventHandler`1<ErrorEventArgs> get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(EventHandler`1<ErrorEventArgs> value);
    public StreamingContext get_Context();
    public void set_Context(StreamingContext value);
    [NullableContextAttribute("1")]
public string get_DateFormatString();
    [NullableContextAttribute("1")]
public void set_DateFormatString(string value);
    public Nullable`1<int> get_MaxDepth();
    public void set_MaxDepth(Nullable`1<int> value);
    public Formatting get_Formatting();
    public void set_Formatting(Formatting value);
    public DateFormatHandling get_DateFormatHandling();
    public void set_DateFormatHandling(DateFormatHandling value);
    public DateTimeZoneHandling get_DateTimeZoneHandling();
    public void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public DateParseHandling get_DateParseHandling();
    public void set_DateParseHandling(DateParseHandling value);
    public FloatFormatHandling get_FloatFormatHandling();
    public void set_FloatFormatHandling(FloatFormatHandling value);
    public FloatParseHandling get_FloatParseHandling();
    public void set_FloatParseHandling(FloatParseHandling value);
    public StringEscapeHandling get_StringEscapeHandling();
    public void set_StringEscapeHandling(StringEscapeHandling value);
    [NullableContextAttribute("1")]
public CultureInfo get_Culture();
    [NullableContextAttribute("1")]
public void set_Culture(CultureInfo value);
    public bool get_CheckAdditionalContent();
    public void set_CheckAdditionalContent(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.JsonTextReader : JsonReader {
    private bool _safeAsync;
    private static char UnicodeReplacementChar;
    private static int MaximumJavascriptIntegerCharacterLength;
    private static int LargeBufferLength;
    private TextReader _reader;
    [NullableAttribute("2")]
private Char[] _chars;
    private int _charsUsed;
    private int _charPos;
    private int _lineStartPos;
    private int _lineNumber;
    private bool _isEndOfFile;
    private StringBuffer _stringBuffer;
    private StringReference _stringReference;
    [NullableAttribute("2")]
private IArrayPool`1<char> _arrayPool;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonNameTable <PropertyNameTable>k__BackingField;
    [NullableAttribute("2")]
public JsonNameTable PropertyNameTable { get; public set; }
    [NullableAttribute("2")]
public IArrayPool`1<char> ArrayPool { get; public set; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    public JsonTextReader(TextReader reader);
    public virtual Task`1<bool> ReadAsync(CancellationToken cancellationToken);
    internal Task`1<bool> DoReadAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<DoReadAsync>d__3")]
private Task`1<bool> DoReadAsync(Task`1<bool> task, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParsePostValueAsync>d__4")]
private Task`1<bool> ParsePostValueAsync(bool ignoreComments, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadFromFinishedAsync>d__5")]
private Task`1<bool> ReadFromFinishedAsync(CancellationToken cancellationToken);
    private Task`1<int> ReadDataAsync(bool append, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadDataAsync>d__7")]
private Task`1<int> ReadDataAsync(bool append, int charsRequired, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseValueAsync>d__8")]
private Task`1<bool> ParseValueAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadStringIntoBufferAsync>d__9")]
private Task ReadStringIntoBufferAsync(char quote, CancellationToken cancellationToken);
    private Task ProcessCarriageReturnAsync(bool append, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ProcessCarriageReturnAsync>d__11")]
private Task ProcessCarriageReturnAsync(Task`1<bool> task);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseUnicodeAsync>d__12")]
private Task`1<char> ParseUnicodeAsync(CancellationToken cancellationToken);
    private Task`1<bool> EnsureCharsAsync(int relativePosition, bool append, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadCharsAsync>d__14")]
private Task`1<bool> ReadCharsAsync(int relativePosition, bool append, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseObjectAsync>d__15")]
private Task`1<bool> ParseObjectAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseCommentAsync>d__16")]
private Task ParseCommentAsync(bool setToken, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<EatWhitespaceAsync>d__17")]
private Task EatWhitespaceAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseStringAsync>d__18")]
private Task ParseStringAsync(char quote, ReadType readType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<MatchValueAsync>d__19")]
private Task`1<bool> MatchValueAsync(string value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<MatchValueWithTrailingSeparatorAsync>d__20")]
private Task`1<bool> MatchValueWithTrailingSeparatorAsync(string value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<MatchAndSetAsync>d__21")]
private Task MatchAndSetAsync(string value, JsonToken newToken, object tokenValue, CancellationToken cancellationToken);
    private Task ParseTrueAsync(CancellationToken cancellationToken);
    private Task ParseFalseAsync(CancellationToken cancellationToken);
    private Task ParseNullAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseConstructorAsync>d__25")]
private Task ParseConstructorAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseNumberNaNAsync>d__26")]
private Task`1<object> ParseNumberNaNAsync(ReadType readType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseNumberPositiveInfinityAsync>d__27")]
private Task`1<object> ParseNumberPositiveInfinityAsync(ReadType readType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseNumberNegativeInfinityAsync>d__28")]
private Task`1<object> ParseNumberNegativeInfinityAsync(ReadType readType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseNumberAsync>d__29")]
private Task ParseNumberAsync(ReadType readType, CancellationToken cancellationToken);
    private Task ParseUndefinedAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParsePropertyAsync>d__31")]
private Task`1<bool> ParsePropertyAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadNumberIntoBufferAsync>d__32")]
private Task ReadNumberIntoBufferAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseUnquotedPropertyAsync>d__33")]
private Task ParseUnquotedPropertyAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadNullCharAsync>d__34")]
private Task`1<bool> ReadNullCharAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<HandleNullAsync>d__35")]
private Task HandleNullAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadFinishedAsync>d__36")]
private Task ReadFinishedAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadStringValueAsync>d__37")]
private Task`1<object> ReadStringValueAsync(ReadType readType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadNumberValueAsync>d__38")]
private Task`1<object> ReadNumberValueAsync(ReadType readType, CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<bool>> ReadAsBooleanAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<DoReadAsBooleanAsync>d__40")]
internal Task`1<Nullable`1<bool>> DoReadAsBooleanAsync(CancellationToken cancellationToken);
    public virtual Task`1<Byte[]> ReadAsBytesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<DoReadAsBytesAsync>d__42")]
internal Task`1<Byte[]> DoReadAsBytesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadIntoWrappedTypeObjectAsync>d__43")]
private Task ReadIntoWrappedTypeObjectAsync(CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<DateTime>> ReadAsDateTimeAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<DoReadAsDateTimeAsync>d__45")]
internal Task`1<Nullable`1<DateTime>> DoReadAsDateTimeAsync(CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<DateTimeOffset>> ReadAsDateTimeOffsetAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<DoReadAsDateTimeOffsetAsync>d__47")]
internal Task`1<Nullable`1<DateTimeOffset>> DoReadAsDateTimeOffsetAsync(CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<decimal>> ReadAsDecimalAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<DoReadAsDecimalAsync>d__49")]
internal Task`1<Nullable`1<decimal>> DoReadAsDecimalAsync(CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<double>> ReadAsDoubleAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<DoReadAsDoubleAsync>d__51")]
internal Task`1<Nullable`1<double>> DoReadAsDoubleAsync(CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<int>> ReadAsInt32Async(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<DoReadAsInt32Async>d__53")]
internal Task`1<Nullable`1<int>> DoReadAsInt32Async(CancellationToken cancellationToken);
    public virtual Task`1<string> ReadAsStringAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<DoReadAsStringAsync>d__55")]
internal Task`1<string> DoReadAsStringAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public JsonNameTable get_PropertyNameTable();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_PropertyNameTable(JsonNameTable value);
    [NullableContextAttribute("2")]
public IArrayPool`1<char> get_ArrayPool();
    [NullableContextAttribute("2")]
public void set_ArrayPool(IArrayPool`1<char> value);
    private void EnsureBufferNotEmpty();
    private void SetNewLine(bool hasNextChar);
    private void OnNewLine(int pos);
    private void ParseString(char quote, ReadType readType);
    private void ParseReadString(char quote, ReadType readType);
    private static void BlockCopyChars(Char[] src, int srcOffset, Char[] dst, int dstOffset, int count);
    private void ShiftBufferIfNeeded();
    private int ReadData(bool append);
    private void PrepareBufferForReadData(bool append, int charsRequired);
    private int ReadData(bool append, int charsRequired);
    private bool EnsureChars(int relativePosition, bool append);
    private bool ReadChars(int relativePosition, bool append);
    public virtual bool Read();
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    [NullableContextAttribute("2")]
public virtual string ReadAsString();
    [NullableContextAttribute("2")]
public virtual Byte[] ReadAsBytes();
    [NullableContextAttribute("2")]
private object ReadStringValue(ReadType readType);
    [NullableContextAttribute("2")]
private object FinishReadQuotedStringValue(ReadType readType);
    private JsonReaderException CreateUnexpectedCharacterException(char c);
    public virtual Nullable`1<bool> ReadAsBoolean();
    private void ProcessValueComma();
    [NullableContextAttribute("2")]
private object ReadNumberValue(ReadType readType);
    [NullableContextAttribute("2")]
private object FinishReadQuotedNumber(ReadType readType);
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<double> ReadAsDouble();
    private void HandleNull();
    private void ReadFinished();
    private bool ReadNullChar();
    private void EnsureBuffer();
    private void ReadStringIntoBuffer(char quote);
    private void FinishReadStringIntoBuffer(int charPos, int initialPosition, int lastWritePosition);
    private void WriteCharToBuffer(char writeChar, int lastWritePosition, int writeToPosition);
    private char ConvertUnicode(bool enoughChars);
    private char ParseUnicode();
    private void ReadNumberIntoBuffer();
    private bool ReadNumberCharIntoBuffer(char currentChar, int charPos);
    private void ClearRecentString();
    private bool ParsePostValue(bool ignoreComments);
    private bool ParseObject();
    private bool ParseProperty();
    private bool ValidIdentifierChar(char value);
    private void ParseUnquotedProperty();
    private bool ReadUnquotedPropertyReportIfDone(char currentChar, int initialPosition);
    private bool ParseValue();
    private void ProcessLineFeed();
    private void ProcessCarriageReturn(bool append);
    private void EatWhitespace();
    private void ParseConstructor();
    private void ParseNumber(ReadType readType);
    private void ParseReadNumber(ReadType readType, char firstChar, int initialPosition);
    private JsonReaderException ThrowReaderError(string message, Exception ex);
    private static object BigIntegerParse(string number, CultureInfo culture);
    private void ParseComment(bool setToken);
    private void EndComment(bool setToken, int initialPosition, int endPosition);
    private bool MatchValue(string value);
    private bool MatchValue(bool enoughChars, string value);
    private bool MatchValueWithTrailingSeparator(string value);
    private bool IsSeparator(char c);
    private void ParseTrue();
    private void ParseNull();
    private void ParseUndefined();
    private void ParseFalse();
    private object ParseNumberNegativeInfinity(ReadType readType);
    private object ParseNumberNegativeInfinity(ReadType readType, bool matched);
    private object ParseNumberPositiveInfinity(ReadType readType);
    private object ParseNumberPositiveInfinity(ReadType readType, bool matched);
    private object ParseNumberNaN(ReadType readType);
    private object ParseNumberNaN(ReadType readType, bool matched);
    public virtual void Close();
    public sealed virtual bool HasLineInfo();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.JsonTextWriter : JsonWriter {
    private bool _safeAsync;
    private static int IndentCharBufferSize;
    private TextWriter _writer;
    [NullableAttribute("2")]
private Base64Encoder _base64Encoder;
    private char _indentChar;
    private int _indentation;
    private char _quoteChar;
    private bool _quoteName;
    [NullableAttribute("2")]
private Boolean[] _charEscapeFlags;
    [NullableAttribute("2")]
private Char[] _writeBuffer;
    [NullableAttribute("2")]
private IArrayPool`1<char> _arrayPool;
    [NullableAttribute("2")]
private Char[] _indentChars;
    private Base64Encoder Base64Encoder { get; }
    [NullableAttribute("2")]
public IArrayPool`1<char> ArrayPool { get; public set; }
    public int Indentation { get; public set; }
    public char QuoteChar { get; public set; }
    public char IndentChar { get; public set; }
    public bool QuoteName { get; public set; }
    public JsonTextWriter(TextWriter textWriter);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    internal Task DoFlushAsync(CancellationToken cancellationToken);
    protected virtual Task WriteValueDelimiterAsync(CancellationToken cancellationToken);
    internal Task DoWriteValueDelimiterAsync(CancellationToken cancellationToken);
    protected virtual Task WriteEndAsync(JsonToken token, CancellationToken cancellationToken);
    internal Task DoWriteEndAsync(JsonToken token, CancellationToken cancellationToken);
    public virtual Task CloseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoCloseAsync>d__8")]
internal Task DoCloseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<CloseBufferAndWriterAsync>d__9")]
private Task CloseBufferAndWriterAsync();
    public virtual Task WriteEndAsync(CancellationToken cancellationToken);
    protected virtual Task WriteIndentAsync(CancellationToken cancellationToken);
    internal Task DoWriteIndentAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<WriteIndentAsync>d__13")]
private Task WriteIndentAsync(int currentIndentCount, int newLineLen, CancellationToken cancellationToken);
    private Task WriteValueInternalAsync(JsonToken token, string value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<WriteValueInternalAsync>d__15")]
private Task WriteValueInternalAsync(Task task, string value, CancellationToken cancellationToken);
    protected virtual Task WriteIndentSpaceAsync(CancellationToken cancellationToken);
    internal Task DoWriteIndentSpaceAsync(CancellationToken cancellationToken);
    public virtual Task WriteRawAsync(string json, CancellationToken cancellationToken);
    internal Task DoWriteRawAsync(string json, CancellationToken cancellationToken);
    public virtual Task WriteNullAsync(CancellationToken cancellationToken);
    internal Task DoWriteNullAsync(CancellationToken cancellationToken);
    private Task WriteDigitsAsync(ulong uvalue, bool negative, CancellationToken cancellationToken);
    private Task WriteIntegerValueAsync(ulong uvalue, bool negative, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<WriteIntegerValueAsync>d__24")]
private Task WriteIntegerValueAsync(Task task, ulong uvalue, bool negative, CancellationToken cancellationToken);
    internal Task WriteIntegerValueAsync(long value, CancellationToken cancellationToken);
    internal Task WriteIntegerValueAsync(ulong uvalue, CancellationToken cancellationToken);
    private Task WriteEscapedStringAsync(string value, bool quote, CancellationToken cancellationToken);
    public virtual Task WritePropertyNameAsync(string name, CancellationToken cancellationToken);
    internal Task DoWritePropertyNameAsync(string name, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWritePropertyNameAsync>d__30")]
private Task DoWritePropertyNameAsync(Task task, string name, CancellationToken cancellationToken);
    public virtual Task WritePropertyNameAsync(string name, bool escape, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWritePropertyNameAsync>d__32")]
internal Task DoWritePropertyNameAsync(string name, bool escape, CancellationToken cancellationToken);
    public virtual Task WriteStartArrayAsync(CancellationToken cancellationToken);
    internal Task DoWriteStartArrayAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteStartArrayAsync>d__35")]
internal Task DoWriteStartArrayAsync(Task task, CancellationToken cancellationToken);
    public virtual Task WriteStartObjectAsync(CancellationToken cancellationToken);
    internal Task DoWriteStartObjectAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteStartObjectAsync>d__38")]
internal Task DoWriteStartObjectAsync(Task task, CancellationToken cancellationToken);
    public virtual Task WriteStartConstructorAsync(string name, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteStartConstructorAsync>d__40")]
internal Task DoWriteStartConstructorAsync(string name, CancellationToken cancellationToken);
    public virtual Task WriteUndefinedAsync(CancellationToken cancellationToken);
    internal Task DoWriteUndefinedAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteUndefinedAsync>d__43")]
private Task DoWriteUndefinedAsync(Task task, CancellationToken cancellationToken);
    public virtual Task WriteWhitespaceAsync(string ws, CancellationToken cancellationToken);
    internal Task DoWriteWhitespaceAsync(string ws, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(bool value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(bool value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<bool> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<bool> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(byte value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<byte> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<byte> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Byte[] value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<WriteValueNonNullAsync>d__54")]
internal Task WriteValueNonNullAsync(Byte[] value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(char value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(char value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<char> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<char> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(DateTime value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteValueAsync>d__60")]
internal Task DoWriteValueAsync(DateTime value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<DateTime> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<DateTime> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(DateTimeOffset value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteValueAsync>d__64")]
internal Task DoWriteValueAsync(DateTimeOffset value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<DateTimeOffset> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<DateTimeOffset> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(decimal value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(decimal value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<decimal> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<decimal> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(double value, CancellationToken cancellationToken);
    internal Task WriteValueAsync(double value, bool nullable, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<double> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(float value, CancellationToken cancellationToken);
    internal Task WriteValueAsync(float value, bool nullable, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<float> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Guid value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteValueAsync>d__78")]
internal Task DoWriteValueAsync(Guid value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<Guid> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<Guid> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(int value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<int> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<int> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(long value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<long> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<long> value, CancellationToken cancellationToken);
    internal Task WriteValueAsync(BigInteger value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(object value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(sbyte value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<sbyte> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<sbyte> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(short value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<short> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<short> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(string value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(string value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteValueAsync>d__97")]
private Task DoWriteValueAsync(Task task, string value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(TimeSpan value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteValueAsync>d__99")]
internal Task DoWriteValueAsync(TimeSpan value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<TimeSpan> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<TimeSpan> value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(UInt32 value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<UInt32> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<UInt32> value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(ulong value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<ulong> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<ulong> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Uri value, CancellationToken cancellationToken);
    internal Task WriteValueNotNullAsync(Uri value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<WriteValueNotNullAsync>d__110")]
internal Task WriteValueNotNullAsync(Task task, Uri value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(ushort value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<ushort> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<ushort> value, CancellationToken cancellationToken);
    public virtual Task WriteCommentAsync(string text, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteCommentAsync>d__115")]
internal Task DoWriteCommentAsync(string text, CancellationToken cancellationToken);
    public virtual Task WriteEndArrayAsync(CancellationToken cancellationToken);
    public virtual Task WriteEndConstructorAsync(CancellationToken cancellationToken);
    public virtual Task WriteEndObjectAsync(CancellationToken cancellationToken);
    public virtual Task WriteRawValueAsync(string json, CancellationToken cancellationToken);
    internal Task DoWriteRawValueAsync(string json, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteRawValueAsync>d__121")]
private Task DoWriteRawValueAsync(Task task, string json, CancellationToken cancellationToken);
    internal Char[] EnsureWriteBuffer(int length, int copyTo);
    private Base64Encoder get_Base64Encoder();
    [NullableContextAttribute("2")]
public IArrayPool`1<char> get_ArrayPool();
    [NullableContextAttribute("2")]
public void set_ArrayPool(IArrayPool`1<char> value);
    public int get_Indentation();
    public void set_Indentation(int value);
    public char get_QuoteChar();
    public void set_QuoteChar(char value);
    public char get_IndentChar();
    public void set_IndentChar(char value);
    public bool get_QuoteName();
    public void set_QuoteName(bool value);
    public virtual void Flush();
    public virtual void Close();
    private void CloseBufferAndWriter();
    public virtual void WriteStartObject();
    public virtual void WriteStartArray();
    public virtual void WriteStartConstructor(string name);
    protected virtual void WriteEnd(JsonToken token);
    public virtual void WritePropertyName(string name);
    public virtual void WritePropertyName(string name, bool escape);
    internal virtual void OnStringEscapeHandlingChanged();
    private void UpdateCharEscapeFlags();
    protected virtual void WriteIndent();
    private int SetIndentChars();
    protected virtual void WriteValueDelimiter();
    protected virtual void WriteIndentSpace();
    private void WriteValueInternal(string value, JsonToken token);
    [NullableContextAttribute("2")]
public virtual void WriteValue(object value);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    [NullableContextAttribute("2")]
public virtual void WriteRaw(string json);
    [NullableContextAttribute("2")]
public virtual void WriteValue(string value);
    private void WriteEscapedString(string value, bool quote);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(Nullable`1<float> value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(Nullable`1<double> value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    private int WriteValueToBuffer(DateTime value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(DateTimeOffset value);
    private int WriteValueToBuffer(DateTimeOffset value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(Uri value);
    [NullableContextAttribute("2")]
public virtual void WriteComment(string text);
    public virtual void WriteWhitespace(string ws);
    private void EnsureWriteBuffer();
    private void WriteIntegerValue(long value);
    private void WriteIntegerValue(ulong value, bool negative);
    private int WriteNumberToBuffer(ulong value, bool negative);
    private void WriteIntegerValue(int value);
    private void WriteIntegerValue(UInt32 value, bool negative);
    private int WriteNumberToBuffer(UInt32 value, bool negative);
}
public enum Newtonsoft.Json.JsonToken : Enum {
    public int value__;
    public static JsonToken None;
    public static JsonToken StartObject;
    public static JsonToken StartArray;
    public static JsonToken StartConstructor;
    public static JsonToken PropertyName;
    public static JsonToken Comment;
    public static JsonToken Raw;
    public static JsonToken Integer;
    public static JsonToken Float;
    public static JsonToken String;
    public static JsonToken Boolean;
    public static JsonToken Null;
    public static JsonToken Undefined;
    public static JsonToken EndObject;
    public static JsonToken EndArray;
    public static JsonToken EndConstructor;
    public static JsonToken Date;
    public static JsonToken Bytes;
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
public class Newtonsoft.Json.JsonValidatingReader : JsonReader {
    private JsonReader _reader;
    private Stack`1<SchemaScope> _stack;
    private JsonSchema _schema;
    private JsonSchemaModel _model;
    private SchemaScope _currentScope;
    [CompilerGeneratedAttribute]
private ValidationEventHandler ValidationEventHandler;
    private static IList`1<JsonSchemaModel> EmptySchemaList;
    public object Value { get; }
    public int Depth { get; }
    public string Path { get; }
    public char QuoteChar { get; protected internal set; }
    public JsonToken TokenType { get; }
    public Type ValueType { get; }
    private IList`1<JsonSchemaModel> CurrentSchemas { get; }
    private IList`1<JsonSchemaModel> CurrentMemberSchemas { get; }
    public JsonSchema Schema { get; public set; }
    public JsonReader Reader { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    public JsonValidatingReader(JsonReader reader);
    private static JsonValidatingReader();
    [CompilerGeneratedAttribute]
public void add_ValidationEventHandler(ValidationEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ValidationEventHandler(ValidationEventHandler value);
    public virtual object get_Value();
    public virtual int get_Depth();
    public virtual string get_Path();
    public virtual char get_QuoteChar();
    protected internal virtual void set_QuoteChar(char value);
    public virtual JsonToken get_TokenType();
    public virtual Type get_ValueType();
    private void Push(SchemaScope scope);
    private SchemaScope Pop();
    private IList`1<JsonSchemaModel> get_CurrentSchemas();
    private IList`1<JsonSchemaModel> get_CurrentMemberSchemas();
    private void RaiseError(string message, JsonSchemaModel schema);
    private void OnValidationEvent(JsonSchemaException exception);
    public JsonSchema get_Schema();
    public void set_Schema(JsonSchema value);
    public JsonReader get_Reader();
    public virtual void Close();
    private void ValidateNotDisallowed(JsonSchemaModel schema);
    private Nullable`1<JsonSchemaType> GetCurrentNodeSchemaType();
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual Byte[] ReadAsBytes();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<double> ReadAsDouble();
    public virtual Nullable`1<bool> ReadAsBoolean();
    public virtual string ReadAsString();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    public virtual bool Read();
    private void ValidateCurrentToken();
    private void WriteToken(IList`1<JsonSchemaModel> schemas);
    private void ValidateEndObject(JsonSchemaModel schema);
    private void ValidateEndArray(JsonSchemaModel schema);
    private void ValidateNull(JsonSchemaModel schema);
    private void ValidateBoolean(JsonSchemaModel schema);
    private void ValidateString(JsonSchemaModel schema);
    private void ValidateInteger(JsonSchemaModel schema);
    private void ProcessValue();
    private void ValidateFloat(JsonSchemaModel schema);
    private static double FloatingPointRemainder(double dividend, double divisor);
    private static bool IsZero(double value);
    private void ValidatePropertyName(JsonSchemaModel schema);
    private bool IsPropertyDefinied(JsonSchemaModel schema, string propertyName);
    private bool ValidateArray(JsonSchemaModel schema);
    private bool ValidateObject(JsonSchemaModel schema);
    private bool TestType(JsonSchemaModel currentSchema, JsonSchemaType currentType);
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Newtonsoft.Json.JsonWriter : object {
    private static State[][] StateArray;
    internal static State[][] StateArrayTemplate;
    [NullableAttribute("2")]
private List`1<JsonPosition> _stack;
    private JsonPosition _currentPosition;
    private State _currentState;
    private Formatting _formatting;
    [CompilerGeneratedAttribute]
private bool <CloseOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoCompleteOnClose>k__BackingField;
    private DateFormatHandling _dateFormatHandling;
    private DateTimeZoneHandling _dateTimeZoneHandling;
    private StringEscapeHandling _stringEscapeHandling;
    private FloatFormatHandling _floatFormatHandling;
    [NullableAttribute("2")]
private string _dateFormatString;
    [NullableAttribute("2")]
private CultureInfo _culture;
    public bool CloseOutput { get; public set; }
    public bool AutoCompleteOnClose { get; public set; }
    protected internal int Top { get; }
    public WriteState WriteState { get; }
    internal string ContainerPath { get; }
    public string Path { get; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    [NullableAttribute("2")]
public string DateFormatString { get; public set; }
    public CultureInfo Culture { get; public set; }
    private static JsonWriter();
    internal Task AutoCompleteAsync(JsonToken tokenBeingWritten, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonWriter/<AutoCompleteAsync>d__1")]
private Task AutoCompleteAsync(CancellationToken cancellationToken);
    public virtual Task CloseAsync(CancellationToken cancellationToken);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    protected virtual Task WriteEndAsync(JsonToken token, CancellationToken cancellationToken);
    protected virtual Task WriteIndentAsync(CancellationToken cancellationToken);
    protected virtual Task WriteValueDelimiterAsync(CancellationToken cancellationToken);
    protected virtual Task WriteIndentSpaceAsync(CancellationToken cancellationToken);
    public virtual Task WriteRawAsync(string json, CancellationToken cancellationToken);
    public virtual Task WriteEndAsync(CancellationToken cancellationToken);
    internal Task WriteEndInternalAsync(CancellationToken cancellationToken);
    internal Task InternalWriteEndAsync(JsonContainerType type, CancellationToken cancellationToken);
    public virtual Task WriteEndArrayAsync(CancellationToken cancellationToken);
    public virtual Task WriteEndConstructorAsync(CancellationToken cancellationToken);
    public virtual Task WriteEndObjectAsync(CancellationToken cancellationToken);
    public virtual Task WriteNullAsync(CancellationToken cancellationToken);
    public virtual Task WritePropertyNameAsync(string name, CancellationToken cancellationToken);
    public virtual Task WritePropertyNameAsync(string name, bool escape, CancellationToken cancellationToken);
    internal Task InternalWritePropertyNameAsync(string name, CancellationToken cancellationToken);
    public virtual Task WriteStartArrayAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonWriter/<InternalWriteStartAsync>d__20")]
internal Task InternalWriteStartAsync(JsonToken token, JsonContainerType container, CancellationToken cancellationToken);
    public virtual Task WriteCommentAsync(string text, CancellationToken cancellationToken);
    internal Task InternalWriteCommentAsync(CancellationToken cancellationToken);
    public virtual Task WriteRawValueAsync(string json, CancellationToken cancellationToken);
    public virtual Task WriteStartConstructorAsync(string name, CancellationToken cancellationToken);
    public virtual Task WriteStartObjectAsync(CancellationToken cancellationToken);
    public Task WriteTokenAsync(JsonReader reader, CancellationToken cancellationToken);
    public Task WriteTokenAsync(JsonReader reader, bool writeChildren, CancellationToken cancellationToken);
    public Task WriteTokenAsync(JsonToken token, CancellationToken cancellationToken);
    public Task WriteTokenAsync(JsonToken token, object value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonWriter/<WriteTokenAsync>d__30")]
internal virtual Task WriteTokenAsync(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonWriter/<WriteTokenSyncReadingAsync>d__31")]
internal Task WriteTokenSyncReadingAsync(JsonReader reader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonWriter/<WriteConstructorDateAsync>d__32")]
private Task WriteConstructorDateAsync(JsonReader reader, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(bool value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<bool> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(byte value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<byte> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Byte[] value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(char value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<char> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(DateTime value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<DateTime> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(DateTimeOffset value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<DateTimeOffset> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(decimal value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<decimal> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(double value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<double> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(float value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<float> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Guid value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<Guid> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(int value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<int> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(long value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<long> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(object value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(sbyte value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<sbyte> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(short value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<short> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(string value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(TimeSpan value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<TimeSpan> value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(UInt32 value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<UInt32> value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(ulong value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<ulong> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Uri value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(ushort value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<ushort> value, CancellationToken cancellationToken);
    public virtual Task WriteUndefinedAsync(CancellationToken cancellationToken);
    public virtual Task WriteWhitespaceAsync(string ws, CancellationToken cancellationToken);
    internal Task InternalWriteValueAsync(JsonToken token, CancellationToken cancellationToken);
    protected Task SetWriteStateAsync(JsonToken token, object value, CancellationToken cancellationToken);
    internal static Task WriteValueAsync(JsonWriter writer, PrimitiveTypeCode typeCode, object value, CancellationToken cancellationToken);
    internal static State[][] BuildStateArray();
    [CompilerGeneratedAttribute]
public bool get_CloseOutput();
    [CompilerGeneratedAttribute]
public void set_CloseOutput(bool value);
    [CompilerGeneratedAttribute]
public bool get_AutoCompleteOnClose();
    [CompilerGeneratedAttribute]
public void set_AutoCompleteOnClose(bool value);
    protected internal int get_Top();
    public WriteState get_WriteState();
    internal string get_ContainerPath();
    public string get_Path();
    public Formatting get_Formatting();
    public void set_Formatting(Formatting value);
    public DateFormatHandling get_DateFormatHandling();
    public void set_DateFormatHandling(DateFormatHandling value);
    public DateTimeZoneHandling get_DateTimeZoneHandling();
    public void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public StringEscapeHandling get_StringEscapeHandling();
    public void set_StringEscapeHandling(StringEscapeHandling value);
    internal virtual void OnStringEscapeHandlingChanged();
    public FloatFormatHandling get_FloatFormatHandling();
    public void set_FloatFormatHandling(FloatFormatHandling value);
    [NullableContextAttribute("2")]
public string get_DateFormatString();
    [NullableContextAttribute("2")]
public void set_DateFormatString(string value);
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    internal void UpdateScopeWithFinishedValue();
    private void Push(JsonContainerType value);
    private JsonContainerType Pop();
    private JsonContainerType Peek();
    public abstract virtual void Flush();
    public virtual void Close();
    public virtual void WriteStartObject();
    public virtual void WriteEndObject();
    public virtual void WriteStartArray();
    public virtual void WriteEndArray();
    public virtual void WriteStartConstructor(string name);
    public virtual void WriteEndConstructor();
    public virtual void WritePropertyName(string name);
    public virtual void WritePropertyName(string name, bool escape);
    public virtual void WriteEnd();
    public void WriteToken(JsonReader reader);
    public void WriteToken(JsonReader reader, bool writeChildren);
    [NullableContextAttribute("2")]
public void WriteToken(JsonToken token, object value);
    public void WriteToken(JsonToken token);
    internal virtual void WriteToken(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments);
    private bool IsWriteTokenIncomplete(JsonReader reader, bool writeChildren, int initialDepth);
    private int CalculateWriteTokenInitialDepth(JsonReader reader);
    private int CalculateWriteTokenFinalDepth(JsonReader reader);
    private void WriteConstructorDate(JsonReader reader);
    private void WriteEnd(JsonContainerType type);
    private void AutoCompleteAll();
    private JsonToken GetCloseTokenForType(JsonContainerType type);
    private void AutoCompleteClose(JsonContainerType type);
    private int CalculateLevelsToComplete(JsonContainerType type);
    private void UpdateCurrentState();
    protected virtual void WriteEnd(JsonToken token);
    protected virtual void WriteIndent();
    protected virtual void WriteValueDelimiter();
    protected virtual void WriteIndentSpace();
    internal void AutoComplete(JsonToken tokenBeingWritten);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    [NullableContextAttribute("2")]
public virtual void WriteRaw(string json);
    [NullableContextAttribute("2")]
public virtual void WriteRawValue(string json);
    [NullableContextAttribute("2")]
public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Nullable`1<int> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<UInt32> value);
    public virtual void WriteValue(Nullable`1<long> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<ulong> value);
    public virtual void WriteValue(Nullable`1<float> value);
    public virtual void WriteValue(Nullable`1<double> value);
    public virtual void WriteValue(Nullable`1<bool> value);
    public virtual void WriteValue(Nullable`1<short> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<ushort> value);
    public virtual void WriteValue(Nullable`1<char> value);
    public virtual void WriteValue(Nullable`1<byte> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<sbyte> value);
    public virtual void WriteValue(Nullable`1<decimal> value);
    public virtual void WriteValue(Nullable`1<DateTime> value);
    public virtual void WriteValue(Nullable`1<DateTimeOffset> value);
    public virtual void WriteValue(Nullable`1<Guid> value);
    public virtual void WriteValue(Nullable`1<TimeSpan> value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(Byte[] value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(Uri value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(object value);
    [NullableContextAttribute("2")]
public virtual void WriteComment(string text);
    public virtual void WriteWhitespace(string ws);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    internal static void WriteValue(JsonWriter writer, PrimitiveTypeCode typeCode, object value);
    private static void ResolveConvertibleValue(IConvertible convertible, PrimitiveTypeCode& typeCode, Object& value);
    private static JsonWriterException CreateUnsupportedTypeException(JsonWriter writer, object value);
    protected void SetWriteState(JsonToken token, object value);
    internal void InternalWriteEnd(JsonContainerType container);
    internal void InternalWritePropertyName(string name);
    internal void InternalWriteRaw();
    internal void InternalWriteStart(JsonToken token, JsonContainerType container);
    internal void InternalWriteValue(JsonToken token);
    internal void InternalWriteWhitespace(string ws);
    internal void InternalWriteComment();
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonWriter/<<InternalWriteEndAsync>g__AwaitProperty|11_0>d")]
[CompilerGeneratedAttribute]
private Task <InternalWriteEndAsync>g__AwaitProperty|11_0(Task task, int LevelsToComplete, JsonToken token, CancellationToken CancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonWriter/<<InternalWriteEndAsync>g__AwaitIndent|11_1>d")]
[CompilerGeneratedAttribute]
private Task <InternalWriteEndAsync>g__AwaitIndent|11_1(Task task, int LevelsToComplete, JsonToken token, CancellationToken CancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonWriter/<<InternalWriteEndAsync>g__AwaitEnd|11_2>d")]
[CompilerGeneratedAttribute]
private Task <InternalWriteEndAsync>g__AwaitEnd|11_2(Task task, int LevelsToComplete, CancellationToken CancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonWriter/<<InternalWriteEndAsync>g__AwaitRemaining|11_3>d")]
[CompilerGeneratedAttribute]
private Task <InternalWriteEndAsync>g__AwaitRemaining|11_3(int LevelsToComplete, CancellationToken CancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.JsonWriterException : JsonException {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [NullableAttribute("2")]
public string Path { get; }
    public JsonWriterException(string message);
    public JsonWriterException(string message, Exception innerException);
    public JsonWriterException(SerializationInfo info, StreamingContext context);
    public JsonWriterException(string message, string path, Exception innerException);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Path();
    internal static JsonWriterException Create(JsonWriter writer, string message, Exception ex);
    internal static JsonWriterException Create(string path, string message, Exception ex);
}
public enum Newtonsoft.Json.Linq.CommentHandling : Enum {
    public int value__;
    public static CommentHandling Ignore;
    public static CommentHandling Load;
}
public enum Newtonsoft.Json.Linq.DuplicatePropertyNameHandling : Enum {
    public int value__;
    public static DuplicatePropertyNameHandling Replace;
    public static DuplicatePropertyNameHandling Ignore;
    public static DuplicatePropertyNameHandling Error;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Newtonsoft.Json.Linq.Extensions : object {
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Ancestors(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> AncestorsAndSelf(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Descendants(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> DescendantsAndSelf(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JProperty> Properties(IEnumerable`1<JObject> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Values(IEnumerable`1<JToken> source, object key);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Values(IEnumerable`1<JToken> source);
    [ExtensionAttribute]
public static IEnumerable`1<U> Values(IEnumerable`1<JToken> source, object key);
    [ExtensionAttribute]
public static IEnumerable`1<U> Values(IEnumerable`1<JToken> source);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static U Value(IEnumerable`1<JToken> value);
    [ExtensionAttribute]
public static U Value(IEnumerable`1<T> value);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.Extensions/<Values>d__11`2")]
[ExtensionAttribute]
internal static IEnumerable`1<U> Values(IEnumerable`1<T> source, object key);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Children(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<U> Children(IEnumerable`1<T> source);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.Extensions/<Convert>d__14`2")]
[ExtensionAttribute]
internal static IEnumerable`1<U> Convert(IEnumerable`1<T> source);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static U Convert(T token);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> AsJEnumerable(IEnumerable`1<JToken> source);
    [ExtensionAttribute]
public static IJEnumerable`1<T> AsJEnumerable(IEnumerable`1<T> source);
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface Newtonsoft.Json.Linq.IJEnumerable`1 {
    public IJEnumerable`1<JToken> Item { get; }
    public abstract virtual IJEnumerable`1<JToken> get_Item(object key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Newtonsoft.Json.Linq.JArray : JContainer {
    private List`1<JToken> _values;
    protected IList`1<JToken> ChildrenTokens { get; }
    public JTokenType Type { get; }
    [NullableAttribute("2")]
public JToken Item { get; public set; }
    public JToken Item { get; public set; }
    public bool IsReadOnly { get; }
    public JArray(JArray other);
    internal JArray(JArray other, JsonCloneSettings settings);
    public JArray(Object[] content);
    public JArray(object content);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JArray/<WriteToAsync>d__0")]
public virtual Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    public static Task`1<JArray> LoadAsync(JsonReader reader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JArray/<LoadAsync>d__2")]
public static Task`1<JArray> LoadAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    public virtual JTokenType get_Type();
    internal virtual bool DeepEquals(JToken node);
    internal virtual JToken CloneToken(JsonCloneSettings settings);
    public static JArray Load(JsonReader reader);
    public static JArray Load(JsonReader reader, JsonLoadSettings settings);
    public static JArray Parse(string json);
    public static JArray Parse(string json, JsonLoadSettings settings);
    public static JArray FromObject(object o);
    public static JArray FromObject(object o, JsonSerializer jsonSerializer);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public sealed virtual JToken get_Item(int index);
    public sealed virtual void set_Item(int index, JToken value);
    [NullableContextAttribute("2")]
internal virtual int IndexOfItem(JToken item);
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    public sealed virtual int IndexOf(JToken item);
    public sealed virtual void Insert(int index, JToken item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual IEnumerator`1<JToken> GetEnumerator();
    public sealed virtual void Add(JToken item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(JToken item);
    public sealed virtual void CopyTo(JToken[] array, int arrayIndex);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(JToken item);
    internal virtual int GetDeepHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Newtonsoft.Json.Linq.JConstructor : JContainer {
    [NullableAttribute("2")]
private string _name;
    private List`1<JToken> _values;
    protected IList`1<JToken> ChildrenTokens { get; }
    [NullableAttribute("2")]
public string Name { get; public set; }
    public JTokenType Type { get; }
    [NullableAttribute("2")]
public JToken Item { get; public set; }
    public JConstructor(JConstructor other);
    internal JConstructor(JConstructor other, JsonCloneSettings settings);
    public JConstructor(string name, Object[] content);
    public JConstructor(string name, object content);
    public JConstructor(string name);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JConstructor/<WriteToAsync>d__0")]
public virtual Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    public static Task`1<JConstructor> LoadAsync(JsonReader reader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JConstructor/<LoadAsync>d__2")]
public static Task`1<JConstructor> LoadAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    [NullableContextAttribute("2")]
internal virtual int IndexOfItem(JToken item);
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    [NullableContextAttribute("2")]
public string get_Name();
    [NullableContextAttribute("2")]
public void set_Name(string value);
    public virtual JTokenType get_Type();
    internal virtual bool DeepEquals(JToken node);
    internal virtual JToken CloneToken(JsonCloneSettings settings);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    internal virtual int GetDeepHashCode();
    public static JConstructor Load(JsonReader reader);
    public static JConstructor Load(JsonReader reader, JsonLoadSettings settings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Newtonsoft.Json.Linq.JContainer : JToken {
    [NullableAttribute("2")]
internal ListChangedEventHandler _listChanged;
    [NullableAttribute("2")]
internal AddingNewEventHandler _addingNew;
    [NullableAttribute("2")]
internal NotifyCollectionChangedEventHandler _collectionChanged;
    [NullableAttribute("2")]
private object _syncRoot;
    private bool _busy;
    protected IList`1<JToken> ChildrenTokens { get; }
    public bool HasValues { get; }
    [NullableAttribute("2")]
public JToken First { get; }
    [NullableAttribute("2")]
public JToken Last { get; }
    private JToken System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.Item { get; private set; }
    private bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.ComponentModel.IBindingList.AllowEdit { get; }
    private bool System.ComponentModel.IBindingList.AllowNew { get; }
    private bool System.ComponentModel.IBindingList.AllowRemove { get; }
    private bool System.ComponentModel.IBindingList.IsSorted { get; }
    private ListSortDirection System.ComponentModel.IBindingList.SortDirection { get; }
    [NullableAttribute("2")]
private PropertyDescriptor System.ComponentModel.IBindingList.SortProperty { get; }
    private bool System.ComponentModel.IBindingList.SupportsChangeNotification { get; }
    private bool System.ComponentModel.IBindingList.SupportsSearching { get; }
    private bool System.ComponentModel.IBindingList.SupportsSorting { get; }
    internal JContainer(JContainer other, JsonCloneSettings settings);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JContainer/<ReadTokenFromAsync>d__0")]
internal Task ReadTokenFromAsync(JsonReader reader, JsonLoadSettings options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JContainer/<ReadContentFromAsync>d__1")]
private Task ReadContentFromAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    public sealed virtual void add_ListChanged(ListChangedEventHandler value);
    public sealed virtual void remove_ListChanged(ListChangedEventHandler value);
    public void add_AddingNew(AddingNewEventHandler value);
    public void remove_AddingNew(AddingNewEventHandler value);
    [NullableContextAttribute("2")]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [NullableContextAttribute("2")]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    protected abstract virtual IList`1<JToken> get_ChildrenTokens();
    internal void CheckReentrancy();
    internal virtual IList`1<JToken> CreateChildrenCollection();
    protected virtual void OnAddingNew(AddingNewEventArgs e);
    protected virtual void OnListChanged(ListChangedEventArgs e);
    protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs e);
    public virtual bool get_HasValues();
    internal bool ContentsEqual(JContainer container);
    [NullableContextAttribute("2")]
public virtual JToken get_First();
    [NullableContextAttribute("2")]
public virtual JToken get_Last();
    public virtual JEnumerable`1<JToken> Children();
    [NullableContextAttribute("2")]
public virtual IEnumerable`1<T> Values();
    public IEnumerable`1<JToken> Descendants();
    public IEnumerable`1<JToken> DescendantsAndSelf();
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JContainer/<GetDescendants>d__36")]
internal IEnumerable`1<JToken> GetDescendants(bool self);
    [NullableContextAttribute("2")]
internal bool IsMultiContent(object content);
    internal JToken EnsureParentToken(JToken item, bool skipParentCheck, bool copyAnnotations);
    [NullableContextAttribute("2")]
internal abstract virtual int IndexOfItem(JToken item);
    [NullableContextAttribute("2")]
internal virtual bool InsertItem(int index, JToken item, bool skipParentCheck, bool copyAnnotations);
    internal virtual void RemoveItemAt(int index);
    [NullableContextAttribute("2")]
internal virtual bool RemoveItem(JToken item);
    internal virtual JToken GetItem(int index);
    [NullableContextAttribute("2")]
internal virtual void SetItem(int index, JToken item);
    internal virtual void ClearItems();
    internal virtual void ReplaceItem(JToken existing, JToken replacement);
    [NullableContextAttribute("2")]
internal virtual bool ContainsItem(JToken item);
    internal virtual void CopyItemsTo(Array array, int arrayIndex);
    internal static bool IsTokenUnchanged(JToken currentValue, JToken newValue);
    internal virtual void ValidateToken(JToken o, JToken existing);
    [NullableContextAttribute("2")]
public virtual void Add(object content);
    [NullableContextAttribute("2")]
internal bool TryAdd(object content);
    internal void AddAndSkipParentCheck(JToken token);
    [NullableContextAttribute("2")]
public void AddFirst(object content);
    [NullableContextAttribute("2")]
internal bool TryAddInternal(int index, object content, bool skipParentCheck, bool copyAnnotations);
    internal static JToken CreateFromContent(object content);
    public JsonWriter CreateWriter();
    public void ReplaceAll(object content);
    public void RemoveAll();
    internal abstract virtual void MergeItem(object content, JsonMergeSettings settings);
    [NullableContextAttribute("2")]
public void Merge(object content);
    [NullableContextAttribute("2")]
public void Merge(object content, JsonMergeSettings settings);
    private void ValidateContent(object content);
    internal void ReadTokenFrom(JsonReader reader, JsonLoadSettings options);
    internal void ReadContentFrom(JsonReader r, JsonLoadSettings settings);
    [NullableContextAttribute("2")]
private static JProperty ReadProperty(JsonReader r, JsonLoadSettings settings, IJsonLineInfo lineInfo, JContainer parent);
    internal int ContentsHashCode();
    private sealed virtual override string System.ComponentModel.ITypedList.GetListName(PropertyDescriptor[] listAccessors);
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ITypedList.GetItemProperties(PropertyDescriptor[] listAccessors);
    private sealed virtual override int System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.IndexOf(JToken item);
    private sealed virtual override void System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.Insert(int index, JToken item);
    private sealed virtual override void System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.RemoveAt(int index);
    private sealed virtual override JToken System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.set_Item(int index, JToken value);
    private sealed virtual override void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Add(JToken item);
    private sealed virtual override void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Contains(JToken item);
    private sealed virtual override void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.CopyTo(JToken[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Remove(JToken item);
    [NullableContextAttribute("2")]
private JToken EnsureValue(object value);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.IList.Contains(object value);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.IndexOf(object value);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    [NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IList.get_Item(int index);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.ComponentModel.IBindingList.AddIndex(PropertyDescriptor property);
    private sealed virtual override object System.ComponentModel.IBindingList.AddNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowEdit();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowRemove();
    private sealed virtual override void System.ComponentModel.IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction);
    private sealed virtual override int System.ComponentModel.IBindingList.Find(PropertyDescriptor property, object key);
    private sealed virtual override bool System.ComponentModel.IBindingList.get_IsSorted();
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveIndex(PropertyDescriptor property);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveSort();
    private sealed virtual override ListSortDirection System.ComponentModel.IBindingList.get_SortDirection();
    [NullableContextAttribute("2")]
private sealed virtual override PropertyDescriptor System.ComponentModel.IBindingList.get_SortProperty();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsChangeNotification();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSearching();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSorting();
    internal static void MergeEnumerableContent(JContainer target, IEnumerable content, JsonMergeSettings settings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class Newtonsoft.Json.Linq.JEnumerable`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static JEnumerable`1<T> Empty;
    private IEnumerable`1<T> _enumerable;
    public IJEnumerable`1<JToken> Item { get; }
    public JEnumerable`1(IEnumerable`1<T> enumerable);
    private static JEnumerable`1();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IJEnumerable`1<JToken> get_Item(object key);
    public sealed virtual bool Equals(JEnumerable`1<T> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Newtonsoft.Json.Linq.JObject : JContainer {
    private JPropertyKeyedCollection _properties;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PropertyChangingEventHandler PropertyChanging;
    protected IList`1<JToken> ChildrenTokens { get; }
    public JTokenType Type { get; }
    [NullableAttribute("2")]
public JToken Item { get; public set; }
    [NullableAttribute("2")]
public JToken Item { get; public set; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ICollection`1<JToken> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.IsReadOnly { get; }
    public JObject(JObject other);
    internal JObject(JObject other, JsonCloneSettings settings);
    public JObject(Object[] content);
    public JObject(object content);
    public virtual Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    public static Task`1<JObject> LoadAsync(JsonReader reader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JObject/<LoadAsync>d__2")]
public static Task`1<JObject> LoadAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanging(PropertyChangingEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanging(PropertyChangingEventHandler value);
    internal virtual bool DeepEquals(JToken node);
    [NullableContextAttribute("2")]
internal virtual int IndexOfItem(JToken item);
    [NullableContextAttribute("2")]
internal virtual bool InsertItem(int index, JToken item, bool skipParentCheck, bool copyAnnotations);
    internal virtual void ValidateToken(JToken o, JToken existing);
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    private static bool IsNull(JToken token);
    internal void InternalPropertyChanged(JProperty childProperty);
    internal void InternalPropertyChanging(JProperty childProperty);
    internal virtual JToken CloneToken(JsonCloneSettings settings);
    public virtual JTokenType get_Type();
    public IEnumerable`1<JProperty> Properties();
    public JProperty Property(string name);
    public JProperty Property(string name, StringComparison comparison);
    public JEnumerable`1<JToken> PropertyValues();
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public sealed virtual JToken get_Item(string propertyName);
    public sealed virtual void set_Item(string propertyName, JToken value);
    public static JObject Load(JsonReader reader);
    public static JObject Load(JsonReader reader, JsonLoadSettings settings);
    public static JObject Parse(string json);
    public static JObject Parse(string json, JsonLoadSettings settings);
    public static JObject FromObject(object o);
    public static JObject FromObject(object o, JsonSerializer jsonSerializer);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    [NullableContextAttribute("2")]
public JToken GetValue(string propertyName);
    [NullableContextAttribute("2")]
public JToken GetValue(string propertyName, StringComparison comparison);
    public bool TryGetValue(string propertyName, StringComparison comparison, JToken& value);
    public sealed virtual void Add(string propertyName, JToken value);
    public sealed virtual bool ContainsKey(string propertyName);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.get_Keys();
    public sealed virtual bool Remove(string propertyName);
    public sealed virtual bool TryGetValue(string propertyName, JToken& value);
    private sealed virtual override ICollection`1<JToken> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.get_Values();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Add(KeyValuePair`2<string, JToken> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Contains(KeyValuePair`2<string, JToken> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Remove(KeyValuePair`2<string, JToken> item);
    internal virtual int GetDeepHashCode();
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JObject/<GetEnumerator>d__64")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, JToken>> GetEnumerator();
    protected virtual void OnPropertyChanged(string propertyName);
    protected virtual void OnPropertyChanging(string propertyName);
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties();
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties(Attribute[] attributes);
    private sealed virtual override AttributeCollection System.ComponentModel.ICustomTypeDescriptor.GetAttributes();
    [NullableContextAttribute("2")]
private sealed virtual override string System.ComponentModel.ICustomTypeDescriptor.GetClassName();
    [NullableContextAttribute("2")]
private sealed virtual override string System.ComponentModel.ICustomTypeDescriptor.GetComponentName();
    private sealed virtual override TypeConverter System.ComponentModel.ICustomTypeDescriptor.GetConverter();
    [NullableContextAttribute("2")]
private sealed virtual override EventDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultEvent();
    [NullableContextAttribute("2")]
private sealed virtual override PropertyDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultProperty();
    private sealed virtual override object System.ComponentModel.ICustomTypeDescriptor.GetEditor(Type editorBaseType);
    private sealed virtual override EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents(Attribute[] attributes);
    private sealed virtual override EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents();
    [NullableContextAttribute("2")]
private sealed virtual override object System.ComponentModel.ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd);
    protected virtual DynamicMetaObject GetMetaObject(Expression parameter);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JObject/<<WriteToAsync>g__AwaitProperties|0_0>d")]
[CompilerGeneratedAttribute]
private Task <WriteToAsync>g__AwaitProperties|0_0(Task task, int i, JsonWriter Writer, CancellationToken CancellationToken, JsonConverter[] Converters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Linq.JProperty : JContainer {
    private JPropertyList _content;
    private string _name;
    protected IList`1<JToken> ChildrenTokens { get; }
    public string Name { get; }
    public JToken Value { get; public set; }
    public JTokenType Type { get; }
    public JProperty(JProperty other);
    internal JProperty(JProperty other, JsonCloneSettings settings);
    internal JProperty(string name);
    public JProperty(string name, Object[] content);
    public JProperty(string name, object content);
    public virtual Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JProperty/<WriteToAsync>d__1")]
private Task WriteToAsync(Task task, JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    private Task WriteValueAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    public static Task`1<JProperty> LoadAsync(JsonReader reader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JProperty/<LoadAsync>d__4")]
public static Task`1<JProperty> LoadAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    [DebuggerStepThroughAttribute]
public string get_Name();
    [DebuggerStepThroughAttribute]
public JToken get_Value();
    public void set_Value(JToken value);
    internal virtual JToken GetItem(int index);
    [NullableContextAttribute("2")]
internal virtual void SetItem(int index, JToken item);
    [NullableContextAttribute("2")]
internal virtual bool RemoveItem(JToken item);
    internal virtual void RemoveItemAt(int index);
    [NullableContextAttribute("2")]
internal virtual int IndexOfItem(JToken item);
    [NullableContextAttribute("2")]
internal virtual bool InsertItem(int index, JToken item, bool skipParentCheck, bool copyAnnotations);
    [NullableContextAttribute("2")]
internal virtual bool ContainsItem(JToken item);
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    internal virtual void ClearItems();
    internal virtual bool DeepEquals(JToken node);
    internal virtual JToken CloneToken(JsonCloneSettings settings);
    [DebuggerStepThroughAttribute]
public virtual JTokenType get_Type();
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    internal virtual int GetDeepHashCode();
    public static JProperty Load(JsonReader reader);
    public static JProperty Load(JsonReader reader, JsonLoadSettings settings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Linq.JPropertyDescriptor : PropertyDescriptor {
    public Type ComponentType { get; }
    public bool IsReadOnly { get; }
    public Type PropertyType { get; }
    protected int NameHashCode { get; }
    public JPropertyDescriptor(string name);
    private static JObject CastInstance(object instance);
    public virtual bool CanResetValue(object component);
    [NullableContextAttribute("2")]
public virtual object GetValue(object component);
    public virtual void ResetValue(object component);
    [NullableContextAttribute("2")]
public virtual void SetValue(object component, object value);
    public virtual bool ShouldSerializeValue(object component);
    public virtual Type get_ComponentType();
    public virtual bool get_IsReadOnly();
    public virtual Type get_PropertyType();
    protected virtual int get_NameHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
internal class Newtonsoft.Json.Linq.JPropertyKeyedCollection : Collection`1<JToken> {
    private static IEqualityComparer`1<string> Comparer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, JToken> _dictionary;
    public JToken Item { get; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<JToken> Values { get; }
    private static JPropertyKeyedCollection();
    private void AddKey(string key, JToken item);
    protected void ChangeItemKey(JToken item, string newKey);
    protected virtual void ClearItems();
    public bool Contains(string key);
    private bool ContainsItem(JToken item);
    private void EnsureDictionary();
    private string GetKeyForItem(JToken item);
    protected virtual void InsertItem(int index, JToken item);
    public bool Remove(string key);
    protected virtual void RemoveItem(int index);
    private void RemoveKey(string key);
    protected virtual void SetItem(int index, JToken item);
    public JToken get_Item(string key);
    public bool TryGetValue(string key, JToken& value);
    public ICollection`1<string> get_Keys();
    public ICollection`1<JToken> get_Values();
    public int IndexOfReference(JToken t);
    public bool Compare(JPropertyKeyedCollection other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Linq.JRaw : JValue {
    public JRaw(JRaw other);
    internal JRaw(JRaw other, JsonCloneSettings settings);
    [NullableContextAttribute("2")]
public JRaw(object rawJson);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JRaw/<CreateAsync>d__0")]
public static Task`1<JRaw> CreateAsync(JsonReader reader, CancellationToken cancellationToken);
    public static JRaw Create(JsonReader reader);
    internal virtual JToken CloneToken(JsonCloneSettings settings);
}
public class Newtonsoft.Json.Linq.JsonCloneSettings : object {
    [NullableAttribute("1")]
internal static JsonCloneSettings SkipCopyAnnotations;
    [CompilerGeneratedAttribute]
private bool <CopyAnnotations>k__BackingField;
    public bool CopyAnnotations { get; public set; }
    private static JsonCloneSettings();
    [CompilerGeneratedAttribute]
public bool get_CopyAnnotations();
    [CompilerGeneratedAttribute]
public void set_CopyAnnotations(bool value);
}
public class Newtonsoft.Json.Linq.JsonLoadSettings : object {
    private CommentHandling _commentHandling;
    private LineInfoHandling _lineInfoHandling;
    private DuplicatePropertyNameHandling _duplicatePropertyNameHandling;
    public CommentHandling CommentHandling { get; public set; }
    public LineInfoHandling LineInfoHandling { get; public set; }
    public DuplicatePropertyNameHandling DuplicatePropertyNameHandling { get; public set; }
    public CommentHandling get_CommentHandling();
    public void set_CommentHandling(CommentHandling value);
    public LineInfoHandling get_LineInfoHandling();
    public void set_LineInfoHandling(LineInfoHandling value);
    public DuplicatePropertyNameHandling get_DuplicatePropertyNameHandling();
    public void set_DuplicatePropertyNameHandling(DuplicatePropertyNameHandling value);
}
public class Newtonsoft.Json.Linq.JsonMergeSettings : object {
    private MergeArrayHandling _mergeArrayHandling;
    private MergeNullValueHandling _mergeNullValueHandling;
    private StringComparison _propertyNameComparison;
    public MergeArrayHandling MergeArrayHandling { get; public set; }
    public MergeNullValueHandling MergeNullValueHandling { get; public set; }
    public StringComparison PropertyNameComparison { get; public set; }
    public MergeArrayHandling get_MergeArrayHandling();
    public void set_MergeArrayHandling(MergeArrayHandling value);
    public MergeNullValueHandling get_MergeNullValueHandling();
    public void set_MergeNullValueHandling(MergeNullValueHandling value);
    public StringComparison get_PropertyNameComparison();
    public void set_PropertyNameComparison(StringComparison value);
}
internal class Newtonsoft.Json.Linq.JsonPath.ArrayIndexFilter : PathFilter {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Index>k__BackingField;
    public Nullable`1<int> Index { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(Nullable`1<int> value);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JsonPath.ArrayIndexFilter/<ExecuteFilter>d__4")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.ArrayMultipleIndexFilter : PathFilter {
    internal List`1<int> Indexes;
    public ArrayMultipleIndexFilter(List`1<int> indexes);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JsonPath.ArrayMultipleIndexFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
internal class Newtonsoft.Json.Linq.JsonPath.ArraySliceFilter : PathFilter {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <End>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Step>k__BackingField;
    public Nullable`1<int> Start { get; public set; }
    public Nullable`1<int> End { get; public set; }
    public Nullable`1<int> Step { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_End();
    [CompilerGeneratedAttribute]
public void set_End(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Step();
    [CompilerGeneratedAttribute]
public void set_Step(Nullable`1<int> value);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JsonPath.ArraySliceFilter/<ExecuteFilter>d__12")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
    private bool IsValid(int index, int stopIndex, bool positiveStep);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.BooleanQueryExpression : QueryExpression {
    public object Left;
    [NullableAttribute("2")]
public object Right;
    public BooleanQueryExpression(QueryOperator operator, object left, object right);
    private IEnumerable`1<JToken> GetResult(JToken root, JToken t, object o);
    public virtual bool IsMatch(JToken root, JToken t, JsonSelectSettings settings);
    private bool MatchTokens(JToken leftResult, JToken rightResult, JsonSelectSettings settings);
    private static bool RegexEquals(JValue input, JValue pattern, JsonSelectSettings settings);
    internal static bool EqualsWithStringCoercion(JValue value, JValue queryValue);
    internal static bool EqualsWithStrictMatch(JValue value, JValue queryValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.CompositeExpression : QueryExpression {
    [CompilerGeneratedAttribute]
private List`1<QueryExpression> <Expressions>k__BackingField;
    public List`1<QueryExpression> Expressions { get; public set; }
    public CompositeExpression(QueryOperator operator);
    [CompilerGeneratedAttribute]
public List`1<QueryExpression> get_Expressions();
    [CompilerGeneratedAttribute]
public void set_Expressions(List`1<QueryExpression> value);
    public virtual bool IsMatch(JToken root, JToken t, JsonSelectSettings settings);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.FieldFilter : PathFilter {
    internal string Name;
    public FieldFilter(string name);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JsonPath.FieldFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.FieldMultipleFilter : PathFilter {
    internal List`1<string> Names;
    public FieldMultipleFilter(List`1<string> names);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JsonPath.FieldMultipleFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.JPath : object {
    private static Char[] FloatCharacters;
    private string _expression;
    [CompilerGeneratedAttribute]
private List`1<PathFilter> <Filters>k__BackingField;
    private int _currentIndex;
    public List`1<PathFilter> Filters { get; }
    public JPath(string expression);
    private static JPath();
    [CompilerGeneratedAttribute]
public List`1<PathFilter> get_Filters();
    private void ParseMain();
    private bool ParsePath(List`1<PathFilter> filters, int currentPartStartIndex, bool query);
    private static PathFilter CreatePathFilter(string member, bool scan);
    private PathFilter ParseIndexer(char indexerOpenChar, bool scan);
    private PathFilter ParseArrayIndexer(char indexerCloseChar);
    private void EatWhitespace();
    private PathFilter ParseQuery(char indexerCloseChar, bool scan);
    private bool TryParseExpression(List`1& expressionPath);
    private JsonException CreateUnexpectedCharacterException();
    private object ParseSide();
    private QueryExpression ParseExpression();
    [NullableContextAttribute("2")]
private bool TryParseValue(Object& value);
    private string ReadQuotedString();
    private string ReadRegexString();
    private bool Match(string s);
    private QueryOperator ParseOperator();
    private PathFilter ParseQuotedField(char indexerCloseChar, bool scan);
    private void EnsureLength(string message);
    internal IEnumerable`1<JToken> Evaluate(JToken root, JToken t, JsonSelectSettings settings);
    internal static IEnumerable`1<JToken> Evaluate(List`1<PathFilter> filters, JToken root, JToken t, JsonSelectSettings settings);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class Newtonsoft.Json.Linq.JsonPath.PathFilter : object {
    [NullableContextAttribute("1")]
public abstract virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
    protected static JToken GetTokenIndex(JToken t, JsonSelectSettings settings, int index);
    protected static JToken GetNextScanValue(JToken originalParent, JToken container, JToken value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Newtonsoft.Json.Linq.JsonPath.QueryExpression : object {
    internal QueryOperator Operator;
    public QueryExpression(QueryOperator operator);
    public bool IsMatch(JToken root, JToken t);
    public abstract virtual bool IsMatch(JToken root, JToken t, JsonSelectSettings settings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.QueryFilter : PathFilter {
    internal QueryExpression Expression;
    public QueryFilter(QueryExpression expression);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JsonPath.QueryFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
internal enum Newtonsoft.Json.Linq.JsonPath.QueryOperator : Enum {
    public int value__;
    public static QueryOperator None;
    public static QueryOperator Equals;
    public static QueryOperator NotEquals;
    public static QueryOperator Exists;
    public static QueryOperator LessThan;
    public static QueryOperator LessThanOrEquals;
    public static QueryOperator GreaterThan;
    public static QueryOperator GreaterThanOrEquals;
    public static QueryOperator And;
    public static QueryOperator Or;
    public static QueryOperator RegexEquals;
    public static QueryOperator StrictEquals;
    public static QueryOperator StrictNotEquals;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.QueryScanFilter : PathFilter {
    internal QueryExpression Expression;
    public QueryScanFilter(QueryExpression expression);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JsonPath.QueryScanFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.RootFilter : PathFilter {
    public static RootFilter Instance;
    private static RootFilter();
    public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.ScanFilter : PathFilter {
    internal string Name;
    public ScanFilter(string name);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JsonPath.ScanFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.ScanMultipleFilter : PathFilter {
    private List`1<string> _names;
    public ScanMultipleFilter(List`1<string> names);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JsonPath.ScanMultipleFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
public class Newtonsoft.Json.Linq.JsonSelectSettings : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <RegexMatchTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ErrorWhenNoMatch>k__BackingField;
    public Nullable`1<TimeSpan> RegexMatchTimeout { get; public set; }
    public bool ErrorWhenNoMatch { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_RegexMatchTimeout();
    [CompilerGeneratedAttribute]
public void set_RegexMatchTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public bool get_ErrorWhenNoMatch();
    [CompilerGeneratedAttribute]
public void set_ErrorWhenNoMatch(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public abstract class Newtonsoft.Json.Linq.JToken : object {
    [NullableAttribute("2")]
private static JTokenEqualityComparer _equalityComparer;
    [NullableAttribute("2")]
private JContainer _parent;
    [NullableAttribute("2")]
private JToken _previous;
    [NullableAttribute("2")]
private JToken _next;
    [NullableAttribute("2")]
private object _annotations;
    private static JTokenType[] BooleanTypes;
    private static JTokenType[] NumberTypes;
    private static JTokenType[] BigIntegerTypes;
    private static JTokenType[] StringTypes;
    private static JTokenType[] GuidTypes;
    private static JTokenType[] TimeSpanTypes;
    private static JTokenType[] UriTypes;
    private static JTokenType[] CharTypes;
    private static JTokenType[] DateTimeTypes;
    private static JTokenType[] BytesTypes;
    public static JTokenEqualityComparer EqualityComparer { get; }
    [NullableAttribute("2")]
public JContainer Parent { get; internal set; }
    public JToken Root { get; }
    public JTokenType Type { get; }
    public bool HasValues { get; }
    [NullableAttribute("2")]
public JToken Next { get; internal set; }
    [NullableAttribute("2")]
public JToken Previous { get; internal set; }
    public string Path { get; }
    [NullableAttribute("2")]
public JToken Item { get; public set; }
    [NullableAttribute("2")]
public JToken First { get; }
    [NullableAttribute("2")]
public JToken Last { get; }
    private IJEnumerable`1<JToken> Newtonsoft.Json.Linq.IJEnumerable<Newtonsoft.Json.Linq.JToken>.Item { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    private static JToken();
    public virtual Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    public Task WriteToAsync(JsonWriter writer, JsonConverter[] converters);
    public static Task`1<JToken> ReadFromAsync(JsonReader reader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JToken/<ReadFromAsync>d__3")]
public static Task`1<JToken> ReadFromAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    public static Task`1<JToken> LoadAsync(JsonReader reader, CancellationToken cancellationToken);
    public static Task`1<JToken> LoadAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    public static JTokenEqualityComparer get_EqualityComparer();
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public JContainer get_Parent();
    [NullableContextAttribute("2")]
internal void set_Parent(JContainer value);
    public JToken get_Root();
    internal abstract virtual JToken CloneToken(JsonCloneSettings settings);
    internal abstract virtual bool DeepEquals(JToken node);
    public abstract virtual JTokenType get_Type();
    public abstract virtual bool get_HasValues();
    [NullableContextAttribute("2")]
public static bool DeepEquals(JToken t1, JToken t2);
    [NullableContextAttribute("2")]
public JToken get_Next();
    [NullableContextAttribute("2")]
internal void set_Next(JToken value);
    [NullableContextAttribute("2")]
public JToken get_Previous();
    [NullableContextAttribute("2")]
internal void set_Previous(JToken value);
    public string get_Path();
    [NullableContextAttribute("2")]
public void AddAfterSelf(object content);
    [NullableContextAttribute("2")]
public void AddBeforeSelf(object content);
    public IEnumerable`1<JToken> Ancestors();
    public IEnumerable`1<JToken> AncestorsAndSelf();
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JToken/<GetAncestors>d__48")]
internal IEnumerable`1<JToken> GetAncestors(bool self);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JToken/<AfterSelf>d__49")]
public IEnumerable`1<JToken> AfterSelf();
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JToken/<BeforeSelf>d__50")]
public IEnumerable`1<JToken> BeforeSelf();
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    [NullableContextAttribute("2")]
public virtual T Value(object key);
    [NullableContextAttribute("2")]
public virtual JToken get_First();
    [NullableContextAttribute("2")]
public virtual JToken get_Last();
    public virtual JEnumerable`1<JToken> Children();
    [NullableContextAttribute("0")]
public JEnumerable`1<T> Children();
    [NullableContextAttribute("2")]
public virtual IEnumerable`1<T> Values();
    public void Remove();
    public void Replace(JToken value);
    public abstract virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual string ToString();
    public string ToString(Formatting formatting, JsonConverter[] converters);
    private static JValue EnsureValue(JToken value);
    private static string GetType(JToken token);
    private static bool ValidateToken(JToken o, JTokenType[] validTypes, bool nullable);
    public static bool op_Explicit(JToken value);
    public static DateTimeOffset op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<bool> op_Explicit(JToken value);
    public static long op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<DateTime> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<DateTimeOffset> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<decimal> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<double> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<char> op_Explicit(JToken value);
    public static int op_Explicit(JToken value);
    public static short op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static char op_Explicit(JToken value);
    public static byte op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<int> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<short> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<ushort> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<byte> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<sbyte> op_Explicit(JToken value);
    public static DateTime op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<long> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<float> op_Explicit(JToken value);
    public static decimal op_Explicit(JToken value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<UInt32> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<ulong> op_Explicit(JToken value);
    public static double op_Explicit(JToken value);
    public static float op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static string op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Byte[] op_Explicit(JToken value);
    public static Guid op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<Guid> op_Explicit(JToken value);
    public static TimeSpan op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<TimeSpan> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Uri op_Explicit(JToken value);
    private static BigInteger ToBigInteger(JToken value);
    private static Nullable`1<BigInteger> ToBigIntegerNullable(JToken value);
    public static JToken op_Implicit(bool value);
    public static JToken op_Implicit(DateTimeOffset value);
    public static JToken op_Implicit(byte value);
    public static JToken op_Implicit(Nullable`1<byte> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(sbyte value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<sbyte> value);
    public static JToken op_Implicit(Nullable`1<bool> value);
    public static JToken op_Implicit(long value);
    public static JToken op_Implicit(Nullable`1<DateTime> value);
    public static JToken op_Implicit(Nullable`1<DateTimeOffset> value);
    public static JToken op_Implicit(Nullable`1<decimal> value);
    public static JToken op_Implicit(Nullable`1<double> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(short value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(ushort value);
    public static JToken op_Implicit(int value);
    public static JToken op_Implicit(Nullable`1<int> value);
    public static JToken op_Implicit(DateTime value);
    public static JToken op_Implicit(Nullable`1<long> value);
    public static JToken op_Implicit(Nullable`1<float> value);
    public static JToken op_Implicit(decimal value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<short> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<ushort> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<UInt32> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<ulong> value);
    public static JToken op_Implicit(double value);
    public static JToken op_Implicit(float value);
    public static JToken op_Implicit(string value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(UInt32 value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(ulong value);
    public static JToken op_Implicit(Byte[] value);
    public static JToken op_Implicit(Uri value);
    public static JToken op_Implicit(TimeSpan value);
    public static JToken op_Implicit(Nullable`1<TimeSpan> value);
    public static JToken op_Implicit(Guid value);
    public static JToken op_Implicit(Nullable`1<Guid> value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<JToken> System.Collections.Generic.IEnumerable<Newtonsoft.Json.Linq.JToken>.GetEnumerator();
    internal abstract virtual int GetDeepHashCode();
    private sealed virtual override IJEnumerable`1<JToken> Newtonsoft.Json.Linq.IJEnumerable<Newtonsoft.Json.Linq.JToken>.get_Item(object key);
    public JsonReader CreateReader();
    internal static JToken FromObjectInternal(object o, JsonSerializer jsonSerializer);
    public static JToken FromObject(object o);
    public static JToken FromObject(object o, JsonSerializer jsonSerializer);
    [NullableContextAttribute("2")]
public T ToObject();
    public object ToObject(Type objectType);
    [NullableContextAttribute("2")]
public T ToObject(JsonSerializer jsonSerializer);
    [NullableContextAttribute("2")]
public object ToObject(Type objectType, JsonSerializer jsonSerializer);
    public static JToken ReadFrom(JsonReader reader);
    public static JToken ReadFrom(JsonReader reader, JsonLoadSettings settings);
    public static JToken Parse(string json);
    public static JToken Parse(string json, JsonLoadSettings settings);
    public static JToken Load(JsonReader reader, JsonLoadSettings settings);
    public static JToken Load(JsonReader reader);
    [NullableContextAttribute("2")]
internal void SetLineInfo(IJsonLineInfo lineInfo, JsonLoadSettings settings);
    internal void SetLineInfo(int lineNumber, int linePosition);
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
    public JToken SelectToken(string path);
    public JToken SelectToken(string path, bool errorWhenNoMatch);
    [NullableContextAttribute("2")]
public JToken SelectToken(string path, JsonSelectSettings settings);
    public IEnumerable`1<JToken> SelectTokens(string path);
    public IEnumerable`1<JToken> SelectTokens(string path, bool errorWhenNoMatch);
    public IEnumerable`1<JToken> SelectTokens(string path, JsonSelectSettings settings);
    protected virtual DynamicMetaObject GetMetaObject(Expression parameter);
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
    private sealed virtual override object System.ICloneable.Clone();
    public JToken DeepClone();
    public JToken DeepClone(JsonCloneSettings settings);
    public void AddAnnotation(object annotation);
    public T Annotation();
    public object Annotation(Type type);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JToken/<Annotations>d__185`1")]
public IEnumerable`1<T> Annotations();
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JToken/<Annotations>d__186")]
public IEnumerable`1<object> Annotations(Type type);
    public void RemoveAnnotations();
    public void RemoveAnnotations(Type type);
    internal void CopyAnnotations(JToken target, JToken source);
}
public class Newtonsoft.Json.Linq.JTokenEqualityComparer : object {
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(JToken x, JToken y);
    [NullableContextAttribute("1")]
public sealed virtual int GetHashCode(JToken obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Linq.JTokenReader : JsonReader {
    private JToken _root;
    [NullableAttribute("2")]
private string _initialPath;
    [NullableAttribute("2")]
private JToken _parent;
    [NullableAttribute("2")]
private JToken _current;
    [NullableAttribute("2")]
public JToken CurrentToken { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    public string Path { get; }
    public JTokenReader(JToken token);
    public JTokenReader(JToken token, string initialPath);
    [NullableContextAttribute("2")]
public JToken get_CurrentToken();
    public virtual bool Read();
    private bool ReadOver(JToken t);
    private bool ReadToEnd();
    private Nullable`1<JsonToken> GetEndToken(JContainer c);
    private bool ReadInto(JContainer c);
    private bool SetEnd(JContainer c);
    private void SetToken(JToken token);
    [NullableContextAttribute("2")]
private string SafeToString(object value);
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
    public virtual string get_Path();
}
public enum Newtonsoft.Json.Linq.JTokenType : Enum {
    public int value__;
    public static JTokenType None;
    public static JTokenType Object;
    public static JTokenType Array;
    public static JTokenType Constructor;
    public static JTokenType Property;
    public static JTokenType Comment;
    public static JTokenType Integer;
    public static JTokenType Float;
    public static JTokenType String;
    public static JTokenType Boolean;
    public static JTokenType Null;
    public static JTokenType Undefined;
    public static JTokenType Date;
    public static JTokenType Raw;
    public static JTokenType Bytes;
    public static JTokenType Guid;
    public static JTokenType Uri;
    public static JTokenType TimeSpan;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Linq.JTokenWriter : JsonWriter {
    private JContainer _token;
    private JContainer _parent;
    private JValue _value;
    private JToken _current;
    public JToken CurrentToken { get; }
    public JToken Token { get; }
    [NullableContextAttribute("1")]
public JTokenWriter(JContainer container);
    [NullableContextAttribute("1")]
internal virtual Task WriteTokenAsync(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments, CancellationToken cancellationToken);
    public JToken get_CurrentToken();
    public JToken get_Token();
    public virtual void Flush();
    public virtual void Close();
    public virtual void WriteStartObject();
    [NullableContextAttribute("1")]
private void AddParent(JContainer container);
    private void RemoveParent();
    public virtual void WriteStartArray();
    [NullableContextAttribute("1")]
public virtual void WriteStartConstructor(string name);
    protected virtual void WriteEnd(JsonToken token);
    [NullableContextAttribute("1")]
public virtual void WritePropertyName(string name);
    private void AddRawValue(object value, JTokenType type, JsonToken token);
    internal void AddJValue(JValue value, JsonToken token);
    public virtual void WriteValue(object value);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteRaw(string json);
    public virtual void WriteComment(string text);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(Uri value);
    [NullableContextAttribute("1")]
internal virtual void WriteToken(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Linq.JValue : JToken {
    private JTokenType _valueType;
    private object _value;
    public bool HasValues { get; }
    public JTokenType Type { get; }
    public object Value { get; public set; }
    internal JValue(object value, JTokenType type);
    [NullableContextAttribute("1")]
internal JValue(JValue other, JsonCloneSettings settings);
    [NullableContextAttribute("1")]
public JValue(JValue other);
    public JValue(long value);
    public JValue(decimal value);
    public JValue(char value);
    [CLSCompliantAttribute("False")]
public JValue(ulong value);
    public JValue(double value);
    public JValue(float value);
    public JValue(DateTime value);
    public JValue(DateTimeOffset value);
    public JValue(bool value);
    public JValue(string value);
    public JValue(Guid value);
    public JValue(Uri value);
    public JValue(TimeSpan value);
    public JValue(object value);
    [NullableContextAttribute("1")]
public virtual Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    [NullableContextAttribute("1")]
internal virtual bool DeepEquals(JToken node);
    public virtual bool get_HasValues();
    [NullableContextAttribute("1")]
private static int CompareBigInteger(BigInteger i1, object i2);
    internal static int Compare(JTokenType valueType, object objA, object objB);
    [NullableContextAttribute("1")]
private static int CompareFloat(object objA, object objB);
    private static bool Operation(ExpressionType operation, object objA, object objB, Object& result);
    [NullableContextAttribute("1")]
internal virtual JToken CloneToken(JsonCloneSettings settings);
    [NullableContextAttribute("1")]
public static JValue CreateComment(string value);
    [NullableContextAttribute("1")]
public static JValue CreateString(string value);
    [NullableContextAttribute("1")]
public static JValue CreateNull();
    [NullableContextAttribute("1")]
public static JValue CreateUndefined();
    private static JTokenType GetValueType(Nullable`1<JTokenType> current, object value);
    private static JTokenType GetStringValueType(Nullable`1<JTokenType> current);
    public virtual JTokenType get_Type();
    public object get_Value();
    public void set_Value(object value);
    [NullableContextAttribute("1")]
public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    internal virtual int GetDeepHashCode();
    [NullableContextAttribute("1")]
private static bool ValuesEquals(JValue v1, JValue v2);
    public sealed virtual bool Equals(JValue other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    [NullableContextAttribute("1")]
protected virtual DynamicMetaObject GetMetaObject(Expression parameter);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public sealed virtual int CompareTo(JValue obj);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("1")]
private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
}
public enum Newtonsoft.Json.Linq.LineInfoHandling : Enum {
    public int value__;
    public static LineInfoHandling Ignore;
    public static LineInfoHandling Load;
}
public enum Newtonsoft.Json.Linq.MergeArrayHandling : Enum {
    public int value__;
    public static MergeArrayHandling Concat;
    public static MergeArrayHandling Union;
    public static MergeArrayHandling Replace;
    public static MergeArrayHandling Merge;
}
[FlagsAttribute]
public enum Newtonsoft.Json.Linq.MergeNullValueHandling : Enum {
    public int value__;
    public static MergeNullValueHandling Ignore;
    public static MergeNullValueHandling Merge;
}
public enum Newtonsoft.Json.MemberSerialization : Enum {
    public int value__;
    public static MemberSerialization OptOut;
    public static MemberSerialization OptIn;
    public static MemberSerialization Fields;
}
public enum Newtonsoft.Json.MetadataPropertyHandling : Enum {
    public int value__;
    public static MetadataPropertyHandling Default;
    public static MetadataPropertyHandling ReadAhead;
    public static MetadataPropertyHandling Ignore;
}
public enum Newtonsoft.Json.MissingMemberHandling : Enum {
    public int value__;
    public static MissingMemberHandling Ignore;
    public static MissingMemberHandling Error;
}
public enum Newtonsoft.Json.NullValueHandling : Enum {
    public int value__;
    public static NullValueHandling Include;
    public static NullValueHandling Ignore;
}
public enum Newtonsoft.Json.ObjectCreationHandling : Enum {
    public int value__;
    public static ObjectCreationHandling Auto;
    public static ObjectCreationHandling Reuse;
    public static ObjectCreationHandling Replace;
}
[FlagsAttribute]
public enum Newtonsoft.Json.PreserveReferencesHandling : Enum {
    public int value__;
    public static PreserveReferencesHandling None;
    public static PreserveReferencesHandling Objects;
    public static PreserveReferencesHandling Arrays;
    public static PreserveReferencesHandling All;
}
internal enum Newtonsoft.Json.ReadType : Enum {
    public int value__;
    public static ReadType Read;
    public static ReadType ReadAsInt32;
    public static ReadType ReadAsInt64;
    public static ReadType ReadAsBytes;
    public static ReadType ReadAsString;
    public static ReadType ReadAsDecimal;
    public static ReadType ReadAsDateTime;
    public static ReadType ReadAsDateTimeOffset;
    public static ReadType ReadAsDouble;
    public static ReadType ReadAsBoolean;
}
public enum Newtonsoft.Json.ReferenceLoopHandling : Enum {
    public int value__;
    public static ReferenceLoopHandling Error;
    public static ReferenceLoopHandling Ignore;
    public static ReferenceLoopHandling Serialize;
}
public enum Newtonsoft.Json.Required : Enum {
    public int value__;
    public static Required Default;
    public static Required AllowNull;
    public static Required Always;
    public static Required DisallowNull;
}
[ExtensionAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
public static class Newtonsoft.Json.Schema.Extensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
public static bool IsValid(JToken source, JsonSchema schema);
    [ExtensionAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
public static bool IsValid(JToken source, JsonSchema schema, IList`1& errorMessages);
    [ExtensionAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
public static void Validate(JToken source, JsonSchema schema);
    [ExtensionAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
public static void Validate(JToken source, JsonSchema schema, ValidationEventHandler validationEventHandler);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
public class Newtonsoft.Json.Schema.JsonSchema : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Required>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Hidden>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Transient>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonSchemaType> <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <DivisibleBy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Minimum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Maximum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ExclusiveMinimum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ExclusiveMaximum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JsonSchema> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PositionalItemsValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchema <AdditionalItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAdditionalItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UniqueItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonSchema> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchema <AdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonSchema> <PatternProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Requires>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JToken> <Enum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonSchemaType> <Disallow>k__BackingField;
    [CompilerGeneratedAttribute]
private JToken <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JsonSchema> <Extends>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Location>k__BackingField;
    private string _internalId;
    [CompilerGeneratedAttribute]
private string <DeferredReference>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReferencesResolved>k__BackingField;
    public string Id { get; public set; }
    public string Title { get; public set; }
    public Nullable`1<bool> Required { get; public set; }
    public Nullable`1<bool> ReadOnly { get; public set; }
    public Nullable`1<bool> Hidden { get; public set; }
    public Nullable`1<bool> Transient { get; public set; }
    public string Description { get; public set; }
    public Nullable`1<JsonSchemaType> Type { get; public set; }
    public string Pattern { get; public set; }
    public Nullable`1<int> MinimumLength { get; public set; }
    public Nullable`1<int> MaximumLength { get; public set; }
    public Nullable`1<double> DivisibleBy { get; public set; }
    public Nullable`1<double> Minimum { get; public set; }
    public Nullable`1<double> Maximum { get; public set; }
    public Nullable`1<bool> ExclusiveMinimum { get; public set; }
    public Nullable`1<bool> ExclusiveMaximum { get; public set; }
    public Nullable`1<int> MinimumItems { get; public set; }
    public Nullable`1<int> MaximumItems { get; public set; }
    public IList`1<JsonSchema> Items { get; public set; }
    public bool PositionalItemsValidation { get; public set; }
    public JsonSchema AdditionalItems { get; public set; }
    public bool AllowAdditionalItems { get; public set; }
    public bool UniqueItems { get; public set; }
    public IDictionary`2<string, JsonSchema> Properties { get; public set; }
    public JsonSchema AdditionalProperties { get; public set; }
    public IDictionary`2<string, JsonSchema> PatternProperties { get; public set; }
    public bool AllowAdditionalProperties { get; public set; }
    public string Requires { get; public set; }
    public IList`1<JToken> Enum { get; public set; }
    public Nullable`1<JsonSchemaType> Disallow { get; public set; }
    public JToken Default { get; public set; }
    public IList`1<JsonSchema> Extends { get; public set; }
    public string Format { get; public set; }
    internal string Location { get; internal set; }
    internal string InternalId { get; }
    internal string DeferredReference { get; internal set; }
    internal bool ReferencesResolved { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Required();
    [CompilerGeneratedAttribute]
public void set_Required(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ReadOnly();
    [CompilerGeneratedAttribute]
public void set_ReadOnly(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Hidden();
    [CompilerGeneratedAttribute]
public void set_Hidden(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Transient();
    [CompilerGeneratedAttribute]
public void set_Transient(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<JsonSchemaType> get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Nullable`1<JsonSchemaType> value);
    [CompilerGeneratedAttribute]
public string get_Pattern();
    [CompilerGeneratedAttribute]
public void set_Pattern(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumLength();
    [CompilerGeneratedAttribute]
public void set_MinimumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumLength();
    [CompilerGeneratedAttribute]
public void set_MaximumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_DivisibleBy();
    [CompilerGeneratedAttribute]
public void set_DivisibleBy(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Minimum();
    [CompilerGeneratedAttribute]
public void set_Minimum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Maximum();
    [CompilerGeneratedAttribute]
public void set_Maximum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ExclusiveMinimum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMinimum(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ExclusiveMaximum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMaximum(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumItems();
    [CompilerGeneratedAttribute]
public void set_MinimumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumItems();
    [CompilerGeneratedAttribute]
public void set_MaximumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public IList`1<JsonSchema> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(IList`1<JsonSchema> value);
    [CompilerGeneratedAttribute]
public bool get_PositionalItemsValidation();
    [CompilerGeneratedAttribute]
public void set_PositionalItemsValidation(bool value);
    [CompilerGeneratedAttribute]
public JsonSchema get_AdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AdditionalItems(JsonSchema value);
    [CompilerGeneratedAttribute]
public bool get_AllowAdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AllowAdditionalItems(bool value);
    [CompilerGeneratedAttribute]
public bool get_UniqueItems();
    [CompilerGeneratedAttribute]
public void set_UniqueItems(bool value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonSchema> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, JsonSchema> value);
    [CompilerGeneratedAttribute]
public JsonSchema get_AdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AdditionalProperties(JsonSchema value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonSchema> get_PatternProperties();
    [CompilerGeneratedAttribute]
public void set_PatternProperties(IDictionary`2<string, JsonSchema> value);
    [CompilerGeneratedAttribute]
public bool get_AllowAdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AllowAdditionalProperties(bool value);
    [CompilerGeneratedAttribute]
public string get_Requires();
    [CompilerGeneratedAttribute]
public void set_Requires(string value);
    [CompilerGeneratedAttribute]
public IList`1<JToken> get_Enum();
    [CompilerGeneratedAttribute]
public void set_Enum(IList`1<JToken> value);
    [CompilerGeneratedAttribute]
public Nullable`1<JsonSchemaType> get_Disallow();
    [CompilerGeneratedAttribute]
public void set_Disallow(Nullable`1<JsonSchemaType> value);
    [CompilerGeneratedAttribute]
public JToken get_Default();
    [CompilerGeneratedAttribute]
public void set_Default(JToken value);
    [CompilerGeneratedAttribute]
public IList`1<JsonSchema> get_Extends();
    [CompilerGeneratedAttribute]
public void set_Extends(IList`1<JsonSchema> value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [CompilerGeneratedAttribute]
internal string get_Location();
    [CompilerGeneratedAttribute]
internal void set_Location(string value);
    internal string get_InternalId();
    [CompilerGeneratedAttribute]
internal string get_DeferredReference();
    [CompilerGeneratedAttribute]
internal void set_DeferredReference(string value);
    [CompilerGeneratedAttribute]
internal bool get_ReferencesResolved();
    [CompilerGeneratedAttribute]
internal void set_ReferencesResolved(bool value);
    public static JsonSchema Read(JsonReader reader);
    public static JsonSchema Read(JsonReader reader, JsonSchemaResolver resolver);
    public static JsonSchema Parse(string json);
    public static JsonSchema Parse(string json, JsonSchemaResolver resolver);
    public void WriteTo(JsonWriter writer);
    public void WriteTo(JsonWriter writer, JsonSchemaResolver resolver);
    public virtual string ToString();
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.JsonSchemaBuilder : object {
    private IList`1<JsonSchema> _stack;
    private JsonSchemaResolver _resolver;
    private IDictionary`2<string, JsonSchema> _documentSchemas;
    private JsonSchema _currentSchema;
    private JObject _rootSchema;
    private JsonSchema CurrentSchema { get; }
    public JsonSchemaBuilder(JsonSchemaResolver resolver);
    private void Push(JsonSchema value);
    private JsonSchema Pop();
    private JsonSchema get_CurrentSchema();
    internal JsonSchema Read(JsonReader reader);
    private string UnescapeReference(string reference);
    private JsonSchema ResolveReferences(JsonSchema schema);
    private JsonSchema BuildSchema(JToken token);
    private void ProcessSchemaProperties(JObject schemaObject);
    private void ProcessExtends(JToken token);
    private void ProcessEnum(JToken token);
    private void ProcessAdditionalProperties(JToken token);
    private void ProcessAdditionalItems(JToken token);
    private IDictionary`2<string, JsonSchema> ProcessProperties(JToken token);
    private void ProcessItems(JToken token);
    private Nullable`1<JsonSchemaType> ProcessType(JToken token);
    internal static JsonSchemaType MapType(string type);
    internal static string MapType(JsonSchemaType type);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal static class Newtonsoft.Json.Schema.JsonSchemaConstants : object {
    public static string TypePropertyName;
    public static string PropertiesPropertyName;
    public static string ItemsPropertyName;
    public static string AdditionalItemsPropertyName;
    public static string RequiredPropertyName;
    public static string PatternPropertiesPropertyName;
    public static string AdditionalPropertiesPropertyName;
    public static string RequiresPropertyName;
    public static string MinimumPropertyName;
    public static string MaximumPropertyName;
    public static string ExclusiveMinimumPropertyName;
    public static string ExclusiveMaximumPropertyName;
    public static string MinimumItemsPropertyName;
    public static string MaximumItemsPropertyName;
    public static string PatternPropertyName;
    public static string MaximumLengthPropertyName;
    public static string MinimumLengthPropertyName;
    public static string EnumPropertyName;
    public static string ReadOnlyPropertyName;
    public static string TitlePropertyName;
    public static string DescriptionPropertyName;
    public static string FormatPropertyName;
    public static string DefaultPropertyName;
    public static string TransientPropertyName;
    public static string DivisibleByPropertyName;
    public static string HiddenPropertyName;
    public static string DisallowPropertyName;
    public static string ExtendsPropertyName;
    public static string IdPropertyName;
    public static string UniqueItemsPropertyName;
    public static string OptionValuePropertyName;
    public static string OptionLabelPropertyName;
    public static IDictionary`2<string, JsonSchemaType> JsonSchemaTypeMapping;
    private static JsonSchemaConstants();
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
public class Newtonsoft.Json.Schema.JsonSchemaException : JsonException {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public int LineNumber { get; }
    public int LinePosition { get; }
    public string Path { get; }
    public JsonSchemaException(string message);
    public JsonSchemaException(string message, Exception innerException);
    public JsonSchemaException(SerializationInfo info, StreamingContext context);
    internal JsonSchemaException(string message, Exception innerException, string path, int lineNumber, int linePosition);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [CompilerGeneratedAttribute]
public string get_Path();
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
public class Newtonsoft.Json.Schema.JsonSchemaGenerator : object {
    [CompilerGeneratedAttribute]
private UndefinedSchemaIdHandling <UndefinedSchemaIdHandling>k__BackingField;
    private IContractResolver _contractResolver;
    private JsonSchemaResolver _resolver;
    private IList`1<TypeSchema> _stack;
    private JsonSchema _currentSchema;
    public UndefinedSchemaIdHandling UndefinedSchemaIdHandling { get; public set; }
    public IContractResolver ContractResolver { get; public set; }
    private JsonSchema CurrentSchema { get; }
    [CompilerGeneratedAttribute]
public UndefinedSchemaIdHandling get_UndefinedSchemaIdHandling();
    [CompilerGeneratedAttribute]
public void set_UndefinedSchemaIdHandling(UndefinedSchemaIdHandling value);
    public IContractResolver get_ContractResolver();
    public void set_ContractResolver(IContractResolver value);
    private JsonSchema get_CurrentSchema();
    private void Push(TypeSchema typeSchema);
    private TypeSchema Pop();
    public JsonSchema Generate(Type type);
    public JsonSchema Generate(Type type, JsonSchemaResolver resolver);
    public JsonSchema Generate(Type type, bool rootSchemaNullable);
    public JsonSchema Generate(Type type, JsonSchemaResolver resolver, bool rootSchemaNullable);
    private string GetTitle(Type type);
    private string GetDescription(Type type);
    private string GetTypeId(Type type, bool explicitOnly);
    private JsonSchema GenerateInternal(Type type, Required valueRequired, bool required);
    private JsonSchemaType AddNullType(JsonSchemaType type, Required valueRequired);
    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag);
    private void GenerateObjectSchema(Type type, JsonObjectContract contract);
    private void GenerateISerializableContract(Type type, JsonISerializableContract contract);
    internal static bool HasFlag(Nullable`1<JsonSchemaType> value, JsonSchemaType flag);
    private JsonSchemaType GetJsonSchemaType(Type type, Required valueRequired);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.JsonSchemaModel : object {
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <DivisibleBy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Minimum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Maximum>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExclusiveMinimum>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExclusiveMaximum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Patterns>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JsonSchemaModel> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonSchemaModel> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonSchemaModel> <PatternProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaModel <AdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaModel <AdditionalItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PositionalItemsValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAdditionalItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UniqueItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JToken> <Enum>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaType <Disallow>k__BackingField;
    public bool Required { get; public set; }
    public JsonSchemaType Type { get; public set; }
    public Nullable`1<int> MinimumLength { get; public set; }
    public Nullable`1<int> MaximumLength { get; public set; }
    public Nullable`1<double> DivisibleBy { get; public set; }
    public Nullable`1<double> Minimum { get; public set; }
    public Nullable`1<double> Maximum { get; public set; }
    public bool ExclusiveMinimum { get; public set; }
    public bool ExclusiveMaximum { get; public set; }
    public Nullable`1<int> MinimumItems { get; public set; }
    public Nullable`1<int> MaximumItems { get; public set; }
    public IList`1<string> Patterns { get; public set; }
    public IList`1<JsonSchemaModel> Items { get; public set; }
    public IDictionary`2<string, JsonSchemaModel> Properties { get; public set; }
    public IDictionary`2<string, JsonSchemaModel> PatternProperties { get; public set; }
    public JsonSchemaModel AdditionalProperties { get; public set; }
    public JsonSchemaModel AdditionalItems { get; public set; }
    public bool PositionalItemsValidation { get; public set; }
    public bool AllowAdditionalProperties { get; public set; }
    public bool AllowAdditionalItems { get; public set; }
    public bool UniqueItems { get; public set; }
    public IList`1<JToken> Enum { get; public set; }
    public JsonSchemaType Disallow { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
public void set_Required(bool value);
    [CompilerGeneratedAttribute]
public JsonSchemaType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(JsonSchemaType value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumLength();
    [CompilerGeneratedAttribute]
public void set_MinimumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumLength();
    [CompilerGeneratedAttribute]
public void set_MaximumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_DivisibleBy();
    [CompilerGeneratedAttribute]
public void set_DivisibleBy(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Minimum();
    [CompilerGeneratedAttribute]
public void set_Minimum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Maximum();
    [CompilerGeneratedAttribute]
public void set_Maximum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public bool get_ExclusiveMinimum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMinimum(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExclusiveMaximum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMaximum(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumItems();
    [CompilerGeneratedAttribute]
public void set_MinimumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumItems();
    [CompilerGeneratedAttribute]
public void set_MaximumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Patterns();
    [CompilerGeneratedAttribute]
public void set_Patterns(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IList`1<JsonSchemaModel> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(IList`1<JsonSchemaModel> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonSchemaModel> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, JsonSchemaModel> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonSchemaModel> get_PatternProperties();
    [CompilerGeneratedAttribute]
public void set_PatternProperties(IDictionary`2<string, JsonSchemaModel> value);
    [CompilerGeneratedAttribute]
public JsonSchemaModel get_AdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AdditionalProperties(JsonSchemaModel value);
    [CompilerGeneratedAttribute]
public JsonSchemaModel get_AdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AdditionalItems(JsonSchemaModel value);
    [CompilerGeneratedAttribute]
public bool get_PositionalItemsValidation();
    [CompilerGeneratedAttribute]
public void set_PositionalItemsValidation(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowAdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AllowAdditionalProperties(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowAdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AllowAdditionalItems(bool value);
    [CompilerGeneratedAttribute]
public bool get_UniqueItems();
    [CompilerGeneratedAttribute]
public void set_UniqueItems(bool value);
    [CompilerGeneratedAttribute]
public IList`1<JToken> get_Enum();
    [CompilerGeneratedAttribute]
public void set_Enum(IList`1<JToken> value);
    [CompilerGeneratedAttribute]
public JsonSchemaType get_Disallow();
    [CompilerGeneratedAttribute]
public void set_Disallow(JsonSchemaType value);
    public static JsonSchemaModel Create(IList`1<JsonSchema> schemata);
    private static void Combine(JsonSchemaModel model, JsonSchema schema);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.JsonSchemaModelBuilder : object {
    private JsonSchemaNodeCollection _nodes;
    private Dictionary`2<JsonSchemaNode, JsonSchemaModel> _nodeModels;
    private JsonSchemaNode _node;
    public JsonSchemaModel Build(JsonSchema schema);
    public JsonSchemaNode AddSchema(JsonSchemaNode existingNode, JsonSchema schema);
    public void AddProperties(IDictionary`2<string, JsonSchema> source, IDictionary`2<string, JsonSchemaNode> target);
    public void AddProperty(IDictionary`2<string, JsonSchemaNode> target, string propertyName, JsonSchema schema);
    public void AddItem(JsonSchemaNode parentNode, int index, JsonSchema schema);
    public void AddAdditionalProperties(JsonSchemaNode parentNode, JsonSchema schema);
    public void AddAdditionalItems(JsonSchemaNode parentNode, JsonSchema schema);
    private JsonSchemaModel BuildNodeModel(JsonSchemaNode node);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.JsonSchemaNode : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<JsonSchema> <Schemas>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, JsonSchemaNode> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, JsonSchemaNode> <PatternProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<JsonSchemaNode> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaNode <AdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaNode <AdditionalItems>k__BackingField;
    public string Id { get; }
    public ReadOnlyCollection`1<JsonSchema> Schemas { get; }
    public Dictionary`2<string, JsonSchemaNode> Properties { get; }
    public Dictionary`2<string, JsonSchemaNode> PatternProperties { get; }
    public List`1<JsonSchemaNode> Items { get; }
    public JsonSchemaNode AdditionalProperties { get; public set; }
    public JsonSchemaNode AdditionalItems { get; public set; }
    public JsonSchemaNode(JsonSchema schema);
    private JsonSchemaNode(JsonSchemaNode source, JsonSchema schema);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<JsonSchema> get_Schemas();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, JsonSchemaNode> get_Properties();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, JsonSchemaNode> get_PatternProperties();
    [CompilerGeneratedAttribute]
public List`1<JsonSchemaNode> get_Items();
    [CompilerGeneratedAttribute]
public JsonSchemaNode get_AdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AdditionalProperties(JsonSchemaNode value);
    [CompilerGeneratedAttribute]
public JsonSchemaNode get_AdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AdditionalItems(JsonSchemaNode value);
    public JsonSchemaNode Combine(JsonSchema schema);
    public static string GetId(IEnumerable`1<JsonSchema> schemata);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.JsonSchemaNodeCollection : KeyedCollection`2<string, JsonSchemaNode> {
    protected virtual string GetKeyForItem(JsonSchemaNode item);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
public class Newtonsoft.Json.Schema.JsonSchemaResolver : object {
    [CompilerGeneratedAttribute]
private IList`1<JsonSchema> <LoadedSchemas>k__BackingField;
    public IList`1<JsonSchema> LoadedSchemas { get; protected set; }
    [CompilerGeneratedAttribute]
public IList`1<JsonSchema> get_LoadedSchemas();
    [CompilerGeneratedAttribute]
protected void set_LoadedSchemas(IList`1<JsonSchema> value);
    public virtual JsonSchema GetSchema(string reference);
}
[FlagsAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
public enum Newtonsoft.Json.Schema.JsonSchemaType : Enum {
    public int value__;
    public static JsonSchemaType None;
    public static JsonSchemaType String;
    public static JsonSchemaType Float;
    public static JsonSchemaType Integer;
    public static JsonSchemaType Boolean;
    public static JsonSchemaType Object;
    public static JsonSchemaType Array;
    public static JsonSchemaType Null;
    public static JsonSchemaType Any;
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.JsonSchemaWriter : object {
    private JsonWriter _writer;
    private JsonSchemaResolver _resolver;
    public JsonSchemaWriter(JsonWriter writer, JsonSchemaResolver resolver);
    private void ReferenceOrWriteSchema(JsonSchema schema);
    public void WriteSchema(JsonSchema schema);
    private void WriteSchemaDictionaryIfNotNull(JsonWriter writer, string propertyName, IDictionary`2<string, JsonSchema> properties);
    private void WriteItems(JsonSchema schema);
    private void WriteType(string propertyName, JsonWriter writer, JsonSchemaType type);
    private void WritePropertyIfNotNull(JsonWriter writer, string propertyName, object value);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
public enum Newtonsoft.Json.Schema.UndefinedSchemaIdHandling : Enum {
    public int value__;
    public static UndefinedSchemaIdHandling None;
    public static UndefinedSchemaIdHandling UseTypeName;
    public static UndefinedSchemaIdHandling UseAssemblyQualifiedName;
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
public class Newtonsoft.Json.Schema.ValidationEventArgs : EventArgs {
    private JsonSchemaException _ex;
    public JsonSchemaException Exception { get; }
    public string Path { get; }
    public string Message { get; }
    internal ValidationEventArgs(JsonSchemaException ex);
    public JsonSchemaException get_Exception();
    public string get_Path();
    public string get_Message();
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
public class Newtonsoft.Json.Schema.ValidationEventHandler : MulticastDelegate {
    public ValidationEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ValidationEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ValidationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class Newtonsoft.Json.Serialization.CachedAttributeGetter`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ThreadSafeStore`2<object, T> TypeAttributeCache;
    private static CachedAttributeGetter`1();
    [NullableContextAttribute("1")]
public static T GetAttribute(object type);
}
public class Newtonsoft.Json.Serialization.CamelCaseNamingStrategy : NamingStrategy {
    public CamelCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames);
    public CamelCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames, bool processExtensionDataNames);
    [NullableContextAttribute("1")]
protected virtual string ResolvePropertyName(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver : DefaultContractResolver {
    private static object TypeContractCacheLock;
    private static DefaultJsonNameTable NameTable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<StructMultiKey`2<Type, Type>, JsonContract> _contractCache;
    private static CamelCasePropertyNamesContractResolver();
    public virtual JsonContract ResolveContract(Type type);
    internal virtual DefaultJsonNameTable GetNameTable();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Serialization.DefaultContractResolver : object {
    private static IContractResolver _instance;
    private static String[] BlacklistedTypeNames;
    private static JsonConverter[] BuiltInConverters;
    private DefaultJsonNameTable _nameTable;
    private ThreadSafeStore`2<Type, JsonContract> _contractCache;
    [CompilerGeneratedAttribute]
private BindingFlags <DefaultMembersSearchFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SerializeCompilerGeneratedMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreSerializableInterface>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreSerializableAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreIsSpecifiedMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreShouldSerializeMembers>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private NamingStrategy <NamingStrategy>k__BackingField;
    internal static IContractResolver Instance { get; }
    public bool DynamicCodeGeneration { get; }
    [ObsoleteAttribute("DefaultMembersSearchFlags is obsolete. To modify the members serialized inherit from DefaultContractResolver and override the GetSerializableMembers method instead.")]
public BindingFlags DefaultMembersSearchFlags { get; public set; }
    public bool SerializeCompilerGeneratedMembers { get; public set; }
    public bool IgnoreSerializableInterface { get; public set; }
    public bool IgnoreSerializableAttribute { get; public set; }
    public bool IgnoreIsSpecifiedMembers { get; public set; }
    public bool IgnoreShouldSerializeMembers { get; public set; }
    [NullableAttribute("2")]
public NamingStrategy NamingStrategy { get; public set; }
    private static DefaultContractResolver();
    internal static IContractResolver get_Instance();
    public bool get_DynamicCodeGeneration();
    [CompilerGeneratedAttribute]
public BindingFlags get_DefaultMembersSearchFlags();
    [CompilerGeneratedAttribute]
public void set_DefaultMembersSearchFlags(BindingFlags value);
    [CompilerGeneratedAttribute]
public bool get_SerializeCompilerGeneratedMembers();
    [CompilerGeneratedAttribute]
public void set_SerializeCompilerGeneratedMembers(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreSerializableInterface();
    [CompilerGeneratedAttribute]
public void set_IgnoreSerializableInterface(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreSerializableAttribute();
    [CompilerGeneratedAttribute]
public void set_IgnoreSerializableAttribute(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreIsSpecifiedMembers();
    [CompilerGeneratedAttribute]
public void set_IgnoreIsSpecifiedMembers(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreShouldSerializeMembers();
    [CompilerGeneratedAttribute]
public void set_IgnoreShouldSerializeMembers(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public NamingStrategy get_NamingStrategy();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_NamingStrategy(NamingStrategy value);
    public virtual JsonContract ResolveContract(Type type);
    private static bool FilterMembers(MemberInfo member);
    protected virtual List`1<MemberInfo> GetSerializableMembers(Type objectType);
    private bool ShouldSerializeEntityMember(MemberInfo memberInfo);
    protected virtual JsonObjectContract CreateObjectContract(Type objectType);
    private static void ThrowUnableToSerializeError(object o, StreamingContext context);
    private MemberInfo GetExtensionDataMemberForType(Type type);
    private static void SetExtensionDataDelegates(JsonObjectContract contract, MemberInfo member);
    private ConstructorInfo GetAttributeConstructor(Type objectType);
    private ConstructorInfo GetImmutableConstructor(Type objectType, JsonPropertyCollection memberProperties);
    private ConstructorInfo GetParameterizedConstructor(Type objectType);
    protected virtual IList`1<JsonProperty> CreateConstructorParameters(ConstructorInfo constructor, JsonPropertyCollection memberProperties);
    private JsonProperty MatchProperty(JsonPropertyCollection properties, string name, Type type);
    protected virtual JsonProperty CreatePropertyFromConstructorParameter(JsonProperty matchingMemberProperty, ParameterInfo parameterInfo);
    protected virtual JsonConverter ResolveContractConverter(Type objectType);
    private Func`1<object> GetDefaultCreator(Type createdType);
    private void InitializeContract(JsonContract contract);
    private void ResolveCallbackMethods(JsonContract contract, Type t);
    private void GetCallbackMethodsForType(Type type, List`1& onSerializing, List`1& onSerialized, List`1& onDeserializing, List`1& onDeserialized, List`1& onError);
    private static bool IsConcurrentOrObservableCollection(Type t);
    private static bool ShouldSkipDeserialized(Type t);
    private static bool ShouldSkipSerializing(Type t);
    private List`1<Type> GetClassHierarchyForType(Type type);
    protected virtual JsonDictionaryContract CreateDictionaryContract(Type objectType);
    protected virtual JsonArrayContract CreateArrayContract(Type objectType);
    protected virtual JsonPrimitiveContract CreatePrimitiveContract(Type objectType);
    protected virtual JsonLinqContract CreateLinqContract(Type objectType);
    protected virtual JsonISerializableContract CreateISerializableContract(Type objectType);
    protected virtual JsonDynamicContract CreateDynamicContract(Type objectType);
    protected virtual JsonStringContract CreateStringContract(Type objectType);
    protected virtual JsonContract CreateContract(Type objectType);
    internal static bool IsJsonPrimitiveType(Type t);
    internal static bool IsIConvertible(Type t);
    internal static bool CanConvertToString(Type type);
    private static bool IsValidCallback(MethodInfo method, ParameterInfo[] parameters, Type attributeType, MethodInfo currentCallback, Type& prevAttributeType);
    internal static string GetClrTypeFullName(Type type);
    protected virtual IList`1<JsonProperty> CreateProperties(Type type, MemberSerialization memberSerialization);
    internal virtual DefaultJsonNameTable GetNameTable();
    protected virtual IValueProvider CreateMemberValueProvider(MemberInfo member);
    protected virtual JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization);
    private void SetPropertySettingsFromAttributes(JsonProperty property, object attributeProvider, string name, Type declaringType, MemberSerialization memberSerialization, Boolean& allowNonPublicAccess);
    private Predicate`1<object> CreateShouldSerializeTest(MemberInfo member);
    private void SetIsSpecifiedActions(JsonProperty property, MemberInfo member, bool allowNonPublicAccess);
    protected virtual string ResolvePropertyName(string propertyName);
    protected virtual string ResolveExtensionDataName(string extensionDataName);
    protected virtual string ResolveDictionaryKey(string dictionaryKey);
    public string GetResolvedPropertyName(string propertyName);
}
public class Newtonsoft.Json.Serialization.DefaultNamingStrategy : NamingStrategy {
    [NullableContextAttribute("1")]
protected virtual string ResolvePropertyName(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.DefaultReferenceResolver : object {
    private int _referenceCount;
    private BidirectionalDictionary`2<string, object> GetMappings(object context);
    public sealed virtual object ResolveReference(object context, string reference);
    public sealed virtual string GetReference(object context, object value);
    public sealed virtual void AddReference(object context, string reference, object value);
    public sealed virtual bool IsReferenced(object context, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Serialization.DefaultSerializationBinder : SerializationBinder {
    internal static DefaultSerializationBinder Instance;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ThreadSafeStore`2<StructMultiKey`2<string, string>, Type> _typeCache;
    private static DefaultSerializationBinder();
    private Type GetTypeFromTypeNameKey(StructMultiKey`2<string, string> typeNameKey);
    private Type GetGenericTypeFromTypeName(string typeName, Assembly assembly);
    private Type GetTypeByName(StructMultiKey`2<string, string> typeNameKey);
    public virtual Type BindToType(string assemblyName, string typeName);
    [NullableContextAttribute("2")]
public virtual void BindToName(Type serializedType, String& assemblyName, String& typeName);
}
public class Newtonsoft.Json.Serialization.DiagnosticsTraceWriter : object {
    [CompilerGeneratedAttribute]
private TraceLevel <LevelFilter>k__BackingField;
    public TraceLevel LevelFilter { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual TraceLevel get_LevelFilter();
    [CompilerGeneratedAttribute]
public void set_LevelFilter(TraceLevel value);
    private TraceEventType GetTraceEventType(TraceLevel level);
    [NullableContextAttribute("1")]
public sealed virtual void Trace(TraceLevel level, string message, Exception ex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Serialization.DynamicValueProvider : object {
    private MemberInfo _memberInfo;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<object, object> _getter;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`2<object, object> _setter;
    public DynamicValueProvider(MemberInfo memberInfo);
    public sealed virtual void SetValue(object target, object value);
    public sealed virtual object GetValue(object target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Serialization.ErrorContext : object {
    [CompilerGeneratedAttribute]
private bool <Traced>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <OriginalObject>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Handled>k__BackingField;
    internal bool Traced { get; internal set; }
    public Exception Error { get; }
    [NullableAttribute("2")]
public object OriginalObject { get; }
    [NullableAttribute("2")]
public object Member { get; }
    public string Path { get; }
    public bool Handled { get; public set; }
    internal ErrorContext(object originalObject, object member, string path, Exception error);
    [CompilerGeneratedAttribute]
internal bool get_Traced();
    [CompilerGeneratedAttribute]
internal void set_Traced(bool value);
    [CompilerGeneratedAttribute]
public Exception get_Error();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_OriginalObject();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_Member();
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public bool get_Handled();
    [CompilerGeneratedAttribute]
public void set_Handled(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Serialization.ErrorEventArgs : EventArgs {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <CurrentObject>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorContext <ErrorContext>k__BackingField;
    [NullableAttribute("2")]
public object CurrentObject { get; }
    public ErrorContext ErrorContext { get; }
    public ErrorEventArgs(object currentObject, ErrorContext errorContext);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_CurrentObject();
    [CompilerGeneratedAttribute]
public ErrorContext get_ErrorContext();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Serialization.ExpressionValueProvider : object {
    private MemberInfo _memberInfo;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<object, object> _getter;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`2<object, object> _setter;
    public ExpressionValueProvider(MemberInfo memberInfo);
    public sealed virtual void SetValue(object target, object value);
    public sealed virtual object GetValue(object target);
}
public class Newtonsoft.Json.Serialization.ExtensionDataGetter : MulticastDelegate {
    public ExtensionDataGetter(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual IEnumerable`1<KeyValuePair`2<object, object>> Invoke(object o);
    public virtual IAsyncResult BeginInvoke(object o, AsyncCallback callback, object object);
    public virtual IEnumerable`1<KeyValuePair`2<object, object>> EndInvoke(IAsyncResult result);
}
public class Newtonsoft.Json.Serialization.ExtensionDataSetter : MulticastDelegate {
    public ExtensionDataSetter(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object o, string key, object value);
    public virtual IAsyncResult BeginInvoke(object o, string key, object value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
public interface Newtonsoft.Json.Serialization.IAttributeProvider {
    public abstract virtual IList`1<Attribute> GetAttributes(bool inherit);
    public abstract virtual IList`1<Attribute> GetAttributes(Type attributeType, bool inherit);
}
[NullableContextAttribute("1")]
public interface Newtonsoft.Json.Serialization.IContractResolver {
    public abstract virtual JsonContract ResolveContract(Type type);
}
[NullableContextAttribute("1")]
public interface Newtonsoft.Json.Serialization.IReferenceResolver {
    public abstract virtual object ResolveReference(object context, string reference);
    public abstract virtual string GetReference(object context, object value);
    public abstract virtual bool IsReferenced(object context, object value);
    public abstract virtual void AddReference(object context, string reference, object value);
}
[NullableContextAttribute("1")]
public interface Newtonsoft.Json.Serialization.ISerializationBinder {
    public abstract virtual Type BindToType(string assemblyName, string typeName);
    [NullableContextAttribute("2")]
public abstract virtual void BindToName(Type serializedType, String& assemblyName, String& typeName);
}
[NullableContextAttribute("1")]
public interface Newtonsoft.Json.Serialization.ITraceWriter {
    public TraceLevel LevelFilter { get; }
    public abstract virtual TraceLevel get_LevelFilter();
    public abstract virtual void Trace(TraceLevel level, string message, Exception ex);
}
[NullableContextAttribute("1")]
public interface Newtonsoft.Json.Serialization.IValueProvider {
    public abstract virtual void SetValue(object target, object value);
    public abstract virtual object GetValue(object target);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Serialization.JsonArrayContract : JsonContainerContract {
    [CompilerGeneratedAttribute]
private Type <CollectionItemType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMultidimensionalArray>k__BackingField;
    private Type _genericCollectionDefinitionType;
    private Type _genericWrapperType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _genericWrapperCreator;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`1<object> _genericTemporaryCollectionCreator;
    [CompilerGeneratedAttribute]
private bool <IsArray>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldCreateWrapper>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanDeserialize>k__BackingField;
    private ConstructorInfo _parameterizedConstructor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _parameterizedCreator;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _overrideCreator;
    [CompilerGeneratedAttribute]
private bool <HasParameterizedCreator>k__BackingField;
    public Type CollectionItemType { get; }
    public bool IsMultidimensionalArray { get; }
    internal bool IsArray { get; }
    internal bool ShouldCreateWrapper { get; }
    internal bool CanDeserialize { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ObjectConstructor`1<object> ParameterizedCreator { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ObjectConstructor`1<object> OverrideCreator { get; public set; }
    public bool HasParameterizedCreator { get; public set; }
    internal bool HasParameterizedCreatorInternal { get; }
    [NullableContextAttribute("1")]
public JsonArrayContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Type get_CollectionItemType();
    [CompilerGeneratedAttribute]
public bool get_IsMultidimensionalArray();
    [CompilerGeneratedAttribute]
internal bool get_IsArray();
    [CompilerGeneratedAttribute]
internal bool get_ShouldCreateWrapper();
    [CompilerGeneratedAttribute]
internal bool get_CanDeserialize();
    [CompilerGeneratedAttribute]
private void set_CanDeserialize(bool value);
    internal ObjectConstructor`1<object> get_ParameterizedCreator();
    public ObjectConstructor`1<object> get_OverrideCreator();
    public void set_OverrideCreator(ObjectConstructor`1<object> value);
    [CompilerGeneratedAttribute]
public bool get_HasParameterizedCreator();
    [CompilerGeneratedAttribute]
public void set_HasParameterizedCreator(bool value);
    internal bool get_HasParameterizedCreatorInternal();
    [NullableContextAttribute("1")]
internal IWrappedCollection CreateWrapper(object list);
    [NullableContextAttribute("1")]
internal IList CreateTemporaryCollection();
    [NullableContextAttribute("1")]
private void StoreFSharpListCreatorIfNecessary(Type underlyingType);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Serialization.JsonContainerContract : JsonContract {
    private JsonContract _itemContract;
    private JsonContract _finalItemContract;
    [CompilerGeneratedAttribute]
private JsonConverter <ItemConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ItemIsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReferenceLoopHandling> <ItemReferenceLoopHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypeNameHandling> <ItemTypeNameHandling>k__BackingField;
    internal JsonContract ItemContract { get; internal set; }
    internal JsonContract FinalItemContract { get; }
    public JsonConverter ItemConverter { get; public set; }
    public Nullable`1<bool> ItemIsReference { get; public set; }
    public Nullable`1<ReferenceLoopHandling> ItemReferenceLoopHandling { get; public set; }
    public Nullable`1<TypeNameHandling> ItemTypeNameHandling { get; public set; }
    [NullableContextAttribute("1")]
internal JsonContainerContract(Type underlyingType);
    internal JsonContract get_ItemContract();
    internal void set_ItemContract(JsonContract value);
    internal JsonContract get_FinalItemContract();
    [CompilerGeneratedAttribute]
public JsonConverter get_ItemConverter();
    [CompilerGeneratedAttribute]
public void set_ItemConverter(JsonConverter value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ItemIsReference();
    [CompilerGeneratedAttribute]
public void set_ItemIsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReferenceLoopHandling> get_ItemReferenceLoopHandling();
    [CompilerGeneratedAttribute]
public void set_ItemReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TypeNameHandling> get_ItemTypeNameHandling();
    [CompilerGeneratedAttribute]
public void set_ItemTypeNameHandling(Nullable`1<TypeNameHandling> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Newtonsoft.Json.Serialization.JsonContract : object {
    internal bool IsNullable;
    internal bool IsConvertable;
    internal bool IsEnum;
    internal Type NonNullableUnderlyingType;
    internal ReadType InternalReadType;
    internal JsonContractType ContractType;
    internal bool IsReadOnlyOrFixedSize;
    internal bool IsSealed;
    internal bool IsInstantiable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<SerializationCallback> _onDeserializedCallbacks;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<SerializationCallback> _onDeserializingCallbacks;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<SerializationCallback> _onSerializedCallbacks;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<SerializationCallback> _onSerializingCallbacks;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<SerializationErrorCallback> _onErrorCallbacks;
    private Type _createdType;
    [CompilerGeneratedAttribute]
private Type <UnderlyingType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsReference>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonConverter <Converter>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonConverter <InternalConverter>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`1<object> <DefaultCreator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DefaultCreatorNonPublic>k__BackingField;
    public Type UnderlyingType { get; }
    public Type CreatedType { get; public set; }
    public Nullable`1<bool> IsReference { get; public set; }
    [NullableAttribute("2")]
public JsonConverter Converter { get; public set; }
    [NullableAttribute("2")]
public JsonConverter InternalConverter { get; internal set; }
    public IList`1<SerializationCallback> OnDeserializedCallbacks { get; }
    public IList`1<SerializationCallback> OnDeserializingCallbacks { get; }
    public IList`1<SerializationCallback> OnSerializedCallbacks { get; }
    public IList`1<SerializationCallback> OnSerializingCallbacks { get; }
    public IList`1<SerializationErrorCallback> OnErrorCallbacks { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`1<object> DefaultCreator { get; public set; }
    public bool DefaultCreatorNonPublic { get; public set; }
    internal JsonContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Type get_UnderlyingType();
    public Type get_CreatedType();
    public void set_CreatedType(Type value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsReference();
    [CompilerGeneratedAttribute]
public void set_IsReference(Nullable`1<bool> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public JsonConverter get_Converter();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Converter(JsonConverter value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public JsonConverter get_InternalConverter();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_InternalConverter(JsonConverter value);
    public IList`1<SerializationCallback> get_OnDeserializedCallbacks();
    public IList`1<SerializationCallback> get_OnDeserializingCallbacks();
    public IList`1<SerializationCallback> get_OnSerializedCallbacks();
    public IList`1<SerializationCallback> get_OnSerializingCallbacks();
    public IList`1<SerializationErrorCallback> get_OnErrorCallbacks();
    [CompilerGeneratedAttribute]
public Func`1<object> get_DefaultCreator();
    [CompilerGeneratedAttribute]
public void set_DefaultCreator(Func`1<object> value);
    [CompilerGeneratedAttribute]
public bool get_DefaultCreatorNonPublic();
    [CompilerGeneratedAttribute]
public void set_DefaultCreatorNonPublic(bool value);
    internal void InvokeOnSerializing(object o, StreamingContext context);
    internal void InvokeOnSerialized(object o, StreamingContext context);
    internal void InvokeOnDeserializing(object o, StreamingContext context);
    internal void InvokeOnDeserialized(object o, StreamingContext context);
    internal void InvokeOnError(object o, StreamingContext context, ErrorContext errorContext);
    internal static SerializationCallback CreateSerializationCallback(MethodInfo callbackMethodInfo);
    internal static SerializationErrorCallback CreateSerializationErrorCallback(MethodInfo callbackMethodInfo);
}
internal enum Newtonsoft.Json.Serialization.JsonContractType : Enum {
    public int value__;
    public static JsonContractType None;
    public static JsonContractType Object;
    public static JsonContractType Array;
    public static JsonContractType Primitive;
    public static JsonContractType String;
    public static JsonContractType Dictionary;
    public static JsonContractType Dynamic;
    public static JsonContractType Serializable;
    public static JsonContractType Linq;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Serialization.JsonDictionaryContract : JsonContainerContract {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<string, string> <DictionaryKeyResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DictionaryKeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DictionaryValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonContract <KeyContract>k__BackingField;
    private Type _genericCollectionDefinitionType;
    private Type _genericWrapperType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _genericWrapperCreator;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`1<object> _genericTemporaryDictionaryCreator;
    [CompilerGeneratedAttribute]
private bool <ShouldCreateWrapper>k__BackingField;
    private ConstructorInfo _parameterizedConstructor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _overrideCreator;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _parameterizedCreator;
    [CompilerGeneratedAttribute]
private bool <HasParameterizedCreator>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<string, string> DictionaryKeyResolver { get; public set; }
    public Type DictionaryKeyType { get; }
    public Type DictionaryValueType { get; }
    internal JsonContract KeyContract { get; internal set; }
    internal bool ShouldCreateWrapper { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ObjectConstructor`1<object> ParameterizedCreator { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ObjectConstructor`1<object> OverrideCreator { get; public set; }
    public bool HasParameterizedCreator { get; public set; }
    internal bool HasParameterizedCreatorInternal { get; }
    [NullableContextAttribute("1")]
public JsonDictionaryContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Func`2<string, string> get_DictionaryKeyResolver();
    [CompilerGeneratedAttribute]
public void set_DictionaryKeyResolver(Func`2<string, string> value);
    [CompilerGeneratedAttribute]
public Type get_DictionaryKeyType();
    [CompilerGeneratedAttribute]
public Type get_DictionaryValueType();
    [CompilerGeneratedAttribute]
internal JsonContract get_KeyContract();
    [CompilerGeneratedAttribute]
internal void set_KeyContract(JsonContract value);
    [CompilerGeneratedAttribute]
internal bool get_ShouldCreateWrapper();
    internal ObjectConstructor`1<object> get_ParameterizedCreator();
    public ObjectConstructor`1<object> get_OverrideCreator();
    public void set_OverrideCreator(ObjectConstructor`1<object> value);
    [CompilerGeneratedAttribute]
public bool get_HasParameterizedCreator();
    [CompilerGeneratedAttribute]
public void set_HasParameterizedCreator(bool value);
    internal bool get_HasParameterizedCreatorInternal();
    [NullableContextAttribute("1")]
internal IWrappedDictionary CreateWrapper(object dictionary);
    [NullableContextAttribute("1")]
internal IDictionary CreateTemporaryDictionary();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Serialization.JsonDynamicContract : JsonContainerContract {
    [CompilerGeneratedAttribute]
private JsonPropertyCollection <Properties>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<string, string> <PropertyNameResolver>k__BackingField;
    private ThreadSafeStore`2<string, CallSite`1<Func`3<CallSite, object, object>>> _callSiteGetters;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ThreadSafeStore`2<string, CallSite`1<Func`4<CallSite, object, object, object>>> _callSiteSetters;
    public JsonPropertyCollection Properties { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<string, string> PropertyNameResolver { get; public set; }
    public JsonDynamicContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public JsonPropertyCollection get_Properties();
    [CompilerGeneratedAttribute]
public Func`2<string, string> get_PropertyNameResolver();
    [CompilerGeneratedAttribute]
public void set_PropertyNameResolver(Func`2<string, string> value);
    private static CallSite`1<Func`3<CallSite, object, object>> CreateCallSiteGetter(string name);
    private static CallSite`1<Func`4<CallSite, object, object, object>> CreateCallSiteSetter(string name);
    internal bool TryGetMember(IDynamicMetaObjectProvider dynamicProvider, string name, Object& value);
    internal bool TrySetMember(IDynamicMetaObjectProvider dynamicProvider, string name, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.JsonFormatterConverter : object {
    private JsonSerializerInternalReader _reader;
    private JsonISerializableContract _contract;
    [NullableAttribute("2")]
private JsonProperty _member;
    public JsonFormatterConverter(JsonSerializerInternalReader reader, JsonISerializableContract contract, JsonProperty member);
    private T GetTokenValue(object value);
    public sealed virtual object Convert(object value, Type type);
    public sealed virtual object Convert(object value, TypeCode typeCode);
    public sealed virtual bool ToBoolean(object value);
    public sealed virtual byte ToByte(object value);
    public sealed virtual char ToChar(object value);
    public sealed virtual DateTime ToDateTime(object value);
    public sealed virtual decimal ToDecimal(object value);
    public sealed virtual double ToDouble(object value);
    public sealed virtual short ToInt16(object value);
    public sealed virtual int ToInt32(object value);
    public sealed virtual long ToInt64(object value);
    public sealed virtual sbyte ToSByte(object value);
    public sealed virtual float ToSingle(object value);
    public sealed virtual string ToString(object value);
    public sealed virtual ushort ToUInt16(object value);
    public sealed virtual UInt32 ToUInt32(object value);
    public sealed virtual ulong ToUInt64(object value);
}
public class Newtonsoft.Json.Serialization.JsonISerializableContract : JsonContainerContract {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ObjectConstructor`1<object> <ISerializableCreator>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ObjectConstructor`1<object> ISerializableCreator { get; public set; }
    [NullableContextAttribute("1")]
public JsonISerializableContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public ObjectConstructor`1<object> get_ISerializableCreator();
    [CompilerGeneratedAttribute]
public void set_ISerializableCreator(ObjectConstructor`1<object> value);
}
public class Newtonsoft.Json.Serialization.JsonLinqContract : JsonContract {
    [NullableContextAttribute("1")]
public JsonLinqContract(Type underlyingType);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Serialization.JsonObjectContract : JsonContainerContract {
    [CompilerGeneratedAttribute]
private MemberSerialization <MemberSerialization>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<MissingMemberHandling> <MissingMemberHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Required> <ItemRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<NullValueHandling> <ItemNullValueHandling>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private JsonPropertyCollection <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtensionDataSetter <ExtensionDataSetter>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtensionDataGetter <ExtensionDataGetter>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<string, string> <ExtensionDataNameResolver>k__BackingField;
    internal bool ExtensionDataIsJToken;
    private Nullable`1<bool> _hasRequiredOrDefaultValueProperties;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _overrideCreator;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _parameterizedCreator;
    private JsonPropertyCollection _creatorParameters;
    private Type _extensionDataValueType;
    public MemberSerialization MemberSerialization { get; public set; }
    public Nullable`1<MissingMemberHandling> MissingMemberHandling { get; public set; }
    public Nullable`1<Required> ItemRequired { get; public set; }
    public Nullable`1<NullValueHandling> ItemNullValueHandling { get; public set; }
    [NullableAttribute("1")]
public JsonPropertyCollection Properties { get; }
    [NullableAttribute("1")]
public JsonPropertyCollection CreatorParameters { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ObjectConstructor`1<object> OverrideCreator { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ObjectConstructor`1<object> ParameterizedCreator { get; internal set; }
    public ExtensionDataSetter ExtensionDataSetter { get; public set; }
    public ExtensionDataGetter ExtensionDataGetter { get; public set; }
    public Type ExtensionDataValueType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<string, string> ExtensionDataNameResolver { get; public set; }
    internal bool HasRequiredOrDefaultValueProperties { get; }
    [NullableContextAttribute("1")]
public JsonObjectContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public MemberSerialization get_MemberSerialization();
    [CompilerGeneratedAttribute]
public void set_MemberSerialization(MemberSerialization value);
    [CompilerGeneratedAttribute]
public Nullable`1<MissingMemberHandling> get_MissingMemberHandling();
    [CompilerGeneratedAttribute]
public void set_MissingMemberHandling(Nullable`1<MissingMemberHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Required> get_ItemRequired();
    [CompilerGeneratedAttribute]
public void set_ItemRequired(Nullable`1<Required> value);
    [CompilerGeneratedAttribute]
public Nullable`1<NullValueHandling> get_ItemNullValueHandling();
    [CompilerGeneratedAttribute]
public void set_ItemNullValueHandling(Nullable`1<NullValueHandling> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public JsonPropertyCollection get_Properties();
    [NullableContextAttribute("1")]
public JsonPropertyCollection get_CreatorParameters();
    public ObjectConstructor`1<object> get_OverrideCreator();
    public void set_OverrideCreator(ObjectConstructor`1<object> value);
    internal ObjectConstructor`1<object> get_ParameterizedCreator();
    internal void set_ParameterizedCreator(ObjectConstructor`1<object> value);
    [CompilerGeneratedAttribute]
public ExtensionDataSetter get_ExtensionDataSetter();
    [CompilerGeneratedAttribute]
public void set_ExtensionDataSetter(ExtensionDataSetter value);
    [CompilerGeneratedAttribute]
public ExtensionDataGetter get_ExtensionDataGetter();
    [CompilerGeneratedAttribute]
public void set_ExtensionDataGetter(ExtensionDataGetter value);
    public Type get_ExtensionDataValueType();
    public void set_ExtensionDataValueType(Type value);
    [CompilerGeneratedAttribute]
public Func`2<string, string> get_ExtensionDataNameResolver();
    [CompilerGeneratedAttribute]
public void set_ExtensionDataNameResolver(Func`2<string, string> value);
    internal bool get_HasRequiredOrDefaultValueProperties();
    [NullableContextAttribute("1")]
[SecuritySafeCriticalAttribute]
internal object GetUninitializedObject();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Serialization.JsonPrimitiveContract : JsonContract {
    [CompilerGeneratedAttribute]
private PrimitiveTypeCode <TypeCode>k__BackingField;
    private static Dictionary`2<Type, ReadType> ReadTypeMap;
    internal PrimitiveTypeCode TypeCode { get; internal set; }
    public JsonPrimitiveContract(Type underlyingType);
    private static JsonPrimitiveContract();
    [CompilerGeneratedAttribute]
internal PrimitiveTypeCode get_TypeCode();
    [CompilerGeneratedAttribute]
internal void set_TypeCode(PrimitiveTypeCode value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Serialization.JsonProperty : object {
    internal Nullable`1<Required> _required;
    internal bool _hasExplicitDefaultValue;
    private object _defaultValue;
    private bool _hasGeneratedDefaultValue;
    private string _propertyName;
    internal bool _skipPropertyNameEscape;
    private Type _propertyType;
    [CompilerGeneratedAttribute]
private JsonContract <PropertyContract>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UnderlyingName>k__BackingField;
    [CompilerGeneratedAttribute]
private IValueProvider <ValueProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IAttributeProvider <AttributeProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <Converter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ignored>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Readable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Writable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasMemberAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<NullValueHandling> <NullValueHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DefaultValueHandling> <DefaultValueHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReferenceLoopHandling> <ReferenceLoopHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ObjectCreationHandling> <ObjectCreationHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypeNameHandling> <TypeNameHandling>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Predicate`1<object> <ShouldSerialize>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Predicate`1<object> <ShouldDeserialize>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Predicate`1<object> <GetIsSpecified>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`2<object, object> <SetIsSpecified>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <ItemConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ItemIsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypeNameHandling> <ItemTypeNameHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReferenceLoopHandling> <ItemReferenceLoopHandling>k__BackingField;
    internal JsonContract PropertyContract { get; internal set; }
    public string PropertyName { get; public set; }
    public Type DeclaringType { get; public set; }
    public Nullable`1<int> Order { get; public set; }
    public string UnderlyingName { get; public set; }
    public IValueProvider ValueProvider { get; public set; }
    public IAttributeProvider AttributeProvider { get; public set; }
    public Type PropertyType { get; public set; }
    public JsonConverter Converter { get; public set; }
    [ObsoleteAttribute("MemberConverter is obsolete. Use Converter instead.")]
public JsonConverter MemberConverter { get; public set; }
    public bool Ignored { get; public set; }
    public bool Readable { get; public set; }
    public bool Writable { get; public set; }
    public bool HasMemberAttribute { get; public set; }
    public object DefaultValue { get; public set; }
    public Required Required { get; public set; }
    public bool IsRequiredSpecified { get; }
    public Nullable`1<bool> IsReference { get; public set; }
    public Nullable`1<NullValueHandling> NullValueHandling { get; public set; }
    public Nullable`1<DefaultValueHandling> DefaultValueHandling { get; public set; }
    public Nullable`1<ReferenceLoopHandling> ReferenceLoopHandling { get; public set; }
    public Nullable`1<ObjectCreationHandling> ObjectCreationHandling { get; public set; }
    public Nullable`1<TypeNameHandling> TypeNameHandling { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Predicate`1<object> ShouldSerialize { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Predicate`1<object> ShouldDeserialize { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Predicate`1<object> GetIsSpecified { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<object, object> SetIsSpecified { get; public set; }
    public JsonConverter ItemConverter { get; public set; }
    public Nullable`1<bool> ItemIsReference { get; public set; }
    public Nullable`1<TypeNameHandling> ItemTypeNameHandling { get; public set; }
    public Nullable`1<ReferenceLoopHandling> ItemReferenceLoopHandling { get; public set; }
    [CompilerGeneratedAttribute]
internal JsonContract get_PropertyContract();
    [CompilerGeneratedAttribute]
internal void set_PropertyContract(JsonContract value);
    public string get_PropertyName();
    public void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public Type get_DeclaringType();
    [CompilerGeneratedAttribute]
public void set_DeclaringType(Type value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_UnderlyingName();
    [CompilerGeneratedAttribute]
public void set_UnderlyingName(string value);
    [CompilerGeneratedAttribute]
public IValueProvider get_ValueProvider();
    [CompilerGeneratedAttribute]
public void set_ValueProvider(IValueProvider value);
    [CompilerGeneratedAttribute]
public IAttributeProvider get_AttributeProvider();
    [CompilerGeneratedAttribute]
public void set_AttributeProvider(IAttributeProvider value);
    public Type get_PropertyType();
    public void set_PropertyType(Type value);
    [CompilerGeneratedAttribute]
public JsonConverter get_Converter();
    [CompilerGeneratedAttribute]
public void set_Converter(JsonConverter value);
    public JsonConverter get_MemberConverter();
    public void set_MemberConverter(JsonConverter value);
    [CompilerGeneratedAttribute]
public bool get_Ignored();
    [CompilerGeneratedAttribute]
public void set_Ignored(bool value);
    [CompilerGeneratedAttribute]
public bool get_Readable();
    [CompilerGeneratedAttribute]
public void set_Readable(bool value);
    [CompilerGeneratedAttribute]
public bool get_Writable();
    [CompilerGeneratedAttribute]
public void set_Writable(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasMemberAttribute();
    [CompilerGeneratedAttribute]
public void set_HasMemberAttribute(bool value);
    public object get_DefaultValue();
    public void set_DefaultValue(object value);
    internal object GetResolvedDefaultValue();
    public Required get_Required();
    public void set_Required(Required value);
    public bool get_IsRequiredSpecified();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsReference();
    [CompilerGeneratedAttribute]
public void set_IsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<NullValueHandling> get_NullValueHandling();
    [CompilerGeneratedAttribute]
public void set_NullValueHandling(Nullable`1<NullValueHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DefaultValueHandling> get_DefaultValueHandling();
    [CompilerGeneratedAttribute]
public void set_DefaultValueHandling(Nullable`1<DefaultValueHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReferenceLoopHandling> get_ReferenceLoopHandling();
    [CompilerGeneratedAttribute]
public void set_ReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ObjectCreationHandling> get_ObjectCreationHandling();
    [CompilerGeneratedAttribute]
public void set_ObjectCreationHandling(Nullable`1<ObjectCreationHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TypeNameHandling> get_TypeNameHandling();
    [CompilerGeneratedAttribute]
public void set_TypeNameHandling(Nullable`1<TypeNameHandling> value);
    [CompilerGeneratedAttribute]
public Predicate`1<object> get_ShouldSerialize();
    [CompilerGeneratedAttribute]
public void set_ShouldSerialize(Predicate`1<object> value);
    [CompilerGeneratedAttribute]
public Predicate`1<object> get_ShouldDeserialize();
    [CompilerGeneratedAttribute]
public void set_ShouldDeserialize(Predicate`1<object> value);
    [CompilerGeneratedAttribute]
public Predicate`1<object> get_GetIsSpecified();
    [CompilerGeneratedAttribute]
public void set_GetIsSpecified(Predicate`1<object> value);
    [CompilerGeneratedAttribute]
public Action`2<object, object> get_SetIsSpecified();
    [CompilerGeneratedAttribute]
public void set_SetIsSpecified(Action`2<object, object> value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public JsonConverter get_ItemConverter();
    [CompilerGeneratedAttribute]
public void set_ItemConverter(JsonConverter value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ItemIsReference();
    [CompilerGeneratedAttribute]
public void set_ItemIsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TypeNameHandling> get_ItemTypeNameHandling();
    [CompilerGeneratedAttribute]
public void set_ItemTypeNameHandling(Nullable`1<TypeNameHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReferenceLoopHandling> get_ItemReferenceLoopHandling();
    [CompilerGeneratedAttribute]
public void set_ItemReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value);
    [NullableContextAttribute("1")]
internal void WritePropertyName(JsonWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Newtonsoft.Json.Serialization.JsonPropertyCollection : KeyedCollection`2<string, JsonProperty> {
    private Type _type;
    private List`1<JsonProperty> _list;
    public JsonPropertyCollection(Type type);
    protected virtual string GetKeyForItem(JsonProperty item);
    public void AddProperty(JsonProperty property);
    public JsonProperty GetClosestMatchProperty(string propertyName);
    private bool TryGetProperty(string key, JsonProperty& item);
    public JsonProperty GetProperty(string propertyName, StringComparison comparisonType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Newtonsoft.Json.Serialization.JsonSerializerInternalBase : object {
    [NullableAttribute("2")]
private ErrorContext _currentErrorContext;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private BidirectionalDictionary`2<string, object> _mappings;
    internal JsonSerializer Serializer;
    [NullableAttribute("2")]
internal ITraceWriter TraceWriter;
    [NullableAttribute("2")]
protected JsonSerializerProxy InternalSerializer;
    internal BidirectionalDictionary`2<string, object> DefaultReferenceMappings { get; }
    protected JsonSerializerInternalBase(JsonSerializer serializer);
    internal BidirectionalDictionary`2<string, object> get_DefaultReferenceMappings();
    protected NullValueHandling ResolvedNullValueHandling(JsonObjectContract containerContract, JsonProperty property);
    private ErrorContext GetErrorContext(object currentObject, object member, string path, Exception error);
    protected void ClearErrorContext();
    [NullableContextAttribute("2")]
protected bool IsErrorHandled(object currentObject, JsonContract contract, object keyValue, IJsonLineInfo lineInfo, string path, Exception ex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.JsonSerializerInternalReader : JsonSerializerInternalBase {
    public JsonSerializerInternalReader(JsonSerializer serializer);
    public void Populate(JsonReader reader, object target);
    [NullableContextAttribute("2")]
private JsonContract GetContractSafe(Type type);
    private JsonContract GetContract(Type type);
    [NullableContextAttribute("2")]
public object Deserialize(JsonReader reader, Type objectType, bool checkAdditionalContent);
    private JsonSerializerProxy GetInternalSerializer();
    [NullableContextAttribute("2")]
private JToken CreateJToken(JsonReader reader, JsonContract contract);
    private JToken CreateJObject(JsonReader reader);
    [NullableContextAttribute("2")]
private object CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue);
    [NullableContextAttribute("2")]
private static bool CoerceEmptyStringToNull(Type objectType, JsonContract contract, string s);
    internal string GetExpectedDescription(JsonContract contract);
    [NullableContextAttribute("2")]
private JsonConverter GetConverter(JsonContract contract, JsonConverter memberConverter, JsonContainerContract containerContract, JsonProperty containerProperty);
    [NullableContextAttribute("2")]
private object CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue);
    [NullableContextAttribute("2")]
private bool ReadMetadataPropertiesToken(JTokenReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue, Object& newValue, String& id);
    [NullableContextAttribute("2")]
private bool ReadMetadataProperties(JsonReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue, Object& newValue, String& id);
    [NullableContextAttribute("2")]
private void ResolveTypeName(JsonReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, string qualifiedTypeName);
    private JsonArrayContract EnsureArrayContract(JsonReader reader, Type objectType, JsonContract contract);
    [NullableContextAttribute("2")]
private object CreateList(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, object existingValue, string id);
    [NullableContextAttribute("2")]
private bool HasNoDefinedType(JsonContract contract);
    [NullableContextAttribute("2")]
private object EnsureType(JsonReader reader, object value, CultureInfo culture, JsonContract contract, Type targetType);
    private bool SetPropertyValue(JsonProperty property, JsonConverter propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target);
    [NullableContextAttribute("2")]
private bool CalculatePropertyDetails(JsonProperty property, JsonConverter& propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target, Boolean& useExistingValue, Object& currentValue, JsonContract& propertyContract, Boolean& gottenCurrentValue, Boolean& ignoredValue);
    private void AddReference(JsonReader reader, string id, object value);
    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag);
    [NullableContextAttribute("2")]
private bool ShouldSetPropertyValue(JsonProperty property, JsonObjectContract contract, object value);
    private IList CreateNewList(JsonReader reader, JsonArrayContract contract, Boolean& createdFromNonDefaultCreator);
    private IDictionary CreateNewDictionary(JsonReader reader, JsonDictionaryContract contract, Boolean& createdFromNonDefaultCreator);
    private void OnDeserializing(JsonReader reader, JsonContract contract, object value);
    private void OnDeserialized(JsonReader reader, JsonContract contract, object value);
    private object PopulateDictionary(IDictionary dictionary, JsonReader reader, JsonDictionaryContract contract, JsonProperty containerProperty, string id);
    private object PopulateMultidimensionalArray(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id);
    private void ThrowUnexpectedEndException(JsonReader reader, JsonContract contract, object currentObject, string message);
    private object PopulateList(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id);
    private object CreateISerializable(JsonReader reader, JsonISerializableContract contract, JsonProperty member, string id);
    internal object CreateISerializableItem(JToken token, Type type, JsonISerializableContract contract, JsonProperty member);
    private object CreateDynamic(JsonReader reader, JsonDynamicContract contract, JsonProperty member, string id);
    private object CreateObjectUsingCreatorWithParameters(JsonReader reader, JsonObjectContract contract, JsonProperty containerProperty, ObjectConstructor`1<object> creator, string id);
    private object DeserializeConvertable(JsonConverter converter, JsonReader reader, Type objectType, object existingValue);
    private List`1<CreatorPropertyContext> ResolvePropertyAndCreatorValues(JsonObjectContract contract, JsonProperty containerProperty, JsonReader reader, Type objectType);
    public object CreateNewObject(JsonReader reader, JsonObjectContract objectContract, JsonProperty containerMember, JsonProperty containerProperty, string id, Boolean& createdFromNonDefaultCreator);
    private object PopulateObject(object newObject, JsonReader reader, JsonObjectContract contract, JsonProperty member, string id);
    private bool ShouldDeserialize(JsonReader reader, JsonProperty property, object target);
    private bool CheckPropertyName(JsonReader reader, string memberName);
    private void SetExtensionData(JsonObjectContract contract, JsonProperty member, JsonReader reader, string memberName, object o);
    private object ReadExtensionDataValue(JsonObjectContract contract, JsonProperty member, JsonReader reader);
    private void EndProcessProperty(object newObject, JsonReader reader, JsonObjectContract contract, int initialDepth, JsonProperty property, PropertyPresence presence, bool setDefaultValue);
    private void SetPropertyPresence(JsonReader reader, JsonProperty property, Dictionary`2<JsonProperty, PropertyPresence> requiredProperties);
    private void HandleError(JsonReader reader, bool readPastError, int initialDepth);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.JsonSerializerInternalWriter : JsonSerializerInternalBase {
    [NullableAttribute("2")]
private Type _rootType;
    private int _rootLevel;
    private List`1<object> _serializeStack;
    public JsonSerializerInternalWriter(JsonSerializer serializer);
    [NullableContextAttribute("2")]
public void Serialize(JsonWriter jsonWriter, object value, Type objectType);
    private JsonSerializerProxy GetInternalSerializer();
    [NullableContextAttribute("2")]
private JsonContract GetContractSafe(object value);
    private JsonContract GetContract(object value);
    private void SerializePrimitive(JsonWriter writer, object value, JsonPrimitiveContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    [NullableContextAttribute("2")]
private void SerializeValue(JsonWriter writer, object value, JsonContract valueContract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    [NullableContextAttribute("2")]
private Nullable`1<bool> ResolveIsReference(JsonContract contract, JsonProperty property, JsonContainerContract collectionContract, JsonProperty containerProperty);
    [NullableContextAttribute("2")]
private bool ShouldWriteReference(object value, JsonProperty property, JsonContract valueContract, JsonContainerContract collectionContract, JsonProperty containerProperty);
    [NullableContextAttribute("2")]
private bool ShouldWriteProperty(object memberValue, JsonObjectContract containerContract, JsonProperty property);
    [NullableContextAttribute("2")]
private bool CheckForCircularReference(JsonWriter writer, object value, JsonProperty property, JsonContract contract, JsonContainerContract containerContract, JsonProperty containerProperty);
    private void WriteReference(JsonWriter writer, object value);
    private string GetReference(JsonWriter writer, object value);
    internal static bool TryConvertToString(object value, Type type, String& s);
    private void SerializeString(JsonWriter writer, object value, JsonStringContract contract);
    private void OnSerializing(JsonWriter writer, JsonContract contract, object value);
    private void OnSerialized(JsonWriter writer, JsonContract contract, object value);
    private void SerializeObject(JsonWriter writer, object value, JsonObjectContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private bool CalculatePropertyValues(JsonWriter writer, object value, JsonContainerContract contract, JsonProperty member, JsonProperty property, JsonContract& memberContract, Object& memberValue);
    private void WriteObjectStart(JsonWriter writer, object value, JsonContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private bool HasCreatorParameter(JsonContainerContract contract, JsonProperty property);
    private void WriteReferenceIdProperty(JsonWriter writer, Type type, object value);
    private void WriteTypeProperty(JsonWriter writer, Type type);
    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag);
    private bool HasFlag(PreserveReferencesHandling value, PreserveReferencesHandling flag);
    private bool HasFlag(TypeNameHandling value, TypeNameHandling flag);
    private void SerializeConvertable(JsonWriter writer, JsonConverter converter, object value, JsonContract contract, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeList(JsonWriter writer, IEnumerable values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, int initialDepth, Int32[] indices);
    private bool WriteStartArray(JsonWriter writer, object values, JsonArrayContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    [SecuritySafeCriticalAttribute]
private void SerializeISerializable(JsonWriter writer, ISerializable value, JsonISerializableContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeDynamic(JsonWriter writer, IDynamicMetaObjectProvider value, JsonDynamicContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    [NullableContextAttribute("2")]
private bool ShouldWriteDynamicProperty(object memberValue);
    [NullableContextAttribute("2")]
private bool ShouldWriteType(TypeNameHandling typeNameHandlingFlag, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    private void SerializeDictionary(JsonWriter writer, IDictionary values, JsonDictionaryContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private string GetPropertyName(JsonWriter writer, object name, JsonContract contract, Boolean& escape);
    private void HandleError(JsonWriter writer, int initialDepth);
    private bool ShouldSerialize(JsonWriter writer, JsonProperty property, object target);
    private bool IsSpecified(JsonWriter writer, JsonProperty property, object target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.JsonSerializerProxy : JsonSerializer {
    [NullableAttribute("2")]
private JsonSerializerInternalReader _serializerReader;
    [NullableAttribute("2")]
private JsonSerializerInternalWriter _serializerWriter;
    internal JsonSerializer _serializer;
    [NullableAttribute("2")]
public IReferenceResolver ReferenceResolver { get; public set; }
    [NullableAttribute("2")]
public ITraceWriter TraceWriter { get; public set; }
    [NullableAttribute("2")]
public IEqualityComparer EqualityComparer { get; public set; }
    public JsonConverterCollection Converters { get; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public IContractResolver ContractResolver { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public PreserveReferencesHandling PreserveReferencesHandling { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public MetadataPropertyHandling MetadataPropertyHandling { get; public set; }
    [ObsoleteAttribute("TypeNameAssemblyFormat is obsolete. Use TypeNameAssemblyFormatHandling instead.")]
public FormatterAssemblyStyle TypeNameAssemblyFormat { get; public set; }
    public TypeNameAssemblyFormatHandling TypeNameAssemblyFormatHandling { get; public set; }
    public ConstructorHandling ConstructorHandling { get; public set; }
    [ObsoleteAttribute("Binder is obsolete. Use SerializationBinder instead.")]
public SerializationBinder Binder { get; public set; }
    public ISerializationBinder SerializationBinder { get; public set; }
    public StreamingContext Context { get; public set; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    public string DateFormatString { get; public set; }
    public CultureInfo Culture { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public bool CheckAdditionalContent { get; public set; }
    public JsonSerializerProxy(JsonSerializerInternalReader serializerReader);
    public JsonSerializerProxy(JsonSerializerInternalWriter serializerWriter);
    public virtual void add_Error(EventHandler`1<ErrorEventArgs> value);
    public virtual void remove_Error(EventHandler`1<ErrorEventArgs> value);
    [NullableContextAttribute("2")]
public virtual IReferenceResolver get_ReferenceResolver();
    [NullableContextAttribute("2")]
public virtual void set_ReferenceResolver(IReferenceResolver value);
    [NullableContextAttribute("2")]
public virtual ITraceWriter get_TraceWriter();
    [NullableContextAttribute("2")]
public virtual void set_TraceWriter(ITraceWriter value);
    [NullableContextAttribute("2")]
public virtual IEqualityComparer get_EqualityComparer();
    [NullableContextAttribute("2")]
public virtual void set_EqualityComparer(IEqualityComparer value);
    public virtual JsonConverterCollection get_Converters();
    public virtual DefaultValueHandling get_DefaultValueHandling();
    public virtual void set_DefaultValueHandling(DefaultValueHandling value);
    public virtual IContractResolver get_ContractResolver();
    public virtual void set_ContractResolver(IContractResolver value);
    public virtual MissingMemberHandling get_MissingMemberHandling();
    public virtual void set_MissingMemberHandling(MissingMemberHandling value);
    public virtual NullValueHandling get_NullValueHandling();
    public virtual void set_NullValueHandling(NullValueHandling value);
    public virtual ObjectCreationHandling get_ObjectCreationHandling();
    public virtual void set_ObjectCreationHandling(ObjectCreationHandling value);
    public virtual ReferenceLoopHandling get_ReferenceLoopHandling();
    public virtual void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public virtual PreserveReferencesHandling get_PreserveReferencesHandling();
    public virtual void set_PreserveReferencesHandling(PreserveReferencesHandling value);
    public virtual TypeNameHandling get_TypeNameHandling();
    public virtual void set_TypeNameHandling(TypeNameHandling value);
    public virtual MetadataPropertyHandling get_MetadataPropertyHandling();
    public virtual void set_MetadataPropertyHandling(MetadataPropertyHandling value);
    public virtual FormatterAssemblyStyle get_TypeNameAssemblyFormat();
    public virtual void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value);
    public virtual TypeNameAssemblyFormatHandling get_TypeNameAssemblyFormatHandling();
    public virtual void set_TypeNameAssemblyFormatHandling(TypeNameAssemblyFormatHandling value);
    public virtual ConstructorHandling get_ConstructorHandling();
    public virtual void set_ConstructorHandling(ConstructorHandling value);
    public virtual SerializationBinder get_Binder();
    public virtual void set_Binder(SerializationBinder value);
    public virtual ISerializationBinder get_SerializationBinder();
    public virtual void set_SerializationBinder(ISerializationBinder value);
    public virtual StreamingContext get_Context();
    public virtual void set_Context(StreamingContext value);
    public virtual Formatting get_Formatting();
    public virtual void set_Formatting(Formatting value);
    public virtual DateFormatHandling get_DateFormatHandling();
    public virtual void set_DateFormatHandling(DateFormatHandling value);
    public virtual DateTimeZoneHandling get_DateTimeZoneHandling();
    public virtual void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public virtual DateParseHandling get_DateParseHandling();
    public virtual void set_DateParseHandling(DateParseHandling value);
    public virtual FloatFormatHandling get_FloatFormatHandling();
    public virtual void set_FloatFormatHandling(FloatFormatHandling value);
    public virtual FloatParseHandling get_FloatParseHandling();
    public virtual void set_FloatParseHandling(FloatParseHandling value);
    public virtual StringEscapeHandling get_StringEscapeHandling();
    public virtual void set_StringEscapeHandling(StringEscapeHandling value);
    public virtual string get_DateFormatString();
    public virtual void set_DateFormatString(string value);
    public virtual CultureInfo get_Culture();
    public virtual void set_Culture(CultureInfo value);
    public virtual Nullable`1<int> get_MaxDepth();
    public virtual void set_MaxDepth(Nullable`1<int> value);
    public virtual bool get_CheckAdditionalContent();
    public virtual void set_CheckAdditionalContent(bool value);
    internal JsonSerializerInternalBase GetInternalSerializer();
    [NullableContextAttribute("2")]
internal virtual object DeserializeInternal(JsonReader reader, Type objectType);
    internal virtual void PopulateInternal(JsonReader reader, object target);
    [NullableContextAttribute("2")]
internal virtual void SerializeInternal(JsonWriter jsonWriter, object value, Type rootType);
}
public class Newtonsoft.Json.Serialization.JsonStringContract : JsonPrimitiveContract {
    [NullableContextAttribute("1")]
public JsonStringContract(Type underlyingType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Serialization.JsonTypeReflector : object {
    private static Nullable`1<bool> _dynamicCodeGeneration;
    private static Nullable`1<bool> _fullyTrusted;
    public static string IdPropertyName;
    public static string RefPropertyName;
    public static string TypePropertyName;
    public static string ValuePropertyName;
    public static string ArrayValuesPropertyName;
    public static string ShouldSerializePrefix;
    public static string SpecifiedPostfix;
    public static string ConcurrentDictionaryTypeName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ThreadSafeStore`2<Type, Func`2<Object[], object>> CreatorCache;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ThreadSafeStore`2<Type, Type> AssociatedMetadataTypesCache;
    [NullableAttribute("2")]
private static ReflectionObject _metadataTypeAttributeReflectionObject;
    public static bool DynamicCodeGeneration { get; }
    public static bool FullyTrusted { get; }
    public static ReflectionDelegateFactory ReflectionDelegateFactory { get; }
    private static JsonTypeReflector();
    public static T GetCachedAttribute(object attributeProvider);
    public static bool CanTypeDescriptorConvertString(Type type, TypeConverter& typeConverter);
    public static DataContractAttribute GetDataContractAttribute(Type type);
    public static DataMemberAttribute GetDataMemberAttribute(MemberInfo memberInfo);
    public static MemberSerialization GetObjectMemberSerialization(Type objectType, bool ignoreSerializableAttribute);
    public static JsonConverter GetJsonConverter(object attributeProvider);
    public static JsonConverter CreateJsonConverterInstance(Type converterType, Object[] args);
    public static NamingStrategy CreateNamingStrategyInstance(Type namingStrategyType, Object[] args);
    public static NamingStrategy GetContainerNamingStrategy(JsonContainerAttribute containerAttribute);
    private static Func`2<Object[], object> GetCreator(Type type);
    private static Type GetAssociatedMetadataType(Type type);
    private static Type GetAssociateMetadataTypeFromAttribute(Type type);
    private static T GetAttribute(Type type);
    private static T GetAttribute(MemberInfo memberInfo);
    public static bool IsNonSerializable(object provider);
    public static bool IsSerializable(object provider);
    public static T GetAttribute(object provider);
    [SecuritySafeCriticalAttribute]
public static bool get_DynamicCodeGeneration();
    public static bool get_FullyTrusted();
    public static ReflectionDelegateFactory get_ReflectionDelegateFactory();
}
public class Newtonsoft.Json.Serialization.KebabCaseNamingStrategy : NamingStrategy {
    public KebabCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames);
    public KebabCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames, bool processExtensionDataNames);
    [NullableContextAttribute("1")]
protected virtual string ResolvePropertyName(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Serialization.MemoryTraceWriter : object {
    private Queue`1<string> _traceMessages;
    private object _lock;
    [CompilerGeneratedAttribute]
private TraceLevel <LevelFilter>k__BackingField;
    public TraceLevel LevelFilter { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual TraceLevel get_LevelFilter();
    [CompilerGeneratedAttribute]
public void set_LevelFilter(TraceLevel value);
    public sealed virtual void Trace(TraceLevel level, string message, Exception ex);
    public IEnumerable`1<string> GetTraceMessages();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Newtonsoft.Json.Serialization.NamingStrategy : object {
    [CompilerGeneratedAttribute]
private bool <ProcessDictionaryKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ProcessExtensionDataNames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OverrideSpecifiedNames>k__BackingField;
    public bool ProcessDictionaryKeys { get; public set; }
    public bool ProcessExtensionDataNames { get; public set; }
    public bool OverrideSpecifiedNames { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ProcessDictionaryKeys();
    [CompilerGeneratedAttribute]
public void set_ProcessDictionaryKeys(bool value);
    [CompilerGeneratedAttribute]
public bool get_ProcessExtensionDataNames();
    [CompilerGeneratedAttribute]
public void set_ProcessExtensionDataNames(bool value);
    [CompilerGeneratedAttribute]
public bool get_OverrideSpecifiedNames();
    [CompilerGeneratedAttribute]
public void set_OverrideSpecifiedNames(bool value);
    public virtual string GetPropertyName(string name, bool hasSpecifiedName);
    public virtual string GetExtensionDataName(string name);
    public virtual string GetDictionaryKey(string key);
    protected abstract virtual string ResolvePropertyName(string name);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
protected bool Equals(NamingStrategy other);
}
public class Newtonsoft.Json.Serialization.ObjectConstructor`1 : MulticastDelegate {
    public ObjectConstructor`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual object Invoke(Object[] args);
    public virtual IAsyncResult BeginInvoke(Object[] args, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("64")]
public class Newtonsoft.Json.Serialization.OnErrorAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Serialization.ReflectionAttributeProvider : object {
    private object _attributeProvider;
    public ReflectionAttributeProvider(object attributeProvider);
    public sealed virtual IList`1<Attribute> GetAttributes(bool inherit);
    public sealed virtual IList`1<Attribute> GetAttributes(Type attributeType, bool inherit);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Serialization.ReflectionValueProvider : object {
    private MemberInfo _memberInfo;
    public ReflectionValueProvider(MemberInfo memberInfo);
    public sealed virtual void SetValue(object target, object value);
    public sealed virtual object GetValue(object target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.SerializationBinderAdapter : object {
    public SerializationBinder SerializationBinder;
    public SerializationBinderAdapter(SerializationBinder serializationBinder);
    public sealed virtual Type BindToType(string assemblyName, string typeName);
    [NullableContextAttribute("2")]
public sealed virtual void BindToName(Type serializedType, String& assemblyName, String& typeName);
}
public class Newtonsoft.Json.Serialization.SerializationCallback : MulticastDelegate {
    public SerializationCallback(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object o, StreamingContext context);
    public virtual IAsyncResult BeginInvoke(object o, StreamingContext context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Newtonsoft.Json.Serialization.SerializationErrorCallback : MulticastDelegate {
    public SerializationErrorCallback(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object o, StreamingContext context, ErrorContext errorContext);
    public virtual IAsyncResult BeginInvoke(object o, StreamingContext context, ErrorContext errorContext, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Newtonsoft.Json.Serialization.SnakeCaseNamingStrategy : NamingStrategy {
    public SnakeCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames);
    public SnakeCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames, bool processExtensionDataNames);
    [NullableContextAttribute("1")]
protected virtual string ResolvePropertyName(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.TraceJsonReader : JsonReader {
    private JsonReader _innerReader;
    private JsonTextWriter _textWriter;
    private StringWriter _sw;
    public int Depth { get; }
    public string Path { get; }
    public char QuoteChar { get; protected internal set; }
    public JsonToken TokenType { get; }
    [NullableAttribute("2")]
public object Value { get; }
    [NullableAttribute("2")]
public Type ValueType { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    public TraceJsonReader(JsonReader innerReader);
    public string GetDeserializedJsonMessage();
    public virtual bool Read();
    public virtual Nullable`1<int> ReadAsInt32();
    [NullableContextAttribute("2")]
public virtual string ReadAsString();
    [NullableContextAttribute("2")]
public virtual Byte[] ReadAsBytes();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<double> ReadAsDouble();
    public virtual Nullable`1<bool> ReadAsBoolean();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    public void WriteCurrentToken();
    public virtual int get_Depth();
    public virtual string get_Path();
    public virtual char get_QuoteChar();
    protected internal virtual void set_QuoteChar(char value);
    public virtual JsonToken get_TokenType();
    [NullableContextAttribute("2")]
public virtual object get_Value();
    [NullableContextAttribute("2")]
public virtual Type get_ValueType();
    public virtual void Close();
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.TraceJsonWriter : JsonWriter {
    private JsonWriter _innerWriter;
    private JsonTextWriter _textWriter;
    private StringWriter _sw;
    public TraceJsonWriter(JsonWriter innerWriter);
    public string GetSerializedJsonMessage();
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(Nullable`1<decimal> value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(Nullable`1<bool> value);
    public virtual void WriteValue(byte value);
    public virtual void WriteValue(Nullable`1<byte> value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(Nullable`1<char> value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(Nullable`1<DateTime> value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Nullable`1<DateTimeOffset> value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(Nullable`1<double> value);
    public virtual void WriteUndefined();
    public virtual void WriteNull();
    public virtual void WriteValue(float value);
    public virtual void WriteValue(Nullable`1<float> value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(Nullable`1<Guid> value);
    public virtual void WriteValue(int value);
    public virtual void WriteValue(Nullable`1<int> value);
    public virtual void WriteValue(long value);
    public virtual void WriteValue(Nullable`1<long> value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(object value);
    public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(Nullable`1<sbyte> value);
    public virtual void WriteValue(short value);
    public virtual void WriteValue(Nullable`1<short> value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(string value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Nullable`1<TimeSpan> value);
    public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(Nullable`1<UInt32> value);
    public virtual void WriteValue(ulong value);
    public virtual void WriteValue(Nullable`1<ulong> value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(Uri value);
    public virtual void WriteValue(ushort value);
    public virtual void WriteValue(Nullable`1<ushort> value);
    public virtual void WriteWhitespace(string ws);
    [NullableContextAttribute("2")]
public virtual void WriteComment(string text);
    public virtual void WriteStartArray();
    public virtual void WriteEndArray();
    public virtual void WriteStartConstructor(string name);
    public virtual void WriteEndConstructor();
    public virtual void WritePropertyName(string name);
    public virtual void WritePropertyName(string name, bool escape);
    public virtual void WriteStartObject();
    public virtual void WriteEndObject();
    [NullableContextAttribute("2")]
public virtual void WriteRawValue(string json);
    [NullableContextAttribute("2")]
public virtual void WriteRaw(string json);
    public virtual void Close();
    public virtual void Flush();
}
public enum Newtonsoft.Json.StringEscapeHandling : Enum {
    public int value__;
    public static StringEscapeHandling Default;
    public static StringEscapeHandling EscapeNonAscii;
    public static StringEscapeHandling EscapeHtml;
}
public enum Newtonsoft.Json.TypeNameAssemblyFormatHandling : Enum {
    public int value__;
    public static TypeNameAssemblyFormatHandling Simple;
    public static TypeNameAssemblyFormatHandling Full;
}
[FlagsAttribute]
public enum Newtonsoft.Json.TypeNameHandling : Enum {
    public int value__;
    public static TypeNameHandling None;
    public static TypeNameHandling Objects;
    public static TypeNameHandling Arrays;
    public static TypeNameHandling All;
    public static TypeNameHandling Auto;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.AsyncUtils : object {
    public static Task`1<bool> False;
    public static Task`1<bool> True;
    internal static Task CompletedTask;
    private static AsyncUtils();
    [ExtensionAttribute]
internal static Task`1<bool> ToAsync(bool value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Task CancelIfRequestedAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Task`1<T> CancelIfRequestedAsync(CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task FromCanceled(CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<T> FromCanceled(CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task WriteAsync(TextWriter writer, char value, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task WriteAsync(TextWriter writer, string value, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task WriteAsync(TextWriter writer, Char[] value, int start, int count, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<int> ReadAsync(TextReader reader, Char[] buffer, int index, int count, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsCompletedSuccessfully(Task task);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.Base64Encoder : object {
    private static int Base64LineSize;
    private static int LineSizeInBytes;
    private Char[] _charsLine;
    private TextWriter _writer;
    [NullableAttribute("2")]
private Byte[] _leftOverBytes;
    private int _leftOverBytesCount;
    public Base64Encoder(TextWriter writer);
    private void ValidateEncode(Byte[] buffer, int index, int count);
    public void Encode(Byte[] buffer, int index, int count);
    private void StoreLeftOverBytes(Byte[] buffer, int index, Int32& count);
    private bool FulfillFromLeftover(Byte[] buffer, int index, Int32& count);
    public void Flush();
    private void WriteChars(Char[] chars, int index, int count);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Utilities.Base64Encoder/<EncodeAsync>d__13")]
public Task EncodeAsync(Byte[] buffer, int index, int count, CancellationToken cancellationToken);
    private Task WriteCharsAsync(Char[] chars, int index, int count, CancellationToken cancellationToken);
    public Task FlushAsync(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.BidirectionalDictionary`2 : object {
    private IDictionary`2<TFirst, TSecond> _firstToSecond;
    private IDictionary`2<TSecond, TFirst> _secondToFirst;
    private string _duplicateFirstErrorMessage;
    private string _duplicateSecondErrorMessage;
    public BidirectionalDictionary`2(IEqualityComparer`1<TFirst> firstEqualityComparer, IEqualityComparer`1<TSecond> secondEqualityComparer);
    public BidirectionalDictionary`2(IEqualityComparer`1<TFirst> firstEqualityComparer, IEqualityComparer`1<TSecond> secondEqualityComparer, string duplicateFirstErrorMessage, string duplicateSecondErrorMessage);
    public void Set(TFirst first, TSecond second);
    public bool TryGetByFirst(TFirst first, TSecond& second);
    public bool TryGetBySecond(TSecond second, TFirst& first);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Utilities.BoxedPrimitives : object {
    internal static object BooleanTrue;
    internal static object BooleanFalse;
    internal static object Int32_M1;
    internal static object Int32_0;
    internal static object Int32_1;
    internal static object Int32_2;
    internal static object Int32_3;
    internal static object Int32_4;
    internal static object Int32_5;
    internal static object Int32_6;
    internal static object Int32_7;
    internal static object Int32_8;
    internal static object Int64_M1;
    internal static object Int64_0;
    internal static object Int64_1;
    internal static object Int64_2;
    internal static object Int64_3;
    internal static object Int64_4;
    internal static object Int64_5;
    internal static object Int64_6;
    internal static object Int64_7;
    internal static object Int64_8;
    internal static object DoubleNaN;
    internal static object DoublePositiveInfinity;
    internal static object DoubleNegativeInfinity;
    internal static object DoubleZero;
    internal static object DoubleNegativeZero;
    private static BoxedPrimitives();
    internal static object Get(bool value);
    internal static object Get(int value);
    internal static object Get(long value);
    internal static object Get(decimal value);
    internal static object Get(double value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Utilities.BufferUtils : object {
    [NullableContextAttribute("1")]
public static Char[] RentBuffer(IArrayPool`1<char> bufferPool, int minSize);
    public static void ReturnBuffer(IArrayPool`1<char> bufferPool, Char[] buffer);
    public static Char[] EnsureBufferSize(IArrayPool`1<char> bufferPool, int size, Char[] buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.CollectionUtils : object {
    public static bool IsNullOrEmpty(ICollection`1<T> collection);
    [ExtensionAttribute]
public static void AddRange(IList`1<T> initial, IEnumerable`1<T> collection);
    public static bool IsDictionaryType(Type type);
    public static ConstructorInfo ResolveEnumerableCollectionConstructor(Type collectionType, Type collectionItemType);
    public static ConstructorInfo ResolveEnumerableCollectionConstructor(Type collectionType, Type collectionItemType, Type constructorArgumentType);
    [ExtensionAttribute]
public static bool AddDistinct(IList`1<T> list, T value);
    [ExtensionAttribute]
public static bool AddDistinct(IList`1<T> list, T value, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool ContainsValue(IEnumerable`1<TSource> source, TSource value, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static bool AddRangeDistinct(IList`1<T> list, IEnumerable`1<T> values, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> collection, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool Contains(List`1<T> list, T value, IEqualityComparer comparer);
    [ExtensionAttribute]
public static int IndexOfReference(List`1<T> list, T item);
    [ExtensionAttribute]
public static void FastReverse(List`1<T> list);
    private static IList`1<int> GetDimensions(IList values, int dimensionsCount);
    private static void CopyFromJaggedToMultidimensionalArray(IList values, Array multidimensionalArray, Int32[] indices);
    private static object JaggedArrayGetValue(IList values, Int32[] indices);
    public static Array ToMultidimensionalArray(IList values, Type type, int rank);
    public static T[] ArrayEmpty();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.CollectionWrapper`1 : object {
    [NullableAttribute("2")]
private IList _list;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ICollection`1<T> _genericCollection;
    [NullableAttribute("2")]
private object _syncRoot;
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public object UnderlyingCollection { get; }
    public CollectionWrapper`1(IList list);
    public CollectionWrapper`1(ICollection`1<T> list);
    public virtual void Add(T item);
    public virtual void Clear();
    public virtual bool Contains(T item);
    public virtual void CopyTo(T[] array, int arrayIndex);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual bool Remove(T item);
    public virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.Add(object value);
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.IList.Contains(object value);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Remove(object value);
    [NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IList.get_Item(int index);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    [NullableContextAttribute("2")]
private static void VerifyValueType(object value);
    [NullableContextAttribute("2")]
private static bool IsCompatibleObject(object value);
    public sealed virtual object get_UnderlyingCollection();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Utilities.ConvertUtils : object {
    private static Dictionary`2<Type, PrimitiveTypeCode> TypeCodeMap;
    private static TypeInformation[] PrimitiveTypeCodes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ThreadSafeStore`2<StructMultiKey`2<Type, Type>, Func`2<object, object>> CastConverters;
    private static ConvertUtils();
    public static PrimitiveTypeCode GetTypeCode(Type t);
    public static PrimitiveTypeCode GetTypeCode(Type t, Boolean& isEnum);
    public static TypeInformation GetTypeInformation(IConvertible convertable);
    public static bool IsConvertible(Type t);
    public static TimeSpan ParseTimeSpan(string input);
    [NullableContextAttribute("2")]
private static Func`2<object, object> CreateCastConverter(StructMultiKey`2<Type, Type> t);
    internal static BigInteger ToBigInteger(object value);
    public static object FromBigInteger(BigInteger i, Type targetType);
    public static object Convert(object initialValue, CultureInfo culture, Type targetType);
    private static bool TryConvert(object initialValue, CultureInfo culture, Type targetType, Object& value);
    private static ConvertResult TryConvertInternal(object initialValue, CultureInfo culture, Type targetType, Object& value);
    public static object ConvertOrCast(object initialValue, CultureInfo culture, Type targetType);
    private static object EnsureTypeAssignable(object value, Type initialType, Type targetType);
    public static bool VersionTryParse(string input, Version& result);
    public static bool IsInteger(object value);
    public static ParseResult Int32TryParse(Char[] chars, int start, int length, Int32& value);
    public static ParseResult Int64TryParse(Char[] chars, int start, int length, Int64& value);
    public static ParseResult DecimalTryParse(Char[] chars, int start, int length, Decimal& value);
    public static bool TryConvertGuid(string s, Guid& g);
    public static bool TryHexTextToInt(Char[] text, int start, int end, Int32& value);
}
internal class Newtonsoft.Json.Utilities.Creator`1 : MulticastDelegate {
    public Creator`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual T Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.DateTimeParser : ValueType {
    public int Year;
    public int Month;
    public int Day;
    public int Hour;
    public int Minute;
    public int Second;
    public int Fraction;
    public int ZoneHour;
    public int ZoneMinute;
    public ParserTimeZone Zone;
    private Char[] _text;
    private int _end;
    private static Int32[] Power10;
    private static int Lzyyyy;
    private static int Lzyyyy_;
    private static int Lzyyyy_MM;
    private static int Lzyyyy_MM_;
    private static int Lzyyyy_MM_dd;
    private static int Lzyyyy_MM_ddT;
    private static int LzHH;
    private static int LzHH_;
    private static int LzHH_mm;
    private static int LzHH_mm_;
    private static int LzHH_mm_ss;
    private static int Lz_;
    private static int Lz_zz;
    private static short MaxFractionDigits;
    private static DateTimeParser();
    public bool Parse(Char[] text, int startIndex, int length);
    private bool ParseDate(int start);
    private bool ParseTimeAndZoneAndWhitespace(int start);
    private bool ParseTime(Int32& start);
    private bool ParseZone(int start);
    private bool Parse4Digit(int start, Int32& num);
    private bool Parse2Digit(int start, Int32& num);
    private bool ParseChar(int start, char ch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.DateTimeUtils : object {
    internal static long InitialJavaScriptDateTicks;
    private static string IsoDateFormat;
    private static int DaysPer100Years;
    private static int DaysPer400Years;
    private static int DaysPer4Years;
    private static int DaysPerYear;
    private static long TicksPerDay;
    private static Int32[] DaysToMonth365;
    private static Int32[] DaysToMonth366;
    private static DateTimeUtils();
    [ExtensionAttribute]
public static TimeSpan GetUtcOffset(DateTime d);
    public static XmlDateTimeSerializationMode ToSerializationMode(DateTimeKind kind);
    internal static DateTime EnsureDateTime(DateTime value, DateTimeZoneHandling timeZone);
    private static DateTime SwitchToLocalTime(DateTime value);
    private static DateTime SwitchToUtcTime(DateTime value);
    private static long ToUniversalTicks(DateTime dateTime);
    private static long ToUniversalTicks(DateTime dateTime, TimeSpan offset);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, TimeSpan offset);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, bool convertToUtc);
    private static long UniversalTicksToJavaScriptTicks(long universalTicks);
    internal static DateTime ConvertJavaScriptTicksToDateTime(long javaScriptTicks);
    internal static bool TryParseDateTimeIso(StringReference text, DateTimeZoneHandling dateTimeZoneHandling, DateTime& dt);
    internal static bool TryParseDateTimeOffsetIso(StringReference text, DateTimeOffset& dt);
    private static DateTime CreateDateTime(DateTimeParser dateTimeParser);
    internal static bool TryParseDateTime(StringReference s, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, DateTime& dt);
    internal static bool TryParseDateTime(string s, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, DateTime& dt);
    internal static bool TryParseDateTimeOffset(StringReference s, string dateFormatString, CultureInfo culture, DateTimeOffset& dt);
    internal static bool TryParseDateTimeOffset(string s, string dateFormatString, CultureInfo culture, DateTimeOffset& dt);
    private static bool TryParseMicrosoftDate(StringReference text, Int64& ticks, TimeSpan& offset, DateTimeKind& kind);
    private static bool TryParseDateTimeMicrosoft(StringReference text, DateTimeZoneHandling dateTimeZoneHandling, DateTime& dt);
    private static bool TryParseDateTimeExact(string text, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, DateTime& dt);
    private static bool TryParseDateTimeOffsetMicrosoft(StringReference text, DateTimeOffset& dt);
    private static bool TryParseDateTimeOffsetExact(string text, string dateFormatString, CultureInfo culture, DateTimeOffset& dt);
    private static bool TryReadOffset(StringReference offsetText, int startIndex, TimeSpan& offset);
    internal static void WriteDateTimeString(TextWriter writer, DateTime value, DateFormatHandling format, string formatString, CultureInfo culture);
    internal static int WriteDateTimeString(Char[] chars, int start, DateTime value, Nullable`1<TimeSpan> offset, DateTimeKind kind, DateFormatHandling format);
    internal static int WriteDefaultIsoDate(Char[] chars, int start, DateTime dt);
    private static void CopyIntToCharArray(Char[] chars, int start, int value, int digits);
    internal static int WriteDateTimeOffset(Char[] chars, int start, TimeSpan offset, DateFormatHandling format);
    internal static void WriteDateTimeOffsetString(TextWriter writer, DateTimeOffset value, DateFormatHandling format, string formatString, CultureInfo culture);
    private static void GetDateValues(DateTime td, Int32& year, Int32& month, Int32& day);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Newtonsoft.Json.Utilities.DictionaryWrapper`2 : object {
    [NullableAttribute("2")]
private IDictionary _dictionary;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<TKey, TValue> _genericDictionary;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyDictionary`2<TKey, TValue> _readOnlyDictionary;
    [NullableAttribute("2")]
private object _syncRoot;
    internal IDictionary`2<TKey, TValue> GenericDictionary { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public object UnderlyingDictionary { get; }
    public DictionaryWrapper`2(IDictionary dictionary);
    public DictionaryWrapper`2(IDictionary`2<TKey, TValue> dictionary);
    public DictionaryWrapper`2(IReadOnlyDictionary`2<TKey, TValue> dictionary);
    internal IDictionary`2<TKey, TValue> get_GenericDictionary();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    public sealed virtual void Remove(object key);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual object get_UnderlyingDictionary();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.DynamicProxy`1 : object {
    public virtual IEnumerable`1<string> GetDynamicMemberNames(T instance);
    public virtual bool TryBinaryOperation(T instance, BinaryOperationBinder binder, object arg, Object& result);
    public virtual bool TryConvert(T instance, ConvertBinder binder, Object& result);
    public virtual bool TryCreateInstance(T instance, CreateInstanceBinder binder, Object[] args, Object& result);
    public virtual bool TryDeleteIndex(T instance, DeleteIndexBinder binder, Object[] indexes);
    public virtual bool TryDeleteMember(T instance, DeleteMemberBinder binder);
    public virtual bool TryGetIndex(T instance, GetIndexBinder binder, Object[] indexes, Object& result);
    public virtual bool TryGetMember(T instance, GetMemberBinder binder, Object& result);
    public virtual bool TryInvoke(T instance, InvokeBinder binder, Object[] args, Object& result);
    public virtual bool TryInvokeMember(T instance, InvokeMemberBinder binder, Object[] args, Object& result);
    public virtual bool TrySetIndex(T instance, SetIndexBinder binder, Object[] indexes, object value);
    public virtual bool TrySetMember(T instance, SetMemberBinder binder, object value);
    public virtual bool TryUnaryOperation(T instance, UnaryOperationBinder binder, Object& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.DynamicProxyMetaObject`1 : DynamicMetaObject {
    private DynamicProxy`1<T> _proxy;
    private static Expression[] NoArgs { get; }
    internal DynamicProxyMetaObject`1(Expression expression, T value, DynamicProxy`1<T> proxy);
    private bool IsOverridden(string method);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    public virtual DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value);
    public virtual DynamicMetaObject BindDeleteMember(DeleteMemberBinder binder);
    public virtual DynamicMetaObject BindConvert(ConvertBinder binder);
    public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindCreateInstance(CreateInstanceBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindBinaryOperation(BinaryOperationBinder binder, DynamicMetaObject arg);
    public virtual DynamicMetaObject BindUnaryOperation(UnaryOperationBinder binder);
    public virtual DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value);
    public virtual DynamicMetaObject BindDeleteIndex(DeleteIndexBinder binder, DynamicMetaObject[] indexes);
    private static Expression[] get_NoArgs();
    private static IEnumerable`1<Expression> GetArgs(DynamicMetaObject[] args);
    private static Expression[] GetArgArray(DynamicMetaObject[] args);
    private static Expression[] GetArgArray(DynamicMetaObject[] args, DynamicMetaObject value);
    private static ConstantExpression Constant(DynamicMetaObjectBinder binder);
    private DynamicMetaObject CallMethodWithResult(string methodName, DynamicMetaObjectBinder binder, IEnumerable`1<Expression> args, Fallback<T> fallback, Fallback<T> fallbackInvoke);
    private DynamicMetaObject BuildCallMethodWithResult(string methodName, DynamicMetaObjectBinder binder, IEnumerable`1<Expression> args, DynamicMetaObject fallbackResult, Fallback<T> fallbackInvoke);
    private DynamicMetaObject CallMethodReturnLast(string methodName, DynamicMetaObjectBinder binder, IEnumerable`1<Expression> args, Fallback<T> fallback);
    private DynamicMetaObject CallMethodNoResult(string methodName, DynamicMetaObjectBinder binder, Expression[] args, Fallback<T> fallback);
    private BindingRestrictions GetRestrictions();
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.DynamicReflectionDelegateFactory : ReflectionDelegateFactory {
    [CompilerGeneratedAttribute]
private static DynamicReflectionDelegateFactory <Instance>k__BackingField;
    internal static DynamicReflectionDelegateFactory Instance { get; }
    private static DynamicReflectionDelegateFactory();
    [CompilerGeneratedAttribute]
internal static DynamicReflectionDelegateFactory get_Instance();
    private static DynamicMethod CreateDynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner);
    public virtual ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method);
    public virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    private void GenerateCreateMethodCallIL(MethodBase method, ILGenerator generator, int argsIndex);
    public virtual Func`1<T> CreateDefaultConstructor(Type type);
    private void GenerateCreateDefaultConstructorIL(Type type, ILGenerator generator, Type delegateType);
    public virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    private void GenerateCreateGetPropertyIL(PropertyInfo propertyInfo, ILGenerator generator);
    public virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    private void GenerateCreateGetFieldIL(FieldInfo fieldInfo, ILGenerator generator);
    public virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    internal static void GenerateCreateSetFieldIL(FieldInfo fieldInfo, ILGenerator generator);
    public virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
    internal static void GenerateCreateSetPropertyIL(PropertyInfo propertyInfo, ILGenerator generator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.DynamicUtils : object {
    [ExtensionAttribute]
public static IEnumerable`1<string> GetDynamicMemberNames(IDynamicMetaObjectProvider dynamicProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.EnumInfo : object {
    public bool IsFlags;
    public UInt64[] Values;
    public String[] Names;
    public String[] ResolvedNames;
    public EnumInfo(bool isFlags, UInt64[] values, String[] names, String[] resolvedNames);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Utilities.EnumUtils : object {
    private static char EnumSeparatorChar;
    private static string EnumSeparatorString;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ThreadSafeStore`2<StructMultiKey`2<Type, NamingStrategy>, EnumInfo> ValuesAndNamesPerEnum;
    private static CamelCaseNamingStrategy _camelCaseNamingStrategy;
    private static EnumUtils();
    private static EnumInfo InitializeValuesAndNames(StructMultiKey`2<Type, NamingStrategy> key);
    [NullableContextAttribute("0")]
public static IList`1<T> GetFlagsValues(T value);
    public static bool TryToString(Type enumType, object value, bool camelCase, String& name);
    public static bool TryToString(Type enumType, object value, NamingStrategy namingStrategy, String& name);
    private static string InternalFlagsFormat(EnumInfo entry, ulong result);
    public static EnumInfo GetEnumValuesAndNames(Type enumType);
    private static ulong ToUInt64(object value);
    public static object ParseEnum(Type enumType, NamingStrategy namingStrategy, string value, bool disallowNumber);
    private static Nullable`1<int> MatchName(string value, String[] enumNames, String[] resolvedNames, int valueIndex, int valueSubstringLength, StringComparison comparison);
    private static Nullable`1<int> FindIndexByName(String[] enumNames, string value, int valueIndex, int valueSubstringLength, StringComparison comparison);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.ExpressionReflectionDelegateFactory : ReflectionDelegateFactory {
    private static ExpressionReflectionDelegateFactory _instance;
    internal static ReflectionDelegateFactory Instance { get; }
    private static ExpressionReflectionDelegateFactory();
    internal static ReflectionDelegateFactory get_Instance();
    public virtual ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method);
    public virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    private Expression BuildMethodCall(MethodBase method, Type type, ParameterExpression targetParameterExpression, ParameterExpression argsParameterExpression);
    public virtual Func`1<T> CreateDefaultConstructor(Type type);
    public virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
    private Expression EnsureCastExpression(Expression expression, Type targetType, bool allowWidening);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.FSharpFunction : object {
    private object _instance;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private MethodCall`2<object, object> _invoker;
    public FSharpFunction(object instance, MethodCall`2<object, object> invoker);
    [NullableContextAttribute("1")]
public object Invoke(Object[] args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.FSharpUtils : object {
    private static object Lock;
    [NullableAttribute("2")]
private static FSharpUtils _instance;
    private MethodInfo _ofSeq;
    private Type _mapType;
    [CompilerGeneratedAttribute]
private Assembly <FSharpCoreAssembly>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MethodCall`2<object, object> <IsUnion>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MethodCall`2<object, object> <GetUnionCases>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MethodCall`2<object, object> <PreComputeUnionTagReader>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MethodCall`2<object, object> <PreComputeUnionReader>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MethodCall`2<object, object> <PreComputeUnionConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, object> <GetUnionCaseInfoDeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, object> <GetUnionCaseInfoName>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, object> <GetUnionCaseInfoTag>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MethodCall`2<object, object> <GetUnionCaseInfoFields>k__BackingField;
    public static string FSharpSetTypeName;
    public static string FSharpListTypeName;
    public static string FSharpMapTypeName;
    public static FSharpUtils Instance { get; }
    public Assembly FSharpCoreAssembly { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public MethodCall`2<object, object> IsUnion { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public MethodCall`2<object, object> GetUnionCases { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public MethodCall`2<object, object> PreComputeUnionTagReader { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public MethodCall`2<object, object> PreComputeUnionReader { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public MethodCall`2<object, object> PreComputeUnionConstructor { get; private set; }
    public Func`2<object, object> GetUnionCaseInfoDeclaringType { get; private set; }
    public Func`2<object, object> GetUnionCaseInfoName { get; private set; }
    public Func`2<object, object> GetUnionCaseInfoTag { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public MethodCall`2<object, object> GetUnionCaseInfoFields { get; private set; }
    private FSharpUtils(Assembly fsharpCoreAssembly);
    private static FSharpUtils();
    public static FSharpUtils get_Instance();
    [CompilerGeneratedAttribute]
public Assembly get_FSharpCoreAssembly();
    [CompilerGeneratedAttribute]
private void set_FSharpCoreAssembly(Assembly value);
    [CompilerGeneratedAttribute]
public MethodCall`2<object, object> get_IsUnion();
    [CompilerGeneratedAttribute]
private void set_IsUnion(MethodCall`2<object, object> value);
    [CompilerGeneratedAttribute]
public MethodCall`2<object, object> get_GetUnionCases();
    [CompilerGeneratedAttribute]
private void set_GetUnionCases(MethodCall`2<object, object> value);
    [CompilerGeneratedAttribute]
public MethodCall`2<object, object> get_PreComputeUnionTagReader();
    [CompilerGeneratedAttribute]
private void set_PreComputeUnionTagReader(MethodCall`2<object, object> value);
    [CompilerGeneratedAttribute]
public MethodCall`2<object, object> get_PreComputeUnionReader();
    [CompilerGeneratedAttribute]
private void set_PreComputeUnionReader(MethodCall`2<object, object> value);
    [CompilerGeneratedAttribute]
public MethodCall`2<object, object> get_PreComputeUnionConstructor();
    [CompilerGeneratedAttribute]
private void set_PreComputeUnionConstructor(MethodCall`2<object, object> value);
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_GetUnionCaseInfoDeclaringType();
    [CompilerGeneratedAttribute]
private void set_GetUnionCaseInfoDeclaringType(Func`2<object, object> value);
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_GetUnionCaseInfoName();
    [CompilerGeneratedAttribute]
private void set_GetUnionCaseInfoName(Func`2<object, object> value);
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_GetUnionCaseInfoTag();
    [CompilerGeneratedAttribute]
private void set_GetUnionCaseInfoTag(Func`2<object, object> value);
    [CompilerGeneratedAttribute]
public MethodCall`2<object, object> get_GetUnionCaseInfoFields();
    [CompilerGeneratedAttribute]
private void set_GetUnionCaseInfoFields(MethodCall`2<object, object> value);
    public static void EnsureInitialized(Assembly fsharpCoreAssembly);
    private static MethodInfo GetMethodWithNonPublicFallback(Type type, string methodName, BindingFlags bindingFlags);
    private static MethodCall`2<object, object> CreateFSharpFuncCall(Type type, string methodName);
    public ObjectConstructor`1<object> CreateSeq(Type t);
    public ObjectConstructor`1<object> CreateMap(Type keyType, Type valueType);
    [NullableContextAttribute("2")]
public ObjectConstructor`1<object> BuildMapCreator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.ILGeneratorExtensions : object {
    [ExtensionAttribute]
public static void PushInstance(ILGenerator generator, Type type);
    [ExtensionAttribute]
public static void PushArrayInstance(ILGenerator generator, int argsIndex, int arrayIndex);
    [ExtensionAttribute]
public static void BoxIfNeeded(ILGenerator generator, Type type);
    [ExtensionAttribute]
public static void UnboxIfNeeded(ILGenerator generator, Type type);
    [ExtensionAttribute]
public static void CallMethod(ILGenerator generator, MethodInfo methodInfo);
    [ExtensionAttribute]
public static void Return(ILGenerator generator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Utilities.ImmutableCollectionsUtils : object {
    private static string ImmutableListGenericInterfaceTypeName;
    private static string ImmutableQueueGenericInterfaceTypeName;
    private static string ImmutableStackGenericInterfaceTypeName;
    private static string ImmutableSetGenericInterfaceTypeName;
    private static string ImmutableArrayTypeName;
    private static string ImmutableArrayGenericTypeName;
    private static string ImmutableListTypeName;
    private static string ImmutableListGenericTypeName;
    private static string ImmutableQueueTypeName;
    private static string ImmutableQueueGenericTypeName;
    private static string ImmutableStackTypeName;
    private static string ImmutableStackGenericTypeName;
    private static string ImmutableSortedSetTypeName;
    private static string ImmutableSortedSetGenericTypeName;
    private static string ImmutableHashSetTypeName;
    private static string ImmutableHashSetGenericTypeName;
    private static IList`1<ImmutableCollectionTypeInfo> ArrayContractImmutableCollectionDefinitions;
    private static string ImmutableDictionaryGenericInterfaceTypeName;
    private static string ImmutableDictionaryTypeName;
    private static string ImmutableDictionaryGenericTypeName;
    private static string ImmutableSortedDictionaryTypeName;
    private static string ImmutableSortedDictionaryGenericTypeName;
    private static IList`1<ImmutableCollectionTypeInfo> DictionaryContractImmutableCollectionDefinitions;
    private static ImmutableCollectionsUtils();
    internal static bool TryBuildImmutableForArrayContract(Type underlyingType, Type collectionItemType, Type& createdType, ObjectConstructor`1& parameterizedCreator);
    internal static bool TryBuildImmutableForDictionaryContract(Type underlyingType, Type keyItemType, Type valueItemType, Type& createdType, ObjectConstructor`1& parameterizedCreator);
}
internal interface Newtonsoft.Json.Utilities.IWrappedCollection {
    [NullableAttribute("1")]
public object UnderlyingCollection { get; }
    [NullableContextAttribute("1")]
public abstract virtual object get_UnderlyingCollection();
}
internal interface Newtonsoft.Json.Utilities.IWrappedDictionary {
    [NullableAttribute("1")]
public object UnderlyingDictionary { get; }
    [NullableContextAttribute("1")]
public abstract virtual object get_UnderlyingDictionary();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Utilities.JavaScriptUtils : object {
    internal static Boolean[] SingleQuoteCharEscapeFlags;
    internal static Boolean[] DoubleQuoteCharEscapeFlags;
    internal static Boolean[] HtmlCharEscapeFlags;
    private static int UnicodeTextLength;
    private static string EscapedUnicodeText;
    private static JavaScriptUtils();
    public static Boolean[] GetCharEscapeFlags(StringEscapeHandling stringEscapeHandling, char quoteChar);
    public static bool ShouldEscapeJavaScriptString(string s, Boolean[] charEscapeFlags);
    [NullableContextAttribute("2")]
public static void WriteEscapedJavaScriptString(TextWriter writer, string s, char delimiter, bool appendDelimiters, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, IArrayPool`1<char> bufferPool, Char[]& writeBuffer);
    public static string ToEscapedJavaScriptString(string value, char delimiter, bool appendDelimiters, StringEscapeHandling stringEscapeHandling);
    private static int FirstCharToEscape(string s, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling);
    public static Task WriteEscapedJavaScriptStringAsync(TextWriter writer, string s, char delimiter, bool appendDelimiters, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, JsonTextWriter client, Char[] writeBuffer, CancellationToken cancellationToken);
    private static Task WriteEscapedJavaScriptStringWithDelimitersAsync(TextWriter writer, string s, char delimiter, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, JsonTextWriter client, Char[] writeBuffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Utilities.JavaScriptUtils/<WriteEscapedJavaScriptStringWithDelimitersAsync>d__13")]
private static Task WriteEscapedJavaScriptStringWithDelimitersAsync(Task task, TextWriter writer, string s, char delimiter, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, JsonTextWriter client, Char[] writeBuffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Utilities.JavaScriptUtils/<WriteCharAsync>d__14")]
public static Task WriteCharAsync(Task task, TextWriter writer, char c, CancellationToken cancellationToken);
    private static Task WriteEscapedJavaScriptStringWithoutDelimitersAsync(TextWriter writer, string s, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, JsonTextWriter client, Char[] writeBuffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Utilities.JavaScriptUtils/<WriteDefinitelyEscapedJavaScriptStringWithoutDelimitersAsync>d__16")]
private static Task WriteDefinitelyEscapedJavaScriptStringWithoutDelimitersAsync(TextWriter writer, string s, int lastWritePosition, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, JsonTextWriter client, Char[] writeBuffer, CancellationToken cancellationToken);
    public static bool TryGetDateFromConstructorJson(JsonReader reader, DateTime& dateTime, String& errorMessage);
    private static bool TryGetDateConstructorValue(JsonReader reader, Nullable`1& integer, String& errorMessage);
}
internal static class Newtonsoft.Json.Utilities.JsonTokenUtils : object {
    internal static bool IsEndToken(JsonToken token);
    internal static bool IsStartToken(JsonToken token);
    internal static bool IsPrimitiveToken(JsonToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.LateBoundReflectionDelegateFactory : ReflectionDelegateFactory {
    private static LateBoundReflectionDelegateFactory _instance;
    internal static ReflectionDelegateFactory Instance { get; }
    private static LateBoundReflectionDelegateFactory();
    internal static ReflectionDelegateFactory get_Instance();
    public virtual ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method);
    public virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    public virtual Func`1<T> CreateDefaultConstructor(Type type);
    public virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
}
internal static class Newtonsoft.Json.Utilities.MathUtils : object {
    public static int IntLength(ulong i);
    public static char IntToHex(int n);
    public static Nullable`1<int> Min(Nullable`1<int> val1, Nullable`1<int> val2);
    public static Nullable`1<int> Max(Nullable`1<int> val1, Nullable`1<int> val2);
    public static Nullable`1<double> Max(Nullable`1<double> val1, Nullable`1<double> val2);
    public static bool ApproxEquals(double d1, double d2);
}
internal class Newtonsoft.Json.Utilities.MethodCall`2 : MulticastDelegate {
    public MethodCall`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T target, Object[] args);
    public virtual IAsyncResult BeginInvoke(T target, Object[] args, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Utilities.MiscellaneousUtils : object {
    [NullableContextAttribute("2")]
[ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message);
    [NullableContextAttribute("2")]
public static bool ValueEquals(object objA, object objB);
    public static ArgumentOutOfRangeException CreateArgumentOutOfRangeException(string paramName, object actualValue, string message);
    public static string ToString(object value);
    public static int ByteArrayCompare(Byte[] a1, Byte[] a2);
    public static string GetPrefix(string qualifiedName);
    public static string GetLocalName(string qualifiedName);
    public static void GetQualifiedNameParts(string qualifiedName, String& prefix, String& localName);
    internal static RegexOptions GetRegexOptions(string optionsText);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.NoThrowExpressionVisitor : ExpressionVisitor {
    internal static object ErrorResult;
    private static NoThrowExpressionVisitor();
    protected virtual Expression VisitConditional(ConditionalExpression node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.NoThrowGetBinderMember : GetMemberBinder {
    private GetMemberBinder _innerBinder;
    public NoThrowGetBinderMember(GetMemberBinder innerBinder);
    public virtual DynamicMetaObject FallbackGetMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.NoThrowSetBinderMember : SetMemberBinder {
    private SetMemberBinder _innerBinder;
    public NoThrowSetBinderMember(SetMemberBinder innerBinder);
    public virtual DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
}
internal enum Newtonsoft.Json.Utilities.ParseResult : Enum {
    public int value__;
    public static ParseResult None;
    public static ParseResult Success;
    public static ParseResult Overflow;
    public static ParseResult Invalid;
}
internal enum Newtonsoft.Json.Utilities.ParserTimeZone : Enum {
    public int value__;
    public static ParserTimeZone Unspecified;
    public static ParserTimeZone Utc;
    public static ParserTimeZone LocalWestOfUtc;
    public static ParserTimeZone LocalEastOfUtc;
}
internal enum Newtonsoft.Json.Utilities.PrimitiveTypeCode : Enum {
    public int value__;
    public static PrimitiveTypeCode Empty;
    public static PrimitiveTypeCode Object;
    public static PrimitiveTypeCode Char;
    public static PrimitiveTypeCode CharNullable;
    public static PrimitiveTypeCode Boolean;
    public static PrimitiveTypeCode BooleanNullable;
    public static PrimitiveTypeCode SByte;
    public static PrimitiveTypeCode SByteNullable;
    public static PrimitiveTypeCode Int16;
    public static PrimitiveTypeCode Int16Nullable;
    public static PrimitiveTypeCode UInt16;
    public static PrimitiveTypeCode UInt16Nullable;
    public static PrimitiveTypeCode Int32;
    public static PrimitiveTypeCode Int32Nullable;
    public static PrimitiveTypeCode Byte;
    public static PrimitiveTypeCode ByteNullable;
    public static PrimitiveTypeCode UInt32;
    public static PrimitiveTypeCode UInt32Nullable;
    public static PrimitiveTypeCode Int64;
    public static PrimitiveTypeCode Int64Nullable;
    public static PrimitiveTypeCode UInt64;
    public static PrimitiveTypeCode UInt64Nullable;
    public static PrimitiveTypeCode Single;
    public static PrimitiveTypeCode SingleNullable;
    public static PrimitiveTypeCode Double;
    public static PrimitiveTypeCode DoubleNullable;
    public static PrimitiveTypeCode DateTime;
    public static PrimitiveTypeCode DateTimeNullable;
    public static PrimitiveTypeCode DateTimeOffset;
    public static PrimitiveTypeCode DateTimeOffsetNullable;
    public static PrimitiveTypeCode Decimal;
    public static PrimitiveTypeCode DecimalNullable;
    public static PrimitiveTypeCode Guid;
    public static PrimitiveTypeCode GuidNullable;
    public static PrimitiveTypeCode TimeSpan;
    public static PrimitiveTypeCode TimeSpanNullable;
    public static PrimitiveTypeCode BigInteger;
    public static PrimitiveTypeCode BigIntegerNullable;
    public static PrimitiveTypeCode Uri;
    public static PrimitiveTypeCode String;
    public static PrimitiveTypeCode Bytes;
    public static PrimitiveTypeCode DBNull;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Newtonsoft.Json.Utilities.ReflectionDelegateFactory : object {
    public Func`2<T, object> CreateGet(MemberInfo memberInfo);
    public Action`2<T, object> CreateSet(MemberInfo memberInfo);
    public abstract virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    public abstract virtual ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method);
    public abstract virtual Func`1<T> CreateDefaultConstructor(Type type);
    public abstract virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public abstract virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public abstract virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public abstract virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.ReflectionMember : object {
    [CompilerGeneratedAttribute]
private Type <MemberType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<object, object> <Getter>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`2<object, object> <Setter>k__BackingField;
    public Type MemberType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<object, object> Getter { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<object, object> Setter { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_MemberType();
    [CompilerGeneratedAttribute]
public void set_MemberType(Type value);
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_Getter();
    [CompilerGeneratedAttribute]
public void set_Getter(Func`2<object, object> value);
    [CompilerGeneratedAttribute]
public Action`2<object, object> get_Setter();
    [CompilerGeneratedAttribute]
public void set_Setter(Action`2<object, object> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.ReflectionObject : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ObjectConstructor`1<object> <Creator>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, ReflectionMember> <Members>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ObjectConstructor`1<object> Creator { get; }
    public IDictionary`2<string, ReflectionMember> Members { get; }
    private ReflectionObject(ObjectConstructor`1<object> creator);
    [CompilerGeneratedAttribute]
public ObjectConstructor`1<object> get_Creator();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, ReflectionMember> get_Members();
    public object GetValue(object target, string member);
    public void SetValue(object target, string member, object value);
    public Type GetType(string member);
    public static ReflectionObject Create(Type t, String[] memberNames);
    public static ReflectionObject Create(Type t, MethodBase creator, String[] memberNames);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.ReflectionUtils : object {
    public static Type[] EmptyTypes;
    private static ReflectionUtils();
    [ExtensionAttribute]
public static bool IsVirtual(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static MethodInfo GetBaseDefinition(PropertyInfo propertyInfo);
    public static bool IsPublic(PropertyInfo property);
    [NullableContextAttribute("2")]
public static Type GetObjectType(object v);
    public static string GetTypeName(Type t, TypeNameAssemblyFormatHandling assemblyFormat, ISerializationBinder binder);
    private static string GetFullyQualifiedTypeName(Type t, ISerializationBinder binder);
    private static string RemoveAssemblyDetails(string fullyQualifiedTypeName);
    public static bool HasDefaultConstructor(Type t, bool nonPublic);
    public static ConstructorInfo GetDefaultConstructor(Type t);
    public static ConstructorInfo GetDefaultConstructor(Type t, bool nonPublic);
    public static bool IsNullable(Type t);
    public static bool IsNullableType(Type t);
    public static Type EnsureNotNullableType(Type t);
    public static Type EnsureNotByRefType(Type t);
    public static bool IsGenericDefinition(Type type, Type genericInterfaceDefinition);
    public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition);
    public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition, Type& implementingType);
    public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition);
    public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition, Type& implementingType);
    private static bool InheritsGenericDefinitionInternal(Type type, Type genericClassDefinition, Type& implementingType);
    public static Type GetCollectionItemType(Type type);
    [NullableContextAttribute("2")]
public static void GetDictionaryKeyValueTypes(Type dictionaryType, Type& keyType, Type& valueType);
    public static Type GetMemberUnderlyingType(MemberInfo member);
    public static bool IsByRefLikeType(Type type);
    public static bool IsIndexedProperty(PropertyInfo property);
    public static object GetMemberValue(MemberInfo member, object target);
    public static void SetMemberValue(MemberInfo member, object target, object value);
    public static bool CanReadMemberValue(MemberInfo member, bool nonPublic);
    public static bool CanSetMemberValue(MemberInfo member, bool nonPublic, bool canSetReadOnly);
    public static List`1<MemberInfo> GetFieldsAndProperties(Type type, BindingFlags bindingAttr);
    private static bool IsOverridenGenericMember(MemberInfo memberInfo, BindingFlags bindingAttr);
    public static T GetAttribute(object attributeProvider);
    public static T GetAttribute(object attributeProvider, bool inherit);
    public static T[] GetAttributes(object attributeProvider, bool inherit);
    public static Attribute[] GetAttributes(object attributeProvider, Type attributeType, bool inherit);
    public static StructMultiKey`2<string, string> SplitFullyQualifiedTypeName(string fullyQualifiedTypeName);
    private static Nullable`1<int> GetAssemblyDelimiterIndex(string fullyQualifiedTypeName);
    public static MemberInfo GetMemberInfoFromType(Type targetType, MemberInfo memberInfo);
    public static IEnumerable`1<FieldInfo> GetFields(Type targetType, BindingFlags bindingAttr);
    private static void GetChildPrivateFields(IList`1<MemberInfo> initialFields, Type type, BindingFlags bindingAttr);
    public static IEnumerable`1<PropertyInfo> GetProperties(Type targetType, BindingFlags bindingAttr);
    [ExtensionAttribute]
public static BindingFlags RemoveFlag(BindingFlags bindingAttr, BindingFlags flag);
    private static void GetChildPrivateProperties(IList`1<PropertyInfo> initialProperties, Type type, BindingFlags bindingAttr);
    public static bool IsMethodOverridden(Type currentType, Type methodDeclaringType, string method);
    public static object GetDefaultValue(Type type);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.StringBuffer : ValueType {
    private Char[] _buffer;
    private int _position;
    public int Position { get; public set; }
    public bool IsEmpty { get; }
    public Char[] InternalBuffer { get; }
    public StringBuffer(IArrayPool`1<char> bufferPool, int initalSize);
    [NullableContextAttribute("1")]
private StringBuffer(Char[] buffer);
    public int get_Position();
    public void set_Position(int value);
    public bool get_IsEmpty();
    public void Append(IArrayPool`1<char> bufferPool, char value);
    [NullableContextAttribute("1")]
public void Append(IArrayPool`1<char> bufferPool, Char[] buffer, int startIndex, int count);
    public void Clear(IArrayPool`1<char> bufferPool);
    private void EnsureSize(IArrayPool`1<char> bufferPool, int appendLength);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(int start, int length);
    public Char[] get_InternalBuffer();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Newtonsoft.Json.Utilities.StringReference : ValueType {
    private Char[] _chars;
    private int _startIndex;
    private int _length;
    public char Item { get; }
    public Char[] Chars { get; }
    public int StartIndex { get; }
    public int Length { get; }
    public StringReference(Char[] chars, int startIndex, int length);
    public char get_Item(int i);
    public Char[] get_Chars();
    public int get_StartIndex();
    public int get_Length();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.StringReferenceExtensions : object {
    [ExtensionAttribute]
public static int IndexOf(StringReference s, char c, int startIndex, int length);
    [ExtensionAttribute]
public static bool StartsWith(StringReference s, string text);
    [ExtensionAttribute]
public static bool EndsWith(StringReference s, string text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.StringUtils : object {
    public static string CarriageReturnLineFeed;
    public static string Empty;
    public static char CarriageReturn;
    public static char LineFeed;
    public static char Tab;
    [NullableContextAttribute("2")]
public static bool IsNullOrEmpty(string value);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0, object arg1);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0, object arg1, object arg2);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0, object arg1, object arg2, object arg3);
    [ExtensionAttribute]
private static string FormatWith(string format, IFormatProvider provider, Object[] args);
    public static bool IsWhiteSpace(string s);
    public static StringWriter CreateStringWriter(int capacity);
    public static void ToCharAsUnicode(char c, Char[] buffer);
    [ExtensionAttribute]
public static TSource ForgivingCaseSensitiveFind(IEnumerable`1<TSource> source, Func`2<TSource, string> valueSelector, string testValue);
    public static string ToCamelCase(string s);
    private static char ToLower(char c);
    public static string ToSnakeCase(string s);
    public static string ToKebabCase(string s);
    private static string ToSeparatedCase(string s, char separator);
    public static bool IsHighSurrogate(char c);
    public static bool IsLowSurrogate(char c);
    public static int IndexOf(string s, char c);
    public static string Replace(string s, string oldValue, string newValue);
    [ExtensionAttribute]
public static bool StartsWith(string source, char value);
    [ExtensionAttribute]
public static bool EndsWith(string source, char value);
    [ExtensionAttribute]
public static string Trim(string s, int start, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Newtonsoft.Json.Utilities.StructMultiKey`2 : ValueType {
    public T1 Value1;
    public T2 Value2;
    public StructMultiKey`2(T1 v1, T2 v2);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(StructMultiKey`2<T1, T2> other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.ThreadSafeStore`2 : object {
    private ConcurrentDictionary`2<TKey, TValue> _concurrentStore;
    private Func`2<TKey, TValue> _creator;
    public ThreadSafeStore`2(Func`2<TKey, TValue> creator);
    public TValue Get(TKey key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.TypeExtensions : object {
    [ExtensionAttribute]
public static MethodInfo Method(Delegate d);
    [ExtensionAttribute]
public static MemberTypes MemberType(MemberInfo memberInfo);
    [ExtensionAttribute]
public static bool ContainsGenericParameters(Type type);
    [ExtensionAttribute]
public static bool IsInterface(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
public static bool IsGenericTypeDefinition(Type type);
    [ExtensionAttribute]
public static Type BaseType(Type type);
    [ExtensionAttribute]
public static Assembly Assembly(Type type);
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool IsClass(Type type);
    [ExtensionAttribute]
public static bool IsSealed(Type type);
    [ExtensionAttribute]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
public static bool IsVisible(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static bool IsPrimitive(Type type);
    [ExtensionAttribute]
public static bool AssignableToTypeName(Type type, string fullTypeName, bool searchInterfaces, Type& match);
    [ExtensionAttribute]
public static bool AssignableToTypeName(Type type, string fullTypeName, bool searchInterfaces);
    [ExtensionAttribute]
public static bool ImplementInterface(Type type, Type interfaceType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.TypeInformation : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private PrimitiveTypeCode <TypeCode>k__BackingField;
    public Type Type { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public TypeInformation(Type type, PrimitiveTypeCode typeCode);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public PrimitiveTypeCode get_TypeCode();
}
internal static class Newtonsoft.Json.Utilities.ValidationUtils : object {
    [NullableContextAttribute("1")]
public static void ArgumentNotNull(object value, string parameterName);
}
public enum Newtonsoft.Json.WriteState : Enum {
    public int value__;
    public static WriteState Error;
    public static WriteState Closed;
    public static WriteState Object;
    public static WriteState Array;
    public static WriteState Constructor;
    public static WriteState Property;
    public static WriteState Start;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>SimplePool`1 : object {
    private object _lockObj;
    private Stack`1<T> _values;
    private Func`1<T> _allocate;
    public <07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>StringBuilderPool : object {
    private static int MaxPoolSize;
    private <07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>SimplePool`1<StringBuilder> _pool;
    public static <07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>StringBuilderPool Shared;
    private static <07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NuGet.<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static <07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>TaskResultCache`2 : object {
    private ConcurrentDictionary`2<TKey, Task`1<TValue>> _cache;
    private ConcurrentDictionary`2<TKey, object> _perTaskLock;
    public <07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>TaskResultCache`2(IEqualityComparer`1<TKey> comparer);
    public Task`1<TValue> GetOrAddAsync(TKey key, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
    public Task`1<TValue> GetOrAddAsync(TKey key, bool refresh, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.<095eee27-c9f8-4608-aee1-977bdb32e1fa>NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.<095eee27-c9f8-4608-aee1-977bdb32e1fa>SimplePool`1 : object {
    private object _lockObj;
    private Stack`1<T> _values;
    private Func`1<T> _allocate;
    public <095eee27-c9f8-4608-aee1-977bdb32e1fa>SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.<095eee27-c9f8-4608-aee1-977bdb32e1fa>StringBuilderPool : object {
    private static int MaxPoolSize;
    private <095eee27-c9f8-4608-aee1-977bdb32e1fa>SimplePool`1<StringBuilder> _pool;
    public static <095eee27-c9f8-4608-aee1-977bdb32e1fa>StringBuilderPool Shared;
    private static <095eee27-c9f8-4608-aee1-977bdb32e1fa>StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NuGet.<095eee27-c9f8-4608-aee1-977bdb32e1fa>TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static <095eee27-c9f8-4608-aee1-977bdb32e1fa>TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.<095eee27-c9f8-4608-aee1-977bdb32e1fa>TaskResultCache`2 : object {
    private ConcurrentDictionary`2<TKey, Task`1<TValue>> _cache;
    private ConcurrentDictionary`2<TKey, object> _perTaskLock;
    public <095eee27-c9f8-4608-aee1-977bdb32e1fa>TaskResultCache`2(IEqualityComparer`1<TKey> comparer);
    public Task`1<TValue> GetOrAddAsync(TKey key, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
    public Task`1<TValue> GetOrAddAsync(TKey key, bool refresh, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.<76dee5d5-572c-44bd-8e59-41aaed8a29e3>NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.<76dee5d5-572c-44bd-8e59-41aaed8a29e3>SimplePool`1 : object {
    private object _lockObj;
    private Stack`1<T> _values;
    private Func`1<T> _allocate;
    public <76dee5d5-572c-44bd-8e59-41aaed8a29e3>SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.<76dee5d5-572c-44bd-8e59-41aaed8a29e3>StringBuilderPool : object {
    private static int MaxPoolSize;
    private <76dee5d5-572c-44bd-8e59-41aaed8a29e3>SimplePool`1<StringBuilder> _pool;
    public static <76dee5d5-572c-44bd-8e59-41aaed8a29e3>StringBuilderPool Shared;
    private static <76dee5d5-572c-44bd-8e59-41aaed8a29e3>StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NuGet.<76dee5d5-572c-44bd-8e59-41aaed8a29e3>TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static <76dee5d5-572c-44bd-8e59-41aaed8a29e3>TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.<76dee5d5-572c-44bd-8e59-41aaed8a29e3>TaskResultCache`2 : object {
    private ConcurrentDictionary`2<TKey, Task`1<TValue>> _cache;
    private ConcurrentDictionary`2<TKey, object> _perTaskLock;
    public <76dee5d5-572c-44bd-8e59-41aaed8a29e3>TaskResultCache`2(IEqualityComparer`1<TKey> comparer);
    public Task`1<TValue> GetOrAddAsync(TKey key, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
    public Task`1<TValue> GetOrAddAsync(TKey key, bool refresh, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>SimplePool`1 : object {
    private object _lockObj;
    private Stack`1<T> _values;
    private Func`1<T> _allocate;
    public <9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>StringBuilderPool : object {
    private static int MaxPoolSize;
    private <9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>SimplePool`1<StringBuilder> _pool;
    public static <9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>StringBuilderPool Shared;
    private static <9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NuGet.<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static <9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>TaskResultCache`2 : object {
    private ConcurrentDictionary`2<TKey, Task`1<TValue>> _cache;
    private ConcurrentDictionary`2<TKey, object> _perTaskLock;
    public <9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>TaskResultCache`2(IEqualityComparer`1<TKey> comparer);
    public Task`1<TValue> GetOrAddAsync(TKey key, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
    public Task`1<TValue> GetOrAddAsync(TKey key, bool refresh, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.<9f65e429-7a44-41af-85cb-9a867a352998>NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.<9f65e429-7a44-41af-85cb-9a867a352998>SimplePool`1 : object {
    private object _lockObj;
    private Stack`1<T> _values;
    private Func`1<T> _allocate;
    public <9f65e429-7a44-41af-85cb-9a867a352998>SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.<9f65e429-7a44-41af-85cb-9a867a352998>StringBuilderPool : object {
    private static int MaxPoolSize;
    private <9f65e429-7a44-41af-85cb-9a867a352998>SimplePool`1<StringBuilder> _pool;
    public static <9f65e429-7a44-41af-85cb-9a867a352998>StringBuilderPool Shared;
    private static <9f65e429-7a44-41af-85cb-9a867a352998>StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NuGet.<9f65e429-7a44-41af-85cb-9a867a352998>TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static <9f65e429-7a44-41af-85cb-9a867a352998>TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.<9f65e429-7a44-41af-85cb-9a867a352998>TaskResultCache`2 : object {
    private ConcurrentDictionary`2<TKey, Task`1<TValue>> _cache;
    private ConcurrentDictionary`2<TKey, object> _perTaskLock;
    public <9f65e429-7a44-41af-85cb-9a867a352998>TaskResultCache`2(IEqualityComparer`1<TKey> comparer);
    public Task`1<TValue> GetOrAddAsync(TKey key, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
    public Task`1<TValue> GetOrAddAsync(TKey key, bool refresh, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.<a8b4d782-62ae-4aef-a59e-d702453e5cda>NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.<a8b4d782-62ae-4aef-a59e-d702453e5cda>SimplePool`1 : object {
    private object _lockObj;
    private Stack`1<T> _values;
    private Func`1<T> _allocate;
    public <a8b4d782-62ae-4aef-a59e-d702453e5cda>SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.<a8b4d782-62ae-4aef-a59e-d702453e5cda>StringBuilderPool : object {
    private static int MaxPoolSize;
    private <a8b4d782-62ae-4aef-a59e-d702453e5cda>SimplePool`1<StringBuilder> _pool;
    public static <a8b4d782-62ae-4aef-a59e-d702453e5cda>StringBuilderPool Shared;
    private static <a8b4d782-62ae-4aef-a59e-d702453e5cda>StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NuGet.<a8b4d782-62ae-4aef-a59e-d702453e5cda>TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static <a8b4d782-62ae-4aef-a59e-d702453e5cda>TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.<a8b4d782-62ae-4aef-a59e-d702453e5cda>TaskResultCache`2 : object {
    private ConcurrentDictionary`2<TKey, Task`1<TValue>> _cache;
    private ConcurrentDictionary`2<TKey, object> _perTaskLock;
    public <a8b4d782-62ae-4aef-a59e-d702453e5cda>TaskResultCache`2(IEqualityComparer`1<TKey> comparer);
    public Task`1<TValue> GetOrAddAsync(TKey key, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
    public Task`1<TValue> GetOrAddAsync(TKey key, bool refresh, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>SimplePool`1 : object {
    private object _lockObj;
    private Stack`1<T> _values;
    private Func`1<T> _allocate;
    public <b3265425-ee30-40bd-8eb8-b1f3195bfa4b>SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>StringBuilderPool : object {
    private static int MaxPoolSize;
    private <b3265425-ee30-40bd-8eb8-b1f3195bfa4b>SimplePool`1<StringBuilder> _pool;
    public static <b3265425-ee30-40bd-8eb8-b1f3195bfa4b>StringBuilderPool Shared;
    private static <b3265425-ee30-40bd-8eb8-b1f3195bfa4b>StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NuGet.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static <b3265425-ee30-40bd-8eb8-b1f3195bfa4b>TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>TaskResultCache`2 : object {
    private ConcurrentDictionary`2<TKey, Task`1<TValue>> _cache;
    private ConcurrentDictionary`2<TKey, object> _perTaskLock;
    public <b3265425-ee30-40bd-8eb8-b1f3195bfa4b>TaskResultCache`2(IEqualityComparer`1<TKey> comparer);
    public Task`1<TValue> GetOrAddAsync(TKey key, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
    public Task`1<TValue> GetOrAddAsync(TKey key, bool refresh, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.<cf090466-d32c-4025-b476-cee6b8291f40>NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.<cf090466-d32c-4025-b476-cee6b8291f40>SimplePool`1 : object {
    private object _lockObj;
    private Stack`1<T> _values;
    private Func`1<T> _allocate;
    public <cf090466-d32c-4025-b476-cee6b8291f40>SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.<cf090466-d32c-4025-b476-cee6b8291f40>StringBuilderPool : object {
    private static int MaxPoolSize;
    private <cf090466-d32c-4025-b476-cee6b8291f40>SimplePool`1<StringBuilder> _pool;
    public static <cf090466-d32c-4025-b476-cee6b8291f40>StringBuilderPool Shared;
    private static <cf090466-d32c-4025-b476-cee6b8291f40>StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NuGet.<cf090466-d32c-4025-b476-cee6b8291f40>TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static <cf090466-d32c-4025-b476-cee6b8291f40>TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.<cf090466-d32c-4025-b476-cee6b8291f40>TaskResultCache`2 : object {
    private ConcurrentDictionary`2<TKey, Task`1<TValue>> _cache;
    private ConcurrentDictionary`2<TKey, object> _perTaskLock;
    public <cf090466-d32c-4025-b476-cee6b8291f40>TaskResultCache`2(IEqualityComparer`1<TKey> comparer);
    public Task`1<TValue> GetOrAddAsync(TKey key, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
    public Task`1<TValue> GetOrAddAsync(TKey key, bool refresh, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
}
internal class NuGet.Client.AnyFramework : NuGetFramework {
    [CompilerGeneratedAttribute]
private static AnyFramework <Instance>k__BackingField;
    internal static AnyFramework Instance { get; }
    private static AnyFramework();
    [CompilerGeneratedAttribute]
internal static AnyFramework get_Instance();
}
public class NuGet.Client.ManagedCodeConventions : object {
    private static ContentPropertyDefinition LocaleProperty;
    private static ContentPropertyDefinition AnyProperty;
    private static ContentPropertyDefinition AssemblyProperty;
    private static ContentPropertyDefinition MSBuildProperty;
    private static ContentPropertyDefinition SatelliteAssemblyProperty;
    private static ContentPropertyDefinition CodeLanguageProperty;
    private static Dictionary`2<string, object> NetTFMTable;
    private static Dictionary`2<string, object> DefaultTfmAny;
    private static PatternTable DotnetAnyTable;
    private static PatternTable AnyTable;
    private static FrameworkReducer FrameworkReducer;
    private RuntimeGraph _runtimeGraph;
    private Dictionary`2<string, NuGetFramework> _frameworkCache;
    [CompilerGeneratedAttribute]
private ManagedCodeCriteria <Criteria>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, ContentPropertyDefinition> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private ManagedCodePatterns <Patterns>k__BackingField;
    public ManagedCodeCriteria Criteria { get; }
    public IReadOnlyDictionary`2<string, ContentPropertyDefinition> Properties { get; }
    public ManagedCodePatterns Patterns { get; }
    public ManagedCodeConventions(RuntimeGraph runtimeGraph);
    private static ManagedCodeConventions();
    [CompilerGeneratedAttribute]
public ManagedCodeCriteria get_Criteria();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, ContentPropertyDefinition> get_Properties();
    [CompilerGeneratedAttribute]
public ManagedCodePatterns get_Patterns();
    private bool RuntimeIdentifier_CompatibilityTest(object criteria, object available);
    private static object CodeLanguage_Parser(string name, PatternTable table);
    private static object Locale_Parser(string name, PatternTable table);
    private object TargetFrameworkName_Parser(string name, PatternTable table);
    private static NuGetFramework TargetFrameworkName_ParserCore(string name);
    private static object AllowEmptyFolderParser(string s, PatternTable table);
    private static bool TargetFrameworkName_CompatibilityTest(object criteria, object available);
    private static int TargetFrameworkName_NearestCompareTest(object projectFramework, object criteria, object available);
    private static Version NormalizeVersion(Version version);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.ActivityCorrelationId : object {
    private static string CorrelationIdSlot;
    private static string DefaultCorrelationId;
    public static string Current { get; }
    private static ActivityCorrelationId();
    public static string get_Current();
    public static void StartNew();
    public static void Clear();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Common.AggregateEnumerableAsync`1 : object {
    private IList`1<IEnumerableAsync`1<T>> _asyncEnumerables;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IComparer`1<T> _comparer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEqualityComparer`1<T> _equalityComparer;
    public AggregateEnumerableAsync`1(IList`1<IEnumerableAsync`1<T>> asyncEnumerables, IComparer`1<T> comparer, IEqualityComparer`1<T> equalityComparer);
    public sealed virtual IEnumeratorAsync`1<T> GetEnumeratorAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Common.AggregateEnumeratorAsync`1 : object {
    private HashSet`1<T> _seen;
    private IComparer`1<T> _orderingComparer;
    private List`1<IEnumeratorAsync`1<T>> _asyncEnumerators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumeratorAsync`1<T> _currentEnumeratorAsync;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumeratorAsync`1<T> _lastAwaitedEnumeratorAsync;
    private bool firstPass;
    public T Current { get; }
    public AggregateEnumeratorAsync`1(IList`1<IEnumerableAsync`1<T>> asyncEnumerables, IComparer`1<T> orderingComparer, IEqualityComparer`1<T> equalityComparer);
    public sealed virtual T get_Current();
    [AsyncStateMachineAttribute("NuGet.Common.AggregateEnumeratorAsync`1/<MoveNextAsync>d__9")]
public sealed virtual Task`1<bool> MoveNextAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.AsyncLazy : object {
    public static AsyncLazy`1<T> New(Func`1<Task`1<T>> asyncValueFactory);
    public static AsyncLazy`1<T> New(Func`1<T> valueFactory);
    public static AsyncLazy`1<T> New(Lazy`1<Task`1<T>> inner);
    public static AsyncLazy`1<T> New(T innerData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[CLSCompliantAttribute("True")]
public class NuGet.Common.AsyncLazy`1 : object {
    private Lazy`1<Task`1<T>> _inner;
    public AsyncLazy`1(Func`1<Task`1<T>> valueFactory);
    public AsyncLazy`1(Lazy`1<Task`1<T>> inner);
    public TaskAwaiter`1<T> GetAwaiter();
    public static Lazy`1<Task`1<T>> op_Implicit(AsyncLazy`1<T> outer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Common.AuthTypeFilteredCredentials : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <AuthTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private NetworkCredential <InnerCredential>k__BackingField;
    public IReadOnlyList`1<string> AuthTypes { get; }
    public NetworkCredential InnerCredential { get; }
    public AuthTypeFilteredCredentials(NetworkCredential innerCredential, IEnumerable`1<string> authTypes);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_AuthTypes();
    [CompilerGeneratedAttribute]
public NetworkCredential get_InnerCredential();
    public sealed virtual NetworkCredential GetCredential(Uri uri, string authType);
}
public static class NuGet.Common.ClientVersionUtility : object {
    [NullableAttribute("2")]
private static string _clientVersion;
    [NullableContextAttribute("1")]
public static string GetNuGetAssemblyVersion();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Common.CommandLineArgumentCombinationException : Exception {
    private ILogMessage _logMessage;
    public CommandLineArgumentCombinationException(string message);
    public virtual ILogMessage AsLogMessage();
}
public static class NuGet.Common.ComparisonUtility : object {
    [NullableAttribute("1")]
public static StringComparer FrameworkReferenceNameComparer;
    private static ComparisonUtility();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.ConcurrencyUtilities : object {
    private static int NumberOfRetries;
    private static int HashLength;
    private static TimeSpan SleepDuration;
    private static KeyedLock PerFileLock;
    private static bool UseDeleteOnClose;
    [NullableAttribute("2")]
private static string _basePath;
    private static string BasePath { get; }
    private static ConcurrencyUtilities();
    [AsyncStateMachineAttribute("NuGet.Common.ConcurrencyUtilities/<ExecuteWithFileLockedAsync>d__5`1")]
public static Task`1<T> ExecuteWithFileLockedAsync(string filePath, Func`2<CancellationToken, Task`1<T>> action, CancellationToken token);
    public static void ExecuteWithFileLocked(string filePath, Action action);
    internal static void ExecuteWithFileLocked(string filePath, Action action, Func`2<string, FileStream> acquireFileStream, int numberOfRetries);
    private static FileStream AcquireFileStream(string lockPath);
    private static string get_BasePath();
    private static string FileLockPath(string filePath);
    private static string FilePathToLockName(string filePath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Common.CryptoHashProvider : object {
    private static string SHA512HashAlgorithm;
    private static string SHA256HashAlgorithm;
    private string _hashAlgorithm;
    [NullableContextAttribute("2")]
public CryptoHashProvider(string hashAlgorithm);
    public Byte[] CalculateHash(Stream stream);
    public Byte[] CalculateHash(Byte[] data);
    public bool VerifyHash(Byte[] data, Byte[] hash);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NuGet.Common.CryptoHashUtility : object {
    private static string SHA256_OID;
    private static string SHA384_OID;
    private static string SHA512_OID;
    private static string SHA256_RSA_OID;
    private static string SHA384_RSA_OID;
    private static string SHA512_RSA_OID;
    private static Lazy`1<bool> AllowFipsAlgorithmsOnly;
    private static CryptoHashUtility();
    [ExtensionAttribute]
public static string ComputeHashAsBase64(HashAlgorithm hashAlgorithm, Stream data);
    [ExtensionAttribute]
public static string ComputeHashAsBase64(HashAlgorithm hashAlgorithm, Stream data, bool leaveStreamOpen);
    [ExtensionAttribute]
public static Byte[] ComputeHash(HashAlgorithmName hashAlgorithmName, Byte[] data);
    [ExtensionAttribute]
public static Byte[] ComputeHash(HashAlgorithm hashAlgorithm, Stream data);
    [ExtensionAttribute]
public static Byte[] ComputeHash(HashAlgorithm hashAlgorithm, Stream data, bool leaveStreamOpen);
    public static HashAlgorithm GetHashAlgorithm(string hashAlgorithmName);
    public static HashAlgorithmName GetHashAlgorithmName(string hashAlgorithm);
    public static HashAlgorithm GetHashAlgorithm(HashAlgorithmName hashAlgorithmName);
    [ExtensionAttribute]
public static HashAlgorithm GetHashProvider(HashAlgorithmName hashAlgorithmName);
    private static bool ReadFipsConfigValue();
    [ExtensionAttribute]
public static HashAlgorithmName ConvertToSystemSecurityHashAlgorithmName(HashAlgorithmName hashAlgorithmName);
    [ExtensionAttribute]
public static string ConvertToOidString(HashAlgorithmName hashAlgorithmName);
    [ExtensionAttribute]
public static Oid ConvertToOid(HashAlgorithmName hashAlgorithm);
    public static HashAlgorithmName OidToHashAlgorithmName(string oid);
    [ExtensionAttribute]
public static string ConvertToOidString(SignatureAlgorithmName signatureAlgorithmName);
}
public static class NuGet.Common.CultureUtility : object {
    public static void DisableLocalization();
    [NullableContextAttribute("1")]
private static void SetCulture(CultureInfo culture);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.DatetimeUtility : object {
    public static string ToReadableTimeFormat(TimeSpan time);
    internal static string ToReadableTimeFormat(TimeSpan time, IFormatProvider format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Common.EnvironmentVariableWrapper : object {
    [CompilerGeneratedAttribute]
private static IEnvironmentVariableReader <Instance>k__BackingField;
    public static IEnvironmentVariableReader Instance { get; }
    private static EnvironmentVariableWrapper();
    [CompilerGeneratedAttribute]
public static IEnvironmentVariableReader get_Instance();
    public sealed virtual string GetEnvironmentVariable(string variable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Common.ExceptionLogger : object {
    [CompilerGeneratedAttribute]
private bool <ShowStack>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExceptionLogger <Instance>k__BackingField;
    public bool ShowStack { get; }
    public static ExceptionLogger Instance { get; }
    public ExceptionLogger(IEnvironmentVariableReader reader);
    private static ExceptionLogger();
    [CompilerGeneratedAttribute]
public bool get_ShowStack();
    private static bool ShouldShowStack(IEnvironmentVariableReader reader);
    [CompilerGeneratedAttribute]
public static ExceptionLogger get_Instance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.ExceptionUtilities : object {
    public static void LogException(Exception ex, ILogger logger);
    public static void LogException(Exception ex, ILogger logger, bool logStackAsError);
    public static string DisplayMessage(Exception exception, bool indent);
    public static string DisplayMessage(Exception exception);
    public static string DisplayMessage(AggregateException exception);
    public static string DisplayMessage(TargetInvocationException exception);
    public static Exception Unwrap(Exception exception);
    [IteratorStateMachineAttribute("NuGet.Common.ExceptionUtilities/<GetMessages>d__7")]
private static IEnumerable`1<string> GetMessages(AggregateException exception);
    private static IEnumerable`1<string> GetMessages(TargetInvocationException exception);
    [IteratorStateMachineAttribute("NuGet.Common.ExceptionUtilities/<GetMessages>d__9")]
private static IEnumerable`1<string> GetMessages(Exception exception);
    [IteratorStateMachineAttribute("NuGet.Common.ExceptionUtilities/<GetLines>d__10")]
private static IEnumerable`1<string> GetLines(string input);
    private static string JoinMessages(IEnumerable`1<string> messages, bool indent);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.FileUtility : object {
    public static int MaxTries;
    public static FileShare FileSharePermissions;
    private static FileUtility();
    public static string GetTempFilePath(string directory);
    [AsyncStateMachineAttribute("NuGet.Common.FileUtility/<DeleteWithLock>d__3")]
public static Task DeleteWithLock(string filePath);
    [AsyncStateMachineAttribute("NuGet.Common.FileUtility/<ReplaceWithLock>d__4")]
public static Task ReplaceWithLock(Action`1<string> writeSourceFile, string destFilePath);
    public static void Replace(Action`1<string> writeSourceFile, string destFilePath);
    [AsyncStateMachineAttribute("NuGet.Common.FileUtility/<ReplaceAsync>d__6")]
public static Task ReplaceAsync(Func`2<string, Task> writeSourceFile, string destFilePath);
    public static void Replace(string sourceFileName, string destFileName);
    public static void Move(string sourceFileName, string destFileName);
    public static void Delete(string path);
    public static T SafeRead(string filePath, Func`3<FileStream, string, T> read);
    [AsyncStateMachineAttribute("NuGet.Common.FileUtility/<SafeReadAsync>d__11`1")]
public static Task`1<T> SafeReadAsync(string filePath, Func`3<FileStream, string, Task`1<T>> read);
    private static void Sleep(int ms);
}
public enum NuGet.Common.HashAlgorithmName : Enum {
    public int value__;
    public static HashAlgorithmName Unknown;
    public static HashAlgorithmName SHA256;
    public static HashAlgorithmName SHA384;
    public static HashAlgorithmName SHA512;
}
[NullableContextAttribute("1")]
public interface NuGet.Common.ICollectorLogger {
    public IEnumerable`1<IRestoreLogMessage> Errors { get; }
    public abstract virtual IEnumerable`1<IRestoreLogMessage> get_Errors();
}
[NullableContextAttribute("1")]
public interface NuGet.Common.IEnumerableAsync`1 {
    public abstract virtual IEnumeratorAsync`1<T> GetEnumeratorAsync();
}
[NullableContextAttribute("1")]
public interface NuGet.Common.IEnumeratorAsync`1 {
    public T Current { get; }
    public abstract virtual T get_Current();
    public abstract virtual Task`1<bool> MoveNextAsync();
}
[NullableContextAttribute("1")]
public interface NuGet.Common.IEnvironmentVariableReader {
    public abstract virtual string GetEnvironmentVariable(string variable);
}
[NullableContextAttribute("2")]
public interface NuGet.Common.ILogFileContext {
    public string FilePath { get; public set; }
    public int StartLineNumber { get; public set; }
    public int StartColumnNumber { get; public set; }
    public int EndLineNumber { get; public set; }
    public int EndColumnNumber { get; public set; }
    public abstract virtual string get_FilePath();
    public abstract virtual void set_FilePath(string value);
    public abstract virtual int get_StartLineNumber();
    public abstract virtual void set_StartLineNumber(int value);
    public abstract virtual int get_StartColumnNumber();
    public abstract virtual void set_StartColumnNumber(int value);
    public abstract virtual int get_EndLineNumber();
    public abstract virtual void set_EndLineNumber(int value);
    public abstract virtual int get_EndColumnNumber();
    public abstract virtual void set_EndColumnNumber(int value);
}
[NullableContextAttribute("1")]
public interface NuGet.Common.ILogger {
    public abstract virtual void LogDebug(string data);
    public abstract virtual void LogVerbose(string data);
    public abstract virtual void LogInformation(string data);
    public abstract virtual void LogMinimal(string data);
    public abstract virtual void LogWarning(string data);
    public abstract virtual void LogError(string data);
    public abstract virtual void LogInformationSummary(string data);
    public abstract virtual void Log(LogLevel level, string data);
    public abstract virtual Task LogAsync(LogLevel level, string data);
    public abstract virtual void Log(ILogMessage message);
    public abstract virtual Task LogAsync(ILogMessage message);
}
[NullableContextAttribute("1")]
public interface NuGet.Common.ILogMessage {
    public LogLevel Level { get; public set; }
    public WarningLevel WarningLevel { get; public set; }
    public NuGetLogCode Code { get; public set; }
    public string Message { get; public set; }
    [NullableAttribute("2")]
public string ProjectPath { get; public set; }
    public DateTimeOffset Time { get; public set; }
    public abstract virtual LogLevel get_Level();
    public abstract virtual void set_Level(LogLevel value);
    public abstract virtual WarningLevel get_WarningLevel();
    public abstract virtual void set_WarningLevel(WarningLevel value);
    public abstract virtual NuGetLogCode get_Code();
    public abstract virtual void set_Code(NuGetLogCode value);
    public abstract virtual string get_Message();
    public abstract virtual void set_Message(string value);
    [NullableContextAttribute("2")]
public abstract virtual string get_ProjectPath();
    [NullableContextAttribute("2")]
public abstract virtual void set_ProjectPath(string value);
    public abstract virtual DateTimeOffset get_Time();
    public abstract virtual void set_Time(DateTimeOffset value);
}
[NullableContextAttribute("1")]
public interface NuGet.Common.ILogMessageException {
    public abstract virtual ILogMessage AsLogMessage();
}
public interface NuGet.Common.INuGetLogMessage {
}
[NullableContextAttribute("1")]
public interface NuGet.Common.INuGetPathContext {
    public string UserPackageFolder { get; }
    public IReadOnlyList`1<string> FallbackPackageFolders { get; }
    public string HttpCacheFolder { get; }
    public abstract virtual string get_UserPackageFolder();
    public abstract virtual IReadOnlyList`1<string> get_FallbackPackageFolders();
    public abstract virtual string get_HttpCacheFolder();
}
[NullableContextAttribute("1")]
public interface NuGet.Common.INuGetTelemetryService {
    public abstract virtual void EmitTelemetryEvent(TelemetryEvent telemetryData);
    public abstract virtual IDisposable StartActivity(string activityName);
}
[NullableContextAttribute("2")]
public interface NuGet.Common.IPackLogMessage {
    public string LibraryId { get; public set; }
    public NuGetFramework Framework { get; public set; }
    public abstract virtual string get_LibraryId();
    public abstract virtual void set_LibraryId(string value);
    public abstract virtual NuGetFramework get_Framework();
    public abstract virtual void set_Framework(NuGetFramework value);
}
public interface NuGet.Common.IRestoreLogMessage {
    [NullableAttribute("2")]
public string LibraryId { get; public set; }
    [NullableAttribute("1")]
public IReadOnlyList`1<string> TargetGraphs { get; public set; }
    public bool ShouldDisplay { get; public set; }
    [NullableContextAttribute("2")]
public abstract virtual string get_LibraryId();
    [NullableContextAttribute("2")]
public abstract virtual void set_LibraryId(string value);
    [NullableContextAttribute("1")]
public abstract virtual IReadOnlyList`1<string> get_TargetGraphs();
    [NullableContextAttribute("1")]
public abstract virtual void set_TargetGraphs(IReadOnlyList`1<string> value);
    public abstract virtual bool get_ShouldDisplay();
    public abstract virtual void set_ShouldDisplay(bool value);
}
[NullableContextAttribute("1")]
public interface NuGet.Common.ITelemetrySession {
    public abstract virtual void PostEvent(TelemetryEvent telemetryEvent);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.Common.KeyedLock : object {
    private Dictionary`2<string, LockState> _locks;
    private SemaphoreSlim _dictionaryLock;
    [AsyncStateMachineAttribute("NuGet.Common.KeyedLock/<EnterAsync>d__3")]
internal Task EnterAsync(string key, CancellationToken token);
    internal void Enter(string key);
    private LockState GetOrCreate(string key);
    [AsyncStateMachineAttribute("NuGet.Common.KeyedLock/<ExitAsync>d__6")]
internal Task ExitAsync(string key);
    internal void Exit(string key);
    private void Cleanup(string key);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NuGet.Common.LegacyLoggerAdapter : object {
    public sealed virtual void Log(LogLevel level, string data);
    public sealed virtual Task LogAsync(LogLevel level, string data);
    public virtual void Log(ILogMessage message);
    [AsyncStateMachineAttribute("NuGet.Common.LegacyLoggerAdapter/<LogAsync>d__3")]
public virtual Task LogAsync(ILogMessage message);
    public abstract virtual void LogDebug(string data);
    public abstract virtual void LogVerbose(string data);
    public abstract virtual void LogInformation(string data);
    public abstract virtual void LogMinimal(string data);
    public abstract virtual void LogWarning(string data);
    public abstract virtual void LogError(string data);
    public abstract virtual void LogInformationSummary(string data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.LocalResourceUtils : object {
    public static void DeleteDirectoryTree(string folderPath, List`1<string> failedDeletes);
    private static void SafeDeleteDirectoryTree(string folderPath);
    private static void DeleteFilesInDirectoryTree(string folderPath, List`1<string> failedDeletes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NuGet.Common.LoggerBase : object {
    [CompilerGeneratedAttribute]
private LogLevel <VerbosityLevel>k__BackingField;
    public LogLevel VerbosityLevel { get; public set; }
    public LoggerBase(LogLevel verbosityLevel);
    [CompilerGeneratedAttribute]
public LogLevel get_VerbosityLevel();
    [CompilerGeneratedAttribute]
public void set_VerbosityLevel(LogLevel value);
    public abstract virtual void Log(ILogMessage message);
    public abstract virtual Task LogAsync(ILogMessage message);
    public virtual void Log(LogLevel level, string data);
    public virtual Task LogAsync(LogLevel level, string data);
    public virtual void LogDebug(string data);
    public virtual void LogError(string data);
    public virtual void LogInformation(string data);
    public virtual void LogInformationSummary(string data);
    public virtual void LogMinimal(string data);
    public virtual void LogVerbose(string data);
    public virtual void LogWarning(string data);
    protected virtual bool DisplayMessage(LogLevel messageLevel);
    protected virtual bool CollectMessage(LogLevel messageLevel);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NuGet.Common.LoggingExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string FormatWithCode(ILogMessage message);
    [ExtensionAttribute]
public static string GetName(NuGetLogCode code);
    [ExtensionAttribute]
public static bool TryGetName(NuGetLogCode code, String& codeString);
}
public enum NuGet.Common.LogLevel : Enum {
    public int value__;
    public static LogLevel Debug;
    public static LogLevel Verbose;
    public static LogLevel Information;
    public static LogLevel Minimal;
    public static LogLevel Warning;
    public static LogLevel Error;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Common.LogMessage : object {
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private WarningLevel <WarningLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLogCode <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Time>k__BackingField;
    public LogLevel Level { get; public set; }
    public WarningLevel WarningLevel { get; public set; }
    public NuGetLogCode Code { get; public set; }
    public string Message { get; public set; }
    [NullableAttribute("2")]
public string ProjectPath { get; public set; }
    public DateTimeOffset Time { get; public set; }
    public LogMessage(LogLevel level, string message, NuGetLogCode code);
    public LogMessage(LogLevel level, string message);
    [CompilerGeneratedAttribute]
public sealed virtual LogLevel get_Level();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Level(LogLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual WarningLevel get_WarningLevel();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WarningLevel(WarningLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetLogCode get_Code();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Code(NuGetLogCode value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Message(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_ProjectPath();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Time();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Time(DateTimeOffset value);
    public virtual string ToString();
    public static LogMessage CreateError(NuGetLogCode code, string message);
    public static LogMessage CreateWarning(NuGetLogCode code, string message);
    public static LogMessage Create(LogLevel level, string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.LogMessageProperties : object {
    public static string LEVEL;
    public static string CODE;
    public static string MESSAGE;
    public static string LIBRARY_ID;
    public static string TARGET_GRAPHS;
    public static string WARNING_LEVEL;
    public static string FILE_PATH;
    public static string START_LINE_NUMBER;
    public static string START_COLUMN_NUMBER;
    public static string END_LINE_NUMBER;
    public static string END_COLUMN_NUMBER;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NuGet.Common.Migrations.Migration1 : object {
    public static void Run();
    internal static void DeleteMigratedDirectories(string nugetBaseDirectory);
    internal static void EnsureExpectedPermissions(HashSet`1<string> pathsToCheck, PosixPermissions umask);
    private static HashSet`1<string> GetPathsToCheck();
    private static string GetMonoConfigPath();
    private static string GetDotnetConfigPath();
    private static void EnsureConfigFilePermissions();
    internal static void EnsureConfigFilePermissions(string directory, PosixPermissions umask);
    private static PosixPermissions GetUmask();
    private static void FixPermissions(string path, PosixPermissions umask);
    internal static Nullable`1<PosixPermissions> GetPermissions(string path);
    internal static string Exec(string command, string args);
    [CompilerGeneratedAttribute]
internal static void <GetPathsToCheck>g__AddAllParentDirectoriesUpToHome|3_0(string path, <>c__DisplayClass3_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.Migrations.MigrationRunner : object {
    private static string MaxMigrationFilename;
    public static void Run();
    internal static void Run(string migrationsDirectory);
    internal static string GetMigrationsDirectory();
    [CompilerGeneratedAttribute]
internal static bool <Run>g__WaitForMutex|2_0(Mutex mutex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.Common.Migrations.PosixPermissions : ValueType {
    private int _mode;
    public PosixPermissions(int mode);
    public virtual string ToString();
    public static PosixPermissions Parse(string input);
    public bool SatisfiesUmask(PosixPermissions umask);
    public PosixPermissions WithUmask(PosixPermissions umask);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.MSBuildStringUtility : object {
    public static String[] Split(string s);
    public static String[] Split(string s, Char[] chars);
    [NullableContextAttribute("2")]
public static string TrimAndGetNullForEmpty(string s);
    public static String[] TrimAndExcludeNullOrEmpty(String[] strings);
    [NullableContextAttribute("2")]
public static bool IsTrue(string value);
    [NullableContextAttribute("2")]
public static bool IsTrueOrEmpty(string value);
    public static IList`1<NuGetLogCode> GetNuGetLogCodes(string s);
    [NullableContextAttribute("2")]
public static Nullable`1<bool> GetBooleanOrNull(string value);
    [NullableContextAttribute("2")]
public static string Convert(string value);
    public static IEnumerable`1<NuGetLogCode> GetDistinctNuGetLogCodesOrDefault(IEnumerable`1<IEnumerable`1<NuGetLogCode>> nugetLogCodeLists);
}
public static class NuGet.Common.NetworkProtocolUtility : object {
    public static void SetConnectionLimit();
}
public static class NuGet.Common.NuGetEnvironment : object {
    private static string DotNet;
    private static string DotNetExe;
    private static string Home;
    private static string UserProfile;
    private static Lazy`1<string> _getHome;
    private static string _nuGetTempDirectory;
    internal static string NuGetTempDirectory { get; }
    private static NuGetEnvironment();
    internal static string get_NuGetTempDirectory();
    private static string GetNuGetTempDirectory();
    public static string GetFolderPath(NuGetFolderPath folder);
    private static int chmod(string pathname, int mode);
    internal static string GetFolderPath(SpecialFolder folder);
    private static string GetHome();
    private static string GetHomeWindows();
    private static string GetValueOrThrowMissingEnvVarsDotnet(Func`1<string> getValue, string home, string dotnetHome);
    private static string GetValueOrThrowMissingEnvVar(Func`1<string> getValue, string name);
    public static string GetDotNetLocation();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.NuGetEventSource : object {
    [CompilerGeneratedAttribute]
private static EventSource <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsEnabled>k__BackingField;
    public static EventSource Instance { get; }
    public static bool IsEnabled { get; }
    private static NuGetEventSource();
    [CompilerGeneratedAttribute]
public static EventSource get_Instance();
    [CompilerGeneratedAttribute]
public static bool get_IsEnabled();
}
public enum NuGet.Common.NuGetFolderPath : Enum {
    public int value__;
    public static NuGetFolderPath MachineWideSettingsBaseDirectory;
    public static NuGetFolderPath MachineWideConfigDirectory;
    public static NuGetFolderPath UserSettingsDirectory;
    public static NuGetFolderPath HttpCacheDirectory;
    public static NuGetFolderPath NuGetHome;
    public static NuGetFolderPath DefaultMsBuildPath;
    public static NuGetFolderPath Temp;
    public static NuGetFolderPath NuGetPluginsCacheDirectory;
}
public enum NuGet.Common.NuGetLogCode : Enum {
    public int value__;
    public static NuGetLogCode Undefined;
    public static NuGetLogCode NU1000;
    public static NuGetLogCode NU1001;
    public static NuGetLogCode NU1002;
    public static NuGetLogCode NU1003;
    public static NuGetLogCode NU1004;
    public static NuGetLogCode NU1005;
    public static NuGetLogCode NU1006;
    public static NuGetLogCode NU1007;
    public static NuGetLogCode NU1008;
    public static NuGetLogCode NU1009;
    public static NuGetLogCode NU1010;
    public static NuGetLogCode NU1011;
    public static NuGetLogCode NU1012;
    public static NuGetLogCode NU1013;
    public static NuGetLogCode NU1014;
    public static NuGetLogCode NU1100;
    public static NuGetLogCode NU1101;
    public static NuGetLogCode NU1102;
    public static NuGetLogCode NU1103;
    public static NuGetLogCode NU1104;
    public static NuGetLogCode NU1105;
    public static NuGetLogCode NU1106;
    public static NuGetLogCode NU1107;
    public static NuGetLogCode NU1108;
    public static NuGetLogCode NU1109;
    public static NuGetLogCode NU1110;
    public static NuGetLogCode NU1201;
    public static NuGetLogCode NU1202;
    public static NuGetLogCode NU1203;
    public static NuGetLogCode NU1204;
    public static NuGetLogCode NU1211;
    public static NuGetLogCode NU1212;
    public static NuGetLogCode NU1213;
    public static NuGetLogCode NU1301;
    public static NuGetLogCode NU1401;
    public static NuGetLogCode NU1402;
    public static NuGetLogCode NU1403;
    public static NuGetLogCode NU1410;
    public static NuGetLogCode NU1500;
    public static NuGetLogCode NU1501;
    public static NuGetLogCode NU1502;
    public static NuGetLogCode NU1503;
    public static NuGetLogCode NU1504;
    public static NuGetLogCode NU1505;
    public static NuGetLogCode NU1506;
    public static NuGetLogCode NU1507;
    public static NuGetLogCode NU1601;
    public static NuGetLogCode NU1602;
    public static NuGetLogCode NU1603;
    public static NuGetLogCode NU1604;
    public static NuGetLogCode NU1605;
    public static NuGetLogCode NU1608;
    public static NuGetLogCode NU1701;
    public static NuGetLogCode NU1702;
    public static NuGetLogCode NU1703;
    public static NuGetLogCode NU1801;
    public static NuGetLogCode NU1802;
    public static NuGetLogCode NU1803;
    public static NuGetLogCode NU1900;
    public static NuGetLogCode NU1901;
    public static NuGetLogCode NU1902;
    public static NuGetLogCode NU1903;
    public static NuGetLogCode NU1904;
    public static NuGetLogCode NU3000;
    public static NuGetLogCode NU3001;
    public static NuGetLogCode NU3002;
    public static NuGetLogCode NU3003;
    public static NuGetLogCode NU3004;
    public static NuGetLogCode NU3005;
    public static NuGetLogCode NU3006;
    public static NuGetLogCode NU3007;
    public static NuGetLogCode NU3008;
    public static NuGetLogCode NU3009;
    public static NuGetLogCode NU3010;
    public static NuGetLogCode NU3011;
    public static NuGetLogCode NU3012;
    public static NuGetLogCode NU3013;
    public static NuGetLogCode NU3014;
    public static NuGetLogCode NU3015;
    public static NuGetLogCode NU3016;
    public static NuGetLogCode NU3017;
    public static NuGetLogCode NU3018;
    public static NuGetLogCode NU3019;
    public static NuGetLogCode NU3020;
    public static NuGetLogCode NU3021;
    public static NuGetLogCode NU3022;
    public static NuGetLogCode NU3023;
    public static NuGetLogCode NU3024;
    public static NuGetLogCode NU3025;
    public static NuGetLogCode NU3026;
    public static NuGetLogCode NU3027;
    public static NuGetLogCode NU3028;
    public static NuGetLogCode NU3029;
    public static NuGetLogCode NU3030;
    public static NuGetLogCode NU3031;
    public static NuGetLogCode NU3032;
    public static NuGetLogCode NU3033;
    public static NuGetLogCode NU3034;
    public static NuGetLogCode NU3035;
    public static NuGetLogCode NU3036;
    public static NuGetLogCode NU3037;
    public static NuGetLogCode NU3038;
    public static NuGetLogCode NU3039;
    public static NuGetLogCode NU3040;
    public static NuGetLogCode NU3041;
    public static NuGetLogCode NU3042;
    public static NuGetLogCode NU5000;
    public static NuGetLogCode NU5001;
    public static NuGetLogCode NU5002;
    public static NuGetLogCode NU5003;
    public static NuGetLogCode NU5004;
    public static NuGetLogCode NU5005;
    public static NuGetLogCode NU5007;
    public static NuGetLogCode NU5008;
    public static NuGetLogCode NU5009;
    public static NuGetLogCode NU5010;
    public static NuGetLogCode NU5011;
    public static NuGetLogCode NU5012;
    public static NuGetLogCode NU5013;
    public static NuGetLogCode NU5014;
    public static NuGetLogCode NU5015;
    public static NuGetLogCode NU5016;
    public static NuGetLogCode NU5017;
    public static NuGetLogCode NU5018;
    public static NuGetLogCode NU5019;
    public static NuGetLogCode NU5020;
    public static NuGetLogCode NU5021;
    public static NuGetLogCode NU5022;
    public static NuGetLogCode NU5023;
    public static NuGetLogCode NU5024;
    public static NuGetLogCode NU5025;
    public static NuGetLogCode NU5026;
    public static NuGetLogCode NU5027;
    public static NuGetLogCode NU5028;
    public static NuGetLogCode NU5029;
    public static NuGetLogCode NU5030;
    public static NuGetLogCode NU5031;
    public static NuGetLogCode NU5032;
    public static NuGetLogCode NU5033;
    public static NuGetLogCode NU5034;
    public static NuGetLogCode NU5035;
    public static NuGetLogCode NU5036;
    public static NuGetLogCode NU5037;
    public static NuGetLogCode NU5038;
    public static NuGetLogCode NU5039;
    public static NuGetLogCode NU5040;
    public static NuGetLogCode NU5041;
    public static NuGetLogCode NU5042;
    public static NuGetLogCode NU5045;
    public static NuGetLogCode NU5046;
    public static NuGetLogCode NU5047;
    public static NuGetLogCode NU5048;
    public static NuGetLogCode NU5049;
    public static NuGetLogCode NU5050;
    public static NuGetLogCode NU5100;
    public static NuGetLogCode NU5101;
    public static NuGetLogCode NU5102;
    public static NuGetLogCode NU5103;
    public static NuGetLogCode NU5104;
    public static NuGetLogCode NU5105;
    public static NuGetLogCode NU5106;
    public static NuGetLogCode NU5107;
    public static NuGetLogCode NU5108;
    public static NuGetLogCode NU5109;
    public static NuGetLogCode NU5110;
    public static NuGetLogCode NU5111;
    public static NuGetLogCode NU5112;
    public static NuGetLogCode NU5114;
    public static NuGetLogCode NU5115;
    public static NuGetLogCode NU5116;
    public static NuGetLogCode NU5117;
    public static NuGetLogCode NU5118;
    public static NuGetLogCode NU5119;
    public static NuGetLogCode NU5120;
    public static NuGetLogCode NU5121;
    public static NuGetLogCode NU5122;
    public static NuGetLogCode NU5123;
    public static NuGetLogCode NU5124;
    public static NuGetLogCode NU5125;
    public static NuGetLogCode NU5126;
    public static NuGetLogCode NU5127;
    public static NuGetLogCode NU5128;
    public static NuGetLogCode NU5129;
    public static NuGetLogCode NU5130;
    public static NuGetLogCode NU5131;
    public static NuGetLogCode NU5132;
    public static NuGetLogCode NU5133;
    public static NuGetLogCode NU5500;
    public static NuGetLogCode NU5501;
}
public enum NuGet.Common.NuGetOperationStatus : Enum {
    public int value__;
    public static NuGetOperationStatus NoOp;
    public static NuGetOperationStatus Succeeded;
    public static NuGetOperationStatus Failed;
    public static NuGetOperationStatus Cancelled;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Common.NullLogger : LoggerBase {
    [NullableAttribute("2")]
private static ILogger _instance;
    public static ILogger Instance { get; }
    public static ILogger get_Instance();
    public virtual void Log(ILogMessage message);
    public virtual void Log(LogLevel level, string data);
    public virtual Task LogAsync(ILogMessage message);
    public virtual Task LogAsync(LogLevel level, string data);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NuGet.Common.PackagingLogMessage : object {
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLogCode <Code>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Time>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private WarningLevel <WarningLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartColumnNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumnNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LibraryId>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <Framework>k__BackingField;
    public LogLevel Level { get; public set; }
    public NuGetLogCode Code { get; public set; }
    [NullableAttribute("1")]
public string Message { get; public set; }
    public DateTimeOffset Time { get; public set; }
    public string ProjectPath { get; public set; }
    public WarningLevel WarningLevel { get; public set; }
    public string FilePath { get; public set; }
    public int StartLineNumber { get; public set; }
    public int StartColumnNumber { get; public set; }
    public int EndLineNumber { get; public set; }
    public int EndColumnNumber { get; public set; }
    public string LibraryId { get; public set; }
    public NuGetFramework Framework { get; public set; }
    [NullableContextAttribute("1")]
private PackagingLogMessage(LogLevel logLevel, NuGetLogCode logCode, string message);
    private PackagingLogMessage(LogLevel logLevel, NuGetLogCode logCode, string message, string libraryId, NuGetFramework framework);
    [NullableContextAttribute("1")]
private PackagingLogMessage(LogLevel logLevel, string message);
    [CompilerGeneratedAttribute]
public sealed virtual LogLevel get_Level();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Level(LogLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetLogCode get_Code();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Code(NuGetLogCode value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual void set_Message(string value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Time();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Time(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProjectPath();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual WarningLevel get_WarningLevel();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WarningLevel(WarningLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FilePath();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_StartLineNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StartLineNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_StartColumnNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StartColumnNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_EndLineNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EndLineNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_EndColumnNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EndColumnNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_LibraryId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LibraryId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetFramework get_Framework();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Framework(NuGetFramework value);
    [NullableContextAttribute("1")]
public static PackagingLogMessage CreateError(string message, NuGetLogCode code);
    [NullableContextAttribute("1")]
public static PackagingLogMessage CreateWarning(string message, NuGetLogCode code);
    [NullableContextAttribute("1")]
public static PackagingLogMessage CreateMessage(string message, LogLevel logLevel);
    [NullableContextAttribute("1")]
public static PackagingLogMessage CreateWarning(string message, NuGetLogCode code, string libraryId, NuGetFramework framework);
    private static NuGetLogCode GetDefaultLogCode(LogLevel logLevel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.PathResolver : object {
    public static IEnumerable`1<T> GetMatches(IEnumerable`1<T> source, Func`2<T, string> getPath, IEnumerable`1<string> wildcards);
    public static void FilterPackageFiles(ICollection`1<T> source, Func`2<T, string> getPath, IEnumerable`1<string> wildcards);
    public static IEnumerable`1<T> GetFilteredPackageFiles(ICollection`1<T> source, Func`2<T, string> getPath, IEnumerable`1<string> wildcards);
    public static string NormalizeWildcardForExcludedFiles(string basePath, string wildcard);
    private static Regex WildcardToRegex(string wildcard);
    public static IEnumerable`1<string> PerformWildcardSearch(string basePath, string searchPath);
    public static IEnumerable`1<SearchPathResult> PerformWildcardSearch(string basePath, string searchPath, bool includeEmptyDirectories, String& normalizedBasePath);
    internal static string GetPathToEnumerateFrom(string basePath, string searchPath);
    internal static string NormalizeBasePath(string basePath, String& searchPath);
    public static bool IsWildcardSearch(string filter);
    [NullableContextAttribute("2")]
public static bool IsDirectoryPath(string path);
    private static bool IsEmptyDirectory(string directory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.PathUtility : object {
    private static Lazy`1<bool> _isFileSystemCaseInsensitive;
    public static bool IsFileSystemCaseInsensitive { get; }
    private static PathUtility();
    public static StringComparer GetStringComparerBasedOnOS();
    public static StringComparison GetStringComparisonBasedOnOS();
    [IteratorStateMachineAttribute("NuGet.Common.PathUtility/<GetUniquePathsBasedOnOS>d__3")]
public static IEnumerable`1<string> GetUniquePathsBasedOnOS(IEnumerable`1<string> paths);
    public static string GetPathWithForwardSlashes(string path);
    public static string EnsureTrailingSlash(string path);
    public static string EnsureTrailingForwardSlash(string path);
    private static string EnsureTrailingCharacter(string path, char trailingCharacter);
    public static bool IsChildOfDirectory(string dir, string candidate);
    [NullableContextAttribute("2")]
public static bool HasTrailingDirectorySeparator(string path);
    public static bool IsDirectorySeparatorChar(char ch);
    public static void EnsureParentDirectory(string filePath);
    public static string GetRelativePath(string path1, string path2);
    public static string GetRelativePath(string path1, string path2, char separator);
    public static string GetAbsolutePath(string basePath, string relativePath);
    public static string GetDirectoryName(string path);
    public static string GetPathWithBackSlashes(string path);
    public static string GetPathWithDirectorySeparator(string path);
    public static string GetPath(Uri uri);
    public static string EscapePSPath(string path);
    public static string SmartTruncate(string path, int maxWidth);
    public static bool IsSubdirectory(string basePath, string path);
    public static string ReplaceAltDirSeparatorWithDirSeparator(string path);
    public static string ReplaceDirSeparatorWithAltDirSeparator(string path);
    public static ZipArchiveEntry GetEntry(ZipArchive archive, string path);
    public static bool get_IsFileSystemCaseInsensitive();
    private static bool CheckIfFileSystemIsCaseInsensitive();
    private static string GetFirstParentDirectoryThatExists(string path);
    private static bool CheckIfFileSystemIsCaseInsensitive(string path);
    public static string StripLeadingDirectorySeparators(string filename);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.PathValidator : object {
    public static bool IsValidSource(string source);
    public static bool IsValidLocalPath(string path);
    public static bool IsValidUncPath(string path);
    public static bool IsValidUrl(string url);
    public static bool IsValidRelativePath(string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.Preprocessor : object {
    [AsyncStateMachineAttribute("NuGet.Common.Preprocessor/<ProcessAsync>d__0")]
public static Task`1<string> ProcessAsync(Func`1<Task`1<Stream>> streamTaskFactory, Func`2<string, string> tokenReplacement, CancellationToken cancellationToken);
    public static string Process(Stream stream, Func`2<string, string> tokenReplacement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.ProjectJsonPathUtilities : object {
    public static string ProjectConfigFileName;
    public static string ProjectConfigFileEnding;
    public static string ProjectLockFileName;
    private static ProjectJsonPathUtilities();
    public static string GetProjectConfigPath(string directoryPath, string projectName);
    public static string GetProjectConfigWithProjectName(string projectName);
    public static string GetProjectLockFileNameWithProjectName(string projectName);
    public static string GetLockFilePath(string configFilePath);
    public static string GetProjectNameFromConfigFileName(string configPath);
    public static bool IsProjectConfig(string configPath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Common.RestoreLogMessage : object {
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLogCode <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Time>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private WarningLevel <WarningLevel>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartColumnNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumnNumber>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <LibraryId>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <TargetGraphs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldDisplay>k__BackingField;
    public LogLevel Level { get; public set; }
    public NuGetLogCode Code { get; public set; }
    public string Message { get; public set; }
    public DateTimeOffset Time { get; public set; }
    [NullableAttribute("2")]
public string ProjectPath { get; public set; }
    public WarningLevel WarningLevel { get; public set; }
    [NullableAttribute("2")]
public string FilePath { get; public set; }
    public int StartLineNumber { get; public set; }
    public int StartColumnNumber { get; public set; }
    public int EndLineNumber { get; public set; }
    public int EndColumnNumber { get; public set; }
    [NullableAttribute("2")]
public string LibraryId { get; public set; }
    public IReadOnlyList`1<string> TargetGraphs { get; public set; }
    public bool ShouldDisplay { get; public set; }
    public RestoreLogMessage(LogLevel logLevel, NuGetLogCode errorCode, string errorString, string targetGraph, bool logToInnerLogger);
    public RestoreLogMessage(LogLevel logLevel, NuGetLogCode errorCode, string errorString, string targetGraph);
    public RestoreLogMessage(LogLevel logLevel, NuGetLogCode errorCode, string errorString);
    public RestoreLogMessage(LogLevel logLevel, string errorString);
    [CompilerGeneratedAttribute]
public sealed virtual LogLevel get_Level();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Level(LogLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetLogCode get_Code();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Code(NuGetLogCode value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Message(string value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Time();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Time(DateTimeOffset value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_ProjectPath();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual WarningLevel get_WarningLevel();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WarningLevel(WarningLevel value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_FilePath();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_StartLineNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StartLineNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_StartColumnNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StartColumnNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_EndLineNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EndLineNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_EndColumnNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EndColumnNumber(int value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_LibraryId();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_LibraryId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_TargetGraphs();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TargetGraphs(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ShouldDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ShouldDisplay(bool value);
    public static RestoreLogMessage CreateWarning(NuGetLogCode code, string message, string libraryId, String[] targetGraphs);
    public static RestoreLogMessage CreateWarning(NuGetLogCode code, string message);
    public static RestoreLogMessage CreateError(NuGetLogCode code, string message);
    public static RestoreLogMessage CreateError(NuGetLogCode code, string message, string libraryId, String[] targetGraphs);
    private static NuGetLogCode GetDefaultLogCode(LogLevel logLevel);
}
public enum NuGet.Common.RevocationMode : Enum {
    public int value__;
    public static RevocationMode Online;
    public static RevocationMode Offline;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.RuntimeEnvironmentHelper : object {
    private static String[] VisualStudioProcesses;
    private static Lazy`1<bool> _isMono;
    private static Lazy`1<bool> _isWindows;
    private static Lazy`1<bool> _IsMacOSX;
    private static Lazy`1<bool> _IsLinux;
    private static Lazy`1<bool> _isRunningInVisualStudio;
    public static bool IsWindows { get; }
    public static bool IsMono { get; }
    public static bool IsRunningInVisualStudio { get; }
    public static bool IsMacOSX { get; }
    public static bool IsLinux { get; }
    private static RuntimeEnvironmentHelper();
    private static int uname(IntPtr buf);
    public static bool get_IsWindows();
    private static bool GetIsWindows();
    public static bool get_IsMono();
    public static bool get_IsRunningInVisualStudio();
    private static string GetCurrentProcessFilePath();
    public static bool get_IsMacOSX();
    private static bool GetIsMacOSX();
    public static bool get_IsLinux();
    private static bool GetIsLinux();
}
public enum NuGet.Common.SignatureAlgorithmName : Enum {
    public int value__;
    public static SignatureAlgorithmName Unknown;
    public static SignatureAlgorithmName SHA256RSA;
    public static SignatureAlgorithmName SHA384RSA;
    public static SignatureAlgorithmName SHA512RSA;
}
public enum NuGet.Common.SignatureValidationMode : Enum {
    public int value__;
    public static SignatureValidationMode Accept;
    public static SignatureValidationMode Require;
}
[ExtensionAttribute]
internal static class NuGet.Common.StringExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static string FormatWithDoubleQuotes(string s);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Common.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Argument_Must_Be_GreaterThanOrEqualTo { get; }
    internal static string ArgumentNullOrEmpty { get; }
    internal static string MissingRequiredEnvVar { get; }
    internal static string MissingRequiredEnvVarsDotnet { get; }
    internal static string TimeUnits_Hour { get; }
    internal static string TimeUnits_Millisecond { get; }
    internal static string TimeUnits_Minute { get; }
    internal static string TimeUnits_Second { get; }
    internal static string UnableToDetemineClientVersion { get; }
    internal static string UnableToSetNuGetTempFolderPermission { get; }
    internal static string UnauthorizedLockFail { get; }
    internal static string UnsupportedHashAlgorithm { get; }
    internal static string UnsupportedHashAlgorithmName { get; }
    internal static string UnsupportedSignatureAlgorithmName { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Argument_Must_Be_GreaterThanOrEqualTo();
    internal static string get_ArgumentNullOrEmpty();
    internal static string get_MissingRequiredEnvVar();
    internal static string get_MissingRequiredEnvVarsDotnet();
    internal static string get_TimeUnits_Hour();
    internal static string get_TimeUnits_Millisecond();
    internal static string get_TimeUnits_Minute();
    internal static string get_TimeUnits_Second();
    internal static string get_UnableToDetemineClientVersion();
    internal static string get_UnableToSetNuGetTempFolderPermission();
    internal static string get_UnauthorizedLockFail();
    internal static string get_UnsupportedHashAlgorithm();
    internal static string get_UnsupportedHashAlgorithmName();
    internal static string get_UnsupportedSignatureAlgorithmName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Common.TelemetryActivity : object {
    private DateTime _startTime;
    private Stopwatch _stopwatch;
    private Stopwatch _intervalWatch;
    private List`1<Tuple`2<string, TimeSpan>> _intervalList;
    [NullableAttribute("2")]
private IDisposable _telemetryActivity;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private TelemetryEvent <TelemetryEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ParentId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <OperationId>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private static INuGetTelemetryService <NuGetTelemetryService>k__BackingField;
    public TelemetryEvent TelemetryEvent { get; public set; }
    public Guid ParentId { get; }
    public Guid OperationId { get; }
    [NullableAttribute("2")]
public static INuGetTelemetryService NuGetTelemetryService { get; public set; }
    private TelemetryActivity(Guid parentId, TelemetryEvent telemetryEvent, Guid operationId);
    [CompilerGeneratedAttribute]
public TelemetryEvent get_TelemetryEvent();
    [CompilerGeneratedAttribute]
public void set_TelemetryEvent(TelemetryEvent value);
    [CompilerGeneratedAttribute]
public Guid get_ParentId();
    [CompilerGeneratedAttribute]
public Guid get_OperationId();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static INuGetTelemetryService get_NuGetTelemetryService();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static void set_NuGetTelemetryService(INuGetTelemetryService value);
    public void StartIntervalMeasure();
    public void EndIntervalMeasure(string propertyName);
    public IDisposable StartIndependentInterval(string propertyName);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public static void EmitTelemetryEvent(TelemetryEvent TelemetryEvent);
    public static TelemetryActivity Create(string eventName);
    public static TelemetryActivity Create(TelemetryEvent telemetryEvent);
    public static TelemetryActivity Create(Guid parentId, string eventName);
    public static TelemetryActivity Create(Guid parentId, TelemetryEvent telemetryEvent);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class NuGet.Common.TelemetryEvent : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<string, object> _properties;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<string, object> _piiProperties;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IDictionary`2<string, object> <ComplexData>k__BackingField;
    public string Name { get; }
    public int Count { get; }
    [NullableAttribute("2")]
public object Item { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, object> ComplexData { get; }
    public TelemetryEvent(string eventName);
    public TelemetryEvent(string eventName, Dictionary`2<string, object> properties);
    [CompilerGeneratedAttribute]
public string get_Name();
    public int get_Count();
    public object get_Item(string key);
    public void set_Item(string key, object value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_ComplexData();
    public IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    public void AddPiiData(string key, object value);
    public IEnumerable`1<KeyValuePair`2<string, object>> GetPiiData();
}
public static class NuGet.Common.TelemetryServiceUtility : object {
    [NullableAttribute("2")]
private static Stopwatch StopWatch;
    public static void StartOrResumeTimer();
    public static void StopTimer();
    public static TimeSpan GetTimerElapsedTime();
    public static double GetTimerElapsedTimeInSeconds();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Common.Token : object {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenCategory <Category>k__BackingField;
    public string Value { get; private set; }
    public TokenCategory Category { get; private set; }
    public Token(TokenCategory category, string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
    [CompilerGeneratedAttribute]
public TokenCategory get_Category();
    [CompilerGeneratedAttribute]
private void set_Category(TokenCategory value);
}
public enum NuGet.Common.TokenCategory : Enum {
    public int value__;
    public static TokenCategory Text;
    public static TokenCategory Variable;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Common.Tokenizer : object {
    private string _text;
    private int _index;
    public Tokenizer(string text);
    [NullableContextAttribute("2")]
public Token Read();
    private static bool IsWordChar(char ch);
    private Token ParseTokenAfterDollarSign();
    private Token ParseText();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.UriUtility : object {
    private static string FilePrefix;
    private static bool IsHttpUrl(Uri uri);
    public static Uri CreateSourceUri(string source, UriKind kind);
    public static Uri TryCreateSourceUri(string source, UriKind kind);
    private static string FixSourceUri(string source);
    public static string UrlEncodeOdataParameter(string value);
    public static string GetLocalPath(string localOrUriPath);
    public static string GetAbsolutePathFromFile(string sourceFile, string path);
    [NullableContextAttribute("2")]
public static string GetAbsolutePath(string rootDirectory, string path);
    [NullableContextAttribute("2")]
public static bool IsNuGetOrg(string source);
}
public enum NuGet.Common.WarningLevel : Enum {
    public int value__;
    public static WarningLevel Severe;
    public static WarningLevel Important;
    public static WarningLevel Minimal;
    public static WarningLevel Default;
}
[ObsoleteAttribute("This class is obsolete and will be removed in a future release.")]
public static class NuGet.Common.XmlUtility : object {
    [NullableContextAttribute("1")]
public static XDocument Load(string filePath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.AddItem : SettingItem {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> <DisallowedValues>k__BackingField;
    public string ElementName { get; }
    public string Key { get; }
    public string Value { get; public set; }
    public IReadOnlyDictionary`2<string, string> AdditionalAttributes { get; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    protected IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> DisallowedValues { get; }
    public AddItem(string key, string value);
    internal AddItem(XElement element, SettingsFile origin);
    public AddItem(string key, string value, IReadOnlyDictionary`2<string, string> additionalAttributes);
    public virtual string get_ElementName();
    public string get_Key();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public IReadOnlyDictionary`2<string, string> get_AdditionalAttributes();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> get_DisallowedValues();
    public virtual string GetValueAsPath();
    public void AddOrUpdateAdditionalAttribute(string attributeName, string value);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(object other);
    public sealed virtual int GetHashCode();
    public virtual SettingBase Clone();
    internal virtual void Update(SettingItem other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.AuthorItem : TrustedSignerItem {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    public string ElementName { get; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    public AuthorItem(string name, CertificateItem[] certificates);
    internal AuthorItem(XElement element, SettingsFile origin);
    public virtual string get_ElementName();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    public virtual SettingBase Clone();
    internal virtual XNode AsXNode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.CertificateItem : SettingItem {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    public string ElementName { get; }
    public string Fingerprint { get; public set; }
    public HashAlgorithmName HashAlgorithm { get; public set; }
    public bool AllowUntrustedRoot { get; public set; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    public CertificateItem(string fingerprint, HashAlgorithmName hashAlgorithm, bool allowUntrustedRoot);
    internal CertificateItem(XElement element, SettingsFile origin);
    public virtual string get_ElementName();
    public string get_Fingerprint();
    public void set_Fingerprint(string value);
    public HashAlgorithmName get_HashAlgorithm();
    public void set_HashAlgorithm(HashAlgorithmName value);
    public bool get_AllowUntrustedRoot();
    public void set_AllowUntrustedRoot(bool value);
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    public virtual SettingBase Clone();
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.ClearItem : SettingItem {
    public string ElementName { get; }
    internal ClearItem(XElement element, SettingsFile origin);
    public virtual string get_ElementName();
    public virtual bool IsEmpty();
    public virtual SettingBase Clone();
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.ClientCertificateProvider : object {
    private ISettings _settings;
    public ClientCertificateProvider(ISettings settings);
    public sealed virtual void AddOrUpdate(ClientCertItem item);
    public sealed virtual void Remove(IReadOnlyList`1<ClientCertItem> items);
    public sealed virtual IReadOnlyList`1<ClientCertItem> GetClientCertificates();
    public ClientCertItem GetClientCertificate(string packageSourceName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NuGet.Configuration.ClientCertItem : SettingItem {
    public string PackageSource { get; }
    protected bool CanHaveChildren { get; }
    protected ClientCertItem(string packageSource);
    internal ClientCertItem(XElement element, SettingsFile origin);
    public string get_PackageSource();
    protected virtual bool get_CanHaveChildren();
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public abstract virtual IEnumerable`1<X509Certificate> Search();
    protected void SetPackageSource(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Configuration.ConfigurationConstants : object {
    public static string ActivePackageSourceSectionName;
    public static string Add;
    public static string AllowUntrustedRoot;
    public static string AllowInsecureConnections;
    public static string ApiKeys;
    public static string AuditSources;
    public static string Author;
    public static string BeginIgnoreMarker;
    public static string BindingRedirectsSection;
    public static string Certificate;
    public static string Package;
    public static string Clear;
    public static string ClearTextPasswordAttribute;
    public static string ClearTextPasswordToken;
    public static string ClientCertificates;
    public static string Config;
    public static string Configuration;
    public static string ConfigurationDefaultsFile;
    public static string CredentialsSectionName;
    public static string DefaultPackageManagementFormatKey;
    public static string DefaultPushSource;
    public static string DependencyVersion;
    public static string DisabledPackageSources;
    public static string DisableTLSCertificateValidation;
    public static string DoNotShowPackageManagementSelectionKey;
    public static string Enabled;
    public static string EndIgnoreMarker;
    public static string FailOnBindingRedirects;
    public static string FallbackPackageFolders;
    public static string FileCertificate;
    public static string FindByAttribute;
    public static string FindValueAttribute;
    public static string Fingerprint;
    public static string FingerprintAlgorithm;
    public static string UpdatePackageLastAccessTime;
    public static string GlobalPackagesFolder;
    public static string HashAlgorithm;
    public static string HostKey;
    public static string KeyAttribute;
    public static string MaxHttpRequestsPerSource;
    public static string NameAttribute;
    public static string NoProxy;
    public static string Owners;
    public static string PackageManagementSection;
    public static string PackageRestore;
    public static string PackageSourceAttribute;
    public static string PackageSources;
    public static string PasswordAttribute;
    public static string PasswordKey;
    public static string PasswordToken;
    public static string PathAttribute;
    public static string ProtocolVersionAttribute;
    public static string Repository;
    public static string RepositoryPath;
    public static string ServiceIndex;
    public static string SignatureValidationMode;
    public static string SkipBindingRedirectsKey;
    public static string StoreCertificate;
    public static string StoreLocationAttribute;
    public static string StoreNameAttribute;
    public static string TrustedSigners;
    public static string PackageSourceMapping;
    public static string UserKey;
    public static string UsernameToken;
    public static string ValidAuthenticationTypesToken;
    public static string ValueAttribute;
    public static string PatternAttribute;
    private static ConfigurationConstants();
    public static IReadOnlyList`1<string> GetConfigKeys();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.ConfigurationDefaults : object {
    private ISettings _settingsManager;
    private bool _defaultPackageSourceInitialized;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyList`1<PackageSource> _defaultPackageSources;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyList`1<PackageSource> _defaultAuditSources;
    [NullableAttribute("2")]
private string _defaultPushSource;
    [CompilerGeneratedAttribute]
private static ConfigurationDefaults <Instance>k__BackingField;
    public static ConfigurationDefaults Instance { get; }
    public IEnumerable`1<PackageSource> DefaultPackageSources { get; }
    public IReadOnlyList`1<PackageSource> DefaultAuditSources { get; }
    [NullableAttribute("2")]
public string DefaultPushSource { get; }
    [NullableAttribute("2")]
public string DefaultPackageRestoreConsent { get; }
    internal ConfigurationDefaults(string directory, string configFile);
    internal ConfigurationDefaults(ISettings settingsManager);
    private static ConfigurationDefaults();
    private static ConfigurationDefaults InitializeInstance();
    [CompilerGeneratedAttribute]
public static ConfigurationDefaults get_Instance();
    private IReadOnlyList`1<PackageSource> GetSourceItems(string sectionName);
    public IEnumerable`1<PackageSource> get_DefaultPackageSources();
    public IReadOnlyList`1<PackageSource> get_DefaultAuditSources();
    [NullableContextAttribute("2")]
public string get_DefaultPushSource();
    [NullableContextAttribute("2")]
public string get_DefaultPackageRestoreConsent();
}
public enum NuGet.Configuration.CredentialRequestType : Enum {
    public int value__;
    public static CredentialRequestType Proxy;
    public static CredentialRequestType Unauthorized;
    public static CredentialRequestType Forbidden;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.CredentialsItem : SettingItem {
    [CompilerGeneratedAttribute]
private string <ElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPasswordClearText>k__BackingField;
    internal AddItem _username;
    internal AddItem _password;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private AddItem <_validAuthenticationTypes>k__BackingField;
    public string ElementName { get; }
    public string Username { get; public set; }
    public bool IsPasswordClearText { get; private set; }
    public string Password { get; }
    [NullableAttribute("2")]
public string ValidAuthenticationTypes { get; public set; }
    protected bool CanHaveChildren { get; }
    [NullableAttribute("2")]
internal AddItem _validAuthenticationTypes { get; internal set; }
    public CredentialsItem(string name, string username, string password, bool isPasswordClearText, string validAuthenticationTypes);
    internal CredentialsItem(XElement element, SettingsFile origin);
    [CompilerGeneratedAttribute]
public virtual string get_ElementName();
    public string get_Username();
    public void set_Username(string value);
    [CompilerGeneratedAttribute]
public bool get_IsPasswordClearText();
    [CompilerGeneratedAttribute]
private void set_IsPasswordClearText(bool value);
    public string get_Password();
    public void UpdatePassword(string password, bool isPasswordClearText);
    [NullableContextAttribute("2")]
public string get_ValidAuthenticationTypes();
    [NullableContextAttribute("2")]
public void set_ValidAuthenticationTypes(string value);
    protected virtual bool get_CanHaveChildren();
    public virtual bool IsEmpty();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal AddItem get__validAuthenticationTypes();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set__validAuthenticationTypes(AddItem value);
    public virtual SettingBase Clone();
    internal virtual XNode AsXNode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
    internal virtual void Update(SettingItem other);
    internal virtual void SetOrigin(SettingsFile origin);
    internal virtual void RemoveFromSettings();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Configuration.EncryptionUtility : object {
    private static Byte[] _entropyBytes;
    private static EncryptionUtility();
    public static string EncryptString(string value);
    public static string DecryptString(string encryptedString);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.FileClientCertItem : ClientCertItem {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <AllowedAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    public string ElementName { get; }
    public string FilePath { get; }
    public bool IsPasswordIsClearText { get; }
    [NullableAttribute("2")]
public string Password { get; }
    protected IReadOnlyCollection`1<string> AllowedAttributes { get; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    public FileClientCertItem(string packageSource, string filePath, string password, bool storePasswordInClearText, string settingsFilePath);
    internal FileClientCertItem(string packageSource, string filePath, string password, bool storePasswordInClearText, SettingsFile origin);
    internal FileClientCertItem(XElement element, SettingsFile origin);
    private static SettingsFile GetSettingsFile(string settingsFilePath);
    public virtual string get_ElementName();
    public string get_FilePath();
    public bool get_IsPasswordIsClearText();
    [NullableContextAttribute("2")]
public string get_Password();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_AllowedAttributes();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    internal virtual XNode AsXNode();
    public virtual SettingBase Clone();
    public virtual IEnumerable`1<X509Certificate> Search();
    public void Update(string filePath, string password, bool storePasswordInClearText);
    [NullableContextAttribute("2")]
private string FindAbsoluteFilePath();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NuGet.Configuration.FileSystemUtility : object {
    internal static XDocument GetOrCreateDocument(XDocument content, string fullPath);
    internal static void AddFile(string fullPath, Action`1<Stream> writeToStream);
    private static int chmod(string pathname, int mode);
    internal static bool IsPathAFile(string path);
    internal static bool DoesFileExistIn(string root, string file);
    internal static IEnumerable`1<string> GetFilesRelativeToRoot(string root, string path, String[] filters, SearchOption searchOption);
    internal static string GetRelativePath(string root, string fullPath);
    internal static string EnsureTrailingSlash(string path);
    internal static string EnsureTrailingForwardSlash(string path);
    private static string EnsureTrailingCharacter(string path, char trailingCharacter);
}
[NullableContextAttribute("1")]
public interface NuGet.Configuration.IClientCertificateProvider {
    public abstract virtual void AddOrUpdate(ClientCertItem item);
    public abstract virtual IReadOnlyList`1<ClientCertItem> GetClientCertificates();
    public abstract virtual void Remove(IReadOnlyList`1<ClientCertItem> items);
}
[NullableContextAttribute("1")]
public interface NuGet.Configuration.ICredentialCache {
    public abstract virtual void Add(Uri uri, ICredentials credentials);
    public abstract virtual ICredentials GetCredentials(Uri uri);
}
[NullableContextAttribute("1")]
public interface NuGet.Configuration.ICredentialService {
    public bool HandlesDefaultCredentials { get; }
    public abstract virtual Task`1<ICredentials> GetCredentialsAsync(Uri uri, IWebProxy proxy, CredentialRequestType type, string message, CancellationToken cancellationToken);
    public abstract virtual bool TryGetLastKnownGoodCredentialsFromCache(Uri uri, bool isProxy, ICredentials& credentials);
    public abstract virtual bool get_HandlesDefaultCredentials();
}
[NullableContextAttribute("1")]
public interface NuGet.Configuration.IExtensionLocator {
    public abstract virtual IEnumerable`1<string> FindExtensions();
    public abstract virtual IEnumerable`1<string> FindCredentialProviders();
}
[NullableContextAttribute("1")]
public interface NuGet.Configuration.IMachineWideSettings {
    public ISettings Settings { get; }
    public abstract virtual ISettings get_Settings();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.Configuration.ImmutableSettings : object {
    private ISettings _settings;
    internal ImmutableSettings(ISettings settings);
    [NullableContextAttribute("2")]
public sealed virtual void add_SettingsChanged(EventHandler value);
    [NullableContextAttribute("2")]
public sealed virtual void remove_SettingsChanged(EventHandler value);
    public sealed virtual void AddOrUpdate(string sectionName, SettingItem item);
    public sealed virtual IList`1<string> GetConfigFilePaths();
    public sealed virtual IList`1<string> GetConfigRoots();
    public sealed virtual SettingSection GetSection(string sectionName);
    public sealed virtual void Remove(string sectionName, SettingItem item);
    public sealed virtual void SaveToDisk();
}
[NullableContextAttribute("1")]
public interface NuGet.Configuration.IPackageSourceProvider {
    [NullableAttribute("2")]
public string ActivePackageSourceName { get; }
    [NullableAttribute("2")]
public string DefaultPushSource { get; }
    public abstract virtual IEnumerable`1<PackageSource> LoadPackageSources();
    public abstract virtual IReadOnlyList`1<PackageSource> LoadAuditSources();
    public abstract virtual PackageSource GetPackageSourceByName(string name);
    public abstract virtual PackageSource GetPackageSourceBySource(string source);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public abstract virtual void add_PackageSourcesChanged(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public abstract virtual void remove_PackageSourcesChanged(EventHandler value);
    public abstract virtual void RemovePackageSource(string name);
    public abstract virtual void EnablePackageSource(string name);
    public abstract virtual void DisablePackageSource(string name);
    public abstract virtual void UpdatePackageSource(PackageSource source, bool updateCredentials, bool updateEnabled);
    public abstract virtual void AddPackageSource(PackageSource source);
    public abstract virtual void SavePackageSources(IEnumerable`1<PackageSource> sources);
    public abstract virtual bool IsPackageSourceEnabled(string name);
    [NullableContextAttribute("2")]
public abstract virtual string get_ActivePackageSourceName();
    [NullableContextAttribute("2")]
public abstract virtual string get_DefaultPushSource();
    public abstract virtual void SaveActivePackageSource(PackageSource source);
}
[NullableContextAttribute("1")]
public interface NuGet.Configuration.IProxyCache {
    public abstract virtual void Add(IWebProxy proxy);
    public abstract virtual IWebProxy GetProxy(Uri uri);
}
public interface NuGet.Configuration.IProxyCredentialCache {
    public Guid Version { get; }
    public abstract virtual Guid get_Version();
    [NullableContextAttribute("1")]
public abstract virtual void UpdateCredential(Uri proxyAddress, NetworkCredential credentials);
}
[NullableContextAttribute("1")]
public interface NuGet.Configuration.ISettings {
    public abstract virtual SettingSection GetSection(string sectionName);
    public abstract virtual void AddOrUpdate(string sectionName, SettingItem item);
    public abstract virtual void Remove(string sectionName, SettingItem item);
    public abstract virtual void SaveToDisk();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public abstract virtual void add_SettingsChanged(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public abstract virtual void remove_SettingsChanged(EventHandler value);
    public abstract virtual IList`1<string> GetConfigFilePaths();
    public abstract virtual IList`1<string> GetConfigRoots();
}
[NullableContextAttribute("1")]
internal interface NuGet.Configuration.ISettingsGroup {
    public abstract virtual void Remove(SettingElement setting);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class NuGet.Configuration.NuGetConfiguration : SettingsGroup`1<SettingSection> {
    internal IReadOnlyDictionary`2<string, SettingSection> Sections { get; }
    protected bool CanBeCleared { get; }
    private NuGetConfiguration(IReadOnlyDictionary`2<string, string> attributes, IEnumerable`1<SettingSection> children);
    internal NuGetConfiguration(SettingSection[] sections);
    internal NuGetConfiguration(SettingsFile origin);
    internal NuGetConfiguration(XElement element, SettingsFile origin);
    internal IReadOnlyDictionary`2<string, SettingSection> get_Sections();
    protected virtual bool get_CanBeCleared();
    public void AddOrUpdate(string sectionName, SettingItem item);
    public void Remove(string sectionName, SettingItem item);
    public SettingSection GetSection(string sectionName);
    internal void MergeSectionsInto(Dictionary`2<string, VirtualSettingSection> sectionsContainer);
    public virtual SettingBase Clone();
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.NuGetConfigurationException : Exception {
    public NuGetConfigurationException(string message);
    public NuGetConfigurationException(string message, Exception innerException);
    protected NuGetConfigurationException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Configuration.NuGetConstants : object {
    public static string NuGetHostName;
    public static string NuGetSymbolHostName;
    public static string V3FeedUrl;
    public static string V2FeedUrl;
    public static string V2LegacyOfficialPackageSourceUrl;
    public static string V2LegacyFeedUrl;
    public static string V1FeedUrl;
    public static string DefaultGalleryServerUrl;
    public static string ReadmeFileName;
    public static string NuGetSolutionSettingsFolder;
    public static string PackageExtension;
    public static string SnupkgExtension;
    public static string SymbolsExtension;
    public static string ManifestExtension;
    public static string ManifestSymbolsExtension;
    public static string ReadmeExtension;
    public static string PackageReferenceFile;
    public static string PackageSpecFileName;
    public static string FeedName;
    public static string DefaultConfigContent;
    private static NuGetConstants();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>RequiredMemberAttribute]
public class NuGet.Configuration.NuGetPathContext : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <FallbackPackageFolders>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserPackageFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HttpCacheFolder>k__BackingField;
    [<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>RequiredMemberAttribute]
public IReadOnlyList`1<string> FallbackPackageFolders { get; public set; }
    [<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>RequiredMemberAttribute]
public string UserPackageFolder { get; public set; }
    [<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>RequiredMemberAttribute]
public string HttpCacheFolder { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_FallbackPackageFolders();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>IsExternalInit) set_FallbackPackageFolders(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_UserPackageFolder();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>IsExternalInit) set_UserPackageFolder(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_HttpCacheFolder();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>IsExternalInit) set_HttpCacheFolder(string value);
    public static NuGetPathContext Create(ISettings settings);
    public static NuGetPathContext Create(string settingsRoot);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.NullSettings : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler SettingsChanged;
    [CompilerGeneratedAttribute]
private static NullSettings <Instance>k__BackingField;
    public static NullSettings Instance { get; }
    private static NullSettings();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_SettingsChanged(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_SettingsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public static NullSettings get_Instance();
    public sealed virtual SettingSection GetSection(string sectionName);
    public sealed virtual void AddOrUpdate(string sectionName, SettingItem item);
    public sealed virtual void Remove(string sectionName, SettingItem item);
    public sealed virtual void SaveToDisk();
    public sealed virtual IList`1<string> GetConfigFilePaths();
    public sealed virtual IList`1<string> GetConfigRoots();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.OwnersItem : SettingItem {
    public static char OwnersListSeparator;
    [CompilerGeneratedAttribute]
private IList`1<string> <Content>k__BackingField;
    private SettingText _content;
    public string ElementName { get; }
    protected bool CanHaveChildren { get; }
    public IList`1<string> Content { get; private set; }
    public OwnersItem(string owners);
    internal OwnersItem(XElement element, SettingsFile origin);
    private static OwnersItem();
    public virtual string get_ElementName();
    protected virtual bool get_CanHaveChildren();
    [CompilerGeneratedAttribute]
public IList`1<string> get_Content();
    [CompilerGeneratedAttribute]
private void set_Content(IList`1<string> value);
    public virtual SettingBase Clone();
    internal virtual XNode AsXNode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
    internal virtual void Update(SettingItem other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.PackagePatternItem : SettingItem {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    public string ElementName { get; }
    public string Pattern { get; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    public PackagePatternItem(string pattern);
    internal PackagePatternItem(XElement element, SettingsFile origin);
    public virtual string get_ElementName();
    public string get_Pattern();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    public virtual SettingBase Clone();
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.PackageSource : object {
    public static int DefaultProtocolVersion;
    public static int MaxProtocolVersion;
    internal static bool DefaultAllowInsecureConnections;
    internal static bool DefaultDisableTLSCertificateValidation;
    private int _hashCode;
    private string _source;
    private bool _isHttp;
    private bool _isHttps;
    private bool _isLocal;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOfficial>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMachineWide>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PackageSourceCredential <Credentials>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPersistable>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxHttpRequestsPerSource>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<X509Certificate> <ClientCertificates>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProtocolVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowInsecureConnections>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableTLSCertificateValidation>k__BackingField;
    public string Name { get; }
    public string Source { get; public set; }
    [NullableAttribute("2")]
public Uri TrySourceAsUri { get; }
    public Uri SourceUri { get; }
    public bool IsOfficial { get; public set; }
    public bool IsMachineWide { get; public set; }
    public bool IsEnabled { get; public set; }
    [NullableAttribute("2")]
public PackageSourceCredential Credentials { get; public set; }
    [NullableAttribute("2")]
public string Description { get; public set; }
    public bool IsPersistable { get; }
    public int MaxHttpRequestsPerSource { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<X509Certificate> ClientCertificates { get; public set; }
    public int ProtocolVersion { get; public set; }
    public bool AllowInsecureConnections { get; public set; }
    public bool DisableTLSCertificateValidation { get; public set; }
    public bool IsHttp { get; }
    public bool IsHttps { get; }
    public bool IsLocal { get; }
    public PackageSource(string source);
    public PackageSource(string source, string name);
    public PackageSource(string source, string name, bool isEnabled);
    public PackageSource(string source, string name, bool isEnabled, bool isOfficial, bool isPersistable);
    [CompilerGeneratedAttribute]
public string get_Name();
    public string get_Source();
    public void set_Source(string value);
    [NullableContextAttribute("2")]
public Uri get_TrySourceAsUri();
    public Uri get_SourceUri();
    [CompilerGeneratedAttribute]
public bool get_IsOfficial();
    [CompilerGeneratedAttribute]
public void set_IsOfficial(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsMachineWide();
    [CompilerGeneratedAttribute]
public void set_IsMachineWide(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    [CompilerGeneratedAttribute]
public void set_IsEnabled(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public PackageSourceCredential get_Credentials();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Credentials(PackageSourceCredential value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Description();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public bool get_IsPersistable();
    [CompilerGeneratedAttribute]
public int get_MaxHttpRequestsPerSource();
    [CompilerGeneratedAttribute]
public void set_MaxHttpRequestsPerSource(int value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<X509Certificate> get_ClientCertificates();
    [CompilerGeneratedAttribute]
public void set_ClientCertificates(IReadOnlyList`1<X509Certificate> value);
    [CompilerGeneratedAttribute]
public int get_ProtocolVersion();
    [CompilerGeneratedAttribute]
public void set_ProtocolVersion(int value);
    [CompilerGeneratedAttribute]
public bool get_AllowInsecureConnections();
    [CompilerGeneratedAttribute]
public void set_AllowInsecureConnections(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableTLSCertificateValidation();
    [CompilerGeneratedAttribute]
public void set_DisableTLSCertificateValidation(bool value);
    public bool get_IsHttp();
    public bool get_IsHttps();
    public bool get_IsLocal();
    public SourceItem AsSourceItem();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(PackageSource other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual string ToString();
    public virtual int GetHashCode();
    public PackageSource Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.PackageSourceCredential : object {
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PasswordText>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPasswordClearText>k__BackingField;
    private Lazy`1<int> _hashCode;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ValidAuthenticationTypesText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    public string Username { get; }
    public string PasswordText { get; }
    public bool IsPasswordClearText { get; }
    public IEnumerable`1<string> ValidAuthenticationTypes { get; }
    [NullableAttribute("2")]
public string ValidAuthenticationTypesText { get; }
    public string Password { get; }
    public string Source { get; }
    public PackageSourceCredential(string source, string username, string passwordText, bool isPasswordClearText, string validAuthenticationTypesText);
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public string get_PasswordText();
    [CompilerGeneratedAttribute]
public bool get_IsPasswordClearText();
    public IEnumerable`1<string> get_ValidAuthenticationTypes();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_ValidAuthenticationTypesText();
    public string get_Password();
    [CompilerGeneratedAttribute]
public string get_Source();
    public bool IsValid();
    public static PackageSourceCredential FromUserInput(string source, string username, string password, bool storePasswordInClearText, string validAuthenticationTypesText);
    public ICredentials ToICredentials();
    internal PackageSourceCredential Clone();
    private static IEnumerable`1<string> ParseAuthTypeFilterString(string str);
    public CredentialsItem AsCredentialsItem();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(PackageSourceCredential other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
private int <.ctor>b__21_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.PackageSourceMapping : object {
    [CompilerGeneratedAttribute]
private static int <PackageIdMaxLength>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> <Patterns>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Lazy`1<SearchTree> <SearchTree>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    internal static int PackageIdMaxLength { get; }
    internal IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> Patterns { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<SearchTree> SearchTree { get; }
    public bool IsEnabled { get; }
    public PackageSourceMapping(IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> patterns);
    private static PackageSourceMapping();
    [CompilerGeneratedAttribute]
internal static int get_PackageIdMaxLength();
    [CompilerGeneratedAttribute]
internal IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> get_Patterns();
    [CompilerGeneratedAttribute]
private Lazy`1<SearchTree> get_SearchTree();
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    public IReadOnlyList`1<string> GetConfiguredPackageSources(string packageId);
    public string SearchForPattern(string packageId);
    public static PackageSourceMapping GetPackageSourceMapping(ISettings settings);
    private SearchTree GetSearchTree();
    [CompilerGeneratedAttribute]
private SearchTree <.ctor>b__14_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.PackageSourceMappingProvider : object {
    private ISettings _settings;
    [CompilerGeneratedAttribute]
private bool <ShouldSkipSave>k__BackingField;
    public bool ShouldSkipSave { get; }
    public PackageSourceMappingProvider(ISettings settings);
    public PackageSourceMappingProvider(ISettings settings, bool shouldSkipSave);
    [CompilerGeneratedAttribute]
public bool get_ShouldSkipSave();
    public IReadOnlyList`1<PackageSourceMappingSourceItem> GetPackageSourceMappingItems();
    internal void Remove(IReadOnlyList`1<PackageSourceMappingSourceItem> packageSourceMappingSourceItems);
    internal void AddOrUpdatePackageSourceMappingSourceItem(PackageSourceMappingSourceItem packageSourceMappingSourceItem);
    public void SavePackageSourceMappings(IReadOnlyList`1<PackageSourceMappingSourceItem> packageSourceMappingsSourceItems);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.PackageSourceMappingSourceItem : SettingItem {
    [CompilerGeneratedAttribute]
private IList`1<PackagePatternItem> <Patterns>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    protected bool CanHaveChildren { get; }
    public IList`1<PackagePatternItem> Patterns { get; }
    public string ElementName { get; }
    public string Key { get; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    public PackageSourceMappingSourceItem(string name, IEnumerable`1<PackagePatternItem> packagePatternItems);
    internal PackageSourceMappingSourceItem(XElement element, SettingsFile origin);
    protected virtual bool get_CanHaveChildren();
    [CompilerGeneratedAttribute]
public IList`1<PackagePatternItem> get_Patterns();
    public virtual string get_ElementName();
    public virtual string get_Key();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    protected void SetKey(string value);
    internal virtual void SetOrigin(SettingsFile origin);
    internal virtual void RemoveFromSettings();
    public virtual SettingBase Clone();
    internal virtual XNode AsXNode();
    internal virtual void Update(SettingItem other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.PackageSourceProvider : object {
    [CompilerGeneratedAttribute]
private ISettings <Settings>k__BackingField;
    internal static int MaxSupportedProtocolVersion;
    private IReadOnlyList`1<PackageSource> _configurationDefaultSources;
    private IReadOnlyList`1<PackageSource> _configurationDefaultAuditSources;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler PackageSourcesChanged;
    public ISettings Settings { get; private set; }
    [NullableAttribute("2")]
public string DefaultPushSource { get; }
    [NullableAttribute("2")]
public string ActivePackageSourceName { get; }
    public PackageSourceProvider(ISettings settings);
    [ObsoleteAttribute("https://github.com/NuGet/Home/issues/8479")]
public PackageSourceProvider(ISettings settings, bool enablePackageSourcesChangedEvent);
    public PackageSourceProvider(ISettings settings, IEnumerable`1<PackageSource> configurationDefaultSources);
    [ObsoleteAttribute("https://github.com/NuGet/Home/issues/8479")]
public PackageSourceProvider(ISettings settings, IEnumerable`1<PackageSource> configurationDefaultSources, bool enablePackageSourcesChangedEvent);
    public PackageSourceProvider(ISettings settings, ConfigurationDefaults configurationDefaults);
    [ObsoleteAttribute("https://github.com/NuGet/Home/issues/8479")]
public PackageSourceProvider(ISettings settings, ConfigurationDefaults configurationDefaults, bool enablePackageSourcesChangedEvent);
    private PackageSourceProvider(ISettings settings, IEnumerable`1<PackageSource> configurationDefaultSources, IReadOnlyList`1<PackageSource> configurationDefaultAuditSources, bool enablePackageSourcesChangedEvent);
    [CompilerGeneratedAttribute]
public ISettings get_Settings();
    [CompilerGeneratedAttribute]
private void set_Settings(ISettings value);
    private static IReadOnlyList`1<PackageSource> LoadConfigurationDefaultSources(IEnumerable`1<PackageSource> configurationDefaultSources);
    private static List`1<PackageSource> GetPackageSourceFromSettings(ISettings settings, string sectionName);
    public sealed virtual IEnumerable`1<PackageSource> LoadPackageSources();
    public sealed virtual IReadOnlyList`1<PackageSource> LoadAuditSources();
    public static IEnumerable`1<PackageSource> LoadPackageSources(ISettings settings);
    private static List`1<PackageSource> LoadPackageSources(ISettings settings, string sectionName, IEnumerable`1<PackageSource> defaultSources);
    private static void AddDefaultPackageSources(List`1<PackageSource> loadedPackageSources, IEnumerable`1<PackageSource> defaultPackageSources);
    internal static PackageSource ReadPackageSource(SourceItem setting, bool isEnabled, ISettings settings);
    private static int ReadProtocolVersion(SourceItem setting);
    private static bool ReadDisableTLSCertificateValidation(SourceItem setting);
    private static bool ReadAllowInsecureConnections(SourceItem setting);
    private static void AddOrUpdateIndexedSource(Dictionary`2<string, IndexedPackageSource> packageSourceLookup, PackageSource packageSource, Int32& packageIndex);
    private static PackageSourceCredential ReadCredential(string sourceName, ISettings settings);
    private static PackageSourceCredential ReadCredentialFromEnvironment(string sourceName);
    public sealed virtual PackageSource GetPackageSourceByName(string name);
    public HashSet`1<string> GetPackageSourceNamesMatchingNamePrefix(string namePrefix);
    public sealed virtual PackageSource GetPackageSourceBySource(string source);
    public sealed virtual void RemovePackageSource(string name);
    private void RemovePackageSource(string name, bool shouldSkipSave, Boolean& isDirty);
    [ObsoleteAttribute("DisablePackageSource(PackageSource source) is deprecated. Please use DisablePackageSource(string name) instead.")]
public void DisablePackageSource(PackageSource source);
    public sealed virtual void DisablePackageSource(string name);
    private void AddDisabledSource(string name, bool shouldSkipSave, Boolean& isDirty);
    public sealed virtual void EnablePackageSource(string name);
    private void RemoveDisabledSource(string name, bool shouldSkipSave, Boolean& isDirty);
    public sealed virtual void UpdatePackageSource(PackageSource source, bool updateCredentials, bool updateEnabled);
    private void UpdatePackageSource(PackageSource newSource, PackageSource existingSource, AddItem existingDisabledSourceItem, CredentialsItem existingCredentialsItem, bool updateEnabled, bool updateCredentials, bool shouldSkipSave, Boolean& isDirty);
    public sealed virtual void AddPackageSource(PackageSource source);
    private void AddPackageSource(PackageSource source, bool shouldSkipSave, Boolean& isDirty);
    public sealed virtual void SavePackageSources(IEnumerable`1<PackageSource> sources);
    private Dictionary`2<string, SourceItem> GetExistingSettingsLookup();
    private void OnPackageSourcesChanged();
    [NullableContextAttribute("2")]
public sealed virtual string get_DefaultPushSource();
    public sealed virtual bool IsPackageSourceEnabled(string name);
    [ObsoleteAttribute("IsPackageSourceEnabled(PackageSource source) is deprecated. Please use IsPackageSourceEnabled(string name) instead.")]
public bool IsPackageSourceEnabled(PackageSource source);
    [NullableContextAttribute("2")]
public sealed virtual string get_ActivePackageSourceName();
    public sealed virtual void SaveActivePackageSource(PackageSource source);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_PackageSourcesChanged(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_PackageSourcesChanged(EventHandler value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__13_0(object _, EventArgs __);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.Configuration.ParsedSettingSection : SettingSection {
    internal ParsedSettingSection(string name, XElement element, SettingsFile origin);
    internal ParsedSettingSection(string name, SettingItem[] children);
    public virtual SettingBase Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.ProxyCache : object {
    private static IWebProxy _originalSystemProxy;
    private ConcurrentDictionary`2<Uri, ICredentials> _cachedCredentials;
    private ISettings _settings;
    private IEnvironmentVariableReader _environment;
    private static Lazy`1<ProxyCache> _instance;
    [CompilerGeneratedAttribute]
private Guid <Version>k__BackingField;
    public static ProxyCache Instance { get; }
    public Guid Version { get; private set; }
    public ProxyCache(ISettings settings, IEnvironmentVariableReader environment);
    private static ProxyCache();
    private static ProxyCache FromDefaultSettings();
    public static ProxyCache get_Instance();
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(Guid value);
    public sealed virtual IWebProxy GetProxy(Uri sourceUri);
    private bool TryAddProxyCredentialsToCache(WebProxy configuredProxy);
    [NullableContextAttribute("2")]
public WebProxy GetUserConfiguredProxy();
    public sealed virtual void UpdateCredential(Uri proxyAddress, NetworkCredential credentials);
    public sealed virtual NetworkCredential GetCredential(Uri proxyAddress, string authType);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Retained for backcompat only. Use UpdateCredential instead")]
public sealed virtual void Add(IWebProxy proxy);
    private static WebProxy GetSystemProxy(Uri uri);
    private static bool IsSystemProxySet(Uri uri);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.RepositoryItem : TrustedSignerItem {
    [NullableAttribute("2")]
private OwnersItem _owners;
    [CompilerGeneratedAttribute]
private IList`1<string> <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    public string ElementName { get; }
    public string ServiceIndex { get; }
    public string Name { get; public set; }
    public IList`1<string> Owners { get; private set; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    public RepositoryItem(string name, string serviceIndex, CertificateItem[] certificates);
    public RepositoryItem(string name, string serviceIndex, string owners, CertificateItem[] certificates);
    internal RepositoryItem(XElement element, SettingsFile origin);
    internal RepositoryItem(XElement element, SettingsFile origin, IEnumerable`1<SettingBase> parsedDescendants);
    public virtual string get_ElementName();
    public string get_ServiceIndex();
    public string get_Name();
    public void set_Name(string value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Owners();
    [CompilerGeneratedAttribute]
private void set_Owners(IList`1<string> value);
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    public virtual SettingBase Clone();
    internal virtual XNode AsXNode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
    internal virtual void SetOrigin(SettingsFile origin);
    internal virtual void RemoveFromSettings();
    internal virtual void Update(SettingItem otherRepository);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Configuration.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Argument_Cannot_Be_Null_Empty_Or_WhiteSpaceOnly { get; }
    internal static string Argument_Cannot_Be_Null_Or_Empty { get; }
    internal static string AttributeNotAllowed { get; }
    internal static string AttributeValueNotAllowed { get; }
    internal static string CannotUpdateDifferentItems { get; }
    internal static string CannotUpdateMachineWide { get; }
    internal static string CannotUpdateNode { get; }
    internal static string CannotUpdateReadOnlyConfig { get; }
    internal static string ClientCertificateDuplicateConfiguration { get; }
    internal static string CredentialsItemMustHaveUsernamePassword { get; }
    internal static string Error_DuplicatePackageSource { get; }
    internal static string Error_EncryptionUnsupported { get; }
    internal static string Error_InvalidAttribute { get; }
    internal static string Error_ItemNeedsAtLeastOnePackagePattern { get; }
    internal static string Error_ItemNeedsAtLeastOnePackagePatternWithPath { get; }
    internal static string Error_MergeTwoDifferentSections { get; }
    internal static string Error_MoreThanOnePassword { get; }
    internal static string Error_MoreThanOneUsername { get; }
    internal static string Error_MoreThanOneValidAuthenticationTypes { get; }
    internal static string Error_StoreCertCertificateNotFound { get; }
    internal static string FileCertItemPasswordAndClearTextPasswordAtSameTime { get; }
    internal static string FileCertItemPasswordCannotBeDecrypted { get; }
    internal static string FileCertItemPathFileNotExist { get; }
    internal static string FileCertItemPathFileNotSet { get; }
    internal static string FileDoesNotExist { get; }
    internal static string InvalidNullSettingsOperation { get; }
    internal static string ItemDoesNotExist { get; }
    internal static string MissingRequiredAttribute { get; }
    internal static string MustContainAbsolutePath { get; }
    internal static string NoAttributesAllowed { get; }
    internal static string NoWritteableConfig { get; }
    internal static string OwnersItemMustHaveAtLeastOneOwner { get; }
    internal static string OwnersMustOnlyHaveContent { get; }
    internal static string PropertyCannotBeNullOrEmpty { get; }
    internal static string RepositoryMustHaveOneOwners { get; }
    internal static string SectionDoesNotExist { get; }
    internal static string Settings_FileName_Cannot_Be_A_Path { get; }
    internal static string ShowError_CannotHaveChildren { get; }
    internal static string ShowError_ConfigDuplicateDisabledSources { get; }
    internal static string ShowError_ConfigHasInvalidPackageSource { get; }
    internal static string ShowError_ConfigInvalidOperation { get; }
    internal static string ShowError_ConfigInvalidXml { get; }
    internal static string ShowError_ConfigRootInvalid { get; }
    internal static string ShowError_ConfigUnauthorizedAccess { get; }
    internal static string ShowError_UnknownOrigin { get; }
    internal static string TextShouldNotBeEmpty { get; }
    internal static string TrustedSignerMustHaveCertificates { get; }
    internal static string Unknown_Config_Exception { get; }
    internal static string UnknownHashAlgorithmNotSupported { get; }
    internal static string UnsupportedDecryptPassword { get; }
    internal static string UnsupportedEncryptPassword { get; }
    internal static string UnsupportedHashAlgorithm { get; }
    internal static string UserSettings_UnableToParseConfigFile { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Argument_Cannot_Be_Null_Empty_Or_WhiteSpaceOnly();
    internal static string get_Argument_Cannot_Be_Null_Or_Empty();
    internal static string get_AttributeNotAllowed();
    internal static string get_AttributeValueNotAllowed();
    internal static string get_CannotUpdateDifferentItems();
    internal static string get_CannotUpdateMachineWide();
    internal static string get_CannotUpdateNode();
    internal static string get_CannotUpdateReadOnlyConfig();
    internal static string get_ClientCertificateDuplicateConfiguration();
    internal static string get_CredentialsItemMustHaveUsernamePassword();
    internal static string get_Error_DuplicatePackageSource();
    internal static string get_Error_EncryptionUnsupported();
    internal static string get_Error_InvalidAttribute();
    internal static string get_Error_ItemNeedsAtLeastOnePackagePattern();
    internal static string get_Error_ItemNeedsAtLeastOnePackagePatternWithPath();
    internal static string get_Error_MergeTwoDifferentSections();
    internal static string get_Error_MoreThanOnePassword();
    internal static string get_Error_MoreThanOneUsername();
    internal static string get_Error_MoreThanOneValidAuthenticationTypes();
    internal static string get_Error_StoreCertCertificateNotFound();
    internal static string get_FileCertItemPasswordAndClearTextPasswordAtSameTime();
    internal static string get_FileCertItemPasswordCannotBeDecrypted();
    internal static string get_FileCertItemPathFileNotExist();
    internal static string get_FileCertItemPathFileNotSet();
    internal static string get_FileDoesNotExist();
    internal static string get_InvalidNullSettingsOperation();
    internal static string get_ItemDoesNotExist();
    internal static string get_MissingRequiredAttribute();
    internal static string get_MustContainAbsolutePath();
    internal static string get_NoAttributesAllowed();
    internal static string get_NoWritteableConfig();
    internal static string get_OwnersItemMustHaveAtLeastOneOwner();
    internal static string get_OwnersMustOnlyHaveContent();
    internal static string get_PropertyCannotBeNullOrEmpty();
    internal static string get_RepositoryMustHaveOneOwners();
    internal static string get_SectionDoesNotExist();
    internal static string get_Settings_FileName_Cannot_Be_A_Path();
    internal static string get_ShowError_CannotHaveChildren();
    internal static string get_ShowError_ConfigDuplicateDisabledSources();
    internal static string get_ShowError_ConfigHasInvalidPackageSource();
    internal static string get_ShowError_ConfigInvalidOperation();
    internal static string get_ShowError_ConfigInvalidXml();
    internal static string get_ShowError_ConfigRootInvalid();
    internal static string get_ShowError_ConfigUnauthorizedAccess();
    internal static string get_ShowError_UnknownOrigin();
    internal static string get_TextShouldNotBeEmpty();
    internal static string get_TrustedSignerMustHaveCertificates();
    internal static string get_Unknown_Config_Exception();
    internal static string get_UnknownHashAlgorithmNotSupported();
    internal static string get_UnsupportedDecryptPassword();
    internal static string get_UnsupportedEncryptPassword();
    internal static string get_UnsupportedHashAlgorithm();
    internal static string get_UserSettings_UnableToParseConfigFile();
}
internal class NuGet.Configuration.SearchNode : object {
    [NullableAttribute("1")]
public Dictionary`2<char, SearchNode> Children;
    [CompilerGeneratedAttribute]
private bool <IsGlobbing>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<string> PackageSources;
    public bool IsGlobbing { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsGlobbing();
    [CompilerGeneratedAttribute]
public void set_IsGlobbing(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.Configuration.SearchTree : object {
    private SearchNode _root;
    internal SearchTree(PackageSourceMapping configuration);
    private void Add(string packageSourceKey, string packagePattern);
    public string SearchForPattern(string term);
    public IReadOnlyList`1<string> GetConfiguredPackageSources(string term);
    private SearchNode SearchNodeByTerm(string term);
    private string SearchPatternByTerm(string term);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class NuGet.Configuration.SettingBase : object {
    [CompilerGeneratedAttribute]
private XNode <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private ISettingsGroup <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private SettingsFile <Origin>k__BackingField;
    internal XNode Node { get; private set; }
    internal ISettingsGroup Parent { get; internal set; }
    internal SettingsFile Origin { get; private set; }
    [NullableContextAttribute("1")]
internal SettingBase(XNode node, SettingsFile origin);
    [CompilerGeneratedAttribute]
internal XNode get_Node();
    [CompilerGeneratedAttribute]
private void set_Node(XNode value);
    [CompilerGeneratedAttribute]
internal ISettingsGroup get_Parent();
    [CompilerGeneratedAttribute]
internal void set_Parent(ISettingsGroup value);
    [CompilerGeneratedAttribute]
internal SettingsFile get_Origin();
    [CompilerGeneratedAttribute]
private void set_Origin(SettingsFile value);
    internal bool IsAbstract();
    internal bool IsCopy();
    public abstract virtual bool IsEmpty();
    internal virtual XNode AsXNode();
    [NullableContextAttribute("1")]
public abstract virtual SettingBase Clone();
    [NullableContextAttribute("1")]
internal void SetNode(XNode node);
    [NullableContextAttribute("1")]
internal virtual void SetOrigin(SettingsFile origin);
    internal virtual void RemoveFromSettings();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NuGet.Configuration.SettingElement : SettingBase {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <AllowedAttributes>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> <AllowedValues>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> <DisallowedValues>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <MutableAttributes>k__BackingField;
    public string ElementName { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected IReadOnlyCollection`1<string> AllowedAttributes { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> AllowedValues { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> DisallowedValues { get; }
    protected Dictionary`2<string, string> MutableAttributes { get; }
    internal IReadOnlyDictionary`2<string, string> Attributes { get; }
    [NullableAttribute("2")]
public string ConfigPath { get; }
    protected SettingElement(IReadOnlyDictionary`2<string, string> attributes);
    internal SettingElement(XElement element, SettingsFile origin);
    public abstract virtual string get_ElementName();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_AllowedAttributes();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> get_AllowedValues();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> get_DisallowedValues();
    [CompilerGeneratedAttribute]
protected Dictionary`2<string, string> get_MutableAttributes();
    internal IReadOnlyDictionary`2<string, string> get_Attributes();
    public virtual bool IsEmpty();
    [NullableContextAttribute("2")]
public string get_ConfigPath();
    internal virtual XNode AsXNode();
    protected void AddOrUpdateAttribute(string attributeName, string value);
    internal bool UpdateAttribute(string attributeName, string newValue);
    protected void AddAttribute(string attributeName, string value);
    private bool IsAttributeValid(string attributeName, string value);
    private void ValidateAttributes(XElement element, SettingsFile origin);
}
public enum NuGet.Configuration.SettingElementType : Enum {
    public int value__;
    public static SettingElementType Unknown;
    public static SettingElementType Configuration;
    public static SettingElementType ActivePackageSource;
    public static SettingElementType BindingRedirects;
    public static SettingElementType Config;
    public static SettingElementType PackageManagement;
    public static SettingElementType PackageRestore;
    public static SettingElementType PackageSourceCredentials;
    public static SettingElementType PackageSources;
    public static SettingElementType Add;
    public static SettingElementType Author;
    public static SettingElementType Certificate;
    public static SettingElementType Clear;
    public static SettingElementType Owners;
    public static SettingElementType Repository;
    public static SettingElementType FileCert;
    public static SettingElementType StoreCert;
    public static SettingElementType PackageSourceMapping;
    public static SettingElementType PackageSource;
    public static SettingElementType Package;
    public static SettingElementType AuditSources;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NuGet.Configuration.SettingFactory : object {
    internal static SettingBase Parse(XNode node, SettingsFile origin);
    internal static IEnumerable`1<T> ParseChildren(XElement xElement, SettingsFile origin, bool canBeCleared);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class NuGet.Configuration.SettingItem : SettingElement {
    [CompilerGeneratedAttribute]
private SettingItem <MergedWith>k__BackingField;
    protected bool CanHaveChildren { get; }
    internal SettingItem MergedWith { get; internal set; }
    protected SettingItem(IReadOnlyDictionary`2<string, string> attributes);
    [NullableContextAttribute("1")]
internal SettingItem(XElement element, SettingsFile origin);
    protected virtual bool get_CanHaveChildren();
    [CompilerGeneratedAttribute]
internal SettingItem get_MergedWith();
    [CompilerGeneratedAttribute]
internal void set_MergedWith(SettingItem value);
    [NullableContextAttribute("1")]
internal virtual void Update(SettingItem setting);
    [NullableContextAttribute("1")]
public IReadOnlyDictionary`2<string, string> GetAttributes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.Settings : object {
    public static string DefaultSettingsFileName;
    public static String[] OrderedSettingsFileNames;
    public static String[] SupportedMachineWideConfigExtension;
    private Dictionary`2<string, VirtualSettingSection> _computedSections;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler SettingsChanged;
    [CompilerGeneratedAttribute]
private IList`1<SettingsFile> <SettingsFiles>k__BackingField;
    private IList`1<SettingsFile> SettingsFiles { get; }
    internal IEnumerable`1<SettingsFile> Priority { get; }
    public Settings(string root);
    public Settings(string root, string fileName);
    public Settings(string root, string fileName, bool isMachineWide);
    internal Settings(IList`1<SettingsFile> settingsFiles);
    private static Settings();
    public sealed virtual SettingSection GetSection(string sectionName);
    public IEnumerable`1<string> GetAllSettingSections();
    public sealed virtual void AddOrUpdate(string sectionName, SettingItem item);
    internal void AddOrUpdate(SettingsFile settingsFile, string sectionName, SettingItem item);
    public sealed virtual void Remove(string sectionName, SettingItem item);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_SettingsChanged(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_SettingsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
private IList`1<SettingsFile> get_SettingsFiles();
    private SettingsFile GetOutputSettingFileForSection(string sectionName);
    internal IEnumerable`1<SettingsFile> get_Priority();
    public sealed virtual void SaveToDisk();
    public static ISettings LoadDefaultSettings(string root);
    [NullableContextAttribute("2")]
public static ISettings LoadDefaultSettings(string root, string configFileName, IMachineWideSettings machineWideSettings);
    [NullableContextAttribute("2")]
public static ISettings LoadDefaultSettings(string root, string configFileName, IMachineWideSettings machineWideSettings, SettingsLoadingContext settingsLoadingContext);
    public static ISettings LoadSpecificSettings(string root, string configFileName);
    public static ISettings LoadImmutableSettingsGivenConfigPaths(IList`1<string> configFilePaths, SettingsLoadingContext settingsLoadingContext);
    public static ISettings LoadSettingsGivenConfigPaths(IList`1<string> configFilePaths);
    private static ISettings LoadSettingsGivenSettingsFiles(List`1<SettingsFile> settings);
    [NullableContextAttribute("2")]
internal static ISettings LoadSettings(string root, string configFileName, IMachineWideSettings machineWideSettings, bool loadUserWideSettings, bool useTestingGlobalPath, SettingsLoadingContext settingsLoadingContext);
    internal static ISettings LoadSettings(DirectoryInfo root, IMachineWideSettings machineWideSettings, bool loadUserWideSettings, bool useTestingGlobalPath, SettingsLoadingContext settingsLoadingContext);
    [NullableContextAttribute("2")]
private static ISettings LoadSettingsForSpecificConfigs(string root, string configFileName, List`1<SettingsFile> validSettingFiles, IMachineWideSettings machineWideSettings, bool loadUserWideSettings, bool useTestingGlobalPath, SettingsLoadingContext settingsLoadingContext);
    [NullableContextAttribute("2")]
[IteratorStateMachineAttribute("NuGet.Configuration.Settings/<LoadUserSpecificSettings>d__33")]
internal static IEnumerable`1<SettingsFile> LoadUserSpecificSettings(string root, string configFileName, bool useTestingGlobalPath, SettingsLoadingContext settingsLoadingContext);
    private static string GetUserSettingsDirectory(string rootDirectory, bool useTestingGlobalPath);
    private static string GetAdditionalUserWideConfigurationDirectory(string userSettingsDirectory);
    public static ISettings LoadMachineWideSettings(string root, String[] paths);
    public static string ApplyEnvironmentTransform(string value);
    public static Tuple`2<string, string> GetFileNameAndItsRoot(string root, string settingsPath);
    public sealed virtual IList`1<string> GetConfigFilePaths();
    public sealed virtual IList`1<string> GetConfigRoots();
    internal static string ResolvePathFromOrigin(string originDirectoryPath, string originFilePath, string path);
    private static string ResolveRelativePath(string originDirectoryPath, string originFilePath, string path);
    private static string ResolvePath(string configDirectory, string value);
    private static SettingsFile ReadSettings(string settingsRoot, string settingsPath, bool isMachineWideSettings, bool isAdditionalUserWideConfig, SettingsLoadingContext settingsLoadingContext);
    [IteratorStateMachineAttribute("NuGet.Configuration.Settings/<GetSettingsFilesFullPath>d__45")]
private static IEnumerable`1<string> GetSettingsFilesFullPath(string root);
    private static string GetSettingsFileNameFromDir(string directory);
    [IteratorStateMachineAttribute("NuGet.Configuration.Settings/<GetSettingsFilePaths>d__47")]
private static IEnumerable`1<string> GetSettingsFilePaths(string root);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class NuGet.Configuration.SettingSection : SettingsGroup`1<SettingItem> {
    public IReadOnlyCollection`1<SettingItem> Items { get; }
    protected SettingSection(string name, IReadOnlyDictionary`2<string, string> attributes, IEnumerable`1<SettingItem> children);
    internal SettingSection(string name, XElement element, SettingsFile origin);
    public IReadOnlyCollection`1<SettingItem> get_Items();
    public T GetFirstItemWithAttribute(string attributeName, string expectedAttributeValue);
    internal bool Update(SettingItem item);
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.Configuration.SettingsFile : object {
    [CompilerGeneratedAttribute]
private string <ConfigFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DirectoryPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDirty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMachineWide>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    private XDocument _xDocument;
    private NuGetConfiguration _rootElement;
    internal string ConfigFilePath { get; }
    internal string DirectoryPath { get; }
    internal string FileName { get; }
    internal bool IsDirty { get; internal set; }
    internal bool IsMachineWide { get; }
    internal bool IsReadOnly { get; }
    public SettingsFile(string directoryPath);
    public SettingsFile(string directoryPath, string fileName);
    public SettingsFile(string directoryPath, string fileName, bool isMachineWide, bool isReadOnly);
    [CompilerGeneratedAttribute]
internal string get_ConfigFilePath();
    [CompilerGeneratedAttribute]
internal string get_DirectoryPath();
    [CompilerGeneratedAttribute]
internal string get_FileName();
    [CompilerGeneratedAttribute]
internal bool get_IsDirty();
    [CompilerGeneratedAttribute]
internal void set_IsDirty(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsMachineWide();
    [CompilerGeneratedAttribute]
internal bool get_IsReadOnly();
    public SettingSection GetSection(string sectionName);
    internal void AddOrUpdate(string sectionName, SettingItem item);
    internal void Remove(string sectionName, SettingItem item);
    internal void SaveToDisk();
    internal bool IsEmpty();
    internal bool TryGetSection(string sectionName, SettingSection& section);
    internal void MergeSectionsInto(Dictionary`2<string, VirtualSettingSection> sectionsContainer);
    private XDocument CreateDefaultConfig();
    private T ExecuteSynchronized(Func`1<T> ioOperation);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private XDocument <.ctor>b__23_0();
    [CompilerGeneratedAttribute]
private int <SaveToDisk>b__27_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NuGet.Configuration.SettingsGroup`1 : SettingElement {
    [CompilerGeneratedAttribute]
private IList`1<T> <Children>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ElementName>k__BackingField;
    protected IList`1<T> Children { get; private set; }
    protected bool CanBeCleared { get; }
    public string ElementName { get; }
    protected SettingsGroup`1(string name);
    protected SettingsGroup`1(string name, IReadOnlyDictionary`2<string, string> attributes, IEnumerable`1<T> children);
    internal SettingsGroup`1(string name, XElement element, SettingsFile origin);
    [CompilerGeneratedAttribute]
protected IList`1<T> get_Children();
    [CompilerGeneratedAttribute]
private void set_Children(IList`1<T> value);
    protected virtual bool get_CanBeCleared();
    [CompilerGeneratedAttribute]
public virtual string get_ElementName();
    public virtual bool IsEmpty();
    internal virtual XNode AsXNode();
    internal virtual void SetOrigin(SettingsFile origin);
    internal virtual void RemoveFromSettings();
    internal virtual bool Add(T setting);
    internal virtual void Remove(T setting);
    protected bool TryGetChild(T expectedChild, T& currentChild);
    private sealed virtual override void NuGet.Configuration.ISettingsGroup.Remove(SettingElement setting);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.SettingsLoadingContext : object {
    private ConcurrentDictionary`2<string, Lazy`1<SettingsFile>> _cache;
    private bool _isDisposed;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<string> FileRead;
    [CompilerGeneratedAttribute]
internal void add_FileRead(EventHandler`1<string> value);
    [CompilerGeneratedAttribute]
internal void remove_FileRead(EventHandler`1<string> value);
    public sealed virtual void Dispose();
    internal SettingsFile GetOrCreateSettingsFile(string filePath, bool isMachineWide, bool isReadOnly);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Configuration.SettingsUtility : object {
    private static string GlobalPackagesFolderEnvironmentKey;
    private static string FallbackPackagesFolderEnvironmentKey;
    private static string HttpCacheEnvironmentKey;
    private static string PluginsCacheEnvironmentKey;
    public static string DefaultGlobalPackagesFolderPath;
    private static string RevocationModeEnvironmentKey;
    private static SettingsUtility();
    public static string GetValueForAddItem(ISettings settings, string section, string key, bool isPath);
    public static bool DeleteValue(ISettings settings, string section, string attributeKey, string attributeValue);
    public static string GetRepositoryPath(ISettings settings);
    public static int GetMaxHttpRequest(ISettings settings);
    public static SignatureValidationMode GetSignatureValidationMode(ISettings settings);
    public static bool GetUpdatePackageLastAccessTimeEnabledStatus(ISettings settings);
    public static string GetDecryptedValueForAddItem(ISettings settings, string section, string key, bool isPath);
    public static void SetEncryptedValueForAddItem(ISettings settings, string section, string key, string value);
    public static string GetConfigValue(ISettings settings, string key, bool decrypt, bool isPath);
    public static void SetConfigValue(ISettings settings, string key, string value, bool encrypt);
    public static bool DeleteConfigValue(ISettings settings, string key);
    public static string GetGlobalPackagesFolder(ISettings settings);
    public static IReadOnlyList`1<string> GetFallbackPackageFolders(ISettings settings);
    private static IReadOnlyList`1<string> GetFallbackPackageFoldersFromConfig(ISettings settings);
    public static string GetHttpCacheFolder();
    public static string GetPluginsCacheFolder();
    public static IEnumerable`1<PackageSource> GetEnabledSources(ISettings settings);
    public static string GetDefaultPushSource(ISettings settings);
    [NullableContextAttribute("2")]
public static RevocationMode GetRevocationMode(IEnvironmentVariableReader environmentVariableReader);
    private static void VerifyPathIsRooted(string key, string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.SettingText : SettingBase {
    private string _value;
    public string Value { get; public set; }
    public SettingText(string value);
    internal SettingText(XText text, SettingsFile origin);
    public string get_Value();
    public void set_Value(string value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual bool IsEmpty();
    public virtual SettingBase Clone();
    internal virtual XNode AsXNode();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NuGet.Configuration.SourceItem : AddItem {
    public string ProtocolVersion { get; public set; }
    public string AllowInsecureConnections { get; public set; }
    public string DisableTLSCertificateValidation { get; public set; }
    [NullableContextAttribute("1")]
public SourceItem(string key, string value);
    [NullableContextAttribute("1")]
public SourceItem(string key, string value, string protocolVersion);
    [NullableContextAttribute("1")]
public SourceItem(string key, string value, string protocolVersion, string allowInsecureConnections);
    public SourceItem(string key, string value, string protocolVersion, string allowInsecureConnections, string disableTLSCertificateValidation);
    [NullableContextAttribute("1")]
internal SourceItem(XElement element, SettingsFile origin);
    public string get_ProtocolVersion();
    public void set_ProtocolVersion(string value);
    public string get_AllowInsecureConnections();
    public void set_AllowInsecureConnections(string value);
    public string get_DisableTLSCertificateValidation();
    public void set_DisableTLSCertificateValidation(string value);
    [NullableContextAttribute("1")]
public virtual SettingBase Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.StoreClientCertItem : ClientCertItem {
    private static X509FindType DefaultFindBy;
    private static StoreLocation DefaultStoreLocation;
    private static StoreName DefaultStoreName;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <AllowedAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> <AllowedValues>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    public string ElementName { get; }
    public X509FindType FindType { get; }
    public string FindValue { get; }
    public StoreLocation StoreLocation { get; }
    public StoreName StoreName { get; }
    protected IReadOnlyCollection`1<string> AllowedAttributes { get; }
    protected IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> AllowedValues { get; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    public StoreClientCertItem(string packageSource, string findValue, Nullable`1<StoreLocation> storeLocation, Nullable`1<StoreName> storeName, Nullable`1<X509FindType> findBy);
    internal StoreClientCertItem(XElement element, SettingsFile origin);
    public static string GetString(X509FindType type);
    public static string GetString(StoreName storeName);
    public static string GetString(StoreLocation storeLocation);
    public virtual string get_ElementName();
    public X509FindType get_FindType();
    public string get_FindValue();
    public StoreLocation get_StoreLocation();
    public StoreName get_StoreName();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_AllowedAttributes();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> get_AllowedValues();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    internal virtual XNode AsXNode();
    public virtual SettingBase Clone();
    public virtual IEnumerable`1<X509Certificate> Search();
    [NullableContextAttribute("2")]
public void Update(string findValue, Nullable`1<StoreLocation> storeLocation, Nullable`1<StoreName> storeName, Nullable`1<X509FindType> findBy);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NuGet.Configuration.TrustedSignerItem : SettingItem {
    [CompilerGeneratedAttribute]
private IList`1<CertificateItem> <Certificates>k__BackingField;
    protected bool CanHaveChildren { get; }
    public IList`1<CertificateItem> Certificates { get; }
    public string Name { get; }
    protected TrustedSignerItem(string name, IEnumerable`1<CertificateItem> certificates);
    internal TrustedSignerItem(XElement element, SettingsFile origin);
    internal TrustedSignerItem(XElement element, SettingsFile origin, IEnumerable`1<SettingBase> parsedDescendants);
    protected virtual bool get_CanHaveChildren();
    [CompilerGeneratedAttribute]
public IList`1<CertificateItem> get_Certificates();
    public virtual string get_Name();
    protected void SetName(string value);
    internal static IEnumerable`1<SettingBase> ParseDescendants(XElement element, SettingsFile origin);
    internal virtual void SetOrigin(SettingsFile origin);
    internal virtual void RemoveFromSettings();
    internal virtual void Update(SettingItem other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.UnknownItem : SettingItem {
    [CompilerGeneratedAttribute]
private string <ElementName>k__BackingField;
    private Dictionary`2<SettingBase, SettingBase> _mutableChildren;
    public string ElementName { get; }
    public IReadOnlyList`1<SettingBase> Children { get; }
    protected bool CanHaveChildren { get; }
    internal UnknownItem(XElement element, SettingsFile origin);
    public UnknownItem(string name, IReadOnlyDictionary`2<string, string> attributes, IEnumerable`1<SettingBase> children);
    [CompilerGeneratedAttribute]
public virtual string get_ElementName();
    public IReadOnlyList`1<SettingBase> get_Children();
    public virtual bool IsEmpty();
    protected virtual bool get_CanHaveChildren();
    public virtual SettingBase Clone();
    internal bool Add(SettingBase setting);
    private sealed virtual override void NuGet.Configuration.ISettingsGroup.Remove(SettingElement setting);
    internal void Remove(SettingBase setting);
    internal virtual XNode AsXNode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
    internal virtual void Update(SettingItem setting);
    internal void Merge(UnknownItem item);
    internal virtual void SetOrigin(SettingsFile origin);
    internal virtual void RemoveFromSettings();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.VirtualSettingSection : SettingSection {
    internal VirtualSettingSection(SettingSection section);
    internal VirtualSettingSection(string name, SettingItem[] children);
    internal VirtualSettingSection(string name, IReadOnlyDictionary`2<string, string> attributes, IEnumerable`1<SettingItem> children);
    internal VirtualSettingSection Merge(SettingSection other);
    internal virtual bool Add(SettingItem setting);
    internal virtual void Remove(SettingItem setting);
    private bool TryRemoveAllMergedWith(SettingItem currentSetting, SettingItem& undeletedItem);
    public virtual SettingBase Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.WebProxy : object {
    private IReadOnlyList`1<string> _bypassList;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Regex[] _regExBypassList;
    [CompilerGeneratedAttribute]
private Uri <ProxyAddress>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ICredentials <Credentials>k__BackingField;
    public Uri ProxyAddress { get; private set; }
    [NullableAttribute("2")]
public ICredentials Credentials { get; public set; }
    public IReadOnlyList`1<string> BypassList { get; public set; }
    public WebProxy(string proxyAddress);
    public WebProxy(Uri proxyAddress);
    [CompilerGeneratedAttribute]
public Uri get_ProxyAddress();
    [CompilerGeneratedAttribute]
private void set_ProxyAddress(Uri value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual ICredentials get_Credentials();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_Credentials(ICredentials value);
    public IReadOnlyList`1<string> get_BypassList();
    public void set_BypassList(IReadOnlyList`1<string> value);
    public sealed virtual Uri GetProxy(Uri destination);
    public sealed virtual bool IsBypassed(Uri uri);
    private void UpdateRegExList();
    private static string WildcardToRegex(string pattern);
    private static Uri CreateProxyUri(string address);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NuGet.Configuration.XElementUtility : object {
    internal static string GetOptionalAttributeValue(XElement element, string localName);
    internal static string GetOptionalAttributeValue(XElement element, string localName, string namespaceName);
    [NullableContextAttribute("2")]
internal static void AddIndented(XContainer container, XNode content);
    [NullableContextAttribute("2")]
internal static void RemoveIndented(XNode element);
    private static string ComputeOneLevelOfIndentation(XNode node);
    private static bool IsWhiteSpace(XText textNode);
    private static void IndentChildrenElements(XContainer container, string containerIndent, string oneIndentLevel);
    private static void AddLeadingIndentation(XContainer container, string containerIndent, string oneIndentLevel);
    private static void AddTrailingIndentation(XContainer container, string containerIndent);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Configuration.XPlatMachineWideSetting : object {
    private Lazy`1<ISettings> _settings;
    public ISettings Settings { get; }
    public sealed virtual ISettings get_Settings();
}
public class NuGet.ContentModel.Asset : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Link>k__BackingField;
    public string Path { get; public set; }
    public string Link { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_Link();
    [CompilerGeneratedAttribute]
public void set_Link(string value);
    public virtual string ToString();
}
public class NuGet.ContentModel.ContentItem : object {
    private Dictionary`2<string, object> _properties;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public string Path { get; public set; }
    public Dictionary`2<string, object> Properties { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    public Dictionary`2<string, object> get_Properties();
    internal void set_Properties(Dictionary`2<string, object> value);
    public virtual string ToString();
    private Dictionary`2<string, object> CreateDictionary();
}
public class NuGet.ContentModel.ContentItemCollection : object {
    private List`1<Asset> _assets;
    private ConcurrentDictionary`2<string, string> _assemblyRelatedExtensions;
    [CompilerGeneratedAttribute]
private bool <HasContract>k__BackingField;
    public bool HasContract { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_HasContract();
    [CompilerGeneratedAttribute]
private void set_HasContract(bool value);
    public void Load(IEnumerable`1<string> paths);
    public IEnumerable`1<ContentItem> FindItems(PatternSet definition);
    [IteratorStateMachineAttribute("NuGet.ContentModel.ContentItemCollection/<FindItemGroups>d__8")]
[ObsoleteAttribute("This method causes excessive memory allocation with yield return. Use ContentItemCollection.PopulateItemGroups instead.")]
public IEnumerable`1<ContentItemGroup> FindItemGroups(PatternSet definition);
    public void PopulateItemGroups(PatternSet definition, IList`1<ContentItemGroup> contentItemGroupList);
    public bool HasItemGroup(SelectionCriteria criteria, PatternSet[] definitions);
    public ContentItemGroup FindBestItemGroup(SelectionCriteria criteria, PatternSet[] definitions);
    private List`1<ContentItem> FindItemsImplementation(PatternSet definition, IEnumerable`1<Asset> assets);
    internal string GetRelatedFileExtensionProperty(string assemblyPath, IEnumerable`1<Asset> assets);
    private static bool IsValidAsset(string path);
}
[DebuggerDisplayAttribute("Items: {Items.Count}, Properties: {Properties.Count}")]
public class NuGet.ContentModel.ContentItemGroup : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ContentItem> <Items>k__BackingField;
    public IDictionary`2<string, object> Properties { get; }
    public IList`1<ContentItem> Items { get; }
    internal ContentItemGroup(IDictionary`2<string, object> properties, IList`1<ContentItem> items);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Properties();
    [CompilerGeneratedAttribute]
public IList`1<ContentItem> get_Items();
}
public class NuGet.ContentModel.ContentPropertyDefinition : object {
    private static Func`3<object, object, bool> EqualsTest;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <FileExtensions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FileExtensionAllowSubFolders>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<string, PatternTable, object> <Parser>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<object, object, bool> <CompatibilityTest>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`4<object, object, object, int> <CompareTest>k__BackingField;
    public string Name { get; }
    public List`1<string> FileExtensions { get; }
    public bool FileExtensionAllowSubFolders { get; }
    public Func`3<string, PatternTable, object> Parser { get; }
    public Func`3<object, object, bool> CompatibilityTest { get; }
    public Func`4<object, object, object, int> CompareTest { get; }
    public ContentPropertyDefinition(string name);
    public ContentPropertyDefinition(string name, Func`3<string, PatternTable, object> parser);
    public ContentPropertyDefinition(string name, Func`3<object, object, bool> compatibilityTest);
    public ContentPropertyDefinition(string name, Func`3<string, PatternTable, object> parser, Func`3<object, object, bool> compatibilityTest);
    public ContentPropertyDefinition(string name, Func`3<string, PatternTable, object> parser, Func`3<object, object, bool> compatibilityTest, Func`4<object, object, object, int> compareTest);
    public ContentPropertyDefinition(string name, IEnumerable`1<string> fileExtensions);
    public ContentPropertyDefinition(string name, Func`3<string, PatternTable, object> parser, IEnumerable`1<string> fileExtensions);
    public ContentPropertyDefinition(string name, IEnumerable`1<string> fileExtensions, bool allowSubfolders);
    public ContentPropertyDefinition(string name, Func`3<string, PatternTable, object> parser, IEnumerable`1<string> fileExtensions, bool allowSubfolders);
    public ContentPropertyDefinition(string name, Func`3<string, PatternTable, object> parser, Func`3<object, object, bool> compatibilityTest, Func`4<object, object, object, int> compareTest, IEnumerable`1<string> fileExtensions, bool allowSubfolders);
    private static ContentPropertyDefinition();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public List`1<string> get_FileExtensions();
    [CompilerGeneratedAttribute]
public bool get_FileExtensionAllowSubFolders();
    [CompilerGeneratedAttribute]
public Func`3<string, PatternTable, object> get_Parser();
    public virtual bool TryLookup(string name, PatternTable table, Object& value);
    private static bool ContainsSlash(string name);
    [CompilerGeneratedAttribute]
public Func`3<object, object, bool> get_CompatibilityTest();
    [CompilerGeneratedAttribute]
public Func`4<object, object, object, int> get_CompareTest();
    public virtual bool IsCriteriaSatisfied(object critieriaValue, object candidateValue);
    public virtual int Compare(object criteriaValue, object candidateValue1, object candidateValue2);
}
public class NuGet.ContentModel.Infrastructure.PatternExpression : object {
    private List`1<Segment> _segments;
    private Dictionary`2<string, object> _defaults;
    private PatternTable _table;
    public PatternExpression(PatternDefinition pattern);
    private void Initialize(string pattern);
    internal ContentItem Match(string path, IReadOnlyDictionary`2<string, ContentPropertyDefinition> propertyDefinitions);
}
public class NuGet.ContentModel.PatternDefinition : object {
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Defaults>k__BackingField;
    [CompilerGeneratedAttribute]
private PatternTable <Table>k__BackingField;
    public string Pattern { get; }
    public IReadOnlyDictionary`2<string, object> Defaults { get; }
    public PatternTable Table { get; }
    public PatternDefinition(string pattern);
    public PatternDefinition(string pattern, PatternTable table);
    public PatternDefinition(string pattern, PatternTable table, IEnumerable`1<KeyValuePair`2<string, object>> defaults);
    [CompilerGeneratedAttribute]
public string get_Pattern();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Defaults();
    [CompilerGeneratedAttribute]
public PatternTable get_Table();
    public static PatternDefinition op_Implicit(string pattern);
}
public class NuGet.ContentModel.PatternSet : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<PatternDefinition> <GroupPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private PatternExpression[] <GroupExpressions>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PatternDefinition> <PathPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private PatternExpression[] <PathExpressions>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, ContentPropertyDefinition> <PropertyDefinitions>k__BackingField;
    public IEnumerable`1<PatternDefinition> GroupPatterns { get; }
    internal PatternExpression[] GroupExpressions { get; }
    public IEnumerable`1<PatternDefinition> PathPatterns { get; }
    internal PatternExpression[] PathExpressions { get; }
    public IReadOnlyDictionary`2<string, ContentPropertyDefinition> PropertyDefinitions { get; public set; }
    public PatternSet(IReadOnlyDictionary`2<string, ContentPropertyDefinition> properties, IEnumerable`1<PatternDefinition> groupPatterns, IEnumerable`1<PatternDefinition> pathPatterns);
    [CompilerGeneratedAttribute]
public IEnumerable`1<PatternDefinition> get_GroupPatterns();
    [CompilerGeneratedAttribute]
internal PatternExpression[] get_GroupExpressions();
    [CompilerGeneratedAttribute]
public IEnumerable`1<PatternDefinition> get_PathPatterns();
    [CompilerGeneratedAttribute]
internal PatternExpression[] get_PathExpressions();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, ContentPropertyDefinition> get_PropertyDefinitions();
    [CompilerGeneratedAttribute]
public void set_PropertyDefinitions(IReadOnlyDictionary`2<string, ContentPropertyDefinition> value);
}
public class NuGet.ContentModel.PatternTable : object {
    private Dictionary`2<string, Dictionary`2<string, object>> _table;
    public PatternTable(IEnumerable`1<PatternTableEntry> entries);
    public bool TryLookup(string propertyName, string name, Object& value);
}
public class NuGet.ContentModel.PatternTableEntry : object {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public string PropertyName { get; }
    public string Name { get; }
    public object Value { get; }
    public PatternTableEntry(string propertyName, string name, object value);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public object get_Value();
}
public class NuGet.ContentModel.SelectionCriteria : object {
    [CompilerGeneratedAttribute]
private IList`1<SelectionCriteriaEntry> <Entries>k__BackingField;
    public IList`1<SelectionCriteriaEntry> Entries { get; public set; }
    [CompilerGeneratedAttribute]
public IList`1<SelectionCriteriaEntry> get_Entries();
    [CompilerGeneratedAttribute]
public void set_Entries(IList`1<SelectionCriteriaEntry> value);
}
public class NuGet.ContentModel.SelectionCriteriaBuilder : object {
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, ContentPropertyDefinition> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private SelectionCriteria <Criteria>k__BackingField;
    public IReadOnlyDictionary`2<string, ContentPropertyDefinition> Properties { get; }
    public SelectionCriteria Criteria { get; }
    public SelectionCriteriaEntryBuilder Add { get; }
    public SelectionCriteriaBuilder(IReadOnlyDictionary`2<string, ContentPropertyDefinition> properties);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, ContentPropertyDefinition> get_Properties();
    [CompilerGeneratedAttribute]
public virtual SelectionCriteria get_Criteria();
    public virtual SelectionCriteriaEntryBuilder get_Add();
}
public class NuGet.ContentModel.SelectionCriteriaEntry : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Properties>k__BackingField;
    public IDictionary`2<string, object> Properties { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, object> value);
}
[DefaultMemberAttribute("Item")]
public class NuGet.ContentModel.SelectionCriteriaEntryBuilder : SelectionCriteriaBuilder {
    [CompilerGeneratedAttribute]
private SelectionCriteriaEntry <Entry>k__BackingField;
    [CompilerGeneratedAttribute]
private SelectionCriteriaBuilder <Builder>k__BackingField;
    public SelectionCriteriaEntry Entry { get; }
    public SelectionCriteriaBuilder Builder { get; }
    public SelectionCriteriaEntryBuilder Item { get; }
    public SelectionCriteriaEntryBuilder Item { get; }
    public SelectionCriteriaEntryBuilder Add { get; }
    public SelectionCriteria Criteria { get; }
    internal SelectionCriteriaEntryBuilder(SelectionCriteriaBuilder builder, SelectionCriteriaEntry entry);
    [CompilerGeneratedAttribute]
public SelectionCriteriaEntry get_Entry();
    [CompilerGeneratedAttribute]
public SelectionCriteriaBuilder get_Builder();
    public SelectionCriteriaEntryBuilder get_Item(string key, string value);
    public SelectionCriteriaEntryBuilder get_Item(string key, object value);
    public virtual SelectionCriteriaEntryBuilder get_Add();
    public virtual SelectionCriteria get_Criteria();
}
public class NuGet.DependencyResolver.AnalyzeResult`1 : object {
    [CompilerGeneratedAttribute]
private List`1<DowngradeResult`1<TItem>> <Downgrades>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<VersionConflictResult`1<TItem>> <VersionConflicts>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<GraphNode`1<TItem>> <Cycles>k__BackingField;
    public List`1<DowngradeResult`1<TItem>> Downgrades { get; }
    public List`1<VersionConflictResult`1<TItem>> VersionConflicts { get; }
    public List`1<GraphNode`1<TItem>> Cycles { get; }
    [CompilerGeneratedAttribute]
public List`1<DowngradeResult`1<TItem>> get_Downgrades();
    [CompilerGeneratedAttribute]
public List`1<VersionConflictResult`1<TItem>> get_VersionConflicts();
    [CompilerGeneratedAttribute]
public List`1<GraphNode`1<TItem>> get_Cycles();
    public void Combine(AnalyzeResult`1<TItem> result);
}
public enum NuGet.DependencyResolver.Disposition : Enum {
    public int value__;
    public static Disposition Acceptable;
    public static Disposition Rejected;
    public static Disposition Accepted;
    public static Disposition PotentiallyDowngraded;
    public static Disposition Cycle;
}
public class NuGet.DependencyResolver.DowngradeResult`1 : object {
    [CompilerGeneratedAttribute]
private GraphNode`1<TItem> <DowngradedFrom>k__BackingField;
    [CompilerGeneratedAttribute]
private GraphNode`1<TItem> <DowngradedTo>k__BackingField;
    public GraphNode`1<TItem> DowngradedFrom { get; public set; }
    public GraphNode`1<TItem> DowngradedTo { get; public set; }
    [CompilerGeneratedAttribute]
public GraphNode`1<TItem> get_DowngradedFrom();
    [CompilerGeneratedAttribute]
public void set_DowngradedFrom(GraphNode`1<TItem> value);
    [CompilerGeneratedAttribute]
public GraphNode`1<TItem> get_DowngradedTo();
    [CompilerGeneratedAttribute]
public void set_DowngradedTo(GraphNode`1<TItem> value);
}
public class NuGet.DependencyResolver.GraphEdge`1 : object {
    [CompilerGeneratedAttribute]
private GraphEdge`1<TItem> <OuterEdge>k__BackingField;
    [CompilerGeneratedAttribute]
private GraphItem`1<TItem> <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryDependency <Edge>k__BackingField;
    public GraphEdge`1<TItem> OuterEdge { get; }
    public GraphItem`1<TItem> Item { get; }
    public LibraryDependency Edge { get; }
    public GraphEdge`1(GraphEdge`1<TItem> outerEdge, GraphItem`1<TItem> item, LibraryDependency edge);
    [CompilerGeneratedAttribute]
public GraphEdge`1<TItem> get_OuterEdge();
    [CompilerGeneratedAttribute]
public GraphItem`1<TItem> get_Item();
    [CompilerGeneratedAttribute]
public LibraryDependency get_Edge();
}
[DebuggerDisplayAttribute("{Key}")]
public class NuGet.DependencyResolver.GraphItem`1 : object {
    [CompilerGeneratedAttribute]
private LibraryIdentity <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private TItem <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCentralTransitive>k__BackingField;
    public LibraryIdentity Key { get; public set; }
    public TItem Data { get; public set; }
    public bool IsCentralTransitive { get; public set; }
    public GraphItem`1(LibraryIdentity key);
    [CompilerGeneratedAttribute]
public LibraryIdentity get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(LibraryIdentity value);
    [CompilerGeneratedAttribute]
public TItem get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(TItem value);
    [CompilerGeneratedAttribute]
public bool get_IsCentralTransitive();
    [CompilerGeneratedAttribute]
public void set_IsCentralTransitive(bool value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(GraphItem`1<TItem> other);
    public virtual int GetHashCode();
    private bool KeyCompare(GraphItem`1<TItem> other);
}
public class NuGet.DependencyResolver.GraphItemKeyComparer`1 : object {
    private static Lazy`1<GraphItemKeyComparer`1<T>> DefaultComparer;
    public static GraphItemKeyComparer`1<T> Instance { get; }
    private static GraphItemKeyComparer`1();
    public static GraphItemKeyComparer`1<T> get_Instance();
    public sealed virtual bool Equals(GraphItem`1<T> x, GraphItem`1<T> y);
    public sealed virtual int GetHashCode(GraphItem`1<T> obj);
}
public class NuGet.DependencyResolver.GraphNode`1 : object {
    internal static IList`1<GraphNode`1<TItem>> EmptyList;
    [CompilerGeneratedAttribute]
private LibraryRange <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private GraphItem`1<TItem> <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private GraphNode`1<TItem> <OuterNode>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<GraphNode`1<TItem>> <InnerNodes>k__BackingField;
    [CompilerGeneratedAttribute]
private Disposition <Disposition>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<GraphNode`1<TItem>> <ParentNodes>k__BackingField;
    public LibraryRange Key { get; public set; }
    public GraphItem`1<TItem> Item { get; public set; }
    public GraphNode`1<TItem> OuterNode { get; public set; }
    public IList`1<GraphNode`1<TItem>> InnerNodes { get; public set; }
    public Disposition Disposition { get; public set; }
    public IList`1<GraphNode`1<TItem>> ParentNodes { get; }
    public GraphNode`1(LibraryRange key);
    internal GraphNode`1(LibraryRange key, bool hasInnerNodes, bool hasParentNodes);
    private static GraphNode`1();
    [CompilerGeneratedAttribute]
public LibraryRange get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(LibraryRange value);
    [CompilerGeneratedAttribute]
public GraphItem`1<TItem> get_Item();
    [CompilerGeneratedAttribute]
public void set_Item(GraphItem`1<TItem> value);
    [CompilerGeneratedAttribute]
public GraphNode`1<TItem> get_OuterNode();
    [CompilerGeneratedAttribute]
public void set_OuterNode(GraphNode`1<TItem> value);
    [CompilerGeneratedAttribute]
public IList`1<GraphNode`1<TItem>> get_InnerNodes();
    [CompilerGeneratedAttribute]
public void set_InnerNodes(IList`1<GraphNode`1<TItem>> value);
    [CompilerGeneratedAttribute]
public Disposition get_Disposition();
    [CompilerGeneratedAttribute]
public void set_Disposition(Disposition value);
    [CompilerGeneratedAttribute]
public IList`1<GraphNode`1<TItem>> get_ParentNodes();
    internal bool AreAllParentsRejected();
    internal void EnsureInnerNodeCapacity(int additionalSpace);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class NuGet.DependencyResolver.GraphOperations : object {
    private static string NodeArrow;
    [ThreadStaticAttribute]
private static Dictionary`2<GraphNode`1<RemoteResolveResult>, GraphNode`1<RemoteResolveResult>> _tempDowngrades;
    private static char LIGHT_HORIZONTAL;
    private static char LIGHT_VERTICAL_AND_RIGHT;
    [ExtensionAttribute]
public static AnalyzeResult`1<RemoteResolveResult> Analyze(GraphNode`1<RemoteResolveResult> root);
    private static bool IsRelevantDowngrade(DowngradeResult`1<RemoteResolveResult> d);
    [ExtensionAttribute]
private static void CheckCycleAndNearestWins(GraphNode`1<RemoteResolveResult> root, List`1<DowngradeResult`1<RemoteResolveResult>> downgrades, List`1<GraphNode`1<RemoteResolveResult>> cycles);
    private static void WalkTreeCheckCycleAndNearestWins(CyclesAndDowngrades context, GraphNode`1<RemoteResolveResult> node);
    [ExtensionAttribute]
public static string GetPath(GraphNode`1<TItem> node);
    [ExtensionAttribute]
public static string GetPathWithLastRange(GraphNode`1<TItem> node);
    [ExtensionAttribute]
public static GraphNode`1<TItem> Path(GraphNode`1<TItem> node, String[] path);
    [ExtensionAttribute]
public static string GetIdAndRange(GraphNode`1<TItem> node);
    [ExtensionAttribute]
public static string GetIdAndVersionOrRange(GraphNode`1<TItem> node);
    [ExtensionAttribute]
public static string GetId(GraphNode`1<TItem> node);
    [ExtensionAttribute]
public static NuGetVersion GetVersionOrDefault(GraphNode`1<TItem> node);
    [ExtensionAttribute]
public static VersionRange GetVersionRange(GraphNode`1<TItem> node);
    [ExtensionAttribute]
public static bool IsPackage(GraphNode`1<TItem> node);
    [ExtensionAttribute]
private static bool TryResolveConflicts(GraphNode`1<TItem> root, List`1<VersionConflictResult`1<TItem>> versionConflicts);
    private static void WalkTreeDectectConflicts(GraphNode`1<TItem> node, ConflictsAndAccepted`1<TItem> context);
    private static WalkState WalkTreeMarkAmbiguousNodes(GraphNode`1<TItem> node, WalkState state, Tracker`1<TItem> context);
    private static bool WalkTreeRejectNodesOfRejectedNodes(bool state, GraphNode`1<TItem> node, Tracker`1<TItem> context);
    private static bool WalkTreeAcceptOrRejectNodes(TrackerAndAccepted`1<TItem> context, bool state, GraphNode`1<TItem> node);
    [ExtensionAttribute]
private static TState ForEachGlobalState(GraphNode`1<TItem> root, TState state, Func`3<GraphNode`1<TItem>, TState, TState> visitor, Func`2<GraphNode`1<TItem>, bool> skipNode);
    [ExtensionAttribute]
private static void ForEach(GraphNode`1<TItem> root, TState state, Func`4<GraphNode`1<TItem>, TState, TContext, TState> visitor, TContext context, Func`2<GraphNode`1<TItem>, bool> skipNode);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<GraphNode`1<TItem>> roots, Action`1<GraphNode`1<TItem>> visitor);
    [ExtensionAttribute]
private static void ForEach(GraphNode`1<TItem> root, Action`1<GraphNode`1<TItem>> visitor, Func`2<GraphNode`1<TItem>, bool> skipNode);
    [ExtensionAttribute]
public static void ForEach(GraphNode`1<TItem> root, Action`1<GraphNode`1<TItem>> visitor);
    [ExtensionAttribute]
private static void ForEach(GraphNode`1<TItem> root, Action`2<GraphNode`1<TItem>, TContext> visitor, TContext context, Func`2<GraphNode`1<TItem>, bool> skipNode);
    [ExtensionAttribute]
public static void ForEach(GraphNode`1<TItem> root, Action`2<GraphNode`1<TItem>, TContext> visitor, TContext context);
    private static void AddInnerNodesToQueue(IList`1<GraphNode`1<TItem>> innerNodes, Queue`1<NodeWithState`2<TItem, TState>> queue, TState innerState);
    private static void AddInnerNodesToQueue(IList`1<GraphNode`1<TItem>> innerNodes, Queue`1<GraphNode`1<TItem>> queue);
    public static Dictionary`2<GraphNode`1<RemoteResolveResult>, GraphNode`1<RemoteResolveResult>> RentDowngradesDictionary();
    public static void ReleaseDowngradesDictionary(Dictionary`2<GraphNode`1<RemoteResolveResult>, GraphNode`1<RemoteResolveResult>> dictionary);
    private static ConflictsAndAccepted`1<TItem> CreateState(List`1<VersionConflictResult`1<TItem>> versionConflicts, Dictionary`2<string, GraphNode`1<TItem>> acceptedLibraries);
    private static TrackerAndAccepted`1<TItem> CreateState(Tracker`1<TItem> tracker, Dictionary`2<string, GraphNode`1<TItem>> acceptedLibraries);
    private static CyclesAndDowngrades CreateState(List`1<GraphNode`1<RemoteResolveResult>> cycles, Dictionary`2<GraphNode`1<RemoteResolveResult>, GraphNode`1<RemoteResolveResult>> downgrades);
    private static void DetectAndMarkAmbiguousCentralTransitiveDependencies(Tracker`1<TItem> tracker, List`1<GraphNode`1<TItem>> centralTransitiveNodes);
    [ExtensionAttribute]
private static void RejectCentralTransitiveBecauseOfRejectedParents(GraphNode`1<TItem> root, Tracker`1<TItem> tracker, List`1<GraphNode`1<TItem>> centralTransitiveNodes);
    private static bool WalkTreeRejectNodesOfRejectedNodes(bool state, GraphNode`1<TItem> node, HashSet`1<GraphNode`1<TItem>> context);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void Dump(GraphNode`1<TItem> root, Action`1<string> write);
    private static void DumpChildren(GraphNode`1<TItem> root, Action`1<string> write, int level);
    private static void DumpNode(GraphNode`1<TItem> node, Action`1<string> write, int level);
    [CompilerGeneratedAttribute]
internal static bool <IsRelevantDowngrade>g__AreAllParentsAccepted|3_0(DowngradeResult`1<RemoteResolveResult> d);
}
public interface NuGet.DependencyResolver.IDependencyProvider {
    public abstract virtual bool SupportsType(LibraryDependencyTarget libraryTypeFlag);
    public abstract virtual Library GetLibrary(LibraryRange libraryRange, NuGetFramework targetFramework);
}
public interface NuGet.DependencyResolver.IRemoteDependencyProvider {
    public bool IsHttp { get; }
    public PackageSource Source { get; }
    public SourceRepository SourceRepository { get; }
    public abstract virtual bool get_IsHttp();
    public abstract virtual PackageSource get_Source();
    public abstract virtual SourceRepository get_SourceRepository();
    public abstract virtual Task`1<LibraryIdentity> FindLibraryAsync(LibraryRange libraryRange, NuGetFramework targetFramework, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public abstract virtual Task`1<LibraryDependencyInfo> GetDependenciesAsync(LibraryIdentity libraryIdentity, NuGetFramework targetFramework, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public abstract virtual Task`1<IPackageDownloader> GetPackageDownloaderAsync(PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
}
[IsReadOnlyAttribute]
public class NuGet.DependencyResolver.LibraryRangeCacheKey : ValueType {
    [CompilerGeneratedAttribute]
private NuGetFramework <Framework>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryRange <LibraryRange>k__BackingField;
    public NuGetFramework Framework { get; }
    public LibraryRange LibraryRange { get; }
    public LibraryRangeCacheKey(LibraryRange range, NuGetFramework framework);
    [CompilerGeneratedAttribute]
public NuGetFramework get_Framework();
    [CompilerGeneratedAttribute]
public LibraryRange get_LibraryRange();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(LibraryRangeCacheKey other);
    public virtual string ToString();
    public static bool op_Equality(LibraryRangeCacheKey left, LibraryRangeCacheKey right);
    public static bool op_Inequality(LibraryRangeCacheKey left, LibraryRangeCacheKey right);
}
[DefaultMemberAttribute("Item")]
internal class NuGet.DependencyResolver.LightweightList`1 : ValueType {
    private static int Fields;
    private int _expectedCapacity;
    private int _count;
    private T _firstItem;
    private T _secondItem;
    private T _thirdItem;
    private T _fourthItem;
    private T _fifthItem;
    private List`1<T> _additionalItems;
    public int Count { get; }
    public T Item { get; }
    public LightweightList`1(int expectedCapacity);
    [IsReadOnlyAttribute]
public int get_Count();
    [IsReadOnlyAttribute]
public T get_Item(int index);
    public void Add(T task);
    [IsReadOnlyAttribute]
public Enumerator<T> GetEnumerator();
}
public class NuGet.DependencyResolver.LocalDependencyProvider : object {
    private IDependencyProvider _dependencyProvider;
    [CompilerGeneratedAttribute]
private bool <IsHttp>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSource <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceRepository <SourceRepository>k__BackingField;
    public bool IsHttp { get; private set; }
    public PackageSource Source { get; private set; }
    public SourceRepository SourceRepository { get; private set; }
    public LocalDependencyProvider(IDependencyProvider dependencyProvider);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsHttp();
    [CompilerGeneratedAttribute]
private void set_IsHttp(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual PackageSource get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(PackageSource value);
    [CompilerGeneratedAttribute]
public sealed virtual SourceRepository get_SourceRepository();
    [CompilerGeneratedAttribute]
private void set_SourceRepository(SourceRepository value);
    public sealed virtual Task`1<LibraryIdentity> FindLibraryAsync(LibraryRange libraryRange, NuGetFramework targetFramework, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public sealed virtual Task`1<LibraryDependencyInfo> GetDependenciesAsync(LibraryIdentity libraryIdentity, NuGetFramework targetFramework, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public sealed virtual Task`1<IPackageDownloader> GetPackageDownloaderAsync(PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public sealed virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
}
public class NuGet.DependencyResolver.LocalMatch : RemoteMatch {
    [CompilerGeneratedAttribute]
private Library <LocalLibrary>k__BackingField;
    [CompilerGeneratedAttribute]
private IDependencyProvider <LocalProvider>k__BackingField;
    public Library LocalLibrary { get; public set; }
    public IDependencyProvider LocalProvider { get; public set; }
    [CompilerGeneratedAttribute]
public Library get_LocalLibrary();
    [CompilerGeneratedAttribute]
public void set_LocalLibrary(Library value);
    [CompilerGeneratedAttribute]
public IDependencyProvider get_LocalProvider();
    [CompilerGeneratedAttribute]
public void set_LocalProvider(IDependencyProvider value);
}
public class NuGet.DependencyResolver.LockFileCacheKey : object {
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifier>k__BackingField;
    public NuGetFramework TargetFramework { get; }
    public string RuntimeIdentifier { get; }
    public string Name { get; }
    public LockFileCacheKey(NuGetFramework framework, string runtimeIdentifier);
    [CompilerGeneratedAttribute]
public NuGetFramework get_TargetFramework();
    [CompilerGeneratedAttribute]
public string get_RuntimeIdentifier();
    public string get_Name();
    public sealed virtual bool Equals(LockFileCacheKey other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private static string GetNameString(string framework, string runtime);
}
public static class NuGet.DependencyResolver.PackagingUtility : object {
    public static LibraryDependency GetLibraryDependencyFromNuspec(PackageDependency dependency);
}
public class NuGet.DependencyResolver.RemoteDependencyWalker : object {
    private RemoteWalkContext _context;
    public RemoteDependencyWalker(RemoteWalkContext context);
    [AsyncStateMachineAttribute("NuGet.DependencyResolver.RemoteDependencyWalker/<WalkAsync>d__2")]
public Task`1<GraphNode`1<RemoteResolveResult>> WalkAsync(LibraryRange library, NuGetFramework framework, string runtimeIdentifier, RuntimeGraph runtimeGraph, bool recursive);
    [AsyncStateMachineAttribute("NuGet.DependencyResolver.RemoteDependencyWalker/<CreateGraphNodeAsync>d__3")]
private ValueTask`1<GraphNode`1<RemoteResolveResult>> CreateGraphNodeAsync(LibraryRange libraryRange, NuGetFramework framework, string runtimeName, RuntimeGraph runtimeGraph, Func`2<LibraryRange, ValueTuple`2<DependencyResult, LibraryDependency>> predicate, GraphEdge`1<RemoteResolveResult> outerEdge, TransitiveCentralPackageVersions transitiveCentralPackageVersions, bool hasParentNodes);
    private static ValueTuple`2<DependencyResult, LibraryDependency> WalkParentsAndCalculateDependencyResult(GraphEdge`1<RemoteResolveResult> graphEdge, LibraryDependency dependency, Func`2<LibraryRange, ValueTuple`2<DependencyResult, LibraryDependency>> rootPredicate);
    private static Func`2<LibraryRange, ValueTuple`2<DependencyResult, LibraryDependency>> ChainPredicate(Func`2<LibraryRange, ValueTuple`2<DependencyResult, LibraryDependency>> predicate, GraphNode`1<RemoteResolveResult> node, LibraryDependency dependency);
    private static ValueTuple`2<Nullable`1<DependencyResult>, LibraryDependency> CalculateDependencyResult(GraphItem`1<RemoteResolveResult> item, LibraryDependency parentDependency, LibraryRange childDependencyLibrary, bool isRoot);
    public static bool IsGreaterThanOrEqualTo(VersionRange nearVersion, VersionRange farVersion);
    private static NuGetVersion GetReleaseLabelFreeVersion(VersionRange versionRange);
    private void MarkCentralVersionForTransitiveProcessing(LibraryDependency libraryDependency, TransitiveCentralPackageVersions transitiveCentralPackageVersions, GraphNode`1<RemoteResolveResult> parentNode);
    [AsyncStateMachineAttribute("NuGet.DependencyResolver.RemoteDependencyWalker/<AddTransitiveCentralPackageVersionNodesAsync>d__11")]
private Task`1<GraphNode`1<RemoteResolveResult>> AddTransitiveCentralPackageVersionNodesAsync(GraphNode`1<RemoteResolveResult> rootNode, LibraryDependency centralPackageVersionDependency, NuGetFramework framework, string runtimeIdentifier, RuntimeGraph runtimeGraph, TransitiveCentralPackageVersions transitiveCentralPackageVersions);
    internal bool IsDependencyValidForGraph(LibraryDependency dependency);
    [CompilerGeneratedAttribute]
internal static void <CreateGraphNodeAsync>g__EvaluateRuntimeDependencies|3_0(LibraryRange& libraryRange, string runtimeName, RuntimeGraph runtimeGraph, HashSet`1& runtimeDependencies);
    [CompilerGeneratedAttribute]
internal static void <CreateGraphNodeAsync>g__MergeRuntimeDependencies|3_1(HashSet`1<LibraryDependency> runtimeDependencies, GraphNode`1<RemoteResolveResult> node);
}
public class NuGet.DependencyResolver.RemoteMatch : object {
    [CompilerGeneratedAttribute]
private IRemoteDependencyProvider <Provider>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryIdentity <Library>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public IRemoteDependencyProvider Provider { get; public set; }
    public LibraryIdentity Library { get; public set; }
    public string Path { get; public set; }
    [CompilerGeneratedAttribute]
public IRemoteDependencyProvider get_Provider();
    [CompilerGeneratedAttribute]
public void set_Provider(IRemoteDependencyProvider value);
    [CompilerGeneratedAttribute]
public LibraryIdentity get_Library();
    [CompilerGeneratedAttribute]
public void set_Library(LibraryIdentity value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RemoteMatch other);
    public virtual int GetHashCode();
}
public class NuGet.DependencyResolver.RemoteResolveResult : object {
    internal static List`1<LibraryDependency> EmptyDependencies;
    [CompilerGeneratedAttribute]
private RemoteMatch <Match>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<LibraryDependency> <Dependencies>k__BackingField;
    public RemoteMatch Match { get; public set; }
    public List`1<LibraryDependency> Dependencies { get; public set; }
    private static RemoteResolveResult();
    [CompilerGeneratedAttribute]
public RemoteMatch get_Match();
    [CompilerGeneratedAttribute]
public void set_Match(RemoteMatch value);
    [CompilerGeneratedAttribute]
public List`1<LibraryDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(List`1<LibraryDependency> value);
}
public class NuGet.DependencyResolver.RemoteWalkContext : object {
    [CompilerGeneratedAttribute]
private SourceCacheContext <CacheContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IDependencyProvider> <ProjectLibraryProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IRemoteDependencyProvider> <LocalLibraryProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IRemoteDependencyProvider> <RemoteLibraryProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSourceMapping <PackageSourceMapping>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<LockFileCacheKey, IList`1<LibraryIdentity>> <LockFileLibraries>k__BackingField;
    [CompilerGeneratedAttribute]
private <76dee5d5-572c-44bd-8e59-41aaed8a29e3>TaskResultCache`2<LibraryRangeCacheKey, GraphItem`1<RemoteResolveResult>> <FindLibraryEntryCache>k__BackingField;
    [CompilerGeneratedAttribute]
private <76dee5d5-572c-44bd-8e59-41aaed8a29e3>TaskResultCache`2<LibraryRange, Tuple`2<LibraryRange, RemoteMatch>> <ResolvePackageLibraryMatchCache>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMsBuildBased>k__BackingField;
    public SourceCacheContext CacheContext { get; }
    public ILogger Logger { get; }
    public IList`1<IDependencyProvider> ProjectLibraryProviders { get; }
    public IList`1<IRemoteDependencyProvider> LocalLibraryProviders { get; }
    public IList`1<IRemoteDependencyProvider> RemoteLibraryProviders { get; }
    public PackageSourceMapping PackageSourceMapping { get; }
    public IDictionary`2<LockFileCacheKey, IList`1<LibraryIdentity>> LockFileLibraries { get; }
    internal <76dee5d5-572c-44bd-8e59-41aaed8a29e3>TaskResultCache`2<LibraryRangeCacheKey, GraphItem`1<RemoteResolveResult>> FindLibraryEntryCache { get; }
    internal <76dee5d5-572c-44bd-8e59-41aaed8a29e3>TaskResultCache`2<LibraryRange, Tuple`2<LibraryRange, RemoteMatch>> ResolvePackageLibraryMatchCache { get; }
    public bool IsMsBuildBased { get; public set; }
    public RemoteWalkContext(SourceCacheContext cacheContext, PackageSourceMapping packageSourceMapping, ILogger logger);
    [CompilerGeneratedAttribute]
public SourceCacheContext get_CacheContext();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public IList`1<IDependencyProvider> get_ProjectLibraryProviders();
    [CompilerGeneratedAttribute]
public IList`1<IRemoteDependencyProvider> get_LocalLibraryProviders();
    [CompilerGeneratedAttribute]
public IList`1<IRemoteDependencyProvider> get_RemoteLibraryProviders();
    [CompilerGeneratedAttribute]
public PackageSourceMapping get_PackageSourceMapping();
    [CompilerGeneratedAttribute]
public IDictionary`2<LockFileCacheKey, IList`1<LibraryIdentity>> get_LockFileLibraries();
    [CompilerGeneratedAttribute]
internal <76dee5d5-572c-44bd-8e59-41aaed8a29e3>TaskResultCache`2<LibraryRangeCacheKey, GraphItem`1<RemoteResolveResult>> get_FindLibraryEntryCache();
    [CompilerGeneratedAttribute]
internal <76dee5d5-572c-44bd-8e59-41aaed8a29e3>TaskResultCache`2<LibraryRange, Tuple`2<LibraryRange, RemoteMatch>> get_ResolvePackageLibraryMatchCache();
    [CompilerGeneratedAttribute]
public bool get_IsMsBuildBased();
    [CompilerGeneratedAttribute]
public void set_IsMsBuildBased(bool value);
    public IList`1<IRemoteDependencyProvider> FilterDependencyProvidersForLibrary(LibraryRange libraryRange);
}
public static class NuGet.DependencyResolver.ResolverUtility : object {
    public static Task`1<GraphItem`1<RemoteResolveResult>> FindLibraryCachedAsync(LibraryRange libraryRange, NuGetFramework framework, string runtimeIdentifier, RemoteWalkContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.DependencyResolver.ResolverUtility/<FindLibraryEntryAsync>d__1")]
public static Task`1<GraphItem`1<RemoteResolveResult>> FindLibraryEntryAsync(LibraryRange libraryRange, NuGetFramework framework, string runtimeIdentifier, RemoteWalkContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.DependencyResolver.ResolverUtility/<CreateGraphItemAsync>d__2")]
private static Task`1<GraphItem`1<RemoteResolveResult>> CreateGraphItemAsync(RemoteMatch match, NuGetFramework framework, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.DependencyResolver.ResolverUtility/<FindLibraryMatchAsync>d__3")]
public static Task`1<RemoteMatch> FindLibraryMatchAsync(LibraryRange libraryRange, NuGetFramework framework, string runtimeIdentifier, IEnumerable`1<IRemoteDependencyProvider> remoteProviders, IEnumerable`1<IRemoteDependencyProvider> localProviders, IEnumerable`1<IDependencyProvider> projectProviders, IDictionary`2<LockFileCacheKey, IList`1<LibraryIdentity>> lockFileLibraries, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public static Task`1<Tuple`2<LibraryRange, RemoteMatch>> FindPackageLibraryMatchCachedAsync(LibraryRange libraryRange, RemoteWalkContext remoteWalkContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.DependencyResolver.ResolverUtility/<ResolvePackageLibraryMatchAsync>d__5")]
private static Task`1<Tuple`2<LibraryRange, RemoteMatch>> ResolvePackageLibraryMatchAsync(LibraryRange libraryRange, RemoteWalkContext remoteWalkContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.DependencyResolver.ResolverUtility/<FindPackageLibraryMatchAsync>d__6")]
private static Task`1<RemoteMatch> FindPackageLibraryMatchAsync(LibraryRange libraryRange, NuGetFramework framework, IEnumerable`1<IRemoteDependencyProvider> remoteProviders, IEnumerable`1<IRemoteDependencyProvider> localProviders, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public static Task`1<RemoteMatch> FindProjectMatchAsync(LibraryRange libraryRange, NuGetFramework framework, IEnumerable`1<IDependencyProvider> projectProviders, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.DependencyResolver.ResolverUtility/<FindLibraryByVersionAsync>d__8")]
public static Task`1<RemoteMatch> FindLibraryByVersionAsync(LibraryRange libraryRange, NuGetFramework framework, IEnumerable`1<IRemoteDependencyProvider> providers, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.DependencyResolver.ResolverUtility/<FindLibraryFromSourcesAsync>d__9")]
private static Task`1<RemoteMatch> FindLibraryFromSourcesAsync(LibraryRange libraryRange, IEnumerable`1<IRemoteDependencyProvider> providers, NuGetFramework framework, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    private static GraphItem`1<RemoteResolveResult> CreateUnresolvedResult(LibraryRange libraryRange);
    private static RemoteMatch CreateUnresolvedMatch(LibraryRange libraryRange);
    private static void LogIfPackageSourceMappingIsEnabled(string packageName, RemoteWalkContext context, IList`1<IRemoteDependencyProvider> remoteDependencyProviders);
    [AsyncStateMachineAttribute("NuGet.DependencyResolver.ResolverUtility/<<FindLibraryFromSourcesAsync>g__FindLibraryFromProviderAsync|9_0>d")]
[CompilerGeneratedAttribute]
internal static Task`1<RemoteMatch> <FindLibraryFromSourcesAsync>g__FindLibraryFromProviderAsync|9_0(IRemoteDependencyProvider provider, LibraryRange libraryRange, NuGetFramework framework, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.DependencyResolver.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Error_PackageNotFoundWhenExpected { get; }
    internal static string Log_MatchingSourceFoundForPackage { get; }
    internal static string Log_NoMatchingSourceFoundForPackage { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Error_PackageNotFoundWhenExpected();
    internal static string get_Log_MatchingSourceFoundForPackage();
    internal static string get_Log_NoMatchingSourceFoundForPackage();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.DependencyResolver.Tracker`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, Entry<TItem>> _entryByLibraryName;
    public void Track(GraphItem`1<TItem> item);
    public bool IsDisputed(GraphItem`1<TItem> item);
    public bool IsAmbiguous(GraphItem`1<TItem> item);
    public void MarkAmbiguous(GraphItem`1<TItem> item);
    public bool IsBestVersion(GraphItem`1<TItem> item);
    public IEnumerable`1<GraphItem`1<TItem>> GetDisputes(GraphItem`1<TItem> item);
    internal void Clear();
    private Entry<TItem> TryGetEntry(GraphItem`1<TItem> item);
    private Entry<TItem> GetOrAddEntry(GraphItem`1<TItem> item);
}
public class NuGet.DependencyResolver.VersionConflictResult`1 : object {
    [CompilerGeneratedAttribute]
private GraphNode`1<TItem> <Selected>k__BackingField;
    [CompilerGeneratedAttribute]
private GraphNode`1<TItem> <Conflicting>k__BackingField;
    public GraphNode`1<TItem> Selected { get; public set; }
    public GraphNode`1<TItem> Conflicting { get; public set; }
    [CompilerGeneratedAttribute]
public GraphNode`1<TItem> get_Selected();
    [CompilerGeneratedAttribute]
public void set_Selected(GraphNode`1<TItem> value);
    [CompilerGeneratedAttribute]
public GraphNode`1<TItem> get_Conflicting();
    [CompilerGeneratedAttribute]
public void set_Conflicting(GraphNode`1<TItem> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Frameworks.AssetTargetFallbackFramework : NuGetFramework {
    private Nullable`1<int> _hashCode;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<NuGetFramework> <Fallback>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <RootFramework>k__BackingField;
    public IReadOnlyList`1<NuGetFramework> Fallback { get; }
    public NuGetFramework RootFramework { get; }
    public AssetTargetFallbackFramework(NuGetFramework framework, IReadOnlyList`1<NuGetFramework> fallbackFrameworks);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<NuGetFramework> get_Fallback();
    [CompilerGeneratedAttribute]
public NuGetFramework get_RootFramework();
    private static NuGetFramework ValidateFrameworkArgument(NuGetFramework framework);
    public FallbackFramework AsFallbackFramework();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(AssetTargetFallbackFramework other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class NuGet.Frameworks.CompatibilityCacheKey : ValueType {
    [CompilerGeneratedAttribute]
private NuGetFramework <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <Candidate>k__BackingField;
    private int _hashCode;
    public NuGetFramework Target { get; }
    public NuGetFramework Candidate { get; }
    public CompatibilityCacheKey(NuGetFramework target, NuGetFramework candidate);
    [CompilerGeneratedAttribute]
public NuGetFramework get_Target();
    [CompilerGeneratedAttribute]
public NuGetFramework get_Candidate();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(CompatibilityCacheKey other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Frameworks.CompatibilityListProvider : object {
    private IFrameworkNameProvider _nameProvider;
    private IFrameworkCompatibilityProvider _compatibilityProvider;
    private FrameworkReducer _reducer;
    [NullableAttribute("2")]
private static IFrameworkCompatibilityListProvider _default;
    public static IFrameworkCompatibilityListProvider Default { get; }
    public CompatibilityListProvider(IFrameworkNameProvider nameProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public sealed virtual IEnumerable`1<NuGetFramework> GetFrameworksSupporting(NuGetFramework target);
    private IEnumerable`1<NuGetFramework> ReduceDownwards(IEnumerable`1<NuGetFramework> frameworks);
    public static IFrameworkCompatibilityListProvider get_Default();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Frameworks.CompatibilityMappingComparer : object {
    [CompilerGeneratedAttribute]
private static CompatibilityMappingComparer <Instance>k__BackingField;
    public static CompatibilityMappingComparer Instance { get; }
    private static CompatibilityMappingComparer();
    [CompilerGeneratedAttribute]
public static CompatibilityMappingComparer get_Instance();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(OneWayCompatibilityMappingEntry x, OneWayCompatibilityMappingEntry y);
    public sealed virtual int GetHashCode(OneWayCompatibilityMappingEntry obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Frameworks.CompatibilityProvider : object {
    private IFrameworkNameProvider _mappings;
    private FrameworkExpander _expander;
    private static NuGetFrameworkFullComparer FullComparer;
    private ConcurrentDictionary`2<CompatibilityCacheKey, bool> _cache;
    public CompatibilityProvider(IFrameworkNameProvider mappings);
    private static CompatibilityProvider();
    public sealed virtual bool IsCompatible(NuGetFramework target, NuGetFramework candidate);
    private Nullable`1<bool> IsCompatibleCore(NuGetFramework target, NuGetFramework candidate);
    private Nullable`1<bool> IsSpecialFrameworkCompatible(NuGetFramework target, NuGetFramework candidate);
    private bool IsPCLCompatible(NuGetFramework target, NuGetFramework candidate);
    private bool PCLInnerCompare(IEnumerable`1<NuGetFramework> targetFrameworks, IEnumerable`1<NuGetFramework> candidateFrameworks);
    private bool IsCompatibleWithTarget(NuGetFramework target, NuGetFramework candidate);
    private static bool IsCompatibleWithTargetCore(NuGetFramework target, NuGetFramework candidate);
    private static bool IsVersionCompatible(Version target, Version candidate);
    [IteratorStateMachineAttribute("NuGet.Frameworks.CompatibilityProvider/<GetEquivalentFrameworksClosure>d__13")]
private IEnumerable`1<NuGetFramework> GetEquivalentFrameworksClosure(NuGetFramework framework);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Frameworks.CompatibilityTable : object {
    private IFrameworkNameProvider _mappings;
    private IFrameworkCompatibilityProvider _compat;
    private Dictionary`2<NuGetFramework, HashSet`1<NuGetFramework>> _table;
    private FrameworkReducer _reducer;
    public CompatibilityTable(IEnumerable`1<NuGetFramework> frameworks);
    public CompatibilityTable(IEnumerable`1<NuGetFramework> frameworks, IFrameworkNameProvider mappings, IFrameworkCompatibilityProvider compat);
    public bool HasFramework(NuGetFramework framework);
    public IEnumerable`1<NuGetFramework> GetNearest(NuGetFramework framework);
    public bool TryGetCompatible(NuGetFramework framework, IEnumerable`1& compatible);
    private static Dictionary`2<NuGetFramework, HashSet`1<NuGetFramework>> GetTable(IEnumerable`1<NuGetFramework> frameworks, IFrameworkCompatibilityProvider compat);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Frameworks.DefaultCompatibilityProvider : CompatibilityProvider {
    [NullableAttribute("2")]
private static IFrameworkCompatibilityProvider _instance;
    public static IFrameworkCompatibilityProvider Instance { get; }
    public static IFrameworkCompatibilityProvider get_Instance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Frameworks.DefaultFrameworkMappings : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<KeyValuePair`2[]> IdentifierSynonymsLazy;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<KeyValuePair`2[]> IdentifierShortNamesLazy;
    private static Lazy`1<FrameworkSpecificMapping[]> ProfileShortNamesLazy;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<KeyValuePair`2[]> EquivalentFrameworksLazy;
    private static Lazy`1<FrameworkSpecificMapping[]> EquivalentProfilesLazy;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<KeyValuePair`2[]> SubSetFrameworksLazy;
    private static Lazy`1<OneWayCompatibilityMappingEntry[]> CompatibilityMappingsLazy;
    private static Lazy`1<String[]> NonPackageBasedFrameworkPrecedenceLazy;
    private static Lazy`1<String[]> PackageBasedFrameworkPrecedenceLazy;
    private static Lazy`1<String[]> EquivalentFrameworkPrecedenceLazy;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<KeyValuePair`2[]> ShortNameReplacementsLazy;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<KeyValuePair`2[]> FullNameReplacementsLazy;
    private static Lazy`1<IFrameworkMappings> InstanceLazy;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, string>> IdentifierSynonyms { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, string>> IdentifierShortNames { get; }
    public IEnumerable`1<FrameworkSpecificMapping> ProfileShortNames { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> EquivalentFrameworks { get; }
    public IEnumerable`1<FrameworkSpecificMapping> EquivalentProfiles { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, string>> SubSetFrameworks { get; }
    public IEnumerable`1<OneWayCompatibilityMappingEntry> CompatibilityMappings { get; }
    public IEnumerable`1<string> NonPackageBasedFrameworkPrecedence { get; }
    public IEnumerable`1<string> PackageBasedFrameworkPrecedence { get; }
    public IEnumerable`1<string> EquivalentFrameworkPrecedence { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> ShortNameReplacements { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> FullNameReplacements { get; }
    public static IFrameworkMappings Instance { get; }
    private static DefaultFrameworkMappings();
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> get_IdentifierSynonyms();
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> get_IdentifierShortNames();
    public sealed virtual IEnumerable`1<FrameworkSpecificMapping> get_ProfileShortNames();
    public sealed virtual IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> get_EquivalentFrameworks();
    public sealed virtual IEnumerable`1<FrameworkSpecificMapping> get_EquivalentProfiles();
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> get_SubSetFrameworks();
    public sealed virtual IEnumerable`1<OneWayCompatibilityMappingEntry> get_CompatibilityMappings();
    private static OneWayCompatibilityMappingEntry CreateGenerationMapping(NuGetFramework framework, NuGetFramework netPlatform);
    private static OneWayCompatibilityMappingEntry CreateStandardMapping(NuGetFramework framework, NuGetFramework netPlatform);
    [IteratorStateMachineAttribute("NuGet.Frameworks.DefaultFrameworkMappings/<CreateGenerationAndStandardMapping>d__23")]
private static IEnumerable`1<OneWayCompatibilityMappingEntry> CreateGenerationAndStandardMapping(NuGetFramework framework, NuGetFramework netPlatform, NuGetFramework netStandard);
    private static IEnumerable`1<OneWayCompatibilityMappingEntry> CreateGenerationAndStandardMappingForAllVersions(string framework, NuGetFramework netPlatform, NuGetFramework netStandard);
    public sealed virtual IEnumerable`1<string> get_NonPackageBasedFrameworkPrecedence();
    public sealed virtual IEnumerable`1<string> get_PackageBasedFrameworkPrecedence();
    public sealed virtual IEnumerable`1<string> get_EquivalentFrameworkPrecedence();
    public sealed virtual IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> get_ShortNameReplacements();
    public sealed virtual IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> get_FullNameReplacements();
    public static IFrameworkMappings get_Instance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Frameworks.DefaultFrameworkNameProvider : FrameworkNameProvider {
    private static Lazy`1<IFrameworkNameProvider> InstanceLazy;
    public static IFrameworkNameProvider Instance { get; }
    private static DefaultFrameworkNameProvider();
    public static IFrameworkNameProvider get_Instance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Frameworks.DefaultPortableFrameworkMappings : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<KeyValuePair`2[]> ProfileFrameworksLazy;
    private static Int32[] ProfilesWithOptionalFrameworks;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<List`1<KeyValuePair`2<int, NuGetFramework[]>>> ProfileOptionalFrameworksLazy;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<KeyValuePair`2[]> CompatibilityMappingsLazy;
    private static Lazy`1<IPortableFrameworkMappings> InstanceLazy;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> ProfileFrameworks { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> ProfileOptionalFrameworks { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<int, FrameworkRange>> CompatibilityMappings { get; }
    public static IPortableFrameworkMappings Instance { get; }
    private static DefaultPortableFrameworkMappings();
    public sealed virtual IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> get_ProfileFrameworks();
    private static KeyValuePair`2<int, NuGetFramework[]> CreateProfileFrameworks(int profile, NuGetFramework[] frameworks);
    public sealed virtual IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> get_ProfileOptionalFrameworks();
    public sealed virtual IEnumerable`1<KeyValuePair`2<int, FrameworkRange>> get_CompatibilityMappings();
    private static KeyValuePair`2<int, FrameworkRange> CreateStandardMapping(int profileNumber, NuGetFramework netStandard);
    public static IPortableFrameworkMappings get_Instance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Frameworks.DualCompatibilityFramework : NuGetFramework {
    [CompilerGeneratedAttribute]
private NuGetFramework <RootFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <SecondaryFramework>k__BackingField;
    private Nullable`1<int> _hashCode;
    [NullableAttribute("2")]
private FallbackFramework _fallbackFramework;
    public NuGetFramework RootFramework { get; }
    public NuGetFramework SecondaryFramework { get; }
    public DualCompatibilityFramework(NuGetFramework framework, NuGetFramework secondaryFramework);
    [CompilerGeneratedAttribute]
public NuGetFramework get_RootFramework();
    [CompilerGeneratedAttribute]
public NuGetFramework get_SecondaryFramework();
    public FallbackFramework AsFallbackFramework();
    private static NuGetFramework ValidateFrameworkArgument(NuGetFramework framework);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public bool Equals(DualCompatibilityFramework other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Frameworks.FallbackFramework : NuGetFramework {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<NuGetFramework> <Fallback>k__BackingField;
    private Nullable`1<int> _hashCode;
    public IReadOnlyList`1<NuGetFramework> Fallback { get; }
    public FallbackFramework(NuGetFramework framework, IReadOnlyList`1<NuGetFramework> fallbackFrameworks);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<NuGetFramework> get_Fallback();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(FallbackFramework other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Frameworks.FrameworkConstants : object {
    public static Version EmptyVersion;
    public static Version MaxVersion;
    public static Version Version5;
    public static Version Version6;
    public static Version Version7;
    public static Version Version8;
    public static Version Version10;
    public static FrameworkRange DotNetAll;
    private static FrameworkConstants();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Frameworks.FrameworkException : Exception {
    public FrameworkException(string message);
    protected FrameworkException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Frameworks.FrameworkExpander : object {
    private IFrameworkNameProvider _mappings;
    public FrameworkExpander(IFrameworkNameProvider mappings);
    [IteratorStateMachineAttribute("NuGet.Frameworks.FrameworkExpander/<Expand>d__3")]
public IEnumerable`1<NuGetFramework> Expand(NuGetFramework framework);
    [IteratorStateMachineAttribute("NuGet.Frameworks.FrameworkExpander/<ExpandInternal>d__4")]
private IEnumerable`1<NuGetFramework> ExpandInternal(NuGetFramework framework);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Frameworks.FrameworkNameHelpers : object {
    public static string GetPortableProfileNumberString(int profileNumber);
    public static string GetFolderName(string identifierShortName, string versionString, string profileShortName);
    public static string GetVersionString(Version version);
    public static Version GetVersion(string versionString);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Frameworks.FrameworkNameProvider : object {
    private static HashSet`1<NuGetFramework> EmptyFrameworkSet;
    private static HashSet`1<string> SingleDigitVersionFrameworks;
    private static HashSet`1<string> DecimalPointFrameworks;
    private Dictionary`2<string, string> _identifierSynonyms;
    private Dictionary`2<string, string> _identifierToShortName;
    private Dictionary`2<string, string> _profilesToShortName;
    private Dictionary`2<string, string> _identifierShortToLong;
    private Dictionary`2<string, string> _profileShortToLong;
    private Dictionary`2<int, HashSet`1<NuGetFramework>> _portableFrameworks;
    private Dictionary`2<int, HashSet`1<NuGetFramework>> _portableOptionalFrameworks;
    private Dictionary`2<int, HashSet`1<FrameworkRange>> _portableCompatibilityMappings;
    private Dictionary`2<NuGetFramework, HashSet`1<NuGetFramework>> _equivalentFrameworks;
    private Dictionary`2<string, Dictionary`2<string, HashSet`1<string>>> _equivalentProfiles;
    private Dictionary`2<string, HashSet`1<OneWayCompatibilityMappingEntry>> _compatibilityMappings;
    private Dictionary`2<string, HashSet`1<string>> _subSetFrameworks;
    private Dictionary`2<string, int> _nonPackageBasedFrameworkPrecedence;
    private Dictionary`2<string, int> _packageBasedFrameworkPrecedence;
    private Dictionary`2<string, int> _equivalentFrameworkPrecedence;
    private Dictionary`2<NuGetFramework, NuGetFramework> _shortNameRewrites;
    private Dictionary`2<NuGetFramework, NuGetFramework> _fullNameRewrites;
    private List`1<NuGetFramework> _netStandardVersions;
    private List`1<NuGetFramework> _compatibleCandidates;
    public FrameworkNameProvider(IEnumerable`1<IFrameworkMappings> mappings, IEnumerable`1<IPortableFrameworkMappings> portableMappings);
    private static FrameworkNameProvider();
    private static bool TryConvertOrNormalize(string key, IDictionary`2<string, string> mappings, IDictionary`2<string, string> reverse, String& value);
    public sealed virtual bool TryGetIdentifier(string framework, String& identifier);
    public sealed virtual bool TryGetProfile(string frameworkIdentifier, string profileShortName, String& profile);
    public sealed virtual bool TryGetShortIdentifier(string identifier, String& identifierShortName);
    public sealed virtual bool TryGetShortProfile(string frameworkIdentifier, string profile, String& profileShortName);
    public sealed virtual bool TryGetVersion(string versionString, Version& version);
    public sealed virtual bool TryGetPlatformVersion(string versionString, Version& version);
    public sealed virtual string GetVersionString(string framework, Version version);
    public sealed virtual bool TryGetPortableProfile(IEnumerable`1<NuGetFramework> supportedFrameworks, Int32& profileNumber);
    private HashSet`1<NuGetFramework> RemoveDuplicateFramework(IEnumerable`1<NuGetFramework> supportedFrameworks);
    private HashSet`1<NuGetFramework> GetAllEquivalentFrameworks(NuGetFramework framework);
    [IteratorStateMachineAttribute("NuGet.Frameworks.FrameworkNameProvider/<GetEquivalentPermutations>d__34")]
private IEnumerable`1<HashSet`1<NuGetFramework>> GetEquivalentPermutations(HashSet`1<NuGetFramework> frameworks);
    private HashSet`1<NuGetFramework> GetOptionalFrameworks(int profile);
    public sealed virtual bool TryGetPortableFrameworks(int profile, IEnumerable`1& frameworks);
    public sealed virtual bool TryGetPortableFrameworks(int profile, bool includeOptional, IEnumerable`1& frameworks);
    public sealed virtual bool TryGetPortableFrameworks(string shortPortableProfiles, IEnumerable`1& frameworks);
    public sealed virtual bool TryGetPortableCompatibilityMappings(int profile, IEnumerable`1& supportedFrameworkRanges);
    public sealed virtual bool TryGetPortableProfileNumber(string profile, Int32& profileNumber);
    public sealed virtual bool TryGetPortableFrameworks(string profile, bool includeOptional, IEnumerable`1& frameworks);
    public sealed virtual bool TryGetEquivalentFrameworks(NuGetFramework framework, IEnumerable`1& frameworks);
    public sealed virtual bool TryGetEquivalentFrameworks(FrameworkRange range, IEnumerable`1& frameworks);
    private void InitMappings(IEnumerable`1<IFrameworkMappings> mappings);
    private void InitPortableMappings(IEnumerable`1<IPortableFrameworkMappings> portableMappings);
    private void InitNetStandard();
    private void AddShortNameRewriteMappings(IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> mappings);
    private void AddFullNameRewriteMappings(IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> mappings);
    private void AddCompatibilityMappings(IEnumerable`1<OneWayCompatibilityMappingEntry> mappings);
    private void AddSubSetFrameworks(IEnumerable`1<KeyValuePair`2<string, string>> mappings);
    private void AddEquivalentProfiles(IEnumerable`1<FrameworkSpecificMapping> mappings);
    private void AddEquivalentFrameworks(IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> mappings);
    private void AddFrameworkSynonyms(IEnumerable`1<KeyValuePair`2<string, string>> mappings);
    private void AddIdentifierShortNames(IEnumerable`1<KeyValuePair`2<string, string>> mappings);
    private void AddProfileShortNames(IEnumerable`1<FrameworkSpecificMapping> mappings);
    private void AddPortableProfileMappings(IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> mappings);
    private void AddPortableOptionalFrameworks(IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> mappings);
    private void AddPortableCompatibilityMappings(IEnumerable`1<KeyValuePair`2<int, FrameworkRange>> mappings);
    public void AddFrameworkPrecedenceMappings(IDictionary`2<string, int> destination, IEnumerable`1<string> mappings);
    public sealed virtual bool TryGetCompatibilityMappings(NuGetFramework framework, IEnumerable`1& supportedFrameworkRanges);
    public sealed virtual bool TryGetSubSetFrameworks(string frameworkIdentifier, IEnumerable`1& subSetFrameworks);
    [NullableContextAttribute("2")]
public sealed virtual int CompareFrameworks(NuGetFramework x, NuGetFramework y);
    [NullableContextAttribute("2")]
public sealed virtual int CompareEquivalentFrameworks(NuGetFramework x, NuGetFramework y);
    [NullableContextAttribute("2")]
private static int CompareUsingPrecedence(NuGetFramework x, NuGetFramework y, Dictionary`2<string, int> precedence);
    public sealed virtual NuGetFramework GetShortNameReplacement(NuGetFramework framework);
    public sealed virtual NuGetFramework GetFullNameReplacement(NuGetFramework framework);
    public sealed virtual IEnumerable`1<NuGetFramework> GetNetStandardVersions();
    public sealed virtual IEnumerable`1<NuGetFramework> GetCompatibleCandidates();
    private void AddNetStandardVersions();
    private void AddCompatibleCandidates();
    private static bool SetEquals(HashSet`1<NuGetFramework> left, HashSet`1<NuGetFramework> right);
    private static void UnionWith(HashSet`1<NuGetFramework> toAccumulate, HashSet`1<NuGetFramework> toAdd);
    [CompilerGeneratedAttribute]
internal static bool <GetVersionString>g__HasGreaterThanNinePart|30_0(<>c__DisplayClass30_0& );
    [CompilerGeneratedAttribute]
internal static bool <GetVersionString>g__IsZero|30_1(Version version);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Frameworks.FrameworkPrecedenceSorter : object {
    private IFrameworkNameProvider _mappings;
    private bool _allEquivalent;
    public FrameworkPrecedenceSorter(IFrameworkNameProvider mappings, bool allEquivalent);
    [NullableContextAttribute("2")]
public sealed virtual int Compare(NuGetFramework x, NuGetFramework y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Frameworks.FrameworkRange : object {
    private bool _includeMin;
    private bool _includeMax;
    [CompilerGeneratedAttribute]
private NuGetFramework <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <Max>k__BackingField;
    public NuGetFramework Min { get; }
    public NuGetFramework Max { get; }
    public bool IncludeMin { get; }
    public bool IncludeMax { get; }
    public string FrameworkIdentifier { get; }
    public FrameworkRange(NuGetFramework min, NuGetFramework max);
    public FrameworkRange(NuGetFramework min, NuGetFramework max, bool includeMin, bool includeMax);
    [CompilerGeneratedAttribute]
public NuGetFramework get_Min();
    [CompilerGeneratedAttribute]
public NuGetFramework get_Max();
    public bool get_IncludeMin();
    public bool get_IncludeMax();
    public string get_FrameworkIdentifier();
    public bool Satisfies(NuGetFramework framework);
    private static bool SameExceptForVersion(NuGetFramework x, NuGetFramework y);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(FrameworkRange other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Frameworks.FrameworkRangeComparer : object {
    [CompilerGeneratedAttribute]
private static FrameworkRangeComparer <Instance>k__BackingField;
    public static FrameworkRangeComparer Instance { get; }
    private static FrameworkRangeComparer();
    [CompilerGeneratedAttribute]
public static FrameworkRangeComparer get_Instance();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(FrameworkRange x, FrameworkRange y);
    public sealed virtual int GetHashCode(FrameworkRange obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Frameworks.FrameworkReducer : object {
    private IFrameworkNameProvider _mappings;
    private IFrameworkCompatibilityProvider _compat;
    public FrameworkReducer(IFrameworkNameProvider mappings, IFrameworkCompatibilityProvider compat);
    public NuGetFramework GetNearest(NuGetFramework framework, IEnumerable`1<NuGetFramework> possibleFrameworks);
    private NuGetFramework GetNearestInternal(NuGetFramework framework, IEnumerable`1<NuGetFramework> possibleFrameworks);
    [IteratorStateMachineAttribute("NuGet.Frameworks.FrameworkReducer/<ReduceEquivalent>d__6")]
public IEnumerable`1<NuGetFramework> ReduceEquivalent(IEnumerable`1<NuGetFramework> frameworks);
    public IEnumerable`1<NuGetFramework> ReduceUpwards(IEnumerable`1<NuGetFramework> frameworks);
    public IEnumerable`1<NuGetFramework> ReduceDownwards(IEnumerable`1<NuGetFramework> frameworks);
    private IEnumerable`1<NuGetFramework> ReduceCore(IEnumerable`1<NuGetFramework> frameworks, Func`3<NuGetFramework, NuGetFramework, bool> isCompat);
    private IEnumerable`1<NuGetFramework> GetNearestNonPCLtoPCL(NuGetFramework framework, IEnumerable`1<NuGetFramework> reduced);
    private IEnumerable`1<NuGetFramework> GetNearestPCLtoPCL(NuGetFramework framework, IEnumerable`1<NuGetFramework> reduced);
    private Dictionary`2<NuGetFramework, IEnumerable`1<NuGetFramework>> ExplodePortableFrameworks(IEnumerable`1<NuGetFramework> pcls);
    private IEnumerable`1<NuGetFramework> ExplodePortableFramework(NuGetFramework pcl, bool includeOptional);
    private NuGetFramework GetBestPCL(IEnumerable`1<NuGetFramework> reduced);
    private bool IsBetterPCL(NuGetFramework current, NuGetFramework considering);
    [CompilerGeneratedAttribute]
private bool <ReduceUpwards>b__7_2(NuGetFramework x, NuGetFramework y);
    [CompilerGeneratedAttribute]
private bool <ReduceDownwards>b__8_1(NuGetFramework x, NuGetFramework y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Frameworks.FrameworkRuntimePair : object {
    [CompilerGeneratedAttribute]
private NuGetFramework <Framework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public NuGetFramework Framework { get; }
    public string RuntimeIdentifier { get; }
    public string Name { get; }
    public FrameworkRuntimePair(NuGetFramework framework, string runtimeIdentifier);
    [CompilerGeneratedAttribute]
public NuGetFramework get_Framework();
    [CompilerGeneratedAttribute]
public string get_RuntimeIdentifier();
    [CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(FrameworkRuntimePair other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [ObsoleteAttribute("This type is immutable, so there is no need or point to clone it.")]
public FrameworkRuntimePair Clone();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(FrameworkRuntimePair other);
    public static string GetName(NuGetFramework framework, string runtimeIdentifier);
    public static string GetTargetGraphName(NuGetFramework framework, string runtimeIdentifier);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Frameworks.FrameworkSpecificMapping : object {
    [CompilerGeneratedAttribute]
private string <FrameworkIdentifier>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private KeyValuePair`2<string, string> <Mapping>k__BackingField;
    public string FrameworkIdentifier { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyValuePair`2<string, string> Mapping { get; }
    public FrameworkSpecificMapping(string frameworkIdentifier, string key, string value);
    public FrameworkSpecificMapping(string frameworkIdentifier, KeyValuePair`2<string, string> mapping);
    [CompilerGeneratedAttribute]
public string get_FrameworkIdentifier();
    [CompilerGeneratedAttribute]
public KeyValuePair`2<string, string> get_Mapping();
}
[NullableContextAttribute("1")]
public interface NuGet.Frameworks.IFrameworkCompatibilityListProvider {
    public abstract virtual IEnumerable`1<NuGetFramework> GetFrameworksSupporting(NuGetFramework target);
}
[NullableContextAttribute("1")]
public interface NuGet.Frameworks.IFrameworkCompatibilityProvider {
    public abstract virtual bool IsCompatible(NuGetFramework framework, NuGetFramework other);
}
[NullableContextAttribute("1")]
public interface NuGet.Frameworks.IFrameworkMappings {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, string>> IdentifierSynonyms { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, string>> IdentifierShortNames { get; }
    public IEnumerable`1<FrameworkSpecificMapping> ProfileShortNames { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> EquivalentFrameworks { get; }
    public IEnumerable`1<FrameworkSpecificMapping> EquivalentProfiles { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, string>> SubSetFrameworks { get; }
    public IEnumerable`1<OneWayCompatibilityMappingEntry> CompatibilityMappings { get; }
    public IEnumerable`1<string> NonPackageBasedFrameworkPrecedence { get; }
    public IEnumerable`1<string> PackageBasedFrameworkPrecedence { get; }
    public IEnumerable`1<string> EquivalentFrameworkPrecedence { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> ShortNameReplacements { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> FullNameReplacements { get; }
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> get_IdentifierSynonyms();
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> get_IdentifierShortNames();
    public abstract virtual IEnumerable`1<FrameworkSpecificMapping> get_ProfileShortNames();
    public abstract virtual IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> get_EquivalentFrameworks();
    public abstract virtual IEnumerable`1<FrameworkSpecificMapping> get_EquivalentProfiles();
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> get_SubSetFrameworks();
    public abstract virtual IEnumerable`1<OneWayCompatibilityMappingEntry> get_CompatibilityMappings();
    public abstract virtual IEnumerable`1<string> get_NonPackageBasedFrameworkPrecedence();
    public abstract virtual IEnumerable`1<string> get_PackageBasedFrameworkPrecedence();
    public abstract virtual IEnumerable`1<string> get_EquivalentFrameworkPrecedence();
    public abstract virtual IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> get_ShortNameReplacements();
    public abstract virtual IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> get_FullNameReplacements();
}
[NullableContextAttribute("1")]
public interface NuGet.Frameworks.IFrameworkNameProvider {
    public abstract virtual bool TryGetIdentifier(string identifierShortName, String& identifier);
    public abstract virtual bool TryGetShortIdentifier(string identifier, String& identifierShortName);
    public abstract virtual bool TryGetProfile(string frameworkIdentifier, string profileShortName, String& profile);
    public abstract virtual bool TryGetShortProfile(string frameworkIdentifier, string profile, String& profileShortName);
    public abstract virtual bool TryGetVersion(string versionString, Version& version);
    public abstract virtual bool TryGetPlatformVersion(string versionString, Version& version);
    public abstract virtual string GetVersionString(string framework, Version version);
    public abstract virtual bool TryGetPortableProfileNumber(string profile, Int32& profileNumber);
    public abstract virtual bool TryGetPortableProfile(IEnumerable`1<NuGetFramework> supportedFrameworks, Int32& profileNumber);
    public abstract virtual bool TryGetPortableFrameworks(int profile, IEnumerable`1& frameworks);
    public abstract virtual bool TryGetPortableFrameworks(int profile, bool includeOptional, IEnumerable`1& frameworks);
    public abstract virtual bool TryGetPortableFrameworks(string profile, bool includeOptional, IEnumerable`1& frameworks);
    public abstract virtual bool TryGetPortableFrameworks(string shortPortableProfiles, IEnumerable`1& frameworks);
    public abstract virtual bool TryGetPortableCompatibilityMappings(int profile, IEnumerable`1& supportedFrameworkRanges);
    public abstract virtual bool TryGetEquivalentFrameworks(NuGetFramework framework, IEnumerable`1& frameworks);
    public abstract virtual bool TryGetEquivalentFrameworks(FrameworkRange range, IEnumerable`1& frameworks);
    public abstract virtual bool TryGetCompatibilityMappings(NuGetFramework framework, IEnumerable`1& supportedFrameworkRanges);
    public abstract virtual bool TryGetSubSetFrameworks(string frameworkIdentifier, IEnumerable`1& subSetFrameworkIdentifiers);
    [NullableContextAttribute("2")]
public abstract virtual int CompareFrameworks(NuGetFramework x, NuGetFramework y);
    [NullableContextAttribute("2")]
public abstract virtual int CompareEquivalentFrameworks(NuGetFramework x, NuGetFramework y);
    public abstract virtual NuGetFramework GetShortNameReplacement(NuGetFramework framework);
    public abstract virtual NuGetFramework GetFullNameReplacement(NuGetFramework framework);
    public abstract virtual IEnumerable`1<NuGetFramework> GetNetStandardVersions();
    public abstract virtual IEnumerable`1<NuGetFramework> GetCompatibleCandidates();
}
[NullableContextAttribute("1")]
public interface NuGet.Frameworks.IFrameworkSpecific {
    public NuGetFramework TargetFramework { get; }
    public abstract virtual NuGetFramework get_TargetFramework();
}
[NullableContextAttribute("1")]
public interface NuGet.Frameworks.IFrameworkTargetable {
    public IEnumerable`1<NuGetFramework> SupportedFrameworks { get; }
    public abstract virtual IEnumerable`1<NuGetFramework> get_SupportedFrameworks();
}
public interface NuGet.Frameworks.IPortableFrameworkMappings {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> ProfileFrameworks { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> ProfileOptionalFrameworks { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<int, FrameworkRange>> CompatibilityMappings { get; }
    public abstract virtual IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> get_ProfileFrameworks();
    public abstract virtual IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> get_ProfileOptionalFrameworks();
    public abstract virtual IEnumerable`1<KeyValuePair`2<int, FrameworkRange>> get_CompatibilityMappings();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Frameworks.NuGetFramework : object {
    private string _frameworkIdentifier;
    private Version _frameworkVersion;
    private string _frameworkProfile;
    [NullableAttribute("2")]
private string _targetFrameworkMoniker;
    [NullableAttribute("2")]
private string _targetPlatformMoniker;
    private Nullable`1<int> _hashCode;
    private static int Version5;
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <PlatformVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNet5Era>k__BackingField;
    public static IEqualityComparer`1<NuGetFramework> Comparer;
    public static IEqualityComparer`1<NuGetFramework> FrameworkNameComparer;
    private static SortedSet`1<string> PackagesBased;
    public static NuGetFramework UnsupportedFramework;
    public static NuGetFramework AgnosticFramework;
    public static NuGetFramework AnyFramework;
    private static Char[] CommaSeparator;
    public string Framework { get; }
    public Version Version { get; }
    public string Platform { get; }
    public Version PlatformVersion { get; }
    public bool HasPlatform { get; }
    public bool HasProfile { get; }
    public string Profile { get; }
    public string DotNetFrameworkName { get; }
    public string DotNetPlatformName { get; }
    public bool IsPCL { get; }
    public bool IsPackageBased { get; }
    public bool AllFrameworkVersions { get; }
    public bool IsUnsupported { get; }
    public bool IsAgnostic { get; }
    public bool IsAny { get; }
    public bool IsSpecificFramework { get; }
    internal bool IsNet5Era { get; private set; }
    public NuGetFramework(NuGetFramework framework);
    public NuGetFramework(string framework);
    public NuGetFramework(string framework, Version version);
    public NuGetFramework(string frameworkIdentifier, Version frameworkVersion, string frameworkProfile);
    public NuGetFramework(string frameworkIdentifier, Version frameworkVersion, string platform, Version platformVersion);
    internal NuGetFramework(string frameworkIdentifier, Version frameworkVersion, string profile, string platform, Version platformVersion);
    private static NuGetFramework();
    public string get_Framework();
    public Version get_Version();
    [CompilerGeneratedAttribute]
public string get_Platform();
    [CompilerGeneratedAttribute]
public Version get_PlatformVersion();
    public bool get_HasPlatform();
    public bool get_HasProfile();
    public string get_Profile();
    public string get_DotNetFrameworkName();
    public string GetDotNetFrameworkName(IFrameworkNameProvider mappings);
    public string get_DotNetPlatformName();
    public string GetShortFolderName();
    private string GetFrameworkIdentifier();
    public virtual string GetShortFolderName(IFrameworkNameProvider mappings);
    private static string GetDisplayVersion(Version version);
    private static string GetLettersAndDigitsOnly(string s);
    public bool get_IsPCL();
    public bool get_IsPackageBased();
    public bool get_AllFrameworkVersions();
    public bool get_IsUnsupported();
    public bool get_IsAgnostic();
    public bool get_IsAny();
    public bool get_IsSpecificFramework();
    [CompilerGeneratedAttribute]
internal bool get_IsNet5Era();
    [CompilerGeneratedAttribute]
private void set_IsNet5Era(bool value);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(NuGetFramework other);
    [NullableContextAttribute("2")]
public static bool op_Equality(NuGetFramework left, NuGetFramework right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(NuGetFramework left, NuGetFramework right);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private static Version NormalizeVersion(Version version);
    public static NuGetFramework Parse(string folderName);
    public static NuGetFramework Parse(string folderName, IFrameworkNameProvider mappings);
    public static NuGetFramework ParseComponents(string targetFrameworkMoniker, string targetPlatformMoniker);
    internal static NuGetFramework ParseComponents(string targetFrameworkMoniker, string targetPlatformMoniker, IFrameworkNameProvider mappings);
    private static String[] GetParts(string targetPlatformMoniker);
    public static NuGetFramework ParseFrameworkName(string frameworkName, IFrameworkNameProvider mappings);
    private static void ParseFrameworkNameParts(IFrameworkNameProvider mappings, String[] parts, String& framework, Version& version, String& profile);
    private static void ParsePlatformParts(String[] parts, String& targetPlatformIdentifier, Version& platformVersion);
    public static NuGetFramework ParseFolder(string folderName);
    public static NuGetFramework ParseFolder(string folderName, IFrameworkNameProvider mappings);
    private static bool TryParseDeprecatedFramework(string s, NuGetFramework& framework);
    private static Tuple`3<string, string, string> RawParse(string s);
    private static bool IsLetterOrDot(char c);
    private static bool IsDigitOrDot(char c);
    private static bool IsValidProfileChar(char c);
    private static bool TryParseSpecialFramework(string frameworkString, NuGetFramework& framework);
    private static bool TryParseCommonFramework(string frameworkString, NuGetFramework& framework);
    private static string SingleOrDefaultSafe(IEnumerable`1<string> items);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NuGet.Frameworks.NuGetFrameworkExtensions : object {
    [ExtensionAttribute]
public static bool IsDesktop(NuGetFramework framework);
    [ExtensionAttribute]
public static T GetNearest(IEnumerable`1<T> items, NuGetFramework projectFramework);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Frameworks.NuGetFrameworkFullComparer : object {
    [CompilerGeneratedAttribute]
private static NuGetFrameworkFullComparer <Instance>k__BackingField;
    public static NuGetFrameworkFullComparer Instance { get; }
    private static NuGetFrameworkFullComparer();
    [CompilerGeneratedAttribute]
public static NuGetFrameworkFullComparer get_Instance();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(NuGetFramework x, NuGetFramework y);
    public sealed virtual int GetHashCode(NuGetFramework obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Frameworks.NuGetFrameworkNameComparer : object {
    [CompilerGeneratedAttribute]
private static NuGetFrameworkNameComparer <Instance>k__BackingField;
    public static NuGetFrameworkNameComparer Instance { get; }
    private static NuGetFrameworkNameComparer();
    [CompilerGeneratedAttribute]
public static NuGetFrameworkNameComparer get_Instance();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(NuGetFramework x, NuGetFramework y);
    public sealed virtual int GetHashCode(NuGetFramework obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Frameworks.NuGetFrameworkSorter : object {
    [CompilerGeneratedAttribute]
private static NuGetFrameworkSorter <Instance>k__BackingField;
    public static NuGetFrameworkSorter Instance { get; }
    private static NuGetFrameworkSorter();
    [CompilerGeneratedAttribute]
public static NuGetFrameworkSorter get_Instance();
    [NullableContextAttribute("2")]
public sealed virtual int Compare(NuGetFramework x, NuGetFramework y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Frameworks.NuGetFrameworkUtility : object {
    public static T GetNearest(IEnumerable`1<T> items, NuGetFramework framework, Func`2<T, NuGetFramework> selector);
    public static T GetNearest(IEnumerable`1<T> items, NuGetFramework framework, IFrameworkNameProvider frameworkMappings, IFrameworkCompatibilityProvider compatibilityProvider, Func`2<T, NuGetFramework> selector);
    public static T GetNearest(IEnumerable`1<T> items, NuGetFramework framework);
    public static T GetNearest(IEnumerable`1<T> items, NuGetFramework framework, IFrameworkNameProvider frameworkMappings, IFrameworkCompatibilityProvider compatibilityProvider);
    public static bool IsCompatibleWithFallbackCheck(NuGetFramework projectFramework, NuGetFramework candidate);
    public static bool IsNetCore50AndUp(NuGetFramework framework);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Frameworks.OneWayCompatibilityMappingEntry : object {
    private FrameworkRange _targetFramework;
    private FrameworkRange _supportedFramework;
    public FrameworkRange TargetFrameworkRange { get; }
    public FrameworkRange SupportedFrameworkRange { get; }
    public static CompatibilityMappingComparer Comparer { get; }
    public OneWayCompatibilityMappingEntry(FrameworkRange targetFramework, FrameworkRange supportedFramework);
    public FrameworkRange get_TargetFrameworkRange();
    public FrameworkRange get_SupportedFrameworkRange();
    public static CompatibilityMappingComparer get_Comparer();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(OneWayCompatibilityMappingEntry other);
    public virtual string ToString();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Frameworks.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ArgumentCannotBeNullOrEmpty { get; }
    internal static string FrameworkDoesNotSupportProfiles { get; }
    internal static string FrameworkMismatch { get; }
    internal static string InvalidFrameworkIdentifier { get; }
    internal static string InvalidFrameworkVersion { get; }
    internal static string InvalidPlatformVersion { get; }
    internal static string InvalidPortableFrameworksDueToHyphen { get; }
    internal static string MissingPortableFrameworks { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ArgumentCannotBeNullOrEmpty();
    internal static string get_FrameworkDoesNotSupportProfiles();
    internal static string get_FrameworkMismatch();
    internal static string get_InvalidFrameworkIdentifier();
    internal static string get_InvalidFrameworkVersion();
    internal static string get_InvalidPlatformVersion();
    internal static string get_InvalidPortableFrameworksDueToHyphen();
    internal static string get_MissingPortableFrameworks();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.LibraryModel.CentralPackageVersion : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <VersionRange>k__BackingField;
    public string Name { get; }
    public VersionRange VersionRange { get; }
    public CentralPackageVersion(string name, VersionRange versionRange);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public VersionRange get_VersionRange();
    public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(CentralPackageVersion other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.LibraryModel.CentralPackageVersionNameComparer : object {
    [CompilerGeneratedAttribute]
private static CentralPackageVersionNameComparer <Default>k__BackingField;
    public static CentralPackageVersionNameComparer Default { get; }
    private static CentralPackageVersionNameComparer();
    [CompilerGeneratedAttribute]
public static CentralPackageVersionNameComparer get_Default();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(CentralPackageVersion x, CentralPackageVersion y);
    public sealed virtual int GetHashCode(CentralPackageVersion obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.LibraryModel.DownloadDependency : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <VersionRange>k__BackingField;
    public string Name { get; }
    public VersionRange VersionRange { get; }
    public DownloadDependency(string name, VersionRange versionRange);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public VersionRange get_VersionRange();
    public static LibraryRange op_Implicit(DownloadDependency library);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(DownloadDependency other);
    public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(DownloadDependency other);
    [ObsoleteAttribute("This type is immutable, so there is no need or point to clone it.")]
public DownloadDependency Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.LibraryModel.FrameworkDependency : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private FrameworkDependencyFlags <PrivateAssets>k__BackingField;
    public string Name { get; }
    public FrameworkDependencyFlags PrivateAssets { get; }
    public FrameworkDependency(string name, FrameworkDependencyFlags privateAssets);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public FrameworkDependencyFlags get_PrivateAssets();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(FrameworkDependency other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(FrameworkDependency other);
    public virtual int GetHashCode();
}
[FlagsAttribute]
public enum NuGet.LibraryModel.FrameworkDependencyFlags : Enum {
    public ushort value__;
    public static FrameworkDependencyFlags None;
    public static FrameworkDependencyFlags All;
}
public static class NuGet.LibraryModel.FrameworkDependencyFlagsUtils : object {
    public static FrameworkDependencyFlags Default;
    public static FrameworkDependencyFlags GetFlags(IEnumerable`1<string> values);
    [NullableContextAttribute("1")]
public static string GetFlagString(FrameworkDependencyFlags flags);
    [NullableContextAttribute("2")]
public static FrameworkDependencyFlags GetFlags(string flags);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.LibraryModel.KnownLibraryProperties : object {
    public static string AssemblyPath;
    public static string LockFileLibrary;
    public static string LockFileTargetLibrary;
    public static string PackageSpec;
    public static string TargetFrameworkInformation;
    public static string MSBuildProjectPath;
    public static string ProjectRestoreMetadataFiles;
    public static string FrameworkAssemblies;
    public static string ProjectFrameworks;
    public static string ProjectStyle;
    public static string FrameworkReferences;
    private static KnownLibraryProperties();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[<9f65e429-7a44-41af-85cb-9a867a352998>RequiredMemberAttribute]
public class NuGet.LibraryModel.Library : object {
    public static IEqualityComparer`1<Library> IdentityComparer;
    [CompilerGeneratedAttribute]
private LibraryRange <LibraryRange>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryIdentity <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<LibraryDependency> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Resolved>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Items>k__BackingField;
    [<9f65e429-7a44-41af-85cb-9a867a352998>RequiredMemberAttribute]
public LibraryRange LibraryRange { get; public set; }
    [<9f65e429-7a44-41af-85cb-9a867a352998>RequiredMemberAttribute]
public LibraryIdentity Identity { get; public set; }
    [<9f65e429-7a44-41af-85cb-9a867a352998>RequiredMemberAttribute]
public IEnumerable`1<LibraryDependency> Dependencies { get; public set; }
    public bool Resolved { get; public set; }
    [NullableAttribute("2")]
public string Path { get; public set; }
    public IDictionary`2<string, object> Items { get; public set; }
    public object Item { get; public set; }
    [<9f65e429-7a44-41af-85cb-9a867a352998>SetsRequiredMembersAttribute]
public Library(LibraryRange libraryRange, LibraryIdentity identity, IEnumerable`1<LibraryDependency> dependencies);
    private static Library();
    [CompilerGeneratedAttribute]
public LibraryRange get_LibraryRange();
    [CompilerGeneratedAttribute]
public void set_LibraryRange(LibraryRange value);
    [CompilerGeneratedAttribute]
public LibraryIdentity get_Identity();
    [CompilerGeneratedAttribute]
public void set_Identity(LibraryIdentity value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<LibraryDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(IEnumerable`1<LibraryDependency> value);
    [CompilerGeneratedAttribute]
public bool get_Resolved();
    [CompilerGeneratedAttribute]
public void set_Resolved(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Path();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(IDictionary`2<string, object> value);
    public object get_Item(string key);
    public void set_Item(string key, object value);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[<9f65e429-7a44-41af-85cb-9a867a352998>RequiredMemberAttribute]
public class NuGet.LibraryModel.LibraryDependency : object {
    [CompilerGeneratedAttribute]
private LibraryRange <LibraryRange>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryIncludeFlags <IncludeType>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryIncludeFlags <SuppressParent>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<NuGetLogCode> <NoWarn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoReferenced>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <VersionCentrallyManaged>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryDependencyReferenceType <ReferenceType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GeneratePathProperty>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Aliases>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private VersionRange <VersionOverride>k__BackingField;
    [<9f65e429-7a44-41af-85cb-9a867a352998>RequiredMemberAttribute]
public LibraryRange LibraryRange { get; public set; }
    public LibraryIncludeFlags IncludeType { get; public set; }
    public LibraryIncludeFlags SuppressParent { get; public set; }
    public IList`1<NuGetLogCode> NoWarn { get; public set; }
    public string Name { get; }
    public bool AutoReferenced { get; public set; }
    public bool VersionCentrallyManaged { get; public set; }
    public LibraryDependencyReferenceType ReferenceType { get; public set; }
    public bool GeneratePathProperty { get; public set; }
    [NullableAttribute("2")]
public string Aliases { get; public set; }
    [NullableAttribute("2")]
public VersionRange VersionOverride { get; public set; }
    [ObsoleteAttribute("Constructors of types with required members are not supported in this version of your compiler.", "True")]
[<9f65e429-7a44-41af-85cb-9a867a352998>CompilerFeatureRequiredAttribute("RequiredMembers")]
public LibraryDependency(IList`1<NuGetLogCode> noWarn);
    [<9f65e429-7a44-41af-85cb-9a867a352998>SetsRequiredMembersAttribute]
public LibraryDependency(LibraryRange libraryRange);
    [<9f65e429-7a44-41af-85cb-9a867a352998>SetsRequiredMembersAttribute]
internal LibraryDependency(LibraryRange libraryRange, LibraryIncludeFlags includeType, LibraryIncludeFlags suppressParent, IList`1<NuGetLogCode> noWarn, bool autoReferenced, bool generatePathProperty, bool versionCentrallyManaged, LibraryDependencyReferenceType libraryDependencyReferenceType, string aliases, VersionRange versionOverride);
    [CompilerGeneratedAttribute]
public LibraryRange get_LibraryRange();
    [CompilerGeneratedAttribute]
public void set_LibraryRange(LibraryRange value);
    [CompilerGeneratedAttribute]
public LibraryIncludeFlags get_IncludeType();
    [CompilerGeneratedAttribute]
public void set_IncludeType(LibraryIncludeFlags value);
    [CompilerGeneratedAttribute]
public LibraryIncludeFlags get_SuppressParent();
    [CompilerGeneratedAttribute]
public void set_SuppressParent(LibraryIncludeFlags value);
    [CompilerGeneratedAttribute]
public IList`1<NuGetLogCode> get_NoWarn();
    [CompilerGeneratedAttribute]
public void set_NoWarn(IList`1<NuGetLogCode> value);
    public string get_Name();
    [CompilerGeneratedAttribute]
public bool get_AutoReferenced();
    [CompilerGeneratedAttribute]
public void set_AutoReferenced(bool value);
    [CompilerGeneratedAttribute]
public bool get_VersionCentrallyManaged();
    [CompilerGeneratedAttribute]
public void set_VersionCentrallyManaged(bool value);
    [CompilerGeneratedAttribute]
public LibraryDependencyReferenceType get_ReferenceType();
    [CompilerGeneratedAttribute]
public void set_ReferenceType(LibraryDependencyReferenceType value);
    [CompilerGeneratedAttribute]
public bool get_GeneratePathProperty();
    [CompilerGeneratedAttribute]
public void set_GeneratePathProperty(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Aliases();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Aliases(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public VersionRange get_VersionOverride();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_VersionOverride(VersionRange value);
    public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(LibraryDependency other);
    public LibraryDependency Clone();
    public static void ApplyCentralVersionInformation(IList`1<LibraryDependency> packageReferences, IDictionary`2<string, CentralPackageVersion> centralPackageVersions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.LibraryModel.LibraryDependencyInfo : object {
    [CompilerGeneratedAttribute]
private bool <Resolved>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryIdentity <Library>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<LibraryDependency> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <Framework>k__BackingField;
    public bool Resolved { get; }
    public LibraryIdentity Library { get; }
    public IEnumerable`1<LibraryDependency> Dependencies { get; }
    public NuGetFramework Framework { get; }
    public LibraryDependencyInfo(LibraryIdentity library, bool resolved, NuGetFramework framework, IEnumerable`1<LibraryDependency> dependencies);
    [CompilerGeneratedAttribute]
public bool get_Resolved();
    [CompilerGeneratedAttribute]
public LibraryIdentity get_Library();
    [CompilerGeneratedAttribute]
public IEnumerable`1<LibraryDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public NuGetFramework get_Framework();
    public static LibraryDependencyInfo CreateUnresolved(LibraryIdentity library, NuGetFramework framework);
    public static LibraryDependencyInfo Create(LibraryIdentity library, NuGetFramework framework, IEnumerable`1<LibraryDependency> dependencies);
}
public enum NuGet.LibraryModel.LibraryDependencyReferenceType : Enum {
    public int value__;
    public static LibraryDependencyReferenceType None;
    public static LibraryDependencyReferenceType Transitive;
    public static LibraryDependencyReferenceType Direct;
}
[FlagsAttribute]
public enum NuGet.LibraryModel.LibraryDependencyTarget : Enum {
    public ushort value__;
    public static LibraryDependencyTarget None;
    public static LibraryDependencyTarget Package;
    public static LibraryDependencyTarget Project;
    public static LibraryDependencyTarget ExternalProject;
    public static LibraryDependencyTarget Assembly;
    public static LibraryDependencyTarget Reference;
    public static LibraryDependencyTarget WinMD;
    public static LibraryDependencyTarget All;
    public static LibraryDependencyTarget PackageProjectExternal;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NuGet.LibraryModel.LibraryDependencyTargetUtils : object {
    private static ConcurrentDictionary`2<LibraryDependencyTarget, string> LibraryDependencyTargetCache;
    private static LibraryDependencyTargetUtils();
    [NullableContextAttribute("2")]
public static LibraryDependencyTarget Parse(string flag);
    private static LibraryDependencyTarget ParseMultiFlag(string flag, int end);
    private static LibraryDependencyTarget ParseSingleFlag(StringSegment flag);
    public static string GetFlagString(LibraryDependencyTarget flags);
    [ExtensionAttribute]
public static string AsString(LibraryDependencyTarget includeFlags);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NuGet.LibraryModel.LibraryExtensions : object {
    [ExtensionAttribute]
public static bool IsEclipsedBy(LibraryRange library, LibraryRange other);
    [ExtensionAttribute]
public static T GetItem(Library library, string key);
    [ExtensionAttribute]
public static T GetRequiredItem(Library library, string key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[<9f65e429-7a44-41af-85cb-9a867a352998>RequiredMemberAttribute]
public class NuGet.LibraryModel.LibraryIdentity : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryType <Type>k__BackingField;
    [<9f65e429-7a44-41af-85cb-9a867a352998>RequiredMemberAttribute]
public string Name { get; public set; }
    [<9f65e429-7a44-41af-85cb-9a867a352998>RequiredMemberAttribute]
public NuGetVersion Version { get; public set; }
    [<9f65e429-7a44-41af-85cb-9a867a352998>RequiredMemberAttribute]
public LibraryType Type { get; public set; }
    [<9f65e429-7a44-41af-85cb-9a867a352998>SetsRequiredMembersAttribute]
public LibraryIdentity(string name, NuGetVersion version, LibraryType type);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public LibraryType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(LibraryType value);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(LibraryIdentity other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(LibraryIdentity left, LibraryIdentity right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(LibraryIdentity left, LibraryIdentity right);
    public static LibraryRange op_Implicit(LibraryIdentity library);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(LibraryIdentity other);
}
[FlagsAttribute]
public enum NuGet.LibraryModel.LibraryIncludeFlags : Enum {
    public ushort value__;
    public static LibraryIncludeFlags None;
    public static LibraryIncludeFlags Runtime;
    public static LibraryIncludeFlags Compile;
    public static LibraryIncludeFlags Build;
    public static LibraryIncludeFlags Native;
    public static LibraryIncludeFlags ContentFiles;
    public static LibraryIncludeFlags Analyzers;
    public static LibraryIncludeFlags BuildTransitive;
    public static LibraryIncludeFlags All;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NuGet.LibraryModel.LibraryIncludeFlagUtils : object {
    public static LibraryIncludeFlags DefaultSuppressParent;
    public static LibraryIncludeFlags NoContent;
    private static ConcurrentDictionary`2<LibraryIncludeFlags, string> LibraryIncludeFlagsCache;
    private static LibraryIncludeFlagUtils();
    public static LibraryIncludeFlags GetFlags(IEnumerable`1<string> flags);
    public static string GetFlagString(LibraryIncludeFlags flags);
    public static LibraryIncludeFlags GetFlags(string flags, LibraryIncludeFlags defaultFlags);
    [ExtensionAttribute]
public static string AsString(LibraryIncludeFlags includeFlags);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[<9f65e429-7a44-41af-85cb-9a867a352998>RequiredMemberAttribute]
public class NuGet.LibraryModel.LibraryRange : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <VersionRange>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryDependencyTarget <TypeConstraint>k__BackingField;
    [NullableAttribute("1")]
[<9f65e429-7a44-41af-85cb-9a867a352998>RequiredMemberAttribute]
public string Name { get; public set; }
    public VersionRange VersionRange { get; public set; }
    public LibraryDependencyTarget TypeConstraint { get; public set; }
    [NullableContextAttribute("1")]
[<9f65e429-7a44-41af-85cb-9a867a352998>SetsRequiredMembersAttribute]
public LibraryRange(string name);
    [NullableContextAttribute("1")]
[<9f65e429-7a44-41af-85cb-9a867a352998>SetsRequiredMembersAttribute]
public LibraryRange(string name, LibraryDependencyTarget typeConstraint);
    [NullableContextAttribute("1")]
[<9f65e429-7a44-41af-85cb-9a867a352998>SetsRequiredMembersAttribute]
public LibraryRange(string name, VersionRange versionRange, LibraryDependencyTarget typeConstraint);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public VersionRange get_VersionRange();
    [CompilerGeneratedAttribute]
public void set_VersionRange(VersionRange value);
    [CompilerGeneratedAttribute]
public LibraryDependencyTarget get_TypeConstraint();
    [CompilerGeneratedAttribute]
public void set_TypeConstraint(LibraryDependencyTarget value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public string ToLockFileDependencyGroupString();
    public bool TypeConstraintAllows(LibraryDependencyTarget flag);
    public bool TypeConstraintAllowsAnyOf(LibraryDependencyTarget flag);
    public sealed virtual bool Equals(LibraryRange other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(LibraryRange left, LibraryRange right);
    public static bool op_Inequality(LibraryRange left, LibraryRange right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.LibraryModel.LibraryType : ValueType {
    private static ConcurrentDictionary`2<string, LibraryType> _knownLibraryTypes;
    public static LibraryType Project;
    public static LibraryType ExternalProject;
    public static LibraryType Package;
    public static LibraryType Assembly;
    public static LibraryType Reference;
    public static LibraryType WinMD;
    public static LibraryType Unresolved;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsKnown>k__BackingField;
    public string Value { get; }
    public bool IsKnown { get; }
    private LibraryType(string value, bool isKnown);
    private static LibraryType();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Value();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsKnown();
    public static LibraryType Parse(string value);
    public virtual string ToString();
    public sealed virtual bool Equals(LibraryType other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static bool op_Equality(LibraryType left, LibraryType right);
    public static bool op_Inequality(LibraryType left, LibraryType right);
    public static string op_Implicit(LibraryType libraryType);
    public virtual int GetHashCode();
    private static LibraryType Define(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
[ExtensionAttribute]
public static class NuGet.Packaging.CollectionExtensions : object {
    [ExtensionAttribute]
public static void AddRange(ICollection`1<T> collection, IEnumerable`1<T> items);
}
internal static class NuGet.Packaging.Core.ContentExtractor : object {
    internal static void GetContentForPattern(ContentItemCollection collection, PatternSet pattern, IList`1<ContentItemGroup> itemGroups);
    internal static IEnumerable`1<NuGetFramework> GetGroupFrameworks(IEnumerable`1<ContentItemGroup> groups);
}
public class NuGet.Packaging.Core.ContentFilesEntry : object {
    [CompilerGeneratedAttribute]
private string <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildAction>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <CopyToOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Flatten>k__BackingField;
    public string Include { get; }
    public string Exclude { get; }
    public string BuildAction { get; }
    public Nullable`1<bool> CopyToOutput { get; }
    public Nullable`1<bool> Flatten { get; }
    public ContentFilesEntry(string include, string exclude, string buildAction, Nullable`1<bool> copyToOutput, Nullable`1<bool> flatten);
    [CompilerGeneratedAttribute]
public string get_Include();
    [CompilerGeneratedAttribute]
public string get_Exclude();
    [CompilerGeneratedAttribute]
public string get_BuildAction();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_CopyToOutput();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Flatten();
}
public class NuGet.Packaging.Core.ExtractPackageFileDelegate : MulticastDelegate {
    public ExtractPackageFileDelegate(object object, IntPtr method);
    public virtual string Invoke(string sourceFile, string targetPath, Stream fileStream);
    public virtual IAsyncResult BeginInvoke(string sourceFile, string targetPath, Stream fileStream, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
public class NuGet.Packaging.Core.Fingerprints : object {
    private IDictionary`2<string, string> _keyValuePairs;
    public string Item { get; }
    public Fingerprints(IDictionary`2<string, string> fingerPrints);
    public string get_Item(string key);
    public IEnumerator`1<KeyValuePair`2<string, string>> GetEnumerator();
}
public interface NuGet.Packaging.Core.IAsyncPackageCoreReader {
    public abstract virtual Task`1<PackageIdentity> GetIdentityAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<NuGetVersion> GetMinClientVersionAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IReadOnlyList`1<PackageType>> GetPackageTypesAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> GetStreamAsync(string path, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<string>> GetFilesAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<string>> GetFilesAsync(string folder, CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> GetNuspecAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<string> GetNuspecFileAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<string>> CopyFilesAsync(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken cancellationToken);
}
public interface NuGet.Packaging.Core.INuspecCoreReader {
    public abstract virtual string GetId();
    public abstract virtual NuGetVersion GetVersion();
    public abstract virtual NuGetVersion GetMinClientVersion();
    public abstract virtual IReadOnlyList`1<PackageType> GetPackageTypes();
    public abstract virtual PackageIdentity GetIdentity();
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> GetMetadata();
}
public interface NuGet.Packaging.Core.IPackageCoreReader {
    public abstract virtual PackageIdentity GetIdentity();
    public abstract virtual NuGetVersion GetMinClientVersion();
    public abstract virtual IReadOnlyList`1<PackageType> GetPackageTypes();
    public abstract virtual Stream GetStream(string path);
    public abstract virtual IEnumerable`1<string> GetFiles();
    public abstract virtual IEnumerable`1<string> GetFiles(string folder);
    public abstract virtual Stream GetNuspec();
    public abstract virtual string GetNuspecFile();
    public abstract virtual IEnumerable`1<string> CopyFiles(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken token);
}
public interface NuGet.Packaging.Core.IPackageIdentityComparer {
}
public interface NuGet.Packaging.Core.IRepositoryCertificateInfo {
    public string ContentUrl { get; }
    public Fingerprints Fingerprints { get; }
    public string Issuer { get; }
    public DateTimeOffset NotAfter { get; }
    public DateTimeOffset NotBefore { get; }
    public string Subject { get; }
    public abstract virtual string get_ContentUrl();
    public abstract virtual Fingerprints get_Fingerprints();
    public abstract virtual string get_Issuer();
    public abstract virtual DateTimeOffset get_NotAfter();
    public abstract virtual DateTimeOffset get_NotBefore();
    public abstract virtual string get_Subject();
}
public class NuGet.Packaging.Core.NuspecCoreReader : NuspecCoreReaderBase {
    public NuspecCoreReader(Stream stream);
    public NuspecCoreReader(XDocument xml);
    [IteratorStateMachineAttribute("NuGet.Packaging.Core.NuspecCoreReader/<GetDependencies>d__2")]
public virtual IEnumerable`1<PackageDependency> GetDependencies();
}
public abstract class NuGet.Packaging.Core.NuspecCoreReaderBase : object {
    private XDocument _xml;
    private XElement _metadataNode;
    private Dictionary`2<string, string> _metadataValues;
    protected static string Metadata;
    protected static string Id;
    protected static string Version;
    protected static string MinClientVersion;
    protected static string DevelopmentDependency;
    protected Dictionary`2<string, string> MetadataValues { get; }
    protected XElement MetadataNode { get; }
    public XDocument Xml { get; }
    public NuspecCoreReaderBase(string path);
    public NuspecCoreReaderBase(Stream stream);
    public NuspecCoreReaderBase(Stream stream, bool leaveStreamOpen);
    public NuspecCoreReaderBase(XDocument xml);
    public virtual string GetId();
    public virtual NuGetVersion GetVersion();
    public virtual NuGetVersion GetMinClientVersion();
    public virtual IReadOnlyList`1<PackageType> GetPackageTypes();
    public virtual bool IsServiceable();
    public virtual bool GetDevelopmentDependency();
    public virtual IEnumerable`1<KeyValuePair`2<string, string>> GetMetadata();
    public virtual string GetMetadataValue(string name);
    protected Dictionary`2<string, string> get_MetadataValues();
    protected XElement get_MetadataNode();
    public XDocument get_Xml();
    public virtual PackageIdentity GetIdentity();
    private static XDocument LoadXml(Stream stream, bool leaveStreamOpen);
}
public static class NuGet.Packaging.Core.NuspecUtility : object {
    public static string PackageTypes;
    public static string PackageType;
    public static string Name;
    public static string Version;
    public static string Serviceable;
    public static string Repository;
    public static string Type;
    public static string RepositoryUrl;
    public static string RepositoryBranch;
    public static string RepositoryCommit;
    public static string License;
    public static string Group;
    public static string FrameworkReferences;
    public static string FrameworkReference;
    public static string TargetFramework;
    private static NuspecUtility();
    public static IReadOnlyList`1<PackageType> GetPackageTypes(XElement metadataNode, bool useMetadataNamespace);
    public static bool IsServiceable(XElement metadataNode);
    [IteratorStateMachineAttribute("NuGet.Packaging.Core.NuspecUtility/<GetFrameworkReferenceGroups>d__17")]
internal static IEnumerable`1<FrameworkReferenceGroup> GetFrameworkReferenceGroups(XElement metadataNode, IFrameworkNameProvider frameworkProvider, bool useMetadataNamespace);
    private static IEnumerable`1<string> GetFrameworkReferences(IEnumerable`1<XElement> nodes);
    private static string GetAttributeValue(XElement element, string attributeName);
}
public class NuGet.Packaging.Core.PackageDependency : object {
    private VersionRange _versionRange;
    private static List`1<string> EmptyList;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Exclude>k__BackingField;
    public string Id { get; }
    public IReadOnlyList`1<string> Include { get; }
    public IReadOnlyList`1<string> Exclude { get; }
    public VersionRange VersionRange { get; }
    public PackageDependency(string id);
    public PackageDependency(string id, VersionRange versionRange);
    public PackageDependency(string id, VersionRange versionRange, IReadOnlyList`1<string> include, IReadOnlyList`1<string> exclude);
    private static PackageDependency();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Include();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Exclude();
    public VersionRange get_VersionRange();
    public sealed virtual bool Equals(PackageDependency other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class NuGet.Packaging.Core.PackageDependencyComparer : object {
    private IVersionRangeComparer _versionRangeComparer;
    public static PackageDependencyComparer Default;
    public PackageDependencyComparer(IVersionRangeComparer versionRangeComparer);
    private static PackageDependencyComparer();
    public sealed virtual bool Equals(PackageDependency x, PackageDependency y);
    public sealed virtual int GetHashCode(PackageDependency obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Packaging.Core.PackageDependencyInfo : PackageIdentity {
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageDependency> <Dependencies>k__BackingField;
    public IEnumerable`1<PackageDependency> Dependencies { get; }
    public PackageDependencyInfo(string id, NuGetVersion version);
    public PackageDependencyInfo(PackageIdentity identity, IEnumerable`1<PackageDependency> dependencies);
    public PackageDependencyInfo(string id, NuGetVersion version, IEnumerable`1<PackageDependency> dependencies);
    [CompilerGeneratedAttribute]
public IEnumerable`1<PackageDependency> get_Dependencies();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(PackageDependencyInfo other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class NuGet.Packaging.Core.PackageDependencyInfoComparer : object {
    private IPackageIdentityComparer _identityComparer;
    private PackageDependencyComparer _dependencyComparer;
    [CompilerGeneratedAttribute]
private static PackageDependencyInfoComparer <Default>k__BackingField;
    public static PackageDependencyInfoComparer Default { get; }
    public PackageDependencyInfoComparer(IPackageIdentityComparer identityComparer, PackageDependencyComparer dependencyComparer);
    private static PackageDependencyInfoComparer();
    [CompilerGeneratedAttribute]
public static PackageDependencyInfoComparer get_Default();
    public sealed virtual bool Equals(PackageDependencyInfo x, PackageDependencyInfo y);
    public sealed virtual int GetHashCode(PackageDependencyInfo obj);
}
public class NuGet.Packaging.Core.PackageIdentity : object {
    private string _id;
    private NuGetVersion _version;
    private static string ToStringFormat;
    public string Id { get; }
    public NuGetVersion Version { get; }
    public bool HasVersion { get; }
    public static PackageIdentityComparer Comparer { get; }
    public PackageIdentity(string id, NuGetVersion version);
    public string get_Id();
    public NuGetVersion get_Version();
    public bool get_HasVersion();
    public sealed virtual bool Equals(PackageIdentity other);
    public virtual bool Equals(PackageIdentity other, VersionComparison versionComparison);
    public sealed virtual int CompareTo(PackageIdentity other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static PackageIdentityComparer get_Comparer();
    public virtual string ToString();
}
public class NuGet.Packaging.Core.PackageIdentityComparer : object {
    private IVersionComparer _versionComparer;
    [CompilerGeneratedAttribute]
private static PackageIdentityComparer <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private static PackageIdentityComparer <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private static PackageIdentityComparer <VersionRelease>k__BackingField;
    [CompilerGeneratedAttribute]
private static PackageIdentityComparer <VersionReleaseMetadata>k__BackingField;
    public static PackageIdentityComparer Default { get; }
    internal static PackageIdentityComparer Version { get; }
    internal static PackageIdentityComparer VersionRelease { get; }
    internal static PackageIdentityComparer VersionReleaseMetadata { get; }
    public PackageIdentityComparer(VersionComparison versionComparison);
    public PackageIdentityComparer(IVersionComparer versionComparer);
    private static PackageIdentityComparer();
    [CompilerGeneratedAttribute]
public static PackageIdentityComparer get_Default();
    [CompilerGeneratedAttribute]
internal static PackageIdentityComparer get_Version();
    [CompilerGeneratedAttribute]
internal static PackageIdentityComparer get_VersionRelease();
    [CompilerGeneratedAttribute]
internal static PackageIdentityComparer get_VersionReleaseMetadata();
    internal static PackageIdentityComparer Get(VersionComparison versionComparison);
    public sealed virtual bool Equals(PackageIdentity x, PackageIdentity y);
    public sealed virtual int GetHashCode(PackageIdentity obj);
    public sealed virtual int Compare(PackageIdentity x, PackageIdentity y);
}
public class NuGet.Packaging.Core.PackageType : object {
    public static Version EmptyVersion;
    public static PackageType Legacy;
    public static PackageType DotnetCliTool;
    public static PackageType Dependency;
    public static PackageType DotnetTool;
    public static PackageType SymbolsPackage;
    public static PackageType DotnetPlatform;
    public static StringComparer PackageTypeNameComparer;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public string Name { get; }
    public Version Version { get; }
    public PackageType(string name, Version version);
    private static PackageType();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Version get_Version();
    public virtual bool Equals(object obj);
    public static bool op_Equality(PackageType a, PackageType b);
    public static bool op_Inequality(PackageType a, PackageType b);
    public sealed virtual bool Equals(PackageType other);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(PackageType other);
}
public static class NuGet.Packaging.Core.PackagingCoreConstants : object {
    public static string HashFileExtension;
    public static string NupkgExtension;
    public static string NuspecExtension;
    public static string PackageDownloadMarkerFileExtension;
    public static string NupkgMetadataFileExtension;
    public static string EmptyFolder;
    public static string ForwardSlashEmptyFolder;
    private static PackagingCoreConstants();
}
public class NuGet.Packaging.Core.PackagingException : Exception {
    private IPackLogMessage _logMessage;
    public PackagingException(string message);
    public PackagingException(NuGetLogCode logCode, string message);
    public PackagingException(NuGetLogCode logCode, string message, Exception innerException);
    public PackagingException(string message, Exception innerException);
    public virtual ILogMessage AsLogMessage();
}
public class NuGet.Packaging.Core.RepositoryMetadata : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Branch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Commit>k__BackingField;
    public string Type { get; public set; }
    public string Url { get; public set; }
    public string Branch { get; public set; }
    public string Commit { get; public set; }
    public RepositoryMetadata(string type, string url, string branch, string commit);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public string get_Branch();
    [CompilerGeneratedAttribute]
public void set_Branch(string value);
    [CompilerGeneratedAttribute]
public string get_Commit();
    [CompilerGeneratedAttribute]
public void set_Commit(string value);
    public virtual bool Equals(object obj);
    public static bool op_Equality(RepositoryMetadata a, RepositoryMetadata b);
    public static bool op_Inequality(RepositoryMetadata a, RepositoryMetadata b);
    public sealed virtual bool Equals(RepositoryMetadata other);
    public virtual int GetHashCode();
}
internal class NuGet.Packaging.EmptyFrameworkFolderFile : PhysicalPackageFile {
    public EmptyFrameworkFolderFile(string directoryPathInPackage);
}
public enum NuGet.Packaging.ExtractionSource : Enum {
    public int value__;
    public static ExtractionSource RestoreCommand;
    public static ExtractionSource DownloadResource;
    public static ExtractionSource NuGetFolderProject;
}
public class NuGet.Packaging.FallbackPackagePathInfo : object {
    [CompilerGeneratedAttribute]
private VersionFolderPathResolver <PathResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    public VersionFolderPathResolver PathResolver { get; }
    public string Id { get; }
    public NuGetVersion Version { get; }
    public FallbackPackagePathInfo(string id, NuGetVersion version, VersionFolderPathResolver resolver);
    [CompilerGeneratedAttribute]
public VersionFolderPathResolver get_PathResolver();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
}
public class NuGet.Packaging.FallbackPackagePathResolver : object {
    private List`1<VersionFolderPathResolver> _pathResolvers;
    public FallbackPackagePathResolver(INuGetPathContext pathContext);
    public FallbackPackagePathResolver(string userPackageFolder, IEnumerable`1<string> fallbackPackageFolders);
    public string GetPackageDirectory(string packageId, string version);
    public string GetPackageDirectory(string packageId, NuGetVersion version);
    public FallbackPackagePathInfo GetPackageInfo(string packageId, NuGetVersion version);
}
public class NuGet.Packaging.FrameworkAssemblyReference : object {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<NuGetFramework> <SupportedFrameworks>k__BackingField;
    public string AssemblyName { get; private set; }
    public IEnumerable`1<NuGetFramework> SupportedFrameworks { get; private set; }
    public FrameworkAssemblyReference(string assemblyName, IEnumerable`1<NuGetFramework> supportedFrameworks);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
private void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<NuGetFramework> get_SupportedFrameworks();
    [CompilerGeneratedAttribute]
private void set_SupportedFrameworks(IEnumerable`1<NuGetFramework> value);
}
public static class NuGet.Packaging.FrameworkNameUtility : object {
    public static FrameworkName ParseFrameworkNameFromFilePath(string filePath, String& effectivePath);
    public static FrameworkName ParseFrameworkFolderName(string path, bool strictParsing, String& effectivePath);
    public static NuGetFramework ParseNuGetFrameworkFromFilePath(string filePath, String& effectivePath);
    public static NuGetFramework ParseNuGetFrameworkFolderName(string path, bool strictParsing, String& effectivePath);
}
public class NuGet.Packaging.FrameworkReference : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public FrameworkReference(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    public sealed virtual int Compare(FrameworkReference x, FrameworkReference y);
    public sealed virtual bool Equals(FrameworkReference other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(FrameworkReference other);
}
public class NuGet.Packaging.FrameworkReferenceGroup : object {
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<FrameworkReference> <FrameworkReferences>k__BackingField;
    public NuGetFramework TargetFramework { get; }
    public IEnumerable`1<FrameworkReference> FrameworkReferences { get; }
    public FrameworkReferenceGroup(NuGetFramework targetFramework, IEnumerable`1<FrameworkReference> frameworkReferences);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetFramework get_TargetFramework();
    [CompilerGeneratedAttribute]
public IEnumerable`1<FrameworkReference> get_FrameworkReferences();
    public sealed virtual bool Equals(FrameworkReferenceGroup other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class NuGet.Packaging.FrameworksExtensions : object {
    [ExtensionAttribute]
public static string GetFrameworkString(NuGetFramework self);
}
public class NuGet.Packaging.FrameworkSpecificGroup : object {
    private NuGetFramework _targetFramework;
    private String[] _items;
    [CompilerGeneratedAttribute]
private bool <HasEmptyFolder>k__BackingField;
    public NuGetFramework TargetFramework { get; }
    public IEnumerable`1<string> Items { get; }
    public bool HasEmptyFolder { get; }
    public FrameworkSpecificGroup(NuGetFramework targetFramework, IEnumerable`1<string> items);
    public sealed virtual NuGetFramework get_TargetFramework();
    public IEnumerable`1<string> get_Items();
    [CompilerGeneratedAttribute]
public bool get_HasEmptyFolder();
    public sealed virtual bool Equals(FrameworkSpecificGroup other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public interface NuGet.Packaging.IAsyncPackageContentReader {
    public abstract virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetFrameworkItemsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetBuildItemsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetToolItemsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetContentItemsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetLibItemsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetReferenceItemsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<PackageDependencyGroup>> GetPackageDependenciesAsync(CancellationToken cancellationToken);
}
public interface NuGet.Packaging.IHashFunction {
    public abstract virtual string GetHash();
    public abstract virtual void Update(Byte[] data, int offset, int count);
}
public interface NuGet.Packaging.INuspecReader {
    public abstract virtual IEnumerable`1<PackageDependencyGroup> GetDependencyGroups();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetReferenceGroups();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetFrameworkReferenceGroups();
    public abstract virtual string GetLanguage();
}
public interface NuGet.Packaging.IPackageContentReader {
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetFrameworkItems();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetBuildItems();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetToolItems();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetContentItems();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetLibItems();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetReferenceItems();
    public abstract virtual IEnumerable`1<PackageDependencyGroup> GetPackageDependencies();
}
public interface NuGet.Packaging.IPackageDownloader {
    public IAsyncPackageContentReader ContentReader { get; }
    public IAsyncPackageCoreReader CoreReader { get; }
    public ISignedPackageReader SignedPackageReader { get; }
    public string Source { get; }
    public abstract virtual IAsyncPackageContentReader get_ContentReader();
    public abstract virtual IAsyncPackageCoreReader get_CoreReader();
    public abstract virtual ISignedPackageReader get_SignedPackageReader();
    public abstract virtual string get_Source();
    public abstract virtual Task`1<bool> CopyNupkgFileToAsync(string destinationFilePath, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> GetPackageHashAsync(string hashAlgorithm, CancellationToken cancellationToken);
    public abstract virtual void SetExceptionHandler(Func`2<Exception, Task`1<bool>> handleExceptionAsync);
    public abstract virtual void SetThrottle(SemaphoreSlim throttle);
}
public interface NuGet.Packaging.IPackageFile {
    public string Path { get; }
    public string EffectivePath { get; }
    [ObsoleteAttribute("Use NuGetFramework instead. This property will be null for any frameworks net5.0 or above.")]
public FrameworkName TargetFramework { get; }
    public NuGetFramework NuGetFramework { get; }
    public DateTimeOffset LastWriteTime { get; }
    public abstract virtual string get_Path();
    public abstract virtual string get_EffectivePath();
    public abstract virtual FrameworkName get_TargetFramework();
    public abstract virtual NuGetFramework get_NuGetFramework();
    public abstract virtual DateTimeOffset get_LastWriteTime();
    public abstract virtual Stream GetStream();
}
public interface NuGet.Packaging.IPackageMetadata {
    public string Id { get; }
    public NuGetVersion Version { get; }
    public string Title { get; }
    public IEnumerable`1<string> Authors { get; }
    public IEnumerable`1<string> Owners { get; }
    public Uri IconUrl { get; }
    public Uri LicenseUrl { get; }
    public Uri ProjectUrl { get; }
    public bool RequireLicenseAcceptance { get; }
    public bool DevelopmentDependency { get; }
    public string Description { get; }
    public string Summary { get; }
    public string ReleaseNotes { get; }
    public string Language { get; }
    public string Tags { get; }
    public bool Serviceable { get; }
    public string Copyright { get; }
    public string Icon { get; }
    public string Readme { get; }
    public IEnumerable`1<FrameworkAssemblyReference> FrameworkReferences { get; }
    public IEnumerable`1<PackageReferenceSet> PackageAssemblyReferences { get; }
    public IEnumerable`1<PackageDependencyGroup> DependencyGroups { get; }
    public Version MinClientVersion { get; }
    public IEnumerable`1<ManifestContentFiles> ContentFiles { get; }
    public IEnumerable`1<PackageType> PackageTypes { get; }
    public RepositoryMetadata Repository { get; }
    public LicenseMetadata LicenseMetadata { get; }
    public IEnumerable`1<FrameworkReferenceGroup> FrameworkReferenceGroups { get; }
    public abstract virtual string get_Id();
    public abstract virtual NuGetVersion get_Version();
    public abstract virtual string get_Title();
    public abstract virtual IEnumerable`1<string> get_Authors();
    public abstract virtual IEnumerable`1<string> get_Owners();
    public abstract virtual Uri get_IconUrl();
    public abstract virtual Uri get_LicenseUrl();
    public abstract virtual Uri get_ProjectUrl();
    public abstract virtual bool get_RequireLicenseAcceptance();
    public abstract virtual bool get_DevelopmentDependency();
    public abstract virtual string get_Description();
    public abstract virtual string get_Summary();
    public abstract virtual string get_ReleaseNotes();
    public abstract virtual string get_Language();
    public abstract virtual string get_Tags();
    public abstract virtual bool get_Serviceable();
    public abstract virtual string get_Copyright();
    public abstract virtual string get_Icon();
    public abstract virtual string get_Readme();
    public abstract virtual IEnumerable`1<FrameworkAssemblyReference> get_FrameworkReferences();
    public abstract virtual IEnumerable`1<PackageReferenceSet> get_PackageAssemblyReferences();
    public abstract virtual IEnumerable`1<PackageDependencyGroup> get_DependencyGroups();
    public abstract virtual Version get_MinClientVersion();
    public abstract virtual IEnumerable`1<ManifestContentFiles> get_ContentFiles();
    public abstract virtual IEnumerable`1<PackageType> get_PackageTypes();
    public abstract virtual RepositoryMetadata get_Repository();
    public abstract virtual LicenseMetadata get_LicenseMetadata();
    public abstract virtual IEnumerable`1<FrameworkReferenceGroup> get_FrameworkReferenceGroups();
}
public interface NuGet.Packaging.IPackageResolver {
    public abstract virtual IEnumerable`1<PackageIdentity> Resolve(IEnumerable`1<PackageIdentity> targets, IEnumerable`1<PackageDependencyInfo> availablePackages, CancellationToken token);
    public abstract virtual IEnumerable`1<PackageIdentity> Resolve(IEnumerable`1<PackageIdentity> targets, IEnumerable`1<PackageDependencyInfo> availablePackages, IEnumerable`1<PackageReference> installedPackages, CancellationToken token);
    public abstract virtual IEnumerable`1<PackageIdentity> Resolve(IEnumerable`1<string> targets, IEnumerable`1<PackageDependencyInfo> availablePackages, CancellationToken token);
    public abstract virtual IEnumerable`1<PackageIdentity> Resolve(IEnumerable`1<string> targets, IEnumerable`1<PackageDependencyInfo> availablePackages, IEnumerable`1<PackageReference> installedPackages, CancellationToken token);
}
public class NuGet.Packaging.LicenseMetadata : object {
    public static Version EmptyVersion;
    public static Version CurrentVersion;
    public static Uri LicenseFileDeprecationUrl;
    public static string LicenseServiceLinkTemplate;
    [CompilerGeneratedAttribute]
private LicenseType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <License>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLicenseExpression <LicenseExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <WarningsAndErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public LicenseType Type { get; }
    public string License { get; }
    public NuGetLicenseExpression LicenseExpression { get; }
    public IReadOnlyList`1<string> WarningsAndErrors { get; }
    public Version Version { get; }
    public Uri LicenseUrl { get; }
    public LicenseMetadata(LicenseType type, string license, NuGetLicenseExpression expression, IReadOnlyList`1<string> warningsAndErrors, Version version);
    private static LicenseMetadata();
    [CompilerGeneratedAttribute]
public LicenseType get_Type();
    [CompilerGeneratedAttribute]
public string get_License();
    [CompilerGeneratedAttribute]
public NuGetLicenseExpression get_LicenseExpression();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_WarningsAndErrors();
    [CompilerGeneratedAttribute]
public Version get_Version();
    public sealed virtual bool Equals(LicenseMetadata other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Uri get_LicenseUrl();
    private static string GenerateLicenseServiceLink(string license);
}
public class NuGet.Packaging.Licenses.ExceptionData : object {
    [CompilerGeneratedAttribute]
private string <LicenseExceptionID>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDeprecatedLicenseId>k__BackingField;
    public string LicenseExceptionID { get; }
    public bool IsDeprecatedLicenseId { get; }
    public ExceptionData(string licenseID, bool isDeprecatedLicenseId);
    [CompilerGeneratedAttribute]
public string get_LicenseExceptionID();
    [CompilerGeneratedAttribute]
public bool get_IsDeprecatedLicenseId();
}
public class NuGet.Packaging.Licenses.LicenseData : object {
    [CompilerGeneratedAttribute]
private string <LicenseID>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOsiApproved>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDeprecatedLicenseId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFsfLibre>k__BackingField;
    public string LicenseID { get; }
    public bool IsOsiApproved { get; }
    public bool IsDeprecatedLicenseId { get; }
    public bool IsFsfLibre { get; }
    public LicenseData(string licenseID, bool isOsiApproved, bool isDeprecatedLicenseId, bool isFsfLibre);
    [CompilerGeneratedAttribute]
public string get_LicenseID();
    [CompilerGeneratedAttribute]
public bool get_IsOsiApproved();
    [CompilerGeneratedAttribute]
public bool get_IsDeprecatedLicenseId();
    [CompilerGeneratedAttribute]
public bool get_IsFsfLibre();
}
internal class NuGet.Packaging.Licenses.LicenseExpressionToken : object {
    [CompilerGeneratedAttribute]
private LicenseTokenType <TokenType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    internal LicenseTokenType TokenType { get; }
    internal string Value { get; }
    internal LicenseExpressionToken(string value, LicenseTokenType tokenType);
    [CompilerGeneratedAttribute]
internal LicenseTokenType get_TokenType();
    [CompilerGeneratedAttribute]
internal string get_Value();
    public virtual string ToString();
}
internal class NuGet.Packaging.Licenses.LicenseExpressionTokenizer : object {
    private string _value;
    internal LicenseExpressionTokenizer(string value);
    internal bool HasValidCharacters();
    [IteratorStateMachineAttribute("NuGet.Packaging.Licenses.LicenseExpressionTokenizer/<Tokenize>d__3")]
internal IEnumerable`1<LicenseExpressionToken> Tokenize();
    private LicenseExpressionToken ParseBracket(char bracket);
    private LicenseExpressionToken ParseTokenType(string token);
}
public enum NuGet.Packaging.Licenses.LicenseExpressionType : Enum {
    public int value__;
    public static LicenseExpressionType License;
    public static LicenseExpressionType Operator;
}
public abstract class NuGet.Packaging.Licenses.LicenseOperator : NuGetLicenseExpression {
    [CompilerGeneratedAttribute]
private LicenseOperatorType <OperatorType>k__BackingField;
    public LicenseOperatorType OperatorType { get; }
    protected LicenseOperator(LicenseOperatorType operatorType);
    [CompilerGeneratedAttribute]
public LicenseOperatorType get_OperatorType();
}
public enum NuGet.Packaging.Licenses.LicenseOperatorType : Enum {
    public int value__;
    public static LicenseOperatorType WithOperator;
    public static LicenseOperatorType LogicalOperator;
}
internal enum NuGet.Packaging.Licenses.LicenseTokenType : Enum {
    public int value__;
    public static LicenseTokenType WITH;
    public static LicenseTokenType AND;
    public static LicenseTokenType OR;
    public static LicenseTokenType OPENING_BRACKET;
    public static LicenseTokenType CLOSING_BRACKET;
    public static LicenseTokenType IDENTIFIER;
}
[ExtensionAttribute]
internal static class NuGet.Packaging.Licenses.LicenseTokenTypeExtensions : object {
    [ExtensionAttribute]
public static bool IsOperator(LicenseTokenType tokenType);
    [ExtensionAttribute]
public static bool IsValidPrecedingToken(LicenseTokenType current, LicenseTokenType precedingToken);
}
public class NuGet.Packaging.Licenses.LogicalOperator : LicenseOperator {
    [CompilerGeneratedAttribute]
private LogicalOperatorType <LogicalOperatorType>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLicenseExpression <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLicenseExpression <Right>k__BackingField;
    public LogicalOperatorType LogicalOperatorType { get; }
    public NuGetLicenseExpression Left { get; }
    public NuGetLicenseExpression Right { get; }
    public LogicalOperator(LogicalOperatorType logicalOperatorType, NuGetLicenseExpression left, NuGetLicenseExpression right);
    [CompilerGeneratedAttribute]
public LogicalOperatorType get_LogicalOperatorType();
    [CompilerGeneratedAttribute]
public NuGetLicenseExpression get_Left();
    [CompilerGeneratedAttribute]
public NuGetLicenseExpression get_Right();
    public virtual string ToString();
}
public enum NuGet.Packaging.Licenses.LogicalOperatorType : Enum {
    public int value__;
    public static LogicalOperatorType And;
    public static LogicalOperatorType Or;
}
public class NuGet.Packaging.Licenses.NuGetLicense : NuGetLicenseExpression {
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Plus>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStandardLicense>k__BackingField;
    internal static string UNLICENSED;
    public string Identifier { get; }
    public bool Plus { get; }
    public bool IsStandardLicense { get; }
    private NuGetLicense(string identifier, bool plus, bool isStandardLicense);
    private static NuGetLicense();
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public bool get_Plus();
    [CompilerGeneratedAttribute]
public bool get_IsStandardLicense();
    internal static NuGetLicense ParseIdentifier(string licenseIdentifier, bool allowUnlicensed);
    private static bool HasValidCharacters(string value);
    private static NuGetLicense ProcessLicenseNotInStandardData(string licenseIdentifier, bool plus, bool allowUnlicensed);
    public virtual string ToString();
}
public static class NuGet.Packaging.Licenses.NuGetLicenseData : object {
    [CompilerGeneratedAttribute]
private static string <LicenseListVersion>k__BackingField;
    public static IReadOnlyDictionary`2<string, LicenseData> LicenseList;
    public static IReadOnlyDictionary`2<string, ExceptionData> ExceptionList;
    public static string LicenseListVersion { get; }
    private static NuGetLicenseData();
    [CompilerGeneratedAttribute]
public static string get_LicenseListVersion();
}
public class NuGet.Packaging.Licenses.NuGetLicenseException : object {
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    public string Identifier { get; }
    private NuGetLicenseException(string identifier);
    [CompilerGeneratedAttribute]
public string get_Identifier();
    internal static NuGetLicenseException ParseIdentifier(string exceptionIdentifier);
    public virtual string ToString();
}
public abstract class NuGet.Packaging.Licenses.NuGetLicenseExpression : object {
    [CompilerGeneratedAttribute]
private LicenseExpressionType <Type>k__BackingField;
    public LicenseExpressionType Type { get; protected set; }
    [CompilerGeneratedAttribute]
public LicenseExpressionType get_Type();
    [CompilerGeneratedAttribute]
protected void set_Type(LicenseExpressionType value);
    public static NuGetLicenseExpression Parse(string expression);
}
[ExtensionAttribute]
public static class NuGet.Packaging.Licenses.NuGetLicenseExpressionExtensions : object {
    [ExtensionAttribute]
public static bool HasOnlyStandardIdentifiers(NuGetLicenseExpression expression);
    [ExtensionAttribute]
public static void OnEachLeafNode(NuGetLicenseExpression expression, Action`1<NuGetLicense> licenseProcessor, Action`1<NuGetLicenseException> exceptionProcessor);
    [ExtensionAttribute]
public static bool IsUnlicensed(NuGetLicense license);
    [ExtensionAttribute]
public static bool IsUnlicensed(NuGetLicenseExpression expression);
}
internal static class NuGet.Packaging.Licenses.NuGetLicenseExpressionParser : object {
    internal static NuGetLicenseExpression Parse(string expression);
    private static IEnumerable`1<LicenseExpressionToken> GetTokens(string expression);
    private static void ProcessOperators(Stack`1<LicenseExpressionToken> operatorStack, Stack`1<Tuple`2<bool, object>> operandStack);
    private static Tuple`2<bool, object> PopIfNotEmpty(Stack`1<Tuple`2<bool, object>> operandStack);
}
public class NuGet.Packaging.Licenses.NuGetLicenseExpressionParsingException : Exception {
    public NuGetLicenseExpressionParsingException(string message);
    public NuGetLicenseExpressionParsingException(string message, Exception innerException);
    protected NuGetLicenseExpressionParsingException(SerializationInfo info, StreamingContext context);
}
public class NuGet.Packaging.Licenses.WithOperator : LicenseOperator {
    [CompilerGeneratedAttribute]
private NuGetLicense <License>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLicenseException <Exception>k__BackingField;
    public NuGetLicense License { get; private set; }
    public NuGetLicenseException Exception { get; private set; }
    public WithOperator(NuGetLicense license, NuGetLicenseException exception);
    [CompilerGeneratedAttribute]
public NuGetLicense get_License();
    [CompilerGeneratedAttribute]
private void set_License(NuGetLicense value);
    [CompilerGeneratedAttribute]
public NuGetLicenseException get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(NuGetLicenseException value);
    public virtual string ToString();
}
public enum NuGet.Packaging.LicenseType : Enum {
    public int value__;
    public static LicenseType File;
    public static LicenseType Expression;
}
[ObsoleteAttribute("Use NuGet.Protocol.LocalPackageArchiveDownloader")]
public class NuGet.Packaging.LocalPackageArchiveDownloader : object {
    private Func`2<Exception, Task`1<bool>> _handleExceptionAsync;
    private bool _isDisposed;
    private ILogger _logger;
    private string _packageFilePath;
    private PackageIdentity _packageIdentity;
    private Lazy`1<PackageArchiveReader> _packageReader;
    private Lazy`1<FileStream> _sourceStream;
    private SemaphoreSlim _throttle;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    public IAsyncPackageContentReader ContentReader { get; }
    public IAsyncPackageCoreReader CoreReader { get; }
    public ISignedPackageReader SignedPackageReader { get; }
    public string Source { get; }
    public LocalPackageArchiveDownloader(string source, string packageFilePath, PackageIdentity packageIdentity, ILogger logger);
    public sealed virtual IAsyncPackageContentReader get_ContentReader();
    public sealed virtual IAsyncPackageCoreReader get_CoreReader();
    public sealed virtual ISignedPackageReader get_SignedPackageReader();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Source();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Packaging.LocalPackageArchiveDownloader/<CopyNupkgFileToAsync>d__19")]
public sealed virtual Task`1<bool> CopyNupkgFileToAsync(string destinationFilePath, CancellationToken cancellationToken);
    public sealed virtual Task`1<string> GetPackageHashAsync(string hashAlgorithm, CancellationToken cancellationToken);
    public sealed virtual void SetExceptionHandler(Func`2<Exception, Task`1<bool>> handleExceptionAsync);
    public sealed virtual void SetThrottle(SemaphoreSlim throttle);
    private PackageArchiveReader GetPackageReader();
    private FileStream GetSourceStream();
    private void ThrowIfDisposed();
}
public class NuGet.Packaging.Manifest : object {
    [CompilerGeneratedAttribute]
private ManifestMetadata <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ManifestFile> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasFilesNode>k__BackingField;
    public ManifestMetadata Metadata { get; }
    public ICollection`1<ManifestFile> Files { get; }
    public bool HasFilesNode { get; }
    public Manifest(ManifestMetadata metadata);
    public Manifest(ManifestMetadata metadata, ICollection`1<ManifestFile> files);
    [CompilerGeneratedAttribute]
public ManifestMetadata get_Metadata();
    [CompilerGeneratedAttribute]
public ICollection`1<ManifestFile> get_Files();
    [CompilerGeneratedAttribute]
public bool get_HasFilesNode();
    public void Save(Stream stream);
    public void Save(Stream stream, bool generateBackwardsCompatible);
    public void Save(Stream stream, int minimumManifestVersion);
    public void Save(Stream stream, int minimumManifestVersion, bool generateBackwardsCompatible);
    public static Manifest ReadFrom(Stream stream, bool validateSchema);
    public static Manifest ReadFrom(Stream stream, Func`2<string, string> propertyProvider, bool validateSchema);
    private static string GetSchemaNamespace(XDocument document);
    public static Manifest Create(IPackageMetadata metadata);
    private static void ValidateManifestSchema(XDocument document, string schemaNamespace);
    private static void CheckSchemaVersion(XDocument document);
    private static string GetPackageId(XElement metadataElement);
    private static XElement GetMetadataElement(XDocument document);
    public static void Validate(Manifest manifest);
    private static void ValidateDependencyGroups(IPackageMetadata metadata);
    private static void ValidateDependencyVersion(PackageDependency dependency);
}
public class NuGet.Packaging.ManifestContentFiles : object {
    [CompilerGeneratedAttribute]
private string <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildAction>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyToOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Flatten>k__BackingField;
    public string Include { get; public set; }
    public string Exclude { get; public set; }
    public string BuildAction { get; public set; }
    public string CopyToOutput { get; public set; }
    public string Flatten { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Include();
    [CompilerGeneratedAttribute]
public void set_Include(string value);
    [CompilerGeneratedAttribute]
public string get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(string value);
    [CompilerGeneratedAttribute]
public string get_BuildAction();
    [CompilerGeneratedAttribute]
public void set_BuildAction(string value);
    [CompilerGeneratedAttribute]
public string get_CopyToOutput();
    [CompilerGeneratedAttribute]
public void set_CopyToOutput(string value);
    [CompilerGeneratedAttribute]
public string get_Flatten();
    [CompilerGeneratedAttribute]
public void set_Flatten(string value);
}
public class NuGet.Packaging.ManifestFile : object {
    private static Char[] _invalidSourceCharacters;
    internal static Char[] ReferenceFileInvalidCharacters;
    private static Char[] _invalidTargetChars;
    private string _target;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exclude>k__BackingField;
    public string Source { get; public set; }
    public string Target { get; public set; }
    public string Exclude { get; public set; }
    private static ManifestFile();
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    public string get_Target();
    public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(string value);
    [IteratorStateMachineAttribute("NuGet.Packaging.ManifestFile/<Validate>d__15")]
public IEnumerable`1<string> Validate();
}
public class NuGet.Packaging.ManifestMetadata : object {
    private string _minClientVersionString;
    private IEnumerable`1<string> _authors;
    private IEnumerable`1<string> _owners;
    private string _iconUrl;
    private string _licenseUrl;
    private string _projectUrl;
    [CompilerGeneratedAttribute]
private Version <MinClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Icon>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EmitRequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DevelopmentDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReleaseNotes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Readme>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Serviceable>k__BackingField;
    [CompilerGeneratedAttribute]
private RepositoryMetadata <Repository>k__BackingField;
    private IEnumerable`1<PackageDependencyGroup> _dependencyGroups;
    [CompilerGeneratedAttribute]
private IEnumerable`1<FrameworkReferenceGroup> <FrameworkReferenceGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<FrameworkAssemblyReference> <FrameworkReferences>k__BackingField;
    private IEnumerable`1<PackageReferenceSet> _packageAssemblyReferences;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ManifestContentFiles> <ContentFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageType> <PackageTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private LicenseMetadata <LicenseMetadata>k__BackingField;
    [ManifestVersionAttribute("5")]
public string MinClientVersionString { get; public set; }
    public Version MinClientVersion { get; private set; }
    public string Id { get; public set; }
    public NuGetVersion Version { get; public set; }
    public string Title { get; public set; }
    public IEnumerable`1<string> Authors { get; public set; }
    public IEnumerable`1<string> Owners { get; public set; }
    public Uri IconUrl { get; }
    public string Icon { get; public set; }
    public Uri LicenseUrl { get; }
    public Uri ProjectUrl { get; }
    public bool RequireLicenseAcceptance { get; public set; }
    public bool EmitRequireLicenseAcceptance { get; public set; }
    public bool DevelopmentDependency { get; public set; }
    public string Description { get; public set; }
    public string Summary { get; public set; }
    [ManifestVersionAttribute("2")]
public string ReleaseNotes { get; public set; }
    [ManifestVersionAttribute("2")]
public string Copyright { get; public set; }
    public string Language { get; public set; }
    public string Tags { get; public set; }
    public string Readme { get; public set; }
    public bool Serviceable { get; public set; }
    public RepositoryMetadata Repository { get; public set; }
    public IEnumerable`1<PackageDependencyGroup> DependencyGroups { get; public set; }
    public IEnumerable`1<FrameworkReferenceGroup> FrameworkReferenceGroups { get; public set; }
    public IEnumerable`1<FrameworkAssemblyReference> FrameworkReferences { get; public set; }
    [ManifestVersionAttribute("2")]
public IEnumerable`1<PackageReferenceSet> PackageAssemblyReferences { get; public set; }
    public IEnumerable`1<ManifestContentFiles> ContentFiles { get; public set; }
    public IEnumerable`1<PackageType> PackageTypes { get; public set; }
    public LicenseMetadata LicenseMetadata { get; public set; }
    public ManifestMetadata(IPackageMetadata copy);
    public string get_MinClientVersionString();
    public void set_MinClientVersionString(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Version get_MinClientVersion();
    [CompilerGeneratedAttribute]
private void set_MinClientVersion(Version value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    public sealed virtual IEnumerable`1<string> get_Authors();
    public void set_Authors(IEnumerable`1<string> value);
    public sealed virtual IEnumerable`1<string> get_Owners();
    public void set_Owners(IEnumerable`1<string> value);
    public void SetIconUrl(string iconUrl);
    public sealed virtual Uri get_IconUrl();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Icon();
    [CompilerGeneratedAttribute]
public void set_Icon(string value);
    public void SetLicenseUrl(string licenseUrl);
    public sealed virtual Uri get_LicenseUrl();
    public void SetProjectUrl(string projectUrl);
    public sealed virtual Uri get_ProjectUrl();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_RequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public bool get_EmitRequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_EmitRequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DevelopmentDependency();
    [CompilerGeneratedAttribute]
public void set_DevelopmentDependency(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ReleaseNotes();
    [CompilerGeneratedAttribute]
public void set_ReleaseNotes(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Copyright();
    [CompilerGeneratedAttribute]
public void set_Copyright(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Readme();
    [CompilerGeneratedAttribute]
public void set_Readme(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Serviceable();
    [CompilerGeneratedAttribute]
public void set_Serviceable(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual RepositoryMetadata get_Repository();
    [CompilerGeneratedAttribute]
public void set_Repository(RepositoryMetadata value);
    public sealed virtual IEnumerable`1<PackageDependencyGroup> get_DependencyGroups();
    public void set_DependencyGroups(IEnumerable`1<PackageDependencyGroup> value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<FrameworkReferenceGroup> get_FrameworkReferenceGroups();
    [CompilerGeneratedAttribute]
public void set_FrameworkReferenceGroups(IEnumerable`1<FrameworkReferenceGroup> value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<FrameworkAssemblyReference> get_FrameworkReferences();
    [CompilerGeneratedAttribute]
public void set_FrameworkReferences(IEnumerable`1<FrameworkAssemblyReference> value);
    public sealed virtual IEnumerable`1<PackageReferenceSet> get_PackageAssemblyReferences();
    public void set_PackageAssemblyReferences(IEnumerable`1<PackageReferenceSet> value);
    private static IEnumerable`1<PackageReferenceSet> MergePackageAssemblyReferences(IEnumerable`1<PackageReferenceSet> referenceSets);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<ManifestContentFiles> get_ContentFiles();
    [CompilerGeneratedAttribute]
public void set_ContentFiles(IEnumerable`1<ManifestContentFiles> value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<PackageType> get_PackageTypes();
    [CompilerGeneratedAttribute]
public void set_PackageTypes(IEnumerable`1<PackageType> value);
    [CompilerGeneratedAttribute]
public sealed virtual LicenseMetadata get_LicenseMetadata();
    [CompilerGeneratedAttribute]
public void set_LicenseMetadata(LicenseMetadata value);
    private static IEnumerable`1<PackageDependencyGroup> MergeDependencyGroups(IEnumerable`1<PackageDependencyGroup> actualDependencyGroups);
    private static PackageDependencyGroup CreatePackageDependencyGroup(PackageDependencyGroup dependencyGroup);
    [IteratorStateMachineAttribute("NuGet.Packaging.ManifestMetadata/<Validate>d__125")]
public IEnumerable`1<string> Validate();
}
internal static class NuGet.Packaging.ManifestReader : object {
    private static String[] RequiredElements;
    private static ManifestReader();
    public static Manifest ReadManifest(XDocument document);
    private static ManifestMetadata ReadMetadata(XElement xElement);
    private static void ReadMetadataValue(ManifestMetadata manifestMetadata, XElement element, HashSet`1<string> allElements);
    private static IEnumerable`1<FrameworkReferenceGroup> ReadFrameworkReferenceGroups(XElement frameworkReferenceGroupsElement);
    private static LicenseMetadata ReadLicenseMetadata(XElement licenseNode);
    private static List`1<ManifestContentFiles> ReadContentFiles(XElement contentFilesElement);
    private static List`1<PackageReferenceSet> ReadReferenceSets(XElement referencesElement);
    public static List`1<string> ReadReference(XElement referenceElement, bool throwIfEmpty);
    private static List`1<FrameworkAssemblyReference> ReadFrameworkAssemblies(XElement frameworkElement);
    private static List`1<PackageDependencyGroup> ReadDependencyGroups(XElement dependenciesElement);
    private static ISet`1<PackageDependency> ReadDependencies(XElement containerElement);
    private static List`1<ManifestFile> ReadFilesList(XElement xElement);
    private static RepositoryMetadata ReadRepository(XElement element);
}
public static class NuGet.Packaging.ManifestSchemaUtility : object {
    internal static string SchemaVersionV1;
    internal static string SchemaVersionV2;
    internal static string SchemaVersionV3;
    internal static string SchemaVersionV4;
    internal static string SchemaVersionV5;
    internal static string SchemaVersionV6;
    private static String[] VersionToSchemaMappings;
    private static ConcurrentDictionary`2<string, XmlSchemaSet> _manifestSchemaSetCache;
    private static ManifestSchemaUtility();
    public static int GetVersionFromNamespace(string namespace);
    public static string GetSchemaNamespace(int version);
    public static XmlSchemaSet GetManifestSchemaSet(string schemaNamespace);
    public static bool IsKnownSchema(string schemaNamespace);
}
[AttributeUsageAttribute("128")]
internal class NuGet.Packaging.ManifestVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    public int Version { get; private set; }
    public ManifestVersionAttribute(int version);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(int value);
}
public static class NuGet.Packaging.ManifestVersionUtility : object {
    public static int DefaultVersion;
    public static int SemverVersion;
    public static int TargetFrameworkSupportForDependencyContentsAndToolsVersion;
    public static int TargetFrameworkSupportForReferencesVersion;
    public static int XdtTransformationVersion;
    public static int GetManifestVersion(ManifestMetadata metadata);
    private static int GetMaxVersionFromMetadata(ManifestMetadata metadata);
    private static int GetVersionFromObject(object obj);
    private static int GetVersionFromPropertyInfo(object obj, PropertyInfo property);
    private static int VisitList(IEnumerable list);
    private static Nullable`1<int> GetPropertyVersion(PropertyInfo property);
}
public class NuGet.Packaging.MinClientVersionException : PackagingException {
    public MinClientVersionException(string message);
    public virtual ILogMessage AsLogMessage();
}
public static class NuGet.Packaging.MinClientVersionUtility : object {
    private static NuGetVersion _clientVersion;
    public static void VerifyMinClientVersion(NuspecCoreReaderBase nuspecReader);
    public static bool IsMinClientVersionCompatible(NuspecCoreReaderBase nuspecReader);
    public static bool IsMinClientVersionCompatible(NuGetVersion packageMinClientVersion);
    public static NuGetVersion GetNuGetClientVersion();
}
internal static class NuGet.Packaging.NuGetExtractionFileIO : object {
    private static int _unixPermissions;
    private static Lazy`1<Func`2<string, FileStream>> _createFileMethod;
    private static NuGetExtractionFileIO();
    internal static FileStream CreateFile(string path);
    private static Func`2<string, FileStream> CreateFileMethodSelector();
    private static FileStream DotnetCoreCreateFile(string path);
    private static FileStream MonoPosixCreateFile(string path);
    private static void ApplyUMaskToUnixPermissions();
    private static bool ApplyUMaskToUnixPermissionsFromProcess();
    private static void ApplyUMaskToUnixPermissionsFromLibc();
    private static int PosixCreate(string pathname, int mode);
    private static int PosixChmod(string pathname, int mode);
    private static int PosixUMask(int mask);
}
public class NuGet.Packaging.NupkgMetadataFile : object {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    public int Version { get; public set; }
    public string ContentHash { get; public set; }
    public string Source { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    [CompilerGeneratedAttribute]
public string get_ContentHash();
    [CompilerGeneratedAttribute]
public void set_ContentHash(string value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    public sealed virtual bool Equals(NupkgMetadataFile other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class NuGet.Packaging.NupkgMetadataFileFormat : object {
    public static int Version;
    private static string VersionProperty;
    private static string HashProperty;
    private static string SourceProperty;
    private static JsonSerializer JsonSerializer;
    private static NupkgMetadataFileFormat();
    public static NupkgMetadataFile Read(string filePath);
    public static NupkgMetadataFile Read(string filePath, ILogger log);
    public static NupkgMetadataFile Read(Stream stream, ILogger log, string path);
    public static NupkgMetadataFile Read(TextReader reader, ILogger log, string path);
    public static void Write(string filePath, NupkgMetadataFile hashFile);
    public static void Write(Stream stream, NupkgMetadataFile hashFile);
    public static void Write(TextWriter textWriter, NupkgMetadataFile hashFile);
    private static JsonSerializerSettings GetSerializerSettings();
}
public class NuGet.Packaging.NuspecReader : NuspecCoreReaderBase {
    private static string Dependencies;
    private static string Group;
    private static string TargetFramework;
    private static string Dependency;
    private static string References;
    private static string Reference;
    private static string File;
    private static string FrameworkAssemblies;
    private static string FrameworkAssembly;
    private static string AssemblyName;
    private static string Language;
    private static string ContentFiles;
    private static string Files;
    private static string BuildAction;
    private static string Flatten;
    private static string CopyToOutput;
    private static string IncludeFlags;
    private static string ExcludeFlags;
    private static string LicenseUrl;
    private static string Repository;
    private static string Icon;
    private static string Readme;
    private static Char[] CommaArray;
    private IFrameworkNameProvider _frameworkProvider;
    private static List`1<string> EmptyList;
    public NuspecReader(string path);
    public NuspecReader(string path, IFrameworkNameProvider frameworkProvider);
    public NuspecReader(Stream stream);
    public NuspecReader(XDocument xml);
    public NuspecReader(Stream stream, IFrameworkNameProvider frameworkProvider, bool leaveStreamOpen);
    public NuspecReader(XDocument xml, IFrameworkNameProvider frameworkProvider);
    private static NuspecReader();
    public IEnumerable`1<PackageDependencyGroup> GetDependencyGroups();
    [IteratorStateMachineAttribute("NuGet.Packaging.NuspecReader/<GetDependencyGroups>d__31")]
public IEnumerable`1<PackageDependencyGroup> GetDependencyGroups(bool useStrictVersionCheck);
    [IteratorStateMachineAttribute("NuGet.Packaging.NuspecReader/<GetReferenceGroups>d__32")]
public IEnumerable`1<FrameworkSpecificGroup> GetReferenceGroups();
    [ObsoleteAttribute("GetFrameworkReferenceGroups() is deprecated. Please use GetFrameworkAssemblyGroups() instead.")]
public IEnumerable`1<FrameworkSpecificGroup> GetFrameworkReferenceGroups();
    public IEnumerable`1<FrameworkSpecificGroup> GetFrameworkAssemblyGroups();
    public string GetLanguage();
    public string GetLicenseUrl();
    [IteratorStateMachineAttribute("NuGet.Packaging.NuspecReader/<GetContentFiles>d__37")]
public IEnumerable`1<ContentFilesEntry> GetContentFiles();
    public string GetTitle();
    public string GetAuthors();
    public string GetTags();
    public string GetOwners();
    public string GetDescription();
    public string GetReleaseNotes();
    public string GetSummary();
    public string GetProjectUrl();
    public string GetIconUrl();
    public string GetCopyright();
    public RepositoryMetadata GetRepositoryMetadata();
    public LicenseMetadata GetLicenseMetadata();
    private static IList`1<string> GetNonStandardLicenseIdentifiers(NuGetLicenseExpression expression);
    public bool GetRequireLicenseAcceptance();
    public IEnumerable`1<FrameworkReferenceGroup> GetFrameworkRefGroups();
    public string GetIcon();
    public string GetReadme();
    private Nullable`1<bool> AttributeAsNullableBool(XElement element, string attributeName);
    private static string GetAttributeValue(XElement element, string attributeName);
    private static List`1<string> GetFlags(string flags);
    private HashSet`1<PackageDependency> GetPackageDependencies(IEnumerable`1<XElement> nodes, bool useStrictVersionCheck);
}
public class NuGet.Packaging.PackageArchiveReader : PackageReaderBase {
    private ZipArchive _zipArchive;
    private SigningSpecifications _signingSpecifications;
    private IEnvironmentVariableReader _environmentVariableReader;
    [CompilerGeneratedAttribute]
private Stream <ZipReadStream>k__BackingField;
    private Nullable`1<bool> _isSigned;
    protected SigningSpecifications SigningSpecifications { get; }
    protected Stream ZipReadStream { get; protected set; }
    private PackageArchiveReader(IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    internal PackageArchiveReader(Stream stream, IEnvironmentVariableReader environmentVariableReader);
    public PackageArchiveReader(Stream stream);
    public PackageArchiveReader(Stream stream, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public PackageArchiveReader(Stream stream, bool leaveStreamOpen);
    public PackageArchiveReader(Stream stream, bool leaveStreamOpen, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public PackageArchiveReader(ZipArchive zipArchive);
    public PackageArchiveReader(ZipArchive zipArchive, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public PackageArchiveReader(string filePath, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    protected SigningSpecifications get_SigningSpecifications();
    [CompilerGeneratedAttribute]
protected Stream get_ZipReadStream();
    [CompilerGeneratedAttribute]
protected void set_ZipReadStream(Stream value);
    public virtual IEnumerable`1<string> GetFiles();
    public virtual IEnumerable`1<string> GetFiles(string folder);
    public virtual Stream GetStream(string path);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageArchiveReader/<CopyNupkgAsync>d__22")]
public virtual Task`1<string> CopyNupkgAsync(string nupkgFilePath, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public virtual IEnumerable`1<string> CopyFiles(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken token);
    public string ExtractFile(string packageFile, string targetFilePath, ILogger logger);
    public ZipArchiveEntry GetEntry(string packageFile);
    [IteratorStateMachineAttribute("NuGet.Packaging.PackageArchiveReader/<EnumeratePackageEntries>d__28")]
public IEnumerable`1<ZipFilePair> EnumeratePackageEntries(IEnumerable`1<string> packageFiles, string packageDirectory);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageArchiveReader/<ValidatePackageEntriesAsync>d__29")]
public Task ValidatePackageEntriesAsync(CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageArchiveReader/<GetPrimarySignatureAsync>d__30")]
public virtual Task`1<PrimarySignature> GetPrimarySignatureAsync(CancellationToken token);
    public virtual Task`1<bool> IsSignedAsync(CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageArchiveReader/<ValidateIntegrityAsync>d__32")]
public virtual Task ValidateIntegrityAsync(SignatureContent signatureContent, CancellationToken token);
    public virtual string GetContentHash(CancellationToken token, Func`1<string> GetUnsignedPackageHash);
    public virtual Task`1<Byte[]> GetArchiveHashAsync(HashAlgorithmName hashAlgorithmName, CancellationToken token);
    public virtual bool CanVerifySignedPackages(SignedPackageVerifierSettings verifierSettings);
    protected void ThrowIfZipReadStreamIsNull();
    private string GetContentHashForSignedPackage(CancellationToken token);
}
public class NuGet.Packaging.PackageBuilder : object {
    private static Uri DefaultUri;
    private static DateTime ZipFormatMinDate;
    private static DateTime ZipFormatMaxDate;
    internal static string ManifestRelationType;
    private bool _includeEmptyDirectories;
    private bool _deterministic;
    private ILogger _logger;
    public static int MaxIconFileSize;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private RepositoryMetadata <Repository>k__BackingField;
    [CompilerGeneratedAttribute]
private LicenseMetadata <LicenseMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSnapshotVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <Authors>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <IconUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Icon>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <LicenseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ProjectUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EmitRequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Serviceable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DevelopmentDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReleaseNotes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputName>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Readme>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<PackageDependencyGroup> <DependencyGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<IPackageFile> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<FrameworkAssemblyReference> <FrameworkReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<FrameworkReferenceGroup> <FrameworkReferenceGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<NuGetFramework> <TargetFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ManifestContentFiles> <ContentFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<PackageReferenceSet> <PackageAssemblyReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<PackageType> <PackageTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <MinClientVersion>k__BackingField;
    private static Char[] HexValues;
    public string Id { get; public set; }
    public NuGetVersion Version { get; public set; }
    public RepositoryMetadata Repository { get; public set; }
    public LicenseMetadata LicenseMetadata { get; public set; }
    public bool HasSnapshotVersion { get; public set; }
    public string Title { get; public set; }
    public ISet`1<string> Authors { get; private set; }
    public ISet`1<string> Owners { get; private set; }
    public Uri IconUrl { get; public set; }
    public string Icon { get; public set; }
    public Uri LicenseUrl { get; public set; }
    public Uri ProjectUrl { get; public set; }
    public bool RequireLicenseAcceptance { get; public set; }
    public bool EmitRequireLicenseAcceptance { get; public set; }
    public bool Serviceable { get; public set; }
    public bool DevelopmentDependency { get; public set; }
    public string Description { get; public set; }
    public string Summary { get; public set; }
    public string ReleaseNotes { get; public set; }
    public string Language { get; public set; }
    public string OutputName { get; public set; }
    public ISet`1<string> Tags { get; private set; }
    public string Readme { get; public set; }
    public Dictionary`2<string, string> Properties { get; private set; }
    public string Copyright { get; public set; }
    public Collection`1<PackageDependencyGroup> DependencyGroups { get; private set; }
    public ICollection`1<IPackageFile> Files { get; private set; }
    public Collection`1<FrameworkAssemblyReference> FrameworkReferences { get; private set; }
    public Collection`1<FrameworkReferenceGroup> FrameworkReferenceGroups { get; private set; }
    public IList`1<NuGetFramework> TargetFrameworks { get; public set; }
    public ICollection`1<ManifestContentFiles> ContentFiles { get; private set; }
    public ICollection`1<PackageReferenceSet> PackageAssemblyReferences { get; public set; }
    public ICollection`1<PackageType> PackageTypes { get; public set; }
    private IEnumerable`1<string> NuGet.Packaging.IPackageMetadata.Authors { get; }
    private IEnumerable`1<string> NuGet.Packaging.IPackageMetadata.Owners { get; }
    private string NuGet.Packaging.IPackageMetadata.Tags { get; }
    private IEnumerable`1<PackageReferenceSet> NuGet.Packaging.IPackageMetadata.PackageAssemblyReferences { get; }
    private IEnumerable`1<PackageDependencyGroup> NuGet.Packaging.IPackageMetadata.DependencyGroups { get; }
    private IEnumerable`1<FrameworkAssemblyReference> NuGet.Packaging.IPackageMetadata.FrameworkReferences { get; }
    private IEnumerable`1<ManifestContentFiles> NuGet.Packaging.IPackageMetadata.ContentFiles { get; }
    private IEnumerable`1<PackageType> NuGet.Packaging.IPackageMetadata.PackageTypes { get; }
    private IEnumerable`1<FrameworkReferenceGroup> NuGet.Packaging.IPackageMetadata.FrameworkReferenceGroups { get; }
    public Version MinClientVersion { get; public set; }
    public PackageBuilder(string path, Func`2<string, string> propertyProvider, bool includeEmptyDirectories);
    public PackageBuilder(string path, Func`2<string, string> propertyProvider, bool includeEmptyDirectories, bool deterministic);
    public PackageBuilder(string path, Func`2<string, string> propertyProvider, bool includeEmptyDirectories, bool deterministic, ILogger logger);
    public PackageBuilder(string path, string basePath, Func`2<string, string> propertyProvider, bool includeEmptyDirectories);
    public PackageBuilder(string path, string basePath, Func`2<string, string> propertyProvider, bool includeEmptyDirectories, bool deterministic, ILogger logger);
    public PackageBuilder(string path, string basePath, Func`2<string, string> propertyProvider, bool includeEmptyDirectories, bool deterministic);
    public PackageBuilder(Stream stream, string basePath);
    public PackageBuilder(Stream stream, string basePath, Func`2<string, string> propertyProvider);
    public PackageBuilder(bool deterministic);
    public PackageBuilder(bool deterministic, ILogger logger);
    private PackageBuilder(bool includeEmptyDirectories, bool deterministic);
    private PackageBuilder(bool includeEmptyDirectories, bool deterministic, ILogger logger);
    private static PackageBuilder();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public sealed virtual RepositoryMetadata get_Repository();
    [CompilerGeneratedAttribute]
public void set_Repository(RepositoryMetadata value);
    [CompilerGeneratedAttribute]
public sealed virtual LicenseMetadata get_LicenseMetadata();
    [CompilerGeneratedAttribute]
public void set_LicenseMetadata(LicenseMetadata value);
    [CompilerGeneratedAttribute]
public bool get_HasSnapshotVersion();
    [CompilerGeneratedAttribute]
public void set_HasSnapshotVersion(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_Authors();
    [CompilerGeneratedAttribute]
private void set_Authors(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_Owners();
    [CompilerGeneratedAttribute]
private void set_Owners(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_IconUrl();
    [CompilerGeneratedAttribute]
public void set_IconUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Icon();
    [CompilerGeneratedAttribute]
public void set_Icon(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_LicenseUrl();
    [CompilerGeneratedAttribute]
public void set_LicenseUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ProjectUrl();
    [CompilerGeneratedAttribute]
public void set_ProjectUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_RequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public bool get_EmitRequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_EmitRequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Serviceable();
    [CompilerGeneratedAttribute]
public void set_Serviceable(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DevelopmentDependency();
    [CompilerGeneratedAttribute]
public void set_DevelopmentDependency(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ReleaseNotes();
    [CompilerGeneratedAttribute]
public void set_ReleaseNotes(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public string get_OutputName();
    [CompilerGeneratedAttribute]
public void set_OutputName(string value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_Tags();
    [CompilerGeneratedAttribute]
private void set_Tags(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Readme();
    [CompilerGeneratedAttribute]
public void set_Readme(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Copyright();
    [CompilerGeneratedAttribute]
public void set_Copyright(string value);
    [CompilerGeneratedAttribute]
public Collection`1<PackageDependencyGroup> get_DependencyGroups();
    [CompilerGeneratedAttribute]
private void set_DependencyGroups(Collection`1<PackageDependencyGroup> value);
    [CompilerGeneratedAttribute]
public ICollection`1<IPackageFile> get_Files();
    [CompilerGeneratedAttribute]
private void set_Files(ICollection`1<IPackageFile> value);
    [CompilerGeneratedAttribute]
public Collection`1<FrameworkAssemblyReference> get_FrameworkReferences();
    [CompilerGeneratedAttribute]
private void set_FrameworkReferences(Collection`1<FrameworkAssemblyReference> value);
    [CompilerGeneratedAttribute]
public Collection`1<FrameworkReferenceGroup> get_FrameworkReferenceGroups();
    [CompilerGeneratedAttribute]
private void set_FrameworkReferenceGroups(Collection`1<FrameworkReferenceGroup> value);
    [CompilerGeneratedAttribute]
public IList`1<NuGetFramework> get_TargetFrameworks();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworks(IList`1<NuGetFramework> value);
    [CompilerGeneratedAttribute]
public ICollection`1<ManifestContentFiles> get_ContentFiles();
    [CompilerGeneratedAttribute]
private void set_ContentFiles(ICollection`1<ManifestContentFiles> value);
    [CompilerGeneratedAttribute]
public ICollection`1<PackageReferenceSet> get_PackageAssemblyReferences();
    [CompilerGeneratedAttribute]
public void set_PackageAssemblyReferences(ICollection`1<PackageReferenceSet> value);
    [CompilerGeneratedAttribute]
public ICollection`1<PackageType> get_PackageTypes();
    [CompilerGeneratedAttribute]
public void set_PackageTypes(ICollection`1<PackageType> value);
    private sealed virtual override IEnumerable`1<string> NuGet.Packaging.IPackageMetadata.get_Authors();
    private sealed virtual override IEnumerable`1<string> NuGet.Packaging.IPackageMetadata.get_Owners();
    private sealed virtual override string NuGet.Packaging.IPackageMetadata.get_Tags();
    private sealed virtual override IEnumerable`1<PackageReferenceSet> NuGet.Packaging.IPackageMetadata.get_PackageAssemblyReferences();
    private sealed virtual override IEnumerable`1<PackageDependencyGroup> NuGet.Packaging.IPackageMetadata.get_DependencyGroups();
    private sealed virtual override IEnumerable`1<FrameworkAssemblyReference> NuGet.Packaging.IPackageMetadata.get_FrameworkReferences();
    private sealed virtual override IEnumerable`1<ManifestContentFiles> NuGet.Packaging.IPackageMetadata.get_ContentFiles();
    private sealed virtual override IEnumerable`1<PackageType> NuGet.Packaging.IPackageMetadata.get_PackageTypes();
    private sealed virtual override IEnumerable`1<FrameworkReferenceGroup> NuGet.Packaging.IPackageMetadata.get_FrameworkReferenceGroups();
    [CompilerGeneratedAttribute]
public sealed virtual Version get_MinClientVersion();
    [CompilerGeneratedAttribute]
public void set_MinClientVersion(Version value);
    public void Save(Stream stream);
    private static Byte[] ReadAllBytes(Stream stream);
    private string CalcPsmdcpName();
    internal static string EncodeHexString(Byte[] sArray);
    private static string CreatorInfo();
    private static int DetermineMinimumSchemaVersion(ICollection`1<IPackageFile> Files, ICollection`1<PackageDependencyGroup> package);
    private static bool RequiresV4TargetFrameworkSchema(ICollection`1<IPackageFile> files);
    private static bool HasContentFilesV2(ICollection`1<IPackageFile> contentFiles);
    private static bool HasIncludeExclude(IEnumerable`1<PackageDependencyGroup> dependencyGroups);
    private static bool HasXdtTransformFile(ICollection`1<IPackageFile> contentFiles);
    private static void ValidateDependencies(SemanticVersion version, IEnumerable`1<PackageDependencyGroup> dependencies);
    public static void ValidateReferenceAssemblies(IEnumerable`1<IPackageFile> files, IEnumerable`1<PackageReferenceSet> packageAssemblyReferences);
    private static void ValidateFrameworkAssemblies(IEnumerable`1<FrameworkAssemblyReference> references, IEnumerable`1<FrameworkReferenceGroup> referenceGroups);
    private static IPackageFile FindFileInPackage(string filePath, IEnumerable`1<IPackageFile> packageFiles, String& filePathIncorrectCase);
    private void ValidateFilesUnique(IEnumerable`1<IPackageFile> files);
    private void ValidateLicenseFile(IEnumerable`1<IPackageFile> files, LicenseMetadata licenseMetadata);
    private void ValidateIconFile(IEnumerable`1<IPackageFile> files, string iconPath);
    private static void ValidateFileFrameworks(IEnumerable`1<IPackageFile> files);
    private void ValidateReadmeFile(IEnumerable`1<IPackageFile> files, string readmePath);
    private void ReadManifest(Stream stream, string basePath, Func`2<string, string> propertyProvider);
    public void Populate(ManifestMetadata manifestMetadata);
    public void PopulateFiles(string basePath, IEnumerable`1<ManifestFile> files);
    private ZipArchiveEntry CreateEntry(ZipArchive package, string entryName, CompressionLevel compressionLevel);
    private static ZipArchiveEntry CreatePackageFileEntry(ZipArchive package, string entryName, DateTimeOffset timeOffset, CompressionLevel compressionLevel, StringBuilder warningMessage);
    private void WriteManifest(ZipArchive package, int minimumManifestVersion, string psmdcpPath);
    private HashSet`1<string> WriteFiles(ZipArchive package, HashSet`1<string> filesWithoutExtensions);
    public void AddFiles(string basePath, string source, string destination, string exclude);
    internal static IEnumerable`1<PhysicalPackageFile> ResolveSearchPattern(string basePath, string searchPath, string targetPath, bool includeEmptyDirectories);
    internal static string ResolvePackagePath(string searchDirectory, string searchPattern, string fullPath, string targetPath);
    private static bool IsKnownFolder(string targetPath);
    private static void ExcludeFiles(List`1<PhysicalPackageFile> searchFiles, string basePath, string exclude);
    private void CreatePart(ZipArchive package, string path, Stream sourceStream, DateTimeOffset lastWriteTime, StringBuilder warningMessage);
    internal static string CreatePartEntryName(string path);
    internal static string GetStringForPartUri(string escapedPath);
    private static IEnumerable`1<string> ParseTags(string tags);
    private void WriteOpcManifestRelationship(ZipArchive package, string path, string psmdcpPath);
    private void WriteOpcContentTypes(ZipArchive package, HashSet`1<string> extensions, HashSet`1<string> filesWithoutExtensions);
    private void WriteOpcPackageProperties(ZipArchive package, string psmdcpPath);
    private string GenerateRelationshipId(string path);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Packaging.PackageCreation.Resources.NuGetResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CannotCreateEmptyPackage { get; }
    internal static string DependencyHasInvalidVersion { get; }
    internal static string DuplicateDependenciesDefined { get; }
    internal static string FoundDuplicateFile { get; }
    internal static string IconCannotOpenFile { get; }
    internal static string IconErrorEmpty { get; }
    internal static string IconInvalidExtension { get; }
    internal static string IconMaxFileSizeExceeded { get; }
    internal static string IconMissingRequiredValue { get; }
    internal static string IconNoFileElement { get; }
    internal static string IconNoFileElementWithHint { get; }
    internal static string IncompatibleSchema { get; }
    internal static string InvalidPackageId { get; }
    internal static string Manifest_DependenciesHasMixedElements { get; }
    internal static string Manifest_ExcludeContainsInvalidCharacters { get; }
    internal static string Manifest_IdMaxLengthExceeded { get; }
    internal static string Manifest_InvalidMinClientVersion { get; }
    internal static string Manifest_InvalidReference { get; }
    internal static string Manifest_InvalidReferenceFile { get; }
    internal static string Manifest_LicenseFileExtensionIsInvalid { get; }
    internal static string Manifest_LicenseFileIsNotInNupkg { get; }
    internal static string Manifest_LicenseFileIsNotInNupkgWithHint { get; }
    internal static string Manifest_LicenseUrlCannotBeUsedWithLicenseMetadata { get; }
    internal static string Manifest_PropertyValueReadFailure { get; }
    internal static string Manifest_ReferencesHasMixedElements { get; }
    internal static string Manifest_ReferencesIsEmpty { get; }
    internal static string Manifest_RequiredElementMissing { get; }
    internal static string Manifest_RequiredMetadataMissing { get; }
    internal static string Manifest_RequireLicenseAcceptanceRequiresEmit { get; }
    internal static string Manifest_RequireLicenseAcceptanceRequiresLicenseUrl { get; }
    internal static string Manifest_SourceContainsInvalidCharacters { get; }
    internal static string Manifest_TargetContainsInvalidCharacters { get; }
    internal static string Manifest_UriCannotBeEmpty { get; }
    internal static string PackageAuthoring_FileNotFound { get; }
    internal static string ReadmeCannotOpenFile { get; }
    internal static string ReadmeErrorEmpty { get; }
    internal static string ReadmeFileExtensionIsInvalid { get; }
    internal static string ReadmeMissingRequiredValue { get; }
    internal static string ReadmeNoFileElement { get; }
    internal static string UnknownSchemaVersion { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CannotCreateEmptyPackage();
    internal static string get_DependencyHasInvalidVersion();
    internal static string get_DuplicateDependenciesDefined();
    internal static string get_FoundDuplicateFile();
    internal static string get_IconCannotOpenFile();
    internal static string get_IconErrorEmpty();
    internal static string get_IconInvalidExtension();
    internal static string get_IconMaxFileSizeExceeded();
    internal static string get_IconMissingRequiredValue();
    internal static string get_IconNoFileElement();
    internal static string get_IconNoFileElementWithHint();
    internal static string get_IncompatibleSchema();
    internal static string get_InvalidPackageId();
    internal static string get_Manifest_DependenciesHasMixedElements();
    internal static string get_Manifest_ExcludeContainsInvalidCharacters();
    internal static string get_Manifest_IdMaxLengthExceeded();
    internal static string get_Manifest_InvalidMinClientVersion();
    internal static string get_Manifest_InvalidReference();
    internal static string get_Manifest_InvalidReferenceFile();
    internal static string get_Manifest_LicenseFileExtensionIsInvalid();
    internal static string get_Manifest_LicenseFileIsNotInNupkg();
    internal static string get_Manifest_LicenseFileIsNotInNupkgWithHint();
    internal static string get_Manifest_LicenseUrlCannotBeUsedWithLicenseMetadata();
    internal static string get_Manifest_PropertyValueReadFailure();
    internal static string get_Manifest_ReferencesHasMixedElements();
    internal static string get_Manifest_ReferencesIsEmpty();
    internal static string get_Manifest_RequiredElementMissing();
    internal static string get_Manifest_RequiredMetadataMissing();
    internal static string get_Manifest_RequireLicenseAcceptanceRequiresEmit();
    internal static string get_Manifest_RequireLicenseAcceptanceRequiresLicenseUrl();
    internal static string get_Manifest_SourceContainsInvalidCharacters();
    internal static string get_Manifest_TargetContainsInvalidCharacters();
    internal static string get_Manifest_UriCannotBeEmpty();
    internal static string get_PackageAuthoring_FileNotFound();
    internal static string get_ReadmeCannotOpenFile();
    internal static string get_ReadmeErrorEmpty();
    internal static string get_ReadmeFileExtensionIsInvalid();
    internal static string get_ReadmeMissingRequiredValue();
    internal static string get_ReadmeNoFileElement();
    internal static string get_UnknownSchemaVersion();
}
public class NuGet.Packaging.PackageDependencyGroup : object {
    private NuGetFramework _targetFramework;
    private IEnumerable`1<PackageDependency> _packages;
    public NuGetFramework TargetFramework { get; }
    public IEnumerable`1<PackageDependency> Packages { get; }
    public PackageDependencyGroup(NuGetFramework targetFramework, IEnumerable`1<PackageDependency> packages);
    public sealed virtual NuGetFramework get_TargetFramework();
    public IEnumerable`1<PackageDependency> get_Packages();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PackageDependencyGroup other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public static class NuGet.Packaging.PackageExtraction.PackageExtractionBehavior : object {
    private static string XmlDocFileSaveModeEnvironmentKey;
    private static Nullable`1<XmlDocFileSaveMode> _xmlDocFileSaveMode;
    public static XmlDocFileSaveMode XmlDocFileSaveMode { get; public set; }
    public static XmlDocFileSaveMode get_XmlDocFileSaveMode();
    public static void set_XmlDocFileSaveMode(XmlDocFileSaveMode value);
}
public class NuGet.Packaging.PackageExtractionContext : object {
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSaveMode <PackageSaveMode>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDocFileSaveMode <XmlDocFileSaveMode>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientPolicyContext <ClientPolicyContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CopySatelliteFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IPackageSignatureVerifier <SignedPackageVerifier>k__BackingField;
    public ILogger Logger { get; }
    public PackageSaveMode PackageSaveMode { get; public set; }
    public XmlDocFileSaveMode XmlDocFileSaveMode { get; public set; }
    public ClientPolicyContext ClientPolicyContext { get; }
    public bool CopySatelliteFiles { get; public set; }
    public IPackageSignatureVerifier SignedPackageVerifier { get; public set; }
    public PackageExtractionContext(PackageSaveMode packageSaveMode, XmlDocFileSaveMode xmlDocFileSaveMode, ClientPolicyContext clientPolicyContext, ILogger logger);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public PackageSaveMode get_PackageSaveMode();
    [CompilerGeneratedAttribute]
public void set_PackageSaveMode(PackageSaveMode value);
    [CompilerGeneratedAttribute]
public XmlDocFileSaveMode get_XmlDocFileSaveMode();
    [CompilerGeneratedAttribute]
public void set_XmlDocFileSaveMode(XmlDocFileSaveMode value);
    [CompilerGeneratedAttribute]
public ClientPolicyContext get_ClientPolicyContext();
    [CompilerGeneratedAttribute]
public bool get_CopySatelliteFiles();
    [CompilerGeneratedAttribute]
public void set_CopySatelliteFiles(bool value);
    [CompilerGeneratedAttribute]
public IPackageSignatureVerifier get_SignedPackageVerifier();
    [CompilerGeneratedAttribute]
public void set_SignedPackageVerifier(IPackageSignatureVerifier value);
}
public class NuGet.Packaging.PackageExtractionResult : object {
    [CompilerGeneratedAttribute]
private bool <Cached>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <SignVerifyDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSignType <PackageType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <SignVerifyStartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <SignVerifyEndTime>k__BackingField;
    public bool Cached { get; }
    public TimeSpan SignVerifyDelay { get; }
    public PackageSignType PackageType { get; }
    public bool Success { get; }
    public TimeSpan Duration { get; public set; }
    public DateTimeOffset SignVerifyStartTime { get; }
    public DateTimeOffset SignVerifyEndTime { get; }
    public PackageExtractionResult(bool cached, TimeSpan signVerifyDelay, PackageSignType packageType, bool success, DateTimeOffset signVerifyStartTime, DateTimeOffset signVerifyEndTime);
    public PackageExtractionResult(bool cached, TimeSpan signVerifyDelay, PackageSignType packageType, bool success, TimeSpan duration);
    [CompilerGeneratedAttribute]
public bool get_Cached();
    [CompilerGeneratedAttribute]
public TimeSpan get_SignVerifyDelay();
    [CompilerGeneratedAttribute]
public PackageSignType get_PackageType();
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_SignVerifyStartTime();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_SignVerifyEndTime();
}
public class NuGet.Packaging.PackageExtractionTelemetryEvent : TelemetryEvent {
    public static string EventName;
    public PackageSaveMode PackageSaveMode { get; }
    public NuGetOperationStatus Status { get; }
    public ExtractionSource ExtractionSource { get; }
    public string PackageId { get; }
    public string PackageVersion { get; }
    public PackageExtractionTelemetryEvent(PackageSaveMode packageSaveMode, NuGetOperationStatus status, ExtractionSource extractionSource, PackageIdentity packageId);
    public PackageSaveMode get_PackageSaveMode();
    public NuGetOperationStatus get_Status();
    public ExtractionSource get_ExtractionSource();
    public string get_PackageId();
    public string get_PackageVersion();
    public void LogPackageIdentity(PackageIdentity packageId);
    public void SetResult(NuGetOperationStatus status);
}
public static class NuGet.Packaging.PackageExtractor : object {
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<ExtractPackageAsync>d__0")]
public static Task`1<IEnumerable`1<string>> ExtractPackageAsync(string source, Stream packageStream, PackagePathResolver packagePathResolver, PackageExtractionContext packageExtractionContext, CancellationToken token, Guid parentId);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<ExtractPackageAsync>d__1")]
public static Task`1<IEnumerable`1<string>> ExtractPackageAsync(string source, PackageReaderBase packageReader, Stream packageStream, PackagePathResolver packagePathResolver, PackageExtractionContext packageExtractionContext, CancellationToken token, Guid parentId);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<ExtractPackageAsync>d__2")]
public static Task`1<IEnumerable`1<string>> ExtractPackageAsync(string source, PackageReaderBase packageReader, PackagePathResolver packagePathResolver, PackageExtractionContext packageExtractionContext, CancellationToken token, Guid parentId);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<InstallFromSourceAsync>d__3")]
public static Task`1<bool> InstallFromSourceAsync(string source, PackageIdentity packageIdentity, Func`2<Stream, Task> copyToAsync, VersionFolderPathResolver versionFolderPathResolver, PackageExtractionContext packageExtractionContext, CancellationToken token, Guid parentId);
    private static void DeleteTargetAndTempPaths(string targetPath, string targetTempNupkg);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<InstallFromSourceAsync>d__5")]
public static Task`1<bool> InstallFromSourceAsync(PackageIdentity packageIdentity, IPackageDownloader packageDownloader, VersionFolderPathResolver versionFolderPathResolver, PackageExtractionContext packageExtractionContext, CancellationToken token, Guid parentId);
    private static bool ShouldInclude(string fullName, string hashFileName, string nupkgMetadataFileName);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<CopySatelliteFilesAsync>d__7")]
public static Task`1<IEnumerable`1<string>> CopySatelliteFilesAsync(PackageIdentity packageIdentity, PackagePathResolver packagePathResolver, PackageSaveMode packageSaveMode, PackageExtractionContext packageExtractionContext, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<CopySatelliteFilesAsync>d__8")]
private static Task`1<IEnumerable`1<string>> CopySatelliteFilesAsync(PackageReaderBase packageReader, PackagePathResolver packagePathResolver, PackageSaveMode packageSaveMode, PackageExtractionContext packageExtractionContext, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<VerifyPackageSignatureAsync>d__9")]
private static Task VerifyPackageSignatureAsync(string source, Guid parentId, PackageIdentity package, PackageExtractionContext packageExtractionContext, ISignedPackageReader signedPackageReader, CancellationToken token);
    private static void UpdateSignatureLog(string source, PackageIdentity package, ClientPolicyContext policyContext, SignatureLog message);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<LogPackageSignatureVerificationAsync>d__11")]
private static Task LogPackageSignatureVerificationAsync(string source, PackageIdentity package, ILogger logger, VerifySignaturesResult verifyResult);
    private static RepositorySignatureInfo GetRepositorySignatureInfo(string source);
}
public class NuGet.Packaging.PackageFileExtractor : object {
    private HashSet`1<string> _intellisenseXmlFiles;
    private XmlDocFileSaveMode _xmlDocFileSaveMode;
    public PackageFileExtractor(IEnumerable`1<string> packageFiles, XmlDocFileSaveMode xmlDocFileSaveMode);
    private static HashSet`1<string> GatherIntellisenseXmlFiles(IEnumerable`1<string> packageFiles);
    private static string GetBinaryForLanguageSpecificXml(string file);
    public string ExtractPackageFile(string source, string target, Stream stream);
}
public class NuGet.Packaging.PackageFolderReader : PackageReaderBase {
    private DirectoryInfo _root;
    public PackageFolderReader(string folderPath);
    public PackageFolderReader(DirectoryInfo folder);
    public PackageFolderReader(string folderPath, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public PackageFolderReader(DirectoryInfo folder, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public virtual string GetNuspecFile();
    public virtual Stream GetStream(string path);
    private FileInfo GetFile(string path);
    public virtual IEnumerable`1<string> GetFiles();
    [IteratorStateMachineAttribute("NuGet.Packaging.PackageFolderReader/<GetFiles>d__9")]
public virtual IEnumerable`1<string> GetFiles(string folder);
    private static bool IsFileInRoot(string path);
    private static bool IsNupkg(string path);
    private static string GetRelativePath(DirectoryInfo root, FileInfo file);
    public virtual IEnumerable`1<string> CopyFiles(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken token);
    protected virtual void Dispose(bool disposing);
    public virtual Task`1<PrimarySignature> GetPrimarySignatureAsync(CancellationToken token);
    public virtual Task`1<bool> IsSignedAsync(CancellationToken token);
    public virtual Task ValidateIntegrityAsync(SignatureContent signatureContent, CancellationToken token);
    public virtual Task`1<Byte[]> GetArchiveHashAsync(HashAlgorithmName hashAlgorithm, CancellationToken token);
    public virtual bool CanVerifySignedPackages(SignedPackageVerifierSettings verifierSettings);
    public virtual string GetContentHash(CancellationToken token, Func`1<string> GetUnsignedPackageHash);
}
public static class NuGet.Packaging.PackageHelper : object {
    private static String[] ExcludePaths;
    private static Char[] Slashes;
    private static PackageHelper();
    public static bool IsAssembly(string path);
    public static bool IsNuspec(string path);
    public static bool IsManifest(string path);
    public static bool IsRoot(string path);
    public static bool IsPackageFile(string packageFileName, PackageSaveMode packageSaveMode);
    private static bool IsNuGetGeneratedFile(string path);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageHelper/<GetSatellitePackageInfoAsync>d__8")]
private static Task`1<SatellitePackageInfo> GetSatellitePackageInfoAsync(IAsyncPackageCoreReader packageReader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageHelper/<GetSatelliteFilesAsync>d__9")]
public static Task`1<Tuple`2<string, IEnumerable`1<string>>> GetSatelliteFilesAsync(PackageReaderBase packageReader, PackagePathResolver packagePathResolver, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageHelper/<GetInstalledPackageFilesAsync>d__10")]
public static Task`1<IEnumerable`1<ZipFilePair>> GetInstalledPackageFilesAsync(PackageArchiveReader packageReader, PackageIdentity packageIdentity, PackagePathResolver packagePathResolver, PackageSaveMode packageSaveMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageHelper/<GetInstalledSatelliteFilesAsync>d__11")]
public static Task`1<Tuple`2<string, IEnumerable`1<ZipFilePair>>> GetInstalledSatelliteFilesAsync(PackageArchiveReader packageReader, PackagePathResolver packagePathResolver, PackageSaveMode packageSaveMode, CancellationToken cancellationToken);
}
public static class NuGet.Packaging.PackageIdValidator : object {
    public static int MaxPackageIdLength;
    private static Regex IdRegex;
    private static PackageIdValidator();
    public static bool IsValidPackageId(string packageId);
    public static void ValidatePackageId(string packageId);
}
public static class NuGet.Packaging.PackagePathHelper : object {
    internal static IEnumerable`1<string> GetFiles(string root, string path, string filter, bool recursive);
    internal static IEnumerable`1<string> GetDirectories(string root, string path);
    [IteratorStateMachineAttribute("NuGet.Packaging.PackagePathHelper/<GetPackageFiles>d__2")]
private static IEnumerable`1<string> GetPackageFiles(string root, string filter);
    private static bool FileNameMatchesPattern(PackageIdentity packageIdentity, string path);
    public static IEnumerable`1<string> GetPackageLookupPaths(PackageIdentity packageIdentity, PackagePathResolver packagePathResolver);
    public static string GetInstalledPackageFilePath(PackageIdentity packageIdentity, PackagePathResolver packagePathResolver);
}
public class NuGet.Packaging.PackagePathResolver : object {
    private string _rootDirectory;
    [CompilerGeneratedAttribute]
private bool <UseSideBySidePaths>k__BackingField;
    public bool UseSideBySidePaths { get; }
    protected internal string Root { get; }
    public PackagePathResolver(string rootDirectory, bool useSideBySidePaths);
    [CompilerGeneratedAttribute]
public bool get_UseSideBySidePaths();
    protected internal string get_Root();
    public virtual string GetPackageDirectoryName(PackageIdentity packageIdentity);
    public virtual string GetPackageFileName(PackageIdentity packageIdentity);
    public string GetPackageDownloadMarkerFileName(PackageIdentity packageIdentity);
    public string GetManifestFileName(PackageIdentity packageIdentity);
    public virtual string GetInstallPath(PackageIdentity packageIdentity);
    public virtual string GetInstalledPath(PackageIdentity packageIdentity);
    public virtual string GetInstalledPackageFilePath(PackageIdentity packageIdentity);
    private string GetId(PackageIdentity identity);
    private string GetVersion(PackageIdentity identity);
    private StringBuilder GetPathBase(PackageIdentity packageIdentity);
}
public abstract class NuGet.Packaging.PackageReaderBase : object {
    private NuspecReader _nuspecReader;
    [CompilerGeneratedAttribute]
private IFrameworkNameProvider <FrameworkProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IFrameworkCompatibilityProvider <CompatibilityProvider>k__BackingField;
    protected IFrameworkNameProvider FrameworkProvider { get; protected set; }
    protected IFrameworkCompatibilityProvider CompatibilityProvider { get; protected set; }
    public NuspecReader NuspecReader { get; }
    public PackageReaderBase(IFrameworkNameProvider frameworkProvider);
    public PackageReaderBase(IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    [CompilerGeneratedAttribute]
protected IFrameworkNameProvider get_FrameworkProvider();
    [CompilerGeneratedAttribute]
protected void set_FrameworkProvider(IFrameworkNameProvider value);
    [CompilerGeneratedAttribute]
protected IFrameworkCompatibilityProvider get_CompatibilityProvider();
    [CompilerGeneratedAttribute]
protected void set_CompatibilityProvider(IFrameworkCompatibilityProvider value);
    public abstract virtual Stream GetStream(string path);
    public abstract virtual IEnumerable`1<string> GetFiles();
    public abstract virtual IEnumerable`1<string> GetFiles(string folder);
    public abstract virtual IEnumerable`1<string> CopyFiles(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken token);
    public virtual PackageIdentity GetIdentity();
    public virtual NuGetVersion GetMinClientVersion();
    public virtual IReadOnlyList`1<PackageType> GetPackageTypes();
    public virtual Stream GetNuspec();
    public virtual string GetNuspecFile();
    public virtual NuspecReader get_NuspecReader();
    public virtual Task`1<PackageIdentity> GetIdentityAsync(CancellationToken cancellationToken);
    public virtual Task`1<NuGetVersion> GetMinClientVersionAsync(CancellationToken cancellationToken);
    public virtual Task`1<IReadOnlyList`1<PackageType>> GetPackageTypesAsync(CancellationToken cancellationToken);
    public virtual Task`1<Stream> GetStreamAsync(string path, CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<string>> GetFilesAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<string>> GetFilesAsync(string folder, CancellationToken cancellationToken);
    public virtual Task`1<Stream> GetNuspecAsync(CancellationToken cancellationToken);
    public virtual Task`1<string> GetNuspecFileAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<string>> CopyFilesAsync(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetFrameworkItems();
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetBuildItems();
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetToolItems();
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetContentItems();
    public virtual IEnumerable`1<PackageDependencyGroup> GetPackageDependencies();
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetLibItems();
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetReferenceItems();
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetFrameworkItemsAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetBuildItemsAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetToolItemsAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetContentItemsAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetLibItemsAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetReferenceItemsAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<PackageDependencyGroup>> GetPackageDependenciesAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<NuGetFramework> GetSupportedFrameworks();
    public virtual Task`1<IEnumerable`1<NuGetFramework>> GetSupportedFrameworksAsync(CancellationToken cancellationToken);
    public virtual bool IsServiceable();
    public virtual Task`1<bool> IsServiceableAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetItems(string folderName);
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetItemsAsync(string folderName, CancellationToken cancellationToken);
    public virtual bool GetDevelopmentDependency();
    public virtual Task`1<bool> GetDevelopmentDependencyAsync(CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("NuGet.Packaging.PackageReaderBase/<GetFileGroups>d__55")]
protected IEnumerable`1<FrameworkSpecificGroup> GetFileGroups(string folder);
    protected NuGetFramework GetFrameworkFromPath(string path, bool allowSubFolders);
    protected static bool IsAllowedBuildFile(string packageId, string path);
    protected static bool IsReferenceAssembly(string path);
    protected static string GetNuspecFile(IEnumerable`1<string> files);
    protected static void ValidatePackageEntry(string normalizedDestination, string normalizedFilePath, PackageIdentity packageIdentity);
    protected string NormalizeDirectoryPath(string path);
    protected static void ValidatePackageEntries(string normalizedDestination, IEnumerable`1<string> packageFiles, PackageIdentity packageIdentity);
    public virtual Task`1<NuspecReader> GetNuspecReaderAsync(CancellationToken cancellationToken);
    public virtual Task`1<string> CopyNupkgAsync(string nupkgFilePath, CancellationToken cancellationToken);
    public abstract virtual Task`1<PrimarySignature> GetPrimarySignatureAsync(CancellationToken token);
    public abstract virtual Task`1<bool> IsSignedAsync(CancellationToken token);
    public abstract virtual Task ValidateIntegrityAsync(SignatureContent signatureContent, CancellationToken token);
    public abstract virtual Task`1<Byte[]> GetArchiveHashAsync(HashAlgorithmName hashAlgorithm, CancellationToken token);
    public abstract virtual bool CanVerifySignedPackages(SignedPackageVerifierSettings verifierSettings);
    public abstract virtual string GetContentHash(CancellationToken token, Func`1<string> GetUnsignedPackageHash);
}
[ExtensionAttribute]
public static class NuGet.Packaging.PackageReaderExtensions : object {
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageReaderExtensions/<GetPackageFilesAsync>d__0")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<string>> GetPackageFilesAsync(IAsyncPackageCoreReader packageReader, PackageSaveMode packageSaveMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageReaderExtensions/<GetSatelliteFilesAsync>d__1")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<string>> GetSatelliteFilesAsync(IAsyncPackageContentReader packageReader, string packageLanguage, CancellationToken cancellationToken);
}
[DebuggerDisplayAttribute("{PackageIdentity} {TargetFramework}")]
public class NuGet.Packaging.PackageReference : object {
    [CompilerGeneratedAttribute]
private PackageIdentity <PackageIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <AllowedVersions>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDevelopmentDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUserInstalled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireReinstallation>k__BackingField;
    public PackageIdentity PackageIdentity { get; }
    public VersionRange AllowedVersions { get; }
    public bool HasAllowedVersions { get; }
    public NuGetFramework TargetFramework { get; }
    public bool IsDevelopmentDependency { get; }
    public bool IsUserInstalled { get; }
    public bool RequireReinstallation { get; }
    public PackageReference(PackageIdentity identity, NuGetFramework targetFramework);
    public PackageReference(PackageIdentity identity, NuGetFramework targetFramework, bool userInstalled);
    public PackageReference(PackageIdentity identity, NuGetFramework targetFramework, bool userInstalled, bool developmentDependency, bool requireReinstallation);
    public PackageReference(PackageIdentity identity, NuGetFramework targetFramework, bool userInstalled, bool developmentDependency, bool requireReinstallation, VersionRange allowedVersions);
    [CompilerGeneratedAttribute]
public PackageIdentity get_PackageIdentity();
    [CompilerGeneratedAttribute]
public VersionRange get_AllowedVersions();
    public bool get_HasAllowedVersions();
    [CompilerGeneratedAttribute]
public NuGetFramework get_TargetFramework();
    [CompilerGeneratedAttribute]
public bool get_IsDevelopmentDependency();
    [CompilerGeneratedAttribute]
public bool get_IsUserInstalled();
    [CompilerGeneratedAttribute]
public bool get_RequireReinstallation();
    public virtual string ToString();
}
public class NuGet.Packaging.PackageReferenceSet : object {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <References>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    public IReadOnlyCollection`1<string> References { get; }
    public NuGetFramework TargetFramework { get; }
    public PackageReferenceSet(IEnumerable`1<string> references);
    public PackageReferenceSet(string targetFramework, IEnumerable`1<string> references);
    public PackageReferenceSet(NuGetFramework targetFramework, IEnumerable`1<string> references);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_References();
    [CompilerGeneratedAttribute]
public NuGetFramework get_TargetFramework();
    [IteratorStateMachineAttribute("NuGet.Packaging.PackageReferenceSet/<Validate>d__9")]
public IEnumerable`1<string> Validate();
}
[FlagsAttribute]
public enum NuGet.Packaging.PackageSaveMode : Enum {
    public int value__;
    public static PackageSaveMode None;
    public static PackageSaveMode Nuspec;
    public static PackageSaveMode Nupkg;
    public static PackageSaveMode Files;
    public static PackageSaveMode Defaultv2;
    public static PackageSaveMode Defaultv3;
}
public static class NuGet.Packaging.PackagesConfig : object {
    public static string PackagesNodeName;
    public static string PackageNodeName;
    public static string IdAttributeName;
    public static string VersionAttributeName;
    public static string TargetFrameworkAttributeName;
    public static string MinClientAttributeName;
    public static string developmentDependencyAttributeName;
    public static string allowedVersionsAttributeName;
    public static string RequireInstallAttributeName;
    public static string UserInstalledAttributeName;
    private static PackagesConfig();
    public static bool TryGetAttribute(XElement node, string name, String& value);
    public static bool HasAttributeValue(XElement node, string attributeName, string targetValue, XElement& element);
    public static bool BoolAttribute(XElement node, string name, bool defaultValue);
}
public class NuGet.Packaging.PackagesConfigReader : object {
    private XDocument _doc;
    private IFrameworkNameProvider _frameworkMappings;
    public PackagesConfigReader(XDocument xml);
    public PackagesConfigReader(IFrameworkNameProvider frameworkMappings, XDocument xml);
    public PackagesConfigReader(Stream stream);
    public PackagesConfigReader(Stream stream, bool leaveStreamOpen);
    public PackagesConfigReader(IFrameworkNameProvider frameworkMappings, Stream stream, bool leaveStreamOpen);
    public NuGetVersion GetMinClientVersion();
    public IEnumerable`1<PackageReference> GetPackages();
    public IEnumerable`1<PackageReference> GetPackages(bool allowDuplicatePackageIds);
}
public class NuGet.Packaging.PackagesConfigReaderException : PackagingException {
    public PackagesConfigReaderException(string message);
    public PackagesConfigReaderException(string message, Exception innerException);
}
public class NuGet.Packaging.PackagesConfigWriter : object {
    private Stream _stream;
    private string _filePath;
    private bool _disposed;
    private NuGetVersion _minClientVersion;
    private IFrameworkNameProvider _frameworkMappings;
    private XDocument _xDocument;
    public PackagesConfigWriter(string fullPath, bool createNew);
    public PackagesConfigWriter(string fullPath, bool createNew, IFrameworkNameProvider frameworkMappings);
    public PackagesConfigWriter(Stream stream, bool createNew);
    public PackagesConfigWriter(Stream stream, bool createNew, IFrameworkNameProvider frameworkMappings);
    public void WriteMinClientVersion(NuGetVersion version);
    public void AddPackageEntry(string packageId, NuGetVersion version, NuGetFramework targetFramework);
    public void AddPackageEntry(PackageIdentity identity, NuGetFramework targetFramework);
    public void AddPackageEntry(PackageReference entry);
    public void UpdatePackageEntry(PackageReference oldEntry, PackageReference newEntry);
    public void UpdateOrAddPackageEntry(XDocument originalConfig, PackageReference newEntry);
    public void RemovePackageEntry(string packageId, NuGetVersion version, NuGetFramework targetFramework);
    public void RemovePackageEntry(PackageIdentity identity, NuGetFramework targetFramework);
    public void RemovePackageEntry(PackageReference entry);
    private XElement CreateXElementForPackageEntry(PackageReference entry);
    private void CreateDefaultXDocument();
    private XElement EnsurePackagesNode();
    private XElement FindMatchingPackageNode(PackageReference entry, XElement packagesNode);
    private XElement ReplacePackageAttributes(XElement existingNode, PackageReference newEntry);
    private void SortPackageNodes(XElement packagesNode);
    private void WriteFile();
    public void WriteFile(string fullPath);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class NuGet.Packaging.PackagesConfigWriterException : PackagingException {
    public PackagesConfigWriterException(string message);
    public PackagesConfigWriterException(string message, Exception innerException);
}
public class NuGet.Packaging.PackageSigningTelemetryEvent : TelemetryEvent {
    public static string EventName;
    public PackageSignType PackageSignType { get; }
    public NuGetOperationStatus Status { get; }
    public string ExtractionId { get; }
    public PackageSignType get_PackageSignType();
    public NuGetOperationStatus get_Status();
    public string get_ExtractionId();
    public void SetResult(PackageSignType packageSignType, NuGetOperationStatus status);
}
public enum NuGet.Packaging.PackageSignType : Enum {
    public int value__;
    public static PackageSignType Signed;
    public static PackageSignType Unsigned;
}
public static class NuGet.Packaging.PackagingConstants : object {
    public static string AnyFramework;
    public static string AnyCodeLanguage;
    public static string AgnosticFramework;
    public static string TargetFrameworkPropertyKey;
    public static string ContentFilesDefaultBuildAction;
    public static string PackageVerifyDurationName;
    public static string ManifestExtension;
    public static string SnupkgFormat;
    public static string SymbolsNupkgFormat;
    internal static string PackageEmptyFileName;
    private static PackagingConstants();
}
public class NuGet.Packaging.PhysicalPackageFile : object {
    private Func`1<Stream> _streamFactory;
    private string _targetPath;
    private FrameworkName _targetFramework;
    private NuGetFramework _nugetFramework;
    private DateTimeOffset _lastWriteTime;
    [CompilerGeneratedAttribute]
private MemoryStream <MemoryStream>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourcePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EffectivePath>k__BackingField;
    private MemoryStream MemoryStream { get; private set; }
    public string SourcePath { get; public set; }
    public string TargetPath { get; public set; }
    public string Path { get; }
    public string EffectivePath { get; private set; }
    public FrameworkName TargetFramework { get; }
    public NuGetFramework NuGetFramework { get; }
    public DateTimeOffset LastWriteTime { get; }
    public PhysicalPackageFile(MemoryStream stream);
    internal PhysicalPackageFile(Func`1<Stream> streamFactory);
    [CompilerGeneratedAttribute]
private MemoryStream get_MemoryStream();
    [CompilerGeneratedAttribute]
private void set_MemoryStream(MemoryStream value);
    [CompilerGeneratedAttribute]
public string get_SourcePath();
    [CompilerGeneratedAttribute]
public void set_SourcePath(string value);
    public string get_TargetPath();
    public void set_TargetPath(string value);
    public sealed virtual string get_Path();
    [CompilerGeneratedAttribute]
public sealed virtual string get_EffectivePath();
    [CompilerGeneratedAttribute]
private void set_EffectivePath(string value);
    public sealed virtual FrameworkName get_TargetFramework();
    public sealed virtual NuGetFramework get_NuGetFramework();
    public sealed virtual Stream GetStream();
    public sealed virtual DateTimeOffset get_LastWriteTime();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NuGet.Packaging.RepositorySignatureInfo : object {
    [CompilerGeneratedAttribute]
private bool <AllRepositorySigned>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IRepositoryCertificateInfo> <RepositoryCertificateInfos>k__BackingField;
    public bool AllRepositorySigned { get; }
    public IEnumerable`1<IRepositoryCertificateInfo> RepositoryCertificateInfos { get; }
    public RepositorySignatureInfo(bool allRepositorySigned, IEnumerable`1<IRepositoryCertificateInfo> repositoryCertificateInfos);
    [CompilerGeneratedAttribute]
public bool get_AllRepositorySigned();
    [CompilerGeneratedAttribute]
public IEnumerable`1<IRepositoryCertificateInfo> get_RepositoryCertificateInfos();
}
public class NuGet.Packaging.RepositorySignatureInfoProvider : object {
    private ConcurrentDictionary`2<string, RepositorySignatureInfo> _dict;
    [CompilerGeneratedAttribute]
private static RepositorySignatureInfoProvider <Instance>k__BackingField;
    public static RepositorySignatureInfoProvider Instance { get; }
    private static RepositorySignatureInfoProvider();
    [CompilerGeneratedAttribute]
public static RepositorySignatureInfoProvider get_Instance();
    public bool TryGetRepositorySignatureInfo(string source, RepositorySignatureInfo& repositorySignatureInfo);
    public void AddOrUpdateRepositorySignatureInfo(string source, RepositorySignatureInfo repositorySignatureInfo);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public class NuGet.Packaging.Rules.AnalysisResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string AssemblyDirectlyUnderLibWarning { get; }
    public static string AssemblyOutsideLibWarning { get; }
    public static string BuildConventionIsViolatedWarning { get; }
    public static string DefaultSpecValueWarning { get; }
    public static string DependenciesGroupsForEachTFMBeginningToFiles { get; }
    public static string DependenciesGroupsForEachTFMBeginningToNuspec { get; }
    public static string DependenciesGroupsForEachTFMEndingToFile { get; }
    public static string DependenciesGroupsForEachTFMEndingToNuspec { get; }
    public static string DependenciesGroupsForEachTFMHasCompatMatch { get; }
    public static string DependenciesGroupsForEachTFMHasNoExactMatch { get; }
    public static string FilePathTooLongWarning { get; }
    public static string IconUrlDeprecationWarning { get; }
    public static string InvalidFrameworkWarning { get; }
    public static string InvalidPlaceholderFileWarning { get; }
    public static string InvalidPrereleaseDependencyWarning { get; }
    public static string InvalidUndottedFrameworkInDependencyGroupsWarning { get; }
    public static string InvalidUndottedFrameworkInFilesWarning { get; }
    public static string InvalidUndottedFrameworkInFrameworkAssemblyGroupsWarning { get; }
    public static string InvalidUndottedFrameworkInReferenceGroupsWarning { get; }
    public static string InvalidUndottedFrameworkWarning { get; }
    public static string LegacyVersionWarning { get; }
    public static string LicenseUrlDeprecationWarning { get; }
    public static string Migrator_AssemblyDirectlyUnderLibWarning { get; }
    public static string Migrator_PackageHasContentFolder { get; }
    public static string Migrator_PackageHasInstallScript { get; }
    public static string Migrator_XdtTransformInPackage { get; }
    public static string MisplacedInitScriptWarning { get; }
    public static string MisplacedTransformFileWarning { get; }
    public static string MissingReadmeInformation { get; }
    public static string NoRefOrLibFolderInPackage { get; }
    public static string PlaceholderFileInPackageWarning { get; }
    public static string ReferencesInNuspecAndRefFilesDontMatchWarning { get; }
    public static string ReferencesInNuspecAndRefFilesDontMatchWarningAddToNuspecListItemFormat { get; }
    public static string ReferencesInNuspecAndRefFilesDontMatchWarningAddToNuspecNoTfmListItemFormat { get; }
    public static string ReferencesInNuspecAndRefFilesDontMatchWarningAddToRefListItemFormat { get; }
    public static string ScriptOutsideToolsWarning { get; }
    public static string UnrecognizedLicenseIdentifier { get; }
    public static string UnrecognizedScriptWarning { get; }
    public static string UnspecifiedDependencyVersionWarning { get; }
    public static string WinRTObsoleteWarning { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_AssemblyDirectlyUnderLibWarning();
    public static string get_AssemblyOutsideLibWarning();
    public static string get_BuildConventionIsViolatedWarning();
    public static string get_DefaultSpecValueWarning();
    public static string get_DependenciesGroupsForEachTFMBeginningToFiles();
    public static string get_DependenciesGroupsForEachTFMBeginningToNuspec();
    public static string get_DependenciesGroupsForEachTFMEndingToFile();
    public static string get_DependenciesGroupsForEachTFMEndingToNuspec();
    public static string get_DependenciesGroupsForEachTFMHasCompatMatch();
    public static string get_DependenciesGroupsForEachTFMHasNoExactMatch();
    public static string get_FilePathTooLongWarning();
    public static string get_IconUrlDeprecationWarning();
    public static string get_InvalidFrameworkWarning();
    public static string get_InvalidPlaceholderFileWarning();
    public static string get_InvalidPrereleaseDependencyWarning();
    public static string get_InvalidUndottedFrameworkInDependencyGroupsWarning();
    public static string get_InvalidUndottedFrameworkInFilesWarning();
    public static string get_InvalidUndottedFrameworkInFrameworkAssemblyGroupsWarning();
    public static string get_InvalidUndottedFrameworkInReferenceGroupsWarning();
    public static string get_InvalidUndottedFrameworkWarning();
    public static string get_LegacyVersionWarning();
    public static string get_LicenseUrlDeprecationWarning();
    public static string get_Migrator_AssemblyDirectlyUnderLibWarning();
    public static string get_Migrator_PackageHasContentFolder();
    public static string get_Migrator_PackageHasInstallScript();
    public static string get_Migrator_XdtTransformInPackage();
    public static string get_MisplacedInitScriptWarning();
    public static string get_MisplacedTransformFileWarning();
    public static string get_MissingReadmeInformation();
    public static string get_NoRefOrLibFolderInPackage();
    public static string get_PlaceholderFileInPackageWarning();
    public static string get_ReferencesInNuspecAndRefFilesDontMatchWarning();
    public static string get_ReferencesInNuspecAndRefFilesDontMatchWarningAddToNuspecListItemFormat();
    public static string get_ReferencesInNuspecAndRefFilesDontMatchWarningAddToNuspecNoTfmListItemFormat();
    public static string get_ReferencesInNuspecAndRefFilesDontMatchWarningAddToRefListItemFormat();
    public static string get_ScriptOutsideToolsWarning();
    public static string get_UnrecognizedLicenseIdentifier();
    public static string get_UnrecognizedScriptWarning();
    public static string get_UnspecifiedDependencyVersionWarning();
    public static string get_WinRTObsoleteWarning();
}
internal class NuGet.Packaging.Rules.ContentFolderInPackageReferenceProjectRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public ContentFolderInPackageReferenceProjectRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
}
public class NuGet.Packaging.Rules.DefaultManifestValuesRule : object {
    internal static Uri SampleProjectUrl;
    internal static Uri SampleLicenseUrl;
    internal static Uri SampleIconUrl;
    internal static string SampleTags;
    internal static string SampleReleaseNotes;
    internal static string SampleDescription;
    internal static string SampleManifestDependencyId;
    internal static string SampleManifestDependencyVersion;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public DefaultManifestValuesRule(string messageFormat);
    private static DefaultManifestValuesRule();
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.DefaultManifestValuesRule/<Validate>d__12")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreateIssueFor(string field, string value);
}
internal class NuGet.Packaging.Rules.DependenciesGroupsForEachTFMRule : object {
    private static NuGetFramework Net00;
    public string MessageFormat { get; }
    private string CompatMatchFoundWarningMessageFormat { get; }
    private static DependenciesGroupsForEachTFMRule();
    public sealed virtual string get_MessageFormat();
    private string get_CompatMatchFoundWarningMessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader package);
    internal IEnumerable`1<PackagingLogMessage> GenerateWarnings(HashSet`1<NuGetFramework> compatNotExactMatches, HashSet`1<NuGetFramework> noExactMatchesFromFile, HashSet`1<NuGetFramework> noExactMatchesFromNuspec);
    internal ValueTuple`3<HashSet`1<NuGetFramework>, HashSet`1<NuGetFramework>, HashSet`1<NuGetFramework>> Categorize(IEnumerable`1<string> files, IEnumerable`1<NuGetFramework> tfmsFromNuspec);
    internal ValueTuple`2<string, string> GenerateWarningString(ICollection`1<NuGetFramework> noExactMatchesFromFile, ICollection`1<NuGetFramework> noExactMatchesFromNuspec, ICollection`1<NuGetFramework> compatNotExactMatches);
    private static IEnumerable`1<NuGetFramework> ExtractTFMsFromNuspec(Stream packageNuspecStream);
}
internal static class NuGet.Packaging.Rules.FrameworkNameValidatorUtility : object {
    internal static bool IsValidFrameworkName(NuGetFramework framework);
    internal static bool IsValidFrameworkName(string path);
    internal static bool IsValidCultureName(PackageArchiveReader builder, string name);
}
public class NuGet.Packaging.Rules.IconUrlDeprecationWarning : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public IconUrlDeprecationWarning(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.IconUrlDeprecationWarning/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
}
internal class NuGet.Packaging.Rules.InitScriptNotUnderToolsRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public InitScriptNotUnderToolsRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.InitScriptNotUnderToolsRule/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssue(string file);
}
internal class NuGet.Packaging.Rules.InstallScriptInPackageReferenceProjectRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public InstallScriptInPackageReferenceProjectRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
}
internal class NuGet.Packaging.Rules.InvalidFrameworkFolderRule : object {
    private static string LibDirectory;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public InvalidFrameworkFolderRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssue(string target);
}
internal class NuGet.Packaging.Rules.InvalidPlaceholderFileRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public InvalidPlaceholderFileRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.InvalidPlaceholderFileRule/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForPlaceholderFile(string target);
}
internal class NuGet.Packaging.Rules.InvalidPrereleaseDependencyRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public InvalidPrereleaseDependencyRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.InvalidPrereleaseDependencyRule/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private bool IsPrereleaseDependency(PackageDependency dependency);
    private PackagingLogMessage CreatePackageIssueForPrereleaseDependency(PackageDependency dependency, NuGetFramework framework);
}
internal class NuGet.Packaging.Rules.InvalidUndottedFrameworkRule : object {
    private static string TargetFramework;
    private static string Metadata;
    private static string Dependencies;
    private static string Group;
    private static string References;
    private static string FrameworkAssemblies;
    private static string FrameworkAssembly;
    private static Char[] CommaArray;
    public string MessageFormat { get; }
    private static InvalidUndottedFrameworkRule();
    public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    internal static IEnumerable`1<PackagingLogMessage> Validate(XDocument xml, IEnumerable`1<string> files);
    internal static IEnumerable`1<PackagingLogMessage> ValidateDependencyGroups(XElement metadataNode);
    internal static IEnumerable`1<PackagingLogMessage> ValidateReferenceGroups(XElement metadataNode);
    internal static IEnumerable`1<PackagingLogMessage> ValidateFrameworkAssemblies(XDocument xml, XElement metadataNode);
    internal static IEnumerable`1<PackagingLogMessage> ValidateFiles(IEnumerable`1<string> files);
    private static XDocument LoadXml(Stream stream);
    private static string GetAttributeValue(XElement element, string attributeName);
    internal static bool FrameworkVersionHasDesiredDots(string frameworkString);
}
public interface NuGet.Packaging.Rules.IPackageRule {
    public string MessageFormat { get; }
    public abstract virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    public abstract virtual string get_MessageFormat();
}
public class NuGet.Packaging.Rules.LicenseUrlDeprecationWarning : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public LicenseUrlDeprecationWarning(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.LicenseUrlDeprecationWarning/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
}
internal class NuGet.Packaging.Rules.MisplacedAssemblyOutsideLibRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    private static IEnumerable`1<string> ValidFolders { get; }
    public MisplacedAssemblyOutsideLibRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.MisplacedAssemblyOutsideLibRule/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForAssembliesOutsideLib(string target);
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.MisplacedAssemblyOutsideLibRule/<get_ValidFolders>d__7")]
private static IEnumerable`1<string> get_ValidFolders();
}
internal class NuGet.Packaging.Rules.MisplacedAssemblyUnderLibRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    private static IEnumerable`1<string> ValidFolders { get; }
    public MisplacedAssemblyUnderLibRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.MisplacedAssemblyUnderLibRule/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForAssembliesUnderLib(string target);
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.MisplacedAssemblyUnderLibRule/<get_ValidFolders>d__7")]
private static IEnumerable`1<string> get_ValidFolders();
}
internal class NuGet.Packaging.Rules.MisplacedScriptFileRule : object {
    private static string ScriptExtension;
    private static string ToolsDirectory;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public MisplacedScriptFileRule(string messageFormat);
    private static MisplacedScriptFileRule();
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.MisplacedScriptFileRule/<Validate>d__6")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForMisplacedScript(string target);
}
internal class NuGet.Packaging.Rules.MisplacedTransformFileRule : object {
    private static string CodeTransformExtension;
    private static string ConfigTransformExtension;
    private static string ContentDirectory;
    private static string ContentFilesDirectory;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public MisplacedTransformFileRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.MisplacedTransformFileRule/<Validate>d__8")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForMisplacedContent(string path);
}
internal class NuGet.Packaging.Rules.MissingReadmeRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public MissingReadmeRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.MissingReadmeRule/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
}
internal class NuGet.Packaging.Rules.NoRefOrLibFolderInPackageRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public NoRefOrLibFolderInPackageRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader package);
    internal IEnumerable`1<PackagingLogMessage> Validate(IEnumerable`1<string> files);
    private ValueTuple`2<string, string> GenerateWarningString(String[] possibleFrameworks);
    private static string CreateDirectoriesMessage(String[] possibleFrameworks);
}
public class NuGet.Packaging.Rules.PathTooLongRule : object {
    private static int _pathLenghtWarningThreshold;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public PathTooLongRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.PathTooLongRule/<Validate>d__5")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForPathTooLong(string target);
}
internal class NuGet.Packaging.Rules.ReferencesInNuspecMatchRefAssetsRule : object {
    private string _addToRefFormat;
    private string _addToNuspecFormat;
    private string _addToNuspecNoTfmFormat;
    public string MessageFormat { get; }
    public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    internal IDictionary`2<string, IEnumerable`1<string>> GetReferencesFromNuspec(Stream nuspecStream);
    internal IEnumerable`1<MissingReference> Compare(IDictionary`2<string, IEnumerable`1<string>> nuspecReferences, IEnumerable`1<string> refFiles);
    internal IEnumerable`1<PackagingLogMessage> GenerateWarnings(IEnumerable`1<MissingReference> missingReferences);
    internal List`1<string> GetAllKeys(IEnumerable`1<IGrouping`2<string, string>> filesByTFM);
}
public static class NuGet.Packaging.Rules.RuleSet : object {
    private static IPackageRule[] PackageCreationRuleArray;
    private static IPackageRule[] PackageCreationBestPracticeRuleArray;
    private static ReadOnlyCollection`1<IPackageRule> PackageCreationRules;
    private static ReadOnlyCollection`1<IPackageRule> PackagesConfigToPackageReferenceMigrationRules;
    public static IEnumerable`1<IPackageRule> PackageCreationRuleSet { get; }
    public static IEnumerable`1<IPackageRule> PackagesConfigToPackageReferenceMigrationRuleSet { get; }
    private static RuleSet();
    public static IEnumerable`1<IPackageRule> get_PackageCreationRuleSet();
    public static IEnumerable`1<IPackageRule> get_PackagesConfigToPackageReferenceMigrationRuleSet();
}
internal class NuGet.Packaging.Rules.UnrecognizedLicenseIdentifierRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public UnrecognizedLicenseIdentifierRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private void ValidateAllLicenseLeafs(NuGetLicenseExpression expression, IList`1<PackagingLogMessage> logMessages);
}
internal class NuGet.Packaging.Rules.UnrecognizedScriptFileRule : object {
    private static string ScriptExtension;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public UnrecognizedScriptFileRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.UnrecognizedScriptFileRule/<Validate>d__5")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForUnrecognizedScripts(string target);
}
public class NuGet.Packaging.Rules.UnspecifiedDependencyVersionRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public UnspecifiedDependencyVersionRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.UnspecifiedDependencyVersionRule/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
}
internal class NuGet.Packaging.Rules.UpholdBuildConventionRule : object {
    private static ManagedCodeConventions ManagedCodeConventions;
    private static IReadOnlyList`1<string> BuildFolders;
    public string MessageFormat { get; }
    private static UpholdBuildConventionRule();
    public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    internal PackagingLogMessage GenerateWarning(ICollection`1<ExpectedFile> expectedFiles);
    internal List`1<ExpectedFile> FindAbsentExpectedFiles(IEnumerable`1<string> files, string packageId);
    private string GetTfm(string file);
    private string GetBuildFolder(string file);
    private bool EndsWithMsbuildFileExtension(string file);
    private bool InsideBuildFolder(string file);
}
internal class NuGet.Packaging.Rules.WinRTNameIsObsoleteRule : object {
    private static String[] Prefixes;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public WinRTNameIsObsoleteRule(string messageFormat);
    private static WinRTNameIsObsoleteRule();
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.WinRTNameIsObsoleteRule/<Validate>d__5")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreateIssue(string file);
}
internal class NuGet.Packaging.Rules.XdtTransformInPackageReferenceProjectRule : object {
    private static string ConfigTransformExtension;
    private static string InstallXdtExtension;
    private static string UninstallXdtExtension;
    private static string ContentDirectory;
    private static string ContentFilesDirectory;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public XdtTransformInPackageReferenceProjectRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.XdtTransformInPackageReferenceProjectRule/<Validate>d__9")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForTransformFiles(string path);
}
public class NuGet.Packaging.Sha512HashFunction : object {
    private Byte[] _hash;
    private SHA512 _hashFunc;
    public sealed virtual void Update(Byte[] data, int offset, int count);
    public Byte[] GetHashBytes();
    public sealed virtual string GetHash();
    public sealed virtual void Dispose();
}
public class NuGet.Packaging.Signing.Accuracy : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Seconds>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Milliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Microseconds>k__BackingField;
    public Nullable`1<int> Seconds { get; }
    public Nullable`1<int> Milliseconds { get; }
    public Nullable`1<int> Microseconds { get; }
    private Accuracy(Nullable`1<int> seconds, Nullable`1<int> milliseconds, Nullable`1<int> microseconds);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Seconds();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Milliseconds();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Microseconds();
    public static Accuracy Read(Byte[] bytes);
    internal static Accuracy Read(DerSequenceReader reader);
    public Nullable`1<long> GetTotalMicroseconds();
}
public class NuGet.Packaging.Signing.AlgorithmIdentifier : object {
    [CompilerGeneratedAttribute]
private Oid <Algorithm>k__BackingField;
    public Oid Algorithm { get; }
    internal AlgorithmIdentifier(Oid algorithm);
    [CompilerGeneratedAttribute]
public Oid get_Algorithm();
    public static AlgorithmIdentifier Read(Byte[] bytes);
    internal static AlgorithmIdentifier Read(DerSequenceReader reader);
    internal Byte[][] Encode();
}
public class NuGet.Packaging.Signing.AllowListVerificationProvider : object {
    private IReadOnlyCollection`1<VerificationAllowListEntry> _allowList;
    private string _emptyListErrorMessage;
    private string _noMatchErrorMessage;
    private bool _requireNonEmptyAllowList;
    public AllowListVerificationProvider(IReadOnlyCollection`1<VerificationAllowListEntry> allowList, bool requireNonEmptyAllowList, string emptyListErrorMessage, string noMatchErrorMessage);
    public sealed virtual Task`1<PackageVerificationResult> GetTrustResultAsync(ISignedPackageReader package, PrimarySignature signature, SignedPackageVerifierSettings settings, CancellationToken token);
    private PackageVerificationResult VerifyAllowList(ISignedPackageReader package, PrimarySignature signature, SignedPackageVerifierSettings settings);
    private bool IsSignatureAllowed(PrimarySignature signature, IReadOnlyCollection`1<VerificationAllowListEntry> allowList);
    private static bool ShouldVerifyOwners(TrustedSignerAllowListEntry entry, IRepositorySignature repoSignature, IReadOnlyList`1& allowedOwners, IReadOnlyList`1& actualOwners);
    private static bool IsSignatureTargeted(VerificationTarget target, Signature signature);
    private static string GetCertificateFingerprint(Signature signature, HashAlgorithmName fingerprintAlgorithm, IDictionary`2<HashAlgorithmName, string> CertificateFingerprintLookUp);
}
[ExtensionAttribute]
public static class NuGet.Packaging.Signing.AttributeUtility : object {
    public static CryptographicAttributeObject CreateCommitmentTypeIndication(SignatureType type);
    public static SignatureType GetSignatureType(CryptographicAttributeObjectCollection signedAttributes);
    public static CryptographicAttributeObject CreateNuGetV3ServiceIndexUrl(Uri v3ServiceIndexUrl);
    public static Uri GetNuGetV3ServiceIndexUrl(CryptographicAttributeObjectCollection signedAttributes);
    public static CryptographicAttributeObject CreateNuGetPackageOwners(IReadOnlyList`1<string> packageOwners);
    public static IReadOnlyList`1<string> GetNuGetPackageOwners(CryptographicAttributeObjectCollection signedAttributes);
    public static SignatureType GetSignatureType(string oid);
    public static string GetSignatureTypeOid(SignatureType signatureType);
    public static CryptographicAttributeObject CreateSigningCertificateV2(X509Certificate2 certificate, HashAlgorithmName hashAlgorithm);
    [ExtensionAttribute]
internal static CryptographicAttributeObject GetAttributeOrDefault(CryptographicAttributeObjectCollection attributes, string oid);
    private static void ThrowInvalidAttributeException(CryptographicAttributeObject attribute);
    [ExtensionAttribute]
private static List`1<AsnEncodedData> ToList(AsnEncodedDataCollection collection);
    private static IEnumerable`1<SignatureType> GetCommitmentTypeIndicationRawValues(CryptographicAttributeObject attribute);
    [ExtensionAttribute]
public static CryptographicAttributeObject GetAttribute(CryptographicAttributeObjectCollection attributes, string oid);
    [ExtensionAttribute]
public static IEnumerable`1<CryptographicAttributeObject> GetAttributes(CryptographicAttributeObjectCollection attributes, string oid);
}
public class NuGet.Packaging.Signing.AuthorPrimarySignature : PrimarySignature {
    public string FriendlyName { get; }
    public AuthorPrimarySignature(SignedCms signedCms);
    public virtual string get_FriendlyName();
    public virtual SignatureVerificationSummary Verify(Timestamp timestamp, SignatureVerifySettings settings, HashAlgorithmName fingerprintAlgorithm, X509Certificate2Collection certificateExtraStore);
}
public class NuGet.Packaging.Signing.AuthorSignPackageRequest : SignPackageRequest {
    public SignatureType SignatureType { get; }
    public AuthorSignPackageRequest(X509Certificate2 certificate, HashAlgorithmName hashAlgorithm);
    public AuthorSignPackageRequest(X509Certificate2 certificate, HashAlgorithmName signatureHashAlgorithm, HashAlgorithmName timestampHashAlgorithm);
    public virtual SignatureType get_SignatureType();
}
internal class NuGet.Packaging.Signing.BLOB : ValueType {
    public UInt32 cbData;
    public IntPtr pbData;
    public void Dispose();
}
internal class NuGet.Packaging.Signing.CentralDirectoryHeader : object {
    internal static UInt32 SizeInBytesOfFixedLengthFields;
    internal static UInt32 Signature;
    [CompilerGeneratedAttribute]
private ushort <VersionMadeBy>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <VersionNeededToExtract>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <GeneralPurposeBitFlag>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <CompressionMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <LastModFileTime>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <LastModFileDate>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Crc32>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <UncompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <FileNameLength>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <ExtraFieldLength>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <FileCommentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <DiskNumberStart>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <InternalFileAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ExternalFileAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <RelativeOffsetOfLocalHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ExtraField>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <FileComment>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OffsetFromStart>k__BackingField;
    internal ushort VersionMadeBy { get; private set; }
    internal ushort VersionNeededToExtract { get; private set; }
    internal ushort GeneralPurposeBitFlag { get; private set; }
    internal ushort CompressionMethod { get; private set; }
    internal ushort LastModFileTime { get; private set; }
    internal ushort LastModFileDate { get; private set; }
    internal UInt32 Crc32 { get; private set; }
    internal UInt32 CompressedSize { get; private set; }
    internal UInt32 UncompressedSize { get; private set; }
    internal ushort FileNameLength { get; private set; }
    internal ushort ExtraFieldLength { get; private set; }
    internal ushort FileCommentLength { get; private set; }
    internal ushort DiskNumberStart { get; private set; }
    internal ushort InternalFileAttributes { get; private set; }
    internal UInt32 ExternalFileAttributes { get; private set; }
    internal UInt32 RelativeOffsetOfLocalHeader { get; private set; }
    internal Byte[] FileName { get; private set; }
    internal Byte[] ExtraField { get; private set; }
    internal Byte[] FileComment { get; private set; }
    internal long OffsetFromStart { get; private set; }
    [CompilerGeneratedAttribute]
internal ushort get_VersionMadeBy();
    [CompilerGeneratedAttribute]
private void set_VersionMadeBy(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_VersionNeededToExtract();
    [CompilerGeneratedAttribute]
private void set_VersionNeededToExtract(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_GeneralPurposeBitFlag();
    [CompilerGeneratedAttribute]
private void set_GeneralPurposeBitFlag(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_CompressionMethod();
    [CompilerGeneratedAttribute]
private void set_CompressionMethod(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_LastModFileTime();
    [CompilerGeneratedAttribute]
private void set_LastModFileTime(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_LastModFileDate();
    [CompilerGeneratedAttribute]
private void set_LastModFileDate(ushort value);
    [CompilerGeneratedAttribute]
internal UInt32 get_Crc32();
    [CompilerGeneratedAttribute]
private void set_Crc32(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_CompressedSize();
    [CompilerGeneratedAttribute]
private void set_CompressedSize(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_UncompressedSize();
    [CompilerGeneratedAttribute]
private void set_UncompressedSize(UInt32 value);
    [CompilerGeneratedAttribute]
internal ushort get_FileNameLength();
    [CompilerGeneratedAttribute]
private void set_FileNameLength(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_ExtraFieldLength();
    [CompilerGeneratedAttribute]
private void set_ExtraFieldLength(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_FileCommentLength();
    [CompilerGeneratedAttribute]
private void set_FileCommentLength(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_DiskNumberStart();
    [CompilerGeneratedAttribute]
private void set_DiskNumberStart(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_InternalFileAttributes();
    [CompilerGeneratedAttribute]
private void set_InternalFileAttributes(ushort value);
    [CompilerGeneratedAttribute]
internal UInt32 get_ExternalFileAttributes();
    [CompilerGeneratedAttribute]
private void set_ExternalFileAttributes(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_RelativeOffsetOfLocalHeader();
    [CompilerGeneratedAttribute]
private void set_RelativeOffsetOfLocalHeader(UInt32 value);
    [CompilerGeneratedAttribute]
internal Byte[] get_FileName();
    [CompilerGeneratedAttribute]
private void set_FileName(Byte[] value);
    [CompilerGeneratedAttribute]
internal Byte[] get_ExtraField();
    [CompilerGeneratedAttribute]
private void set_ExtraField(Byte[] value);
    [CompilerGeneratedAttribute]
internal Byte[] get_FileComment();
    [CompilerGeneratedAttribute]
private void set_FileComment(Byte[] value);
    [CompilerGeneratedAttribute]
internal long get_OffsetFromStart();
    [CompilerGeneratedAttribute]
private void set_OffsetFromStart(long value);
    internal UInt32 GetSizeInBytes();
    internal static bool TryRead(BinaryReader reader, CentralDirectoryHeader& header);
}
public class NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata : object {
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OffsetToLocalFileHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FileEntryTotalSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPackageSignatureFile>k__BackingField;
    [CompilerGeneratedAttribute]
private long <HeaderSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ChangeInOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndexInHeaders>k__BackingField;
    public long Position { get; public set; }
    public long OffsetToLocalFileHeader { get; public set; }
    public long FileEntryTotalSize { get; public set; }
    public bool IsPackageSignatureFile { get; public set; }
    public long HeaderSize { get; public set; }
    public long ChangeInOffset { get; public set; }
    public int IndexInHeaders { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(long value);
    [CompilerGeneratedAttribute]
public long get_OffsetToLocalFileHeader();
    [CompilerGeneratedAttribute]
public void set_OffsetToLocalFileHeader(long value);
    [CompilerGeneratedAttribute]
public long get_FileEntryTotalSize();
    [CompilerGeneratedAttribute]
public void set_FileEntryTotalSize(long value);
    [CompilerGeneratedAttribute]
public bool get_IsPackageSignatureFile();
    [CompilerGeneratedAttribute]
public void set_IsPackageSignatureFile(bool value);
    [CompilerGeneratedAttribute]
public long get_HeaderSize();
    [CompilerGeneratedAttribute]
public void set_HeaderSize(long value);
    [CompilerGeneratedAttribute]
public long get_ChangeInOffset();
    [CompilerGeneratedAttribute]
public void set_ChangeInOffset(long value);
    [CompilerGeneratedAttribute]
public int get_IndexInHeaders();
    [CompilerGeneratedAttribute]
public void set_IndexInHeaders(int value);
}
internal class NuGet.Packaging.Signing.CERT_CONTEXT : ValueType {
    public UInt32 dwCertEncodingType;
    public IntPtr pbCertEncoded;
    public UInt32 cbCertEncoded;
    public IntPtr pCertInfo;
    public IntPtr hCertStore;
}
internal class NuGet.Packaging.Signing.CERT_ID : ValueType {
    internal UInt32 dwIdChoice;
    internal BLOB KeyId;
}
public static class NuGet.Packaging.Signing.CertificateChainUtility : object {
    internal static X509ChainStatusFlags DefaultObservedStatusFlags;
    public static IX509CertificateChain GetCertificateChain(X509Certificate2 certificate, X509Certificate2Collection extraStore, ILogger logger, CertificateType certificateType);
    public static IX509CertificateChain GetCertificateChain(X509Chain x509Chain);
    private static void GetChainStatusFlags(X509Certificate2 certificate, CertificateType certificateType, X509ChainStatusFlags& errorStatusFlags, X509ChainStatusFlags& warningStatusFlags);
    internal static void SetCertBuildChainPolicy(X509ChainPolicy policy, X509Certificate2Collection additionalCertificates, DateTime verificationTime, CertificateType certificateType);
    internal static bool BuildCertificateChain(IX509Chain chain, X509Certificate2 certificate, X509ChainStatus[]& status);
    internal static bool BuildWithPolicy(IX509Chain chain, X509Certificate2 certificate);
    internal static bool ChainStatusListIncludesStatus(X509ChainStatus[] chainStatuses, X509ChainStatusFlags status, IEnumerable`1& chainStatus);
    internal static bool TryGetStatusAndMessage(X509ChainStatus[] chainStatuses, X509ChainStatusFlags status, IEnumerable`1& statusAndMessages);
    internal static IEnumerable`1<string> GetStatusAndMessagesFromChainStatuses(IEnumerable`1<X509ChainStatus> chainStatuses);
    private static void LogAdditionalContext(IX509Chain chain, ILogger logger);
}
public class NuGet.Packaging.Signing.CertificateHashAllowListEntry : VerificationAllowListEntry {
    [CompilerGeneratedAttribute]
private string <Fingerprint>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <FingerprintAlgorithm>k__BackingField;
    public string Fingerprint { get; }
    public HashAlgorithmName FingerprintAlgorithm { get; }
    public CertificateHashAllowListEntry(VerificationTarget target, SignaturePlacement placement, string fingerprint, HashAlgorithmName algorithm);
    [CompilerGeneratedAttribute]
public string get_Fingerprint();
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_FingerprintAlgorithm();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum NuGet.Packaging.Signing.CertificateType : Enum {
    public int value__;
    public static CertificateType Signature;
    public static CertificateType Timestamp;
}
public static class NuGet.Packaging.Signing.CertificateUtility : object {
    private static int ChainDepthLimit;
    public static string X509Certificate2ToString(X509Certificate2 cert, HashAlgorithmName fingerprintAlgorithm);
    internal static IReadOnlyList`1<SignatureLog> X509Certificate2ToLogMessages(X509Certificate2 cert, HashAlgorithmName fingerprintAlgorithm, string indentation);
    private static void X509Certificate2ToString(X509Certificate2 cert, StringBuilder certStringBuilder, HashAlgorithmName fingerprintAlgorithm, string indentation);
    public static string X509Certificate2CollectionToString(X509Certificate2Collection certCollection, HashAlgorithmName fingerprintAlgorithm);
    public static string X509ChainToString(X509Chain chain, HashAlgorithmName fingerprintAlgorithm);
    public static bool IsSignatureAlgorithmSupported(X509Certificate2 certificate);
    public static bool IsCertificatePublicKeyValid(X509Certificate2 certificate);
    public static bool HasLifetimeSigningEku(X509Certificate2 certificate);
    public static bool HasExtendedKeyUsage(X509Certificate2 certificate, string ekuOid);
    public static bool IsValidForPurposeFast(X509Certificate2 certificate, string ekuOid);
    public static bool IsCertificateValidityPeriodInTheFuture(X509Certificate2 certificate);
    public static bool IsDateInsideValidityPeriod(X509Certificate2 certificate, DateTimeOffset date);
    public static Byte[] GetHash(X509Certificate2 certificate, HashAlgorithmName hashAlgorithm);
    public static string GetHashString(X509Certificate2 certificate, HashAlgorithmName hashAlgorithm);
    public static bool IsSelfIssued(X509Certificate2 certificate);
    public static IReadOnlyList`1<Byte[]> GetRawDataForCollection(X509Certificate2Collection certificates);
}
public class NuGet.Packaging.Signing.ClientPolicyContext : object {
    [CompilerGeneratedAttribute]
private SignatureValidationMode <Policy>k__BackingField;
    [CompilerGeneratedAttribute]
private SignedPackageVerifierSettings <VerifierSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<TrustedSignerAllowListEntry> <AllowList>k__BackingField;
    public SignatureValidationMode Policy { get; }
    public SignedPackageVerifierSettings VerifierSettings { get; }
    public IReadOnlyCollection`1<TrustedSignerAllowListEntry> AllowList { get; }
    internal ClientPolicyContext(SignatureValidationMode policy, IReadOnlyCollection`1<TrustedSignerAllowListEntry> allowList);
    [CompilerGeneratedAttribute]
public SignatureValidationMode get_Policy();
    [CompilerGeneratedAttribute]
public SignedPackageVerifierSettings get_VerifierSettings();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<TrustedSignerAllowListEntry> get_AllowList();
    public static ClientPolicyContext GetClientPolicy(ISettings settings, ILogger logger);
}
internal static class NuGet.Packaging.Signing.CmsFactory : object {
    internal static ICms Create(Byte[] cmsBytes);
}
internal enum NuGet.Packaging.Signing.CMSG_CONTROL_TYPE : Enum {
    public UInt32 value__;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_VERIFY_SIGNATURE;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_DECRYPT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_VERIFY_HASH;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ADD_SIGNER;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_DEL_SIGNER;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ADD_CERT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_DEL_CERT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ADD_CRL;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_DEL_CRL;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ADD_ATTR_CERT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_DEL_ATTR_CERT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_KEY_TRANS_DECRYPT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_KEY_AGREE_DECRYPT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_MAIL_LIST_DECRYPT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_VERIFY_SIGNATURE_EX;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ADD_CMS_SIGNER_INFO;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ENABLE_STRONG_SIGNATURE;
}
internal class NuGet.Packaging.Signing.CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA : ValueType {
    internal UInt32 cbSize;
    internal UInt32 dwSignerIndex;
    internal CRYPT_INTEGER_BLOB BLOB;
}
internal class NuGet.Packaging.Signing.CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA : ValueType {
    internal UInt32 cbSize;
    internal UInt32 dwSignerIndex;
    internal UInt32 dwUnauthAttrIndex;
}
[FlagsAttribute]
internal enum NuGet.Packaging.Signing.CMSG_ENCODING : Enum {
    public UInt32 value__;
    public static CMSG_ENCODING X509_ASN_ENCODING;
    public static CMSG_ENCODING PKCS_7_ASN_ENCODING;
    public static CMSG_ENCODING Any;
}
internal enum NuGet.Packaging.Signing.CMSG_GETPARAM_TYPE : Enum {
    public UInt32 value__;
    public static CMSG_GETPARAM_TYPE CMSG_TYPE_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CONTENT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_BARE_CONTENT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_INNER_CONTENT_TYPE_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_COUNT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_INFO_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_CERT_INFO_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_HASH_ALGORITHM_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_AUTH_ATTR_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_UNAUTH_ATTR_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CERT_COUNT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CERT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CRL_COUNT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CRL_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_ENVELOPE_ALGORITHM_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_RECIPIENT_COUNT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_RECIPIENT_INDEX_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_RECIPIENT_INFO_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_HASH_ALGORITHM_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_HASH_DATA_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_COMPUTED_HASH_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_ENCRYPT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_ENCRYPTED_DIGEST;
    public static CMSG_GETPARAM_TYPE CMSG_ENCODED_SIGNER;
    public static CMSG_GETPARAM_TYPE CMSG_ENCODED_MESSAGE;
    public static CMSG_GETPARAM_TYPE CMSG_VERSION_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_ATTR_CERT_COUNT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_ATTR_CERT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CMS_RECIPIENT_COUNT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CMS_RECIPIENT_INDEX_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CMS_RECIPIENT_INFO_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_UNPROTECTED_ATTR_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_CERT_ID_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CMS_SIGNER_INFO_PARAM;
}
[FlagsAttribute]
internal enum NuGet.Packaging.Signing.CMSG_OPENTODECODE_FLAGS : Enum {
    public UInt32 value__;
    public static CMSG_OPENTODECODE_FLAGS None;
    public static CMSG_OPENTODECODE_FLAGS CMSG_DETACHED_FLAG;
    public static CMSG_OPENTODECODE_FLAGS CMSG_CRYPT_RELEASE_CONTEXT_FLAG;
}
internal class NuGet.Packaging.Signing.CMSG_SIGNED_ENCODE_INFO : ValueType {
    internal int cbSize;
    internal int cSigners;
    internal IntPtr rgSigners;
    internal int cCertEncoded;
    internal IntPtr rgCertEncoded;
    internal int cCrlEncoded;
    internal IntPtr rgCrlEncoded;
    internal int cAttrCertEncoded;
    internal IntPtr rgAttrCertEncoded;
}
internal class NuGet.Packaging.Signing.CMSG_SIGNER_ENCODE_INFO : ValueType {
    internal UInt32 cbSize;
    internal IntPtr pCertInfo;
    internal IntPtr hCryptProvOrhNCryptKey;
    internal int dwKeySpec;
    internal CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
    internal IntPtr pvHashAuxInfo;
    internal int cAuthAttr;
    internal IntPtr rgAuthAttr;
    internal int cUnauthAttr;
    internal IntPtr rgUnauthAttr;
    internal CERT_ID SignerId;
    internal CRYPT_ALGORITHM_IDENTIFIER HashEncryptionAlgorithm;
    internal IntPtr pvHashEncryptionAuxInfo;
    public void Dispose();
}
internal class NuGet.Packaging.Signing.CMSG_SIGNER_INFO : ValueType {
    internal UInt32 dwVersion;
    internal CRYPTOAPI_BLOB Issuer;
    internal CRYPTOAPI_BLOB SerialNumber;
    internal CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
    internal CRYPT_ALGORITHM_IDENTIFIER HashEncryptionAlgorithm;
    internal CRYPTOAPI_BLOB EncryptedHash;
    internal CRYPT_ATTRIBUTES AuthAttrs;
    internal CRYPT_ATTRIBUTES UnauthAttrs;
}
public class NuGet.Packaging.Signing.CommitmentTypeIndication : object {
    [CompilerGeneratedAttribute]
private Oid <CommitmentTypeId>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<CommitmentTypeQualifier> <Qualifiers>k__BackingField;
    public Oid CommitmentTypeId { get; }
    public IReadOnlyList`1<CommitmentTypeQualifier> Qualifiers { get; }
    private CommitmentTypeIndication(Oid commitmentTypeId, IReadOnlyList`1<CommitmentTypeQualifier> qualifiers);
    [CompilerGeneratedAttribute]
public Oid get_CommitmentTypeId();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<CommitmentTypeQualifier> get_Qualifiers();
    public static CommitmentTypeIndication Create(Oid commitmentTypeId);
    public static CommitmentTypeIndication Read(Byte[] bytes);
    internal static CommitmentTypeIndication Read(DerSequenceReader reader);
    internal Byte[] Encode();
}
public class NuGet.Packaging.Signing.CommitmentTypeQualifier : object {
    [CompilerGeneratedAttribute]
private Oid <CommitmentTypeIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Qualifier>k__BackingField;
    public Oid CommitmentTypeIdentifier { get; }
    public Byte[] Qualifier { get; }
    private CommitmentTypeQualifier(Oid commitmentTypeIdentifier, Byte[] qualifier);
    [CompilerGeneratedAttribute]
public Oid get_CommitmentTypeIdentifier();
    [CompilerGeneratedAttribute]
public Byte[] get_Qualifier();
    public static CommitmentTypeQualifier Read(Byte[] bytes);
    internal static CommitmentTypeQualifier Read(DerSequenceReader reader);
    internal Byte[] Encode();
}
public static class NuGet.Packaging.Signing.Crc32 : object {
    private static UInt32[] CrcLookUpTable;
    private static bool CrcLookUptableComputed;
    private static UInt32 Crc32Polynomial;
    private static Crc32();
    [CLSCompliantAttribute("False")]
public static UInt32 CalculateCrc(Byte[] data);
    private static UInt32 UpdateCrc(UInt32 crc, Byte[] buf, int len);
    private static void ComputeCrcLookUpTable();
}
internal class NuGet.Packaging.Signing.CRYPT_ALGORITHM_IDENTIFIER : ValueType {
    public string pszObjId;
    public CRYPT_INTEGER_BLOB Parameters;
}
internal class NuGet.Packaging.Signing.CRYPT_ATTRIBUTE : ValueType {
    internal IntPtr pszObjId;
    internal UInt32 cValue;
    internal IntPtr rgValue;
}
internal class NuGet.Packaging.Signing.CRYPT_ATTRIBUTE_STRING : ValueType {
    internal string pszObjId;
    internal UInt32 cValue;
    internal IntPtr rgValue;
}
internal class NuGet.Packaging.Signing.CRYPT_ATTRIBUTES : ValueType {
    internal UInt32 cAttr;
    internal IntPtr rgAttr;
}
internal class NuGet.Packaging.Signing.CRYPT_INTEGER_BLOB : ValueType {
    internal UInt32 cbData;
    internal IntPtr pbData;
}
internal class NuGet.Packaging.Signing.DefaultX509ChainBuildPolicy : object {
    [CompilerGeneratedAttribute]
private static IX509ChainBuildPolicy <Instance>k__BackingField;
    internal static IX509ChainBuildPolicy Instance { get; }
    private static DefaultX509ChainBuildPolicy();
    [CompilerGeneratedAttribute]
internal static IX509ChainBuildPolicy get_Instance();
    public sealed virtual bool Build(IX509Chain chain, X509Certificate2 certificate);
}
internal static class NuGet.Packaging.Signing.DerEncoding.DerEncoder : object {
    private static byte ConstructedFlag;
    private static byte ConstructedSequenceTag;
    private static byte ConstructedSetTag;
    private static Byte[][] s_nullTlv;
    private static DerEncoder();
    private static Byte[] EncodeLength(int length);
    internal static Byte[][] SegmentedEncodeBoolean(bool value);
    internal static Byte[][] SegmentedEncodeUnsignedInteger(UInt32 value);
    internal static Byte[][] SegmentedEncodeUnsignedInteger(Byte[] bigEndianBytes);
    internal static Byte[][] SegmentedEncodeUnsignedInteger(Byte[] bigEndianBytes, int offset, int count);
    internal static Byte[][] SegmentedEncodeBitString(Byte[][][] childSegments);
    internal static Byte[][] SegmentedEncodeBitString(Byte[] data);
    internal static Byte[][] SegmentedEncodeBitString(int unusedBits, Byte[] data);
    internal static Byte[][] SegmentedEncodeNamedBitList(Byte[] bigEndianBytes, int namedBitsCount);
    internal static Byte[][] SegmentedEncodeOctetString(Byte[] data);
    internal static Byte[][] SegmentedEncodeNull();
    internal static Byte[] EncodeOid(string oidValue);
    internal static Byte[][] SegmentedEncodeOid(Oid oid);
    internal static Byte[][] SegmentedEncodeOid(string oidValue);
    internal static Byte[][] SegmentedEncodeUtf8String(Char[] chars);
    internal static Byte[][] SegmentedEncodeUtf8String(Char[] chars, int offset, int count);
    internal static Byte[][] ConstructSegmentedSequence(Byte[][][] items);
    internal static Byte[][] ConstructSegmentedSequence(IEnumerable`1<Byte[][]> items);
    internal static Byte[][] ConstructSegmentedContextSpecificValue(int contextId, Byte[][][] items);
    internal static Byte[][] ConstructSegmentedSet(Byte[][][] items);
    internal static Byte[][] ConstructSegmentedPresortedSet(Byte[][][] items);
    internal static bool IsValidPrintableString(Char[] chars);
    internal static bool IsValidPrintableString(Char[] chars, int offset, int count);
    internal static Byte[][] SegmentedEncodePrintableString(Char[] chars);
    internal static Byte[][] SegmentedEncodePrintableString(Char[] chars, int offset, int count);
    internal static Byte[][] SegmentedEncodeIA5String(Char[] chars);
    internal static Byte[][] SegmentedEncodeIA5String(Char[] chars, int offset, int count);
    internal static Byte[][] SegmentedEncodeUtcTime(DateTime utcTime);
    internal static Byte[][] SegmentedEncodeGeneralizedTime(DateTime utcTime);
    internal static Byte[] ConstructSequence(Byte[][][] items);
    internal static Byte[] ConstructSequence(IEnumerable`1<Byte[][]> items);
    private static BigInteger ParseOidRid(string oidValue, Int32& startIndex);
    private static int AtoI(char c);
    private static void EncodeRid(List`1<byte> encodedData, BigInteger& rid);
    private static bool IsPrintableStringCharacter(char c);
    private static Byte[] ConcatenateArrays(Byte[][][] segments);
    private static Byte[] ConcatenateArrays(IEnumerable`1<Byte[][]> segments);
}
public class NuGet.Packaging.Signing.DerEncoding.DerGeneralizedTime : object {
    [CompilerGeneratedAttribute]
private DateTime <DateTime>k__BackingField;
    public DateTime DateTime { get; }
    private DerGeneralizedTime(DateTime datetime);
    [CompilerGeneratedAttribute]
public DateTime get_DateTime();
    public static DerGeneralizedTime Read(string decodedTime);
}
internal class NuGet.Packaging.Signing.DerEncoding.DerSequenceReader : object {
    internal static byte ContextSpecificTagFlag;
    internal static byte ConstructedFlag;
    internal static byte ContextSpecificConstructedTag0;
    internal static byte ContextSpecificConstructedTag1;
    internal static byte ContextSpecificConstructedTag2;
    internal static byte ContextSpecificConstructedTag3;
    internal static byte ContextSpecificConstructedTag4;
    internal static byte ConstructedSequence;
    internal static byte TagClassMask;
    internal static byte TagNumberMask;
    internal static DateTimeFormatInfo s_validityDateTimeFormatInfo;
    private Byte[] _data;
    private int _end;
    private int _position;
    [CompilerGeneratedAttribute]
private int <ContentLength>k__BackingField;
    internal int ContentLength { get; private set; }
    internal bool HasData { get; }
    private DerSequenceReader(bool startAtPayload, Byte[] data, int offset, int length);
    internal DerSequenceReader(Byte[] data);
    internal DerSequenceReader(Byte[] data, int offset, int length);
    private DerSequenceReader(DerTag tagToEat, Byte[] data, int offset, int length);
    [CompilerGeneratedAttribute]
internal int get_ContentLength();
    [CompilerGeneratedAttribute]
private void set_ContentLength(int value);
    internal static DerSequenceReader CreateForPayload(Byte[] payload);
    internal bool get_HasData();
    internal byte PeekTag();
    internal bool HasTag(DerTag expectedTag);
    internal bool HasTag(byte expectedTag);
    internal void SkipValue();
    internal void ValidateAndSkipDerValue();
    internal Byte[] ReadNextEncodedValue();
    internal bool ReadBoolean();
    internal Byte[] ReadValue(DerTag tag);
    internal int ReadInteger();
    internal Byte[] ReadIntegerBytes();
    internal Byte[] ReadBitString();
    internal Byte[] ReadOctetString();
    internal string ReadOidAsString();
    internal Oid ReadOid();
    internal string ReadUtf8String();
    private DerSequenceReader ReadCollectionWithTag(DerTag expected);
    internal DerSequenceReader ReadSequence();
    internal DerSequenceReader ReadSet();
    internal string ReadPrintableString();
    internal string ReadIA5String();
    internal DateTime ReadX509Date();
    internal DateTime ReadUtcTime();
    internal DateTime ReadGeneralizedTime();
    internal string ReadBMPString();
    internal void ReadNull();
    private static string TrimTrailingNulls(string value);
    private DateTime ReadTime(DerTag timeTag, string formatString);
    private Byte[] ReadContentAsBytes();
    private void EatTag(DerTag expected);
    private static void CheckTag(DerTag expected, Byte[] data, int position);
    private int EatLength();
    private static int ScanContentLength(Byte[] data, int offset, int end, Int32& bytesConsumed);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Packaging.Signing.DerEncoding.SR : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Argument_InvalidOidValue { get; }
    internal static string Cryptography_Der_Invalid_Encoding { get; }
    internal static string Cryptography_Invalid_IA5String { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Argument_InvalidOidValue();
    internal static string get_Cryptography_Der_Invalid_Encoding();
    internal static string get_Cryptography_Invalid_IA5String();
}
internal class NuGet.Packaging.Signing.DotNetDefaultTrustStoreX509ChainFactory : object {
    public sealed virtual IX509Chain Create();
}
internal class NuGet.Packaging.Signing.EndOfCentralDirectoryRecord : object {
    private static IReadOnlyList`1<byte> Signature;
    [CompilerGeneratedAttribute]
private ushort <NumberOfThisDisk>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <NumberOfTheDiskWithTheStartOfTheCentralDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <CountOfEntriesInCentralDirectoryOnThisDisk>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <CountOfEntriesInCentralDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <SizeOfCentralDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <OffsetOfStartOfCentralDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <FileCommentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <FileComment>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OffsetFromStart>k__BackingField;
    internal ushort NumberOfThisDisk { get; private set; }
    internal ushort NumberOfTheDiskWithTheStartOfTheCentralDirectory { get; private set; }
    internal ushort CountOfEntriesInCentralDirectoryOnThisDisk { get; private set; }
    internal ushort CountOfEntriesInCentralDirectory { get; private set; }
    internal UInt32 SizeOfCentralDirectory { get; private set; }
    internal UInt32 OffsetOfStartOfCentralDirectory { get; private set; }
    internal ushort FileCommentLength { get; private set; }
    internal Byte[] FileComment { get; private set; }
    internal long OffsetFromStart { get; private set; }
    private static EndOfCentralDirectoryRecord();
    [CompilerGeneratedAttribute]
internal ushort get_NumberOfThisDisk();
    [CompilerGeneratedAttribute]
private void set_NumberOfThisDisk(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_NumberOfTheDiskWithTheStartOfTheCentralDirectory();
    [CompilerGeneratedAttribute]
private void set_NumberOfTheDiskWithTheStartOfTheCentralDirectory(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_CountOfEntriesInCentralDirectoryOnThisDisk();
    [CompilerGeneratedAttribute]
private void set_CountOfEntriesInCentralDirectoryOnThisDisk(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_CountOfEntriesInCentralDirectory();
    [CompilerGeneratedAttribute]
private void set_CountOfEntriesInCentralDirectory(ushort value);
    [CompilerGeneratedAttribute]
internal UInt32 get_SizeOfCentralDirectory();
    [CompilerGeneratedAttribute]
private void set_SizeOfCentralDirectory(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_OffsetOfStartOfCentralDirectory();
    [CompilerGeneratedAttribute]
private void set_OffsetOfStartOfCentralDirectory(UInt32 value);
    [CompilerGeneratedAttribute]
internal ushort get_FileCommentLength();
    [CompilerGeneratedAttribute]
private void set_FileCommentLength(ushort value);
    [CompilerGeneratedAttribute]
internal Byte[] get_FileComment();
    [CompilerGeneratedAttribute]
private void set_FileComment(Byte[] value);
    [CompilerGeneratedAttribute]
internal long get_OffsetFromStart();
    [CompilerGeneratedAttribute]
private void set_OffsetFromStart(long value);
    internal static EndOfCentralDirectoryRecord Read(BinaryReader reader);
    private static void SeekToEndOfCentralDirectoryRecord(BinaryReader reader);
    private static void ThrowByteSignatureNotFoundException(IReadOnlyList`1<byte> signature);
}
internal static class NuGet.Packaging.Signing.EnvironmentVariableConstants : object {
    internal static string DotNetNuGetSignatureVerification;
}
public class NuGet.Packaging.Signing.EssCertId : object {
    [CompilerGeneratedAttribute]
private Byte[] <CertificateHash>k__BackingField;
    [CompilerGeneratedAttribute]
private IssuerSerial <IssuerSerial>k__BackingField;
    public Byte[] CertificateHash { get; }
    public IssuerSerial IssuerSerial { get; }
    private EssCertId(Byte[] hash, IssuerSerial issuerSerial);
    [CompilerGeneratedAttribute]
public Byte[] get_CertificateHash();
    [CompilerGeneratedAttribute]
public IssuerSerial get_IssuerSerial();
    public static EssCertId Read(Byte[] bytes);
    internal static EssCertId Read(DerSequenceReader reader);
}
public class NuGet.Packaging.Signing.EssCertIdV2 : object {
    [CompilerGeneratedAttribute]
private AlgorithmIdentifier <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <CertificateHash>k__BackingField;
    [CompilerGeneratedAttribute]
private IssuerSerial <IssuerSerial>k__BackingField;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public Byte[] CertificateHash { get; }
    public IssuerSerial IssuerSerial { get; }
    private EssCertIdV2(AlgorithmIdentifier hashAlgorithm, Byte[] hash, IssuerSerial issuerSerial);
    [CompilerGeneratedAttribute]
public AlgorithmIdentifier get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public Byte[] get_CertificateHash();
    [CompilerGeneratedAttribute]
public IssuerSerial get_IssuerSerial();
    public static EssCertIdV2 Create(X509Certificate2 certificate, HashAlgorithmName hashAlgorithmName);
    public static EssCertIdV2 Read(Byte[] bytes);
    internal static EssCertIdV2 Read(DerSequenceReader reader);
    internal Byte[][] Encode();
}
public class NuGet.Packaging.Signing.Extension : object {
    [CompilerGeneratedAttribute]
private Oid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Critical>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Value>k__BackingField;
    public Oid Id { get; }
    public bool Critical { get; }
    public Byte[] Value { get; }
    private Extension(Oid id, bool critical, Byte[] value);
    [CompilerGeneratedAttribute]
public Oid get_Id();
    [CompilerGeneratedAttribute]
public bool get_Critical();
    [CompilerGeneratedAttribute]
public Byte[] get_Value();
    internal static Extension Read(DerSequenceReader reader);
}
public class NuGet.Packaging.Signing.Extensions : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Extension> <ExtensionsList>k__BackingField;
    public IReadOnlyList`1<Extension> ExtensionsList { get; }
    private Extensions(IReadOnlyList`1<Extension> extensions);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Extension> get_ExtensionsList();
    public static Extensions Read(Byte[] bytes);
    internal static Extensions Read(DerSequenceReader reader);
}
internal class NuGet.Packaging.Signing.ExtraField : object {
    [CompilerGeneratedAttribute]
private ushort <HeaderId>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <DataSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    internal ushort HeaderId { get; private set; }
    internal ushort DataSize { get; private set; }
    internal Byte[] Data { get; private set; }
    protected ExtraField(ushort headerId, ushort dataSize, Byte[] data);
    [CompilerGeneratedAttribute]
internal ushort get_HeaderId();
    [CompilerGeneratedAttribute]
private void set_HeaderId(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_DataSize();
    [CompilerGeneratedAttribute]
private void set_DataSize(ushort value);
    [CompilerGeneratedAttribute]
internal Byte[] get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(Byte[] value);
    internal static bool TryRead(CentralDirectoryHeader header, IReadOnlyList`1& extraFields);
    internal static bool TryRead(LocalFileHeader header, IReadOnlyList`1& extraFields);
    private static bool TryRead(Byte[] extraFieldBytes, bool readUncompressedFileSize, bool readCompressedFileSize, bool readRelativeOffsetOfLocalHeader, bool readDiskNumberStart, IReadOnlyList`1& extraFields);
}
public class NuGet.Packaging.Signing.GeneralName : object {
    [CompilerGeneratedAttribute]
private X500DistinguishedName <DirectoryName>k__BackingField;
    public X500DistinguishedName DirectoryName { get; }
    private GeneralName(X500DistinguishedName directoryName);
    [CompilerGeneratedAttribute]
public X500DistinguishedName get_DirectoryName();
    public static GeneralName Create(X500DistinguishedName distinguishedName);
    public static GeneralName Read(Byte[] bytes);
    internal static GeneralName Read(DerSequenceReader reader);
    internal Byte[][] Encode();
}
internal class NuGet.Packaging.Signing.HeapBlockRetainer : object {
    private List`1<SafeLocalAllocHandle> _blocks;
    public IntPtr Alloc(int cbSize);
    public IntPtr Alloc(int howMany, int cbElement);
    public IntPtr AllocAsciiString(string s);
    public IntPtr AllocBytes(Byte[] data);
    public sealed virtual void Dispose();
}
internal interface NuGet.Packaging.Signing.ICms {
    public abstract virtual Byte[] GetPrimarySignatureSignatureValue();
    public abstract virtual Byte[] GetRepositoryCountersignatureSignatureValue();
    public abstract virtual void AddCertificates(IEnumerable`1<X509Certificate2> certificates);
    public abstract virtual void AddCountersignature(CmsSigner cmsSigner, CngKey privateKey);
    public abstract virtual void AddTimestampToRepositoryCountersignature(SignedCms timestamp);
    public abstract virtual void AddTimestamp(SignedCms timestamp);
    public abstract virtual Byte[] Encode();
}
public class NuGet.Packaging.Signing.IntegrityVerificationProvider : object {
    public sealed virtual Task`1<PackageVerificationResult> GetTrustResultAsync(ISignedPackageReader package, PrimarySignature signature, SignedPackageVerifierSettings settings, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.IntegrityVerificationProvider/<VerifyPackageIntegrityAsync>d__1")]
private Task`1<PackageVerificationResult> VerifyPackageIntegrityAsync(ISignedPackageReader package, PrimarySignature signature, SignedPackageVerifierSettings settings);
}
public class NuGet.Packaging.Signing.InvalidSignaturePackageVerificationResult : PackageVerificationResult {
    public InvalidSignaturePackageVerificationResult(SignatureVerificationStatus trust, IEnumerable`1<SignatureLog> issues);
}
public interface NuGet.Packaging.Signing.IPackageSignatureVerifier {
    public abstract virtual Task`1<VerifySignaturesResult> VerifySignaturesAsync(ISignedPackageReader package, SignedPackageVerifierSettings settings, CancellationToken token, Guid telemetryOperationId);
}
public interface NuGet.Packaging.Signing.IRepositorySignature {
    public Uri V3ServiceIndexUrl { get; }
    public IReadOnlyList`1<string> PackageOwners { get; }
    public abstract virtual Uri get_V3ServiceIndexUrl();
    public abstract virtual IReadOnlyList`1<string> get_PackageOwners();
}
internal interface NuGet.Packaging.Signing.IRfc3161TimestampRequest {
    public abstract virtual Task`1<IRfc3161TimestampToken> SubmitRequestAsync(Uri timestampUri, TimeSpan timeout);
    public abstract virtual Byte[] GetNonce();
}
internal interface NuGet.Packaging.Signing.IRfc3161TimestampToken {
    public IRfc3161TimestampTokenInfo TokenInfo { get; }
    public abstract virtual IRfc3161TimestampTokenInfo get_TokenInfo();
    public abstract virtual SignedCms AsSignedCms();
}
internal interface NuGet.Packaging.Signing.IRfc3161TimestampTokenInfo {
    public string PolicyId { get; }
    public DateTimeOffset Timestamp { get; }
    public Nullable`1<long> AccuracyInMicroseconds { get; }
    public Oid HashAlgorithmId { get; }
    public abstract virtual string get_PolicyId();
    public abstract virtual DateTimeOffset get_Timestamp();
    public abstract virtual Nullable`1<long> get_AccuracyInMicroseconds();
    public abstract virtual Oid get_HashAlgorithmId();
    public abstract virtual bool HasMessageHash(Byte[] hash);
    public abstract virtual Byte[] GetNonce();
}
public interface NuGet.Packaging.Signing.ISignature {
    public SignatureType Type { get; }
    public SignerInfo SignerInfo { get; }
    public abstract virtual SignatureType get_Type();
    public abstract virtual SignerInfo get_SignerInfo();
}
public interface NuGet.Packaging.Signing.ISignatureProvider {
    public abstract virtual Task`1<PrimarySignature> CreatePrimarySignatureAsync(SignPackageRequest request, SignatureContent signatureContent, ILogger logger, CancellationToken token);
    public abstract virtual Task`1<PrimarySignature> CreateRepositoryCountersignatureAsync(RepositorySignPackageRequest request, PrimarySignature primarySignature, ILogger logger, CancellationToken token);
}
public interface NuGet.Packaging.Signing.ISignatureVerificationProvider {
    public abstract virtual Task`1<PackageVerificationResult> GetTrustResultAsync(ISignedPackageReader package, PrimarySignature signature, SignedPackageVerifierSettings settings, CancellationToken token);
}
public interface NuGet.Packaging.Signing.ISignedPackage {
}
public interface NuGet.Packaging.Signing.ISignedPackageReader {
    public abstract virtual Task`1<PrimarySignature> GetPrimarySignatureAsync(CancellationToken token);
    public abstract virtual Task`1<bool> IsSignedAsync(CancellationToken token);
    public abstract virtual Task`1<Byte[]> GetArchiveHashAsync(HashAlgorithmName hashAlgorithm, CancellationToken token);
    public abstract virtual Task ValidateIntegrityAsync(SignatureContent signatureContent, CancellationToken token);
    public abstract virtual string GetContentHash(CancellationToken token, Func`1<string> GetUnsignedPackageHash);
    public abstract virtual bool CanVerifySignedPackages(SignedPackageVerifierSettings verifierSettings);
}
public interface NuGet.Packaging.Signing.ISignedPackageWriter {
    public abstract virtual Task RemoveSignatureAsync(CancellationToken token);
    public abstract virtual Task AddSignatureAsync(Stream signatureStream, CancellationToken token);
    public abstract virtual Task`1<bool> IsZip64Async(CancellationToken token);
}
public class NuGet.Packaging.Signing.IssuerSerial : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<GeneralName> <GeneralNames>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <SerialNumber>k__BackingField;
    public IReadOnlyList`1<GeneralName> GeneralNames { get; }
    public Byte[] SerialNumber { get; }
    private IssuerSerial(IReadOnlyList`1<GeneralName> generalNames, Byte[] serialNumber);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<GeneralName> get_GeneralNames();
    [CompilerGeneratedAttribute]
public Byte[] get_SerialNumber();
    public static IssuerSerial Create(X509Certificate2 certificate);
    public static IssuerSerial Read(Byte[] bytes);
    internal static IssuerSerial Read(DerSequenceReader reader);
    internal Byte[][] Encode();
    private static IReadOnlyList`1<GeneralName> ReadGeneralNames(DerSequenceReader reader);
}
public interface NuGet.Packaging.Signing.ITimestampProvider {
    public abstract virtual Task`1<PrimarySignature> TimestampSignatureAsync(PrimarySignature primarySignature, TimestampRequest request, ILogger logger, CancellationToken token);
}
public interface NuGet.Packaging.Signing.ITrustedSignersProvider {
    public abstract virtual IReadOnlyList`1<TrustedSignerItem> GetTrustedSigners();
    public abstract virtual void AddOrUpdateTrustedSigner(TrustedSignerItem trustedSigner);
    public abstract virtual void Remove(IReadOnlyList`1<TrustedSignerItem> trustedSigners);
}
public interface NuGet.Packaging.Signing.IX509CertificateChain {
}
internal interface NuGet.Packaging.Signing.IX509Chain {
    public ILogMessage AdditionalContext { get; }
    public X509Chain PrivateReference { get; }
    public X509ChainElementCollection ChainElements { get; }
    public X509ChainPolicy ChainPolicy { get; }
    public X509ChainStatus[] ChainStatus { get; }
    public abstract virtual ILogMessage get_AdditionalContext();
    public abstract virtual X509Chain get_PrivateReference();
    public abstract virtual X509ChainElementCollection get_ChainElements();
    public abstract virtual X509ChainPolicy get_ChainPolicy();
    public abstract virtual X509ChainStatus[] get_ChainStatus();
    public abstract virtual bool Build(X509Certificate2 certificate);
}
internal interface NuGet.Packaging.Signing.IX509ChainBuildPolicy {
    public abstract virtual bool Build(IX509Chain chain, X509Certificate2 certificate);
}
internal interface NuGet.Packaging.Signing.IX509ChainFactory {
    public abstract virtual IX509Chain Create();
}
public class NuGet.Packaging.Signing.KeyPairFileReader : object {
    private static Regex NamePattern;
    private StreamReader _reader;
    private bool _disposed;
    public KeyPairFileReader(Stream stream, Encoding encoding);
    private static KeyPairFileReader();
    public Dictionary`2<string, string> ReadSection();
    private static KeyValuePair`2<string, string> GetProperty(string line);
    private static void ThrowInvalidFormat();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public static class NuGet.Packaging.Signing.KeyPairFileUtility : object {
    public static string GetValueOrThrow(Dictionary`2<string, string> values, string key);
}
public class NuGet.Packaging.Signing.KeyPairFileWriter : object {
    private StreamWriter _writer;
    private bool _disposed;
    public KeyPairFileWriter(Stream stream, Encoding encoding, bool leaveOpen);
    public void WritePair(string key, string value);
    public void WriteSectionBreak();
    private void WriteEOL();
    private static string FormatItem(string key, string value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class NuGet.Packaging.Signing.LocalFileHeader : object {
    internal static UInt32 SizeInBytesOfFixedLengthFields;
    internal static UInt32 Signature;
    [CompilerGeneratedAttribute]
private ushort <VersionNeededToExtract>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <GeneralPurposeBitFlag>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <CompressionMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <LastModFileTime>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <LastModFileDate>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Crc32>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <UncompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <FileNameLength>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <ExtraFieldLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ExtraField>k__BackingField;
    internal ushort VersionNeededToExtract { get; private set; }
    internal ushort GeneralPurposeBitFlag { get; private set; }
    internal ushort CompressionMethod { get; private set; }
    internal ushort LastModFileTime { get; private set; }
    internal ushort LastModFileDate { get; private set; }
    internal UInt32 Crc32 { get; private set; }
    internal UInt32 CompressedSize { get; private set; }
    internal UInt32 UncompressedSize { get; private set; }
    internal ushort FileNameLength { get; private set; }
    internal ushort ExtraFieldLength { get; private set; }
    internal Byte[] FileName { get; private set; }
    internal Byte[] ExtraField { get; private set; }
    [CompilerGeneratedAttribute]
internal ushort get_VersionNeededToExtract();
    [CompilerGeneratedAttribute]
private void set_VersionNeededToExtract(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_GeneralPurposeBitFlag();
    [CompilerGeneratedAttribute]
private void set_GeneralPurposeBitFlag(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_CompressionMethod();
    [CompilerGeneratedAttribute]
private void set_CompressionMethod(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_LastModFileTime();
    [CompilerGeneratedAttribute]
private void set_LastModFileTime(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_LastModFileDate();
    [CompilerGeneratedAttribute]
private void set_LastModFileDate(ushort value);
    [CompilerGeneratedAttribute]
internal UInt32 get_Crc32();
    [CompilerGeneratedAttribute]
private void set_Crc32(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_CompressedSize();
    [CompilerGeneratedAttribute]
private void set_CompressedSize(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_UncompressedSize();
    [CompilerGeneratedAttribute]
private void set_UncompressedSize(UInt32 value);
    [CompilerGeneratedAttribute]
internal ushort get_FileNameLength();
    [CompilerGeneratedAttribute]
private void set_FileNameLength(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_ExtraFieldLength();
    [CompilerGeneratedAttribute]
private void set_ExtraFieldLength(ushort value);
    [CompilerGeneratedAttribute]
internal Byte[] get_FileName();
    [CompilerGeneratedAttribute]
private void set_FileName(Byte[] value);
    [CompilerGeneratedAttribute]
internal Byte[] get_ExtraField();
    [CompilerGeneratedAttribute]
private void set_ExtraField(Byte[] value);
    internal static bool TryRead(BinaryReader reader, LocalFileHeader& header);
}
public class NuGet.Packaging.Signing.MessageImprint : object {
    [CompilerGeneratedAttribute]
private AlgorithmIdentifier <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <HashedMessage>k__BackingField;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public Byte[] HashedMessage { get; }
    private MessageImprint(AlgorithmIdentifier hashAlgorithm, Byte[] hashedMessage);
    [CompilerGeneratedAttribute]
public AlgorithmIdentifier get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public Byte[] get_HashedMessage();
    public static MessageImprint Read(Byte[] bytes);
    internal static MessageImprint Read(DerSequenceReader reader);
}
internal class NuGet.Packaging.Signing.NativeCms : object {
    private SafeCryptMsgHandle _handle;
    private NativeCms(SafeCryptMsgHandle handle);
    internal Byte[] GetPrimarySignatureSignatureValue();
    private Byte[] GetByteArrayAttribute(CMSG_GETPARAM_TYPE param, UInt32 index);
    internal Byte[] GetRepositoryCountersignatureSignatureValue();
    private Nullable`1<RepositoryCounterSignerInfo> GetRepositoryCountersignature(HeapBlockRetainer retainer);
    private static bool IsRepositoryCounterSignerInfo(CMSG_SIGNER_INFO counterSignerInfo);
    private static bool IsRepositoryCounterSignerInfo(CRYPT_ATTRIBUTE_STRING commitmentTypeIndicationAttribute);
    internal static NativeCms Decode(Byte[] input);
    internal void AddCertificates(IEnumerable`1<X509Certificate2> certificates);
    internal void AddCountersignature(CmsSigner cmsSigner, CngKey privateKey);
    internal void AddTimestampToRepositoryCountersignature(SignedCms timestamp);
    internal void AddTimestamp(SignedCms timestamp);
    private static CRYPT_ATTRIBUTE GetCryptAttributeForData(Byte[] data, string attributeOid, HeapBlockRetainer hb);
    private static CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA CreateUnsignedAddAttribute(CRYPT_ATTRIBUTE attr, HeapBlockRetainer hb);
    internal Byte[] Encode();
    public sealed virtual void Dispose();
}
internal class NuGet.Packaging.Signing.NativeCmsWrapper : object {
    private NativeCms _nativeCms;
    public NativeCmsWrapper(NativeCms nativeCms);
    public sealed virtual Byte[] GetPrimarySignatureSignatureValue();
    public sealed virtual Byte[] GetRepositoryCountersignatureSignatureValue();
    public sealed virtual void AddCertificates(IEnumerable`1<X509Certificate2> certificates);
    public sealed virtual void AddCountersignature(CmsSigner cmsSigner, CngKey privateKey);
    public sealed virtual void AddTimestampToRepositoryCountersignature(SignedCms timestamp);
    public sealed virtual void AddTimestamp(SignedCms timestamp);
    public sealed virtual Byte[] Encode();
    public sealed virtual void Dispose();
}
internal static class NuGet.Packaging.Signing.NativeMethods : object {
    internal static UInt32 PKCS_ATTRIBUTE;
    internal static UInt32 PKCS7_SIGNER_INFO;
    internal static int ERROR_MORE_DATA;
    internal static UInt32 CMSG_SIGNED;
    internal static UInt32 CERT_KEY_IDENTIFIER_PROP_ID;
    internal static UInt32 CERT_ID_KEY_IDENTIFIER;
    public static SafeCryptMsgHandle CryptMsgOpenToEncode(CMSG_ENCODING dwMsgEncodingType, UInt32 dwFlags, UInt32 dwMsgType, CMSG_SIGNED_ENCODE_INFO& pvMsgEncodeInfo, string pszInnerContentObjID, IntPtr pStreamInfo);
    public static SafeCryptMsgHandle CryptMsgOpenToDecode(CMSG_ENCODING dwMsgEncodingType, CMSG_OPENTODECODE_FLAGS dwFlags, UInt32 dwMsgType, IntPtr hCryptProv, IntPtr pRecipientInfo, IntPtr pStreamInfo);
    public static bool CryptMsgCountersign(SafeCryptMsgHandle hCryptMsg, UInt32 dwIndex, int cCountersigners, CMSG_SIGNER_ENCODE_INFO rgCountersigners);
    public static bool CryptMsgClose(IntPtr hCryptMsg);
    public static bool CryptMsgUpdate(SafeCryptMsgHandle hCryptMsg, Byte[] pbData, UInt32 cbData, bool fFinal);
    public static bool CryptMsgGetParam(SafeCryptMsgHandle hCryptMsg, CMSG_GETPARAM_TYPE dwParamType, UInt32 dwIndex, Byte[] pvData, UInt32& pcbData);
    internal static bool CryptMsgGetParam(SafeCryptMsgHandle hCryptMsg, CMSG_GETPARAM_TYPE dwParamType, UInt32 dwIndex, IntPtr pvData, UInt32& pcbData);
    internal static bool CryptDecodeObject(CMSG_ENCODING dwCertEncodingType, IntPtr lpszStructType, IntPtr pbEncoded, UInt32 cbEncoded, UInt32 dwFlags, IntPtr pvStructInfo, IntPtr pcbStructInfo);
    internal static bool CryptMsgControl(SafeCryptMsgHandle hCryptMsg, UInt32 dwFlags, CMSG_CONTROL_TYPE dwCtrlType, IntPtr pvCtrlPara);
    internal static bool CryptEncodeObjectEx(CMSG_ENCODING dwCertEncodingType, IntPtr lpszStructType, IntPtr pvStructInfo, UInt32 dwFlags, IntPtr pEncodePara, IntPtr pvEncoded, UInt32& pcbEncoded);
    internal static bool CryptReleaseContext(IntPtr hProv, int dwFlags);
    internal static IntPtr CertDuplicateCertificateContext(IntPtr pCertContext);
    internal static bool CertFreeCertificateContext(IntPtr pCertContext);
    internal static bool CertGetCertificateContextProperty(IntPtr pCertContext, UInt32 dwPropId, IntPtr pvData, UInt32& pcbData);
    internal static int GetHRForWin32Error(int err);
}
internal static class NuGet.Packaging.Signing.NativeUtility : object {
    internal static void SafeFree(IntPtr ptr);
    internal static void ThrowIfFailed(bool result);
    internal static SignedCms NativeSign(CmsSigner cmsSigner, Byte[] data, CngKey privateKey);
    internal static CMSG_SIGNER_ENCODE_INFO CreateSignerInfo(CmsSigner cmsSigner, CngKey privateKey, HeapBlockRetainer hb);
}
public class NuGet.Packaging.Signing.NuGetPackageOwners : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <PackageOwners>k__BackingField;
    public IReadOnlyList`1<string> PackageOwners { get; }
    public NuGetPackageOwners(IReadOnlyList`1<string> packageOwners);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_PackageOwners();
    public static NuGetPackageOwners Read(Byte[] bytes);
    internal static NuGetPackageOwners Read(DerSequenceReader reader);
    public Byte[] Encode();
}
public class NuGet.Packaging.Signing.NuGetV3ServiceIndexUrl : object {
    [CompilerGeneratedAttribute]
private Uri <V3ServiceIndexUrl>k__BackingField;
    public Uri V3ServiceIndexUrl { get; }
    public NuGetV3ServiceIndexUrl(Uri v3ServiceIndexUrl);
    [CompilerGeneratedAttribute]
public Uri get_V3ServiceIndexUrl();
    public static NuGetV3ServiceIndexUrl Read(Byte[] bytes);
    internal static NuGetV3ServiceIndexUrl Read(DerSequenceReader reader);
    public Byte[] Encode();
}
public static class NuGet.Packaging.Signing.Oids : object {
    public static string SigningTime;
    public static string Countersignature;
    public static string SignatureTimeStampTokenAttribute;
    public static string Sha1;
    public static string Sha256;
    public static string Sha384;
    public static string Sha512;
    public static string Sha256WithRSAEncryption;
    public static string Sha384WithRSAEncryption;
    public static string Sha512WithRSAEncryption;
    public static string CodeSigningEku;
    public static string Pkcs7Data;
    public static string BaselineTimestampPolicy;
    public static string TimeStampingEku;
    public static string EnhancedKeyUsage;
    public static string TSTInfoContentType;
    public static string LifetimeSigningEku;
    public static string CommitmentTypeIndication;
    public static string CommitmentTypeIdentifierProofOfOrigin;
    public static string CommitmentTypeIdentifierProofOfReceipt;
    public static string SigningCertificate;
    public static string SigningCertificateV2;
    public static string AuthorityKeyIdentifier;
    public static string SubjectKeyIdentifier;
    public static string AnyPolicy;
    public static string IdQtCps;
    public static string IdQtUnotice;
    public static string NuGetV3ServiceIndexUrl;
    public static string NuGetPackageOwners;
}
public class NuGet.Packaging.Signing.PackageSignatureVerifier : object {
    private List`1<ISignatureVerificationProvider> _verificationProviders;
    public PackageSignatureVerifier(IEnumerable`1<ISignatureVerificationProvider> verificationProviders);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.PackageSignatureVerifier/<VerifySignaturesAsync>d__2")]
public sealed virtual Task`1<VerifySignaturesResult> VerifySignaturesAsync(ISignedPackageReader package, SignedPackageVerifierSettings settings, CancellationToken token, Guid parentId);
    private static bool IsValid(IEnumerable`1<PackageVerificationResult> verificationResults);
}
public abstract class NuGet.Packaging.Signing.PackageVerificationResult : object {
    [CompilerGeneratedAttribute]
private SignatureVerificationStatus <Trust>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<SignatureLog> <Issues>k__BackingField;
    public SignatureVerificationStatus Trust { get; }
    public IEnumerable`1<SignatureLog> Issues { get; }
    public PackageVerificationResult(SignatureVerificationStatus trust, IEnumerable`1<SignatureLog> issues);
    [CompilerGeneratedAttribute]
public virtual SignatureVerificationStatus get_Trust();
    [CompilerGeneratedAttribute]
public virtual IEnumerable`1<SignatureLog> get_Issues();
    public IEnumerable`1<ILogMessage> GetWarningIssues();
    public IEnumerable`1<ILogMessage> GetErrorIssues();
}
public class NuGet.Packaging.Signing.PolicyInformation : object {
    [CompilerGeneratedAttribute]
private Oid <PolicyIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PolicyQualifierInfo> <PolicyQualifiers>k__BackingField;
    public Oid PolicyIdentifier { get; }
    public IReadOnlyList`1<PolicyQualifierInfo> PolicyQualifiers { get; }
    private PolicyInformation(Oid policyIdentifier, IReadOnlyList`1<PolicyQualifierInfo> policyQualifiers);
    [CompilerGeneratedAttribute]
public Oid get_PolicyIdentifier();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PolicyQualifierInfo> get_PolicyQualifiers();
    public static PolicyInformation Read(Byte[] bytes);
    internal static PolicyInformation Read(DerSequenceReader reader);
    private static IReadOnlyList`1<PolicyQualifierInfo> ReadPolicyQualifiers(DerSequenceReader reader, bool isAnyPolicy);
}
public class NuGet.Packaging.Signing.PolicyQualifierInfo : object {
    [CompilerGeneratedAttribute]
private Oid <PolicyQualifierId>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Qualifier>k__BackingField;
    public Oid PolicyQualifierId { get; }
    public Byte[] Qualifier { get; }
    private PolicyQualifierInfo(Oid policyQualifierId, Byte[] qualifier);
    [CompilerGeneratedAttribute]
public Oid get_PolicyQualifierId();
    [CompilerGeneratedAttribute]
public Byte[] get_Qualifier();
    public static PolicyQualifierInfo Read(Byte[] bytes);
    internal static PolicyQualifierInfo Read(DerSequenceReader reader);
}
public abstract class NuGet.Packaging.Signing.PrimarySignature : Signature {
    [CompilerGeneratedAttribute]
private SignedCms <SignedCms>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureContent <SignatureContent>k__BackingField;
    public SignedCms SignedCms { get; }
    public SignatureContent SignatureContent { get; }
    public string FriendlyName { get; }
    protected PrimarySignature(SignedCms signedCms, SignatureType signatureType);
    [CompilerGeneratedAttribute]
public SignedCms get_SignedCms();
    [CompilerGeneratedAttribute]
public SignatureContent get_SignatureContent();
    public virtual string get_FriendlyName();
    public void Save(Stream stream);
    public Byte[] GetBytes();
    public static PrimarySignature Load(SignedCms cms);
    public static PrimarySignature Load(Byte[] data);
    public static PrimarySignature Load(Stream stream);
    public virtual Byte[] GetSignatureValue();
    protected virtual void ThrowForInvalidSignature();
    protected static void ThrowForInvalidPrimarySignature();
    private static void VerifySigningCertificate(SignedCms signedCms, SignerInfo signerInfo, SigningSpecifications signingSpecifications);
    private static SignerInfo GetSignerInfo(SignedCms signedCms);
    private static SignedCms Decode(Byte[] bytes);
}
public static class NuGet.Packaging.Signing.PrimarySignatureFactory : object {
    public static PrimarySignature CreateSignature(SignedCms signedCms);
}
public class NuGet.Packaging.Signing.ReadOnlyBufferedStream : Stream {
    private static int _defaultBufferSize;
    private Byte[] _buffer;
    private bool _leaveOpen;
    private Lazy`1<long> _length;
    private Stream _stream;
    private long _bufferStartPosition;
    private int _bufferFillLength;
    private bool _isDisposed;
    private long _position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public ReadOnlyBufferedStream(Stream stream, bool leaveOpen);
    public ReadOnlyBufferedStream(Stream stream, bool leaveOpen, int bufferSize);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    private void FillBuffer();
    private bool IsPositionAfterEndOfStream();
    private bool IsPositionInBuffer();
    private void ThrowIfDisposed();
    [CompilerGeneratedAttribute]
private long <.ctor>b__29_0();
}
public class NuGet.Packaging.Signing.RepositoryCountersignature : Signature {
    private PrimarySignature _primarySignature;
    [CompilerGeneratedAttribute]
private Uri <V3ServiceIndexUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <PackageOwners>k__BackingField;
    public Uri V3ServiceIndexUrl { get; }
    public IReadOnlyList`1<string> PackageOwners { get; }
    public string FriendlyName { get; }
    private RepositoryCountersignature(PrimarySignature primarySignature, SignerInfo counterSignerInfo, Uri v3ServiceIndexUrl, IReadOnlyList`1<string> packageOwners);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_V3ServiceIndexUrl();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_PackageOwners();
    public virtual string get_FriendlyName();
    public static RepositoryCountersignature GetRepositoryCountersignature(PrimarySignature primarySignature);
    public virtual Byte[] GetSignatureValue();
    protected virtual void ThrowForInvalidSignature();
    public virtual SignatureVerificationSummary Verify(Timestamp timestamp, SignatureVerifySettings settings, HashAlgorithmName fingerprintAlgorithm, X509Certificate2Collection certificateExtraStore);
    internal bool IsRelated(PrimarySignature primarySignature);
}
public class NuGet.Packaging.Signing.RepositoryPrimarySignature : PrimarySignature {
    [CompilerGeneratedAttribute]
private Uri <V3ServiceIndexUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <PackageOwners>k__BackingField;
    public Uri V3ServiceIndexUrl { get; }
    public IReadOnlyList`1<string> PackageOwners { get; }
    public string FriendlyName { get; }
    public RepositoryPrimarySignature(SignedCms signedCms);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_V3ServiceIndexUrl();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_PackageOwners();
    public virtual string get_FriendlyName();
    public virtual SignatureVerificationSummary Verify(Timestamp timestamp, SignatureVerifySettings settings, HashAlgorithmName fingerprintAlgorithm, X509Certificate2Collection certificateExtraStore);
}
public static class NuGet.Packaging.Signing.RepositorySignatureInfoUtility : object {
    public static SignedPackageVerifierSettings GetSignedPackageVerifierSettings(RepositorySignatureInfo repoSignatureInfo, SignedPackageVerifierSettings fallbackSettings);
    public static IReadOnlyCollection`1<CertificateHashAllowListEntry> GetRepositoryAllowList(IEnumerable`1<IRepositoryCertificateInfo> repositoryCertificateInfos);
}
public class NuGet.Packaging.Signing.RepositorySignPackageRequest : SignPackageRequest {
    [CompilerGeneratedAttribute]
private Uri <V3ServiceIndexUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <PackageOwners>k__BackingField;
    public Uri V3ServiceIndexUrl { get; }
    public IReadOnlyList`1<string> PackageOwners { get; }
    public SignatureType SignatureType { get; }
    public RepositorySignPackageRequest(X509Certificate2 certificate, HashAlgorithmName signatureHashAlgorithm, HashAlgorithmName timestampHashAlgorithm, Uri v3ServiceIndexUrl, IReadOnlyList`1<string> packageOwners);
    [CompilerGeneratedAttribute]
public Uri get_V3ServiceIndexUrl();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_PackageOwners();
    public virtual SignatureType get_SignatureType();
}
internal class NuGet.Packaging.Signing.RetriableX509ChainBuildPolicy : object {
    [CompilerGeneratedAttribute]
private IX509ChainBuildPolicy <InnerPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <SleepInterval>k__BackingField;
    internal IX509ChainBuildPolicy InnerPolicy { get; }
    internal int RetryCount { get; }
    internal TimeSpan SleepInterval { get; }
    internal RetriableX509ChainBuildPolicy(IX509ChainBuildPolicy innerPolicy, int retryCount, TimeSpan sleepInterval);
    [CompilerGeneratedAttribute]
internal IX509ChainBuildPolicy get_InnerPolicy();
    [CompilerGeneratedAttribute]
internal int get_RetryCount();
    [CompilerGeneratedAttribute]
internal TimeSpan get_SleepInterval();
    public sealed virtual bool Build(IX509Chain chain, X509Certificate2 certificate);
}
public class NuGet.Packaging.Signing.Rfc3161TimestampProvider : object {
    private Uri _timestamperUrl;
    private static TimeSpan RequestTimeout;
    public Rfc3161TimestampProvider(Uri timeStampServerUrl);
    private static Rfc3161TimestampProvider();
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.Rfc3161TimestampProvider/<TimestampSignatureAsync>d__3")]
public sealed virtual Task`1<PrimarySignature> TimestampSignatureAsync(PrimarySignature primarySignature, TimestampRequest request, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.Rfc3161TimestampProvider/<GetTimestampAsync>d__4")]
internal Task`1<SignedCms> GetTimestampAsync(TimestampRequest request, ILogger logger, CancellationToken token);
    private static SignedCms EnsureCertificatesInCertificatesCollection(SignedCms timestamp, IReadOnlyList`1<X509Certificate2> chain);
    private static void ValidateTimestampCms(SigningSpecifications spec, SignedCms timestampCms, IRfc3161TimestampToken timestampToken);
    private static void ValidateTimestampResponse(Byte[] nonce, Byte[] messageHash, IRfc3161TimestampToken timestampToken);
    private static string GetNameOrOidString(Oid oid);
    private static Byte[] GenerateNonce();
    internal static void EnsureValidNonce(Byte[] nonce);
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampRequest : AsnEncodedData {
    private DataType _data;
    private DataType Data { get; }
    public int Version { get; }
    public Oid HashAlgorithmId { get; }
    public Oid RequestedPolicyId { get; }
    public bool RequestSignerCertificate { get; }
    public bool HasExtensions { get; }
    public Rfc3161TimestampRequest(Byte[] encodedRequest);
    public Rfc3161TimestampRequest(Byte[] messageHash, HashAlgorithmName hashAlgorithm, Oid requestedPolicyId, Byte[] nonce, bool requestSignerCertificates, X509ExtensionCollection extensions);
    public Rfc3161TimestampRequest(Byte[] messageHash, Oid hashAlgorithmId, Oid requestedPolicyId, Byte[] nonce, bool requestSignerCertificates, X509ExtensionCollection extensions);
    private DataType get_Data();
    private static Oid OpportunisticOid(string oidValue, OidGroup group);
    public int get_Version();
    public Byte[] GetMessageHash();
    public Oid get_HashAlgorithmId();
    public Oid get_RequestedPolicyId();
    public Byte[] GetNonce();
    public bool get_RequestSignerCertificate();
    public bool get_HasExtensions();
    public X509ExtensionCollection GetExtensions();
    public IRfc3161TimestampToken SubmitRequest(Uri timestampUri, TimeSpan timeout);
    private static Byte[] Encode(DataType data);
    private static DataType Decode(Byte[] rawData);
    private static bool ResolveAlgorithm(HashAlgorithmName hashAlgorithm, Int32& expectedSizeInBytes, String& algorithmIdentifier);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampRequestFactory : object {
    public static IRfc3161TimestampRequest Create(Byte[] messageHash, HashAlgorithmName hashAlgorithm, Oid requestedPolicyId, Byte[] nonce, bool requestSignerCertificates, X509ExtensionCollection extensions);
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampRequestNet472Wrapper : object {
    private Rfc3161TimestampRequest _rfc3161TimestampRequest;
    public Rfc3161TimestampRequestNet472Wrapper(Byte[] messageHash, HashAlgorithmName hashAlgorithm, Oid requestedPolicyId, Byte[] nonce, bool requestSignerCertificates, X509ExtensionCollection extensions);
    public sealed virtual Task`1<IRfc3161TimestampToken> SubmitRequestAsync(Uri timestampUri, TimeSpan timeout);
    public sealed virtual Byte[] GetNonce();
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampToken : object {
    private Byte[] _encoded;
    [CompilerGeneratedAttribute]
private IRfc3161TimestampTokenInfo <TokenInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <SignerCertificate>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2Collection <AdditionalCerts>k__BackingField;
    public IRfc3161TimestampTokenInfo TokenInfo { get; }
    public X509Certificate2 SignerCertificate { get; }
    public X509Certificate2Collection AdditionalCerts { get; }
    internal Rfc3161TimestampToken(IRfc3161TimestampTokenInfo tstInfo, X509Certificate2 signerCertificate, X509Certificate2Collection additionalCerts, Byte[] encoded);
    [CompilerGeneratedAttribute]
public IRfc3161TimestampTokenInfo get_TokenInfo();
    [CompilerGeneratedAttribute]
public X509Certificate2 get_SignerCertificate();
    [CompilerGeneratedAttribute]
public X509Certificate2Collection get_AdditionalCerts();
    public Byte[] GetEncodedValue();
    public SignedCms AsSignedCms();
    public static Rfc3161TimestampToken LoadOnly(Byte[] encodedToken);
    public static Rfc3161TimestampToken LoadAndVerifyData(Byte[] encodedToken, Byte[] data);
    public static Rfc3161TimestampToken LoadAndVerifyHash(Byte[] encodedToken, Byte[] hash);
    private static Rfc3161TimestampToken CryptVerifyTimeStampSignature(Byte[] encodedToken, Byte[] data);
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampTokenFactory : object {
    public static IRfc3161TimestampToken Create(IRfc3161TimestampTokenInfo tstInfo, X509Certificate2 signerCertificate, X509Certificate2Collection additionalCerts, Byte[] encoded);
}
public class NuGet.Packaging.Signing.Rfc3161TimestampTokenInfo : AsnEncodedData {
    public static string TimestampTokenInfoId;
    private TstInfo _decoded;
    private TstInfo Decoded { get; }
    public int Version { get; }
    public string PolicyId { get; }
    public Oid HashAlgorithmId { get; }
    public DateTimeOffset Timestamp { get; }
    public Nullable`1<long> AccuracyInMicroseconds { get; }
    public bool IsOrdering { get; }
    public bool HasExtensions { get; }
    public Rfc3161TimestampTokenInfo(Byte[] timestampTokenInfo);
    internal Rfc3161TimestampTokenInfo(IntPtr pTsContext);
    private TstInfo get_Decoded();
    public int get_Version();
    public string get_PolicyId();
    public Oid get_HashAlgorithmId();
    public Byte[] GetMessageHash();
    public bool HasMessageHash(Byte[] hash);
    public Byte[] GetSerialNumber();
    public DateTimeOffset get_Timestamp();
    public Nullable`1<long> get_AccuracyInMicroseconds();
    public bool get_IsOrdering();
    public Byte[] GetNonce();
    public Byte[] GetTimestampAuthorityName();
    public bool get_HasExtensions();
    public X509ExtensionCollection GetExtensions();
    internal static X509ExtensionCollection ShallowCopy(X509ExtensionCollection existing, bool preserveNull);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    internal static Byte[] CopyFromNative(CRYPTOAPI_BLOB& blob);
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampTokenInfoFactory : object {
    public static IRfc3161TimestampTokenInfo Create(Byte[] bytes);
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampTokenInfoNet472Wrapper : object {
    private Rfc3161TimestampTokenInfo _rfc3161TimestampTokenInfo;
    public string PolicyId { get; }
    public DateTimeOffset Timestamp { get; }
    public Nullable`1<long> AccuracyInMicroseconds { get; }
    public Oid HashAlgorithmId { get; }
    public Rfc3161TimestampTokenInfoNet472Wrapper(Byte[] timestampTokenInfo);
    public Rfc3161TimestampTokenInfoNet472Wrapper(Rfc3161TimestampTokenInfo timestampTokenInfo);
    public sealed virtual string get_PolicyId();
    public sealed virtual DateTimeOffset get_Timestamp();
    public sealed virtual Nullable`1<long> get_AccuracyInMicroseconds();
    public sealed virtual Oid get_HashAlgorithmId();
    public sealed virtual bool HasMessageHash(Byte[] hash);
    public sealed virtual Byte[] GetNonce();
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampTokenNet472Wrapper : object {
    private Rfc3161TimestampToken _rfc3161TimestampToken;
    public IRfc3161TimestampTokenInfo TokenInfo { get; }
    public Rfc3161TimestampTokenNet472Wrapper(IRfc3161TimestampTokenInfo tstInfo, X509Certificate2 signerCertificate, X509Certificate2Collection additionalCerts, Byte[] encoded);
    public sealed virtual IRfc3161TimestampTokenInfo get_TokenInfo();
    public sealed virtual SignedCms AsSignedCms();
}
[ExtensionAttribute]
internal static class NuGet.Packaging.Signing.Rfc3161TimestampUtils : object {
    internal static bool IsLegalOid(string algorithmIdentifier);
    [ExtensionAttribute]
public static Byte[] GetSignature(SignerInfo signerInfo);
    [ExtensionAttribute]
internal static string ByteArrayToHex(Byte[] bytes);
    [ExtensionAttribute]
internal static Byte[] HexToByteArray(string hexString);
}
internal static class NuGet.Packaging.Signing.Rfc3161TimestampVerificationUtility : object {
    internal static bool ValidateSignerCertificateAgainstTimestamp(X509Certificate2 signerCertificate, Timestamp timestamp);
    internal static bool TryReadTSTInfoFromSignedCms(SignedCms timestampCms, IRfc3161TimestampTokenInfo& tstInfo);
    internal static double GetAccuracyInMilliseconds(IRfc3161TimestampTokenInfo tstInfo);
}
internal static class NuGet.Packaging.Signing.Rfc3161TimestampWin32 : object {
    internal static IntPtr TIMESTAMP_REQUEST;
    internal static IntPtr TIMESTAMP_INFO;
    private static Rfc3161TimestampWin32();
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static bool CryptRetrieveTimeStamp(string wszUrl, CryptRetrieveTimeStampFlags dwRetrievalFlags, int dwTimeout, string pszHashId, CRYPT_TIMESTAMP_PARA& pPara, Byte[] pbData, int cbData, IntPtr& ppTsContext, IntPtr& ppTsSigner, IntPtr& phStore);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static bool CryptVerifyTimeStampSignature(Byte[] pbTSContentInfo, int cbTSContentInfo, Byte[] pbData, int cbData, IntPtr hAdditionalStore, IntPtr& ppTsContext, IntPtr& ppTsSigner, IntPtr& phStore);
    [DefaultDllImportSearchPathsAttribute("2048")]
public static bool CryptEncodeObjectEx(CryptEncodingTypes dwCertEncodingType, IntPtr lpszStructType, IntPtr pvStructInfo, CryptEncodeObjectFlags dwFlags, IntPtr pEncodePara, IntPtr pvEncoded, UInt32& pcbEncoded);
    [DefaultDllImportSearchPathsAttribute("2048")]
public static bool CryptDecodeObjectEx(CryptEncodingTypes dwCertEncodingType, IntPtr lpszStructType, IntPtr pbEncoded, int cbEncoded, CryptDecodeObjectFlags dwFlags, IntPtr pDecodePara, IntPtr pvStructInfo, Int32& pcbStructInfo);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static bool CertFreeCertificateContext(IntPtr pCertContext);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static bool CertCloseStore(IntPtr pCertContext, int dwFlags);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static void CryptMemFree(IntPtr pv);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static IntPtr LocalFree(IntPtr handle);
}
internal class NuGet.Packaging.Signing.SafeCryptMsgHandle : SafeHandle {
    internal static SafeCryptMsgHandle InvalidHandle { get; }
    public bool IsInvalid { get; }
    internal SafeCryptMsgHandle(IntPtr handle);
    internal SafeCryptMsgHandle(IntPtr handle, bool ownsHandle);
    internal static SafeCryptMsgHandle get_InvalidHandle();
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class NuGet.Packaging.Signing.SafeLocalAllocHandle : SafeHandle {
    public bool IsInvalid { get; }
    internal SafeLocalAllocHandle(IntPtr handle);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
public abstract class NuGet.Packaging.Signing.Signature : object {
    private Lazy`1<IReadOnlyList`1<Timestamp>> _timestamps;
    [CompilerGeneratedAttribute]
private SignatureType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private SignerInfo <SignerInfo>k__BackingField;
    private IDictionary`2<HashAlgorithmName, string> _signingCertificateFingerprintLookup;
    public SignatureType Type { get; }
    public IReadOnlyList`1<Timestamp> Timestamps { get; }
    public SignerInfo SignerInfo { get; }
    public string FriendlyName { get; }
    protected Signature(SignerInfo signerInfo, SignatureType type);
    [CompilerGeneratedAttribute]
public sealed virtual SignatureType get_Type();
    public IReadOnlyList`1<Timestamp> get_Timestamps();
    [CompilerGeneratedAttribute]
public sealed virtual SignerInfo get_SignerInfo();
    public abstract virtual Byte[] GetSignatureValue();
    protected abstract virtual void ThrowForInvalidSignature();
    public virtual string get_FriendlyName();
    internal bool TryGetValidTimestamp(SignedPackageVerifierSettings settings, HashAlgorithmName fingerprintAlgorithm, List`1<SignatureLog> issues, SignatureVerificationStatusFlags& verificationFlags, Timestamp& validTimestamp);
    public virtual SignatureVerificationSummary Verify(Timestamp timestamp, SignatureVerifySettings settings, HashAlgorithmName fingerprintAlgorithm, X509Certificate2Collection certificateExtraStore);
    public string GetSigningCertificateFingerprint(HashAlgorithmName algorithm);
    private void VerifySigningTimeAttribute(SignerInfo signerInfo);
    private static IReadOnlyList`1<Timestamp> GetTimestamps(SignerInfo signer, string signatureFriendlyName);
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Timestamp> <.ctor>b__11_0();
}
public class NuGet.Packaging.Signing.SignatureContent : object {
    private SigningSpecifications _signingSpecifications;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HashValue>k__BackingField;
    public HashAlgorithmName HashAlgorithm { get; }
    public string HashValue { get; }
    public SignatureContent(SigningSpecifications signingSpecifications, HashAlgorithmName hashAlgorithm, string hashValue);
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public string get_HashValue();
    private void Save(Stream stream);
    public Byte[] GetBytes();
    public static SignatureContent Load(Byte[] bytes, SigningSpecifications signingSpecifications);
    private static SignatureContent Load(Stream stream, SigningSpecifications signingSpecifications);
    private static void ThrowIfEmpty(Dictionary`2<string, string> properties);
    private static bool TryReadPackageHashProperty(KeyValuePair`2<string, string> property, SigningSpecifications signingSpecifications, HashAlgorithmName& hashAlgorithmName);
    private static void ThrowIfSignatureFormatVersionIsUnsupported(Dictionary`2<string, string> properties, SigningSpecifications signingSpecifications);
}
public class NuGet.Packaging.Signing.SignatureException : PackagingException {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PackageVerificationResult> <Results>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageIdentity <PackageIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <VerifyDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLogCode <Code>k__BackingField;
    public IReadOnlyList`1<PackageVerificationResult> Results { get; }
    public PackageIdentity PackageIdentity { get; }
    public TimeSpan VerifyDuration { get; public set; }
    public NuGetLogCode Code { get; }
    public SignatureException(NuGetLogCode code, string message);
    public SignatureException(NuGetLogCode code, string message, Exception innerException);
    public SignatureException(string message);
    public SignatureException(IReadOnlyList`1<PackageVerificationResult> results, PackageIdentity package);
    public SignatureException(NuGetLogCode code, string message, PackageIdentity package);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PackageVerificationResult> get_Results();
    [CompilerGeneratedAttribute]
public PackageIdentity get_PackageIdentity();
    [CompilerGeneratedAttribute]
public TimeSpan get_VerifyDuration();
    [CompilerGeneratedAttribute]
public void set_VerifyDuration(TimeSpan value);
    [CompilerGeneratedAttribute]
public NuGetLogCode get_Code();
}
public class NuGet.Packaging.Signing.SignatureLog : object {
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLogCode <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private WarningLevel <WarningLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Time>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LibraryId>k__BackingField;
    public LogLevel Level { get; public set; }
    public string Message { get; public set; }
    public NuGetLogCode Code { get; public set; }
    public WarningLevel WarningLevel { get; public set; }
    public string ProjectPath { get; public set; }
    public DateTimeOffset Time { get; public set; }
    public string LibraryId { get; public set; }
    private SignatureLog(LogLevel level, NuGetLogCode code, string message);
    [CompilerGeneratedAttribute]
public sealed virtual LogLevel get_Level();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Level(LogLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Message(string value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetLogCode get_Code();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Code(NuGetLogCode value);
    [CompilerGeneratedAttribute]
public sealed virtual WarningLevel get_WarningLevel();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WarningLevel(WarningLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProjectPath();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Time();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Time(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_LibraryId();
    [CompilerGeneratedAttribute]
public void set_LibraryId(string value);
    public static SignatureLog MinimalLog(string message);
    public static SignatureLog InformationLog(string message);
    public static SignatureLog DetailedLog(string message);
    public static SignatureLog DebugLog(string message);
    public static SignatureLog Issue(bool fatal, NuGetLogCode code, string message);
    public static SignatureLog Error(NuGetLogCode code, string message);
    public sealed virtual bool Equals(SignatureLog other);
    public RestoreLogMessage AsRestoreLogMessage();
}
[FlagsAttribute]
public enum NuGet.Packaging.Signing.SignaturePlacement : Enum {
    public int value__;
    public static SignaturePlacement PrimarySignature;
    public static SignaturePlacement Countersignature;
    public static SignaturePlacement Any;
}
public class NuGet.Packaging.Signing.SignatureTrustAndValidityVerificationProvider : object {
    private HashAlgorithmName _fingerprintAlgorithm;
    private IEnumerable`1<KeyValuePair`2<string, HashAlgorithmName>> _allowUntrustedRootList;
    public SignatureTrustAndValidityVerificationProvider(IEnumerable`1<KeyValuePair`2<string, HashAlgorithmName>> allowUntrustedRootList);
    public sealed virtual Task`1<PackageVerificationResult> GetTrustResultAsync(ISignedPackageReader package, PrimarySignature signature, SignedPackageVerifierSettings settings, CancellationToken token);
    private PackageVerificationResult Verify(PrimarySignature signature, SignedPackageVerifierSettings settings);
    private SignatureVerificationSummary GetTimestamp(Signature signature, SignedPackageVerifierSettings verifierSettings, Timestamp& timestamp);
    private SignatureVerificationSummary VerifyValidityAndTrust(Signature signature, SignedPackageVerifierSettings verifierSettings, SignatureVerifySettings settings, X509Certificate2Collection certificateExtraStore);
    private bool IsUntrustedRootAllowed(Signature signature);
    private static bool HasUntrustedRoot(SignatureVerificationSummary summary);
    private static bool IsSignatureExpired(SignatureVerificationSummary summary);
}
public enum NuGet.Packaging.Signing.SignatureType : Enum {
    public int value__;
    public static SignatureType Unknown;
    public static SignatureType Author;
    public static SignatureType Repository;
}
public static class NuGet.Packaging.Signing.SignatureUtility : object {
    private static int SHA1HashLength;
    public static IX509CertificateChain GetCertificateChain(PrimarySignature primarySignature);
    public static IX509CertificateChain GetCertificateChain(PrimarySignature primarySignature, RepositoryCountersignature repositoryCountersignature);
    internal static IX509CertificateChain GetCertificateChain(SignedCms signedCms, SignerInfo signerInfo, SigningSpecifications signingSpecifications, string signatureFriendlyName);
    private static IX509CertificateChain GetPrimarySignatureCertificates(SignedCms signedCms, SignerInfo signerInfo, SigningSpecifications signingSpecifications, string signatureFriendlyName, bool includeChain);
    public static IX509CertificateChain GetTimestampCertificateChain(PrimarySignature primarySignature);
    public static IX509CertificateChain GetTimestampCertificateChain(PrimarySignature primarySignature, RepositoryCountersignature repositoryCountersignature);
    private static IX509CertificateChain GetRepositoryCountersignatureCertificates(SignedCms signedCms, SignerInfo signerInfo, SigningSpecifications signingSpecifications, bool includeChain);
    public static bool HasRepositoryCountersignature(PrimarySignature primarySignature);
    internal static void LogAdditionalContext(IX509Chain chain, List`1<SignatureLog> issues);
    internal static IX509CertificateChain GetTimestampCertificates(SignedCms signedCms, SigningSpecifications signingSpecifications, string signatureFriendlyName);
    private static IX509CertificateChain GetTimestampCertificates(SignedCms signedCms, SigningSpecifications signingSpecifications, string signatureFriendlyName, bool includeChain);
    private static IX509CertificateChain GetCertificates(SignedCms signedCms, SignerInfo signerInfo, SigningCertificateRequirement signingCertificateRequirement, bool isIssuerSerialRequired, Errors errors, SigningSpecifications signingSpecifications, CertificateType certificateType, bool includeChain);
    private static bool IsMatch(X509Certificate2 certificate, EssCertIdV2 essCertIdV2, Errors errors, bool isIssuerSerialRequired);
    private static bool IsMatch(X509Certificate2 certificate, EssCertId essCertId);
    private static bool AreGeneralNamesEqual(IssuerSerial issuerSerial, X509Certificate2 certificate);
    private static bool AreSerialNumbersEqual(IssuerSerial issuerSerial, X509Certificate2 certificate);
    private static IX509CertificateChain GetCertificateChain(X509Certificate2 certificate, X509Certificate2Collection extraStore, CertificateType certificateType, bool includeCertificatesAfterSigningCertificate);
    private static DerSequenceReader CreateDerSequenceReader(CryptographicAttributeObject attribute);
}
public enum NuGet.Packaging.Signing.SignatureVerificationBehavior : Enum {
    public int value__;
    public static SignatureVerificationBehavior Never;
    public static SignatureVerificationBehavior IfExists;
    public static SignatureVerificationBehavior IfExistsAndIsNecessary;
    public static SignatureVerificationBehavior Always;
}
public enum NuGet.Packaging.Signing.SignatureVerificationStatus : Enum {
    public int value__;
    public static SignatureVerificationStatus Unknown;
    public static SignatureVerificationStatus Suspect;
    public static SignatureVerificationStatus Disallowed;
    public static SignatureVerificationStatus Valid;
}
[FlagsAttribute]
public enum NuGet.Packaging.Signing.SignatureVerificationStatusFlags : Enum {
    public int value__;
    public static SignatureVerificationStatusFlags NoErrors;
    public static SignatureVerificationStatusFlags NoSignature;
    public static SignatureVerificationStatusFlags NoCertificate;
    public static SignatureVerificationStatusFlags MultipleSignatures;
    public static SignatureVerificationStatusFlags SignatureCheckFailed;
    public static SignatureVerificationStatusFlags SignatureAlgorithmUnsupported;
    public static SignatureVerificationStatusFlags CertificatePublicKeyInvalid;
    public static SignatureVerificationStatusFlags HasLifetimeSigningEku;
    public static SignatureVerificationStatusFlags CertificateValidityInTheFuture;
    public static SignatureVerificationStatusFlags CertificateExpired;
    public static SignatureVerificationStatusFlags HashAlgorithmUnsupported;
    public static SignatureVerificationStatusFlags MessageImprintUnsupportedAlgorithm;
    public static SignatureVerificationStatusFlags IntegrityCheckFailed;
    public static SignatureVerificationStatusFlags ChainBuildingFailure;
    public static SignatureVerificationStatusFlags UnknownRevocation;
    public static SignatureVerificationStatusFlags CertificateRevoked;
    public static SignatureVerificationStatusFlags UntrustedRoot;
    public static SignatureVerificationStatusFlags GeneralizedTimeOutsideValidity;
    public static SignatureVerificationStatusFlags NoValidTimestamp;
    public static SignatureVerificationStatusFlags MultipleTimestamps;
    public static SignatureVerificationStatusFlags UnknownBuildStatus;
    public static SignatureVerificationStatusFlags Suspect;
    public static SignatureVerificationStatusFlags Illegal;
    public static SignatureVerificationStatusFlags Untrusted;
}
public class NuGet.Packaging.Signing.SignatureVerificationSummary : object {
    [CompilerGeneratedAttribute]
private SignatureType <SignatureType>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureVerificationStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureVerificationStatusFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private Timestamp <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <ExpirationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<SignatureLog> <Issues>k__BackingField;
    public SignatureType SignatureType { get; }
    public SignatureVerificationStatus Status { get; }
    public SignatureVerificationStatusFlags Flags { get; }
    public Timestamp Timestamp { get; }
    public Nullable`1<DateTimeOffset> ExpirationTime { get; }
    public IEnumerable`1<SignatureLog> Issues { get; public set; }
    public SignatureVerificationSummary(SignatureType signatureType, SignatureVerificationStatus status, SignatureVerificationStatusFlags flags, Timestamp timestamp, Nullable`1<DateTimeOffset> expirationTime, IEnumerable`1<SignatureLog> issues);
    public SignatureVerificationSummary(SignatureType signatureType, SignatureVerificationStatus status, SignatureVerificationStatusFlags flags, Timestamp timestamp, IEnumerable`1<SignatureLog> issues);
    public SignatureVerificationSummary(SignatureType signatureType, SignatureVerificationStatus status, SignatureVerificationStatusFlags flags, IEnumerable`1<SignatureLog> issues);
    [CompilerGeneratedAttribute]
public SignatureType get_SignatureType();
    [CompilerGeneratedAttribute]
public SignatureVerificationStatus get_Status();
    [CompilerGeneratedAttribute]
public SignatureVerificationStatusFlags get_Flags();
    [CompilerGeneratedAttribute]
public Timestamp get_Timestamp();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_ExpirationTime();
    [CompilerGeneratedAttribute]
public IEnumerable`1<SignatureLog> get_Issues();
    [CompilerGeneratedAttribute]
public void set_Issues(IEnumerable`1<SignatureLog> value);
}
public class NuGet.Packaging.Signing.SignatureVerifySettings : object {
    [CompilerGeneratedAttribute]
private bool <AllowIllegal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowUntrusted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowUnknownRevocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportUnknownRevocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportUntrustedRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private RevocationMode <RevocationMode>k__BackingField;
    [CompilerGeneratedAttribute]
private static SignatureVerifySettings <Default>k__BackingField;
    public bool AllowIllegal { get; }
    public bool AllowUntrusted { get; }
    public bool AllowUnknownRevocation { get; }
    public bool ReportUnknownRevocation { get; }
    public bool ReportUntrustedRoot { get; }
    public RevocationMode RevocationMode { get; }
    public static SignatureVerifySettings Default { get; }
    public SignatureVerifySettings(bool allowIllegal, bool allowUntrusted, bool allowUnknownRevocation, bool reportUnknownRevocation, bool reportUntrustedRoot, RevocationMode revocationMode);
    private static SignatureVerifySettings();
    [CompilerGeneratedAttribute]
public bool get_AllowIllegal();
    [CompilerGeneratedAttribute]
public bool get_AllowUntrusted();
    [CompilerGeneratedAttribute]
public bool get_AllowUnknownRevocation();
    [CompilerGeneratedAttribute]
public bool get_ReportUnknownRevocation();
    [CompilerGeneratedAttribute]
public bool get_ReportUntrustedRoot();
    [CompilerGeneratedAttribute]
public RevocationMode get_RevocationMode();
    [CompilerGeneratedAttribute]
public static SignatureVerifySettings get_Default();
}
public class NuGet.Packaging.Signing.SignedPackageArchive : PackageArchiveReader {
    private Stream _zipWriteStream;
    public SignedPackageArchive(Stream packageReadStream, Stream packageWriteStream);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.SignedPackageArchive/<AddSignatureAsync>d__2")]
public sealed virtual Task AddSignatureAsync(Stream signatureStream, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.SignedPackageArchive/<RemoveSignatureAsync>d__3")]
public sealed virtual Task RemoveSignatureAsync(CancellationToken token);
    public sealed virtual Task`1<bool> IsZip64Async(CancellationToken token);
    internal UInt32 GetPackageEntryCount();
    protected virtual void Dispose(bool disposing);
}
public static class NuGet.Packaging.Signing.SignedPackageArchiveIOUtility : object {
    private static int _bufferSize;
    private static SigningSpecifications _signingSpecification;
    private static int ValidZipDate_YearMin;
    private static int ValidZipDate_YearMax;
    private static SignedPackageArchiveIOUtility();
    public static void ReadAndWriteUntilPosition(BinaryReader reader, BinaryWriter writer, long position);
    public static void ReadAndHashUntilPosition(BinaryReader reader, HashAlgorithm hashAlgorithm, long position);
    public static void HashBytes(HashAlgorithm hashAlgorithm, Byte[] bytes);
    internal static void HashBytes(HashAlgorithm hashAlgorithm, Byte[] bytes, int count);
    internal static void ReadAndHashUntilPosition(BinaryReader reader, Sha512HashFunction hashFunc, long position);
    internal static void HashBytes(Sha512HashFunction hashFunc, Byte[] bytes);
    internal static void HashBytes(Sha512HashFunction hashFunc, Byte[] bytes, int count);
    public static SignedPackageArchiveMetadata ReadSignedArchiveMetadata(BinaryReader reader, bool validateSignatureEntry);
    internal static void RemoveSignature(BinaryReader reader, BinaryWriter writer);
    private static UnsignedPackageArchiveMetadata ReadUnsignedArchiveMetadata(BinaryReader reader);
    private static void UpdateLocalFileHeadersTotalSize(IReadOnlyList`1<CentralDirectoryHeaderMetadata> records, long startOfCentralDirectory);
    private static void AssertSignatureEntryMetadata(BinaryReader reader, SignedPackageArchiveMetadata metadata);
    private static void AssertSignatureEntryCommonHeaderFields(BinaryReader reader, string errorPrefix, string errorSuffix);
    private static void AssertValue(UInt32 expectedValue, UInt32 actualValue, NuGetLogCode errorCode, string errorMessagePrefix, string errorMessageSuffix, string fieldName);
    internal static void WriteSignatureIntoZip(MemoryStream signatureStream, BinaryReader reader, BinaryWriter writer);
    private static long WriteLocalFileHeaderIntoZip(BinaryWriter writer, Byte[] fileData, UInt32 crc32, UInt32 dosDateTime);
    private static long WriteFileIntoZip(BinaryWriter writer, Byte[] fileData);
    private static long WriteCentralDirectoryHeaderIntoZip(BinaryWriter writer, Byte[] fileData, UInt32 crc32, UInt32 dosDateTime, long fileOffset);
    private static void ReadAndWriteUpdatedEndOfCentralDirectoryRecordIntoZip(BinaryReader reader, BinaryWriter writer, sbyte entryCountChange, long sizeOfSignatureCentralDirectoryRecord, long sizeOfSignatureFileHeaderAndData);
    private static bool CurrentStreamPositionMatchesByteSignature(BinaryReader reader, Byte[] byteSignature);
    private static UInt32 DateTimeToDosTime(DateTime dateTime);
}
public class NuGet.Packaging.Signing.SignedPackageArchiveMetadata : object {
    [CompilerGeneratedAttribute]
private List`1<CentralDirectoryHeaderMetadata> <CentralDirectoryHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private long <StartOfLocalFileHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EndOfCentralDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SignatureCentralDirectoryHeaderIndex>k__BackingField;
    public List`1<CentralDirectoryHeaderMetadata> CentralDirectoryHeaders { get; public set; }
    public long StartOfLocalFileHeaders { get; public set; }
    public long EndOfCentralDirectory { get; public set; }
    public int SignatureCentralDirectoryHeaderIndex { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<CentralDirectoryHeaderMetadata> get_CentralDirectoryHeaders();
    [CompilerGeneratedAttribute]
public void set_CentralDirectoryHeaders(List`1<CentralDirectoryHeaderMetadata> value);
    [CompilerGeneratedAttribute]
public long get_StartOfLocalFileHeaders();
    [CompilerGeneratedAttribute]
public void set_StartOfLocalFileHeaders(long value);
    [CompilerGeneratedAttribute]
public long get_EndOfCentralDirectory();
    [CompilerGeneratedAttribute]
public void set_EndOfCentralDirectory(long value);
    [CompilerGeneratedAttribute]
public int get_SignatureCentralDirectoryHeaderIndex();
    [CompilerGeneratedAttribute]
public void set_SignatureCentralDirectoryHeaderIndex(int value);
    public CentralDirectoryHeaderMetadata GetPackageSignatureFileCentralDirectoryHeaderMetadata();
}
public static class NuGet.Packaging.Signing.SignedPackageArchiveUtility : object {
    private static SigningSpecifications _signingSpecification;
    private static SignedPackageArchiveUtility();
    public static bool IsSigned(BinaryReader reader);
    public static Stream OpenPackageSignatureFileStream(BinaryReader reader);
    private static Stream GetPackageSignatureFile(BinaryReader reader, CentralDirectoryHeaderMetadata signatureCentralDirectoryHeader);
    private static LocalFileHeader ReadPackageSignatureFileLocalFileHeader(BinaryReader reader, CentralDirectoryHeaderMetadata signatureCentralDirectoryHeader);
    internal static bool IsPackageSignatureFileEntry(Byte[] fileName, ushort generalPurposeBitFlag);
    public static bool IsZip64(BinaryReader reader);
    private static bool HasZip64ExtendedInformationExtraField(CentralDirectoryHeader header);
    private static bool HasZip64ExtendedInformationExtraField(LocalFileHeader header);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.SignedPackageArchiveUtility/<RemoveRepositorySignaturesAsync>d__9")]
public static Task`1<bool> RemoveRepositorySignaturesAsync(Stream input, Stream output, CancellationToken cancellationToken);
    private static Task RemoveRepositoryPrimarySignatureAsync(Stream input, Stream output, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.SignedPackageArchiveUtility/<RemoveRepositoryCountersignaturesAsync>d__11")]
private static Task`1<bool> RemoveRepositoryCountersignaturesAsync(Stream input, Stream output, SignedCms signedCms, CancellationToken cancellationToken);
    private static bool TryRemoveRepositoryCountersignatures(SignedCms signedCms, SignedCms& updatedSignedCms);
    private static SignedCms Reencode(SignedCms signedCms);
    internal static void SignZip(MemoryStream signatureStream, BinaryReader reader, BinaryWriter writer);
    internal static void UnsignZip(BinaryReader reader, BinaryWriter writer);
    internal static void HashUInt16(HashAlgorithm hashAlgorithm, ushort value);
    internal static void HashUInt32(HashAlgorithm hashAlgorithm, UInt32 value);
    internal static bool VerifySignedPackageIntegrity(BinaryReader reader, HashAlgorithm hashAlgorithm, Byte[] expectedHash);
    private static List`1<CentralDirectoryHeaderMetadata> RemoveSignatureAndOrderByOffset(SignedPackageArchiveMetadata metadata);
    internal static void HashUInt16(Sha512HashFunction hashFunc, ushort value);
    internal static void HashUInt32(Sha512HashFunction hashFunc, UInt32 value);
    internal static string GetPackageContentHash(BinaryReader reader);
    internal static bool IsUtf8(ushort generalPurposeBitFlags);
    private static bool CompareHash(Byte[] expectedHash, Byte[] actualHash);
}
public class NuGet.Packaging.Signing.SignedPackageVerificationResult : PackageVerificationResult {
    [CompilerGeneratedAttribute]
private PrimarySignature <Signature>k__BackingField;
    public PrimarySignature Signature { get; }
    public SignedPackageVerificationResult(SignatureVerificationStatus trust, PrimarySignature signature, IEnumerable`1<SignatureLog> issues);
    [CompilerGeneratedAttribute]
public PrimarySignature get_Signature();
}
public class NuGet.Packaging.Signing.SignedPackageVerifierSettings : object {
    [CompilerGeneratedAttribute]
private bool <AllowUnsigned>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowIllegal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowUntrusted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowIgnoreTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowMultipleTimestamps>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowNoTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowUnknownRevocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportUnknownRevocation>k__BackingField;
    [CompilerGeneratedAttribute]
private VerificationTarget <VerificationTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private SignaturePlacement <SignaturePlacement>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureVerificationBehavior <RepositoryCountersignatureVerificationBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private RevocationMode <RevocationMode>k__BackingField;
    public bool AllowUnsigned { get; }
    public bool AllowIllegal { get; }
    public bool AllowUntrusted { get; }
    public bool AllowIgnoreTimestamp { get; }
    public bool AllowMultipleTimestamps { get; }
    public bool AllowNoTimestamp { get; }
    public bool AllowUnknownRevocation { get; }
    public bool ReportUnknownRevocation { get; }
    public VerificationTarget VerificationTarget { get; }
    public SignaturePlacement SignaturePlacement { get; }
    public SignatureVerificationBehavior RepositoryCountersignatureVerificationBehavior { get; }
    public RevocationMode RevocationMode { get; }
    public SignedPackageVerifierSettings(bool allowUnsigned, bool allowIllegal, bool allowUntrusted, bool allowIgnoreTimestamp, bool allowMultipleTimestamps, bool allowNoTimestamp, bool allowUnknownRevocation, bool reportUnknownRevocation, VerificationTarget verificationTarget, SignaturePlacement signaturePlacement, SignatureVerificationBehavior repositoryCountersignatureVerificationBehavior, RevocationMode revocationMode);
    [CompilerGeneratedAttribute]
public bool get_AllowUnsigned();
    [CompilerGeneratedAttribute]
public bool get_AllowIllegal();
    [CompilerGeneratedAttribute]
public bool get_AllowUntrusted();
    [CompilerGeneratedAttribute]
public bool get_AllowIgnoreTimestamp();
    [CompilerGeneratedAttribute]
public bool get_AllowMultipleTimestamps();
    [CompilerGeneratedAttribute]
public bool get_AllowNoTimestamp();
    [CompilerGeneratedAttribute]
public bool get_AllowUnknownRevocation();
    [CompilerGeneratedAttribute]
public bool get_ReportUnknownRevocation();
    [CompilerGeneratedAttribute]
public VerificationTarget get_VerificationTarget();
    [CompilerGeneratedAttribute]
public SignaturePlacement get_SignaturePlacement();
    [CompilerGeneratedAttribute]
public SignatureVerificationBehavior get_RepositoryCountersignatureVerificationBehavior();
    [CompilerGeneratedAttribute]
public RevocationMode get_RevocationMode();
    public static SignedPackageVerifierSettings GetDefault(IEnvironmentVariableReader environmentVariableReader);
    public static SignedPackageVerifierSettings GetAcceptModeDefaultPolicy(IEnvironmentVariableReader environmentVariableReader);
    public static SignedPackageVerifierSettings GetRequireModeDefaultPolicy(IEnvironmentVariableReader environmentVariableReader);
    public static SignedPackageVerifierSettings GetVerifyCommandDefaultPolicy(IEnvironmentVariableReader environmentVariableReader);
}
public class NuGet.Packaging.Signing.SigningCertificate : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<EssCertId> <Certificates>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PolicyInformation> <Policies>k__BackingField;
    public IReadOnlyList`1<EssCertId> Certificates { get; }
    public IReadOnlyList`1<PolicyInformation> Policies { get; }
    private SigningCertificate(IReadOnlyList`1<EssCertId> certificates, IReadOnlyList`1<PolicyInformation> policies);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<EssCertId> get_Certificates();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PolicyInformation> get_Policies();
    public static SigningCertificate Read(Byte[] bytes);
    internal static SigningCertificate Read(DerSequenceReader reader);
    private static List`1<EssCertId> ReadCertificates(DerSequenceReader reader);
    private static IReadOnlyList`1<PolicyInformation> ReadPolicies(DerSequenceReader reader);
}
public class NuGet.Packaging.Signing.SigningCertificateV2 : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<EssCertIdV2> <Certificates>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PolicyInformation> <Policies>k__BackingField;
    public IReadOnlyList`1<EssCertIdV2> Certificates { get; }
    public IReadOnlyList`1<PolicyInformation> Policies { get; }
    private SigningCertificateV2(IReadOnlyList`1<EssCertIdV2> certificates, IReadOnlyList`1<PolicyInformation> policies);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<EssCertIdV2> get_Certificates();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PolicyInformation> get_Policies();
    public static SigningCertificateV2 Create(X509Certificate2 certificate, HashAlgorithmName hashAlgorithmName);
    public static SigningCertificateV2 Read(Byte[] bytes);
    internal static SigningCertificateV2 Read(DerSequenceReader reader);
    public Byte[] Encode();
    private static IReadOnlyList`1<EssCertIdV2> ReadCertificates(DerSequenceReader reader);
    private static IReadOnlyList`1<PolicyInformation> ReadPolicies(DerSequenceReader reader);
}
public class NuGet.Packaging.Signing.SigningOptions : object {
    private Lazy`1<Stream> _inputPackageStream;
    private Lazy`1<Stream> _outputPackageStream;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private bool <Overwrite>k__BackingField;
    [CompilerGeneratedAttribute]
private ISignatureProvider <SignatureProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    public Stream InputPackageStream { get; }
    public Stream OutputPackageStream { get; }
    public bool Overwrite { get; }
    public ISignatureProvider SignatureProvider { get; }
    public ILogger Logger { get; }
    public SigningOptions(Lazy`1<Stream> inputPackageStream, Lazy`1<Stream> outputPackageStream, bool overwrite, ISignatureProvider signatureProvider, ILogger logger);
    public Stream get_InputPackageStream();
    public Stream get_OutputPackageStream();
    [CompilerGeneratedAttribute]
public bool get_Overwrite();
    [CompilerGeneratedAttribute]
public ISignatureProvider get_SignatureProvider();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    public static SigningOptions CreateFromFilePaths(string inputPackageFilePath, string outputPackageFilePath, bool overwrite, ISignatureProvider signatureProvider, ILogger logger);
    public sealed virtual void Dispose();
    private static string NormalizeFilePath(string filePath);
}
public abstract class NuGet.Packaging.Signing.SigningSpecifications : object {
    public static SigningSpecificationsV1 V1;
    public string Version { get; }
    public string SignaturePath { get; }
    public HashAlgorithmName[] AllowedHashAlgorithms { get; }
    public String[] AllowedHashAlgorithmOids { get; }
    public SignatureAlgorithmName[] AllowedSignatureAlgorithms { get; }
    public String[] AllowedSignatureAlgorithmOids { get; }
    public int RSAPublicKeyMinLength { get; }
    public Encoding Encoding { get; }
    private static SigningSpecifications();
    public abstract virtual string get_Version();
    public abstract virtual string get_SignaturePath();
    public abstract virtual HashAlgorithmName[] get_AllowedHashAlgorithms();
    public abstract virtual String[] get_AllowedHashAlgorithmOids();
    public abstract virtual SignatureAlgorithmName[] get_AllowedSignatureAlgorithms();
    public abstract virtual String[] get_AllowedSignatureAlgorithmOids();
    public abstract virtual int get_RSAPublicKeyMinLength();
    public abstract virtual Encoding get_Encoding();
}
public class NuGet.Packaging.Signing.SigningSpecificationsV1 : SigningSpecifications {
    private static string _signaturePath;
    private static int _rsaPublicKeyMinLength;
    private static Encoding _encoding;
    private static HashAlgorithmName[] _allowedHashAlgorithms;
    private static String[] _allowedHashAlgorithmOids;
    private static SignatureAlgorithmName[] _allowedSignatureAlgorithms;
    private static String[] _allowedSignatureAlgorithmOids;
    public string Version { get; }
    public string SignaturePath { get; }
    public HashAlgorithmName[] AllowedHashAlgorithms { get; }
    public String[] AllowedHashAlgorithmOids { get; }
    public SignatureAlgorithmName[] AllowedSignatureAlgorithms { get; }
    public String[] AllowedSignatureAlgorithmOids { get; }
    public int RSAPublicKeyMinLength { get; }
    public Encoding Encoding { get; }
    private static SigningSpecificationsV1();
    public virtual string get_Version();
    public virtual string get_SignaturePath();
    public virtual HashAlgorithmName[] get_AllowedHashAlgorithms();
    public virtual String[] get_AllowedHashAlgorithmOids();
    public virtual SignatureAlgorithmName[] get_AllowedSignatureAlgorithms();
    public virtual String[] get_AllowedSignatureAlgorithmOids();
    public virtual int get_RSAPublicKeyMinLength();
    public virtual Encoding get_Encoding();
}
public static class NuGet.Packaging.Signing.SigningUtility : object {
    public static void Verify(SignPackageRequest request, ILogger logger);
    public static CryptographicAttributeObjectCollection CreateSignedAttributes(SignPackageRequest request, IReadOnlyList`1<X509Certificate2> chainList);
    public static CryptographicAttributeObjectCollection CreateSignedAttributes(RepositorySignPackageRequest request, IReadOnlyList`1<X509Certificate2> chainList);
    public static CmsSigner CreateCmsSigner(SignPackageRequest request, ILogger logger);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.SigningUtility/<SignAsync>d__4")]
public static Task SignAsync(SigningOptions options, SignPackageRequest signRequest, CancellationToken token);
    private static SignatureContent GenerateSignatureContent(HashAlgorithmName hashAlgorithmName, Byte[] zipArchiveHash);
}
public abstract class NuGet.Packaging.Signing.SignPackageRequest : object {
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <SignatureHashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <TimestampHashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2Collection <AdditionalCertificates>k__BackingField;
    [CompilerGeneratedAttribute]
private IX509CertificateChain <Chain>k__BackingField;
    [CompilerGeneratedAttribute]
private CngKey <PrivateKey>k__BackingField;
    public HashAlgorithmName SignatureHashAlgorithm { get; }
    public HashAlgorithmName TimestampHashAlgorithm { get; }
    public X509Certificate2 Certificate { get; }
    public X509Certificate2Collection AdditionalCertificates { get; }
    public SignatureType SignatureType { get; }
    internal IX509CertificateChain Chain { get; private set; }
    public CngKey PrivateKey { get; public set; }
    protected SignPackageRequest(X509Certificate2 certificate, HashAlgorithmName signatureHashAlgorithm, HashAlgorithmName timestampHashAlgorithm);
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_SignatureHashAlgorithm();
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_TimestampHashAlgorithm();
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    [CompilerGeneratedAttribute]
public X509Certificate2Collection get_AdditionalCertificates();
    public abstract virtual SignatureType get_SignatureType();
    [CompilerGeneratedAttribute]
internal IX509CertificateChain get_Chain();
    [CompilerGeneratedAttribute]
private void set_Chain(IX509CertificateChain value);
    [CompilerGeneratedAttribute]
public CngKey get_PrivateKey();
    [CompilerGeneratedAttribute]
public void set_PrivateKey(CngKey value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal void BuildSigningCertificateChainOnce(ILogger logger);
}
public class NuGet.Packaging.Signing.Timestamp : object {
    [CompilerGeneratedAttribute]
private DateTimeOffset <UpperLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LowerLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <GeneralizedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private SignedCms <SignedCms>k__BackingField;
    [CompilerGeneratedAttribute]
private IRfc3161TimestampTokenInfo <TstInfo>k__BackingField;
    public DateTimeOffset UpperLimit { get; }
    public DateTimeOffset LowerLimit { get; }
    public DateTimeOffset GeneralizedTime { get; }
    public SignedCms SignedCms { get; }
    public SignerInfo SignerInfo { get; }
    internal IRfc3161TimestampTokenInfo TstInfo { get; }
    public Timestamp(SignedCms timestampCms);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_UpperLimit();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LowerLimit();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_GeneralizedTime();
    [CompilerGeneratedAttribute]
public SignedCms get_SignedCms();
    public SignerInfo get_SignerInfo();
    [CompilerGeneratedAttribute]
internal IRfc3161TimestampTokenInfo get_TstInfo();
    internal SignatureVerificationStatusFlags Verify(Signature signature, SignedPackageVerifierSettings settings, HashAlgorithmName fingerprintAlgorithm, List`1<SignatureLog> issues);
}
public class NuGet.Packaging.Signing.TimestampException : SignatureException {
    public TimestampException(NuGetLogCode code, string message);
    public TimestampException(NuGetLogCode code, string message, Exception innerException);
    public TimestampException(string message);
}
public class NuGet.Packaging.Signing.TimestampRequest : object {
    [CompilerGeneratedAttribute]
private SigningSpecifications <SigningSpecifications>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <HashedMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private SignaturePlacement <Target>k__BackingField;
    public SigningSpecifications SigningSpecifications { get; }
    public Byte[] HashedMessage { get; }
    public HashAlgorithmName HashAlgorithm { get; }
    public SignaturePlacement Target { get; }
    public TimestampRequest(SigningSpecifications signingSpecifications, Byte[] hashedMessage, HashAlgorithmName hashAlgorithm, SignaturePlacement target);
    [CompilerGeneratedAttribute]
public SigningSpecifications get_SigningSpecifications();
    [CompilerGeneratedAttribute]
public Byte[] get_HashedMessage();
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public SignaturePlacement get_Target();
}
public class NuGet.Packaging.Signing.TrustedSignerAllowListEntry : CertificateHashAllowListEntry {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowUntrustedRoot>k__BackingField;
    public IReadOnlyList`1<string> Owners { get; }
    public bool AllowUntrustedRoot { get; }
    public TrustedSignerAllowListEntry(VerificationTarget target, SignaturePlacement placement, string fingerprint, HashAlgorithmName algorithm, bool allowUntrustedRoot, IReadOnlyList`1<string> owners);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Owners();
    [CompilerGeneratedAttribute]
public bool get_AllowUntrustedRoot();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NuGet.Packaging.Signing.TrustedSignersProvider : object {
    private ISettings _settings;
    public TrustedSignersProvider(ISettings settings);
    public sealed virtual IReadOnlyList`1<TrustedSignerItem> GetTrustedSigners();
    public sealed virtual void Remove(IReadOnlyList`1<TrustedSignerItem> trustedSigners);
    public sealed virtual void AddOrUpdateTrustedSigner(TrustedSignerItem trustedSigner);
    public static IReadOnlyList`1<TrustedSignerAllowListEntry> GetAllowListEntries(ISettings settings, ILogger logger);
    private static string GetCertLookupKey(CertificateItem certificate);
    private static VerificationTarget GetItemTarget(TrustedSignerItem item, SignaturePlacement& placement);
}
public class NuGet.Packaging.Signing.TstInfo : object {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Oid <Policy>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageImprint <MessageImprint>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <SerialNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <GenTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Accuracy <Accuracy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ordering>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Nonce>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Tsa>k__BackingField;
    [CompilerGeneratedAttribute]
private X509ExtensionCollection <Extensions>k__BackingField;
    public int Version { get; }
    public Oid Policy { get; }
    public MessageImprint MessageImprint { get; }
    public Byte[] SerialNumber { get; }
    public DateTimeOffset GenTime { get; }
    public Accuracy Accuracy { get; }
    public bool Ordering { get; }
    public Byte[] Nonce { get; }
    public Byte[] Tsa { get; }
    public X509ExtensionCollection Extensions { get; }
    private TstInfo(int version, Oid policy, MessageImprint messageImprint, Byte[] serialNumber, DateTimeOffset genTime, Accuracy accuracy, bool ordering, Byte[] nonce, Byte[] tsa, X509ExtensionCollection extensions);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public Oid get_Policy();
    [CompilerGeneratedAttribute]
public MessageImprint get_MessageImprint();
    [CompilerGeneratedAttribute]
public Byte[] get_SerialNumber();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_GenTime();
    [CompilerGeneratedAttribute]
public Accuracy get_Accuracy();
    [CompilerGeneratedAttribute]
public bool get_Ordering();
    [CompilerGeneratedAttribute]
public Byte[] get_Nonce();
    [CompilerGeneratedAttribute]
public Byte[] get_Tsa();
    [CompilerGeneratedAttribute]
public X509ExtensionCollection get_Extensions();
    public static TstInfo Read(Byte[] bytes);
    internal static TstInfo Read(DerSequenceReader reader);
}
public class NuGet.Packaging.Signing.UnknownPrimarySignature : PrimarySignature {
    public UnknownPrimarySignature(SignedCms signedCms);
}
internal class NuGet.Packaging.Signing.UnsignedPackageArchiveMetadata : object {
    [CompilerGeneratedAttribute]
private long <EndOfLocalFileHeadersPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EndOfCentralDirectoryHeadersPosition>k__BackingField;
    internal long EndOfLocalFileHeadersPosition { get; }
    internal long EndOfCentralDirectoryHeadersPosition { get; }
    internal UnsignedPackageArchiveMetadata(long endOfLocalFileHeadersPosition, long endOfCentralDirectoryHeadersPosition);
    [CompilerGeneratedAttribute]
internal long get_EndOfLocalFileHeadersPosition();
    [CompilerGeneratedAttribute]
internal long get_EndOfCentralDirectoryHeadersPosition();
}
public class NuGet.Packaging.Signing.UnsignedPackageVerificationResult : PackageVerificationResult {
    public UnsignedPackageVerificationResult(SignatureVerificationStatus trust, IEnumerable`1<SignatureLog> issues);
}
internal static class NuGet.Packaging.Signing.Utility.MarshalUtility : object {
    internal static T PtrToStructure(IntPtr pointer);
    internal static int SizeOf();
}
public abstract class NuGet.Packaging.Signing.VerificationAllowListEntry : object {
    [CompilerGeneratedAttribute]
private VerificationTarget <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private SignaturePlacement <Placement>k__BackingField;
    public VerificationTarget Target { get; }
    public SignaturePlacement Placement { get; }
    public VerificationAllowListEntry(VerificationTarget target, SignaturePlacement placement);
    [CompilerGeneratedAttribute]
public VerificationTarget get_Target();
    [CompilerGeneratedAttribute]
public SignaturePlacement get_Placement();
}
[FlagsAttribute]
public enum NuGet.Packaging.Signing.VerificationTarget : Enum {
    public int value__;
    public static VerificationTarget None;
    public static VerificationTarget Unknown;
    public static VerificationTarget Author;
    public static VerificationTarget Repository;
    public static VerificationTarget All;
}
public static class NuGet.Packaging.Signing.VerificationUtility : object {
    public static SignatureVerificationStatus GetSignatureVerificationStatus(SignatureVerificationStatusFlags flags);
    public static bool IsVerificationTarget(SignatureType signatureType, VerificationTarget target);
    internal static SignatureVerificationStatusFlags ValidateSigningCertificate(X509Certificate2 certificate, bool treatIssuesAsErrors, string signatureFriendlyName, List`1<SignatureLog> issues);
    internal static SignatureVerificationStatusFlags ValidateTimestamp(Timestamp timestamp, Signature signature, bool treatIssuesAsErrors, List`1<SignatureLog> issues, SigningSpecifications spec);
}
public class NuGet.Packaging.Signing.VerifySignaturesResult : object {
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSigned>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PackageVerificationResult> <Results>k__BackingField;
    public bool IsValid { get; }
    public bool IsSigned { get; }
    public IReadOnlyList`1<PackageVerificationResult> Results { get; }
    public VerifySignaturesResult(bool isValid, bool isSigned);
    public VerifySignaturesResult(bool isValid, bool isSigned, IEnumerable`1<PackageVerificationResult> results);
    [CompilerGeneratedAttribute]
public bool get_IsValid();
    [CompilerGeneratedAttribute]
public bool get_IsSigned();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PackageVerificationResult> get_Results();
}
public class NuGet.Packaging.Signing.X509CertificateChain : List`1<X509Certificate2> {
    private bool _isDisposed;
    public sealed virtual void Dispose();
}
internal static class NuGet.Packaging.Signing.X509ChainBuildPolicyFactory : object {
    private static string DefaultValue;
    internal static string DisabledValue;
    internal static string EnvironmentVariableName;
    internal static char ValueDelimiter;
    private static object LockObject;
    private static IX509ChainBuildPolicy Policy;
    private static X509ChainBuildPolicyFactory();
    internal static IX509ChainBuildPolicy Create(IEnvironmentVariableReader reader);
    internal static IX509ChainBuildPolicy CreateWithoutCaching(IEnvironmentVariableReader reader);
}
public class NuGet.Packaging.Signing.X509ChainHolder : object {
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private X509Chain <Chain>k__BackingField;
    [CompilerGeneratedAttribute]
private IX509Chain <Chain2>k__BackingField;
    public X509Chain Chain { get; }
    internal IX509Chain Chain2 { get; }
    private X509ChainHolder(X509StorePurpose storePurpose);
    [CompilerGeneratedAttribute]
public X509Chain get_Chain();
    [CompilerGeneratedAttribute]
internal IX509Chain get_Chain2();
    internal static X509ChainHolder CreateForCodeSigning();
    internal static X509ChainHolder CreateForTimestamping();
    public sealed virtual void Dispose();
}
internal class NuGet.Packaging.Signing.X509ChainWrapper : object {
    private X509Chain _chain;
    private Func`2<X509Chain, ILogMessage> _getAdditionalContext;
    [CompilerGeneratedAttribute]
private ILogMessage <AdditionalContext>k__BackingField;
    public ILogMessage AdditionalContext { get; private set; }
    public X509ChainElementCollection ChainElements { get; }
    public X509ChainPolicy ChainPolicy { get; }
    public X509ChainStatus[] ChainStatus { get; }
    public X509Chain PrivateReference { get; }
    internal X509ChainWrapper(X509Chain chain);
    internal X509ChainWrapper(X509Chain chain, Func`2<X509Chain, ILogMessage> getAdditionalContext);
    [CompilerGeneratedAttribute]
public sealed virtual ILogMessage get_AdditionalContext();
    [CompilerGeneratedAttribute]
private void set_AdditionalContext(ILogMessage value);
    public sealed virtual X509ChainElementCollection get_ChainElements();
    public sealed virtual X509ChainPolicy get_ChainPolicy();
    public sealed virtual X509ChainStatus[] get_ChainStatus();
    public sealed virtual X509Chain get_PrivateReference();
    public sealed virtual bool Build(X509Certificate2 certificate);
    public sealed virtual void Dispose();
}
public class NuGet.Packaging.Signing.X509SignatureProvider : object {
    private static int INVALID_PROVIDER_TYPE_HRESULT;
    private ITimestampProvider _timestampProvider;
    public X509SignatureProvider(ITimestampProvider timestampProvider);
    public sealed virtual Task`1<PrimarySignature> CreatePrimarySignatureAsync(SignPackageRequest request, SignatureContent signatureContent, ILogger logger, CancellationToken token);
    public sealed virtual Task`1<PrimarySignature> CreateRepositoryCountersignatureAsync(RepositorySignPackageRequest request, PrimarySignature primarySignature, ILogger logger, CancellationToken token);
    private static PrimarySignature CreatePrimarySignature(SignPackageRequest request, SignatureContent signatureContent, ILogger logger);
    private static PrimarySignature CreateRepositoryCountersignature(SignPackageRequest request, PrimarySignature primarySignature, ILogger logger);
    private static PrimarySignature CreatePrimarySignature(CmsSigner cmsSigner, Byte[] signingData, CngKey privateKey);
    private static PrimarySignature CreatePrimarySignature(CmsSigner cmsSigner, SignPackageRequest request, Byte[] signingData);
    private static PrimarySignature CreateRepositoryCountersignature(CmsSigner cmsSigner, PrimarySignature primarySignature, CngKey privateKey);
    private static PrimarySignature CreateRepositoryCountersignature(CmsSigner cmsSigner, SignPackageRequest request, PrimarySignature primarySignature);
    private Task`1<PrimarySignature> TimestampPrimarySignatureAsync(SignPackageRequest request, ILogger logger, PrimarySignature signature, CancellationToken token);
    private Task`1<PrimarySignature> TimestampRepositoryCountersignatureAsync(SignPackageRequest request, ILogger logger, PrimarySignature primarySignature, CancellationToken token);
}
internal enum NuGet.Packaging.Signing.X509StorePurpose : Enum {
    public int value__;
    public static X509StorePurpose CodeSigning;
    public static X509StorePurpose Timestamping;
}
public static class NuGet.Packaging.Signing.X509TrustStore : object {
    private static IX509ChainFactory CodeSigningX509ChainFactory;
    private static IX509ChainFactory TimestampingX509ChainFactory;
    private static object LockObject;
    private static X509TrustStore();
    public static void InitializeForDotNetSdk(ILogger logger);
    internal static IX509ChainFactory GetX509ChainFactory(X509StorePurpose storePurpose, ILogger logger);
    private static IX509ChainFactory GetX509ChainFactory(X509StorePurpose storePurpose, ILogger logger, Func`3<X509StorePurpose, ILogger, IX509ChainFactory> creator);
    private static IX509ChainFactory CreateX509ChainFactoryForDotNetSdk(X509StorePurpose storePurpose, ILogger logger);
    internal static IX509ChainFactory CreateX509ChainFactoryForDotNetSdk(X509StorePurpose storePurpose, ILogger logger, FileInfo fallbackCertificateBundleFile);
    internal static IX509ChainFactory CreateX509ChainFactory(X509StorePurpose storePurpose, ILogger logger);
    internal static void SetCodeSigningX509ChainFactory(IX509ChainFactory chainFactory);
    internal static void SetTimestampingX509ChainFactory(IX509ChainFactory chainFactory);
}
internal class NuGet.Packaging.Signing.Zip64EndOfCentralDirectoryLocator : object {
    internal static UInt32 Signature;
    internal static UInt32 SizeInBytes;
    internal static bool Exists(BinaryReader reader);
}
internal class NuGet.Packaging.Signing.Zip64ExtendedInformationExtraField : ExtraField {
    [CompilerGeneratedAttribute]
private Nullable`1<ulong> <OriginalUncompressedFileSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ulong> <SizeOfCompressedData>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ulong> <OffsetOfLocalHeaderRecord>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <NumberOfDiskOnWhichThisFileStarts>k__BackingField;
    internal Nullable`1<ulong> OriginalUncompressedFileSize { get; private set; }
    internal Nullable`1<ulong> SizeOfCompressedData { get; private set; }
    internal Nullable`1<ulong> OffsetOfLocalHeaderRecord { get; private set; }
    internal Nullable`1<UInt32> NumberOfDiskOnWhichThisFileStarts { get; private set; }
    private Zip64ExtendedInformationExtraField(ushort headerId, ushort dataSize, Byte[] data, Nullable`1<ulong> originalUncompressedFileSize, Nullable`1<ulong> sizeOfCompressedData, Nullable`1<ulong> offsetOfLocalHeaderRecord, Nullable`1<UInt32> numberOfDiskOnWhichThisFileStarts);
    [CompilerGeneratedAttribute]
internal Nullable`1<ulong> get_OriginalUncompressedFileSize();
    [CompilerGeneratedAttribute]
private void set_OriginalUncompressedFileSize(Nullable`1<ulong> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<ulong> get_SizeOfCompressedData();
    [CompilerGeneratedAttribute]
private void set_SizeOfCompressedData(Nullable`1<ulong> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<ulong> get_OffsetOfLocalHeaderRecord();
    [CompilerGeneratedAttribute]
private void set_OffsetOfLocalHeaderRecord(Nullable`1<ulong> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<UInt32> get_NumberOfDiskOnWhichThisFileStarts();
    [CompilerGeneratedAttribute]
private void set_NumberOfDiskOnWhichThisFileStarts(Nullable`1<UInt32> value);
    internal static Zip64ExtendedInformationExtraField Read(ushort headerId, ushort dataSize, Byte[] data, bool readUncompressedFileSize, bool readCompressedFileSize, bool readRelativeOffsetOfLocalHeader, bool readDiskNumberStart);
}
internal static class NuGet.Packaging.Signing.ZipConstants : object {
    internal static ushort Mask16Bit;
    internal static UInt32 Mask32Bit;
    private static ZipConstants();
}
[ExtensionAttribute]
public static class NuGet.Packaging.StreamExtensions : object {
    [ExtensionAttribute]
public static string CopyToFile(Stream inputStream, string fileFullPath);
    private static void CopyTo(Stream inputStream, Stream outputStream);
}
[ExtensionAttribute]
internal static class NuGet.Packaging.StringExtensions : object {
    [ExtensionAttribute]
public static string SafeTrim(string value);
}
internal static class NuGet.Packaging.StringFormatter : object {
    internal static string Log_InstalledPackage(string packageId, string packageVersion, string source, string contentHash, string filePath);
    internal static string ZipFileTimeStampModifiedMessage(string filePath, string originalLastWriteTimeStamp, string updatedLastWriteTimeStamp);
    internal static string ZipFileTimeStampModifiedWarning(string listOfFileTimeStampModifiedMessages);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Packaging.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AnAbsoluteUriIsRequired { get; }
    internal static string ArgumentCannotBeNullOrEmpty { get; }
    internal static string AuthorPrimarySignatureFriendlyName { get; }
    internal static string CertificateChainBuildFailed { get; }
    internal static string CertificateChainValidationFailed { get; }
    internal static string CertUtilityCertificateHash { get; }
    internal static string CertUtilityCertificateHashSha1 { get; }
    internal static string CertUtilityCertificateIssuer { get; }
    internal static string CertUtilityCertificateSubjectName { get; }
    internal static string CertUtilityCertificateValidity { get; }
    internal static string CertUtilityMultipleCertificatesFooter { get; }
    internal static string CertUtilityMultipleCertificatesHeader { get; }
    internal static string ChainBuilding_UsingDefaultTrustStoreForCodeSigning { get; }
    internal static string ChainBuilding_UsingDefaultTrustStoreForTimestamping { get; }
    internal static string ChainBuilding_UsingFallbackCertificateBundle { get; }
    internal static string ChainBuilding_UsingNoCertificateBundle { get; }
    internal static string ChainBuilding_UsingSystemCertificateBundle { get; }
    internal static string CommitmentTypeIndicationAttributeInvalid { get; }
    internal static string CommitmentTypeIndicationAttributeInvalidCombination { get; }
    internal static string ConflictingAllowUntrustedRoot { get; }
    internal static string DefaultError_EmptyAllowList { get; }
    internal static string DefaultError_NoMatchInAllowList { get; }
    internal static string Error_InvalidTargetFramework { get; }
    internal static string Error_LoadingHashFile { get; }
    internal static string Error_MissingNuspecFile { get; }
    internal static string Error_NoClientAllowList { get; }
    internal static string Error_NoMatchingClientCertificate { get; }
    internal static string Error_NoMatchingRepositoryCertificate { get; }
    internal static string Error_NoRepoAllowList { get; }
    internal static string Error_NotOnePrimarySignature { get; }
    internal static string Error_NotOneRepositoryCounterSignature { get; }
    internal static string Error_RepositorySettings_UnsignedPackage { get; }
    internal static string Error_RepositorySignatureMustNotHaveARepositoryCountersignature { get; }
    internal static string Error_RequireMode_UnsignedPackage { get; }
    internal static string ErrorAuthorTargetCannotBeACountersignature { get; }
    internal static string ErrorByteSignatureNotFound { get; }
    internal static string ErrorDuplicatePackages { get; }
    internal static string ErrorInvalidAllowedVersions { get; }
    internal static string ErrorInvalidCertificateChainUnspecifiedReason { get; }
    internal static string ErrorInvalidMinClientVersion { get; }
    internal static string ErrorInvalidPackageArchive { get; }
    internal static string ErrorInvalidPackageVersion { get; }
    internal static string ErrorInvalidPackageVersionForDependency { get; }
    internal static string ErrorManifestFileNotFound { get; }
    internal static string ErrorMultipleTimestamps { get; }
    internal static string ErrorNoTimestamp { get; }
    internal static string ErrorNullOrEmptyPackageId { get; }
    internal static string ErrorPackageNotSigned { get; }
    internal static string ErrorPackageSignatureInvalid { get; }
    internal static string ErrorUnableCheckPackageEntries { get; }
    internal static string ErrorUnableToDeleteFile { get; }
    internal static string ErrorUnsafePackageEntry { get; }
    internal static string ErrorZip64NotSupported { get; }
    internal static string ExactlyOneAttributeRequired { get; }
    internal static string ExactlyOneAttributeValueRequired { get; }
    internal static string ExtractionLog_InformationPrefix { get; }
    internal static string FailedFileTime { get; }
    internal static string FailToLoadPackagesConfig { get; }
    internal static string FailToWritePackagesConfig { get; }
    internal static string FallbackFolderNotFound { get; }
    internal static string HttpOrHttpsIsRequired { get; }
    internal static string InvalidArgument { get; }
    internal static string InvalidArgumentCombination { get; }
    internal static string InvalidAsn1 { get; }
    internal static string InvalidLicenseExppressionVersion_VersionTooHigh { get; }
    internal static string InvalidNuspecElement { get; }
    internal static string InvalidNuspecEntry { get; }
    internal static string InvalidPackageFrameworkFolderName { get; }
    internal static string InvalidPackageNupkg { get; }
    internal static string InvalidPackageSignatureFile { get; }
    internal static string InvalidPackageSignatureFileEntry { get; }
    internal static string InvalidPackageSignatureFileEntryCentralDirectoryHeader { get; }
    internal static string InvalidPackageSignatureFileEntryLocalFileHeader { get; }
    internal static string InvalidPackageTypeVersion { get; }
    internal static string InvalidPrimarySignature { get; }
    internal static string InvalidRepositoryCountersignature { get; }
    internal static string InvalidSignatureContent { get; }
    internal static string InvalidTimestampSignature { get; }
    internal static string InvalidUrl { get; }
    internal static string InvalidX509StorePurpose { get; }
    internal static string Log_InstalledPackage { get; }
    internal static string Message_Path { get; }
    internal static string MinClientVersionAlreadyExist { get; }
    internal static string MissingMetadataNode { get; }
    internal static string MissingPackageTypeName { get; }
    internal static string MissingTargetPlatformVersionsFromDependencyGroups { get; }
    internal static string MissingTargetPlatformVersionsFromFrameworkAssemblyGroups { get; }
    internal static string MissingTargetPlatformVersionsFromFrameworkAssemblyReferences { get; }
    internal static string MissingTargetPlatformVersionsFromIncludedFiles { get; }
    internal static string MissingTargetPlatformVersionsFromReferenceGroups { get; }
    internal static string MultipleAttributesDisallowed { get; }
    internal static string MultipleNuspecFiles { get; }
    internal static string MultiplePackageSignatureFiles { get; }
    internal static string MustContainAbsolutePath { get; }
    internal static string NoPackageSignatureFile { get; }
    internal static string NoRepositoryCountersignature { get; }
    internal static string NuGetLicense_InvalidLicenseExpressionVersion { get; }
    internal static string NuGetLicense_InvalidLicenseType { get; }
    internal static string NuGetLicense_LicenseElementMissingValue { get; }
    internal static string NuGetLicense_LicenseExpressionVersionTooHigh { get; }
    internal static string NuGetLicense_MissingRequiredValue { get; }
    internal static string NuGetLicenseExpression_DeprecatedIdentifier { get; }
    internal static string NuGetLicenseExpression_ExceptionIdentifierIsLicense { get; }
    internal static string NuGetLicenseExpression_IllegalUnlicensedOperator { get; }
    internal static string NuGetLicenseExpression_InvalidCharacters { get; }
    internal static string NuGetLicenseExpression_InvalidExceptionIdentifier { get; }
    internal static string NuGetLicenseExpression_InvalidExpression { get; }
    internal static string NuGetLicenseExpression_InvalidToken { get; }
    internal static string NuGetLicenseExpression_LicenseIdentifierIsException { get; }
    internal static string NuGetLicenseExpression_LicenseInvalidCharacters { get; }
    internal static string NuGetLicenseExpression_MismatchedParentheses { get; }
    internal static string NuGetLicenseExpression_NonStandardIdentifier { get; }
    internal static string NuGetLicenseExpression_UnexpectedIdentifier { get; }
    internal static string NuGetLicenseExpression_UnlicensedPackageWarning { get; }
    internal static string NuGetPackageOwners { get; }
    internal static string NuGetPackageOwnersInvalid { get; }
    internal static string NuGetPackageOwnersInvalidValue { get; }
    internal static string NuGetV3ServiceIndexUrl { get; }
    internal static string NuGetV3ServiceIndexUrlInvalid { get; }
    internal static string NuGetV3ServiceIndexUrlInvalidValue { get; }
    internal static string PackageEntryAlreadyExist { get; }
    internal static string PackageEntryNotExist { get; }
    internal static string PackageMinVersionNotSatisfied { get; }
    internal static string PackageSignatureVerificationLog { get; }
    internal static string PackagesNodeNotExist { get; }
    internal static string PackageStreamShouldBeSeekable { get; }
    internal static string PrimarySignatureFriendlyName { get; }
    internal static string PrimarySignatureHasNoTimestamp { get; }
    internal static string PropertyCannotBeNull { get; }
    internal static string RangeOutOfBoundsForArray { get; }
    internal static string RepositoryCountersignatureFriendlyName { get; }
    internal static string RepositoryCountersignatureHasNoCertificate { get; }
    internal static string RepositoryCountersignatureHasNoTimestamp { get; }
    internal static string RepositoryPrimarySignatureFriendlyName { get; }
    internal static string SignatureContainsInvalidAttribute { get; }
    internal static string SignatureDebug_HashOidFound { get; }
    internal static string SignatureFailureInvalidHashAlgorithmOid { get; }
    internal static string SignatureFriendlyName { get; }
    internal static string SignatureHashAlgorithm { get; }
    internal static string SignaturePackageIntegrityFailure { get; }
    internal static string SignatureType { get; }
    internal static string SignedPackageAlreadySigned { get; }
    internal static string SignedPackageArchiveIOExtraRead { get; }
    internal static string SignedPackageArchiveIOInvalidRead { get; }
    internal static string SignedPackageNotSignedOnRemove { get; }
    internal static string SignedPackageNotSignedOnVerify { get; }
    internal static string SignedPackagePackageAlreadyCountersigned { get; }
    internal static string SignedPackageUnableToAccessSignature { get; }
    internal static string SignError_TimestampCertificateFailsPublicKeyLengthRequirement { get; }
    internal static string SignError_TimestampGeneralizedTimeInvalid { get; }
    internal static string SignError_TimestampIntegrityCheckFailed { get; }
    internal static string SignError_TimestampNoCertificate { get; }
    internal static string SignError_TimestampNotYetValid { get; }
    internal static string SignError_TimestampSignatureValidationFailed { get; }
    internal static string SignFailureCertificateInvalidProviderType { get; }
    internal static string SigningCannotBeDoneInPlace { get; }
    internal static string SigningCertificateAttributeMustNotBePresent { get; }
    internal static string SigningCertificateCertificateNotFound { get; }
    internal static string SigningCertificateInvalid { get; }
    internal static string SigningCertificateV1OrV2AttributeMustBePresent { get; }
    internal static string SigningCertificateV2CertificateNotFound { get; }
    internal static string SigningCertificateV2Invalid { get; }
    internal static string SigningCertificateV2UnsupportedHashAlgorithm { get; }
    internal static string SigningError_CertificateFailsPublicKeyLengthRequirement { get; }
    internal static string SigningError_CertificateHasLifetimeSigningEKU { get; }
    internal static string SigningError_CertificateHasUnsupportedSignatureAlgorithm { get; }
    internal static string SigningError_NotYetValid { get; }
    internal static string SigningWouldRequireZip64 { get; }
    internal static string StreamMustBeReadable { get; }
    internal static string StreamMustBeSeekable { get; }
    internal static string StringCannotBeNullOrEmpty { get; }
    internal static string TimestampCertificateUnsupportedSignatureAlgorithm { get; }
    internal static string TimestampFailureInvalidHttpScheme { get; }
    internal static string TimestampFailureNonceMismatch { get; }
    internal static string TimestampServiceRespondedError { get; }
    internal static string TimestampSignatureUnsupportedDigestAlgorithm { get; }
    internal static string TimestampValue { get; }
    internal static string UnableToAddEntry { get; }
    internal static string UnableToParseClientVersion { get; }
    internal static string UnableToReadPackageHashInformation { get; }
    internal static string UnexpectedPackageSignatureVerificationError { get; }
    internal static string UnrecognizedEnumValue { get; }
    internal static string UnrelatedSignatures { get; }
    internal static string UnsupportedAsn1 { get; }
    internal static string UnsupportedSignatureFormatVersion { get; }
    internal static string UntrustedRoot_WithCertificateBundle { get; }
    internal static string UntrustedRoot_WithoutCertificateBundle { get; }
    internal static string VerificationCertDisplay { get; }
    internal static string VerificationTimestamperCertDisplay { get; }
    internal static string Verify_ErrorNoCertificate { get; }
    internal static string VerifyCertTrustOfflineWhileRevocationModeOffline { get; }
    internal static string VerifyCertTrustOfflineWhileRevocationModeOnline { get; }
    internal static string VerifyChainBuildingIssue { get; }
    internal static string VerifyChainBuildingIssue_UntrustedRoot { get; }
    internal static string VerifyError_CertificateFailsPublicKeyLengthRequirement { get; }
    internal static string VerifyError_CertificateHasLifetimeSigningEKU { get; }
    internal static string VerifyError_CertificateHasUnsupportedSignatureAlgorithm { get; }
    internal static string VerifyError_CertificateNotYetValid { get; }
    internal static string VerifyError_InvalidCertificateChain { get; }
    internal static string VerifyError_SignatureNotTimeValid { get; }
    internal static string VerifyError_SignatureVerificationFailed { get; }
    internal static string VerifyError_TimestampCertificateFailsPublicKeyLengthRequirement { get; }
    internal static string VerifyError_TimestampGeneralizedTimeInvalid { get; }
    internal static string VerifyError_TimestampIntegrityCheckFailed { get; }
    internal static string VerifyError_TimestampInvalid { get; }
    internal static string VerifyError_TimestampMessageImprintUnsupportedHashAlgorithm { get; }
    internal static string VerifyError_TimestampNoCertificate { get; }
    internal static string VerifyError_TimestampNotYetValid { get; }
    internal static string VerifyError_TimestampSignatureUnsupportedDigestAlgorithm { get; }
    internal static string VerifyError_TimestampSignatureValidationFailed { get; }
    internal static string VerifyError_TimestampUnsupportedSignatureAlgorithm { get; }
    internal static string VerifyError_TimestampVerifyChainBuildingIssue { get; }
    internal static string VerifyTimestampChainBuildingIssue_UntrustedRoot { get; }
    internal static string ZipFileLastWriteTimeStampModifiedMessage { get; }
    internal static string ZipFileTimeStampModifiedWarning { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AnAbsoluteUriIsRequired();
    internal static string get_ArgumentCannotBeNullOrEmpty();
    internal static string get_AuthorPrimarySignatureFriendlyName();
    internal static string get_CertificateChainBuildFailed();
    internal static string get_CertificateChainValidationFailed();
    internal static string get_CertUtilityCertificateHash();
    internal static string get_CertUtilityCertificateHashSha1();
    internal static string get_CertUtilityCertificateIssuer();
    internal static string get_CertUtilityCertificateSubjectName();
    internal static string get_CertUtilityCertificateValidity();
    internal static string get_CertUtilityMultipleCertificatesFooter();
    internal static string get_CertUtilityMultipleCertificatesHeader();
    internal static string get_ChainBuilding_UsingDefaultTrustStoreForCodeSigning();
    internal static string get_ChainBuilding_UsingDefaultTrustStoreForTimestamping();
    internal static string get_ChainBuilding_UsingFallbackCertificateBundle();
    internal static string get_ChainBuilding_UsingNoCertificateBundle();
    internal static string get_ChainBuilding_UsingSystemCertificateBundle();
    internal static string get_CommitmentTypeIndicationAttributeInvalid();
    internal static string get_CommitmentTypeIndicationAttributeInvalidCombination();
    internal static string get_ConflictingAllowUntrustedRoot();
    internal static string get_DefaultError_EmptyAllowList();
    internal static string get_DefaultError_NoMatchInAllowList();
    internal static string get_Error_InvalidTargetFramework();
    internal static string get_Error_LoadingHashFile();
    internal static string get_Error_MissingNuspecFile();
    internal static string get_Error_NoClientAllowList();
    internal static string get_Error_NoMatchingClientCertificate();
    internal static string get_Error_NoMatchingRepositoryCertificate();
    internal static string get_Error_NoRepoAllowList();
    internal static string get_Error_NotOnePrimarySignature();
    internal static string get_Error_NotOneRepositoryCounterSignature();
    internal static string get_Error_RepositorySettings_UnsignedPackage();
    internal static string get_Error_RepositorySignatureMustNotHaveARepositoryCountersignature();
    internal static string get_Error_RequireMode_UnsignedPackage();
    internal static string get_ErrorAuthorTargetCannotBeACountersignature();
    internal static string get_ErrorByteSignatureNotFound();
    internal static string get_ErrorDuplicatePackages();
    internal static string get_ErrorInvalidAllowedVersions();
    internal static string get_ErrorInvalidCertificateChainUnspecifiedReason();
    internal static string get_ErrorInvalidMinClientVersion();
    internal static string get_ErrorInvalidPackageArchive();
    internal static string get_ErrorInvalidPackageVersion();
    internal static string get_ErrorInvalidPackageVersionForDependency();
    internal static string get_ErrorManifestFileNotFound();
    internal static string get_ErrorMultipleTimestamps();
    internal static string get_ErrorNoTimestamp();
    internal static string get_ErrorNullOrEmptyPackageId();
    internal static string get_ErrorPackageNotSigned();
    internal static string get_ErrorPackageSignatureInvalid();
    internal static string get_ErrorUnableCheckPackageEntries();
    internal static string get_ErrorUnableToDeleteFile();
    internal static string get_ErrorUnsafePackageEntry();
    internal static string get_ErrorZip64NotSupported();
    internal static string get_ExactlyOneAttributeRequired();
    internal static string get_ExactlyOneAttributeValueRequired();
    internal static string get_ExtractionLog_InformationPrefix();
    internal static string get_FailedFileTime();
    internal static string get_FailToLoadPackagesConfig();
    internal static string get_FailToWritePackagesConfig();
    internal static string get_FallbackFolderNotFound();
    internal static string get_HttpOrHttpsIsRequired();
    internal static string get_InvalidArgument();
    internal static string get_InvalidArgumentCombination();
    internal static string get_InvalidAsn1();
    internal static string get_InvalidLicenseExppressionVersion_VersionTooHigh();
    internal static string get_InvalidNuspecElement();
    internal static string get_InvalidNuspecEntry();
    internal static string get_InvalidPackageFrameworkFolderName();
    internal static string get_InvalidPackageNupkg();
    internal static string get_InvalidPackageSignatureFile();
    internal static string get_InvalidPackageSignatureFileEntry();
    internal static string get_InvalidPackageSignatureFileEntryCentralDirectoryHeader();
    internal static string get_InvalidPackageSignatureFileEntryLocalFileHeader();
    internal static string get_InvalidPackageTypeVersion();
    internal static string get_InvalidPrimarySignature();
    internal static string get_InvalidRepositoryCountersignature();
    internal static string get_InvalidSignatureContent();
    internal static string get_InvalidTimestampSignature();
    internal static string get_InvalidUrl();
    internal static string get_InvalidX509StorePurpose();
    internal static string get_Log_InstalledPackage();
    internal static string get_Message_Path();
    internal static string get_MinClientVersionAlreadyExist();
    internal static string get_MissingMetadataNode();
    internal static string get_MissingPackageTypeName();
    internal static string get_MissingTargetPlatformVersionsFromDependencyGroups();
    internal static string get_MissingTargetPlatformVersionsFromFrameworkAssemblyGroups();
    internal static string get_MissingTargetPlatformVersionsFromFrameworkAssemblyReferences();
    internal static string get_MissingTargetPlatformVersionsFromIncludedFiles();
    internal static string get_MissingTargetPlatformVersionsFromReferenceGroups();
    internal static string get_MultipleAttributesDisallowed();
    internal static string get_MultipleNuspecFiles();
    internal static string get_MultiplePackageSignatureFiles();
    internal static string get_MustContainAbsolutePath();
    internal static string get_NoPackageSignatureFile();
    internal static string get_NoRepositoryCountersignature();
    internal static string get_NuGetLicense_InvalidLicenseExpressionVersion();
    internal static string get_NuGetLicense_InvalidLicenseType();
    internal static string get_NuGetLicense_LicenseElementMissingValue();
    internal static string get_NuGetLicense_LicenseExpressionVersionTooHigh();
    internal static string get_NuGetLicense_MissingRequiredValue();
    internal static string get_NuGetLicenseExpression_DeprecatedIdentifier();
    internal static string get_NuGetLicenseExpression_ExceptionIdentifierIsLicense();
    internal static string get_NuGetLicenseExpression_IllegalUnlicensedOperator();
    internal static string get_NuGetLicenseExpression_InvalidCharacters();
    internal static string get_NuGetLicenseExpression_InvalidExceptionIdentifier();
    internal static string get_NuGetLicenseExpression_InvalidExpression();
    internal static string get_NuGetLicenseExpression_InvalidToken();
    internal static string get_NuGetLicenseExpression_LicenseIdentifierIsException();
    internal static string get_NuGetLicenseExpression_LicenseInvalidCharacters();
    internal static string get_NuGetLicenseExpression_MismatchedParentheses();
    internal static string get_NuGetLicenseExpression_NonStandardIdentifier();
    internal static string get_NuGetLicenseExpression_UnexpectedIdentifier();
    internal static string get_NuGetLicenseExpression_UnlicensedPackageWarning();
    internal static string get_NuGetPackageOwners();
    internal static string get_NuGetPackageOwnersInvalid();
    internal static string get_NuGetPackageOwnersInvalidValue();
    internal static string get_NuGetV3ServiceIndexUrl();
    internal static string get_NuGetV3ServiceIndexUrlInvalid();
    internal static string get_NuGetV3ServiceIndexUrlInvalidValue();
    internal static string get_PackageEntryAlreadyExist();
    internal static string get_PackageEntryNotExist();
    internal static string get_PackageMinVersionNotSatisfied();
    internal static string get_PackageSignatureVerificationLog();
    internal static string get_PackagesNodeNotExist();
    internal static string get_PackageStreamShouldBeSeekable();
    internal static string get_PrimarySignatureFriendlyName();
    internal static string get_PrimarySignatureHasNoTimestamp();
    internal static string get_PropertyCannotBeNull();
    internal static string get_RangeOutOfBoundsForArray();
    internal static string get_RepositoryCountersignatureFriendlyName();
    internal static string get_RepositoryCountersignatureHasNoCertificate();
    internal static string get_RepositoryCountersignatureHasNoTimestamp();
    internal static string get_RepositoryPrimarySignatureFriendlyName();
    internal static string get_SignatureContainsInvalidAttribute();
    internal static string get_SignatureDebug_HashOidFound();
    internal static string get_SignatureFailureInvalidHashAlgorithmOid();
    internal static string get_SignatureFriendlyName();
    internal static string get_SignatureHashAlgorithm();
    internal static string get_SignaturePackageIntegrityFailure();
    internal static string get_SignatureType();
    internal static string get_SignedPackageAlreadySigned();
    internal static string get_SignedPackageArchiveIOExtraRead();
    internal static string get_SignedPackageArchiveIOInvalidRead();
    internal static string get_SignedPackageNotSignedOnRemove();
    internal static string get_SignedPackageNotSignedOnVerify();
    internal static string get_SignedPackagePackageAlreadyCountersigned();
    internal static string get_SignedPackageUnableToAccessSignature();
    internal static string get_SignError_TimestampCertificateFailsPublicKeyLengthRequirement();
    internal static string get_SignError_TimestampGeneralizedTimeInvalid();
    internal static string get_SignError_TimestampIntegrityCheckFailed();
    internal static string get_SignError_TimestampNoCertificate();
    internal static string get_SignError_TimestampNotYetValid();
    internal static string get_SignError_TimestampSignatureValidationFailed();
    internal static string get_SignFailureCertificateInvalidProviderType();
    internal static string get_SigningCannotBeDoneInPlace();
    internal static string get_SigningCertificateAttributeMustNotBePresent();
    internal static string get_SigningCertificateCertificateNotFound();
    internal static string get_SigningCertificateInvalid();
    internal static string get_SigningCertificateV1OrV2AttributeMustBePresent();
    internal static string get_SigningCertificateV2CertificateNotFound();
    internal static string get_SigningCertificateV2Invalid();
    internal static string get_SigningCertificateV2UnsupportedHashAlgorithm();
    internal static string get_SigningError_CertificateFailsPublicKeyLengthRequirement();
    internal static string get_SigningError_CertificateHasLifetimeSigningEKU();
    internal static string get_SigningError_CertificateHasUnsupportedSignatureAlgorithm();
    internal static string get_SigningError_NotYetValid();
    internal static string get_SigningWouldRequireZip64();
    internal static string get_StreamMustBeReadable();
    internal static string get_StreamMustBeSeekable();
    internal static string get_StringCannotBeNullOrEmpty();
    internal static string get_TimestampCertificateUnsupportedSignatureAlgorithm();
    internal static string get_TimestampFailureInvalidHttpScheme();
    internal static string get_TimestampFailureNonceMismatch();
    internal static string get_TimestampServiceRespondedError();
    internal static string get_TimestampSignatureUnsupportedDigestAlgorithm();
    internal static string get_TimestampValue();
    internal static string get_UnableToAddEntry();
    internal static string get_UnableToParseClientVersion();
    internal static string get_UnableToReadPackageHashInformation();
    internal static string get_UnexpectedPackageSignatureVerificationError();
    internal static string get_UnrecognizedEnumValue();
    internal static string get_UnrelatedSignatures();
    internal static string get_UnsupportedAsn1();
    internal static string get_UnsupportedSignatureFormatVersion();
    internal static string get_UntrustedRoot_WithCertificateBundle();
    internal static string get_UntrustedRoot_WithoutCertificateBundle();
    internal static string get_VerificationCertDisplay();
    internal static string get_VerificationTimestamperCertDisplay();
    internal static string get_Verify_ErrorNoCertificate();
    internal static string get_VerifyCertTrustOfflineWhileRevocationModeOffline();
    internal static string get_VerifyCertTrustOfflineWhileRevocationModeOnline();
    internal static string get_VerifyChainBuildingIssue();
    internal static string get_VerifyChainBuildingIssue_UntrustedRoot();
    internal static string get_VerifyError_CertificateFailsPublicKeyLengthRequirement();
    internal static string get_VerifyError_CertificateHasLifetimeSigningEKU();
    internal static string get_VerifyError_CertificateHasUnsupportedSignatureAlgorithm();
    internal static string get_VerifyError_CertificateNotYetValid();
    internal static string get_VerifyError_InvalidCertificateChain();
    internal static string get_VerifyError_SignatureNotTimeValid();
    internal static string get_VerifyError_SignatureVerificationFailed();
    internal static string get_VerifyError_TimestampCertificateFailsPublicKeyLengthRequirement();
    internal static string get_VerifyError_TimestampGeneralizedTimeInvalid();
    internal static string get_VerifyError_TimestampIntegrityCheckFailed();
    internal static string get_VerifyError_TimestampInvalid();
    internal static string get_VerifyError_TimestampMessageImprintUnsupportedHashAlgorithm();
    internal static string get_VerifyError_TimestampNoCertificate();
    internal static string get_VerifyError_TimestampNotYetValid();
    internal static string get_VerifyError_TimestampSignatureUnsupportedDigestAlgorithm();
    internal static string get_VerifyError_TimestampSignatureValidationFailed();
    internal static string get_VerifyError_TimestampUnsupportedSignatureAlgorithm();
    internal static string get_VerifyError_TimestampVerifyChainBuildingIssue();
    internal static string get_VerifyTimestampChainBuildingIssue_UntrustedRoot();
    internal static string get_ZipFileLastWriteTimeStampModifiedMessage();
    internal static string get_ZipFileTimeStampModifiedWarning();
}
public static class NuGet.Packaging.TopologicalSortUtility : object {
    public static IReadOnlyList`1<T> SortPackagesByDependencyOrder(IEnumerable`1<T> items, StringComparer comparer, Func`2<T, string> getId, Func`2<T, String[]> getDependencies);
    public static IReadOnlyList`1<PackageDependencyInfo> SortPackagesByDependencyOrder(IEnumerable`1<PackageDependencyInfo> packages);
    private static List`1<ItemDependencyInfo> SortPackagesByDependencyOrder(List`1<ItemDependencyInfo> items, StringComparer comparer);
    private static void UpdateChildCounts(ItemDependencyInfo package);
    private static void CalculateRelationships(ItemDependencyInfo[] packages, Dictionary`2<string, ItemDependencyInfo> lookup);
    private static string GetPackageDependencyInfoId(PackageDependencyInfo info);
    private static String[] GetPackageDependencyInfoDependencies(PackageDependencyInfo info);
}
public class NuGet.Packaging.UnsafePackageEntryException : PackagingException {
    public UnsafePackageEntryException(string message);
    public virtual ILogMessage AsLogMessage();
}
public class NuGet.Packaging.VersionFolderPathResolver : object {
    [CompilerGeneratedAttribute]
private string <RootPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLowerCase>k__BackingField;
    public string RootPath { get; }
    public bool IsLowerCase { get; }
    public VersionFolderPathResolver(string rootPath);
    public VersionFolderPathResolver(string rootPath, bool isLowercase);
    [CompilerGeneratedAttribute]
public string get_RootPath();
    [CompilerGeneratedAttribute]
public bool get_IsLowerCase();
    public virtual string GetInstallPath(string packageId, NuGetVersion version);
    public string GetVersionListPath(string packageId);
    public string GetPackageFilePath(string packageId, NuGetVersion version);
    public string GetManifestFilePath(string packageId, NuGetVersion version);
    public string GetHashPath(string packageId, NuGetVersion version);
    public string GetHashFileName(string packageId, NuGetVersion version);
    public string GetNupkgMetadataPath(string packageId, NuGetVersion version);
    public virtual string GetVersionListDirectory(string packageId);
    public virtual string GetPackageDirectory(string packageId, NuGetVersion version);
    public virtual string GetPackageFileName(string packageId, NuGetVersion version);
    public string GetPackageDownloadMarkerFileName(string packageId);
    public virtual string GetManifestFileName(string packageId, NuGetVersion version);
    private string Normalize(NuGetVersion version);
    private string Normalize(string packageId);
}
[ExtensionAttribute]
public static class NuGet.Packaging.XElementExtensions : object {
    [ExtensionAttribute]
public static string GetOptionalAttributeValue(XElement element, string localName, string namespaceName);
    [ExtensionAttribute]
public static IEnumerable`1<XElement> ElementsNoNamespace(XContainer container, string localName);
    [ExtensionAttribute]
public static XElement Except(XElement source, XElement target);
    private static XElement FindElement(XElement source, XElement targetChild);
    private static int Compare(XElement target, XElement left, XElement right);
    private static int CountMatches(XElement left, XElement right, Func`3<XAttribute, XAttribute, bool> matcher);
    private static bool HasComment(XElement element, XComment comment);
    private static bool HasConflict(XElement source, XElement target);
    private static bool AttributeEquals(XAttribute source, XAttribute target);
}
[ExtensionAttribute]
internal static class NuGet.Packaging.Xml.PackageMetadataXmlExtensions : object {
    private static string References;
    private static string Reference;
    private static string Group;
    private static string File;
    private static string TargetFramework;
    private static string FrameworkAssemblies;
    private static string FrameworkAssembly;
    private static string AssemblyName;
    private static string Dependencies;
    private static string Files;
    [ExtensionAttribute]
public static XElement ToXElement(ManifestMetadata metadata, XNamespace ns);
    [ExtensionAttribute]
public static XElement ToXElement(ManifestMetadata metadata, XNamespace ns, bool generateBackwardsCompatible);
    private static XElement GetXElementFromGroupableItemSets(XNamespace ns, IEnumerable`1<TSet> objectSets, Func`2<TSet, bool> isGroupable, Func`2<TSet, string> getGroupIdentifer, Func`2<TSet, IEnumerable`1<TItem>> getItems, Func`3<XNamespace, TItem, XElement> getXElementFromItem, string parentName, string identifierAttributeName);
    private static XElement GetXElementFromFrameworkReference(XNamespace ns, FrameworkReference frameworkReference);
    private static XElement GetXElementFromPackageReference(XNamespace ns, string reference);
    private static XElement GetXElementFromPackageDependency(XNamespace ns, PackageDependency dependency);
    private static XElement GetXElementFromFrameworkAssemblies(XNamespace ns, IEnumerable`1<FrameworkAssemblyReference> references);
    private static XElement GetXElementFromManifestContentFiles(XNamespace ns, IEnumerable`1<ManifestContentFiles> contentFiles);
    private static XElement GetXElementFromManifestContentFile(XNamespace ns, ManifestContentFiles file);
    private static XElement GetXElementFromLicenseMetadata(XNamespace ns, LicenseMetadata metadata);
    private static XElement GetXElementFromManifestRepository(XNamespace ns, RepositoryMetadata repository);
    private static XElement GetXElementFromManifestPackageTypes(XNamespace ns, IEnumerable`1<PackageType> packageTypes);
    private static XElement GetXElementFromManifestPackageType(XNamespace ns, PackageType packageType);
    private static XAttribute GetXAttributeFromNameAndValue(string name, object value);
    private static void AddElementIfNotNull(XElement parent, XNamespace ns, string name, T value);
    private static void AddElementIfNotNull(XElement parent, XNamespace ns, string name, T value, Func`2<T, object> process);
    private static void AddElementIfNotEmpty(XElement parent, XNamespace ns, string name, IEnumerable`1<T> value, Func`2<IEnumerable`1<T>, object> process);
}
public enum NuGet.Packaging.XmlDocFileSaveMode : Enum {
    public int value__;
    public static XmlDocFileSaveMode None;
    public static XmlDocFileSaveMode Skip;
    public static XmlDocFileSaveMode Compress;
}
[ObsoleteAttribute("This class is obsolete and will be removed in a future release.")]
public static class NuGet.Packaging.XmlUtility : object {
    public static XDocument LoadSafe(Stream input);
    public static XDocument LoadSafe(Stream input, bool ignoreWhiteSpace);
}
[ExtensionAttribute]
public static class NuGet.Packaging.ZipArchiveExtensions : object {
    [ExtensionAttribute]
public static ZipArchiveEntry LookupEntry(ZipArchive zipArchive, string path);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetFiles(ZipArchive zipArchive);
    private static string UnescapePath(string path);
    [ExtensionAttribute]
public static Stream OpenFile(ZipArchive zipArchive, string path);
    [ExtensionAttribute]
public static string SaveAsFile(ZipArchiveEntry entry, string fileFullPath, ILogger logger);
    [ExtensionAttribute]
public static void UpdateFileTimeFromEntry(ZipArchiveEntry entry, string fileFullPath, ILogger logger);
    internal static void UpdateFileTime(string fileFullPath, DateTime dateTime);
}
public class NuGet.Packaging.ZipFilePair : object {
    private ZipArchiveEntry _packageEntry;
    private string _fileFullPath;
    public string FileFullPath { get; }
    public ZipArchiveEntry PackageEntry { get; }
    public ZipFilePair(string fileFullPath, ZipArchiveEntry entry);
    public string get_FileFullPath();
    public ZipArchiveEntry get_PackageEntry();
    public bool IsInstalled();
}
public class NuGet.ProjectModel.AssetsLogMessage : object {
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLogCode <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private WarningLevel <WarningLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LibraryId>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <TargetGraphs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartColumnNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumnNumber>k__BackingField;
    public LogLevel Level { get; }
    public NuGetLogCode Code { get; }
    public string Message { get; }
    public string ProjectPath { get; public set; }
    public WarningLevel WarningLevel { get; public set; }
    public string FilePath { get; public set; }
    public string LibraryId { get; public set; }
    public IReadOnlyList`1<string> TargetGraphs { get; public set; }
    public int StartLineNumber { get; public set; }
    public int StartColumnNumber { get; public set; }
    public int EndLineNumber { get; public set; }
    public int EndColumnNumber { get; public set; }
    public AssetsLogMessage(LogLevel logLevel, NuGetLogCode errorCode, string errorString, string targetGraph);
    public AssetsLogMessage(LogLevel logLevel, NuGetLogCode errorCode, string errorString);
    [CompilerGeneratedAttribute]
public sealed virtual LogLevel get_Level();
    [CompilerGeneratedAttribute]
public sealed virtual NuGetLogCode get_Code();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProjectPath();
    [CompilerGeneratedAttribute]
public void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual WarningLevel get_WarningLevel();
    [CompilerGeneratedAttribute]
public void set_WarningLevel(WarningLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_LibraryId();
    [CompilerGeneratedAttribute]
public void set_LibraryId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_TargetGraphs();
    [CompilerGeneratedAttribute]
public void set_TargetGraphs(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_StartLineNumber();
    [CompilerGeneratedAttribute]
public void set_StartLineNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_StartColumnNumber();
    [CompilerGeneratedAttribute]
public void set_StartColumnNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_EndLineNumber();
    [CompilerGeneratedAttribute]
public void set_EndLineNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_EndColumnNumber();
    [CompilerGeneratedAttribute]
public void set_EndColumnNumber(int value);
    public static IAssetsLogMessage Create(IRestoreLogMessage logMessage);
    public sealed virtual bool Equals(IAssetsLogMessage other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class NuGet.ProjectModel.BuildAction : ValueType {
    private static ConcurrentDictionary`2<string, BuildAction> _knownBuildActions;
    public static BuildAction None;
    public static BuildAction Compile;
    public static BuildAction Content;
    public static BuildAction EmbeddedResource;
    public static BuildAction ApplicationDefinition;
    public static BuildAction Page;
    public static BuildAction Resource;
    public static BuildAction SplashScreen;
    public static BuildAction DesignData;
    public static BuildAction DesignDataWithDesignTimeCreatableTypes;
    public static BuildAction CodeAnalysisDictionary;
    public static BuildAction AndroidAsset;
    public static BuildAction AndroidResource;
    public static BuildAction BundleResource;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsKnown>k__BackingField;
    public string Value { get; }
    public bool IsKnown { get; }
    private BuildAction(string value, bool isKnown);
    private static BuildAction();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Value();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsKnown();
    public static BuildAction Parse(string value);
    public virtual string ToString();
    public sealed virtual bool Equals(BuildAction other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(BuildAction left, BuildAction right);
    public static bool op_Inequality(BuildAction left, BuildAction right);
    public virtual int GetHashCode();
    private static BuildAction Define(string name);
}
public class NuGet.ProjectModel.BuildOptions : object {
    [CompilerGeneratedAttribute]
private string <OutputName>k__BackingField;
    public string OutputName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_OutputName();
    [CompilerGeneratedAttribute]
public void set_OutputName(string value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(BuildOptions other);
    public BuildOptions Clone();
}
public class NuGet.ProjectModel.CacheFile : object {
    internal static int CurrentVersion;
    [CompilerGeneratedAttribute]
private string <DgSpecHash>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <ExpectedPackageFilePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IAssetsLogMessage> <LogMessages>k__BackingField;
    public string DgSpecHash { get; }
    public int Version { get; public set; }
    public bool Success { get; public set; }
    public IList`1<string> ExpectedPackageFilePaths { get; public set; }
    [ObsoleteAttribute("File existence checks are a function of time not the cache file content.")]
public bool HasAnyMissingPackageFiles { get; public set; }
    public string ProjectFilePath { get; public set; }
    public IList`1<IAssetsLogMessage> LogMessages { get; public set; }
    public bool IsValid { get; }
    public CacheFile(string dgSpecHash);
    [CompilerGeneratedAttribute]
public string get_DgSpecHash();
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
public void set_Success(bool value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_ExpectedPackageFilePaths();
    [CompilerGeneratedAttribute]
public void set_ExpectedPackageFilePaths(IList`1<string> value);
    public bool get_HasAnyMissingPackageFiles();
    public void set_HasAnyMissingPackageFiles(bool value);
    [CompilerGeneratedAttribute]
public string get_ProjectFilePath();
    [CompilerGeneratedAttribute]
public void set_ProjectFilePath(string value);
    [CompilerGeneratedAttribute]
public IList`1<IAssetsLogMessage> get_LogMessages();
    [CompilerGeneratedAttribute]
public void set_LogMessages(IList`1<IAssetsLogMessage> value);
    public bool get_IsValid();
    public sealed virtual bool Equals(CacheFile other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class NuGet.ProjectModel.CacheFileFormat : object {
    private static string VersionProperty;
    private static string DGSpecHashProperty;
    private static string SuccessProperty;
    private static string ExpectedPackageFilesProperty;
    private static string ProjectFilePathProperty;
    public static CacheFile Read(Stream stream, ILogger log, string path);
    private static CacheFile Read(TextReader reader, ILogger log, string path);
    public static void Write(string filePath, CacheFile lockFile);
    public static void Write(Stream stream, CacheFile cacheFile);
    private static void Write(TextWriter textWriter, CacheFile cacheFile);
    private static CacheFile ReadCacheFile(JObject cursor);
    private static JObject GetCacheFile(CacheFile cacheFile);
    private static string ReadString(JToken json);
    private static JToken WriteString(string item);
    private static int ReadInt(JToken json);
    private static JToken WriteInt(int item);
    private static bool ReadBool(JToken json);
    private static JToken WriteBool(bool item);
}
public class NuGet.ProjectModel.CentralTransitiveDependencyGroup : object {
    [CompilerGeneratedAttribute]
private string <FrameworkName>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<LibraryDependency> <TransitiveDependencies>k__BackingField;
    public string FrameworkName { get; }
    public IEnumerable`1<LibraryDependency> TransitiveDependencies { get; }
    public CentralTransitiveDependencyGroup(NuGetFramework framework, IEnumerable`1<LibraryDependency> transitiveDependencies);
    [CompilerGeneratedAttribute]
public string get_FrameworkName();
    [CompilerGeneratedAttribute]
public IEnumerable`1<LibraryDependency> get_TransitiveDependencies();
    public sealed virtual bool Equals(CentralTransitiveDependencyGroup other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class NuGet.ProjectModel.CircularMemoryStream : MemoryStream {
    private Byte[] _buffer;
    [CompilerGeneratedAttribute]
private EventHandler`1<ArraySegment`1<byte>> OnFlush;
    internal CircularMemoryStream(Byte[] buffer);
    [CompilerGeneratedAttribute]
internal void add_OnFlush(EventHandler`1<ArraySegment`1<byte>> value);
    [CompilerGeneratedAttribute]
internal void remove_OnFlush(EventHandler`1<ArraySegment`1<byte>> value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual void Flush();
    private void FlushIfFull();
}
public class NuGet.ProjectModel.DependencyGraphSpec : object {
    private static bool UseLegacyHashFunction;
    private static string DGSpecFileNameExtension;
    private SortedSet`1<string> _restore;
    private SortedDictionary`2<string, PackageSpec> _projects;
    private static int Version;
    private bool _isReadOnly;
    public IReadOnlyList`1<string> Restore { get; }
    public IReadOnlyList`1<PackageSpec> Projects { get; }
    public DependencyGraphSpec(bool isReadOnly);
    private static DependencyGraphSpec();
    public static string GetDGSpecFileName(string projectName);
    public IReadOnlyList`1<string> get_Restore();
    public IReadOnlyList`1<PackageSpec> get_Projects();
    public PackageSpec GetProjectSpec(string projectUniqueName);
    public IReadOnlyList`1<string> GetParents(string rootUniqueName);
    public DependencyGraphSpec WithProjectClosure(string projectUniqueName);
    public DependencyGraphSpec CreateFromClosure(string projectUniqueName, IReadOnlyList`1<PackageSpec> closure);
    public IReadOnlyList`1<PackageSpec> GetClosure(string rootUniqueName);
    private static IEnumerable`1<string> GetProjectReferenceNames(PackageSpec spec, SortedDictionary`2<string, PackageSpec> projectsByUniqueName);
    public void AddRestore(string projectUniqueName);
    public void AddProject(PackageSpec projectSpec);
    public static DependencyGraphSpec Union(IEnumerable`1<DependencyGraphSpec> dgSpecs);
    public static DependencyGraphSpec Load(string path);
    public void Save(string path);
    public void Save(Stream stream);
    public string GetHash();
    private void Write(IObjectWriter writer, bool hashing, Action`4<PackageSpec, IObjectWriter, bool, IEnvironmentVariableReader> writeAction);
    public static IReadOnlyList`1<PackageSpec> SortPackagesByDependencyOrder(IEnumerable`1<PackageSpec> packages);
    public DependencyGraphSpec WithoutRestores();
    public DependencyGraphSpec WithReplacedSpec(PackageSpec project);
    public DependencyGraphSpec WithPackageSpecs(IEnumerable`1<PackageSpec> packageSpecs);
    public DependencyGraphSpec WithoutTools();
    private static string GetPackageSpecId(PackageSpec spec);
    private static String[] GetPackageSpecDependencyIds(PackageSpec spec);
}
public class NuGet.ProjectModel.ExternalProjectReference : object {
    private PackageSpec _packageSpec;
    [CompilerGeneratedAttribute]
private string <UniqueName>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <ExternalProjectReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectJsonPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageSpecProjectName>k__BackingField;
    public string UniqueName { get; }
    public PackageSpec PackageSpec { get; }
    public IReadOnlyList`1<string> ExternalProjectReferences { get; }
    public string MSBuildProjectPath { get; }
    public string ProjectJsonPath { get; }
    public string PackageSpecProjectName { get; }
    public string ProjectName { get; }
    public ExternalProjectReference(string uniqueName, PackageSpec packageSpec, string msbuildProjectPath, IEnumerable`1<string> projectReferences);
    public ExternalProjectReference(string uniqueName, string packageSpecProjectName, string packageSpecPath, string msbuildProjectPath, IEnumerable`1<string> projectReferences);
    [CompilerGeneratedAttribute]
public string get_UniqueName();
    public PackageSpec get_PackageSpec();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_ExternalProjectReferences();
    [CompilerGeneratedAttribute]
public string get_MSBuildProjectPath();
    [CompilerGeneratedAttribute]
public string get_ProjectJsonPath();
    [CompilerGeneratedAttribute]
public string get_PackageSpecProjectName();
    public string get_ProjectName();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(ExternalProjectReference other);
    public sealed virtual int CompareTo(ExternalProjectReference other);
}
public class NuGet.ProjectModel.FileFormatException : Exception {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    public string Path { get; private set; }
    public int Line { get; private set; }
    public int Column { get; private set; }
    public FileFormatException(string message);
    public FileFormatException(string message, Exception innerException);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
private void set_Line(int value);
    [CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
private void set_Column(int value);
    private FileFormatException WithFilePath(string path);
    private FileFormatException WithLineInfo(JsonReaderException exception);
    private FileFormatException WithLineInfo(int line, int column);
    private FileFormatException WithLineInfo(IJsonLineInfo lineInfo);
    public static FileFormatException Create(Exception exception, JToken value, string path);
    internal static FileFormatException Create(Exception exception, int line, int column, string path);
    internal static FileFormatException Create(Exception exception, string path);
    public static FileFormatException Create(string message, JToken value, string path);
    internal static FileFormatException Create(string message, int line, int column, string path);
    internal static FileFormatException Create(JsonReaderException exception, string path);
    internal static FileFormatException Create(string message, string path);
}
internal class NuGet.ProjectModel.FnvHash64Function : object {
    private ulong _hash;
    public sealed virtual void Update(Byte[] data, int offset, int count);
    public Byte[] GetHashBytes();
    public sealed virtual string GetHash();
    public sealed virtual void Dispose();
}
public class NuGet.ProjectModel.HashObjectWriter : object {
    private static int DefaultBufferSize;
    private Byte[] _buffer;
    private IHashFunction _hashFunc;
    private bool _isDisposed;
    private bool _isReadOnly;
    private int _nestLevel;
    private CircularMemoryStream _stream;
    private StreamWriter _streamWriter;
    private JsonTextWriter _writer;
    public HashObjectWriter(IHashFunction hashFunc);
    public sealed virtual void Dispose();
    public sealed virtual void WriteObjectStart();
    public sealed virtual void WriteObjectStart(string name);
    public sealed virtual void WriteObjectEnd();
    public sealed virtual void WriteNameValue(string name, int value);
    public sealed virtual void WriteNameValue(string name, bool value);
    public sealed virtual void WriteNameValue(string name, string value);
    public sealed virtual void WriteNameArray(string name, IEnumerable`1<string> values);
    public sealed virtual void WriteNonEmptyNameArray(string name, IEnumerable`1<string> values);
    public string GetHash();
    public sealed virtual void WriteArrayStart(string name);
    public sealed virtual void WriteArrayEnd();
    private void OnFlush(object sender, ArraySegment`1<byte> bytes);
    private void ThrowIfReadOnly();
    private void ThrowIfDisposed();
}
public interface NuGet.ProjectModel.IAssetsLogMessage {
    public LogLevel Level { get; }
    public NuGetLogCode Code { get; }
    public string Message { get; }
    public string ProjectPath { get; }
    public WarningLevel WarningLevel { get; }
    public string FilePath { get; }
    public int StartLineNumber { get; }
    public int StartColumnNumber { get; }
    public int EndLineNumber { get; }
    public int EndColumnNumber { get; }
    public string LibraryId { get; }
    public IReadOnlyList`1<string> TargetGraphs { get; }
    public abstract virtual LogLevel get_Level();
    public abstract virtual NuGetLogCode get_Code();
    public abstract virtual string get_Message();
    public abstract virtual string get_ProjectPath();
    public abstract virtual WarningLevel get_WarningLevel();
    public abstract virtual string get_FilePath();
    public abstract virtual int get_StartLineNumber();
    public abstract virtual int get_StartColumnNumber();
    public abstract virtual int get_EndLineNumber();
    public abstract virtual int get_EndColumnNumber();
    public abstract virtual string get_LibraryId();
    public abstract virtual IReadOnlyList`1<string> get_TargetGraphs();
}
public interface NuGet.ProjectModel.IExternalProjectReferenceProvider {
    public abstract virtual IReadOnlyList`1<ExternalProjectReference> GetReferences(string entryPointPath);
    public abstract virtual IReadOnlyList`1<ExternalProjectReference> GetEntryPoints();
}
public class NuGet.ProjectModel.IncludeExcludeFiles : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <IncludeFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <ExcludeFiles>k__BackingField;
    public IReadOnlyList`1<string> Include { get; public set; }
    public IReadOnlyList`1<string> Exclude { get; public set; }
    public IReadOnlyList`1<string> IncludeFiles { get; public set; }
    public IReadOnlyList`1<string> ExcludeFiles { get; public set; }
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Include();
    [CompilerGeneratedAttribute]
public void set_Include(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_IncludeFiles();
    [CompilerGeneratedAttribute]
public void set_IncludeFiles(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_ExcludeFiles();
    [CompilerGeneratedAttribute]
public void set_ExcludeFiles(IReadOnlyList`1<string> value);
    public bool HandleIncludeExcludeFiles(JObject jsonObject);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IncludeExcludeFiles other);
    public IncludeExcludeFiles Clone();
    private static bool TryGetStringEnumerableFromJArray(JToken token, IReadOnlyList`1& result);
}
internal interface NuGet.ProjectModel.IUtf8JsonStreamReaderConverter`1 {
    public abstract virtual T Read(Utf8JsonStreamReader& reader);
}
public static class NuGet.ProjectModel.JsonPackageSpecReader : object {
    private static Char[] DelimitedStringSeparators;
    private static Char[] VersionSeparators;
    private static char VersionSeparator;
    public static string RestoreOptions;
    public static string RestoreSettings;
    public static string HideWarningsAndErrors;
    public static string PackOptions;
    public static string PackageType;
    public static string Files;
    private static Byte[] AuthorsPropertyName;
    private static Byte[] BuildOptionsPropertyName;
    private static Byte[] ContentFilesPropertyName;
    private static Byte[] CopyrightPropertyName;
    private static Byte[] DependenciesPropertyName;
    private static Byte[] DescriptionPropertyName;
    private static Byte[] LanguagePropertyName;
    private static Byte[] PackIncludePropertyName;
    private static Byte[] PackOptionsPropertyName;
    private static Byte[] ScriptsPropertyName;
    private static Byte[] FrameworksPropertyName;
    private static Byte[] RestorePropertyName;
    private static Byte[] RuntimesPropertyName;
    private static Byte[] SupportsPropertyName;
    private static Byte[] TitlePropertyName;
    private static Byte[] VersionPropertyName;
    private static Byte[] OutputNamePropertyName;
    private static Byte[] AutoReferencedPropertyName;
    private static Byte[] ExcludePropertyName;
    private static Byte[] GeneratePathPropertyPropertyName;
    private static Byte[] IncludePropertyName;
    private static Byte[] NoWarnPropertyName;
    private static Byte[] SuppressParentPropertyName;
    private static Byte[] TargetPropertyName;
    private static Byte[] VersionOverridePropertyName;
    private static Byte[] VersionCentrallyManagedPropertyName;
    private static Byte[] AliasesPropertyName;
    private static Byte[] NamePropertyName;
    private static Byte[] PrivateAssetsPropertyName;
    private static Byte[] ExcludeFilesPropertyName;
    private static Byte[] IncludeFilesPropertyName;
    private static Byte[] CentralPackageVersionsManagementEnabledPropertyName;
    private static Byte[] CentralPackageVersionOverrideDisabledPropertyName;
    private static Byte[] CentralPackageTransitivePinningEnabledPropertyName;
    private static Byte[] ConfigFilePathsPropertyName;
    private static Byte[] CrossTargetingPropertyName;
    private static Byte[] FallbackFoldersPropertyName;
    private static Byte[] FilesPropertyName;
    private static Byte[] LegacyPackagesDirectoryPropertyName;
    private static Byte[] OriginalTargetFrameworksPropertyName;
    private static Byte[] OutputPathPropertyName;
    private static Byte[] PackagesConfigPathPropertyName;
    private static Byte[] PackagesPathPropertyName;
    private static Byte[] ProjectJsonPathPropertyName;
    private static Byte[] ProjectNamePropertyName;
    private static Byte[] ProjectPathPropertyName;
    private static Byte[] ProjectStylePropertyName;
    private static Byte[] ProjectUniqueNamePropertyName;
    private static Byte[] RestoreLockPropertiesPropertyName;
    private static Byte[] NuGetLockFilePathPropertyName;
    private static Byte[] RestoreLockedModePropertyName;
    private static Byte[] RestorePackagesWithLockFilePropertyName;
    private static Byte[] RestoreAuditPropertiesPropertyName;
    private static Byte[] EnableAuditPropertyName;
    private static Byte[] AuditLevelPropertyName;
    private static Byte[] AuditModePropertyName;
    private static Byte[] AuditSuppressionsPropertyName;
    private static Byte[] SkipContentFileWritePropertyName;
    private static Byte[] SourcesPropertyName;
    private static Byte[] ValidateRuntimeAssetsPropertyName;
    private static Byte[] WarningPropertiesPropertyName;
    private static Byte[] AllWarningsAsErrorsPropertyName;
    private static Byte[] WarnAsErrorPropertyName;
    private static Byte[] WarnNotAsErrorPropertyName;
    private static Byte[] ExcludeAssetsPropertyName;
    private static Byte[] IncludeAssetsPropertyName;
    private static Byte[] TargetAliasPropertyName;
    private static Byte[] AssetTargetFallbackPropertyName;
    private static Byte[] SecondaryFrameworkPropertyName;
    private static Byte[] CentralPackageVersionsPropertyName;
    private static Byte[] DownloadDependenciesPropertyName;
    private static Byte[] FrameworkAssembliesPropertyName;
    private static Byte[] FrameworkReferencesPropertyName;
    private static Byte[] ImportsPropertyName;
    private static Byte[] RuntimeIdentifierGraphPathPropertyName;
    private static Byte[] WarnPropertyName;
    private static Byte[] IconUrlPropertyName;
    private static Byte[] LicenseUrlPropertyName;
    private static Byte[] OwnersPropertyName;
    private static Byte[] PackageTypePropertyName;
    private static Byte[] ProjectUrlPropertyName;
    private static Byte[] ReleaseNotesPropertyName;
    private static Byte[] RequireLicenseAcceptancePropertyName;
    private static Byte[] SummaryPropertyName;
    private static Byte[] TagsPropertyName;
    private static Byte[] MappingsPropertyName;
    private static Byte[] HashTagImportPropertyName;
    private static Byte[] ProjectReferencesPropertyName;
    private static Byte[] EmptyStringPropertyName;
    private static JsonPackageSpecReader();
    public static PackageSpec GetPackageSpec(string name, string packageSpecPath);
    public static PackageSpec GetPackageSpec(string json, string name, string packageSpecPath);
    public static PackageSpec GetPackageSpec(Stream stream, string name, string packageSpecPath, string snapshotValue);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release.")]
public static PackageSpec GetPackageSpec(JObject json);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release.")]
public static PackageSpec GetPackageSpec(JObject rawPackageSpec, string name, string packageSpecPath, string snapshotValue);
    [ObsoleteAttribute]
internal static PackageSpec GetPackageSpec(JsonTextReader jsonReader, string packageSpecPath);
    internal static PackageSpec GetPackageSpec(Stream stream, string name, string packageSpecPath, string snapshotValue, IEnvironmentVariableReader environmentVariableReader, bool bypassCache);
    [ObsoleteAttribute]
internal static PackageSpec GetPackageSpec(JsonTextReader jsonReader, string name, string packageSpecPath, IEnvironmentVariableReader environmentVariableReader, string snapshotValue);
    [ObsoleteAttribute]
private static PackageType CreatePackageType(JsonTextReader jsonReader);
    [ObsoleteAttribute]
private static void ReadBuildOptions(JsonTextReader jsonReader, PackageSpec packageSpec);
    [ObsoleteAttribute]
private static void ReadCentralPackageVersions(JsonTextReader jsonReader, IDictionary`2<string, CentralPackageVersion> centralPackageVersions, string filePath);
    [ObsoleteAttribute]
private static CompatibilityProfile ReadCompatibilityProfile(JsonTextReader jsonReader, string profileName);
    [IteratorStateMachineAttribute("NuGet.ProjectModel.JsonPackageSpecReader/<ReadCompatibilitySets>d__21")]
[ObsoleteAttribute]
private static IEnumerable`1<FrameworkRuntimePair> ReadCompatibilitySets(JsonTextReader jsonReader, string compatibilitySetName);
    [ObsoleteAttribute]
private static void ReadDependencies(JsonTextReader jsonReader, IList`1<LibraryDependency> results, string packageSpecPath, bool isGacOrFrameworkReference);
    [ObsoleteAttribute]
internal static void ReadCentralTransitiveDependencyGroup(JsonTextReader jsonReader, IList`1<LibraryDependency> results, string packageSpecPath);
    [ObsoleteAttribute]
private static void ReadDownloadDependencies(JsonTextReader jsonReader, IList`1<DownloadDependency> downloadDependencies, string packageSpecPath);
    [ObsoleteAttribute]
private static IReadOnlyList`1<string> ReadEnumerableOfString(JsonTextReader jsonReader);
    [ObsoleteAttribute]
private static void ReadFrameworkReferences(JsonTextReader jsonReader, ISet`1<FrameworkDependency> frameworkReferences, string packageSpecPath);
    [ObsoleteAttribute]
private static void ReadFrameworks(JsonTextReader jsonReader, PackageSpec packageSpec);
    [ObsoleteAttribute]
private static void ReadImports(PackageSpec packageSpec, JsonTextReader jsonReader, TargetFrameworkInformation targetFrameworkInformation);
    [ObsoleteAttribute]
private static void ReadMappings(JsonTextReader jsonReader, string mappingKey, IDictionary`2<string, IncludeExcludeFiles> mappings);
    [ObsoleteAttribute]
private static void ReadMSBuildMetadata(JsonTextReader jsonReader, PackageSpec packageSpec, IEnvironmentVariableReader environmentVariableReader);
    private static string ExtractMacro(string value, string userSettingsDirectory, bool useMacros);
    private static void ExtractMacros(List`1<string> paths, string userSettingsDirectory, bool useMacros);
    private static bool ReadNextTokenAsBoolOrFalse(JsonTextReader jsonReader, string filePath);
    [ObsoleteAttribute]
private static void ReadNuGetLogCodes(JsonTextReader jsonReader, HashSet`1<NuGetLogCode> hashCodes);
    private static IList`1<NuGetLogCode> ReadNuGetLogCodesList(JsonTextReader jsonReader);
    [ObsoleteAttribute]
private static void ReadPackageTypes(PackageSpec packageSpec, JsonTextReader jsonReader);
    [ObsoleteAttribute]
private static void ReadPackInclude(JsonTextReader jsonReader, PackageSpec packageSpec);
    [ObsoleteAttribute]
private static void ReadPackOptions(JsonTextReader jsonReader, PackageSpec packageSpec, Boolean& isMappingsNull);
    [ObsoleteAttribute]
private static bool ReadPackOptionsFiles(PackageSpec packageSpec, JsonTextReader jsonReader, bool wasMappingsRead);
    [ObsoleteAttribute]
private static RuntimeDependencySet ReadRuntimeDependencySet(JsonTextReader jsonReader, string dependencySetName);
    [ObsoleteAttribute]
private static RuntimeDescription ReadRuntimeDescription(JsonTextReader jsonReader, string runtimeName);
    [ObsoleteAttribute]
private static List`1<RuntimeDescription> ReadRuntimes(JsonTextReader jsonReader);
    [ObsoleteAttribute]
private static void ReadScripts(JsonTextReader jsonReader, PackageSpec packageSpec);
    [ObsoleteAttribute]
private static String[] ReadStringArray(JsonTextReader jsonReader);
    [ObsoleteAttribute]
private static List`1<CompatibilityProfile> ReadSupports(JsonTextReader jsonReader);
    [ObsoleteAttribute]
private static LibraryDependencyTarget ReadTarget(JsonTextReader jsonReader, string packageSpecPath, LibraryDependencyTarget targetFlagsValue);
    [ObsoleteAttribute]
private static List`1<ProjectRestoreMetadataFrameworkInfo> ReadTargetFrameworks(JsonTextReader jsonReader);
    [ObsoleteAttribute]
private static void ReadTargetFrameworks(PackageSpec packageSpec, JsonTextReader jsonReader, Int32& frameworkLine, Int32& frameworkColumn);
    [ObsoleteAttribute]
private static void AddTargetFramework(PackageSpec packageSpec, NuGetFramework frameworkName, NuGetFramework secondaryFramework, TargetFrameworkInformation targetFrameworkInformation);
    [ObsoleteAttribute]
private static NuGetFramework GetDualCompatibilityFrameworkIfNeeded(NuGetFramework frameworkName, NuGetFramework secondaryFramework);
    [ObsoleteAttribute]
private static bool ValidateDependencyTarget(LibraryDependencyTarget targetValue);
    private static HashSet`1<string> ReadSuppressedAdvisories(JsonTextReader jsonReader);
    internal static PackageSpec GetPackageSpecUtf8JsonStreamReader(Stream stream, string name, string packageSpecPath, IEnvironmentVariableReader environmentVariableReader, string snapshotValue);
    internal static PackageSpec GetPackageSpec(Utf8JsonStreamReader& jsonReader, string name, string packageSpecPath, IEnvironmentVariableReader environmentVariableReader, string snapshotValue);
    internal static void ReadCentralTransitiveDependencyGroup(Utf8JsonStreamReader& jsonReader, IList`1& results, string packageSpecPath);
    private static LibraryDependency ReadLibraryDependency(Utf8JsonStreamReader& jsonReader, string packageSpecPath, string libraryName);
    private static void ReadCentralTransitiveDependencyGroupProperties(Utf8JsonStreamReader& jsonReader, LibraryIncludeFlags& dependencyIncludeFlagsValue, LibraryIncludeFlags& dependencyExcludeFlagsValue, LibraryIncludeFlags& suppressParentFlagsValue, String& dependencyVersionValue);
    private static void ReadDependencies(Utf8JsonStreamReader& jsonReader, IList`1<LibraryDependency> results, string packageSpecPath, bool isGacOrFrameworkReference);
    private static PackageType CreatePackageType(Utf8JsonStreamReader& jsonReader);
    [ObsoleteAttribute]
private static void ReadBuildOptions(Utf8JsonStreamReader& jsonReader, PackageSpec packageSpec);
    private static void ReadCentralPackageVersions(Utf8JsonStreamReader& jsonReader, IDictionary`2<string, CentralPackageVersion> centralPackageVersions, string filePath);
    private static CompatibilityProfile ReadCompatibilityProfile(Utf8JsonStreamReader& jsonReader, string profileName);
    [IteratorStateMachineAttribute("NuGet.ProjectModel.JsonPackageSpecReader/<ReadCompatibilitySets>d__152")]
private static IEnumerable`1<FrameworkRuntimePair> ReadCompatibilitySets(IReadOnlyList`1<string> values, string compatibilitySetName);
    private static void ReadDownloadDependencies(Utf8JsonStreamReader& jsonReader, IList`1<DownloadDependency> downloadDependencies, string packageSpecPath);
    private static void ReadFrameworkReferences(Utf8JsonStreamReader& jsonReader, ISet`1<FrameworkDependency> frameworkReferences, string packageSpecPath);
    private static void ReadFrameworks(Utf8JsonStreamReader& reader, PackageSpec packageSpec);
    private static void ReadImports(PackageSpec packageSpec, Utf8JsonStreamReader& jsonReader, TargetFrameworkInformation targetFrameworkInformation);
    private static void ReadMappings(Utf8JsonStreamReader& jsonReader, string mappingKey, IDictionary`2<string, IncludeExcludeFiles> mappings);
    private static void ReadMSBuildMetadata(Utf8JsonStreamReader& jsonReader, PackageSpec packageSpec, IEnvironmentVariableReader environmentVariableReader);
    private static void ReadNuGetLogCodes(Utf8JsonStreamReader& jsonReader, HashSet`1<NuGetLogCode> hashCodes);
    private static List`1<NuGetLogCode> ReadNuGetLogCodesList(Utf8JsonStreamReader& jsonReader);
    private static void ReadPackageTypes(PackageSpec packageSpec, Utf8JsonStreamReader& jsonReader);
    [ObsoleteAttribute]
private static void ReadPackInclude(Utf8JsonStreamReader& jsonReader, PackageSpec packageSpec);
    [ObsoleteAttribute]
private static void ReadPackOptions(Utf8JsonStreamReader& jsonReader, PackageSpec packageSpec, Boolean& isMappingsNull);
    [ObsoleteAttribute]
private static bool ReadPackOptionsFiles(PackageSpec packageSpec, Utf8JsonStreamReader& jsonReader, bool wasMappingsRead);
    private static RuntimeDependencySet ReadRuntimeDependencySet(Utf8JsonStreamReader& jsonReader, string dependencySetName);
    private static RuntimeDescription ReadRuntimeDescription(Utf8JsonStreamReader& jsonReader, string runtimeName);
    private static List`1<RuntimeDescription> ReadRuntimes(Utf8JsonStreamReader& jsonReader);
    [ObsoleteAttribute]
private static void ReadScripts(Utf8JsonStreamReader& jsonReader, PackageSpec packageSpec);
    private static List`1<CompatibilityProfile> ReadSupports(Utf8JsonStreamReader& jsonReader);
    private static LibraryDependencyTarget ReadTarget(Utf8JsonStreamReader& jsonReader, string packageSpecPath, LibraryDependencyTarget targetFlagsValue);
    private static List`1<ProjectRestoreMetadataFrameworkInfo> ReadTargetFrameworks(Utf8JsonStreamReader& jsonReader);
    private static void ReadTargetFrameworks(PackageSpec packageSpec, Utf8JsonStreamReader& jsonReader);
    private static HashSet`1<string> ReadSuppressedAdvisories(Utf8JsonStreamReader& jsonReader);
}
[ExtensionAttribute]
internal static class NuGet.ProjectModel.JsonTextReaderExtensions : object {
    private static Char[] DelimitedStringDelimiters;
    private static JsonTextReaderExtensions();
    [ExtensionAttribute]
internal static IReadOnlyList`1<string> ReadDelimitedString(JsonTextReader reader);
    [ExtensionAttribute]
internal static bool ReadNextToken(JsonTextReader reader);
    [ExtensionAttribute]
internal static string ReadNextTokenAsString(JsonTextReader reader);
    [ExtensionAttribute]
internal static bool ReadObject(JsonTextReader reader, Action`1<string> onProperty);
    [ExtensionAttribute]
internal static bool ReadObject(JsonTextReader reader, Action`1<string> onProperty, Int32& startObjectLine, Int32& startObjectColumn);
    [ExtensionAttribute]
internal static void ReadProperties(JsonTextReader reader, Action`1<string> onProperty);
    [ExtensionAttribute]
internal static List`1<string> ReadStringArrayAsList(JsonTextReader reader);
    [ExtensionAttribute]
internal static IReadOnlyList`1<string> ReadStringOrArrayOfStringsAsReadOnlyList(JsonTextReader reader);
    [ExtensionAttribute]
internal static IReadOnlyList`1<string> ReadStringArrayAsReadOnlyListFromArrayStart(JsonTextReader reader);
    [ExtensionAttribute]
private static string ReadTokenAsString(JsonTextReader reader);
}
internal static class NuGet.ProjectModel.JsonUtility : object {
    internal static string NUGET_EXPERIMENTAL_USE_NJ_FOR_FILE_PARSING;
    internal static Nullable`1<bool> UseNewtonsoftJson;
    internal static Char[] PathSplitChars;
    internal static JsonLoadSettings DefaultLoadSettings;
    private static JsonUtility();
    internal static JObject LoadJson(TextReader reader);
    internal static T LoadJson(Stream stream, IUtf8JsonStreamReaderConverter`1<T> converter);
    internal static PackageDependency ReadPackageDependency(string property, JToken json);
    internal static bool UseNewtonsoftJsonForParsing(IEnvironmentVariableReader environmentVariableReader, bool bypassCache);
    internal static JProperty WritePackageDependencyWithLegacyString(PackageDependency item);
    internal static void WritePackageDependencyWithLegacyString(JsonWriter writer, PackageDependency item);
    internal static JProperty WritePackageDependency(PackageDependency item);
    internal static void WritePackageDependency(JsonWriter writer, PackageDependency item);
    internal static TItem ReadProperty(JObject jObject, string propertyName);
    internal static IList`1<TItem> ReadObject(JObject jObject, Func`3<string, JToken, TItem> readItem);
    internal static JObject WriteObject(IEnumerable`1<TItem> items, Func`2<TItem, JProperty> writeItem);
    internal static void WriteObject(JsonWriter writer, IEnumerable`1<TItem> items, Action`2<JsonWriter, TItem> writeItem);
    internal static int ReadInt(JToken cursor, string property, int defaultValue);
    internal static JToken WriteString(string item);
}
[ExtensionAttribute]
public static class NuGet.ProjectModel.JTokenExtensions : object {
    [ExtensionAttribute]
public static T[] ValueAsArray(JToken jToken);
    [ExtensionAttribute]
public static T[] ValueAsArray(JToken jToken, string name);
    [ExtensionAttribute]
public static T GetValue(JToken token, string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class NuGet.ProjectModel.LazyStringSplit : ValueType {
    private string _input;
    private char _delimiter;
    public LazyStringSplit(string input, char delimiter);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<string> System.Collections.Generic.IEnumerable<System.String>.GetEnumerator();
    [IteratorStateMachineAttribute("NuGet.ProjectModel.LazyStringSplit/<Select>d__6`1")]
public IEnumerable`1<T> Select(Func`2<string, T> func);
    public string First();
    [NullableContextAttribute("2")]
public string FirstOrDefault();
}
[ExtensionAttribute]
internal static class NuGet.ProjectModel.LazyStringSplitExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static string FirstOrDefault(LazyStringSplit lazyStringSplit);
}
public class NuGet.ProjectModel.LockFile : object {
    public static NuGetFramework ToolFramework;
    public static char DirectorySeparatorChar;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ProjectFileDependencyGroup> <ProjectFileDependencyGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileLibrary> <Libraries>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileTarget> <Targets>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileItem> <PackageFolders>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IAssetsLogMessage> <LogMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSpec <PackageSpec>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<CentralTransitiveDependencyGroup> <CentralTransitiveDependencyGroups>k__BackingField;
    public int Version { get; public set; }
    public string Path { get; public set; }
    public IList`1<ProjectFileDependencyGroup> ProjectFileDependencyGroups { get; public set; }
    public IList`1<LockFileLibrary> Libraries { get; public set; }
    public IList`1<LockFileTarget> Targets { get; public set; }
    public IList`1<LockFileItem> PackageFolders { get; public set; }
    public IList`1<IAssetsLogMessage> LogMessages { get; public set; }
    public PackageSpec PackageSpec { get; public set; }
    public IList`1<CentralTransitiveDependencyGroup> CentralTransitiveDependencyGroups { get; public set; }
    private static LockFile();
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public IList`1<ProjectFileDependencyGroup> get_ProjectFileDependencyGroups();
    [CompilerGeneratedAttribute]
public void set_ProjectFileDependencyGroups(IList`1<ProjectFileDependencyGroup> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileLibrary> get_Libraries();
    [CompilerGeneratedAttribute]
public void set_Libraries(IList`1<LockFileLibrary> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileTarget> get_Targets();
    [CompilerGeneratedAttribute]
public void set_Targets(IList`1<LockFileTarget> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileItem> get_PackageFolders();
    [CompilerGeneratedAttribute]
public void set_PackageFolders(IList`1<LockFileItem> value);
    [CompilerGeneratedAttribute]
public IList`1<IAssetsLogMessage> get_LogMessages();
    [CompilerGeneratedAttribute]
public void set_LogMessages(IList`1<IAssetsLogMessage> value);
    [CompilerGeneratedAttribute]
public PackageSpec get_PackageSpec();
    [CompilerGeneratedAttribute]
public void set_PackageSpec(PackageSpec value);
    [CompilerGeneratedAttribute]
public IList`1<CentralTransitiveDependencyGroup> get_CentralTransitiveDependencyGroups();
    [CompilerGeneratedAttribute]
public void set_CentralTransitiveDependencyGroups(IList`1<CentralTransitiveDependencyGroup> value);
    public bool IsValidForPackageSpec(PackageSpec spec);
    public bool IsValidForPackageSpec(PackageSpec spec, int requestLockFileVersion);
    private bool ValidateDependencies(PackageSpec spec);
    public LockFileTarget GetTarget(NuGetFramework framework, string runtimeIdentifier);
    public LockFileTarget GetTarget(string frameworkAlias, string runtimeIdentifier);
    public LockFileLibrary GetLibrary(string name, NuGetVersion version);
    public sealed virtual bool Equals(LockFile other);
    private bool LogsEqual(IList`1<IAssetsLogMessage> otherLogMessages);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NuGet.ProjectModel.LockFileContentFile : LockFileItem {
    public static string BuildActionProperty;
    public static string CodeLanguageProperty;
    public static string PPOutputPathProperty;
    public static string OutputPathProperty;
    public static string CopyToOutputProperty;
    public string OutputPath { get; public set; }
    public string PPOutputPath { get; public set; }
    public BuildAction BuildAction { get; public set; }
    public string CodeLanguage { get; public set; }
    public bool CopyToOutput { get; public set; }
    public LockFileContentFile(string path);
    private static LockFileContentFile();
    public string get_OutputPath();
    public void set_OutputPath(string value);
    public string get_PPOutputPath();
    public void set_PPOutputPath(string value);
    public BuildAction get_BuildAction();
    public void set_BuildAction(BuildAction value);
    public string get_CodeLanguage();
    public void set_CodeLanguage(string value);
    public bool get_CopyToOutput();
    public void set_CopyToOutput(bool value);
}
public class NuGet.ProjectModel.LockFileDependency : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <ResolvedVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <RequestedVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageDependencyType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PackageDependency> <Dependencies>k__BackingField;
    public string Id { get; public set; }
    public NuGetVersion ResolvedVersion { get; public set; }
    public VersionRange RequestedVersion { get; public set; }
    public string ContentHash { get; public set; }
    public PackageDependencyType Type { get; public set; }
    public IList`1<PackageDependency> Dependencies { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public NuGetVersion get_ResolvedVersion();
    [CompilerGeneratedAttribute]
public void set_ResolvedVersion(NuGetVersion value);
    [CompilerGeneratedAttribute]
public VersionRange get_RequestedVersion();
    [CompilerGeneratedAttribute]
public void set_RequestedVersion(VersionRange value);
    [CompilerGeneratedAttribute]
public string get_ContentHash();
    [CompilerGeneratedAttribute]
public void set_ContentHash(string value);
    [CompilerGeneratedAttribute]
public PackageDependencyType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(PackageDependencyType value);
    [CompilerGeneratedAttribute]
public IList`1<PackageDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(IList`1<PackageDependency> value);
    public sealed virtual bool Equals(LockFileDependency other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NuGet.ProjectModel.LockFileDependencyIdVersionComparer : object {
    [CompilerGeneratedAttribute]
private static LockFileDependencyIdVersionComparer <Default>k__BackingField;
    public static LockFileDependencyIdVersionComparer Default { get; }
    private static LockFileDependencyIdVersionComparer();
    [CompilerGeneratedAttribute]
public static LockFileDependencyIdVersionComparer get_Default();
    public sealed virtual bool Equals(LockFileDependency x, LockFileDependency y);
    public sealed virtual int GetHashCode(LockFileDependency obj);
}
[ObsoleteAttribute("This is an unused class and will be removed in a future version.")]
public class NuGet.ProjectModel.LockFileDependencyProvider : object {
    private IDictionary`2<Tuple`2<NuGetFramework, string>, LockFileTargetLibrary> _targetLibraries;
    private IDictionary`2<Tuple`2<string, NuGetVersion>, LockFileLibrary> _libraries;
    public LockFileDependencyProvider(LockFile lockFile);
    public sealed virtual bool SupportsType(LibraryDependencyTarget libraryType);
    public sealed virtual Library GetLibrary(LibraryRange libraryRange, NuGetFramework targetFramework);
    private IList`1<LibraryDependency> GetDependencies(LockFileTargetLibrary library);
}
[ExtensionAttribute]
public static class NuGet.ProjectModel.LockFileExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<LockFileTarget> GetTargetGraphs(IAssetsLogMessage message, LockFile assetsFile);
    [ExtensionAttribute]
public static IEnumerable`1<LockFileTargetLibrary> GetTargetLibraries(IAssetsLogMessage message, LockFile assetsFile);
    [ExtensionAttribute]
public static LockFileTargetLibrary GetTargetLibrary(LockFileTarget target, string libraryId);
}
public class NuGet.ProjectModel.LockFileFormat : object {
    public static int Version;
    public static string LockFileName;
    public static string AssetsFileName;
    private static string VersionProperty;
    private static string LibrariesProperty;
    private static string TargetsProperty;
    private static string ProjectFileDependencyGroupsProperty;
    private static string ServicableProperty;
    private static string Sha512Property;
    private static string FilesProperty;
    private static string HasToolsProperty;
    private static string DependenciesProperty;
    private static string FrameworkAssembliesProperty;
    private static string RuntimeProperty;
    private static string CompileProperty;
    private static string NativeProperty;
    private static string BuildProperty;
    private static string BuildMultiTargetingProperty;
    private static string ContentFilesProperty;
    private static string RuntimeTargetsProperty;
    private static string ResourceProperty;
    private static string TypeProperty;
    private static string PathProperty;
    private static string MSBuildProjectProperty;
    private static string FrameworkProperty;
    private static string ToolsProperty;
    private static string PackageFoldersProperty;
    private static string PackageSpecProperty;
    internal static string LogsProperty;
    private static string EmbedProperty;
    private static string FrameworkReferencesProperty;
    private static string CentralTransitiveDependencyGroupsProperty;
    private static LockFileFormat();
    public LockFile Parse(string lockFileContent, string path);
    public LockFile Parse(string lockFileContent, ILogger log, string path);
    public LockFile Read(string filePath);
    public LockFile Read(string filePath, ILogger log);
    public LockFile Read(Stream stream, string path);
    public LockFile Read(Stream stream, ILogger log, string path);
    internal LockFile Read(Stream stream, ILogger log, string path, IEnvironmentVariableReader environmentVariableReader, bool bypassCache);
    [ObsoleteAttribute("This method is deprecated. Use Read(Stream, string) instead.")]
public LockFile Read(TextReader reader, string path);
    [ObsoleteAttribute("This method is deprecated. Use Read(Stream, ILogger, string) instead.")]
public LockFile Read(TextReader reader, ILogger log, string path);
    public void Write(string filePath, LockFile lockFile);
    public void Write(Stream stream, LockFile lockFile);
    public void Write(TextWriter textWriter, LockFile lockFile);
    public string Render(LockFile lockFile);
    private LockFile Utf8JsonRead(Stream stream, ILogger log, string path);
    [ObsoleteAttribute]
private static LockFile ReadLockFile(JObject cursor, string path);
    private static void WriteLockFile(JsonWriter writer, IObjectWriter jsonObjectWriter, LockFile lockFile);
    private static LockFileLibrary ReadLibrary(string property, JToken json);
    private static void WriteLibrary(JsonWriter writer, LockFileLibrary library);
    private static void WriteTarget(JsonWriter writer, LockFileTarget target);
    private static LockFileTarget ReadTarget(string property, JToken json);
    private static void WriteLogMessage(JsonWriter writer, IAssetsLogMessage logMessage, string projectPath);
    private static IAssetsLogMessage ReadLogMessage(JObject json, string projectPath);
    internal static JArray WriteLogMessages(IEnumerable`1<IAssetsLogMessage> logMessages, string projectPath);
    internal static void WriteLogMessages(JsonWriter writer, IEnumerable`1<IAssetsLogMessage> logMessages, string projectPath);
    private static LockFileTargetLibrary ReadTargetLibrary(string property, JToken json);
    private static void WriteTargetLibrary(JsonWriter writer, LockFileTargetLibrary library);
    private static LockFileRuntimeTarget ReadRuntimeTarget(string property, JToken json);
    private static LockFileContentFile ReadContentFile(string property, JToken json);
    private static ProjectFileDependencyGroup ReadProjectFileDependencyGroup(string property, JToken json);
    private static PackageSpec ReadPackageSpec(JObject json);
    private static void WriteProjectFileDependencyGroup(JsonWriter writer, ProjectFileDependencyGroup frameworkInfo);
    private static LockFileItem ReadFileItem(string property, JToken json);
    private static T ReadFileItem(string property, JToken json, Func`2<string, T> factory);
    private static void WriteFileItem(JsonWriter writer, LockFileItem item);
    private static IList`1<TItem> ReadArray(JArray json, Func`2<JToken, TItem> readItem);
    internal static IList`1<IAssetsLogMessage> ReadLogMessageArray(JArray json, string projectPath);
    private static IList`1<string> ReadPathArray(JArray json);
    private static void WritePathArray(JsonWriter writer, string property, IEnumerable`1<string> items);
    internal static void WriteArray(JsonWriter writer, IEnumerable`1<string> values);
    private static bool ReadBool(JToken cursor, string property, bool defaultValue);
    private static string ReadString(JToken json);
    private static SemanticVersion ReadSemanticVersion(JToken json, string property);
    private static string GetPathWithForwardSlashes(string path);
    private static string GetPathWithBackSlashes(string path);
    private static void WriteCentralTransitiveDependencyGroup(IObjectWriter writer, IList`1<CentralTransitiveDependencyGroup> centralTransitiveDependencyGroups);
    [ObsoleteAttribute]
private static List`1<CentralTransitiveDependencyGroup> ReadProjectFileTransitiveDependencyGroup(JObject json, string path);
}
public class NuGet.ProjectModel.LockFileItem : object {
    public static string AliasesProperty;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Properties>k__BackingField;
    public string Path { get; }
    public IDictionary`2<string, string> Properties { get; }
    public LockFileItem(string path);
    private static LockFileItem();
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Properties();
    public virtual string ToString();
    public sealed virtual bool Equals(LockFileItem other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static LockFileItem op_Implicit(string path);
    protected string GetProperty(string name);
    protected void SetProperty(string name, string value);
}
public class NuGet.ProjectModel.LockFileLibrary : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsServiceable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sha512>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildProject>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasTools>k__BackingField;
    public string Name { get; public set; }
    public string Type { get; public set; }
    public NuGetVersion Version { get; public set; }
    public bool IsServiceable { get; public set; }
    public string Sha512 { get; public set; }
    public IList`1<string> Files { get; public set; }
    public string Path { get; public set; }
    public string MSBuildProject { get; public set; }
    public bool HasTools { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public bool get_IsServiceable();
    [CompilerGeneratedAttribute]
public void set_IsServiceable(bool value);
    [CompilerGeneratedAttribute]
public string get_Sha512();
    [CompilerGeneratedAttribute]
public void set_Sha512(string value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(IList`1<string> value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_MSBuildProject();
    [CompilerGeneratedAttribute]
public void set_MSBuildProject(string value);
    [CompilerGeneratedAttribute]
public bool get_HasTools();
    [CompilerGeneratedAttribute]
public void set_HasTools(bool value);
    public sealed virtual bool Equals(LockFileLibrary other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public LockFileLibrary Clone();
}
public class NuGet.ProjectModel.LockFileRuntimeTarget : LockFileItem {
    public static string RidProperty;
    public static string AssetTypeProperty;
    public string Runtime { get; public set; }
    public string AssetType { get; public set; }
    public LockFileRuntimeTarget(string path);
    public LockFileRuntimeTarget(string path, string runtime, string assetType);
    private static LockFileRuntimeTarget();
    public string get_Runtime();
    public void set_Runtime(string value);
    public string get_AssetType();
    public void set_AssetType(string value);
}
public class NuGet.ProjectModel.LockFileTarget : object {
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileTargetLibrary> <Libraries>k__BackingField;
    public NuGetFramework TargetFramework { get; public set; }
    public string RuntimeIdentifier { get; public set; }
    public string Name { get; }
    public IList`1<LockFileTargetLibrary> Libraries { get; public set; }
    [CompilerGeneratedAttribute]
public NuGetFramework get_TargetFramework();
    [CompilerGeneratedAttribute]
public void set_TargetFramework(NuGetFramework value);
    [CompilerGeneratedAttribute]
public string get_RuntimeIdentifier();
    [CompilerGeneratedAttribute]
public void set_RuntimeIdentifier(string value);
    public string get_Name();
    [CompilerGeneratedAttribute]
public IList`1<LockFileTargetLibrary> get_Libraries();
    [CompilerGeneratedAttribute]
public void set_Libraries(IList`1<LockFileTargetLibrary> value);
    public sealed virtual bool Equals(LockFileTarget other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.ProjectModel.LockFileTargetLibrary : object {
    private static PropertyKey DependenciesKey;
    private static PropertyKey FrameworkAssembliesKey;
    private static PropertyKey FrameworkReferencesKey;
    private static PropertyKey RuntimeAssembliesKey;
    private static PropertyKey ResourceAssembliesKey;
    private static PropertyKey CompileTimeAssembliesKey;
    private static PropertyKey NativeLibrariesKey;
    private static PropertyKey BuildKey;
    private static PropertyKey BuildMultiTargetingKey;
    private static PropertyKey ContentFilesKey;
    private static PropertyKey RuntimeTargetsKey;
    private static PropertyKey ToolsAssembliesKey;
    private static PropertyKey EmbedAssembliesKey;
    private static PropertyKey PackageTypeKey;
    private Dictionary`2<PropertyKey, object> _propertyValues;
    private bool _isFrozen;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Framework>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [NullableAttribute("2")]
public string Name { get; public set; }
    [NullableAttribute("2")]
public string Framework { get; public set; }
    [NullableAttribute("2")]
public NuGetVersion Version { get; public set; }
    [NullableAttribute("2")]
public string Type { get; public set; }
    public IList`1<PackageDependency> Dependencies { get; public set; }
    public IList`1<string> FrameworkAssemblies { get; public set; }
    public IList`1<string> FrameworkReferences { get; public set; }
    public IList`1<LockFileItem> RuntimeAssemblies { get; public set; }
    public IList`1<LockFileItem> ResourceAssemblies { get; public set; }
    public IList`1<LockFileItem> CompileTimeAssemblies { get; public set; }
    public IList`1<LockFileItem> NativeLibraries { get; public set; }
    public IList`1<LockFileItem> Build { get; public set; }
    public IList`1<LockFileItem> BuildMultiTargeting { get; public set; }
    public IList`1<LockFileContentFile> ContentFiles { get; public set; }
    public IList`1<LockFileRuntimeTarget> RuntimeTargets { get; public set; }
    public IList`1<LockFileItem> ToolsAssemblies { get; public set; }
    public IList`1<LockFileItem> EmbedAssemblies { get; public set; }
    public IList`1<PackageType> PackageType { get; public set; }
    private static LockFileTargetLibrary();
    private IList`1<T> GetListProperty(PropertyKey key);
    private void SetListProperty(PropertyKey key, IList`1<T> list);
    public void Freeze();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Name(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Framework();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Framework(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Type();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Type(string value);
    public IList`1<PackageDependency> get_Dependencies();
    public void set_Dependencies(IList`1<PackageDependency> value);
    public IList`1<string> get_FrameworkAssemblies();
    public void set_FrameworkAssemblies(IList`1<string> value);
    public IList`1<string> get_FrameworkReferences();
    public void set_FrameworkReferences(IList`1<string> value);
    public IList`1<LockFileItem> get_RuntimeAssemblies();
    public void set_RuntimeAssemblies(IList`1<LockFileItem> value);
    public IList`1<LockFileItem> get_ResourceAssemblies();
    public void set_ResourceAssemblies(IList`1<LockFileItem> value);
    public IList`1<LockFileItem> get_CompileTimeAssemblies();
    public void set_CompileTimeAssemblies(IList`1<LockFileItem> value);
    public IList`1<LockFileItem> get_NativeLibraries();
    public void set_NativeLibraries(IList`1<LockFileItem> value);
    public IList`1<LockFileItem> get_Build();
    public void set_Build(IList`1<LockFileItem> value);
    public IList`1<LockFileItem> get_BuildMultiTargeting();
    public void set_BuildMultiTargeting(IList`1<LockFileItem> value);
    public IList`1<LockFileContentFile> get_ContentFiles();
    public void set_ContentFiles(IList`1<LockFileContentFile> value);
    public IList`1<LockFileRuntimeTarget> get_RuntimeTargets();
    public void set_RuntimeTargets(IList`1<LockFileRuntimeTarget> value);
    public IList`1<LockFileItem> get_ToolsAssemblies();
    public void set_ToolsAssemblies(IList`1<LockFileItem> value);
    public IList`1<LockFileItem> get_EmbedAssemblies();
    public void set_EmbedAssemblies(IList`1<LockFileItem> value);
    public IList`1<PackageType> get_PackageType();
    public void set_PackageType(IList`1<PackageType> value);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(LockFileTargetLibrary other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
private bool <Equals>g__IsListOrderedEqual|78_13(PropertyKey key, Func`2<T, string> accessor, IEqualityComparer`1<T> sequenceComparer, <>c__DisplayClass78_0& );
}
public static class NuGet.ProjectModel.LockFileUtilities : object {
    public static LockFile GetLockFile(string lockFilePath, ILogger logger);
}
public class NuGet.ProjectModel.LockFileValidationResult : object {
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <InvalidReasons>k__BackingField;
    public bool IsValid { get; }
    public IReadOnlyList`1<string> InvalidReasons { get; }
    public LockFileValidationResult(bool isValid, IReadOnlyList`1<string> invalidReasons);
    [CompilerGeneratedAttribute]
public bool get_IsValid();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_InvalidReasons();
}
internal static class NuGet.ProjectModel.MacroStringsUtility : object {
    internal static string NUGET_ENABLE_EXPERIMENTAL_MACROS;
    internal static string UserMacro;
    internal static void ApplyMacros(IList`1<string> list, string macroValue, string macroName, StringComparison stringComparison);
    internal static void ExtractMacros(List`1<string> list, string macroValue, string macroName);
    internal static string ApplyMacro(string originalString, string macroValue, string macroName, StringComparison stringComparison);
    internal static string ExtractMacro(string originalString, string macroValue, string macroName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.ProjectModel.NoAllocNewLineStreamWriter : StreamWriter {
    private string _newLine;
    public string NewLine { get; public set; }
    public NoAllocNewLineStreamWriter(Stream stream, Encoding encoding, int bufferSize, bool leaveOpen);
    public NoAllocNewLineStreamWriter(Stream stream);
    public virtual string get_NewLine();
    public virtual void set_NewLine(string value);
}
public enum NuGet.ProjectModel.PackageDependencyType : Enum {
    public int value__;
    public static PackageDependencyType Direct;
    public static PackageDependencyType Transitive;
    public static PackageDependencyType Project;
    public static PackageDependencyType CentralTransitive;
}
public class NuGet.ProjectModel.PackagesConfigProjectRestoreMetadata : ProjectRestoreMetadata {
    [CompilerGeneratedAttribute]
private string <PackagesConfigPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RepositoryPath>k__BackingField;
    public string PackagesConfigPath { get; public set; }
    public string RepositoryPath { get; public set; }
    [CompilerGeneratedAttribute]
public string get_PackagesConfigPath();
    [CompilerGeneratedAttribute]
public void set_PackagesConfigPath(string value);
    [CompilerGeneratedAttribute]
public string get_RepositoryPath();
    [CompilerGeneratedAttribute]
public void set_RepositoryPath(string value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(PackagesConfigProjectRestoreMetadata obj);
    public virtual ProjectRestoreMetadata Clone();
}
public class NuGet.ProjectModel.PackagesLockFile : object {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PackagesLockFileTarget> <Targets>k__BackingField;
    public int Version { get; public set; }
    public string Path { get; public set; }
    public IList`1<PackagesLockFileTarget> Targets { get; public set; }
    public PackagesLockFile(int version);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public IList`1<PackagesLockFileTarget> get_Targets();
    [CompilerGeneratedAttribute]
public void set_Targets(IList`1<PackagesLockFileTarget> value);
    public sealed virtual bool Equals(PackagesLockFile other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class NuGet.ProjectModel.PackagesLockFileFormat : object {
    public static int Version;
    public static int PackagesLockFileVersion;
    public static string LockFileName;
    private static string VersionProperty;
    private static string ResolvedProperty;
    private static string RequestedProperty;
    private static string ContentHashProperty;
    private static string DependenciesProperty;
    private static string TypeProperty;
    private static PackagesLockFileFormat();
    public static PackagesLockFile Parse(string lockFileContent, string path);
    public static PackagesLockFile Parse(string lockFileContent, ILogger log, string path);
    public static PackagesLockFile Read(string filePath);
    public static PackagesLockFile Read(string filePath, ILogger log);
    public static PackagesLockFile Read(Stream stream, ILogger log, string path);
    public static PackagesLockFile Read(TextReader reader, ILogger log, string path);
    private static PackagesLockFile ReadLockFile(JObject cursor);
    public static string Render(PackagesLockFile lockFile);
    public static void Write(string filePath, PackagesLockFile lockFile);
    public static void Write(Stream stream, PackagesLockFile lockFile);
    public static void Write(TextWriter textWriter, PackagesLockFile lockFile);
    private static JObject WriteLockFile(PackagesLockFile lockFile);
    private static PackagesLockFileTarget ReadDependency(string property, JToken json);
    private static LockFileDependency ReadTargetDependency(string property, JToken json);
    private static JProperty WriteTarget(PackagesLockFileTarget target);
    private static JProperty WriteTargetDependency(LockFileDependency dependency);
}
public class NuGet.ProjectModel.PackagesLockFileTarget : object {
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileDependency> <Dependencies>k__BackingField;
    public NuGetFramework TargetFramework { get; public set; }
    public string RuntimeIdentifier { get; public set; }
    public IList`1<LockFileDependency> Dependencies { get; public set; }
    public string Name { get; }
    [CompilerGeneratedAttribute]
public NuGetFramework get_TargetFramework();
    [CompilerGeneratedAttribute]
public void set_TargetFramework(NuGetFramework value);
    [CompilerGeneratedAttribute]
public string get_RuntimeIdentifier();
    [CompilerGeneratedAttribute]
public void set_RuntimeIdentifier(string value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(IList`1<LockFileDependency> value);
    public string get_Name();
    public sealed virtual bool Equals(PackagesLockFileTarget other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static string GetNameString(NuGetFramework framework, string runtime);
}
public static class NuGet.ProjectModel.PackagesLockFileUtilities : object {
    public static bool IsNuGetLockFileEnabled(PackageSpec project);
    public static string GetNuGetLockFilePath(PackageSpec project);
    public static string GetNuGetLockFilePath(string baseDirectory, string projectName);
    [ObsoleteAttribute("This method is obsolete. Call IsLockFileValid instead.")]
public static bool IsLockFileStillValid(DependencyGraphSpec dgSpec, PackagesLockFile nuGetLockFile);
    public static LockFileValidationResult IsLockFileValid(DependencyGraphSpec dgSpec, PackagesLockFile nuGetLockFile);
    public static LockFileValidityWithMatchedResults IsLockFileStillValid(PackagesLockFile expected, PackagesLockFile actual);
    private static ValueTuple`2<bool, string> HasDirectPackageDependencyChanged(IEnumerable`1<LibraryDependency> newDependencies, IEnumerable`1<LockFileDependency> lockFileDependencies, NuGetFramework nuGetFramework);
    private static ValueTuple`2<bool, string> HasP2PDependencyChanged(IEnumerable`1<LibraryDependency> newDependencies, IEnumerable`1<ProjectRestoreReference> projectRestoreReferences, LockFileDependency projectDependency, DependencyGraphSpec dgSpec);
    private static ValueTuple`2<bool, string> HasProjectTransitiveDependencyChanged(IDictionary`2<string, CentralPackageVersion> centralPackageVersions, IList`1<LockFileDependency> lockFileCentralTransitiveDependencies, IList`1<LockFileDependency> lockTransitiveDependencies);
}
[DebuggerDisplayAttribute("{Name}")]
public class NuGet.ProjectModel.PackageSpec : object {
    public static string PackageSpecFileName;
    public static NuGetVersion DefaultVersion;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    private NuGetVersion _version;
    [CompilerGeneratedAttribute]
private bool <IsDefaultVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasVersionSnapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReleaseNotes>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Authors>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IconUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LicenseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildOptions <BuildOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <ContentFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IEnumerable`1<string>> <Scripts>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <PackInclude>k__BackingField;
    [CompilerGeneratedAttribute]
private PackOptions <PackOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LibraryDependency> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<TargetFrameworkInformation> <TargetFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeGraph <RuntimeGraph>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectRestoreSettings <RestoreSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectRestoreMetadata <RestoreMetadata>k__BackingField;
    public string FilePath { get; public set; }
    public string BaseDirectory { get; }
    public string Name { get; public set; }
    public string Title { get; public set; }
    public NuGetVersion Version { get; public set; }
    [ObsoleteAttribute]
public bool IsDefaultVersion { get; public set; }
    [ObsoleteAttribute]
public bool HasVersionSnapshot { get; public set; }
    [ObsoleteAttribute]
public string Description { get; public set; }
    [ObsoleteAttribute]
public string Summary { get; public set; }
    [ObsoleteAttribute]
public string ReleaseNotes { get; public set; }
    [ObsoleteAttribute]
public String[] Authors { get; public set; }
    [ObsoleteAttribute]
public String[] Owners { get; public set; }
    [ObsoleteAttribute]
public string ProjectUrl { get; public set; }
    [ObsoleteAttribute]
public string IconUrl { get; public set; }
    [ObsoleteAttribute]
public string LicenseUrl { get; public set; }
    [ObsoleteAttribute]
public bool RequireLicenseAcceptance { get; public set; }
    [ObsoleteAttribute]
public string Copyright { get; public set; }
    [ObsoleteAttribute]
public string Language { get; public set; }
    [ObsoleteAttribute]
public BuildOptions BuildOptions { get; public set; }
    [ObsoleteAttribute]
public String[] Tags { get; public set; }
    [ObsoleteAttribute]
public IList`1<string> ContentFiles { get; public set; }
    [ObsoleteAttribute]
public IDictionary`2<string, IEnumerable`1<string>> Scripts { get; private set; }
    [ObsoleteAttribute]
public IDictionary`2<string, string> PackInclude { get; private set; }
    [ObsoleteAttribute]
public PackOptions PackOptions { get; public set; }
    public IList`1<LibraryDependency> Dependencies { get; public set; }
    public IList`1<TargetFrameworkInformation> TargetFrameworks { get; private set; }
    public RuntimeGraph RuntimeGraph { get; public set; }
    public ProjectRestoreSettings RestoreSettings { get; public set; }
    public ProjectRestoreMetadata RestoreMetadata { get; public set; }
    public PackageSpec(IList`1<TargetFrameworkInformation> frameworks);
    internal PackageSpec(IList`1<TargetFrameworkInformation> frameworks, IList`1<LibraryDependency> dependencies, RuntimeGraph runtimeGraph, ProjectRestoreSettings restoreSettings, String[] authors, String[] owners, String[] tags, IList`1<string> contentFiles, IDictionary`2<string, IEnumerable`1<string>> scripts, IDictionary`2<string, string> packInclude, PackOptions packOptions);
    private static PackageSpec();
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    public string get_BaseDirectory();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    public NuGetVersion get_Version();
    public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public bool get_IsDefaultVersion();
    [CompilerGeneratedAttribute]
public void set_IsDefaultVersion(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasVersionSnapshot();
    [CompilerGeneratedAttribute]
public void set_HasVersionSnapshot(bool value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(string value);
    [CompilerGeneratedAttribute]
public string get_ReleaseNotes();
    [CompilerGeneratedAttribute]
public void set_ReleaseNotes(string value);
    [CompilerGeneratedAttribute]
public String[] get_Authors();
    [CompilerGeneratedAttribute]
public void set_Authors(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_Owners();
    [CompilerGeneratedAttribute]
public void set_Owners(String[] value);
    [CompilerGeneratedAttribute]
public string get_ProjectUrl();
    [CompilerGeneratedAttribute]
public void set_ProjectUrl(string value);
    [CompilerGeneratedAttribute]
public string get_IconUrl();
    [CompilerGeneratedAttribute]
public void set_IconUrl(string value);
    [CompilerGeneratedAttribute]
public string get_LicenseUrl();
    [CompilerGeneratedAttribute]
public void set_LicenseUrl(string value);
    [CompilerGeneratedAttribute]
public bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_RequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public string get_Copyright();
    [CompilerGeneratedAttribute]
public void set_Copyright(string value);
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public BuildOptions get_BuildOptions();
    [CompilerGeneratedAttribute]
public void set_BuildOptions(BuildOptions value);
    [CompilerGeneratedAttribute]
public String[] get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(String[] value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_ContentFiles();
    [CompilerGeneratedAttribute]
public void set_ContentFiles(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, IEnumerable`1<string>> get_Scripts();
    [CompilerGeneratedAttribute]
private void set_Scripts(IDictionary`2<string, IEnumerable`1<string>> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_PackInclude();
    [CompilerGeneratedAttribute]
private void set_PackInclude(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public PackOptions get_PackOptions();
    [CompilerGeneratedAttribute]
public void set_PackOptions(PackOptions value);
    [CompilerGeneratedAttribute]
public IList`1<LibraryDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(IList`1<LibraryDependency> value);
    [CompilerGeneratedAttribute]
public IList`1<TargetFrameworkInformation> get_TargetFrameworks();
    [CompilerGeneratedAttribute]
private void set_TargetFrameworks(IList`1<TargetFrameworkInformation> value);
    [CompilerGeneratedAttribute]
public RuntimeGraph get_RuntimeGraph();
    [CompilerGeneratedAttribute]
public void set_RuntimeGraph(RuntimeGraph value);
    [CompilerGeneratedAttribute]
public ProjectRestoreSettings get_RestoreSettings();
    [CompilerGeneratedAttribute]
public void set_RestoreSettings(ProjectRestoreSettings value);
    [CompilerGeneratedAttribute]
public ProjectRestoreMetadata get_RestoreMetadata();
    [CompilerGeneratedAttribute]
public void set_RestoreMetadata(ProjectRestoreMetadata value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(PackageSpec other);
    public PackageSpec Clone();
    private IDictionary`2<string, IEnumerable`1<string>> CloneScripts(IDictionary`2<string, IEnumerable`1<string>> toBeCloned);
}
[ExtensionAttribute]
public static class NuGet.ProjectModel.PackageSpecExtensions : object {
    [ExtensionAttribute]
public static TargetFrameworkInformation GetTargetFramework(PackageSpec project, NuGetFramework targetFramework);
    [ExtensionAttribute]
public static ProjectRestoreMetadataFrameworkInfo GetRestoreMetadataFramework(PackageSpec project, NuGetFramework targetFramework);
}
public static class NuGet.ProjectModel.PackageSpecOperations : object {
    public static void AddOrUpdateDependency(PackageSpec spec, PackageDependency dependency);
    public static void AddOrUpdateDependency(PackageSpec spec, PackageIdentity identity);
    public static bool HasPackage(PackageSpec spec, string packageId);
    public static void AddOrUpdateDependency(PackageSpec spec, PackageDependency dependency, IEnumerable`1<NuGetFramework> frameworksToAdd);
    public static void AddOrUpdateDependency(PackageSpec spec, PackageIdentity identity, IEnumerable`1<NuGetFramework> frameworksToAdd);
    public static void RemoveDependency(PackageSpec spec, string packageId);
    [IteratorStateMachineAttribute("NuGet.ProjectModel.PackageSpecOperations/<GetDependencyLists>d__6")]
private static IEnumerable`1<IList`1<LibraryDependency>> GetDependencyLists(PackageSpec spec, IEnumerable`1<NuGetFramework> frameworksToConsider, bool includeGenericDependencies);
    [IteratorStateMachineAttribute("NuGet.ProjectModel.PackageSpecOperations/<GetCentralPackageVersionLists>d__7")]
private static IEnumerable`1<IDictionary`2<string, CentralPackageVersion>> GetCentralPackageVersionLists(PackageSpec spec, IEnumerable`1<NuGetFramework> frameworksToConsider);
    private static List`1<LibraryDependency> GetExistingDependencies(PackageSpec spec, string packageId);
    private static void AddOrUpdateDependencyInDependencyList(PackageSpec spec, IList`1<LibraryDependency> list, string packageId, VersionRange range);
    private static void AddDependency(IList`1<LibraryDependency> list, string packageId, VersionRange range, bool centralPackageVersionsEnabled);
}
public class NuGet.ProjectModel.PackageSpecReferenceDependencyProvider : object {
    private Dictionary`2<string, ExternalProjectReference> _externalProjectsByPath;
    private Dictionary`2<string, ExternalProjectReference> _externalProjectsByUniqueName;
    private bool _useLegacyAssetTargetFallbackBehavior;
    public PackageSpecReferenceDependencyProvider(IEnumerable`1<ExternalProjectReference> externalProjects, ILogger logger);
    internal PackageSpecReferenceDependencyProvider(IEnumerable`1<ExternalProjectReference> externalProjects, IEnvironmentVariableReader environmentVariableReader);
    public sealed virtual bool SupportsType(LibraryDependencyTarget libraryType);
    public sealed virtual Library GetLibrary(LibraryRange libraryRange, NuGetFramework targetFramework);
    private void AddLibraryProperties(Library library, PackageSpec packageSpec, NuGetFramework targetFramework);
    private List`1<LibraryDependency> GetDependenciesFromSpecRestoreMetadata(PackageSpec packageSpec, NuGetFramework targetFramework);
    private List`1<LibraryDependency> GetDependenciesFromExternalReference(ExternalProjectReference externalReference, PackageSpec packageSpec, NuGetFramework targetFramework);
    internal List`1<LibraryDependency> GetSpecDependencies(PackageSpec packageSpec, NuGetFramework targetFramework);
    private bool IsProject(LibraryDependency dependency);
    private List`1<ExternalProjectReference> GetChildReferences(ExternalProjectReference parent);
}
public static class NuGet.ProjectModel.PackageSpecUtility : object {
    public static NuGetVersion SpecifySnapshot(string version, string snapshotValue);
    public static bool IsSnapshotVersion(string version);
}
public class NuGet.ProjectModel.PackageSpecWriter : object {
    public static void Write(PackageSpec packageSpec, IObjectWriter writer);
    internal static void Write(PackageSpec packageSpec, IObjectWriter writer, bool hashing, IEnvironmentVariableReader environmentVariableReader);
    public static void WriteToFile(PackageSpec packageSpec, string filePath);
    private static bool IsMetadataValid(ProjectRestoreMetadata msbuildMetadata);
    private static void SetMSBuildMetadata(IObjectWriter writer, PackageSpec packageSpec, IEnvironmentVariableReader environmentVariableReader);
    private static string ApplyMacro(string value, string userSettingsDirectory, bool useMacros);
    private static void WriteMetadataBooleans(IObjectWriter writer, ProjectRestoreMetadata msbuildMetadata);
    private static void WriteNuGetLockFileProperties(IObjectWriter writer, ProjectRestoreMetadata msbuildMetadata);
    private static void WriteNuGetAuditProperties(IObjectWriter writer, RestoreAuditProperties auditProperties);
    private static void WriteMetadataTargetFrameworks(IObjectWriter writer, ProjectRestoreMetadata msbuildMetadata);
    private static void WriteMetadataFiles(IObjectWriter writer, ProjectRestoreMetadata msbuildMetadata);
    private static void WriteMetadataSources(IObjectWriter writer, ProjectRestoreMetadata msbuildMetadata);
    private static void SetWarningProperties(IObjectWriter writer, ProjectRestoreMetadata msbuildMetadata);
    [ObsoleteAttribute]
private static void SetPackOptions(IObjectWriter writer, PackageSpec packageSpec);
    private static void SetDependencies(IObjectWriter writer, IList`1<LibraryDependency> libraryDependencies);
    internal static void SetDependencies(IObjectWriter writer, string name, IEnumerable`1<LibraryDependency> libraryDependencies);
    internal static void SetCentralTransitveDependencyGroup(IObjectWriter writer, string name, IEnumerable`1<LibraryDependency> libraryDependencies);
    private static void SetImports(IObjectWriter writer, IList`1<NuGetFramework> frameworks);
    private static void SetDownloadDependencies(IObjectWriter writer, IList`1<DownloadDependency> downloadDependencies);
    private static void SetFrameworks(IObjectWriter writer, IList`1<TargetFrameworkInformation> frameworks, bool hashing);
    private static NuGetFramework DeconstructFallbackFrameworks(NuGetFramework nuGetFramework);
    private static void SetFrameworkReferences(IObjectWriter writer, ISet`1<FrameworkDependency> frameworkReferences);
    private static void SetCentralDependencies(IObjectWriter writer, ICollection`1<CentralPackageVersion> centralPackageVersions, bool hashing);
    private static void SetValueIfTrue(IObjectWriter writer, string name, bool value);
    private static void SetValueIfNotNull(IObjectWriter writer, string name, string value);
    private static void SetValue(IObjectWriter writer, string name, string value);
    private static void SetArrayValue(IObjectWriter writer, string name, IEnumerable`1<string> values);
    private static void SetDictionaryValue(IObjectWriter writer, string name, IDictionary`2<string, string> values);
    private static void SetDictionaryValues(IObjectWriter writer, string name, IDictionary`2<string, IEnumerable`1<string>> values);
}
public class NuGet.ProjectModel.PackOptions : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PackageType> <PackageType>k__BackingField;
    [CompilerGeneratedAttribute]
private IncludeExcludeFiles <IncludeExcludeFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IncludeExcludeFiles> <Mappings>k__BackingField;
    public IReadOnlyList`1<PackageType> PackageType { get; public set; }
    public IncludeExcludeFiles IncludeExcludeFiles { get; public set; }
    public IDictionary`2<string, IncludeExcludeFiles> Mappings { get; public set; }
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PackageType> get_PackageType();
    [CompilerGeneratedAttribute]
public void set_PackageType(IReadOnlyList`1<PackageType> value);
    [CompilerGeneratedAttribute]
public IncludeExcludeFiles get_IncludeExcludeFiles();
    [CompilerGeneratedAttribute]
public void set_IncludeExcludeFiles(IncludeExcludeFiles value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, IncludeExcludeFiles> get_Mappings();
    [CompilerGeneratedAttribute]
public void set_Mappings(IDictionary`2<string, IncludeExcludeFiles> value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PackOptions other);
    public PackOptions Clone();
}
public class NuGet.ProjectModel.ProjectFileDependencyGroup : object {
    [CompilerGeneratedAttribute]
private string <FrameworkName>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Dependencies>k__BackingField;
    public string FrameworkName { get; }
    public IEnumerable`1<string> Dependencies { get; }
    public ProjectFileDependencyGroup(string frameworkName, IEnumerable`1<string> dependencies);
    [CompilerGeneratedAttribute]
public string get_FrameworkName();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Dependencies();
    public sealed virtual bool Equals(ProjectFileDependencyGroup other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NuGet.ProjectModel.ProjectLockFile.LockFileDependencyComparerWithoutContentHash : object {
    [CompilerGeneratedAttribute]
private static LockFileDependencyComparerWithoutContentHash <Default>k__BackingField;
    public static LockFileDependencyComparerWithoutContentHash Default { get; }
    private static LockFileDependencyComparerWithoutContentHash();
    [CompilerGeneratedAttribute]
public static LockFileDependencyComparerWithoutContentHash get_Default();
    public sealed virtual bool Equals(LockFileDependency x, LockFileDependency y);
    public sealed virtual int GetHashCode(LockFileDependency obj);
}
public class NuGet.ProjectModel.ProjectRestoreMetadata : object {
    [CompilerGeneratedAttribute]
private ProjectStyle <ProjectStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectJsonPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectUniqueName>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PackageSource> <Sources>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackagesPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <FallbackFolders>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <ConfigFilePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ProjectRestoreMetadataFrameworkInfo> <TargetFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <OriginalTargetFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CrossTargeting>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LegacyPackagesDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ProjectRestoreMetadataFile> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateRuntimeAssets>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipContentFileWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private WarningProperties <ProjectWideWarningProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private RestoreLockProperties <RestoreLockProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CentralPackageVersionsEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CentralPackageVersionOverrideDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CentralPackageFloatingVersionsEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CentralPackageTransitivePinningEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private RestoreAuditProperties <RestoreAuditProperties>k__BackingField;
    public ProjectStyle ProjectStyle { get; public set; }
    public string ProjectPath { get; public set; }
    public string ProjectJsonPath { get; public set; }
    public string OutputPath { get; public set; }
    public string ProjectName { get; public set; }
    public string ProjectUniqueName { get; public set; }
    public IList`1<PackageSource> Sources { get; public set; }
    public string PackagesPath { get; public set; }
    public string CacheFilePath { get; public set; }
    public IList`1<string> FallbackFolders { get; public set; }
    public IList`1<string> ConfigFilePaths { get; public set; }
    public IList`1<ProjectRestoreMetadataFrameworkInfo> TargetFrameworks { get; public set; }
    public IList`1<string> OriginalTargetFrameworks { get; public set; }
    public bool CrossTargeting { get; public set; }
    public bool LegacyPackagesDirectory { get; public set; }
    public IList`1<ProjectRestoreMetadataFile> Files { get; public set; }
    public bool ValidateRuntimeAssets { get; public set; }
    public bool SkipContentFileWrite { get; public set; }
    public WarningProperties ProjectWideWarningProperties { get; public set; }
    public RestoreLockProperties RestoreLockProperties { get; public set; }
    public bool CentralPackageVersionsEnabled { get; public set; }
    public bool CentralPackageVersionOverrideDisabled { get; public set; }
    public bool CentralPackageFloatingVersionsEnabled { get; public set; }
    public bool CentralPackageTransitivePinningEnabled { get; public set; }
    public RestoreAuditProperties RestoreAuditProperties { get; public set; }
    [CompilerGeneratedAttribute]
public ProjectStyle get_ProjectStyle();
    [CompilerGeneratedAttribute]
public void set_ProjectStyle(ProjectStyle value);
    [CompilerGeneratedAttribute]
public string get_ProjectPath();
    [CompilerGeneratedAttribute]
public void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectJsonPath();
    [CompilerGeneratedAttribute]
public void set_ProjectJsonPath(string value);
    [CompilerGeneratedAttribute]
public string get_OutputPath();
    [CompilerGeneratedAttribute]
public void set_OutputPath(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectName();
    [CompilerGeneratedAttribute]
public void set_ProjectName(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectUniqueName();
    [CompilerGeneratedAttribute]
public void set_ProjectUniqueName(string value);
    [CompilerGeneratedAttribute]
public IList`1<PackageSource> get_Sources();
    [CompilerGeneratedAttribute]
public void set_Sources(IList`1<PackageSource> value);
    [CompilerGeneratedAttribute]
public string get_PackagesPath();
    [CompilerGeneratedAttribute]
public void set_PackagesPath(string value);
    [CompilerGeneratedAttribute]
public string get_CacheFilePath();
    [CompilerGeneratedAttribute]
public void set_CacheFilePath(string value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_FallbackFolders();
    [CompilerGeneratedAttribute]
public void set_FallbackFolders(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_ConfigFilePaths();
    [CompilerGeneratedAttribute]
public void set_ConfigFilePaths(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IList`1<ProjectRestoreMetadataFrameworkInfo> get_TargetFrameworks();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworks(IList`1<ProjectRestoreMetadataFrameworkInfo> value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_OriginalTargetFrameworks();
    [CompilerGeneratedAttribute]
public void set_OriginalTargetFrameworks(IList`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_CrossTargeting();
    [CompilerGeneratedAttribute]
public void set_CrossTargeting(bool value);
    [CompilerGeneratedAttribute]
public bool get_LegacyPackagesDirectory();
    [CompilerGeneratedAttribute]
public void set_LegacyPackagesDirectory(bool value);
    [CompilerGeneratedAttribute]
public IList`1<ProjectRestoreMetadataFile> get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(IList`1<ProjectRestoreMetadataFile> value);
    [CompilerGeneratedAttribute]
public bool get_ValidateRuntimeAssets();
    [CompilerGeneratedAttribute]
public void set_ValidateRuntimeAssets(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipContentFileWrite();
    [CompilerGeneratedAttribute]
public void set_SkipContentFileWrite(bool value);
    [CompilerGeneratedAttribute]
public WarningProperties get_ProjectWideWarningProperties();
    [CompilerGeneratedAttribute]
public void set_ProjectWideWarningProperties(WarningProperties value);
    [CompilerGeneratedAttribute]
public RestoreLockProperties get_RestoreLockProperties();
    [CompilerGeneratedAttribute]
public void set_RestoreLockProperties(RestoreLockProperties value);
    [CompilerGeneratedAttribute]
public bool get_CentralPackageVersionsEnabled();
    [CompilerGeneratedAttribute]
public void set_CentralPackageVersionsEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_CentralPackageVersionOverrideDisabled();
    [CompilerGeneratedAttribute]
public void set_CentralPackageVersionOverrideDisabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_CentralPackageFloatingVersionsEnabled();
    [CompilerGeneratedAttribute]
public void set_CentralPackageFloatingVersionsEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_CentralPackageTransitivePinningEnabled();
    [CompilerGeneratedAttribute]
public void set_CentralPackageTransitivePinningEnabled(bool value);
    [CompilerGeneratedAttribute]
public RestoreAuditProperties get_RestoreAuditProperties();
    [CompilerGeneratedAttribute]
public void set_RestoreAuditProperties(RestoreAuditProperties value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ProjectRestoreMetadata other);
    private HashSet`1<string> GetSources(IList`1<PackageSource> sources);
    public virtual ProjectRestoreMetadata Clone();
    protected void FillClone(ProjectRestoreMetadata clone);
}
public class NuGet.ProjectModel.ProjectRestoreMetadataFile : object {
    [CompilerGeneratedAttribute]
private string <PackagePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AbsolutePath>k__BackingField;
    public string PackagePath { get; }
    public string AbsolutePath { get; }
    public ProjectRestoreMetadataFile(string packagePath, string absolutePath);
    [CompilerGeneratedAttribute]
public string get_PackagePath();
    [CompilerGeneratedAttribute]
public string get_AbsolutePath();
    public sealed virtual bool Equals(ProjectRestoreMetadataFile other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual int CompareTo(ProjectRestoreMetadataFile other);
    public ProjectRestoreMetadataFile Clone();
}
public class NuGet.ProjectModel.ProjectRestoreMetadataFrameworkInfo : object {
    [CompilerGeneratedAttribute]
private string <TargetAlias>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <FrameworkName>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ProjectRestoreReference> <ProjectReferences>k__BackingField;
    public string TargetAlias { get; public set; }
    public NuGetFramework FrameworkName { get; public set; }
    public IList`1<ProjectRestoreReference> ProjectReferences { get; public set; }
    public ProjectRestoreMetadataFrameworkInfo(NuGetFramework frameworkName);
    [CompilerGeneratedAttribute]
public string get_TargetAlias();
    [CompilerGeneratedAttribute]
public void set_TargetAlias(string value);
    [CompilerGeneratedAttribute]
public NuGetFramework get_FrameworkName();
    [CompilerGeneratedAttribute]
public void set_FrameworkName(NuGetFramework value);
    [CompilerGeneratedAttribute]
public IList`1<ProjectRestoreReference> get_ProjectReferences();
    [CompilerGeneratedAttribute]
public void set_ProjectReferences(IList`1<ProjectRestoreReference> value);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ProjectRestoreMetadataFrameworkInfo other);
    public ProjectRestoreMetadataFrameworkInfo Clone();
}
public class NuGet.ProjectModel.ProjectRestoreReference : object {
    [CompilerGeneratedAttribute]
private string <ProjectUniqueName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryIncludeFlags <IncludeAssets>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryIncludeFlags <ExcludeAssets>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryIncludeFlags <PrivateAssets>k__BackingField;
    public string ProjectUniqueName { get; public set; }
    public string ProjectPath { get; public set; }
    public LibraryIncludeFlags IncludeAssets { get; public set; }
    public LibraryIncludeFlags ExcludeAssets { get; public set; }
    public LibraryIncludeFlags PrivateAssets { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ProjectUniqueName();
    [CompilerGeneratedAttribute]
public void set_ProjectUniqueName(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectPath();
    [CompilerGeneratedAttribute]
public void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public LibraryIncludeFlags get_IncludeAssets();
    [CompilerGeneratedAttribute]
public void set_IncludeAssets(LibraryIncludeFlags value);
    [CompilerGeneratedAttribute]
public LibraryIncludeFlags get_ExcludeAssets();
    [CompilerGeneratedAttribute]
public void set_ExcludeAssets(LibraryIncludeFlags value);
    [CompilerGeneratedAttribute]
public LibraryIncludeFlags get_PrivateAssets();
    [CompilerGeneratedAttribute]
public void set_PrivateAssets(LibraryIncludeFlags value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public sealed virtual bool Equals(ProjectRestoreReference other);
    public ProjectRestoreReference Clone();
}
public class NuGet.ProjectModel.ProjectRestoreSettings : object {
    [CompilerGeneratedAttribute]
private bool <HideWarningsAndErrors>k__BackingField;
    public bool HideWarningsAndErrors { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_HideWarningsAndErrors();
    [CompilerGeneratedAttribute]
public void set_HideWarningsAndErrors(bool value);
    public ProjectRestoreSettings Clone();
    public virtual bool Equals(object obj);
    public bool Equals(ProjectRestoreSettings other);
    public virtual int GetHashCode();
}
public enum NuGet.ProjectModel.ProjectStyle : Enum {
    public ushort value__;
    public static ProjectStyle Unknown;
    public static ProjectStyle ProjectJson;
    public static ProjectStyle PackageReference;
    public static ProjectStyle DotnetCliTool;
    public static ProjectStyle Standalone;
    public static ProjectStyle PackagesConfig;
    public static ProjectStyle DotnetToolReference;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NuGet.ProjectModel.RestoreAuditProperties : object {
    [CompilerGeneratedAttribute]
private string <EnableAudit>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AuditLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AuditMode>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private HashSet`1<string> <SuppressedAdvisories>k__BackingField;
    public string EnableAudit { get; public set; }
    public string AuditLevel { get; public set; }
    public string AuditMode { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public HashSet`1<string> SuppressedAdvisories { get; public set; }
    [CompilerGeneratedAttribute]
public string get_EnableAudit();
    [CompilerGeneratedAttribute]
public void set_EnableAudit(string value);
    [CompilerGeneratedAttribute]
public string get_AuditLevel();
    [CompilerGeneratedAttribute]
public void set_AuditLevel(string value);
    [CompilerGeneratedAttribute]
public string get_AuditMode();
    [CompilerGeneratedAttribute]
public void set_AuditMode(string value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_SuppressedAdvisories();
    [CompilerGeneratedAttribute]
public void set_SuppressedAdvisories(HashSet`1<string> value);
    public bool TryParseEnableAudit(Boolean& result);
    public bool TryParseAuditLevel(PackageVulnerabilitySeverity& result);
    public sealed virtual bool Equals(RestoreAuditProperties other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(RestoreAuditProperties x, RestoreAuditProperties y);
    public static bool op_Inequality(RestoreAuditProperties x, RestoreAuditProperties y);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
internal RestoreAuditProperties Clone();
}
public class NuGet.ProjectModel.RestoreLockProperties : object {
    [CompilerGeneratedAttribute]
private string <RestorePackagesWithLockFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NuGetLockFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RestoreLockedMode>k__BackingField;
    public string RestorePackagesWithLockFile { get; }
    public string NuGetLockFilePath { get; }
    public bool RestoreLockedMode { get; }
    public RestoreLockProperties(string restorePackagesWithLockFile, string nuGetLockFilePath, bool restoreLockedMode);
    [CompilerGeneratedAttribute]
public string get_RestorePackagesWithLockFile();
    [CompilerGeneratedAttribute]
public string get_NuGetLockFilePath();
    [CompilerGeneratedAttribute]
public bool get_RestoreLockedMode();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RestoreLockProperties other);
    public RestoreLockProperties Clone();
}
[ExtensionAttribute]
internal static class NuGet.ProjectModel.StringExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static ValueTuple`2<string, string> SplitInTwo(string s, char separator);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.ProjectModel.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ArgumentNullOrEmpty { get; }
    internal static string InvalidDependencyTarget { get; }
    internal static string InvalidPackageType { get; }
    internal static string Log_ErrorReadingLockFile { get; }
    internal static string Log_ErrorReadingProjectJson { get; }
    internal static string Log_ErrorReadingProjectJsonWithLocation { get; }
    internal static string Log_InvalidImportFramework { get; }
    internal static string Log_ProblemReadingCacheFile { get; }
    internal static string MissingVersionOnDependency { get; }
    internal static string MissingVersionOnTool { get; }
    internal static string None { get; }
    internal static string PackagesLockFile_CentralPackageVersionRemoved { get; }
    internal static string PackagesLockFile_IncompatibleLockFileVersion { get; }
    internal static string PackagesLockFile_MismatchedTargetFrameworks { get; }
    internal static string PackagesLockFile_NewTargetFramework { get; }
    internal static string PackagesLockFile_PackageReferenceAdded { get; }
    internal static string PackagesLockFile_PackageReferencesHaveChanged { get; }
    internal static string PackagesLockFile_PackageReferenceVersionChanged { get; }
    internal static string PackagesLockFile_ProjectReferenceAdded { get; }
    internal static string PackagesLockFile_ProjectReferenceDependenciesHasChanged { get; }
    internal static string PackagesLockFile_ProjectReferenceHasNoCompatibleTargetFramework { get; }
    internal static string PackagesLockFile_ProjectReferencesHasChange { get; }
    internal static string PackagesLockFile_ProjectTransitiveDependencyChanged { get; }
    internal static string PackagesLockFile_ProjectTransitiveDependencyVersionChanged { get; }
    internal static string PackagesLockFile_RestoreMetadataMissingTfms { get; }
    internal static string PackagesLockFile_RuntimeIdentifiersChanged { get; }
    internal static string PackagesLockFile_UnableToLoadPackagespec { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ArgumentNullOrEmpty();
    internal static string get_InvalidDependencyTarget();
    internal static string get_InvalidPackageType();
    internal static string get_Log_ErrorReadingLockFile();
    internal static string get_Log_ErrorReadingProjectJson();
    internal static string get_Log_ErrorReadingProjectJsonWithLocation();
    internal static string get_Log_InvalidImportFramework();
    internal static string get_Log_ProblemReadingCacheFile();
    internal static string get_MissingVersionOnDependency();
    internal static string get_MissingVersionOnTool();
    internal static string get_None();
    internal static string get_PackagesLockFile_CentralPackageVersionRemoved();
    internal static string get_PackagesLockFile_IncompatibleLockFileVersion();
    internal static string get_PackagesLockFile_MismatchedTargetFrameworks();
    internal static string get_PackagesLockFile_NewTargetFramework();
    internal static string get_PackagesLockFile_PackageReferenceAdded();
    internal static string get_PackagesLockFile_PackageReferencesHaveChanged();
    internal static string get_PackagesLockFile_PackageReferenceVersionChanged();
    internal static string get_PackagesLockFile_ProjectReferenceAdded();
    internal static string get_PackagesLockFile_ProjectReferenceDependenciesHasChanged();
    internal static string get_PackagesLockFile_ProjectReferenceHasNoCompatibleTargetFramework();
    internal static string get_PackagesLockFile_ProjectReferencesHasChange();
    internal static string get_PackagesLockFile_ProjectTransitiveDependencyChanged();
    internal static string get_PackagesLockFile_ProjectTransitiveDependencyVersionChanged();
    internal static string get_PackagesLockFile_RestoreMetadataMissingTfms();
    internal static string get_PackagesLockFile_RuntimeIdentifiersChanged();
    internal static string get_PackagesLockFile_UnableToLoadPackagespec();
}
public class NuGet.ProjectModel.TargetFrameworkInformation : object {
    [CompilerGeneratedAttribute]
private string <TargetAlias>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <FrameworkName>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LibraryDependency> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<NuGetFramework> <Imports>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AssetTargetFallback>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Warn>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DownloadDependency> <DownloadDependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, CentralPackageVersion> <CentralPackageVersions>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<FrameworkDependency> <FrameworkReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifierGraphPath>k__BackingField;
    public string TargetAlias { get; public set; }
    public NuGetFramework FrameworkName { get; public set; }
    public IList`1<LibraryDependency> Dependencies { get; public set; }
    public IList`1<NuGetFramework> Imports { get; public set; }
    public bool AssetTargetFallback { get; public set; }
    public bool Warn { get; public set; }
    public IList`1<DownloadDependency> DownloadDependencies { get; }
    public IDictionary`2<string, CentralPackageVersion> CentralPackageVersions { get; }
    public ISet`1<FrameworkDependency> FrameworkReferences { get; }
    public string RuntimeIdentifierGraphPath { get; public set; }
    internal TargetFrameworkInformation(TargetFrameworkInformation cloneFrom);
    [CompilerGeneratedAttribute]
public string get_TargetAlias();
    [CompilerGeneratedAttribute]
public void set_TargetAlias(string value);
    [CompilerGeneratedAttribute]
public NuGetFramework get_FrameworkName();
    [CompilerGeneratedAttribute]
public void set_FrameworkName(NuGetFramework value);
    [CompilerGeneratedAttribute]
public IList`1<LibraryDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(IList`1<LibraryDependency> value);
    [CompilerGeneratedAttribute]
public IList`1<NuGetFramework> get_Imports();
    [CompilerGeneratedAttribute]
public void set_Imports(IList`1<NuGetFramework> value);
    [CompilerGeneratedAttribute]
public bool get_AssetTargetFallback();
    [CompilerGeneratedAttribute]
public void set_AssetTargetFallback(bool value);
    [CompilerGeneratedAttribute]
public bool get_Warn();
    [CompilerGeneratedAttribute]
public void set_Warn(bool value);
    [CompilerGeneratedAttribute]
public IList`1<DownloadDependency> get_DownloadDependencies();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, CentralPackageVersion> get_CentralPackageVersions();
    [CompilerGeneratedAttribute]
public ISet`1<FrameworkDependency> get_FrameworkReferences();
    [CompilerGeneratedAttribute]
public string get_RuntimeIdentifierGraphPath();
    [CompilerGeneratedAttribute]
public void set_RuntimeIdentifierGraphPath(string value);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TargetFrameworkInformation other);
    public TargetFrameworkInformation Clone();
    [CompilerGeneratedAttribute]
internal static IList`1<T> <.ctor>g__CloneList|38_1(IList`1<T> source, Func`2<T, T> cloneFunc);
}
public class NuGet.ProjectModel.ToolPathResolver : object {
    private string _packagesDirectory;
    private bool _isLowercase;
    public ToolPathResolver(string packagesDirectory);
    public ToolPathResolver(string packagesDirectory, bool isLowercase);
    public string GetLockFilePath(string toolDirectory);
    public string GetLockFilePath(string packageId, NuGetVersion version, NuGetFramework framework);
    public string GetToolDirectoryPath(string packageId, NuGetVersion version, NuGetFramework framework);
    private string GetPackagesToolsBasePath();
    public string GetBestToolDirectoryPath(string packageId, VersionRange versionRange, NuGetFramework framework);
    private IEnumerable`1<NuGetVersion> GetAvailableToolVersions(string packageId);
}
[ExtensionAttribute]
internal static class NuGet.ProjectModel.Utf8JsonReaderExtensions : object {
    internal static Utf8JsonStreamLockFileConverter LockFileConverter;
    internal static Utf8JsonStreamLockFileItemConverter`1<LockFileItem> LockFileItemConverter;
    internal static Utf8JsonStreamLockFileItemConverter`1<LockFileContentFile> LockFileContentFileConverter;
    internal static Utf8JsonStreamLockFileItemConverter`1<LockFileRuntimeTarget> LockFileRuntimeTargetConverter;
    internal static Utf8JsonStreamLockFileTargetLibraryConverter LockFileTargetLibraryConverter;
    internal static Utf8JsonStreamLockFileLibraryConverter LockFileLibraryConverter;
    internal static Utf8JsonStreamLockFileTargetConverter LockFileTargetConverter;
    internal static Utf8JsonStreamProjectFileDependencyGroupConverter ProjectFileDepencencyGroupConverter;
    internal static Utf8JsonStreamIAssetsLogMessageConverter IAssetsLogMessageConverter;
    private static Utf8JsonReaderExtensions();
    [ExtensionAttribute]
internal static string ReadTokenAsString(Utf8JsonReader& reader);
    [ExtensionAttribute]
private static string ReadNumberAsString(Utf8JsonReader& reader);
}
internal class NuGet.ProjectModel.Utf8JsonStreamIAssetsLogMessageConverter : object {
    private static Byte[] LevelPropertyName;
    private static Byte[] CodePropertyName;
    private static Byte[] WarningLevelPropertyName;
    private static Byte[] FilePathPropertyName;
    private static Byte[] StartLineNumberPropertyName;
    private static Byte[] StartColumnNumberPropertyName;
    private static Byte[] EndLineNumberPropertyName;
    private static Byte[] EndColumnNumberPropertyName;
    private static Byte[] MessagePropertyName;
    private static Byte[] LibraryIdPropertyName;
    private static Byte[] TargetGraphsPropertyName;
    private static Utf8JsonStreamIAssetsLogMessageConverter();
    public sealed virtual IAssetsLogMessage Read(Utf8JsonStreamReader& reader);
}
internal class NuGet.ProjectModel.Utf8JsonStreamLockFileConverter : object {
    private static Byte[] VersionPropertyName;
    private static Byte[] LibrariesPropertyName;
    private static Byte[] TargetsPropertyName;
    private static Byte[] ProjectFileDependencyGroupsPropertyName;
    private static Byte[] PackageFoldersPropertyName;
    private static Byte[] ProjectPropertyName;
    private static Byte[] CentralTransitiveDependencyGroupsPropertyName;
    private static Byte[] LogsPropertyName;
    private static Utf8JsonStreamLockFileConverter();
    public sealed virtual LockFile Read(Utf8JsonStreamReader& reader);
}
internal class NuGet.ProjectModel.Utf8JsonStreamLockFileItemConverter`1 : object {
    private Func`2<string, T> _lockFileItemCreator;
    public Utf8JsonStreamLockFileItemConverter`1(Func`2<string, T> lockFileItemCreator);
    public sealed virtual T Read(Utf8JsonStreamReader& reader);
}
internal class NuGet.ProjectModel.Utf8JsonStreamLockFileLibraryConverter : object {
    private static Byte[] Sha512PropertyName;
    private static Byte[] TypePropertyName;
    private static Byte[] PathPropertyName;
    private static Byte[] MsbuildProjectPropertyName;
    private static Byte[] ServicablePropertyName;
    private static Byte[] HasToolsPropertyName;
    private static Byte[] FilesPropertyName;
    private static Utf8JsonStreamLockFileLibraryConverter();
    public sealed virtual LockFileLibrary Read(Utf8JsonStreamReader& reader);
}
internal class NuGet.ProjectModel.Utf8JsonStreamLockFileTargetConverter : object {
    public sealed virtual LockFileTarget Read(Utf8JsonStreamReader& reader);
}
internal class NuGet.ProjectModel.Utf8JsonStreamLockFileTargetLibraryConverter : object {
    private static Byte[] TypePropertyName;
    private static Byte[] FrameworkPropertyName;
    private static Byte[] DependenciesPropertyName;
    private static Byte[] FrameworkAssembliesPropertyName;
    private static Byte[] RuntimePropertyName;
    private static Byte[] CompilePropertyName;
    private static Byte[] ResourcePropertyName;
    private static Byte[] NativePropertyName;
    private static Byte[] BuildPropertyName;
    private static Byte[] BuildMultiTargetingPropertyName;
    private static Byte[] ContentFilesPropertyName;
    private static Byte[] RuntimeTargetsPropertyName;
    private static Byte[] ToolsPropertyName;
    private static Byte[] EmbedPropertyName;
    private static Byte[] FrameworkReferencesPropertyName;
    private static Utf8JsonStreamLockFileTargetLibraryConverter();
    public sealed virtual LockFileTargetLibrary Read(Utf8JsonStreamReader& reader);
    private IList`1<PackageDependency> ReadPackageDependencyList(Utf8JsonStreamReader& reader);
}
internal class NuGet.ProjectModel.Utf8JsonStreamProjectFileDependencyGroupConverter : object {
    public sealed virtual ProjectFileDependencyGroup Read(Utf8JsonStreamReader& reader);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[<a8b4d782-62ae-4aef-a59e-d702453e5cda>CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.ProjectModel.Utf8JsonStreamReader : ValueType {
    private static Char[] DelimitedStringDelimiters;
    private static Byte[] Utf8Bom;
    private static JsonReaderOptions DefaultJsonReaderOptions;
    private static int BufferSizeDefault;
    private static int MinBufferSize;
    private Utf8JsonReader _reader;
    private Stream _stream;
    private Byte[] _buffer;
    private bool _disposed;
    private ArrayPool`1<byte> _bufferPool;
    private int _bufferUsed;
    internal bool IsFinalBlock { get; }
    internal JsonTokenType TokenType { get; }
    internal Utf8JsonStreamReader(Stream stream, int bufferSize, ArrayPool`1<byte> arrayPool);
    private static Utf8JsonStreamReader();
    internal bool get_IsFinalBlock();
    internal JsonTokenType get_TokenType();
    internal bool ValueTextEquals(ReadOnlySpan`1<byte> utf8Text);
    internal bool TryGetInt32(Int32& value);
    internal string GetString();
    internal bool GetBoolean();
    internal int GetInt32();
    internal bool Read();
    internal void Skip();
    internal IList`1<T> ReadObjectAsList(IUtf8JsonStreamReaderConverter`1<T> streamReaderConverter);
    internal IList`1<T> ReadListOfObjects(IUtf8JsonStreamReaderConverter`1<T> streamReaderConverter);
    internal string ReadNextTokenAsString();
    internal IList`1<string> ReadStringArrayAsIList(IList`1<string> strings);
    internal IReadOnlyList`1<string> ReadDelimitedString();
    internal bool ReadNextTokenAsBoolOrFalse();
    internal IReadOnlyList`1<string> ReadNextStringOrArrayOfStringsAsReadOnlyList();
    internal IReadOnlyList`1<string> ReadStringArrayAsReadOnlyListFromArrayStart();
    private void GetMoreBytesFromStream();
    private void ReadStreamIntoBuffer(JsonReaderState jsonReaderState);
    public void Dispose();
    private void ThrowExceptionIfDisposed();
}
public class NuGet.ProjectModel.WarningProperties : object {
    [CompilerGeneratedAttribute]
private ISet`1<NuGetLogCode> <WarningsAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<NuGetLogCode> <NoWarn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllWarningsAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<NuGetLogCode> <WarningsNotAsErrors>k__BackingField;
    public ISet`1<NuGetLogCode> WarningsAsErrors { get; }
    public ISet`1<NuGetLogCode> NoWarn { get; }
    public bool AllWarningsAsErrors { get; public set; }
    public ISet`1<NuGetLogCode> WarningsNotAsErrors { get; }
    [ObsoleteAttribute("Use the constructor with 4 instead.")]
public WarningProperties(ISet`1<NuGetLogCode> warningsAsErrors, ISet`1<NuGetLogCode> noWarn, bool allWarningsAsErrors);
    public WarningProperties(ISet`1<NuGetLogCode> warningsAsErrors, ISet`1<NuGetLogCode> noWarn, bool allWarningsAsErrors, ISet`1<NuGetLogCode> warningsNotAsErrors);
    [CompilerGeneratedAttribute]
public ISet`1<NuGetLogCode> get_WarningsAsErrors();
    [CompilerGeneratedAttribute]
public ISet`1<NuGetLogCode> get_NoWarn();
    [CompilerGeneratedAttribute]
public bool get_AllWarningsAsErrors();
    [CompilerGeneratedAttribute]
public void set_AllWarningsAsErrors(bool value);
    [CompilerGeneratedAttribute]
public ISet`1<NuGetLogCode> get_WarningsNotAsErrors();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(WarningProperties other);
    public WarningProperties Clone();
    public static WarningProperties GetWarningProperties(string treatWarningsAsErrors, string warningsAsErrors, string noWarn, string warningsNotAsErrors);
    [ObsoleteAttribute]
public static WarningProperties GetWarningProperties(string treatWarningsAsErrors, string warningsAsErrors, string noWarn);
    public static WarningProperties GetWarningProperties(string treatWarningsAsErrors, IEnumerable`1<NuGetLogCode> warningsAsErrors, IEnumerable`1<NuGetLogCode> noWarn, IEnumerable`1<NuGetLogCode> warningsNotAsErrors);
    [ObsoleteAttribute]
public static WarningProperties GetWarningProperties(string treatWarningsAsErrors, IEnumerable`1<NuGetLogCode> warningsAsErrors, IEnumerable`1<NuGetLogCode> noWarn);
}
public class NuGet.Protocol.AlternatePackageMetadata : object {
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <Range>k__BackingField;
    [JsonPropertyAttribute]
public string PackageId { get; internal set; }
    [JsonPropertyAttribute]
public VersionRange Range { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
internal void set_PackageId(string value);
    [CompilerGeneratedAttribute]
public VersionRange get_Range();
    [CompilerGeneratedAttribute]
internal void set_Range(VersionRange value);
}
public class NuGet.Protocol.AmbientAuthenticationState : object {
    internal static int MaxAuthRetries;
    [CompilerGeneratedAttribute]
private bool <IsBlocked>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AuthenticationRetriesCount>k__BackingField;
    public bool IsBlocked { get; private set; }
    public int AuthenticationRetriesCount { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_IsBlocked();
    [CompilerGeneratedAttribute]
private void set_IsBlocked(bool value);
    [CompilerGeneratedAttribute]
public int get_AuthenticationRetriesCount();
    [CompilerGeneratedAttribute]
private void set_AuthenticationRetriesCount(int value);
    public void Block();
    public void Increment();
}
public class NuGet.Protocol.AutoCompleteResourceV2Feed : AutoCompleteResource {
    private HttpSource _httpSource;
    private Uri _baseUri;
    public AutoCompleteResourceV2Feed(HttpSourceResource httpSourceResource, string baseAddress, PackageSource packageSource);
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV2Feed/<IdStartsWith>d__3")]
public virtual Task`1<IEnumerable`1<string>> IdStartsWith(string packageIdPrefix, bool includePrerelease, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV2Feed/<VersionStartsWith>d__4")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> VersionStartsWith(string packageId, string versionPrefix, bool includePrerelease, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV2Feed/<GetResults>d__5")]
private Task`1<IEnumerable`1<string>> GetResults(Uri apiEndpointUri, ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.AutoCompleteResourceV2FeedProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV2FeedProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.AutoCompleteResourceV3 : AutoCompleteResource {
    private RegistrationResourceV3 _regResource;
    private ServiceIndexResourceV3 _serviceIndex;
    private HttpSource _client;
    public AutoCompleteResourceV3(HttpSource client, ServiceIndexResourceV3 serviceIndex, RegistrationResourceV3 regResource);
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV3/<IdStartsWith>d__4")]
public virtual Task`1<IEnumerable`1<string>> IdStartsWith(string packageIdPrefix, bool includePrerelease, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV3/<VersionStartsWith>d__5")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> VersionStartsWith(string packageId, string versionPrefix, bool includePrerelease, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.AutoCompleteResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.CachingSourceProvider : object {
    private IPackageSourceProvider _packageSourceProvider;
    private List`1<Lazy`1<INuGetResourceProvider>> _resourceProviders;
    private List`1<SourceRepository> _repositories;
    private ConcurrentDictionary`2<string, SourceRepository> _cachedSources;
    public IPackageSourceProvider PackageSourceProvider { get; }
    public CachingSourceProvider(IPackageSourceProvider packageSourceProvider);
    public sealed virtual IEnumerable`1<SourceRepository> GetRepositories();
    public SourceRepository CreateRepository(string source);
    public sealed virtual SourceRepository CreateRepository(PackageSource source);
    public sealed virtual SourceRepository CreateRepository(PackageSource source, FeedType type);
    public void AddSourceRepository(SourceRepository source);
    public sealed virtual IPackageSourceProvider get_PackageSourceProvider();
}
public static class NuGet.Protocol.CachingUtility : object {
    public static int BufferSize;
    private static int HashLength;
    public static string ComputeHash(string value, bool addIdentifiableCharacters);
    public static Stream ReadCacheFile(TimeSpan maxAge, string cacheFile);
    public static bool IsFileAlreadyOpen(string filePath);
    public static string RemoveInvalidFileNameChars(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class NuGet.Protocol.Converters.PackageVulnerabilityInfoConverter : JsonConverter`1<PackageVulnerabilityInfo> {
    public virtual PackageVulnerabilityInfo ReadJson(JsonReader reader, Type objectType, PackageVulnerabilityInfo existingValue, bool hasExistingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, PackageVulnerabilityInfo value, JsonSerializer serializer);
}
internal class NuGet.Protocol.Converters.V3SearchResultsConverter : JsonConverter {
    private UInt32 _take;
    public bool CanWrite { get; }
    public V3SearchResultsConverter(UInt32 take);
    public virtual bool get_CanWrite();
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class NuGet.Protocol.Converters.VersionRangeStjConverter : JsonConverter`1<VersionRange> {
    public virtual VersionRange Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, VersionRange value, JsonSerializerOptions options);
}
public abstract class NuGet.Protocol.Core.Types.AutoCompleteResource : object {
    public abstract virtual Task`1<IEnumerable`1<string>> IdStartsWith(string packageIdPrefix, bool includePrerelease, ILogger log, CancellationToken token);
    public abstract virtual Task`1<IEnumerable`1<NuGetVersion>> VersionStartsWith(string packageId, string versionPrefix, bool includePrerelease, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
}
public abstract class NuGet.Protocol.Core.Types.DependencyInfoResource : object {
    public abstract virtual Task`1<SourcePackageDependencyInfo> ResolvePackage(PackageIdentity package, NuGetFramework projectFramework, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    public abstract virtual Task`1<IEnumerable`1<SourcePackageDependencyInfo>> ResolvePackages(string packageId, NuGetFramework projectFramework, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    public virtual Task`1<IEnumerable`1<RemoteSourceDependencyInfo>> ResolvePackages(string packageId, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
}
public abstract class NuGet.Protocol.Core.Types.DownloadResource : object {
    public abstract virtual Task`1<DownloadResourceResult> GetDownloadResourceResultAsync(PackageIdentity identity, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.Core.Types.DownloadResourceResult : object {
    private bool _isDisposed;
    private Stream _stream;
    private PackageReaderBase _packageReader;
    private string _packageSource;
    [CompilerGeneratedAttribute]
private DownloadResourceResultStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SignatureVerified>k__BackingField;
    public DownloadResourceResultStatus Status { get; }
    public bool SignatureVerified { get; public set; }
    public Stream PackageStream { get; }
    public string PackageSource { get; }
    public PackageReaderBase PackageReader { get; }
    public DownloadResourceResult(DownloadResourceResultStatus status);
    public DownloadResourceResult(Stream stream, string source);
    public DownloadResourceResult(Stream stream, PackageReaderBase packageReader, string source);
    public DownloadResourceResult(PackageReaderBase packageReader, string source);
    [CompilerGeneratedAttribute]
public DownloadResourceResultStatus get_Status();
    [CompilerGeneratedAttribute]
public bool get_SignatureVerified();
    [CompilerGeneratedAttribute]
public void set_SignatureVerified(bool value);
    public Stream get_PackageStream();
    public string get_PackageSource();
    public PackageReaderBase get_PackageReader();
    public sealed virtual void Dispose();
}
public enum NuGet.Protocol.Core.Types.DownloadResourceResultStatus : Enum {
    public int value__;
    public static DownloadResourceResultStatus Available;
    public static DownloadResourceResultStatus AvailableWithoutStream;
    public static DownloadResourceResultStatus NotFound;
    public static DownloadResourceResultStatus Cancelled;
}
public class NuGet.Protocol.Core.Types.FatalProtocolException : NuGetProtocolException {
    public FatalProtocolException(string message);
    public FatalProtocolException(string message, Exception innerException);
    protected FatalProtocolException(SerializationInfo info, StreamingContext context);
}
public class NuGet.Protocol.Core.Types.FindPackageByIdDependencyInfo : object {
    [CompilerGeneratedAttribute]
private PackageIdentity <PackageIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PackageDependencyGroup> <DependencyGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<FrameworkSpecificGroup> <FrameworkReferenceGroups>k__BackingField;
    public PackageIdentity PackageIdentity { get; }
    public IReadOnlyList`1<PackageDependencyGroup> DependencyGroups { get; }
    public IReadOnlyList`1<FrameworkSpecificGroup> FrameworkReferenceGroups { get; }
    public FindPackageByIdDependencyInfo(PackageIdentity packageIdentity, IEnumerable`1<PackageDependencyGroup> dependencyGroups, IEnumerable`1<FrameworkSpecificGroup> frameworkReferenceGroups);
    [CompilerGeneratedAttribute]
public PackageIdentity get_PackageIdentity();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PackageDependencyGroup> get_DependencyGroups();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<FrameworkSpecificGroup> get_FrameworkReferenceGroups();
}
public abstract class NuGet.Protocol.Core.Types.FindPackageByIdResource : object {
    public abstract virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public abstract virtual Task`1<FindPackageByIdDependencyInfo> GetDependencyInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> CopyNupkgToStreamAsync(string id, NuGetVersion version, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public abstract virtual Task`1<IPackageDownloader> GetPackageDownloaderAsync(PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> DoesPackageExistAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    protected static FindPackageByIdDependencyInfo GetDependencyInfo(NuspecReader reader);
}
public abstract class NuGet.Protocol.Core.Types.HttpHandlerResource : object {
    public HttpClientHandler ClientHandler { get; }
    public HttpMessageHandler MessageHandler { get; }
    public abstract virtual HttpClientHandler get_ClientHandler();
    public abstract virtual HttpMessageHandler get_MessageHandler();
}
public class NuGet.Protocol.Core.Types.HttpSourceCacheContext : object {
    [CompilerGeneratedAttribute]
private TimeSpan <MaxAge>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DirectDownload>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootTempFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceCacheContext <SourceCacheContext>k__BackingField;
    public TimeSpan MaxAge { get; }
    public bool DirectDownload { get; }
    public string RootTempFolder { get; }
    public SourceCacheContext SourceCacheContext { get; }
    private HttpSourceCacheContext(string rootTempFolder, TimeSpan maxAge, bool directDownload, SourceCacheContext cacheContext);
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxAge();
    [CompilerGeneratedAttribute]
public bool get_DirectDownload();
    [CompilerGeneratedAttribute]
public string get_RootTempFolder();
    [CompilerGeneratedAttribute]
public SourceCacheContext get_SourceCacheContext();
    public static HttpSourceCacheContext Create(SourceCacheContext cacheContext, int retryCount);
    public static HttpSourceCacheContext Create(SourceCacheContext cacheContext, bool isFirstAttempt);
}
public interface NuGet.Protocol.Core.Types.ILegacyFeedCapabilityResource {
    public abstract virtual Task`1<bool> SupportsIsAbsoluteLatestVersionAsync(ILogger log, CancellationToken token);
    public abstract virtual Task`1<bool> SupportsSearchAsync(ILogger log, CancellationToken token);
}
public interface NuGet.Protocol.Core.Types.INuGetResource {
}
[NullableContextAttribute("1")]
public interface NuGet.Protocol.Core.Types.INuGetResourceProvider {
    public Type ResourceType { get; }
    public string Name { get; }
    public IEnumerable`1<string> Before { get; }
    public IEnumerable`1<string> After { get; }
    public abstract virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
    public abstract virtual Type get_ResourceType();
    public abstract virtual string get_Name();
    public abstract virtual IEnumerable`1<string> get_Before();
    public abstract virtual IEnumerable`1<string> get_After();
}
public interface NuGet.Protocol.Core.Types.IPackageSearchMetadata {
    public string Authors { get; }
    public IEnumerable`1<PackageDependencyGroup> DependencySets { get; }
    public string Description { get; }
    public Nullable`1<long> DownloadCount { get; }
    public Uri IconUrl { get; }
    public PackageIdentity Identity { get; }
    public Uri LicenseUrl { get; }
    public Uri ProjectUrl { get; }
    public Uri ReadmeUrl { get; }
    public Uri ReportAbuseUrl { get; }
    public Uri PackageDetailsUrl { get; }
    public Nullable`1<DateTimeOffset> Published { get; }
    public IReadOnlyList`1<string> OwnersList { get; }
    public string Owners { get; }
    public bool RequireLicenseAcceptance { get; }
    public string Summary { get; }
    public string Tags { get; }
    public string Title { get; }
    public bool IsListed { get; }
    public bool PrefixReserved { get; }
    public LicenseMetadata LicenseMetadata { get; }
    public IEnumerable`1<PackageVulnerabilityMetadata> Vulnerabilities { get; }
    public abstract virtual string get_Authors();
    public abstract virtual IEnumerable`1<PackageDependencyGroup> get_DependencySets();
    public abstract virtual string get_Description();
    public abstract virtual Nullable`1<long> get_DownloadCount();
    public abstract virtual Uri get_IconUrl();
    public abstract virtual PackageIdentity get_Identity();
    public abstract virtual Uri get_LicenseUrl();
    public abstract virtual Uri get_ProjectUrl();
    public abstract virtual Uri get_ReadmeUrl();
    public abstract virtual Uri get_ReportAbuseUrl();
    public abstract virtual Uri get_PackageDetailsUrl();
    public abstract virtual Nullable`1<DateTimeOffset> get_Published();
    public abstract virtual IReadOnlyList`1<string> get_OwnersList();
    public abstract virtual string get_Owners();
    public abstract virtual bool get_RequireLicenseAcceptance();
    public abstract virtual string get_Summary();
    public abstract virtual string get_Tags();
    public abstract virtual string get_Title();
    public abstract virtual bool get_IsListed();
    public abstract virtual bool get_PrefixReserved();
    public abstract virtual LicenseMetadata get_LicenseMetadata();
    public abstract virtual Task`1<PackageDeprecationMetadata> GetDeprecationMetadataAsync();
    public abstract virtual Task`1<IEnumerable`1<VersionInfo>> GetVersionsAsync();
    public abstract virtual IEnumerable`1<PackageVulnerabilityMetadata> get_Vulnerabilities();
}
public interface NuGet.Protocol.Core.Types.ISourceRepositoryProvider {
    public IPackageSourceProvider PackageSourceProvider { get; }
    public abstract virtual IEnumerable`1<SourceRepository> GetRepositories();
    public abstract virtual SourceRepository CreateRepository(PackageSource source);
    public abstract virtual SourceRepository CreateRepository(PackageSource source, FeedType type);
    public abstract virtual IPackageSourceProvider get_PackageSourceProvider();
}
public abstract class NuGet.Protocol.Core.Types.LegacyFeedCapabilityResource : object {
    public abstract virtual Task`1<bool> SupportsSearchAsync(ILogger log, CancellationToken token);
    public abstract virtual Task`1<bool> SupportsIsAbsoluteLatestVersionAsync(ILogger log, CancellationToken token);
}
public abstract class NuGet.Protocol.Core.Types.ListResource : object {
    public string Source { get; }
    public abstract virtual Task`1<IEnumerableAsync`1<IPackageSearchMetadata>> ListAsync(string searchTerm, bool prerelease, bool allVersions, bool includeDelisted, ILogger log, CancellationToken token);
    public abstract virtual string get_Source();
}
public abstract class NuGet.Protocol.Core.Types.MetadataResource : object {
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.MetadataResource/<GetVersions>d__0")]
public Task`1<IEnumerable`1<NuGetVersion>> GetVersions(string packageId, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public abstract virtual Task`1<IEnumerable`1<NuGetVersion>> GetVersions(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.MetadataResource/<Exists>d__2")]
public Task`1<bool> Exists(PackageIdentity identity, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public abstract virtual Task`1<bool> Exists(PackageIdentity identity, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.MetadataResource/<Exists>d__4")]
public Task`1<bool> Exists(string packageId, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public abstract virtual Task`1<bool> Exists(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public abstract virtual Task`1<IEnumerable`1<KeyValuePair`2<string, NuGetVersion>>> GetLatestVersions(IEnumerable`1<string> packageIds, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.MetadataResource/<GetLatestVersion>d__7")]
public Task`1<NuGetVersion> GetLatestVersion(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
}
public abstract class NuGet.Protocol.Core.Types.NuGetProtocolException : Exception {
    public NuGetProtocolException(string message);
    public NuGetProtocolException(string message, Exception innerException);
    protected NuGetProtocolException(SerializationInfo info, StreamingContext context);
}
public class NuGet.Protocol.Core.Types.NuGetResourceProviderPositions : object {
    public static string First;
    public static string Last;
}
public static class NuGet.Protocol.Core.Types.NuGetTestMode : object {
    private static string _testModeEnvironmentVariableName;
    public static string NuGetTestClientName;
    [CompilerGeneratedAttribute]
private static bool <Enabled>k__BackingField;
    public static bool Enabled { get; private set; }
    private static NuGetTestMode();
    [CompilerGeneratedAttribute]
public static bool get_Enabled();
    [CompilerGeneratedAttribute]
private static void set_Enabled(bool value);
    private static bool FromEnvironmentVariable();
    public static T InvokeTestFunctionAgainstTestMode(Func`1<T> function, bool testModeEnabled);
}
public class NuGet.Protocol.Core.Types.NullSourceCacheContext : SourceCacheContext {
    private static SourceCacheContext _instance;
    public static SourceCacheContext Instance { get; }
    public string GeneratedTempFolder { get; }
    public static SourceCacheContext get_Instance();
    public virtual string get_GeneratedTempFolder();
    public virtual SourceCacheContext WithRefreshCacheTrue();
    public virtual SourceCacheContext Clone();
}
public class NuGet.Protocol.Core.Types.OfflineFeedAddContext : object {
    [CompilerGeneratedAttribute]
private string <PackagePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowIfSourcePackageIsInvalid>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowIfPackageExistsAndInvalid>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowIfPackageExists>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageExtractionContext <ExtractionContext>k__BackingField;
    public string PackagePath { get; }
    public string Source { get; }
    public ILogger Logger { get; }
    public bool ThrowIfSourcePackageIsInvalid { get; }
    public bool ThrowIfPackageExistsAndInvalid { get; }
    public bool ThrowIfPackageExists { get; }
    public PackageExtractionContext ExtractionContext { get; }
    public OfflineFeedAddContext(string packagePath, string source, ILogger logger, bool throwIfSourcePackageIsInvalid, bool throwIfPackageExistsAndInvalid, bool throwIfPackageExists, PackageExtractionContext extractionContext);
    [CompilerGeneratedAttribute]
public string get_PackagePath();
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public bool get_ThrowIfSourcePackageIsInvalid();
    [CompilerGeneratedAttribute]
public bool get_ThrowIfPackageExistsAndInvalid();
    [CompilerGeneratedAttribute]
public bool get_ThrowIfPackageExists();
    [CompilerGeneratedAttribute]
public PackageExtractionContext get_ExtractionContext();
}
public static class NuGet.Protocol.Core.Types.OfflineFeedUtility : object {
    public static bool PackageExists(PackageIdentity packageIdentity, string offlineFeed, Boolean& isValidPackage);
    public static string GetPackageDirectory(PackageIdentity packageIdentity, string offlineFeed);
    public static void ThrowIfInvalid(string path);
    public static void ThrowIfInvalidOrNotFound(string path, bool isDirectory, string resourceString);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.OfflineFeedUtility/<AddPackageToSource>d__4")]
public static Task AddPackageToSource(OfflineFeedAddContext offlineFeedAddContext, CancellationToken token);
    private static string GetHash(string nupkgFilePath);
}
public class NuGet.Protocol.Core.Types.PackageDownloadContext : object {
    [CompilerGeneratedAttribute]
private SourceCacheContext <SourceCacheContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DirectDownload>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DirectDownloadDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ParentId>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientPolicyContext <ClientPolicyContext>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSourceMapping <PackageSourceMapping>k__BackingField;
    public SourceCacheContext SourceCacheContext { get; }
    public bool DirectDownload { get; }
    public string DirectDownloadDirectory { get; }
    public Guid ParentId { get; public set; }
    public ClientPolicyContext ClientPolicyContext { get; public set; }
    public PackageSourceMapping PackageSourceMapping { get; }
    public PackageDownloadContext(SourceCacheContext sourceCacheContext);
    public PackageDownloadContext(SourceCacheContext sourceCacheContext, string directDownloadDirectory, bool directDownload);
    public PackageDownloadContext(SourceCacheContext sourceCacheContext, string directDownloadDirectory, bool directDownload, PackageSourceMapping packageSourceMappingConfiguration);
    [CompilerGeneratedAttribute]
public SourceCacheContext get_SourceCacheContext();
    [CompilerGeneratedAttribute]
public bool get_DirectDownload();
    [CompilerGeneratedAttribute]
public string get_DirectDownloadDirectory();
    [CompilerGeneratedAttribute]
public Guid get_ParentId();
    [CompilerGeneratedAttribute]
public void set_ParentId(Guid value);
    [CompilerGeneratedAttribute]
public ClientPolicyContext get_ClientPolicyContext();
    [CompilerGeneratedAttribute]
public void set_ClientPolicyContext(ClientPolicyContext value);
    [CompilerGeneratedAttribute]
public PackageSourceMapping get_PackageSourceMapping();
}
public abstract class NuGet.Protocol.Core.Types.PackageMetadataResource : object {
    public abstract virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> GetMetadataAsync(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public abstract virtual Task`1<IPackageSearchMetadata> GetMetadataAsync(PackageIdentity package, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.Core.Types.PackageProgressEventArgs : EventArgs {
    private PackageIdentity _identity;
    private PackageSource _source;
    private double _complete;
    public PackageIdentity PackageIdentity { get; }
    public PackageSource PackageSource { get; }
    public double Complete { get; }
    public bool IsComplete { get; }
    public bool HasPackageSource { get; }
    public PackageProgressEventArgs(PackageIdentity identity, PackageSource source, double complete);
    public PackageIdentity get_PackageIdentity();
    public PackageSource get_PackageSource();
    public double get_Complete();
    public bool get_IsComplete();
    public bool get_HasPackageSource();
}
public class NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder : object {
    private IPackageSearchMetadata _metadata;
    private AsyncLazy`1<IEnumerable`1<VersionInfo>> _lazyVersionsFactory;
    private AsyncLazy`1<PackageDeprecationMetadata> _lazyDeprecationFactory;
    private PackageSearchMetadataBuilder(IPackageSearchMetadata metadata);
    public PackageSearchMetadataBuilder WithVersions(AsyncLazy`1<IEnumerable`1<VersionInfo>> lazyVersionsFactory);
    public PackageSearchMetadataBuilder WithDeprecation(AsyncLazy`1<PackageDeprecationMetadata> lazyDeprecationFactory);
    public IPackageSearchMetadata Build();
    public static PackageSearchMetadataBuilder FromMetadata(IPackageSearchMetadata metadata);
    public static PackageSearchMetadataBuilder FromIdentity(PackageIdentity identity);
}
[ExtensionAttribute]
public static class NuGet.Protocol.Core.Types.PackageSearchMetadataExtensions : object {
    [ExtensionAttribute]
public static IPackageSearchMetadata WithVersions(IPackageSearchMetadata metadata, IEnumerable`1<VersionInfo> versions);
    [ExtensionAttribute]
public static IPackageSearchMetadata WithVersions(IPackageSearchMetadata metadata, Func`1<Task`1<IEnumerable`1<VersionInfo>>> asyncValueFactory);
    [ExtensionAttribute]
public static IPackageSearchMetadata WithVersions(IPackageSearchMetadata metadata, Func`1<IEnumerable`1<VersionInfo>> valueFactory);
}
public abstract class NuGet.Protocol.Core.Types.PackageSearchResource : object {
    public abstract virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> SearchAsync(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken cancellationToken);
}
public class NuGet.Protocol.Core.Types.PackageUpdateResource : object {
    private static string ServiceEndpoint;
    private static string ApiKeyHeader;
    private static string InvalidApiKey;
    private static string TempApiKeyServiceEndpoint;
    private HttpSource _httpSource;
    private string _source;
    private bool _disableBuffering;
    [CompilerGeneratedAttribute]
private ISettings <Settings>k__BackingField;
    public ISettings Settings { get; public set; }
    public Uri SourceUri { get; }
    public PackageUpdateResource(string source, HttpSource httpSource);
    [CompilerGeneratedAttribute]
public ISettings get_Settings();
    [CompilerGeneratedAttribute]
public void set_Settings(ISettings value);
    public Uri get_SourceUri();
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<Push>d__14")]
public Task Push(IList`1<string> packagePaths, string symbolSource, int timeoutInSecond, bool disableBuffering, Func`2<string, string> getApiKey, Func`2<string, string> getSymbolApiKey, bool noServiceEndpoint, bool skipDuplicate, SymbolPackageUpdateResourceV3 symbolPackageUpdateResource, ILogger log);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<Push>d__15")]
public Task Push(IList`1<string> packagePaths, string symbolSource, int timeoutInSecond, bool disableBuffering, Func`2<string, string> getApiKey, Func`2<string, string> getSymbolApiKey, bool noServiceEndpoint, bool skipDuplicate, SymbolPackageUpdateResourceV3 symbolPackageUpdateResource, bool allowInsecureConnections, ILogger log);
    [ObsoleteAttribute("Use Push method which takes multiple package paths.")]
public Task Push(string packagePath, string symbolSource, int timeoutInSecond, bool disableBuffering, Func`2<string, string> getApiKey, Func`2<string, string> getSymbolApiKey, bool noServiceEndpoint, bool skipDuplicate, SymbolPackageUpdateResourceV3 symbolPackageUpdateResource, ILogger log);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<Push>d__17")]
[ObsoleteAttribute("Consolidating to one PackageUpdateResource.Push method which has all parameters defined.")]
public Task Push(string packagePath, string symbolSource, int timeoutInSecond, bool disableBuffering, Func`2<string, string> getApiKey, Func`2<string, string> getSymbolApiKey, bool noServiceEndpoint, ILogger log);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<Delete>d__18")]
public Task Delete(string packageId, string packageVersion, Func`2<string, string> getApiKey, Func`2<string, bool> confirm, bool noServiceEndpoint, ILogger log);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<Delete>d__19")]
public Task Delete(string packageId, string packageVersion, Func`2<string, string> getApiKey, Func`2<string, bool> confirm, bool noServiceEndpoint, bool allowInsecureConnections, ILogger log);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<PushSymbolsPath>d__20")]
private Task PushSymbolsPath(string packagePath, string symbolSource, string apiKey, bool noServiceEndpoint, bool skipDuplicate, SymbolPackageUpdateResourceV3 symbolPackageUpdateResource, bool allowInsecureConnections, TimeSpan requestTimeout, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<PushPackagePath>d__21")]
private Task PushPackagePath(string packagePath, string source, string symbolSource, string apiKey, Func`2<string, string> getSymbolApiKey, bool noServiceEndpoint, bool skipDuplicate, SymbolPackageUpdateResourceV3 symbolPackageUpdateResource, bool allowInsecureConnections, TimeSpan requestTimeout, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<PushPackageCore>d__22")]
private Task`1<bool> PushPackageCore(string source, string apiKey, string packageToPush, bool noServiceEndpoint, bool skipDuplicate, TimeSpan requestTimeout, bool warnForHttpSources, bool allowInsecureConnections, ILogger log, CancellationToken token);
    private static string GetSourceDisplayName(string source);
    private bool IsFileSource();
    private static string GetSymbolsPath(string packagePath, bool isSnupkg);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<PushPackageToServer>d__26")]
private Task`1<bool> PushPackageToServer(string source, string apiKey, string pathToPackage, bool noServiceEndpoint, bool skipDuplicate, TimeSpan requestTimeout, bool warnForHttpSources, bool allowInsecureConnections, ILogger logger, CancellationToken token);
    private static Nullable`1<HttpStatusCode> EnsureSuccessStatusCode(HttpResponseMessage response, Nullable`1<HttpStatusCode> codeNotToThrow, ILogger logger);
    private static bool DetectAndLogSkippedErrorOccurrence(Nullable`1<HttpStatusCode> skippedErrorStatusCode, string source, string packageIdentity, string reasonMessage, ILogger logger);
    private static void AdvertiseAvailableOptionToIgnore(HttpStatusCode errorCodeThatOccurred, ILogger logger);
    private Nullable`1<HttpStatusCode> ConvertSkipDuplicateParamToHttpStatusCode(bool skipDuplicate);
    private HttpRequestMessage CreateRequest(Uri serviceEndpointUrl, string pathToPackage, string apiKey, ILogger log);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<PushPackageToFileSystem>d__32")]
private Task PushPackageToFileSystem(Uri sourceUri, string pathToPackage, bool skipDuplicate, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<DeletePackage>d__33")]
private Task DeletePackage(string source, string apiKey, string packageId, string packageVersion, bool noServiceEndpoint, bool allowInsecureConnections, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<DeletePackageFromServer>d__34")]
private Task DeletePackageFromServer(string source, string apiKey, string packageId, string packageVersion, bool noServiceEndpoint, ILogger logger, CancellationToken token);
    private void DeletePackageFromFileSystem(string source, string packageId, string packageVersion);
    private void ForceDeleteFile(string fullPath);
    public static void ForceDeleteDirectory(string path);
    private Uri GetServiceEndpointUrl(string source, string path, bool noServiceEndpoint);
    private static Uri EnsureTrailingSlash(string value);
    private bool IsV2LocalRepository(string root);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<GetSecureApiKey>d__41")]
private Task`1<string> GetSecureApiKey(PackageIdentity packageIdentity, string apiKey, bool noServiceEndpoint, TimeSpan requestTimeout, ILogger logger, CancellationToken token);
    private bool IsSourceNuGetSymbolServer(string source);
}
public class NuGet.Protocol.Core.Types.PluginFindPackageByIdResource : FindPackageByIdResource {
    private ConcurrentDictionary`2<string, AsyncLazy`1<SortedDictionary`2<NuGetVersion, PackageInfo>>> _packageInfoCache;
    private PackageSource _packageSource;
    private IPlugin _plugin;
    private IPluginMulticlientUtilities _utilities;
    private static string ResourceTypeName;
    private static string ThisTypeName;
    public PluginFindPackageByIdResource(IPlugin plugin, IPluginMulticlientUtilities utilities, PackageSource packageSource);
    public virtual Task`1<bool> CopyNupkgToStreamAsync(string id, NuGetVersion version, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public virtual Task`1<IPackageDownloader> GetPackageDownloaderAsync(PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PluginFindPackageByIdResource/<GetAllVersionsAsync>d__9")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PluginFindPackageByIdResource/<GetDependencyInfoAsync>d__10")]
public virtual Task`1<FindPackageByIdDependencyInfo> GetDependencyInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PluginFindPackageByIdResource/<DoesPackageExistAsync>d__11")]
public virtual Task`1<bool> DoesPackageExistAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PluginFindPackageByIdResource/<EnsurePackagesAsync>d__12")]
private Task`1<SortedDictionary`2<NuGetVersion, PackageInfo>> EnsurePackagesAsync(string id, SourceCacheContext cacheContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PluginFindPackageByIdResource/<FindPackagesByIdAsync>d__13")]
private Task`1<SortedDictionary`2<NuGetVersion, PackageInfo>> FindPackagesByIdAsync(string id, CancellationToken cancellationToken);
    private SortedDictionary`2<NuGetVersion, PackageInfo> ParsePackageVersions(IEnumerable`1<string> versions, string id, string baseUri);
    private PackageInfo CreatePackageInfo(string baseUri, string id, string version);
    private void AddOrUpdateLogger(IPlugin plugin, ILogger logger);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PluginFindPackageByIdResource/<SetLogLevelAsync>d__17")]
private Task SetLogLevelAsync(ILogger logger, CancellationToken cancellationToken);
}
public class NuGet.Protocol.Core.Types.PluginResource : object {
    private static string _basicAuthenticationType;
    private ICredentialService _credentialService;
    private PackageSource _packageSource;
    private IReadOnlyList`1<PluginCreationResult> _pluginCreationResults;
    public PluginResource(IEnumerable`1<PluginCreationResult> pluginCreationResults, PackageSource packageSource, ICredentialService credentialService);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PluginResource/<GetPluginAsync>d__5")]
public Task`1<GetPluginResult> GetPluginAsync(OperationClaim requiredClaim, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PluginResource/<SetPackageSourceCredentialsAsync>d__6")]
private Task SetPackageSourceCredentialsAsync(IPlugin plugin, CancellationToken cancellationToken);
    private SetCredentialsRequest CreateRequest();
    private bool TryGetCachedCredentials(Uri uri, bool isProxy, ICredentials& credentials);
}
public class NuGet.Protocol.Core.Types.PluginResourceProvider : ResourceProvider {
    private IPluginManager _pluginManager;
    public PluginResourceProvider(IPluginManager pluginManager);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PluginResourceProvider/<TryCreate>d__3")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken cancellationToken);
}
internal class NuGet.Protocol.Core.Types.ProviderComparer : object {
    [CompilerGeneratedAttribute]
private static ProviderComparer <Instance>k__BackingField;
    public static ProviderComparer Instance { get; }
    private static ProviderComparer();
    [CompilerGeneratedAttribute]
public static ProviderComparer get_Instance();
    public sealed virtual int Compare(INuGetResourceProvider providerA, INuGetResourceProvider providerB);
}
public class NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo : object {
    [CompilerGeneratedAttribute]
private PackageIdentity <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Listed>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageDependencyGroup> <DependencyGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentUri>k__BackingField;
    public PackageIdentity Identity { get; }
    public bool Listed { get; }
    public IEnumerable`1<PackageDependencyGroup> DependencyGroups { get; }
    public string ContentUri { get; public set; }
    public RemoteSourceDependencyInfo(PackageIdentity identity, bool listed, IEnumerable`1<PackageDependencyGroup> dependencyGroups, string contentUri);
    [CompilerGeneratedAttribute]
public PackageIdentity get_Identity();
    [CompilerGeneratedAttribute]
public bool get_Listed();
    [CompilerGeneratedAttribute]
public IEnumerable`1<PackageDependencyGroup> get_DependencyGroups();
    [CompilerGeneratedAttribute]
public string get_ContentUri();
    [CompilerGeneratedAttribute]
public void set_ContentUri(string value);
    public sealed virtual bool Equals(RemoteSourceDependencyInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public static class NuGet.Protocol.Core.Types.Repository : object {
    private static ProviderFactory _providerFactory;
    [CompilerGeneratedAttribute]
private static RepositoryFactory <Factory>k__BackingField;
    public static RepositoryFactory Factory { get; }
    public static ProviderFactory Provider { get; public set; }
    private static Repository();
    [CompilerGeneratedAttribute]
public static RepositoryFactory get_Factory();
    public static ProviderFactory get_Provider();
    public static void set_Provider(ProviderFactory value);
    [ObsoleteAttribute("https://github.com/NuGet/Home/issues/8479")]
public static ISourceRepositoryProvider CreateProvider(IEnumerable`1<INuGetResourceProvider> resourceProviders);
    [ObsoleteAttribute("https://github.com/NuGet/Home/issues/8479")]
public static ISourceRepositoryProvider CreateProvider(IEnumerable`1<INuGetResourceProvider> resourceProviders, string rootPath);
    public static SourceRepository CreateSource(IEnumerable`1<Lazy`1<INuGetResourceProvider>> resourceProviders, string sourceUrl);
    public static SourceRepository CreateSource(IEnumerable`1<Lazy`1<INuGetResourceProvider>> resourceProviders, string sourceUrl, FeedType type);
    public static SourceRepository CreateSource(IEnumerable`1<Lazy`1<INuGetResourceProvider>> resourceProviders, PackageSource source);
    public static SourceRepository CreateSource(IEnumerable`1<Lazy`1<INuGetResourceProvider>> resourceProviders, PackageSource source, FeedType type);
    private static IEnumerable`1<Lazy`1<INuGetResourceProvider>> CreateLazy(IEnumerable`1<INuGetResourceProvider> providers);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NuGet.Protocol.Core.Types.ResourceProvider : object {
    private Type _resourceType;
    private string _name;
    private IEnumerable`1<string> _after;
    private IEnumerable`1<string> _before;
    public IEnumerable`1<string> After { get; }
    public IEnumerable`1<string> Before { get; }
    public string Name { get; }
    public Type ResourceType { get; }
    public ResourceProvider(Type resourceType);
    public ResourceProvider(Type resourceType, string name);
    public ResourceProvider(Type resourceType, string name, string before);
    public ResourceProvider(Type resourceType, string name, IEnumerable`1<string> before, IEnumerable`1<string> after);
    public virtual IEnumerable`1<string> get_After();
    public virtual IEnumerable`1<string> get_Before();
    public virtual string get_Name();
    public virtual Type get_ResourceType();
    public abstract virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
    private static IEnumerable`1<string> ToArray(string s);
}
public class NuGet.Protocol.Core.Types.RetriableProtocolException : NuGetProtocolException {
    public RetriableProtocolException(string message);
    public RetriableProtocolException(string message, Exception innerException);
    protected RetriableProtocolException(SerializationInfo info, StreamingContext context);
}
public class NuGet.Protocol.Core.Types.SearchFilter : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <SupportedFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludePrerelease>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeDelisted>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <PackageTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SearchFilterType> <Filter>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SearchOrderBy> <OrderBy>k__BackingField;
    public IEnumerable`1<string> SupportedFrameworks { get; public set; }
    public bool IncludePrerelease { get; }
    public bool IncludeDelisted { get; public set; }
    public IEnumerable`1<string> PackageTypes { get; public set; }
    public Nullable`1<SearchFilterType> Filter { get; }
    public Nullable`1<SearchOrderBy> OrderBy { get; public set; }
    public SearchFilter(bool includePrerelease);
    public SearchFilter(bool includePrerelease, Nullable`1<SearchFilterType> filter);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_SupportedFrameworks();
    [CompilerGeneratedAttribute]
public void set_SupportedFrameworks(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_IncludePrerelease();
    [CompilerGeneratedAttribute]
public bool get_IncludeDelisted();
    [CompilerGeneratedAttribute]
public void set_IncludeDelisted(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_PackageTypes();
    [CompilerGeneratedAttribute]
public void set_PackageTypes(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public Nullable`1<SearchFilterType> get_Filter();
    [CompilerGeneratedAttribute]
public Nullable`1<SearchOrderBy> get_OrderBy();
    [CompilerGeneratedAttribute]
public void set_OrderBy(Nullable`1<SearchOrderBy> value);
}
public enum NuGet.Protocol.Core.Types.SearchFilterType : Enum {
    public int value__;
    public static SearchFilterType IsLatestVersion;
    public static SearchFilterType IsAbsoluteLatestVersion;
}
public enum NuGet.Protocol.Core.Types.SearchOrderBy : Enum {
    public int value__;
    public static SearchOrderBy Id;
}
public class NuGet.Protocol.Core.Types.SourceCacheContext : object {
    private string _generatedTempFolder;
    private static TimeSpan DefaultMaxAge;
    [CompilerGeneratedAttribute]
private bool <NoCache>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DirectDownload>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <MaxAge>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RefreshMemoryCache>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreFailedSources>k__BackingField;
    public bool NoCache { get; public set; }
    public bool DirectDownload { get; public set; }
    public Nullable`1<DateTimeOffset> MaxAge { get; public set; }
    public bool RefreshMemoryCache { get; public set; }
    public Guid SessionId { get; public set; }
    public TimeSpan MaxAgeTimeSpan { get; }
    public string GeneratedTempFolder { get; public set; }
    public bool IgnoreFailedSources { get; public set; }
    private static SourceCacheContext();
    [CompilerGeneratedAttribute]
public bool get_NoCache();
    [CompilerGeneratedAttribute]
public void set_NoCache(bool value);
    [CompilerGeneratedAttribute]
public bool get_DirectDownload();
    [CompilerGeneratedAttribute]
public void set_DirectDownload(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_MaxAge();
    [CompilerGeneratedAttribute]
public void set_MaxAge(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public bool get_RefreshMemoryCache();
    [CompilerGeneratedAttribute]
public void set_RefreshMemoryCache(bool value);
    [CompilerGeneratedAttribute]
public Guid get_SessionId();
    [CompilerGeneratedAttribute]
public void set_SessionId(Guid value);
    public TimeSpan get_MaxAgeTimeSpan();
    private TimeSpan GetCacheTime(Nullable`1<DateTimeOffset> maxAge, TimeSpan defaultTime);
    public virtual string get_GeneratedTempFolder();
    public virtual void set_GeneratedTempFolder(string value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreFailedSources();
    [CompilerGeneratedAttribute]
public void set_IgnoreFailedSources(bool value);
    public virtual SourceCacheContext Clone();
    public virtual SourceCacheContext WithRefreshCacheTrue();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class NuGet.Protocol.Core.Types.SourcePackageDependencyInfo : PackageDependencyInfo {
    [CompilerGeneratedAttribute]
private bool <Listed>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceRepository <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <DownloadUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageHash>k__BackingField;
    public bool Listed { get; }
    public SourceRepository Source { get; }
    public Uri DownloadUri { get; }
    public string PackageHash { get; }
    public SourcePackageDependencyInfo(string id, NuGetVersion version, IEnumerable`1<PackageDependency> dependencies, bool listed, SourceRepository source);
    public SourcePackageDependencyInfo(string id, NuGetVersion version, IEnumerable`1<PackageDependency> dependencies, bool listed, SourceRepository source, Uri downloadUri, string packageHash);
    public SourcePackageDependencyInfo(PackageIdentity identity, IEnumerable`1<PackageDependency> dependencies, bool listed, SourceRepository source, Uri downloadUri, string packageHash);
    [CompilerGeneratedAttribute]
public bool get_Listed();
    [CompilerGeneratedAttribute]
public SourceRepository get_Source();
    [CompilerGeneratedAttribute]
public Uri get_DownloadUri();
    [CompilerGeneratedAttribute]
public string get_PackageHash();
}
public class NuGet.Protocol.Core.Types.SourceRepository : object {
    private Dictionary`2<Type, INuGetResourceProvider[]> _providerCache;
    private PackageSource _source;
    [CompilerGeneratedAttribute]
private FeedType <FeedTypeOverride>k__BackingField;
    public FeedType FeedTypeOverride { get; }
    public PackageSource PackageSource { get; }
    public SourceRepository(PackageSource source, IEnumerable`1<INuGetResourceProvider> providers);
    public SourceRepository(PackageSource source, IEnumerable`1<Lazy`1<INuGetResourceProvider>> providers);
    public SourceRepository(PackageSource source, IEnumerable`1<Lazy`1<INuGetResourceProvider>> providers, FeedType feedTypeOverride);
    [CompilerGeneratedAttribute]
public FeedType get_FeedTypeOverride();
    public virtual string ToString();
    public virtual PackageSource get_PackageSource();
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.SourceRepository/<GetFeedType>d__12")]
public virtual Task`1<FeedType> GetFeedType(CancellationToken token);
    public virtual T GetResource();
    public virtual T GetResource(CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.SourceRepository/<GetResourceAsync>d__15`1")]
public virtual Task`1<T> GetResourceAsync();
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.SourceRepository/<GetResourceAsync>d__16`1")]
public virtual Task`1<T> GetResourceAsync(CancellationToken token);
    private static Dictionary`2<Type, INuGetResourceProvider[]> Init(IEnumerable`1<Lazy`1<INuGetResourceProvider>> providers);
    private static INuGetResourceProvider[] Sort(IEnumerable`1<Lazy`1<INuGetResourceProvider>> group);
    private static FeedType GetFeedType(PackageSource source);
}
public class NuGet.Protocol.Core.Types.SourceRepositoryProvider : object {
    private IPackageSourceProvider _packageSourceProvider;
    private IEnumerable`1<Lazy`1<INuGetResourceProvider>> _resourceProviders;
    private List`1<SourceRepository> _repositories;
    public IPackageSourceProvider PackageSourceProvider { get; }
    [ObsoleteAttribute("https://github.com/NuGet/Home/issues/8479")]
public SourceRepositoryProvider(ISettings settings, IEnumerable`1<Lazy`1<INuGetResourceProvider>> resourceProviders);
    public SourceRepositoryProvider(IPackageSourceProvider packageSourceProvider, IEnumerable`1<Lazy`1<INuGetResourceProvider>> resourceProviders);
    public sealed virtual IEnumerable`1<SourceRepository> GetRepositories();
    public sealed virtual SourceRepository CreateRepository(PackageSource source);
    public sealed virtual SourceRepository CreateRepository(PackageSource source, FeedType type);
    public sealed virtual IPackageSourceProvider get_PackageSourceProvider();
    private void Init();
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0(object sender, EventArgs e);
}
public class NuGet.Protocol.Core.Types.SymbolPackageUpdateResourceV3 : object {
    private HttpSource _httpSource;
    private string _source;
    public Uri SourceUri { get; }
    public SymbolPackageUpdateResourceV3(string source, HttpSource httpSource);
    public Uri get_SourceUri();
}
public static class NuGet.Protocol.Core.Types.UserAgent : object {
    [CompilerGeneratedAttribute]
private static string <UserAgentString>k__BackingField;
    public static string UserAgentString { get; private set; }
    private static UserAgent();
    public static void SetUserAgentString(UserAgentStringBuilder builder);
    [CompilerGeneratedAttribute]
public static string get_UserAgentString();
    [CompilerGeneratedAttribute]
private static void set_UserAgentString(string value);
    public static void SetUserAgent(HttpClient client);
}
public class NuGet.Protocol.Core.Types.UserAgentStringBuilder : object {
    public static string DefaultNuGetClientName;
    private static string UserAgentWithOSDescriptionAndVisualStudioSKUTemplate;
    private static string UserAgentWithOSDescriptionTemplate;
    private static string UserAgentTemplate;
    private string _clientName;
    private string _vsInfo;
    private string _osInfo;
    [CompilerGeneratedAttribute]
private string <NuGetClientVersion>k__BackingField;
    public string NuGetClientVersion { get; }
    public UserAgentStringBuilder(string clientName);
    private static UserAgentStringBuilder();
    [CompilerGeneratedAttribute]
public string get_NuGetClientVersion();
    public UserAgentStringBuilder WithOSDescription(string osInfo);
    public UserAgentStringBuilder WithVisualStudioSKU(string vsInfo);
    public string Build();
    private string GetOSVersion();
}
public class NuGet.Protocol.Core.Types.VersionInfo : object {
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <DownloadCount>k__BackingField;
    [CompilerGeneratedAttribute]
private IPackageSearchMetadata <PackageSearchMetadata>k__BackingField;
    public NuGetVersion Version { get; private set; }
    public Nullable`1<long> DownloadCount { get; private set; }
    public IPackageSearchMetadata PackageSearchMetadata { get; public set; }
    public VersionInfo(NuGetVersion version);
    public VersionInfo(NuGetVersion version, string downloadCount);
    public VersionInfo(NuGetVersion version, Nullable`1<long> downloadCount);
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_DownloadCount();
    [CompilerGeneratedAttribute]
private void set_DownloadCount(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public IPackageSearchMetadata get_PackageSearchMetadata();
    [CompilerGeneratedAttribute]
public void set_PackageSearchMetadata(IPackageSearchMetadata value);
}
internal class NuGet.Protocol.DedicatedAsynchronousProcessingThread : object {
    private Task _processingThread;
    private bool _isDisposed;
    private bool _isClosed;
    private TimeSpan _pollingDelay;
    private ConcurrentQueue`1<Func`1<Task>> _taskQueue;
    public DedicatedAsynchronousProcessingThread(TimeSpan pollingDelay);
    internal void Start();
    internal void Enqueue(Func`1<Task> task);
    [AsyncStateMachineAttribute("NuGet.Protocol.DedicatedAsynchronousProcessingThread/<ProcessAsync>d__8")]
private Task ProcessAsync();
    public sealed virtual void Dispose();
    private void ThrowIfAlreadyStarted();
    private void ThrowIfNotAlreadyStarted();
    private void ThrowIfDisposed();
}
internal class NuGet.Protocol.DependencyInfo : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private RegistrationInfo <RegistrationInfo>k__BackingField;
    public string Id { get; public set; }
    public VersionRange Range { get; public set; }
    public RegistrationInfo RegistrationInfo { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public VersionRange get_Range();
    [CompilerGeneratedAttribute]
public void set_Range(VersionRange value);
    [CompilerGeneratedAttribute]
public RegistrationInfo get_RegistrationInfo();
    [CompilerGeneratedAttribute]
public void set_RegistrationInfo(RegistrationInfo value);
    public virtual string ToString();
}
public class NuGet.Protocol.DependencyInfoResourceV2Feed : DependencyInfoResource {
    private V2FeedParser _feedParser;
    private FrameworkReducer _frameworkReducer;
    private SourceRepository _source;
    public DependencyInfoResourceV2Feed(V2FeedParser feedParser, SourceRepository source);
    [AsyncStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV2Feed/<ResolvePackage>d__4")]
public virtual Task`1<SourcePackageDependencyInfo> ResolvePackage(PackageIdentity package, NuGetFramework projectFramework, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV2Feed/<ResolvePackages>d__5")]
public virtual Task`1<IEnumerable`1<SourcePackageDependencyInfo>> ResolvePackages(string packageId, NuGetFramework projectFramework, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    private SourcePackageDependencyInfo CreateDependencyInfo(V2FeedPackageInfo packageVersion, NuGetFramework projectFramework);
}
public class NuGet.Protocol.DependencyInfoResourceV2FeedProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV2FeedProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.DependencyInfoResourceV3 : DependencyInfoResource {
    private HttpSource _client;
    private RegistrationResourceV3 _regResource;
    private SourceRepository _source;
    public DependencyInfoResourceV3(HttpSource client, RegistrationResourceV3 regResource, SourceRepository source);
    [AsyncStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV3/<ResolvePackage>d__4")]
public virtual Task`1<SourcePackageDependencyInfo> ResolvePackage(PackageIdentity package, NuGetFramework projectFramework, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV3/<ResolvePackages>d__5")]
public virtual Task`1<IEnumerable`1<SourcePackageDependencyInfo>> ResolvePackages(string packageId, NuGetFramework projectFramework, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    public virtual Task`1<IEnumerable`1<RemoteSourceDependencyInfo>> ResolvePackages(string packageId, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    [IteratorStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV3/<GetPackagesFromRegistration>d__7")]
private IEnumerable`1<SourcePackageDependencyInfo> GetPackagesFromRegistration(RegistrationInfo registration, CancellationToken token);
}
public class NuGet.Protocol.DependencyInfoResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.DownloadResourcePlugin : DownloadResource {
    private IPlugin _plugin;
    private PackageSource _packageSource;
    private IPluginMulticlientUtilities _utilities;
    public DownloadResourcePlugin(IPlugin plugin, IPluginMulticlientUtilities utilities, PackageSource packageSource);
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourcePlugin/<GetDownloadResourceResultAsync>d__4")]
public virtual Task`1<DownloadResourceResult> GetDownloadResourceResultAsync(PackageIdentity identity, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger logger, CancellationToken cancellationToken);
    private void AddOrUpdateLogger(IPlugin plugin, ILogger logger);
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourcePlugin/<SetLogLevelAsync>d__6")]
private Task SetLogLevelAsync(ILogger logger, CancellationToken cancellationToken);
}
public class NuGet.Protocol.DownloadResourcePluginProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourcePluginProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken cancellationToken);
    private static void AddOrUpdateGetCredentialsRequestHandler(IPlugin plugin, SourceRepository source, HttpHandlerResource httpHandlerResource);
    private static void AddOrUpdateGetServiceIndexRequestHandler(IPlugin plugin, SourceRepository source);
}
public class NuGet.Protocol.DownloadResourceV2Feed : DownloadResource {
    private V2FeedParser _feedParser;
    private string _source;
    [ObsoleteAttribute("Use constructor with source parameter")]
public DownloadResourceV2Feed(V2FeedParser feedParser);
    public DownloadResourceV2Feed(V2FeedParser feedParser, string source);
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourceV2Feed/<GetDownloadResourceResultAsync>d__4")]
public virtual Task`1<DownloadResourceResult> GetDownloadResourceResultAsync(PackageIdentity identity, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.DownloadResourceV2FeedProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourceV2FeedProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.DownloadResourceV3 : DownloadResource {
    private string _source;
    private RegistrationResourceV3 _regResource;
    private HttpSource _client;
    private string _packageBaseAddressUrl;
    [ObsoleteAttribute("Use constructor with source parameter")]
public DownloadResourceV3(HttpSource client, RegistrationResourceV3 regResource);
    public DownloadResourceV3(string source, HttpSource client, RegistrationResourceV3 regResource);
    [ObsoleteAttribute("Use constructor with source parameter")]
public DownloadResourceV3(HttpSource client, string packageBaseAddress);
    public DownloadResourceV3(string source, HttpSource client, string packageBaseAddress);
    private DownloadResourceV3(HttpSource client);
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourceV3/<GetDownloadUrl>d__9")]
private Task`1<Uri> GetDownloadUrl(PackageIdentity identity, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourceV3/<GetDownloadResourceResultAsync>d__10")]
public virtual Task`1<DownloadResourceResult> GetDownloadResourceResultAsync(PackageIdentity identity, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.DownloadResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.DownloadTimeoutStream : Stream {
    private string _downloadName;
    private Stream _networkStream;
    private TimeSpan _timeout;
    [CompilerGeneratedAttribute]
private bool <CanRead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanWrite>k__BackingField;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public DownloadTimeoutStream(string downloadName, Stream networkStream, TimeSpan timeout);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadTimeoutStream/<ReadAsync>d__8")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [CompilerGeneratedAttribute]
public virtual bool get_CanRead();
    [CompilerGeneratedAttribute]
public virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
public class NuGet.Protocol.DownloadTimeoutStreamContent : StreamContent {
    public DownloadTimeoutStreamContent(string downloadName, Stream networkStream, TimeSpan timeout);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.Protocol.EnhancedHttpRetryHelper : object {
    public static int DefaultDelayMilliseconds;
    public static bool DefaultEnabled;
    public static int DefaultRetryCount;
    public static bool DefaultRetry429;
    public static bool DefaultObserveRetryAfter;
    public static string DelayInMillisecondsEnvironmentVariableName;
    public static string IsEnabledEnvironmentVariableName;
    public static string RetryCountEnvironmentVariableName;
    public static string Retry429EnvironmentVariableName;
    public static string ObserveRetryAfterEnvironmentVariableName;
    public static string MaximumRetryAfterDurationEnvironmentVariableName;
    private IEnvironmentVariableReader _environmentVariableReader;
    private Nullable`1<bool> _isEnabled;
    private Nullable`1<int> _retryCount;
    private Nullable`1<int> _delayInMilliseconds;
    private Nullable`1<bool> _retry429;
    private Nullable`1<bool> _observeRetryAfter;
    private Nullable`1<TimeSpan> _maxRetyAfterDelay;
    internal bool IsEnabled { get; }
    internal int RetryCount { get; }
    internal int DelayInMilliseconds { get; }
    internal bool Retry429 { get; }
    internal bool ObserveRetryAfter { get; }
    internal TimeSpan MaxRetryAfterDelay { get; }
    public EnhancedHttpRetryHelper(IEnvironmentVariableReader environmentVariableReader);
    internal bool get_IsEnabled();
    internal int get_RetryCount();
    internal int get_DelayInMilliseconds();
    internal bool get_Retry429();
    internal bool get_ObserveRetryAfter();
    internal TimeSpan get_MaxRetryAfterDelay();
    private static bool GetBoolFromEnvironmentVariable(string variableName, bool defaultValue, IEnvironmentVariableReader environmentVariableReader);
    private static int GetIntFromEnvironmentVariable(string variableName, int defaultValue, IEnvironmentVariableReader environmentVariableReader);
}
public class NuGet.Protocol.Events.ProtocolDiagnosticHttpEvent : ProtocolDiagnosticHttpEventBase {
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <EventDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Bytes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSuccess>k__BackingField;
    public DateTime Timestamp { get; }
    public TimeSpan EventDuration { get; }
    public long Bytes { get; }
    public bool IsSuccess { get; }
    internal ProtocolDiagnosticHttpEvent(DateTime timestamp, string source, Uri url, Nullable`1<TimeSpan> headerDuration, TimeSpan eventDuration, long bytes, Nullable`1<int> httpStatusCode, bool isSuccess, bool isRetry, bool isCancelled, bool isLastAttempt);
    internal ProtocolDiagnosticHttpEvent(DateTime timestamp, TimeSpan eventDuration, long bytes, bool isSuccess, ProtocolDiagnosticHttpEventBase eventBase);
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public TimeSpan get_EventDuration();
    [CompilerGeneratedAttribute]
public long get_Bytes();
    [CompilerGeneratedAttribute]
public bool get_IsSuccess();
}
public abstract class NuGet.Protocol.Events.ProtocolDiagnosticHttpEventBase : object {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <HeaderDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <HttpStatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRetry>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCancelled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLastAttempt>k__BackingField;
    public string Source { get; }
    public Uri Url { get; }
    public Nullable`1<TimeSpan> HeaderDuration { get; }
    public Nullable`1<int> HttpStatusCode { get; }
    public bool IsRetry { get; }
    public bool IsCancelled { get; }
    public bool IsLastAttempt { get; }
    protected ProtocolDiagnosticHttpEventBase(ProtocolDiagnosticHttpEventBase other);
    protected ProtocolDiagnosticHttpEventBase(string source, Uri url, Nullable`1<TimeSpan> headerDuration, Nullable`1<int> httpStatusCode, bool isRetry, bool isCancelled, bool isLastAttempt);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public Uri get_Url();
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_HeaderDuration();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_HttpStatusCode();
    [CompilerGeneratedAttribute]
public bool get_IsRetry();
    [CompilerGeneratedAttribute]
public bool get_IsCancelled();
    [CompilerGeneratedAttribute]
public bool get_IsLastAttempt();
}
internal class NuGet.Protocol.Events.ProtocolDiagnosticInProgressHttpEvent : ProtocolDiagnosticHttpEventBase {
    internal ProtocolDiagnosticInProgressHttpEvent(string source, Uri url, Nullable`1<TimeSpan> headerDuration, Nullable`1<int> httpStatusCode, bool isRetry, bool isCancelled, bool isLastAttempt);
}
public class NuGet.Protocol.Events.ProtocolDiagnosticNupkgCopiedEvent : object {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FileSize>k__BackingField;
    public string Source { get; }
    public long FileSize { get; }
    public ProtocolDiagnosticNupkgCopiedEvent(string source, long fileSize);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public long get_FileSize();
}
public class NuGet.Protocol.Events.ProtocolDiagnosticResourceEvent : object {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    public string Source { get; }
    public string ResourceType { get; }
    public string Type { get; }
    public string Method { get; }
    public TimeSpan Duration { get; }
    public ProtocolDiagnosticResourceEvent(string source, string resourceType, string type, string method, TimeSpan duration);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public string get_ResourceType();
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public string get_Method();
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
}
public static class NuGet.Protocol.Events.ProtocolDiagnostics : object {
    [CompilerGeneratedAttribute]
private static ProtocolDiagnosticHttpEventHandler HttpEvent;
    [CompilerGeneratedAttribute]
private static ProtocolDiagnosticResourceEventHandler ResourceEvent;
    [CompilerGeneratedAttribute]
private static ProtocolDiagnosticsNupkgCopiedEventHandler NupkgCopiedEvent;
    [CompilerGeneratedAttribute]
public static void add_HttpEvent(ProtocolDiagnosticHttpEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_HttpEvent(ProtocolDiagnosticHttpEventHandler value);
    [CompilerGeneratedAttribute]
public static void add_ResourceEvent(ProtocolDiagnosticResourceEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_ResourceEvent(ProtocolDiagnosticResourceEventHandler value);
    [CompilerGeneratedAttribute]
public static void add_NupkgCopiedEvent(ProtocolDiagnosticsNupkgCopiedEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_NupkgCopiedEvent(ProtocolDiagnosticsNupkgCopiedEventHandler value);
    internal static void RaiseEvent(ProtocolDiagnosticHttpEvent pdEvent);
    internal static void RaiseEvent(ProtocolDiagnosticResourceEvent pdrEvent);
    internal static void RaiseEvent(ProtocolDiagnosticNupkgCopiedEvent ncEvent);
}
internal class NuGet.Protocol.Events.ProtocolDiagnosticsStream : Stream {
    private Stream _baseStream;
    private ProtocolDiagnosticInProgressHttpEvent _inProgressEvent;
    private Stopwatch _stopwatch;
    private long _bytes;
    private Action`1<ProtocolDiagnosticHttpEvent> _diagnosticEvent;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal ProtocolDiagnosticsStream(Stream baseStream, ProtocolDiagnosticInProgressHttpEvent inProgressEvent, Stopwatch stopwatch, Action`1<ProtocolDiagnosticHttpEvent> diagnosticEvent);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("NuGet.Protocol.Events.ProtocolDiagnosticsStream/<ReadAsync>d__19")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
    private void RaiseDiagnosticEvent(bool isSuccess);
}
[ExtensionAttribute]
internal static class NuGet.Protocol.Extensions.VersionRangeExtensions : object {
    [ExtensionAttribute]
public static bool DoesRangeSatisfy(VersionRange dependencyRange, NuGetVersion catalogItemLower, NuGetVersion catalogItemUpper);
}
[ExtensionAttribute]
public static class NuGet.Protocol.FactoryExtensionsV3 : object {
    [ExtensionAttribute]
public static SourceRepository GetCoreV3(RepositoryFactory factory, string source, FeedType type);
    [ExtensionAttribute]
public static SourceRepository GetCoreV3(RepositoryFactory factory, string source);
    [ExtensionAttribute]
public static SourceRepository GetCoreV3(RepositoryFactory factory, PackageSource source);
    [ExtensionAttribute]
public static SourceRepository GetCoreV2(RepositoryFactory factory, PackageSource source);
    [ExtensionAttribute]
public static IEnumerable`1<Lazy`1<INuGetResourceProvider>> GetCoreV3(ProviderFactory factory);
}
public enum NuGet.Protocol.FeedType : Enum {
    public int value__;
    public static FeedType Undefined;
    public static FeedType HttpV2;
    public static FeedType HttpV3;
    public static FeedType FileSystemV2;
    public static FeedType FileSystemV3;
    public static FeedType FileSystemUnzipped;
    public static FeedType FileSystemPackagesConfig;
    public static FeedType FileSystemUnknown;
}
public class NuGet.Protocol.FeedTypePackageSource : PackageSource {
    [CompilerGeneratedAttribute]
private FeedType <FeedType>k__BackingField;
    public FeedType FeedType { get; }
    public FeedTypePackageSource(string source, FeedType feedType);
    [CompilerGeneratedAttribute]
public FeedType get_FeedType();
}
public class NuGet.Protocol.FeedTypeResource : object {
    [CompilerGeneratedAttribute]
private FeedType <FeedType>k__BackingField;
    public FeedType FeedType { get; }
    public FeedTypeResource(FeedType feedType);
    [CompilerGeneratedAttribute]
public FeedType get_FeedType();
}
public class NuGet.Protocol.FeedTypeResourceProvider : ResourceProvider {
    private ConcurrentDictionary`2<PackageSource, FeedTypeResource> _feedTypeCache;
    private object _accessLock;
    public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public static class NuGet.Protocol.FeedTypeUtility : object {
    public static FeedType GetFeedType(PackageSource packageSource);
}
public abstract class NuGet.Protocol.FindLocalPackagesResource : object {
    [CompilerGeneratedAttribute]
private string <Root>k__BackingField;
    public string Root { get; protected set; }
    [CompilerGeneratedAttribute]
public string get_Root();
    [CompilerGeneratedAttribute]
protected void set_Root(string value);
    public virtual bool Exists(PackageIdentity identity, ILogger logger, CancellationToken token);
    public virtual bool Exists(string packageId, ILogger logger, CancellationToken token);
    public abstract virtual LocalPackageInfo GetPackage(Uri path, ILogger logger, CancellationToken token);
    public abstract virtual LocalPackageInfo GetPackage(PackageIdentity identity, ILogger logger, CancellationToken token);
    public abstract virtual IEnumerable`1<LocalPackageInfo> FindPackagesById(string id, ILogger logger, CancellationToken token);
    public abstract virtual IEnumerable`1<LocalPackageInfo> GetPackages(ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.FindLocalPackagesResourcePackagesConfig : FindLocalPackagesResource {
    public FindLocalPackagesResourcePackagesConfig(string root);
    public virtual IEnumerable`1<LocalPackageInfo> FindPackagesById(string id, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(Uri path, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(PackageIdentity identity, ILogger logger, CancellationToken token);
    public virtual IEnumerable`1<LocalPackageInfo> GetPackages(ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.FindLocalPackagesResourcePackagesConfigProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.FindLocalPackagesResourcePackagesConfigProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.FindLocalPackagesResourceUnzipped : FindLocalPackagesResource {
    private Lazy`1<IReadOnlyList`1<LocalPackageInfo>> _packages;
    private Lazy`1<Dictionary`2<PackageIdentity, LocalPackageInfo>> _index;
    private Lazy`1<Dictionary`2<Uri, LocalPackageInfo>> _pathIndex;
    public FindLocalPackagesResourceUnzipped(string root);
    public virtual IEnumerable`1<LocalPackageInfo> FindPackagesById(string id, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(Uri path, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(PackageIdentity identity, ILogger logger, CancellationToken token);
    public virtual IEnumerable`1<LocalPackageInfo> GetPackages(ILogger logger, CancellationToken token);
    public virtual bool Exists(PackageIdentity identity, ILogger logger, CancellationToken token);
    private static Dictionary`2<PackageIdentity, LocalPackageInfo> GetIndex(Lazy`1<IReadOnlyList`1<LocalPackageInfo>> packages);
    private static Dictionary`2<Uri, LocalPackageInfo> GetPathIndex(Lazy`1<IReadOnlyList`1<LocalPackageInfo>> packages);
    private static IReadOnlyList`1<LocalPackageInfo> GetPackagesCore(string root);
    private static PackageReaderBase GetPackage(DirectoryInfo root, string name);
    private static NuspecReader GetNuspec(DirectoryInfo root, string name);
}
public class NuGet.Protocol.FindLocalPackagesResourceUnzippedProvider : ResourceProvider {
    private ConcurrentDictionary`2<PackageSource, FindLocalPackagesResourceUnzipped> _cache;
    [AsyncStateMachineAttribute("NuGet.Protocol.FindLocalPackagesResourceUnzippedProvider/<TryCreate>d__2")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.FindLocalPackagesResourceV2 : FindLocalPackagesResource {
    public FindLocalPackagesResourceV2(string root);
    public virtual IEnumerable`1<LocalPackageInfo> FindPackagesById(string id, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(Uri path, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(PackageIdentity identity, ILogger logger, CancellationToken token);
    public virtual IEnumerable`1<LocalPackageInfo> GetPackages(ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.FindLocalPackagesResourceV2Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.FindLocalPackagesResourceV2Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.FindLocalPackagesResourceV3 : FindLocalPackagesResource {
    public FindLocalPackagesResourceV3(string root);
    public virtual IEnumerable`1<LocalPackageInfo> FindPackagesById(string id, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(Uri path, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(PackageIdentity identity, ILogger logger, CancellationToken token);
    public virtual IEnumerable`1<LocalPackageInfo> GetPackages(ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.FindLocalPackagesResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.FindLocalPackagesResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.FindPackagesByIdNupkgDownloader : object {
    private <095eee27-c9f8-4608-aee1-977bdb32e1fa>TaskResultCache`2<string, CacheEntry> _cacheEntries;
    private object _nuspecReadersLock;
    private ConcurrentDictionary`2<string, NuspecReader> _nuspecReaders;
    private HttpSource _httpSource;
    private EnhancedHttpRetryHelper _enhancedHttpRetryHelper;
    public FindPackagesByIdNupkgDownloader(HttpSource httpSource);
    internal FindPackagesByIdNupkgDownloader(HttpSource httpSource, IEnvironmentVariableReader environmentVariableReader);
    [AsyncStateMachineAttribute("NuGet.Protocol.FindPackagesByIdNupkgDownloader/<GetNuspecReaderFromNupkgAsync>d__7")]
public Task`1<NuspecReader> GetNuspecReaderFromNupkgAsync(PackageIdentity identity, string url, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.FindPackagesByIdNupkgDownloader/<CopyNupkgToStreamAsync>d__8")]
public Task`1<bool> CopyNupkgToStreamAsync(PackageIdentity identity, string url, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.FindPackagesByIdNupkgDownloader/<ProcessNupkgStreamAsync>d__9")]
private Task`1<bool> ProcessNupkgStreamAsync(PackageIdentity identity, string url, Func`2<Stream, Task> processStreamAsync, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.FindPackagesByIdNupkgDownloader/<ProcessStreamAndGetCacheEntryAsync>d__10")]
private Task`1<CacheEntry> ProcessStreamAndGetCacheEntryAsync(PackageIdentity identity, string url, Func`2<Stream, Task> processStreamAsync, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.FindPackagesByIdNupkgDownloader/<ProcessHttpSourceResultAsync>d__11`1")]
private Task`1<T> ProcessHttpSourceResultAsync(PackageIdentity identity, string url, Func`2<HttpSourceResult, Task`1<T>> processAsync, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.FindPackagesByIdNupkgDownloader/<ProcessCacheEntryAsync>d__12")]
private Task`1<bool> ProcessCacheEntryAsync(CacheEntry cacheEntry, Func`2<Stream, Task> processStreamAsync, CancellationToken token);
}
public class NuGet.Protocol.FingerprintsConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public static class NuGet.Protocol.GetDownloadResultUtility : object {
    private static int BufferSize;
    private static string DirectDownloadExtension;
    private static string DirectDownloadPattern;
    [AsyncStateMachineAttribute("NuGet.Protocol.GetDownloadResultUtility/<GetDownloadResultAsync>d__3")]
public static Task`1<DownloadResourceResult> GetDownloadResultAsync(HttpSource client, PackageIdentity identity, Uri uri, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger logger, CancellationToken token);
    public static void CleanUpDirectDownloads(PackageDownloadContext downloadContext);
    [AsyncStateMachineAttribute("NuGet.Protocol.GetDownloadResultUtility/<DirectDownloadAsync>d__5")]
private static Task`1<DownloadResourceResult> DirectDownloadAsync(string source, PackageIdentity packageIdentity, Stream packageStream, PackageDownloadContext downloadContext, CancellationToken token);
}
public static class NuGet.Protocol.GlobalPackagesFolderUtility : object {
    private static int BufferSize;
    public static DownloadResourceResult GetPackage(PackageIdentity packageIdentity, string globalPackagesFolder);
    private static DownloadResourceResult CreateDownloadResourceResult(string nupkgPath, string installPath);
    [AsyncStateMachineAttribute("NuGet.Protocol.GlobalPackagesFolderUtility/<AddPackageAsync>d__3")]
public static Task`1<DownloadResourceResult> AddPackageAsync(string source, PackageIdentity packageIdentity, Stream packageStream, string globalPackagesFolder, Guid parentId, ClientPolicyContext clientPolicyContext, ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.HttpCacheResult : object {
    [CompilerGeneratedAttribute]
private TimeSpan <MaxAge>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheFile>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    public TimeSpan MaxAge { get; }
    public string NewFile { get; }
    public string CacheFile { get; }
    public Stream Stream { get; public set; }
    public HttpCacheResult(TimeSpan maxAge, string newFile, string cacheFule);
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxAge();
    [CompilerGeneratedAttribute]
public string get_NewFile();
    [CompilerGeneratedAttribute]
public string get_CacheFile();
    [CompilerGeneratedAttribute]
public Stream get_Stream();
    [CompilerGeneratedAttribute]
public void set_Stream(Stream value);
}
public static class NuGet.Protocol.HttpCacheUtility : object {
    private static int BufferSize;
    public static HttpCacheResult InitializeHttpCacheResult(string httpCacheDirectory, Uri sourceUri, string cacheKey, HttpSourceCacheContext context);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpCacheUtility/<CreateCacheFileAsync>d__2")]
public static Task CreateCacheFileAsync(HttpCacheResult result, HttpResponseMessage response, Action`1<Stream> ensureValidContents, CancellationToken cancellationToken);
}
public class NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource : FindPackageByIdResource {
    private static int DefaultMaxRetries;
    private int _maxRetries;
    private HttpSource _httpSource;
    private ConcurrentDictionary`2<string, AsyncLazy`1<SortedDictionary`2<NuGetVersion, PackageInfo>>> _packageInfoCache;
    private IReadOnlyList`1<Uri> _baseUris;
    private FindPackagesByIdNupkgDownloader _nupkgDownloader;
    private EnhancedHttpRetryHelper _enhancedHttpRetryHelper;
    private static string ResourceTypeName;
    private static string ThisTypeName;
    public HttpFileSystemBasedFindPackageByIdResource(IReadOnlyList`1<Uri> baseUris, HttpSource httpSource);
    internal HttpFileSystemBasedFindPackageByIdResource(IReadOnlyList`1<Uri> baseUris, HttpSource httpSource, IEnvironmentVariableReader environmentVariableReader);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<GetAllVersionsAsync>d__11")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<GetDependencyInfoAsync>d__12")]
public virtual Task`1<FindPackageByIdDependencyInfo> GetDependencyInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<CopyNupkgToStreamAsync>d__13")]
public virtual Task`1<bool> CopyNupkgToStreamAsync(string id, NuGetVersion version, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<GetPackageDownloaderAsync>d__14")]
public virtual Task`1<IPackageDownloader> GetPackageDownloaderAsync(PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<DoesPackageExistAsync>d__15")]
public virtual Task`1<bool> DoesPackageExistAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<EnsurePackagesAsync>d__16")]
private Task`1<SortedDictionary`2<NuGetVersion, PackageInfo>> EnsurePackagesAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<FindPackagesByIdAsync>d__17")]
private Task`1<SortedDictionary`2<NuGetVersion, PackageInfo>> FindPackagesByIdAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<ConsumeFlatContainerIndexAsync>d__18")]
private Task`1<SortedDictionary`2<NuGetVersion, PackageInfo>> ConsumeFlatContainerIndexAsync(Stream stream, string id, string baseUri, CancellationToken token);
    private PackageInfo BuildModel(string baseUri, string id, string version);
}
public class NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository sourceRepository, CancellationToken token);
}
public class NuGet.Protocol.HttpHandlerResourceV3 : HttpHandlerResource {
    private HttpClientHandler _clientHandler;
    private HttpMessageHandler _messageHandler;
    [CompilerGeneratedAttribute]
private static Lazy`1<ICredentialService> <CredentialService>k__BackingField;
    [CompilerGeneratedAttribute]
private static Action`2<Uri, ICredentials> <CredentialsSuccessfullyUsed>k__BackingField;
    public HttpClientHandler ClientHandler { get; }
    public HttpMessageHandler MessageHandler { get; }
    public static Lazy`1<ICredentialService> CredentialService { get; public set; }
    public static Action`2<Uri, ICredentials> CredentialsSuccessfullyUsed { get; public set; }
    public HttpHandlerResourceV3(HttpClientHandler clientHandler, HttpMessageHandler messageHandler);
    public virtual HttpClientHandler get_ClientHandler();
    public virtual HttpMessageHandler get_MessageHandler();
    [CompilerGeneratedAttribute]
public static Lazy`1<ICredentialService> get_CredentialService();
    [CompilerGeneratedAttribute]
public static void set_CredentialService(Lazy`1<ICredentialService> value);
    [CompilerGeneratedAttribute]
public static Action`2<Uri, ICredentials> get_CredentialsSuccessfullyUsed();
    [CompilerGeneratedAttribute]
public static void set_CredentialsSuccessfullyUsed(Action`2<Uri, ICredentials> value);
}
public class NuGet.Protocol.HttpHandlerResourceV3Provider : ResourceProvider {
    private IProxyCache _proxyCache;
    internal HttpHandlerResourceV3Provider(IProxyCache proxyCache);
    public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
    private HttpHandlerResourceV3 CreateResource(PackageSource packageSource);
}
public class NuGet.Protocol.HttpRequestMessageConfiguration : object {
    public static HttpRequestMessageConfiguration Default;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PromptOn403>k__BackingField;
    public ILogger Logger { get; }
    public bool PromptOn403 { get; }
    public HttpRequestMessageConfiguration(ILogger logger, bool promptOn403);
    private static HttpRequestMessageConfiguration();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public bool get_PromptOn403();
}
[ExtensionAttribute]
public static class NuGet.Protocol.HttpRequestMessageExtensions : object {
    private static string NuGetConfigurationKey;
    [ExtensionAttribute]
internal static HttpRequestMessage Clone(HttpRequestMessage request);
    [ExtensionAttribute]
public static HttpRequestMessageConfiguration GetOrCreateConfiguration(HttpRequestMessage request);
    [ExtensionAttribute]
public static void SetConfiguration(HttpRequestMessage request, HttpRequestMessageConfiguration configuration);
    [ExtensionAttribute]
private static T GetProperty(HttpRequestMessage request, string key);
}
public static class NuGet.Protocol.HttpRequestMessageFactory : object {
    public static HttpRequestMessage Create(HttpMethod method, string requestUri, ILogger log);
    public static HttpRequestMessage Create(HttpMethod method, Uri requestUri, ILogger log);
    public static HttpRequestMessage Create(HttpMethod method, string requestUri, HttpRequestMessageConfiguration configuration);
    public static HttpRequestMessage Create(HttpMethod method, Uri requestUri, HttpRequestMessageConfiguration configuration);
}
[ExtensionAttribute]
public static class NuGet.Protocol.HttpResponseMessageExtensions : object {
    [ExtensionAttribute]
public static void LogServerWarning(HttpResponseMessage response, ILogger log);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Protocol.HttpRetryHandler : object {
    private EnhancedHttpRetryHelper _enhancedHttpRetryHelper;
    internal static string StopwatchPropertyName;
    internal HttpRetryHandler(IEnvironmentVariableReader environmentVariableReader);
    public sealed virtual Task`1<HttpResponseMessage> SendAsync(HttpRetryHandlerRequest request, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpRetryHandler/<SendAsync>d__5")]
public sealed virtual Task`1<HttpResponseMessage> SendAsync(HttpRetryHandlerRequest request, string source, ILogger log, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static Nullable`1<TimeSpan> GetRetryAfter(RetryConditionHeaderValue retryAfter);
}
public class NuGet.Protocol.HttpRetryHandlerRequest : object {
    public static int DefaultMaxTries;
    public static TimeSpan DefaultDownloadTimeout;
    [CompilerGeneratedAttribute]
private HttpClient <HttpClient>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<HttpRequestMessage> <RequestFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpCompletionOption <CompletionOption>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTries>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RetryDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <DownloadTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<KeyValuePair`2<string, IEnumerable`1<string>>> <AddHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRetry>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLastAttempt>k__BackingField;
    public HttpClient HttpClient { get; }
    public Func`1<HttpRequestMessage> RequestFactory { get; }
    public HttpCompletionOption CompletionOption { get; public set; }
    public int MaxTries { get; public set; }
    public TimeSpan RequestTimeout { get; public set; }
    public TimeSpan RetryDelay { get; public set; }
    public TimeSpan DownloadTimeout { get; public set; }
    public IList`1<KeyValuePair`2<string, IEnumerable`1<string>>> AddHeaders { get; public set; }
    public bool IsRetry { get; public set; }
    public bool IsLastAttempt { get; public set; }
    public HttpRetryHandlerRequest(HttpClient httpClient, Func`1<HttpRequestMessage> requestFactory);
    private static HttpRetryHandlerRequest();
    [CompilerGeneratedAttribute]
public HttpClient get_HttpClient();
    [CompilerGeneratedAttribute]
public Func`1<HttpRequestMessage> get_RequestFactory();
    [CompilerGeneratedAttribute]
public HttpCompletionOption get_CompletionOption();
    [CompilerGeneratedAttribute]
public void set_CompletionOption(HttpCompletionOption value);
    [CompilerGeneratedAttribute]
public int get_MaxTries();
    [CompilerGeneratedAttribute]
public void set_MaxTries(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RetryDelay();
    [CompilerGeneratedAttribute]
public void set_RetryDelay(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_DownloadTimeout();
    [CompilerGeneratedAttribute]
public void set_DownloadTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public IList`1<KeyValuePair`2<string, IEnumerable`1<string>>> get_AddHeaders();
    [CompilerGeneratedAttribute]
public void set_AddHeaders(IList`1<KeyValuePair`2<string, IEnumerable`1<string>>> value);
    [CompilerGeneratedAttribute]
public bool get_IsRetry();
    [CompilerGeneratedAttribute]
public void set_IsRetry(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsLastAttempt();
    [CompilerGeneratedAttribute]
public void set_IsLastAttempt(bool value);
}
public class NuGet.Protocol.HttpSource : object {
    private Func`1<Task`1<HttpHandlerResource>> _messageHandlerFactory;
    private Uri _sourceUri;
    private HttpClient _httpClient;
    private string _httpCacheDirectory;
    private PackageSource _packageSource;
    private IThrottle _throttle;
    private bool _disposed;
    private SemaphoreSlim _httpClientLock;
    [CompilerGeneratedAttribute]
private IHttpRetryHandler <RetryHandler>k__BackingField;
    public IHttpRetryHandler RetryHandler { get; public set; }
    public string PackageSource { get; }
    public string HttpCacheDirectory { get; public set; }
    public HttpSource(PackageSource packageSource, Func`1<Task`1<HttpHandlerResource>> messageHandlerFactory, IThrottle throttle);
    [CompilerGeneratedAttribute]
public IHttpRetryHandler get_RetryHandler();
    [CompilerGeneratedAttribute]
public void set_RetryHandler(IHttpRetryHandler value);
    public string get_PackageSource();
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<GetAsync>d__15`1")]
public virtual Task`1<T> GetAsync(HttpSourceCachedRequest request, Func`2<HttpSourceResult, Task`1<T>> processAsync, ILogger log, CancellationToken token);
    public Task`1<T> ProcessStreamAsync(HttpSourceRequest request, Func`2<Stream, Task`1<T>> processAsync, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<ProcessHttpStreamAsync>d__17`1")]
internal Task`1<T> ProcessHttpStreamAsync(HttpSourceRequest request, Func`2<HttpResponseMessage, Task`1<T>> processAsync, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<ProcessStreamAsync>d__18`1")]
public Task`1<T> ProcessStreamAsync(HttpSourceRequest request, Func`2<Stream, Task`1<T>> processAsync, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    public Task`1<T> ProcessResponseAsync(HttpSourceRequest request, Func`2<HttpResponseMessage, Task`1<T>> processAsync, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<ProcessResponseAsync>d__20`1")]
public Task`1<T> ProcessResponseAsync(HttpSourceRequest request, Func`2<HttpResponseMessage, Task`1<T>> processAsync, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<GetJObjectAsync>d__21")]
public Task`1<JObject> GetJObjectAsync(HttpSourceRequest request, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<GetThrottledResponse>d__22")]
private Task`1<ThrottledResponse> GetThrottledResponse(Func`1<HttpRequestMessage> requestFactory, TimeSpan requestTimeout, TimeSpan downloadTimeout, int maxTries, bool isRetry, bool isLastAttempt, Guid sessionId, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<EnsureHttpClientAsync>d__23")]
private Task EnsureHttpClientAsync();
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<CreateHttpClientAsync>d__24")]
private Task`1<HttpClient> CreateHttpClientAsync();
    public string get_HttpCacheDirectory();
    public void set_HttpCacheDirectory(string value);
    protected virtual Stream TryReadCacheFile(string uri, TimeSpan maxAge, string cacheFile);
    public static HttpSource Create(SourceRepository source);
    public static HttpSource Create(SourceRepository source, IThrottle throttle);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private Task`1<ThrottledResponse> <ProcessResponseAsync>g__throttledResponseFactory|20_0(<>c__DisplayClass20_0`1& );
}
public class NuGet.Protocol.HttpSourceAuthenticationHandler : DelegatingHandler {
    public static int MaxAuthRetries;
    private static SemaphoreSlim _credentialPromptLock;
    private PackageSource _packageSource;
    private HttpClientHandler _clientHandler;
    private ICredentialService _credentialService;
    private SemaphoreSlim _httpClientLock;
    private Dictionary`2<string, AmbientAuthenticationState> _authStates;
    private HttpSourceCredentials _credentials;
    private bool _isDisposed;
    public HttpSourceAuthenticationHandler(PackageSource packageSource, HttpClientHandler clientHandler, ICredentialService credentialService);
    private static HttpSourceAuthenticationHandler();
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSourceAuthenticationHandler/<SendAsync>d__10")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSourceAuthenticationHandler/<AcquireCredentialsAsync>d__11")]
private Task`1<ICredentials> AcquireCredentialsAsync(HttpStatusCode statusCode, Guid credentialsVersion, ILogger log, bool areLastKnownGoodCredentialsTried, CancellationToken cancellationToken);
    private AmbientAuthenticationState GetAuthenticationState();
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSourceAuthenticationHandler/<PromptForCredentialsAsync>d__13")]
private Task`1<ICredentials> PromptForCredentialsAsync(CredentialRequestType type, string message, AmbientAuthenticationState authState, ILogger log, CancellationToken token);
    private void CredentialsSuccessfullyUsed(Uri uri, ICredentials credentials);
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
public class NuGet.Protocol.HttpSourceCachedRequest : object {
    [CompilerGeneratedAttribute]
private string <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheKey>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpSourceCacheContext <CacheContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<MediaTypeWithQualityHeaderValue> <AcceptHeaderValues>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreNotFounds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTries>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<Stream> <EnsureValidContents>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <DownloadTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRetry>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLastAttempt>k__BackingField;
    public string Uri { get; }
    public string CacheKey { get; }
    public HttpSourceCacheContext CacheContext { get; }
    public IList`1<MediaTypeWithQualityHeaderValue> AcceptHeaderValues { get; }
    public bool IgnoreNotFounds { get; public set; }
    public int MaxTries { get; public set; }
    public Action`1<Stream> EnsureValidContents { get; public set; }
    public TimeSpan RequestTimeout { get; public set; }
    public TimeSpan DownloadTimeout { get; public set; }
    public bool IsRetry { get; public set; }
    public bool IsLastAttempt { get; public set; }
    public HttpSourceCachedRequest(string uri, string cacheKey, HttpSourceCacheContext cacheContext);
    [CompilerGeneratedAttribute]
public string get_Uri();
    [CompilerGeneratedAttribute]
public string get_CacheKey();
    [CompilerGeneratedAttribute]
public HttpSourceCacheContext get_CacheContext();
    [CompilerGeneratedAttribute]
public IList`1<MediaTypeWithQualityHeaderValue> get_AcceptHeaderValues();
    [CompilerGeneratedAttribute]
public bool get_IgnoreNotFounds();
    [CompilerGeneratedAttribute]
public void set_IgnoreNotFounds(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxTries();
    [CompilerGeneratedAttribute]
public void set_MaxTries(int value);
    [CompilerGeneratedAttribute]
public Action`1<Stream> get_EnsureValidContents();
    [CompilerGeneratedAttribute]
public void set_EnsureValidContents(Action`1<Stream> value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_DownloadTimeout();
    [CompilerGeneratedAttribute]
public void set_DownloadTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_IsRetry();
    [CompilerGeneratedAttribute]
public void set_IsRetry(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsLastAttempt();
    [CompilerGeneratedAttribute]
public void set_IsLastAttempt(bool value);
}
public class NuGet.Protocol.HttpSourceCredentials : CredentialCache {
    private VersionedCredentials modreq(System.Runtime.CompilerServices.IsVolatile) _credentials;
    public ICredentials Credentials { get; public set; }
    public Guid Version { get; }
    public HttpSourceCredentials(ICredentials credentials);
    public ICredentials get_Credentials();
    public void set_Credentials(ICredentials value);
    public Guid get_Version();
    private sealed virtual override NetworkCredential System.Net.ICredentials.GetCredential(Uri uri, string authType);
}
public class NuGet.Protocol.HttpSourceRequest : object {
    public static TimeSpan DefaultRequestTimeout;
    [CompilerGeneratedAttribute]
private Func`1<HttpRequestMessage> <RequestFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreNotFounds>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTries>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <DownloadTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRetry>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLastAttempt>k__BackingField;
    public Func`1<HttpRequestMessage> RequestFactory { get; }
    public bool IgnoreNotFounds { get; public set; }
    public TimeSpan RequestTimeout { get; public set; }
    public int MaxTries { get; public set; }
    public TimeSpan DownloadTimeout { get; public set; }
    public bool IsRetry { get; public set; }
    public bool IsLastAttempt { get; public set; }
    public HttpSourceRequest(string uri, ILogger log);
    public HttpSourceRequest(Uri uri, ILogger log);
    public HttpSourceRequest(Func`1<HttpRequestMessage> requestFactory);
    private static HttpSourceRequest();
    [CompilerGeneratedAttribute]
public Func`1<HttpRequestMessage> get_RequestFactory();
    [CompilerGeneratedAttribute]
public bool get_IgnoreNotFounds();
    [CompilerGeneratedAttribute]
public void set_IgnoreNotFounds(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public int get_MaxTries();
    [CompilerGeneratedAttribute]
public void set_MaxTries(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_DownloadTimeout();
    [CompilerGeneratedAttribute]
public void set_DownloadTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_IsRetry();
    [CompilerGeneratedAttribute]
public void set_IsRetry(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsLastAttempt();
    [CompilerGeneratedAttribute]
public void set_IsLastAttempt(bool value);
}
public class NuGet.Protocol.HttpSourceResource : object {
    [CompilerGeneratedAttribute]
private HttpSource <HttpSource>k__BackingField;
    public HttpSource HttpSource { get; }
    public HttpSourceResource(HttpSource httpSource);
    [CompilerGeneratedAttribute]
public HttpSource get_HttpSource();
}
public class NuGet.Protocol.HttpSourceResourceProvider : ResourceProvider {
    private static int DefaultMaxHttpRequestsPerSource;
    private ConcurrentDictionary`2<PackageSource, HttpSourceResource> _cache;
    [CompilerGeneratedAttribute]
private static IThrottle <Throttle>k__BackingField;
    public static IThrottle Throttle { get; public set; }
    [CompilerGeneratedAttribute]
public static IThrottle get_Throttle();
    [CompilerGeneratedAttribute]
public static void set_Throttle(IThrottle value);
    public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.HttpSourceResult : object {
    private bool _disposed;
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpSourceResultStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheFile>k__BackingField;
    public Stream Stream { get; private set; }
    public HttpSourceResultStatus Status { get; }
    public string CacheFile { get; }
    public HttpSourceResult(HttpSourceResultStatus status);
    public HttpSourceResult(HttpSourceResultStatus status, string cacheFileName, Stream stream);
    [CompilerGeneratedAttribute]
public Stream get_Stream();
    [CompilerGeneratedAttribute]
private void set_Stream(Stream value);
    [CompilerGeneratedAttribute]
public HttpSourceResultStatus get_Status();
    [CompilerGeneratedAttribute]
public string get_CacheFile();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public enum NuGet.Protocol.HttpSourceResultStatus : Enum {
    public int value__;
    public static HttpSourceResultStatus NotFound;
    public static HttpSourceResultStatus NoContent;
    public static HttpSourceResultStatus OpenedFromDisk;
    public static HttpSourceResultStatus OpenedFromNetwork;
}
public static class NuGet.Protocol.HttpStreamValidation : object {
    public static void ValidateJObject(string uri, Stream stream);
    public static void ValidateNupkg(string uri, Stream stream);
    public static void ValidateXml(string uri, Stream stream);
}
public interface NuGet.Protocol.IHttpRetryHandler {
    public abstract virtual Task`1<HttpResponseMessage> SendAsync(HttpRetryHandlerRequest request, ILogger log, CancellationToken cancellationToken);
    public abstract virtual Task`1<HttpResponseMessage> SendAsync(HttpRetryHandlerRequest request, string sourceUri, ILogger log, CancellationToken cancellationToken);
}
public abstract class NuGet.Protocol.InvalidCacheProtocolException : FatalProtocolException {
    public InvalidCacheProtocolException(string message);
    public InvalidCacheProtocolException(string message, Exception innerException);
    protected InvalidCacheProtocolException(SerializationInfo info, StreamingContext context);
}
public interface NuGet.Protocol.IThrottle {
    public abstract virtual Task WaitAsync();
    public abstract virtual void Release();
}
public interface NuGet.Protocol.IV2FeedParser {
    public abstract virtual Task`1<V2FeedPage> GetPackagesPageAsync(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken token);
    public abstract virtual Task`1<V2FeedPage> GetSearchPageAsync(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken token);
}
public interface NuGet.Protocol.IVulnerabilityInfoResource {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<GetVulnerabilityInfoResult> GetVulnerabilityInfoAsync(SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class NuGet.Protocol.JsonExtensions : object {
    public static int JsonSerializationMaxDepth;
    public static JsonSerializerSettings ObjectSerializationSettings;
    internal static JsonSerializer JsonObjectSerializer;
    internal static JsonSerializerOptions JsonSerializerOptions;
    private static JsonExtensions();
    private static JsonSerializerOptions CreateJsonSerializerOptions();
    [ExtensionAttribute]
public static string ToJson(object obj, Formatting formatting);
    [ExtensionAttribute]
public static T FromJson(string json);
    [ExtensionAttribute]
public static T FromJson(string json, JsonSerializerSettings settings);
    [ExtensionAttribute]
public static object FromJson(string json, Type type);
    [ExtensionAttribute]
public static JToken ToJToken(object obj);
    [ExtensionAttribute]
public static T FromJToken(JToken jtoken);
    [ExtensionAttribute]
public static object FromJToken(JToken jtoken, Type type);
    [ExtensionAttribute]
public static T GetJObjectProperty(JObject jobject, string propertyName);
    [ExtensionAttribute]
public static Nullable`1<bool> GetBoolean(JObject json, string propertyName);
}
public static class NuGet.Protocol.JsonProperties : object {
    public static string Data;
    public static string SubjectId;
    public static string Type;
    public static string PackageId;
    public static string Version;
    public static string Title;
    public static string Summary;
    public static string Description;
    public static string Authors;
    public static string Owners;
    public static string IconUrl;
    public static string LicenseUrl;
    public static string LicenseExpression;
    public static string LicenseExpressionVersion;
    public static string ProjectUrl;
    public static string ReadmeUrl;
    public static string Tags;
    public static string DownloadCount;
    public static string Created;
    public static string LastEdited;
    public static string Published;
    public static string RequireLicenseAcceptance;
    public static string DependencyGroups;
    public static string LatestVersion;
    public static string TargetFramework;
    public static string Dependencies;
    public static string Range;
    public static string MinimumClientVersion;
    public static string Language;
    public static string PackageContent;
    public static string Versions;
    public static string PrefixReserved;
    public static string Listed;
    public static string Subject;
    public static string Issuer;
    public static string NotBefore;
    public static string NotAfter;
    public static string ContentUrl;
    public static string SigningCertificates;
    public static string AllRepositorySigned;
    public static string Fingerprints;
    public static string Deprecation;
    public static string DeprecationMessage;
    public static string DeprecationReasons;
    public static string AlternatePackage;
    public static string Vulnerabilities;
    public static string AdvisoryUrl;
    public static string Severity;
    public static string Url;
}
internal static class NuGet.Protocol.JsonUtility : object {
    internal static JsonLoadSettings DefaultLoadSettings;
    private static JsonUtility();
    internal static JObject LoadJson(TextReader reader);
    internal static JObject LoadJson(JsonReader jsonReader);
}
public class NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed : LegacyFeedCapabilityResource {
    private static ConcurrentDictionary`2<string, Task`1<Capabilities>> CachedCapabilities;
    private static string MetadataUriFormat;
    private string _metadataUri;
    private V2FeedParser _feedParser;
    public LegacyFeedCapabilityResourceV2Feed(V2FeedParser feedParser, string baseAddress);
    private static LegacyFeedCapabilityResourceV2Feed();
    [AsyncStateMachineAttribute("NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed/<SupportsIsAbsoluteLatestVersionAsync>d__5")]
public virtual Task`1<bool> SupportsIsAbsoluteLatestVersionAsync(ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed/<SupportsSearchAsync>d__6")]
public virtual Task`1<bool> SupportsSearchAsync(ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed/<GetCachedCapabilitiesAsync>d__7")]
private Task`1<Capabilities> GetCachedCapabilitiesAsync(ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed/<GetCapabilitiesAsync>d__8")]
private Task`1<Capabilities> GetCapabilitiesAsync(string metadataUri, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.LocalAutoCompleteResource : AutoCompleteResource {
    private FindLocalPackagesResource _localResource;
    public LocalAutoCompleteResource(FindLocalPackagesResource localResource);
    public virtual Task`1<IEnumerable`1<string>> IdStartsWith(string packageIdPrefix, bool includePrerelease, ILogger log, CancellationToken token);
    public virtual Task`1<IEnumerable`1<NuGetVersion>> VersionStartsWith(string packageId, string versionPrefix, bool includePrerelease, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalAutoCompleteResource/<GetPackageIdsFromLocalPackageRepository>d__4")]
private Task`1<IEnumerable`1<string>> GetPackageIdsFromLocalPackageRepository(string searchFilter, bool includePrerelease, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalAutoCompleteResource/<GetPackageVersionsFromLocalPackageRepository>d__5")]
protected Task`1<IEnumerable`1<NuGetVersion>> GetPackageVersionsFromLocalPackageRepository(string packageId, string versionPrefix, bool includePrerelease, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.LocalAutoCompleteResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalAutoCompleteResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.LocalDependencyInfoResource : DependencyInfoResource {
    private FindLocalPackagesResource _localResource;
    private SourceRepository _source;
    public LocalDependencyInfoResource(FindLocalPackagesResource localResource, SourceRepository source);
    public virtual Task`1<SourcePackageDependencyInfo> ResolvePackage(PackageIdentity package, NuGetFramework projectFramework, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public virtual Task`1<IEnumerable`1<SourcePackageDependencyInfo>> ResolvePackages(string packageId, NuGetFramework projectFramework, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    private SourcePackageDependencyInfo CreateDependencyInfo(LocalPackageInfo package, NuGetFramework projectFramework);
}
public class NuGet.Protocol.LocalDependencyInfoResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalDependencyInfoResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.LocalDownloadResource : DownloadResource {
    private FindLocalPackagesResource _localResource;
    private string _source;
    [ObsoleteAttribute("Use constructor with source parameter")]
public LocalDownloadResource(FindLocalPackagesResource localResource);
    public LocalDownloadResource(string source, FindLocalPackagesResource localResource);
    public virtual Task`1<DownloadResourceResult> GetDownloadResourceResultAsync(PackageIdentity identity, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.LocalDownloadResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalDownloadResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public static class NuGet.Protocol.LocalFolderUtility : object {
    private static string NupkgFilter;
    private static LocalFolderUtility();
    public static LocalPackageInfo GetPackage(Uri path, ILogger log);
    public static IEnumerable`1<LocalPackageInfo> GetPackagesV2(string root, ILogger log);
    public static IEnumerable`1<LocalPackageInfo> GetPackagesV2(string root, ILogger log, CancellationToken cancellationToken);
    public static IEnumerable`1<LocalPackageInfo> GetPackagesV2(string root, string id, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetPackagesV2>d__5")]
public static IEnumerable`1<LocalPackageInfo> GetPackagesV2(string root, string id, ILogger log, CancellationToken cancellationToken);
    public static LocalPackageInfo GetPackageV2(string root, string id, NuGetVersion version, ILogger log);
    public static LocalPackageInfo GetPackageV2(string root, string id, NuGetVersion version, ILogger log, CancellationToken cancellationToken);
    public static LocalPackageInfo GetPackageV2(string root, PackageIdentity identity, ILogger log);
    public static LocalPackageInfo GetPackageV2(string root, PackageIdentity identity, ILogger log, CancellationToken cancellationToken);
    public static IEnumerable`1<LocalPackageInfo> GetPackagesConfigFolderPackages(string root, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetPackagesConfigFolderPackages>d__11")]
public static IEnumerable`1<LocalPackageInfo> GetPackagesConfigFolderPackages(string root, ILogger log, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetPackagesConfigFolderPackages>d__12")]
public static IEnumerable`1<LocalPackageInfo> GetPackagesConfigFolderPackages(string root, string id, ILogger log);
    public static LocalPackageInfo GetPackagesConfigFolderPackage(string root, PackageIdentity identity, ILogger log);
    private static string GetPackagesConfigFolderSearchPattern(string id);
    public static LocalPackageInfo GetPackagesConfigFolderPackage(string root, string id, NuGetVersion version, ILogger log);
    private static LocalPackageInfo GetPackagesConfigFolderPackage(DirectoryInfo dir, ILogger log);
    public static bool IsPossiblePackageMatch(FileInfo file, PackageIdentity identity);
    public static bool IsPossiblePackageMatch(FileInfo file, string id);
    public static PackageIdentity GetIdentityFromNupkgPath(FileInfo file, string id);
    public static NuGetVersion GetVersionFromFileName(string fileName, string id, string extension);
    private static NuGetVersion GetVersionFromIdVersionString(string idVersionString, string id);
    public static LocalPackageInfo GetPackageV3(string root, string id, NuGetVersion version, ILogger log);
    public static LocalPackageInfo GetPackageV3(string root, PackageIdentity identity, ILogger log);
    public static IEnumerable`1<FileInfo> GetNupkgsFromFlatFolder(string root, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetNupkgsFromFlatFolder>d__25")]
public static IEnumerable`1<FileInfo> GetNupkgsFromFlatFolder(string root, ILogger log, CancellationToken cancellationToken);
    public static FeedType GetLocalFeedType(string root, ILogger log);
    public static DirectoryInfo GetAndVerifyRootDirectory(string root);
    private static FileInfo GetAndVerifyFileInfo(Uri fileUri);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetNupkgsFromFlatFolderChunked>d__29")]
private static IEnumerable`1<List`1<FileInfo>> GetNupkgsFromFlatFolderChunked(DirectoryInfo root, ILogger log, CancellationToken cancellationToken);
    public static IEnumerable`1<FileInfo> GetNupkgsFromFlatFolder(string root, string id, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetNupkgsFromFlatFolder>d__31")]
public static IEnumerable`1<FileInfo> GetNupkgsFromFlatFolder(string root, string id, ILogger log, CancellationToken cancellationToken);
    public static IEnumerable`1<LocalPackageInfo> GetPackagesV3(string root, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetPackagesV3>d__33")]
public static IEnumerable`1<LocalPackageInfo> GetPackagesV3(string root, ILogger log, CancellationToken cancellationToken);
    public static IEnumerable`1<LocalPackageInfo> GetPackagesV3(string root, string id, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetPackagesV3>d__35")]
public static IEnumerable`1<LocalPackageInfo> GetPackagesV3(string root, string id, ILogger log, CancellationToken cancellationToken);
    public static IEnumerable`1<string> ResolvePackageFromPath(string packagePath, bool isSnupkg);
    private static string EnsurePackageExtension(string packagePath, bool isSnupkg);
    public static void EnsurePackageFileExists(string packagePath, IEnumerable`1<string> matchingPackagePaths);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetDistinctPackages>d__39")]
public static IEnumerable`1<LocalPackageInfo> GetDistinctPackages(IEnumerable`1<LocalPackageInfo> packages);
    private static List`1<DirectoryInfo> GetDirectoriesSafe(DirectoryInfo root, ILogger log, CancellationToken cancellationToken);
    private static List`1<DirectoryInfo> GetDirectoriesSafe(DirectoryInfo root, string filter, SearchOption searchOption, ILogger log, CancellationToken cancellationToken);
    internal static List`1<FileInfo> GetFilesSafe(DirectoryInfo root, string filter, ILogger log, CancellationToken cancellationToken);
    private static IEnumerable`1<LocalPackageInfo> GetPackagesFromNupkgs(IEnumerable`1<FileInfo> files, CancellationToken cancellationToken);
    private static LocalPackageInfo GetPackageFromNupkg(FileInfo nupkgFile);
    private static List`1<FileInfo> GetNupkgsFromDirectory(DirectoryInfo root, ILogger log, CancellationToken cancellationToken);
    private static LocalPackageInfo GetPackageV3(string root, string id, string version, ILogger log);
    private static FileInfo CreateFileInfoIfValidOrNull(string localPath, ILogger log);
    public static void GenerateNupkgMetadataFile(string nupkgPath, string installPath, string hashPath, string nupkgMetadataPath);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<CancellableYieldEnumeration>d__49`1")]
private static IEnumerable`1<T> CancellableYieldEnumeration(IEnumerable`1<T> enumerable, CancellationToken cancellationToken);
}
public class NuGet.Protocol.LocalMetadataResource : MetadataResource {
    private FindLocalPackagesResource _localResource;
    public LocalMetadataResource(FindLocalPackagesResource localResource);
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalMetadataResource/<GetLatestVersions>d__2")]
public virtual Task`1<IEnumerable`1<KeyValuePair`2<string, NuGetVersion>>> GetLatestVersions(IEnumerable`1<string> packageIds, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public virtual Task`1<IEnumerable`1<NuGetVersion>> GetVersions(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public virtual Task`1<bool> Exists(PackageIdentity identity, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public virtual Task`1<bool> Exists(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.LocalMetadataResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalMetadataResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.LocalPackageArchiveDownloader : object {
    private Func`2<Exception, Task`1<bool>> _handleExceptionAsync;
    private bool _isDisposed;
    private ILogger _logger;
    private string _packageFilePath;
    private PackageIdentity _packageIdentity;
    private Lazy`1<PackageArchiveReader> _packageReader;
    private Lazy`1<FileStream> _sourceStream;
    private SemaphoreSlim _throttle;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    public IAsyncPackageContentReader ContentReader { get; }
    public IAsyncPackageCoreReader CoreReader { get; }
    public ISignedPackageReader SignedPackageReader { get; }
    public string Source { get; }
    public LocalPackageArchiveDownloader(string source, string packageFilePath, PackageIdentity packageIdentity, ILogger logger);
    public sealed virtual IAsyncPackageContentReader get_ContentReader();
    public sealed virtual IAsyncPackageCoreReader get_CoreReader();
    public sealed virtual ISignedPackageReader get_SignedPackageReader();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Source();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalPackageArchiveDownloader/<CopyNupkgFileToAsync>d__19")]
public sealed virtual Task`1<bool> CopyNupkgFileToAsync(string destinationFilePath, CancellationToken cancellationToken);
    public sealed virtual Task`1<string> GetPackageHashAsync(string hashAlgorithm, CancellationToken cancellationToken);
    public sealed virtual void SetExceptionHandler(Func`2<Exception, Task`1<bool>> handleExceptionAsync);
    public sealed virtual void SetThrottle(SemaphoreSlim throttle);
    private PackageArchiveReader GetPackageReader();
    private FileStream GetSourceStream();
    private void ThrowIfDisposed();
}
public class NuGet.Protocol.LocalPackageFileCache : object {
    private ConcurrentDictionary`2<string, Lazy`1<NuspecReader>> _nuspecCache;
    private ConcurrentDictionary`2<string, Lazy`1<IReadOnlyList`1<string>>> _filesCache;
    private ConcurrentDictionary`2<string, Lazy`1<string>> _sha512Cache;
    private ConcurrentDictionary`2<string, bool> _fileExistsCache;
    private ConcurrentDictionary`2<string, Lazy`1<RuntimeGraph>> _runtimeCache;
    private ConcurrentDictionary`2<string, bool> _metadataFileCache;
    public virtual Lazy`1<NuspecReader> GetOrAddNuspec(string manifestPath, string expandedPath);
    public virtual Lazy`1<IReadOnlyList`1<string>> GetOrAddFiles(string expandedPath);
    public virtual Lazy`1<string> GetOrAddSha512(string sha512Path);
    public virtual bool Sha512Exists(string sha512Path);
    public void UpdateLastAccessTime(string nupkgMetadataPath);
    public virtual Lazy`1<RuntimeGraph> GetOrAddRuntimeGraph(string expandedPath);
    private static IReadOnlyList`1<string> GetFiles(string expandedPath);
    private static bool IsAllowedLibraryFile(string path);
    private static NuspecReader GetNuspec(string manifestPath, string expandedPath);
    private RuntimeGraph GetRuntimeGraph(string expandedPath);
    [CompilerGeneratedAttribute]
private Lazy`1<RuntimeGraph> <GetOrAddRuntimeGraph>b__12_0(string p);
}
public class NuGet.Protocol.LocalPackageInfo : object {
    private Lazy`1<NuspecReader> _nuspecHelper;
    private Func`1<PackageReaderBase> _getPackageReader;
    [CompilerGeneratedAttribute]
private PackageIdentity <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastWriteTimeUtc>k__BackingField;
    public PackageIdentity Identity { get; }
    public string Path { get; }
    public DateTime LastWriteTimeUtc { get; }
    public NuspecReader Nuspec { get; }
    public bool IsNupkg { get; }
    [ObsoleteAttribute("use other constructor")]
public LocalPackageInfo(PackageIdentity identity, string path, DateTime lastWriteTimeUtc, Lazy`1<NuspecReader> nuspec, Func`1<PackageReaderBase> getPackageReader);
    public LocalPackageInfo(PackageIdentity identity, string path, DateTime lastWriteTimeUtc, Lazy`1<NuspecReader> nuspec, bool useFolder);
    [CompilerGeneratedAttribute]
public virtual PackageIdentity get_Identity();
    [CompilerGeneratedAttribute]
public virtual string get_Path();
    [CompilerGeneratedAttribute]
public virtual DateTime get_LastWriteTimeUtc();
    public virtual PackageReaderBase GetReader();
    public virtual NuspecReader get_Nuspec();
    public virtual bool get_IsNupkg();
}
public class NuGet.Protocol.LocalPackageListResource : ListResource {
    private PackageSearchResource _localPackageSearchResource;
    private string _baseAddress;
    public string Source { get; }
    public LocalPackageListResource(PackageSearchResource localPackageSearchResource, string baseAddress);
    public virtual string get_Source();
    public virtual Task`1<IEnumerableAsync`1<IPackageSearchMetadata>> ListAsync(string searchTerm, bool prerelease, bool allVersions, bool includeDelisted, ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.LocalPackageMetadataResource : PackageMetadataResource {
    private FindLocalPackagesResource _localResource;
    public LocalPackageMetadataResource(FindLocalPackagesResource localResource);
    public virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> GetMetadataAsync(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public virtual Task`1<IPackageSearchMetadata> GetMetadataAsync(PackageIdentity package, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    private static IPackageSearchMetadata GetPackageMetadata(LocalPackageInfo package);
}
public class NuGet.Protocol.LocalPackageMetadataResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalPackageMetadataResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.LocalPackageSearchMetadata : object {
    private NuspecReader _nuspec;
    private LocalPackageInfo _package;
    private IReadOnlyList`1<string> _ownersList;
    private static int FiveMegabytes;
    public string Authors { get; }
    public IEnumerable`1<PackageDependencyGroup> DependencySets { get; }
    public string Description { get; }
    public Nullable`1<long> DownloadCount { get; }
    public Uri IconUrl { get; }
    public PackageIdentity Identity { get; }
    public Uri LicenseUrl { get; }
    public IReadOnlyList`1<string> OwnersList { get; }
    public string Owners { get; }
    public Uri ProjectUrl { get; }
    public Nullable`1<DateTimeOffset> Published { get; }
    public Uri ReadmeUrl { get; }
    public Uri ReportAbuseUrl { get; }
    public Uri PackageDetailsUrl { get; }
    public bool RequireLicenseAcceptance { get; }
    public string Summary { get; }
    public string Tags { get; }
    public string Title { get; }
    public Func`1<PackageReaderBase> PackageReader { get; }
    public bool IsListed { get; }
    public bool PrefixReserved { get; }
    public LicenseMetadata LicenseMetadata { get; }
    public IEnumerable`1<PackageVulnerabilityMetadata> Vulnerabilities { get; }
    public string PackagePath { get; }
    public LocalPackageSearchMetadata(LocalPackageInfo package);
    public sealed virtual string get_Authors();
    public sealed virtual IEnumerable`1<PackageDependencyGroup> get_DependencySets();
    public sealed virtual string get_Description();
    public sealed virtual Nullable`1<long> get_DownloadCount();
    public sealed virtual Uri get_IconUrl();
    public sealed virtual PackageIdentity get_Identity();
    public sealed virtual Uri get_LicenseUrl();
    public sealed virtual IReadOnlyList`1<string> get_OwnersList();
    public sealed virtual string get_Owners();
    public sealed virtual Uri get_ProjectUrl();
    public sealed virtual Nullable`1<DateTimeOffset> get_Published();
    public sealed virtual Uri get_ReadmeUrl();
    public sealed virtual Uri get_ReportAbuseUrl();
    public sealed virtual Uri get_PackageDetailsUrl();
    public sealed virtual bool get_RequireLicenseAcceptance();
    public sealed virtual string get_Summary();
    public sealed virtual string get_Tags();
    public sealed virtual string get_Title();
    public Func`1<PackageReaderBase> get_PackageReader();
    public sealed virtual Task`1<IEnumerable`1<VersionInfo>> GetVersionsAsync();
    private static Uri Convert(string uri);
    public sealed virtual bool get_IsListed();
    public sealed virtual bool get_PrefixReserved();
    public sealed virtual LicenseMetadata get_LicenseMetadata();
    public sealed virtual Task`1<PackageDeprecationMetadata> GetDeprecationMetadataAsync();
    public sealed virtual IEnumerable`1<PackageVulnerabilityMetadata> get_Vulnerabilities();
    public string get_PackagePath();
    public string LoadFileAsText(string path);
    private Uri GetIconUri();
    [CompilerGeneratedAttribute]
private PackageReaderBase <get_PackageReader>b__41_0();
}
public class NuGet.Protocol.LocalPackageSearchResource : PackageSearchResource {
    private FindLocalPackagesResource _localResource;
    public LocalPackageSearchResource(FindLocalPackagesResource localResource);
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalPackageSearchResource/<SearchAsync>d__2")]
public virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> SearchAsync(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken token);
    private static bool ContainsAnyTerm(String[] terms, LocalPackageInfo package);
    private static bool ContainsTerm(string search, string property);
    private IPackageSearchMetadata CreatePackageSearchResult(LocalPackageInfo package, SearchFilter filter, ILogger log, CancellationToken cancellationToken);
    private static List`1<VersionInfo> GetVersions(FindLocalPackagesResource localResource, LocalPackageInfo package, SearchFilter filter, ILogger log, CancellationToken token);
    private static bool IsLocalOrUNC(string currentSource);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalPackageSearchResource/<CollapseToHighestVersion>d__8")]
private static IEnumerable`1<LocalPackageInfo> CollapseToHighestVersion(IEnumerable`1<LocalPackageInfo> source);
}
public class NuGet.Protocol.LocalPackageSearchResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalPackageSearchResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.LocalRepositories.LocalPackageListResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalRepositories.LocalPackageListResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.LocalV2FindPackageByIdResource : FindPackageByIdResource {
    private ConcurrentDictionary`2<string, IReadOnlyList`1<LocalPackageInfo>> _packageInfoCache;
    private string _source;
    private static string ResourceTypeName;
    private static string ThisTypeName;
    public LocalV2FindPackageByIdResource(PackageSource packageSource);
    public virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalV2FindPackageByIdResource/<CopyNupkgToStreamAsync>d__6")]
public virtual Task`1<bool> CopyNupkgToStreamAsync(string id, NuGetVersion version, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public virtual Task`1<FindPackageByIdDependencyInfo> GetDependencyInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    private LocalPackageInfo GetPackageInfo(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger);
    public virtual Task`1<IPackageDownloader> GetPackageDownloaderAsync(PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public virtual Task`1<bool> DoesPackageExistAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    private IReadOnlyList`1<LocalPackageInfo> GetPackageInfos(string id, SourceCacheContext cacheContext, ILogger logger);
    private IReadOnlyList`1<LocalPackageInfo> GetPackageInfosCore(string id, ILogger logger);
}
public class NuGet.Protocol.LocalV2FindPackageByIdResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalV2FindPackageByIdResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.LocalV3FindPackageByIdResource : FindPackageByIdResource {
    private ConcurrentDictionary`2<string, List`1<NuGetVersion>> _cache;
    private string _source;
    private VersionFolderPathResolver _resolver;
    private LocalPackageFileCache _packageFileCache;
    private Lazy`1<bool> _rootExists;
    private bool _isFallbackFolder;
    private static string ResourceTypeName;
    private static string ThisTypeName;
    public LocalPackageFileCache PackageFileCache { get; public set; }
    public bool IsFallbackFolder { get; public set; }
    public LocalV3FindPackageByIdResource(PackageSource packageSource);
    public LocalPackageFileCache get_PackageFileCache();
    public void set_PackageFileCache(LocalPackageFileCache value);
    public bool get_IsFallbackFolder();
    public void set_IsFallbackFolder(bool value);
    public virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalV3FindPackageByIdResource/<CopyNupkgToStreamAsync>d__16")]
public virtual Task`1<bool> CopyNupkgToStreamAsync(string id, NuGetVersion version, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public virtual Task`1<FindPackageByIdDependencyInfo> GetDependencyInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public virtual Task`1<IPackageDownloader> GetPackageDownloaderAsync(PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public virtual Task`1<bool> DoesPackageExistAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    private T ProcessNuspecReader(string id, NuGetVersion version, Func`2<NuspecReader, T> process);
    private bool DoesVersionExist(string id, NuGetVersion version);
    private List`1<NuGetVersion> GetVersions(string id, SourceCacheContext cacheContext, ILogger logger);
    private List`1<NuGetVersion> GetVersionsCore(string id, ILogger logger);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__14_0();
}
public class NuGet.Protocol.LocalV3FindPackageByIdResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalV3FindPackageByIdResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.MetadataFieldConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NuGet.Protocol.MetadataReferenceCache : object {
    private Dictionary`2<string, string> _stringCache;
    private Dictionary`2<Type, PropertyInfo[]> _propertyCache;
    private Dictionary`2<string, NuGetVersion> _versionCache;
    private Type _metadataReferenceCacheType;
    private static IDictionary`2<Type, string> CachableTypesMap;
    [CompilerGeneratedAttribute]
private Dictionary`2<Type, MethodInfo> <CachableMethodTypes>k__BackingField;
    internal static IEnumerable`1<Type> CachableTypes { get; }
    internal Dictionary`2<Type, MethodInfo> CachableMethodTypes { get; }
    private static MetadataReferenceCache();
    public string GetString(string s);
    public NuGetVersion GetVersion(string s);
    internal static IEnumerable`1<Type> get_CachableTypes();
    [CompilerGeneratedAttribute]
internal Dictionary`2<Type, MethodInfo> get_CachableMethodTypes();
    public T GetObject(T input);
}
public class NuGet.Protocol.MetadataResourceV2Feed : MetadataResource {
    private V2FeedParser _feedParser;
    private SourceRepository _source;
    public MetadataResourceV2Feed(V2FeedParser feedParser, SourceRepository source);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV2Feed/<GetLatestVersions>d__3")]
public virtual Task`1<IEnumerable`1<KeyValuePair`2<string, NuGetVersion>>> GetLatestVersions(IEnumerable`1<string> packageIds, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV2Feed/<GetVersions>d__4")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> GetVersions(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV2Feed/<Exists>d__5")]
public virtual Task`1<bool> Exists(PackageIdentity identity, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV2Feed/<Exists>d__6")]
public virtual Task`1<bool> Exists(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.MetadataResourceV2FeedProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV2FeedProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.MetadataResourceV3 : MetadataResource {
    private RegistrationResourceV3 _regResource;
    public MetadataResourceV3(RegistrationResourceV3 regResource);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV3/<GetLatestVersions>d__2")]
public virtual Task`1<IEnumerable`1<KeyValuePair`2<string, NuGetVersion>>> GetLatestVersions(IEnumerable`1<string> packageIds, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV3/<Exists>d__3")]
public virtual Task`1<bool> Exists(PackageIdentity identity, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV3/<Exists>d__4")]
public virtual Task`1<bool> Exists(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV3/<GetVersions>d__5")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> GetVersions(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.MetadataResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.MetadataStringOrArrayConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
internal class NuGet.Protocol.Model.CaseInsensitiveDictionary`1 : Dictionary`2<string, TValue> {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NuGet.Protocol.Model.GetVulnerabilityInfoResult : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<IReadOnlyDictionary`2<string, IReadOnlyList`1<PackageVulnerabilityInfo>>> <KnownVulnerabilities>k__BackingField;
    [CompilerGeneratedAttribute]
private AggregateException <Exceptions>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<IReadOnlyDictionary`2<string, IReadOnlyList`1<PackageVulnerabilityInfo>>> KnownVulnerabilities { get; }
    public AggregateException Exceptions { get; }
    public GetVulnerabilityInfoResult(IReadOnlyList`1<IReadOnlyDictionary`2<string, IReadOnlyList`1<PackageVulnerabilityInfo>>> knownVulnerabilities, AggregateException exceptions);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IReadOnlyDictionary`2<string, IReadOnlyList`1<PackageVulnerabilityInfo>>> get_KnownVulnerabilities();
    [CompilerGeneratedAttribute]
public AggregateException get_Exceptions();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Protocol.Model.PackageVulnerabilityInfo : object {
    [CompilerGeneratedAttribute]
private Uri <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageVulnerabilitySeverity <Severity>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <Versions>k__BackingField;
    [JsonPropertyNameAttribute("url")]
public Uri Url { get; }
    [JsonPropertyNameAttribute("severity")]
public PackageVulnerabilitySeverity Severity { get; }
    [JsonPropertyNameAttribute("versions")]
public VersionRange Versions { get; }
    [JsonConstructorAttribute]
public PackageVulnerabilityInfo(Uri url, PackageVulnerabilitySeverity severity, VersionRange versions);
    [CompilerGeneratedAttribute]
public Uri get_Url();
    [CompilerGeneratedAttribute]
public PackageVulnerabilitySeverity get_Severity();
    [CompilerGeneratedAttribute]
public VersionRange get_Versions();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(PackageVulnerabilityInfo other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class NuGet.Protocol.Model.RegistrationIndex : object {
    [CompilerGeneratedAttribute]
private List`1<RegistrationPage> <Items>k__BackingField;
    [JsonPropertyAttribute("items")]
public List`1<RegistrationPage> Items { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<RegistrationPage> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(List`1<RegistrationPage> value);
}
internal class NuGet.Protocol.Model.RegistrationLeafItem : object {
    [CompilerGeneratedAttribute]
private PackageSearchMetadataRegistration <CatalogEntry>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <PackageContent>k__BackingField;
    [JsonPropertyAttribute("catalogEntry")]
public PackageSearchMetadataRegistration CatalogEntry { get; public set; }
    [JsonPropertyAttribute]
public Uri PackageContent { get; public set; }
    [CompilerGeneratedAttribute]
public PackageSearchMetadataRegistration get_CatalogEntry();
    [CompilerGeneratedAttribute]
public void set_CatalogEntry(PackageSearchMetadataRegistration value);
    [CompilerGeneratedAttribute]
public Uri get_PackageContent();
    [CompilerGeneratedAttribute]
public void set_PackageContent(Uri value);
}
internal class NuGet.Protocol.Model.RegistrationPage : object {
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<RegistrationLeafItem> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Lower>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Upper>k__BackingField;
    [JsonPropertyAttribute("@id")]
public string Url { get; public set; }
    [JsonPropertyAttribute("items")]
public List`1<RegistrationLeafItem> Items { get; public set; }
    [JsonPropertyAttribute("lower")]
public string Lower { get; public set; }
    [JsonPropertyAttribute("upper")]
public string Upper { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public List`1<RegistrationLeafItem> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(List`1<RegistrationLeafItem> value);
    [CompilerGeneratedAttribute]
public string get_Lower();
    [CompilerGeneratedAttribute]
public void set_Lower(string value);
    [CompilerGeneratedAttribute]
public string get_Upper();
    [CompilerGeneratedAttribute]
public void set_Upper(string value);
}
internal class NuGet.Protocol.Model.V3SearchResults : object {
    [CompilerGeneratedAttribute]
private long <TotalHits>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<PackageSearchMetadata> <Data>k__BackingField;
    [JsonPropertyAttribute("totalHits")]
public long TotalHits { get; public set; }
    [JsonPropertyAttribute("data")]
public List`1<PackageSearchMetadata> Data { get; private set; }
    [CompilerGeneratedAttribute]
public long get_TotalHits();
    [CompilerGeneratedAttribute]
public void set_TotalHits(long value);
    [CompilerGeneratedAttribute]
public List`1<PackageSearchMetadata> get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(List`1<PackageSearchMetadata> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Protocol.Model.V3VulnerabilityIndexEntry : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Updated>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [JsonPropertyNameAttribute("@name")]
public string Name { get; }
    [JsonPropertyNameAttribute("@id")]
public Uri Url { get; }
    [JsonPropertyNameAttribute("@updated")]
public string Updated { get; }
    [NullableAttribute("2")]
[JsonPropertyNameAttribute("comment")]
public string Comment { get; }
    public V3VulnerabilityIndexEntry(string name, Uri url, string updated, string comment);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Uri get_Url();
    [CompilerGeneratedAttribute]
public string get_Updated();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Comment();
}
public class NuGet.Protocol.NuGetVersionConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class NuGet.Protocol.NullThrottle : object {
    private static NullThrottle _instance;
    public static NullThrottle Instance { get; }
    private static NullThrottle();
    public static NullThrottle get_Instance();
    public sealed virtual Task WaitAsync();
    public sealed virtual void Release();
}
public class NuGet.Protocol.ODataServiceDocumentResourceV2 : object {
    private string _baseAddress;
    private DateTime _requestTime;
    public DateTime RequestTime { get; }
    public string BaseAddress { get; }
    public ODataServiceDocumentResourceV2(string baseAddress, DateTime requestTime);
    public virtual DateTime get_RequestTime();
    public string get_BaseAddress();
}
public class NuGet.Protocol.ODataServiceDocumentResourceV2Provider : ResourceProvider {
    private static TimeSpan _defaultCacheDuration;
    private ConcurrentDictionary`2<string, ODataServiceDocumentCacheInfo> _cache;
    private SemaphoreSlim _semaphore;
    [CompilerGeneratedAttribute]
private TimeSpan <MaxCacheDuration>k__BackingField;
    public TimeSpan MaxCacheDuration { get; protected set; }
    private static ODataServiceDocumentResourceV2Provider();
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxCacheDuration();
    [CompilerGeneratedAttribute]
protected void set_MaxCacheDuration(TimeSpan value);
    [AsyncStateMachineAttribute("NuGet.Protocol.ODataServiceDocumentResourceV2Provider/<TryCreate>d__8")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.PackageDependencyGroupConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private static PackageDependency LoadDependency(JToken dependency);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NuGet.Protocol.PackageDeprecationMetadata : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Reasons>k__BackingField;
    [CompilerGeneratedAttribute]
private AlternatePackageMetadata <AlternatePackage>k__BackingField;
    [JsonPropertyAttribute]
public string Message { get; internal set; }
    [JsonPropertyAttribute]
public IEnumerable`1<string> Reasons { get; internal set; }
    [JsonPropertyAttribute]
public AlternatePackageMetadata AlternatePackage { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
internal void set_Message(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Reasons();
    [CompilerGeneratedAttribute]
internal void set_Reasons(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public AlternatePackageMetadata get_AlternatePackage();
    [CompilerGeneratedAttribute]
internal void set_AlternatePackage(AlternatePackageMetadata value);
}
public class NuGet.Protocol.PackageDetailsUriResourceV3 : object {
    private string _template;
    private PackageDetailsUriResourceV3(string template);
    public static PackageDetailsUriResourceV3 CreateOrNull(string uriTemplate);
    private static bool IsValidUriTemplate(string uriTemplate);
    public Uri GetUri(string id, NuGetVersion version);
}
public class NuGet.Protocol.PackageDetailsUriResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageDetailsUriResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.PackageInfo : object {
    [CompilerGeneratedAttribute]
private RegistrationInfo <Registration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Listed>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <PackageContent>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DependencyInfo> <Dependencies>k__BackingField;
    public RegistrationInfo Registration { get; public set; }
    public bool Listed { get; public set; }
    public NuGetVersion Version { get; public set; }
    public Uri PackageContent { get; public set; }
    public IList`1<DependencyInfo> Dependencies { get; private set; }
    [CompilerGeneratedAttribute]
public RegistrationInfo get_Registration();
    [CompilerGeneratedAttribute]
public void set_Registration(RegistrationInfo value);
    [CompilerGeneratedAttribute]
public bool get_Listed();
    [CompilerGeneratedAttribute]
public void set_Listed(bool value);
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public Uri get_PackageContent();
    [CompilerGeneratedAttribute]
public void set_PackageContent(Uri value);
    [CompilerGeneratedAttribute]
public IList`1<DependencyInfo> get_Dependencies();
    [CompilerGeneratedAttribute]
private void set_Dependencies(IList`1<DependencyInfo> value);
    public virtual string ToString();
}
public class NuGet.Protocol.PackageMetadataResourceV2Feed : PackageMetadataResource {
    private HttpSource _httpSource;
    private PackageSource _packageSource;
    private V2FeedParser _feedParser;
    public PackageMetadataResourceV2Feed(HttpSourceResource httpSourceResource, string baseAddress, PackageSource packageSource);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV2Feed/<GetMetadataAsync>d__4")]
public virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> GetMetadataAsync(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV2Feed/<GetMetadataAsync>d__5")]
public virtual Task`1<IPackageSearchMetadata> GetMetadataAsync(PackageIdentity package, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.PackageMetadataResourceV2FeedProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV2FeedProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.PackageMetadataResourceV3 : PackageMetadataResource {
    private RegistrationResourceV3 _regResource;
    private ReportAbuseResourceV3 _reportAbuseResource;
    private PackageDetailsUriResourceV3 _packageDetailsUriResource;
    private HttpSource _client;
    public PackageMetadataResourceV3(HttpSource client, RegistrationResourceV3 regResource, ReportAbuseResourceV3 reportAbuseResource, PackageDetailsUriResourceV3 packageDetailsUriResource);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV3/<GetMetadataAsync>d__5")]
public virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> GetMetadataAsync(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV3/<GetMetadataAsync>d__6")]
public virtual Task`1<IPackageSearchMetadata> GetMetadataAsync(PackageIdentity package, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV3/<GetMetadataAsync>d__7")]
private Task`1<IEnumerable`1<IPackageSearchMetadata>> GetMetadataAsync(string packageId, bool includePrerelease, bool includeUnlisted, VersionRange range, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV3/<DeserializeStreamDataAsync>d__8`1")]
private Task`1<T> DeserializeStreamDataAsync(Stream stream, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV3/<LoadRegistrationIndexAsync>d__9")]
private Task`1<ValueTuple`2<RegistrationIndex, HttpSourceCacheContext>> LoadRegistrationIndexAsync(HttpSource httpSource, Uri registrationUri, string packageId, SourceCacheContext cacheContext, Func`2<HttpSourceResult, Task`1<RegistrationIndex>> processAsync, ILogger log, CancellationToken token);
    private Task`1<RegistrationPage> GetRegistratioIndexPageAsync(HttpSource httpSource, string rangeUri, string packageId, NuGetVersion lower, NuGetVersion upper, HttpSourceCacheContext httpSourceCacheContext, ILogger log, CancellationToken token);
    private void ProcessRegistrationPage(RegistrationPage registrationPage, List`1<PackageSearchMetadataRegistration> results, VersionRange range, bool includePrerelease, bool includeUnlisted, MetadataReferenceCache metadataCache);
}
public class NuGet.Protocol.PackageMetadataResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.PackageNotFoundProtocolException : InvalidCacheProtocolException {
    [CompilerGeneratedAttribute]
private PackageIdentity <PackageIdentity>k__BackingField;
    public PackageIdentity PackageIdentity { get; }
    public PackageNotFoundProtocolException(PackageIdentity package);
    public PackageNotFoundProtocolException(PackageIdentity package, Exception innerException);
    [CompilerGeneratedAttribute]
public PackageIdentity get_PackageIdentity();
    private static string GetMessage(PackageIdentity package);
}
public class NuGet.Protocol.PackageSearchMetadata : object {
    [CompilerGeneratedAttribute]
private string <Authors>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageDependencyGroup> <DependencySetsInternal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <DownloadCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <IconUrl>k__BackingField;
    private PackageIdentity _packageIdentity;
    [CompilerGeneratedAttribute]
private Uri <LicenseUrl>k__BackingField;
    private IReadOnlyList`1<string> _ownersList;
    private string _owners;
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ProjectUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Published>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ReadmeUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ReportAbuseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <PackageDetailsUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    private string _summaryValue;
    [CompilerGeneratedAttribute]
private string <Tags>k__BackingField;
    private string _titleValue;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionInfo[] <ParsedVersions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PrefixReserved>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LicenseExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LicenseExpressionVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsListed>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageDeprecationMetadata <DeprecationMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageVulnerabilityMetadata> <Vulnerabilities>k__BackingField;
    [JsonPropertyAttribute]
[JsonConverterAttribute("NuGet.Protocol.MetadataFieldConverter")]
public string Authors { get; private set; }
    [JsonPropertyAttribute]
public IEnumerable`1<PackageDependencyGroup> DependencySetsInternal { get; private set; }
    [JsonIgnoreAttribute]
public IEnumerable`1<PackageDependencyGroup> DependencySets { get; }
    [JsonPropertyAttribute]
public string Description { get; private set; }
    [JsonPropertyAttribute]
public Nullable`1<long> DownloadCount { get; private set; }
    [JsonPropertyAttribute]
public Uri IconUrl { get; private set; }
    [JsonIgnoreAttribute]
public PackageIdentity Identity { get; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("NuGet.Protocol.SafeUriConverter")]
public Uri LicenseUrl { get; private set; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("NuGet.Protocol.MetadataStringOrArrayConverter")]
public IReadOnlyList`1<string> OwnersList { get; private set; }
    public string Owners { get; }
    [JsonPropertyAttribute]
public string PackageId { get; private set; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("NuGet.Protocol.SafeUriConverter")]
public Uri ProjectUrl { get; private set; }
    [JsonPropertyAttribute]
public Nullable`1<DateTimeOffset> Published { get; private set; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("NuGet.Protocol.SafeUriConverter")]
public Uri ReadmeUrl { get; private set; }
    [JsonIgnoreAttribute]
public Uri ReportAbuseUrl { get; public set; }
    [JsonIgnoreAttribute]
public Uri PackageDetailsUrl { get; public set; }
    [JsonPropertyAttribute]
[DefaultValueAttribute("False")]
[JsonConverterAttribute("NuGet.Protocol.SafeBoolConverter")]
public bool RequireLicenseAcceptance { get; private set; }
    [JsonPropertyAttribute]
public string Summary { get; private set; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("NuGet.Protocol.MetadataFieldConverter")]
public string Tags { get; private set; }
    [JsonPropertyAttribute]
public string Title { get; private set; }
    [JsonPropertyAttribute]
public NuGetVersion Version { get; private set; }
    [JsonPropertyAttribute]
public VersionInfo[] ParsedVersions { get; private set; }
    [JsonPropertyAttribute]
public bool PrefixReserved { get; private set; }
    [JsonPropertyAttribute]
public string LicenseExpression { get; private set; }
    [JsonPropertyAttribute]
public string LicenseExpressionVersion { get; private set; }
    [JsonIgnoreAttribute]
public LicenseMetadata LicenseMetadata { get; }
    [JsonPropertyAttribute]
public bool IsListed { get; private set; }
    [JsonPropertyAttribute]
public PackageDeprecationMetadata DeprecationMetadata { get; private set; }
    [JsonPropertyAttribute]
public IEnumerable`1<PackageVulnerabilityMetadata> Vulnerabilities { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Authors();
    [CompilerGeneratedAttribute]
private void set_Authors(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<PackageDependencyGroup> get_DependencySetsInternal();
    [CompilerGeneratedAttribute]
private void set_DependencySetsInternal(IEnumerable`1<PackageDependencyGroup> value);
    public sealed virtual IEnumerable`1<PackageDependencyGroup> get_DependencySets();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<long> get_DownloadCount();
    [CompilerGeneratedAttribute]
private void set_DownloadCount(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_IconUrl();
    [CompilerGeneratedAttribute]
private void set_IconUrl(Uri value);
    public sealed virtual PackageIdentity get_Identity();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_LicenseUrl();
    [CompilerGeneratedAttribute]
private void set_LicenseUrl(Uri value);
    public sealed virtual IReadOnlyList`1<string> get_OwnersList();
    private void set_OwnersList(IReadOnlyList`1<string> value);
    public sealed virtual string get_Owners();
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
private void set_PackageId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ProjectUrl();
    [CompilerGeneratedAttribute]
private void set_ProjectUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTimeOffset> get_Published();
    [CompilerGeneratedAttribute]
private void set_Published(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ReadmeUrl();
    [CompilerGeneratedAttribute]
private void set_ReadmeUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ReportAbuseUrl();
    [CompilerGeneratedAttribute]
public void set_ReportAbuseUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_PackageDetailsUrl();
    [CompilerGeneratedAttribute]
public void set_PackageDetailsUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
private void set_RequireLicenseAcceptance(bool value);
    public sealed virtual string get_Summary();
    private void set_Summary(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Tags();
    [CompilerGeneratedAttribute]
private void set_Tags(string value);
    public sealed virtual string get_Title();
    private void set_Title(string value);
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public VersionInfo[] get_ParsedVersions();
    [CompilerGeneratedAttribute]
private void set_ParsedVersions(VersionInfo[] value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PrefixReserved();
    [CompilerGeneratedAttribute]
private void set_PrefixReserved(bool value);
    [CompilerGeneratedAttribute]
public string get_LicenseExpression();
    [CompilerGeneratedAttribute]
private void set_LicenseExpression(string value);
    [CompilerGeneratedAttribute]
public string get_LicenseExpressionVersion();
    [CompilerGeneratedAttribute]
private void set_LicenseExpressionVersion(string value);
    public sealed virtual LicenseMetadata get_LicenseMetadata();
    private static IList`1<string> GetNonStandardLicenseIdentifiers(NuGetLicenseExpression expression);
    public sealed virtual Task`1<IEnumerable`1<VersionInfo>> GetVersionsAsync();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsListed();
    [CompilerGeneratedAttribute]
private void set_IsListed(bool value);
    [CompilerGeneratedAttribute]
public PackageDeprecationMetadata get_DeprecationMetadata();
    [CompilerGeneratedAttribute]
private void set_DeprecationMetadata(PackageDeprecationMetadata value);
    public sealed virtual Task`1<PackageDeprecationMetadata> GetDeprecationMetadataAsync();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<PackageVulnerabilityMetadata> get_Vulnerabilities();
    [CompilerGeneratedAttribute]
private void set_Vulnerabilities(IEnumerable`1<PackageVulnerabilityMetadata> value);
}
public class NuGet.Protocol.PackageSearchMetadataRegistration : PackageSearchMetadata {
    [CompilerGeneratedAttribute]
private Uri <CatalogUri>k__BackingField;
    [JsonPropertyAttribute]
public Uri CatalogUri { get; private set; }
    [CompilerGeneratedAttribute]
public Uri get_CatalogUri();
    [CompilerGeneratedAttribute]
private void set_CatalogUri(Uri value);
}
public class NuGet.Protocol.PackageSearchMetadataV2Feed : object {
    [CompilerGeneratedAttribute]
private string <Authors>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageDependencyGroup> <DependencySets>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <DownloadCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <IconUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <LicenseUrl>k__BackingField;
    private IReadOnlyList`1<string> _ownersList;
    [CompilerGeneratedAttribute]
private string <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ProjectUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Created>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <LastEdited>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Published>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ReadmeUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ReportAbuseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <PackageDetailsUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    private string _summaryValue;
    [CompilerGeneratedAttribute]
private string <Tags>k__BackingField;
    private string _titleValue;
    [CompilerGeneratedAttribute]
private LicenseMetadata <LicenseMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageDeprecationMetadata <DeprecationMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageVulnerabilityMetadata> <Vulnerabilities>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsListed>k__BackingField;
    public string Authors { get; private set; }
    public IEnumerable`1<PackageDependencyGroup> DependencySets { get; private set; }
    public string Description { get; private set; }
    public Nullable`1<long> DownloadCount { get; private set; }
    public Uri IconUrl { get; private set; }
    public PackageIdentity Identity { get; }
    public Uri LicenseUrl { get; private set; }
    public IReadOnlyList`1<string> OwnersList { get; }
    public string Owners { get; private set; }
    public string PackageId { get; private set; }
    public Uri ProjectUrl { get; private set; }
    public bool PrefixReserved { get; }
    public Nullable`1<DateTimeOffset> Created { get; private set; }
    public Nullable`1<DateTimeOffset> LastEdited { get; private set; }
    public Nullable`1<DateTimeOffset> Published { get; private set; }
    public Uri ReadmeUrl { get; }
    public Uri ReportAbuseUrl { get; private set; }
    public Uri PackageDetailsUrl { get; private set; }
    public bool RequireLicenseAcceptance { get; private set; }
    public string Summary { get; private set; }
    public string Tags { get; private set; }
    public string Title { get; private set; }
    public LicenseMetadata LicenseMetadata { get; }
    public PackageDeprecationMetadata DeprecationMetadata { get; }
    public NuGetVersion Version { get; private set; }
    public IEnumerable`1<PackageVulnerabilityMetadata> Vulnerabilities { get; }
    public bool IsListed { get; }
    public PackageSearchMetadataV2Feed(V2FeedPackageInfo package);
    public PackageSearchMetadataV2Feed(V2FeedPackageInfo package, MetadataReferenceCache metadataCache);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Authors();
    [CompilerGeneratedAttribute]
private void set_Authors(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<PackageDependencyGroup> get_DependencySets();
    [CompilerGeneratedAttribute]
private void set_DependencySets(IEnumerable`1<PackageDependencyGroup> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<long> get_DownloadCount();
    [CompilerGeneratedAttribute]
private void set_DownloadCount(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_IconUrl();
    [CompilerGeneratedAttribute]
private void set_IconUrl(Uri value);
    public sealed virtual PackageIdentity get_Identity();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_LicenseUrl();
    [CompilerGeneratedAttribute]
private void set_LicenseUrl(Uri value);
    public sealed virtual IReadOnlyList`1<string> get_OwnersList();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Owners();
    [CompilerGeneratedAttribute]
private void set_Owners(string value);
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
private void set_PackageId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ProjectUrl();
    [CompilerGeneratedAttribute]
private void set_ProjectUrl(Uri value);
    public sealed virtual bool get_PrefixReserved();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_Created();
    [CompilerGeneratedAttribute]
private void set_Created(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_LastEdited();
    [CompilerGeneratedAttribute]
private void set_LastEdited(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTimeOffset> get_Published();
    [CompilerGeneratedAttribute]
private void set_Published(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ReadmeUrl();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ReportAbuseUrl();
    [CompilerGeneratedAttribute]
private void set_ReportAbuseUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_PackageDetailsUrl();
    [CompilerGeneratedAttribute]
private void set_PackageDetailsUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
private void set_RequireLicenseAcceptance(bool value);
    public sealed virtual string get_Summary();
    private void set_Summary(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Tags();
    [CompilerGeneratedAttribute]
private void set_Tags(string value);
    public sealed virtual string get_Title();
    private void set_Title(string value);
    [CompilerGeneratedAttribute]
public sealed virtual LicenseMetadata get_LicenseMetadata();
    [CompilerGeneratedAttribute]
public PackageDeprecationMetadata get_DeprecationMetadata();
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(NuGetVersion value);
    public sealed virtual Task`1<IEnumerable`1<VersionInfo>> GetVersionsAsync();
    private static Uri GetUriSafe(string url);
    public sealed virtual Task`1<PackageDeprecationMetadata> GetDeprecationMetadataAsync();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<PackageVulnerabilityMetadata> get_Vulnerabilities();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsListed();
}
public class NuGet.Protocol.PackageSearchResourceV2Feed : PackageSearchResource {
    private HttpSource _httpSource;
    private PackageSource _packageSource;
    private V2FeedParser _feedParser;
    public PackageSearchResourceV2Feed(HttpSourceResource httpSourceResource, string baseAddress, PackageSource packageSource);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV2Feed/<SearchAsync>d__4")]
public virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> SearchAsync(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken cancellationToken);
}
public class NuGet.Protocol.PackageSearchResourceV2FeedProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV2FeedProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.PackageSearchResourceV3 : PackageSearchResource {
    private HttpSource _client;
    private Uri[] _searchEndpoints;
    private RawSearchResourceV3 _rawSearchResource;
    [ObsoleteAttribute("Use PackageSearchResource instead (via SourceRepository.GetResourceAsync<PackageSearchResource>")]
public PackageSearchResourceV3(RawSearchResourceV3 searchResource);
    internal PackageSearchResourceV3(HttpSource client, IEnumerable`1<Uri> searchEndpoints);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV3/<SearchAsync>d__5")]
public virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> SearchAsync(string searchTerm, SearchFilter filter, int skip, int take, ILogger log, CancellationToken cancellationToken);
    private static IEnumerable`1<VersionInfo> GetVersions(PackageSearchMetadata metadata, SearchFilter filter);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV3/<SearchPage>d__7`1")]
private Task`1<T> SearchPage(Func`2<Uri, Task`1<T>> getResultAsync, string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV3/<Search>d__8`1")]
private Task`1<T> Search(Func`3<HttpSource, Uri, Task`1<T>> getResultAsync, string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV3/<Search>d__9")]
internal Task`1<IEnumerable`1<PackageSearchMetadata>> Search(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV3/<ProcessHttpStreamTakeCountedItemAsync>d__10")]
internal Task`1<IEnumerable`1<PackageSearchMetadata>> ProcessHttpStreamTakeCountedItemAsync(HttpResponseMessage httpInitialResponse, int take, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV3/<ProcessHttpStreamWithoutBufferingAsync>d__11")]
private Task`1<V3SearchResults> ProcessHttpStreamWithoutBufferingAsync(HttpResponseMessage httpInitialResponse, UInt32 take, CancellationToken token);
}
public class NuGet.Protocol.PackageSearchResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.PackageUpdateResourceV2Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageUpdateResourceV2Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.PackageUpdateResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageUpdateResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal static class NuGet.Protocol.PackageUtilities : object {
    internal static NuspecReader OpenNuspecFromNupkg(string id, Stream nupkgStream, ILogger log);
}
public class NuGet.Protocol.PackageVulnerabilityMetadata : object {
    [CompilerGeneratedAttribute]
private Uri <AdvisoryUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Severity>k__BackingField;
    [JsonPropertyAttribute]
public Uri AdvisoryUrl { get; internal set; }
    [JsonPropertyAttribute]
public int Severity { get; internal set; }
    [CompilerGeneratedAttribute]
public Uri get_AdvisoryUrl();
    [CompilerGeneratedAttribute]
internal void set_AdvisoryUrl(Uri value);
    [CompilerGeneratedAttribute]
public int get_Severity();
    [CompilerGeneratedAttribute]
internal void set_Severity(int value);
}
public enum NuGet.Protocol.PackageVulnerabilitySeverity : Enum {
    public int value__;
    public static PackageVulnerabilitySeverity Low;
    public static PackageVulnerabilitySeverity Moderate;
    public static PackageVulnerabilitySeverity High;
    public static PackageVulnerabilitySeverity Critical;
    public static PackageVulnerabilitySeverity Unknown;
}
public class NuGet.Protocol.PluginFindPackageByIdResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PluginFindPackageByIdResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken cancellationToken);
    private static void AddOrUpdateGetCredentialsRequestHandler(IPlugin plugin, SourceRepository source, HttpHandlerResource httpHandlerResource);
    private static void AddOrUpdateGetServiceIndexRequestHandler(IPlugin plugin, SourceRepository source);
}
internal class NuGet.Protocol.Plugins.AssemblyLogMessage : PluginLogMessage {
    private string _fileVersion;
    private string _fullName;
    private string _informationalVersion;
    private string _entryAssemblyFullName;
    internal AssemblyLogMessage(DateTimeOffset now);
    public virtual string ToString();
}
public class NuGet.Protocol.Plugins.AutomaticProgressReporter : object {
    private CancellationToken _cancellationToken;
    private CancellationTokenSource _cancellationTokenSource;
    private IConnection _connection;
    private bool _isDisposed;
    private Message _request;
    private SemaphoreSlim _semaphore;
    private Timer _timer;
    private AutomaticProgressReporter(IConnection connection, Message request, TimeSpan interval, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    public static AutomaticProgressReporter Create(IConnection connection, Message request, TimeSpan interval, CancellationToken cancellationToken);
    private void OnTimer(object state);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.AutomaticProgressReporter/<<OnTimer>b__10_0>d")]
[CompilerGeneratedAttribute]
private Task <OnTimer>b__10_0();
}
public class NuGet.Protocol.Plugins.CloseRequestHandler : object {
    private bool _isDisposed;
    private IPlugin _plugin;
    public CancellationToken CancellationToken { get; }
    public CloseRequestHandler(IPlugin plugin);
    public sealed virtual CancellationToken get_CancellationToken();
    public sealed virtual void Dispose();
    public sealed virtual Task HandleResponseAsync(IConnection connection, Message request, IResponseHandler responseHandler, CancellationToken cancellationToken);
}
internal class NuGet.Protocol.Plugins.CommunicationLogMessage : PluginLogMessage {
    private MessageMethod _method;
    private string _requestId;
    private MessageState _state;
    private MessageType _type;
    internal CommunicationLogMessage(DateTimeOffset now, string requestId, MessageMethod method, MessageType type, MessageState state);
    public virtual string ToString();
}
public class NuGet.Protocol.Plugins.Connection : object {
    private bool _isDisposed;
    private IReceiver _receiver;
    private ISender _sender;
    private IPluginLogger _logger;
    private int _state;
    [CompilerGeneratedAttribute]
private EventHandler`1<ProtocolErrorEventArgs> Faulted;
    [CompilerGeneratedAttribute]
private EventHandler`1<MessageEventArgs> MessageReceived;
    [CompilerGeneratedAttribute]
private IMessageDispatcher <MessageDispatcher>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <ProtocolVersion>k__BackingField;
    public ConnectionState State { get; }
    public IMessageDispatcher MessageDispatcher { get; }
    public ConnectionOptions Options { get; }
    public SemanticVersion ProtocolVersion { get; private set; }
    public Connection(IMessageDispatcher dispatcher, ISender sender, IReceiver receiver, ConnectionOptions options);
    internal Connection(IMessageDispatcher dispatcher, ISender sender, IReceiver receiver, ConnectionOptions options, IPluginLogger logger);
    public ConnectionState get_State();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Faulted(EventHandler`1<ProtocolErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Faulted(EventHandler`1<ProtocolErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MessageReceived(EventHandler`1<MessageEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MessageReceived(EventHandler`1<MessageEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual IMessageDispatcher get_MessageDispatcher();
    [CompilerGeneratedAttribute]
public sealed virtual ConnectionOptions get_Options();
    [CompilerGeneratedAttribute]
public sealed virtual SemanticVersion get_ProtocolVersion();
    [CompilerGeneratedAttribute]
private void set_ProtocolVersion(SemanticVersion value);
    public sealed virtual void Dispose();
    public sealed virtual void Close();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.Connection/<ConnectAsync>d__27")]
public Task ConnectAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.Connection/<SendAsync>d__28")]
public sealed virtual Task SendAsync(Message message, CancellationToken cancellationToken);
    public sealed virtual Task`1<TInbound> SendRequestAndReceiveResponseAsync(MessageMethod method, TOutbound payload, CancellationToken cancellationToken);
    private void OnMessageReceived(object sender, MessageEventArgs e);
    private void OnFaulted(object sender, ProtocolErrorEventArgs e);
}
public class NuGet.Protocol.Plugins.ConnectionOptions : object {
    [CompilerGeneratedAttribute]
private TimeSpan <HandshakeTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <MinimumProtocolVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <ProtocolVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RequestTimeout>k__BackingField;
    public TimeSpan HandshakeTimeout { get; }
    public SemanticVersion MinimumProtocolVersion { get; }
    public SemanticVersion ProtocolVersion { get; }
    public TimeSpan RequestTimeout { get; private set; }
    public ConnectionOptions(SemanticVersion protocolVersion, SemanticVersion minimumProtocolVersion, TimeSpan handshakeTimeout, TimeSpan requestTimeout);
    [CompilerGeneratedAttribute]
public TimeSpan get_HandshakeTimeout();
    [CompilerGeneratedAttribute]
public SemanticVersion get_MinimumProtocolVersion();
    [CompilerGeneratedAttribute]
public SemanticVersion get_ProtocolVersion();
    [CompilerGeneratedAttribute]
public TimeSpan get_RequestTimeout();
    [CompilerGeneratedAttribute]
private void set_RequestTimeout(TimeSpan value);
    public void SetRequestTimeout(TimeSpan requestTimeout);
    public static ConnectionOptions CreateDefault(IEnvironmentVariableReader reader);
}
public enum NuGet.Protocol.Plugins.ConnectionState : Enum {
    public int value__;
    public static ConnectionState FailedToHandshake;
    public static ConnectionState Closing;
    public static ConnectionState Closed;
    public static ConnectionState ReadyToConnect;
    public static ConnectionState Connecting;
    public static ConnectionState Handshaking;
    public static ConnectionState Connected;
}
public class NuGet.Protocol.Plugins.CopyFilesInPackageRequest : object {
    [CompilerGeneratedAttribute]
private string <DestinationFolderPath>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <FilesInPackage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageVersion>k__BackingField;
    [JsonRequiredAttribute]
public string DestinationFolderPath { get; }
    [JsonRequiredAttribute]
public IEnumerable`1<string> FilesInPackage { get; }
    [JsonRequiredAttribute]
public string PackageId { get; }
    [JsonRequiredAttribute]
public string PackageSourceRepository { get; }
    [JsonRequiredAttribute]
public string PackageVersion { get; }
    [JsonConstructorAttribute]
public CopyFilesInPackageRequest(string packageSourceRepository, string packageId, string packageVersion, IEnumerable`1<string> filesInPackage, string destinationFolderPath);
    [CompilerGeneratedAttribute]
public string get_DestinationFolderPath();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_FilesInPackage();
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
    [CompilerGeneratedAttribute]
public string get_PackageVersion();
}
public class NuGet.Protocol.Plugins.CopyFilesInPackageResponse : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <CopiedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    public IEnumerable`1<string> CopiedFiles { get; }
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public CopyFilesInPackageResponse(MessageResponseCode responseCode, IEnumerable`1<string> copiedFiles);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_CopiedFiles();
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
public class NuGet.Protocol.Plugins.CopyNupkgFileRequest : object {
    [CompilerGeneratedAttribute]
private string <DestinationFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageVersion>k__BackingField;
    [JsonRequiredAttribute]
public string DestinationFilePath { get; }
    [JsonRequiredAttribute]
public string PackageId { get; }
    [JsonRequiredAttribute]
public string PackageSourceRepository { get; }
    [JsonRequiredAttribute]
public string PackageVersion { get; }
    [JsonConstructorAttribute]
public CopyNupkgFileRequest(string packageSourceRepository, string packageId, string packageVersion, string destinationFilePath);
    [CompilerGeneratedAttribute]
public string get_DestinationFilePath();
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
    [CompilerGeneratedAttribute]
public string get_PackageVersion();
}
public class NuGet.Protocol.Plugins.CopyNupkgFileResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public CopyNupkgFileResponse(MessageResponseCode responseCode);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
public abstract class NuGet.Protocol.Plugins.EmbeddedSignatureVerifier : object {
    public abstract virtual bool IsValid(string filePath);
    public static EmbeddedSignatureVerifier Create();
}
internal static class NuGet.Protocol.Plugins.EnvironmentVariableConstants : object {
    internal static string EnableLog;
    internal static string LogDirectoryPath;
    internal static string HandshakeTimeout;
    internal static string IdleTimeout;
    internal static string PluginPaths;
    internal static string RequestTimeout;
    internal static string DesktopPluginPaths;
    internal static string CorePluginPaths;
}
internal class NuGet.Protocol.Plugins.EnvironmentVariablesLogMessage : PluginLogMessage {
    private Nullable`1<int> _handshakeTimeout;
    private Nullable`1<int> _idleTimeout;
    private Nullable`1<int> _requestTimeout;
    internal EnvironmentVariablesLogMessage(DateTimeOffset now, IEnvironmentVariableReader environmentVariableReader);
    public virtual string ToString();
    private static Nullable`1<int> Read(IEnvironmentVariableReader reader, string variableName);
}
public class NuGet.Protocol.Plugins.FallbackEmbeddedSignatureVerifier : EmbeddedSignatureVerifier {
    public virtual bool IsValid(string filePath);
}
public class NuGet.Protocol.Plugins.Fault : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [JsonRequiredAttribute]
public string Message { get; }
    [JsonConstructorAttribute]
public Fault(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
}
public class NuGet.Protocol.Plugins.FaultedPluginEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private IPlugin <Plugin>k__BackingField;
    public Exception Exception { get; }
    public IPlugin Plugin { get; }
    public FaultedPluginEventArgs(IPlugin plugin, Exception exception);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public IPlugin get_Plugin();
}
public class NuGet.Protocol.Plugins.GetAuthenticationCredentialsRequest : object {
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRetry>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNonInteractive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanShowDialog>k__BackingField;
    [JsonRequiredAttribute]
public Uri Uri { get; }
    [JsonRequiredAttribute]
public bool IsRetry { get; }
    [JsonRequiredAttribute]
public bool IsNonInteractive { get; }
    [JsonRequiredAttribute]
public bool CanShowDialog { get; }
    [JsonConstructorAttribute]
public GetAuthenticationCredentialsRequest(Uri uri, bool isRetry, bool isNonInteractive, bool canShowDialog);
    [CompilerGeneratedAttribute]
public Uri get_Uri();
    [CompilerGeneratedAttribute]
public bool get_IsRetry();
    [CompilerGeneratedAttribute]
public bool get_IsNonInteractive();
    [CompilerGeneratedAttribute]
public bool get_CanShowDialog();
}
public class NuGet.Protocol.Plugins.GetAuthenticationCredentialsResponse : object {
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <AuthenticationTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    public string Username { get; }
    public string Password { get; }
    public string Message { get; }
    public IList`1<string> AuthenticationTypes { get; }
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public GetAuthenticationCredentialsResponse(string username, string password, string message, IList`1<string> authenticationTypes, MessageResponseCode responseCode);
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public IList`1<string> get_AuthenticationTypes();
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
    public bool IsValid();
}
public class NuGet.Protocol.Plugins.GetCredentialsRequest : object {
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpStatusCode <StatusCode>k__BackingField;
    [JsonRequiredAttribute]
public string PackageSourceRepository { get; }
    [JsonRequiredAttribute]
public HttpStatusCode StatusCode { get; }
    [JsonConstructorAttribute]
public GetCredentialsRequest(string packageSourceRepository, HttpStatusCode statusCode);
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
    [CompilerGeneratedAttribute]
public HttpStatusCode get_StatusCode();
}
public class NuGet.Protocol.Plugins.GetCredentialsRequestHandler : object {
    private static string _basicAuthenticationType;
    private ICredentialService _credentialService;
    private bool _isDisposed;
    private IPlugin _plugin;
    private IWebProxy _proxy;
    private ConcurrentDictionary`2<string, SourceRepository> _repositories;
    public CancellationToken CancellationToken { get; }
    public GetCredentialsRequestHandler(IPlugin plugin, IWebProxy proxy, ICredentialService credentialService);
    public sealed virtual CancellationToken get_CancellationToken();
    public sealed virtual void Dispose();
    public void AddOrUpdateSourceRepository(SourceRepository sourceRepository);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.GetCredentialsRequestHandler/<HandleResponseAsync>d__11")]
public sealed virtual Task HandleResponseAsync(IConnection connection, Message request, IResponseHandler responseHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.GetCredentialsRequestHandler/<GetCredentialAsync>d__12")]
private Task`1<ICredentials> GetCredentialAsync(PackageSource packageSource, HttpStatusCode statusCode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.GetCredentialsRequestHandler/<GetPackageSourceCredential>d__13")]
private Task`1<ICredentials> GetPackageSourceCredential(CredentialRequestType requestType, PackageSource packageSource, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.GetCredentialsRequestHandler/<GetProxyCredentialAsync>d__14")]
private Task`1<ICredentials> GetProxyCredentialAsync(PackageSource packageSource, CancellationToken cancellationToken);
    private static CredentialRequestType GetCredentialRequestType(HttpStatusCode statusCode);
    private PackageSource GetPackageSource(string packageSourceRepository);
}
public class NuGet.Protocol.Plugins.GetCredentialsResponse : object {
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <AuthenticationTypes>k__BackingField;
    public string Password { get; }
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    public string Username { get; }
    public IReadOnlyList`1<string> AuthenticationTypes { get; }
    [JsonConstructorAttribute]
public GetCredentialsResponse(MessageResponseCode responseCode, string username, string password, IReadOnlyList`1<string> authenticationTypes);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_AuthenticationTypes();
}
public class NuGet.Protocol.Plugins.GetFilesInPackageRequest : object {
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageVersion>k__BackingField;
    [JsonRequiredAttribute]
public string PackageId { get; }
    [JsonRequiredAttribute]
public string PackageSourceRepository { get; }
    [JsonRequiredAttribute]
public string PackageVersion { get; }
    [JsonConstructorAttribute]
public GetFilesInPackageRequest(string packageSourceRepository, string packageId, string packageVersion);
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
    [CompilerGeneratedAttribute]
public string get_PackageVersion();
}
public class NuGet.Protocol.Plugins.GetFilesInPackageResponse : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    public IEnumerable`1<string> Files { get; }
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public GetFilesInPackageResponse(MessageResponseCode responseCode, IEnumerable`1<string> files);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Files();
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
public class NuGet.Protocol.Plugins.GetOperationClaimsRequest : object {
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private JObject <ServiceIndex>k__BackingField;
    public string PackageSourceRepository { get; }
    public JObject ServiceIndex { get; }
    [JsonConstructorAttribute]
public GetOperationClaimsRequest(string packageSourceRepository, JObject serviceIndex);
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
    [CompilerGeneratedAttribute]
public JObject get_ServiceIndex();
}
public class NuGet.Protocol.Plugins.GetOperationClaimsResponse : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<OperationClaim> <Claims>k__BackingField;
    [JsonRequiredAttribute]
public IReadOnlyList`1<OperationClaim> Claims { get; }
    [JsonConstructorAttribute]
public GetOperationClaimsResponse(IEnumerable`1<OperationClaim> claims);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<OperationClaim> get_Claims();
}
public class NuGet.Protocol.Plugins.GetPackageHashRequest : object {
    [CompilerGeneratedAttribute]
private string <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageVersion>k__BackingField;
    [JsonRequiredAttribute]
public string HashAlgorithm { get; }
    [JsonRequiredAttribute]
public string PackageId { get; }
    [JsonRequiredAttribute]
public string PackageSourceRepository { get; }
    [JsonRequiredAttribute]
public string PackageVersion { get; }
    [JsonConstructorAttribute]
public GetPackageHashRequest(string packageSourceRepository, string packageId, string packageVersion, string hashAlgorithm);
    [CompilerGeneratedAttribute]
public string get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
    [CompilerGeneratedAttribute]
public string get_PackageVersion();
}
public class NuGet.Protocol.Plugins.GetPackageHashResponse : object {
    [CompilerGeneratedAttribute]
private string <Hash>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    public string Hash { get; }
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public GetPackageHashResponse(MessageResponseCode responseCode, string hash);
    [CompilerGeneratedAttribute]
public string get_Hash();
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
public class NuGet.Protocol.Plugins.GetPackageVersionsRequest : object {
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [JsonRequiredAttribute]
public string PackageId { get; }
    [JsonRequiredAttribute]
public string PackageSourceRepository { get; }
    [JsonConstructorAttribute]
public GetPackageVersionsRequest(string packageSourceRepository, string packageId);
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
}
public class NuGet.Protocol.Plugins.GetPackageVersionsResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Versions>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    public IEnumerable`1<string> Versions { get; }
    [JsonConstructorAttribute]
public GetPackageVersionsResponse(MessageResponseCode responseCode, IEnumerable`1<string> versions);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Versions();
}
public class NuGet.Protocol.Plugins.GetServiceIndexRequest : object {
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [JsonRequiredAttribute]
public string PackageSourceRepository { get; }
    [JsonConstructorAttribute]
public GetServiceIndexRequest(string packageSourceRepository);
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
}
public class NuGet.Protocol.Plugins.GetServiceIndexRequestHandler : object {
    private bool _isDisposed;
    private IPlugin _plugin;
    private ConcurrentDictionary`2<string, SourceRepository> _repositories;
    public CancellationToken CancellationToken { get; }
    public GetServiceIndexRequestHandler(IPlugin plugin);
    public sealed virtual CancellationToken get_CancellationToken();
    public sealed virtual void Dispose();
    public void AddOrUpdateSourceRepository(SourceRepository sourceRepository);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.GetServiceIndexRequestHandler/<HandleResponseAsync>d__8")]
public sealed virtual Task HandleResponseAsync(IConnection connection, Message request, IResponseHandler responseHandler, CancellationToken cancellationToken);
}
public class NuGet.Protocol.Plugins.GetServiceIndexResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [CompilerGeneratedAttribute]
private JObject <ServiceIndex>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    public JObject ServiceIndex { get; }
    [JsonConstructorAttribute]
public GetServiceIndexResponse(MessageResponseCode responseCode, JObject serviceIndex);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
    [CompilerGeneratedAttribute]
public JObject get_ServiceIndex();
}
public class NuGet.Protocol.Plugins.HandshakeRequest : object {
    [CompilerGeneratedAttribute]
private SemanticVersion <ProtocolVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <MinimumProtocolVersion>k__BackingField;
    [JsonRequiredAttribute]
public SemanticVersion ProtocolVersion { get; }
    [JsonRequiredAttribute]
public SemanticVersion MinimumProtocolVersion { get; }
    [JsonConstructorAttribute]
public HandshakeRequest(SemanticVersion protocolVersion, SemanticVersion minimumProtocolVersion);
    [CompilerGeneratedAttribute]
public SemanticVersion get_ProtocolVersion();
    [CompilerGeneratedAttribute]
public SemanticVersion get_MinimumProtocolVersion();
}
public class NuGet.Protocol.Plugins.HandshakeResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <ProtocolVersion>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    public SemanticVersion ProtocolVersion { get; }
    [JsonConstructorAttribute]
public HandshakeResponse(MessageResponseCode responseCode, SemanticVersion protocolVersion);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
    [CompilerGeneratedAttribute]
public SemanticVersion get_ProtocolVersion();
}
public interface NuGet.Protocol.Plugins.IConnection {
    public IMessageDispatcher MessageDispatcher { get; }
    public ConnectionOptions Options { get; }
    public SemanticVersion ProtocolVersion { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_Faulted(EventHandler`1<ProtocolErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Faulted(EventHandler`1<ProtocolErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MessageReceived(EventHandler`1<MessageEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MessageReceived(EventHandler`1<MessageEventArgs> value);
    public abstract virtual IMessageDispatcher get_MessageDispatcher();
    public abstract virtual ConnectionOptions get_Options();
    public abstract virtual SemanticVersion get_ProtocolVersion();
    public abstract virtual void Close();
    public abstract virtual Task SendAsync(Message message, CancellationToken cancellationToken);
    public abstract virtual Task`1<TInbound> SendRequestAndReceiveResponseAsync(MessageMethod method, TOutbound payload, CancellationToken cancellationToken);
}
public interface NuGet.Protocol.Plugins.IIdGenerator {
    public abstract virtual string GenerateUniqueId();
}
public interface NuGet.Protocol.Plugins.IMessageDispatcher {
    public IRequestHandlers RequestHandlers { get; }
    public abstract virtual IRequestHandlers get_RequestHandlers();
    public abstract virtual void Close();
    public abstract virtual Message CreateMessage(MessageType type, MessageMethod method);
    public abstract virtual Message CreateMessage(MessageType type, MessageMethod method, TPayload payload);
    public abstract virtual Task DispatchCancelAsync(Message request, CancellationToken cancellationToken);
    public abstract virtual Task DispatchFaultAsync(Message request, Fault fault, CancellationToken cancellationToken);
    public abstract virtual Task DispatchProgressAsync(Message request, Progress progress, CancellationToken cancellationToken);
    public abstract virtual Task`1<TInbound> DispatchRequestAsync(MessageMethod method, TOutbound payload, CancellationToken cancellationToken);
    public abstract virtual Task DispatchResponseAsync(Message request, TOutbound responsePayload, CancellationToken cancellationToken);
    public abstract virtual void SetConnection(IConnection connection);
}
public class NuGet.Protocol.Plugins.InboundRequestContext : object {
    private CancellationToken _cancellationToken;
    private CancellationTokenSource _cancellationTokenSource;
    private IConnection _connection;
    private bool _isDisposed;
    private IPluginLogger _logger;
    private InboundRequestProcessingHandler _inboundRequestProcessingHandler;
    [CompilerGeneratedAttribute]
private string <RequestId>k__BackingField;
    public string RequestId { get; }
    public InboundRequestContext(IConnection connection, string requestId, CancellationToken cancellationToken);
    internal InboundRequestContext(IConnection connection, string requestId, CancellationToken cancellationToken, InboundRequestProcessingHandler inboundRequestProcessingHandler, IPluginLogger logger);
    [CompilerGeneratedAttribute]
public string get_RequestId();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.InboundRequestContext/<ProcessResponseAsync>d__11")]
private Task ProcessResponseAsync(IRequestHandler requestHandler, Message request, IResponseHandler responseHandler);
    public sealed virtual void Dispose();
    public void BeginFaultAsync(Message request, Exception exception);
    public void BeginResponseAsync(Message request, IRequestHandler requestHandler, IResponseHandler responseHandler);
    public void Cancel();
}
internal class NuGet.Protocol.Plugins.InboundRequestProcessingHandler : object {
    private ISet`1<MessageMethod> _fastProccessingMethods;
    private Lazy`1<DedicatedAsynchronousProcessingThread> _processingThread;
    private bool _isDisposed;
    public InboundRequestProcessingHandler(IEnumerable`1<MessageMethod> fastProcessingMethods);
    internal void Handle(MessageMethod messageMethod, Func`1<Task> task, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    private void ThrowIfDisposed();
}
public class NuGet.Protocol.Plugins.InitializeRequest : object {
    [CompilerGeneratedAttribute]
private string <ClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RequestTimeout>k__BackingField;
    [JsonRequiredAttribute]
public string ClientVersion { get; }
    [JsonRequiredAttribute]
public string Culture { get; }
    [JsonRequiredAttribute]
public TimeSpan RequestTimeout { get; }
    [JsonConstructorAttribute]
public InitializeRequest(string clientVersion, string culture, TimeSpan requestTimeout);
    [CompilerGeneratedAttribute]
public string get_ClientVersion();
    [CompilerGeneratedAttribute]
public string get_Culture();
    [CompilerGeneratedAttribute]
public TimeSpan get_RequestTimeout();
}
public class NuGet.Protocol.Plugins.InitializeResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public InitializeResponse(MessageResponseCode responseCode);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
public interface NuGet.Protocol.Plugins.IPlugin {
    public IConnection Connection { get; }
    public string FilePath { get; }
    public string Id { get; }
    public string Name { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_BeforeClose(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BeforeClose(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Closed(EventHandler value);
    public abstract virtual IConnection get_Connection();
    public abstract virtual string get_FilePath();
    public abstract virtual string get_Id();
    public abstract virtual string get_Name();
    public abstract virtual void Close();
}
public interface NuGet.Protocol.Plugins.IPluginDiscoverer {
    public abstract virtual Task`1<IEnumerable`1<PluginDiscoveryResult>> DiscoverAsync(CancellationToken cancellationToken);
}
public interface NuGet.Protocol.Plugins.IPluginFactory {
    public abstract virtual Task`1<IPlugin> GetOrCreateAsync(string filePath, IEnumerable`1<string> arguments, IRequestHandlers requestHandlers, ConnectionOptions options, CancellationToken sessionCancellationToken);
}
internal interface NuGet.Protocol.Plugins.IPluginLogger {
    public bool IsEnabled { get; }
    public DateTimeOffset Now { get; }
    public abstract virtual bool get_IsEnabled();
    public abstract virtual DateTimeOffset get_Now();
    public abstract virtual void Write(IPluginLogMessage message);
}
internal interface NuGet.Protocol.Plugins.IPluginLogMessage {
}
public interface NuGet.Protocol.Plugins.IPluginManager {
    public abstract virtual Task`1<IEnumerable`1<PluginCreationResult>> CreatePluginsAsync(SourceRepository source, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<PluginDiscoveryResult>> FindAvailablePluginsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<Tuple`2<bool, PluginCreationResult>> TryGetSourceAgnosticPluginAsync(PluginDiscoveryResult pluginDiscoveryResult, OperationClaim requestedOperationClaim, CancellationToken cancellationToken);
}
public interface NuGet.Protocol.Plugins.IPluginMulticlientUtilities {
    public abstract virtual Task DoOncePerPluginLifetimeAsync(string key, Func`1<Task> taskFunc, CancellationToken cancellationToken);
}
public interface NuGet.Protocol.Plugins.IPluginProcess {
    public Nullable`1<int> ExitCode { get; }
    public Nullable`1<int> Id { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_LineRead(EventHandler`1<LineReadEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_LineRead(EventHandler`1<LineReadEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Exited(EventHandler`1<IPluginProcess> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Exited(EventHandler`1<IPluginProcess> value);
    public abstract virtual Nullable`1<int> get_ExitCode();
    public abstract virtual Nullable`1<int> get_Id();
    public abstract virtual void BeginReadLine();
    public abstract virtual void CancelRead();
    public abstract virtual void Kill();
}
public interface NuGet.Protocol.Plugins.IReceiver {
    [CompilerGeneratedAttribute]
public abstract virtual void add_Faulted(EventHandler`1<ProtocolErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Faulted(EventHandler`1<ProtocolErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MessageReceived(EventHandler`1<MessageEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MessageReceived(EventHandler`1<MessageEventArgs> value);
    public abstract virtual void Close();
    public abstract virtual void Connect();
}
public interface NuGet.Protocol.Plugins.IRequestHandler {
    public CancellationToken CancellationToken { get; }
    public abstract virtual CancellationToken get_CancellationToken();
    public abstract virtual Task HandleResponseAsync(IConnection connection, Message request, IResponseHandler responseHandler, CancellationToken cancellationToken);
}
public interface NuGet.Protocol.Plugins.IRequestHandlers {
    public abstract virtual void AddOrUpdate(MessageMethod method, Func`1<IRequestHandler> addHandlerFunc, Func`2<IRequestHandler, IRequestHandler> updateHandlerFunc);
    public abstract virtual bool TryAdd(MessageMethod method, IRequestHandler handler);
    public abstract virtual bool TryGet(MessageMethod method, IRequestHandler& handler);
    public abstract virtual bool TryRemove(MessageMethod method);
}
public interface NuGet.Protocol.Plugins.IResponseHandler {
    public abstract virtual Task SendResponseAsync(Message request, TPayload payload, CancellationToken cancellationToken);
}
public interface NuGet.Protocol.Plugins.ISender {
    public abstract virtual void Close();
    public abstract virtual void Connect();
    public abstract virtual Task SendAsync(Message message, CancellationToken cancellationToken);
}
public static class NuGet.Protocol.Plugins.JsonSerializationUtilities : object {
    [CompilerGeneratedAttribute]
private static JsonSerializer <Serializer>k__BackingField;
    public static JsonSerializer Serializer { get; }
    private static JsonSerializationUtilities();
    [CompilerGeneratedAttribute]
public static JsonSerializer get_Serializer();
    public static T Deserialize(string json);
    public static JObject FromObject(object value);
    public static void Serialize(JsonWriter writer, object value);
    public static T ToObject(JObject jObject);
}
public class NuGet.Protocol.Plugins.LineReadEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Line>k__BackingField;
    public string Line { get; }
    public LineReadEventArgs(string line);
    [CompilerGeneratedAttribute]
public string get_Line();
}
public class NuGet.Protocol.Plugins.LogRequest : object {
    [CompilerGeneratedAttribute]
private LogLevel <LogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [JsonRequiredAttribute]
public LogLevel LogLevel { get; }
    [JsonRequiredAttribute]
public string Message { get; }
    [JsonConstructorAttribute]
public LogRequest(LogLevel logLevel, string message);
    [CompilerGeneratedAttribute]
public LogLevel get_LogLevel();
    [CompilerGeneratedAttribute]
public string get_Message();
}
public class NuGet.Protocol.Plugins.LogRequestHandler : object {
    private ILogger _logger;
    private LogLevel _logLevel;
    public CancellationToken CancellationToken { get; }
    public LogRequestHandler(ILogger logger);
    public sealed virtual CancellationToken get_CancellationToken();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.LogRequestHandler/<HandleResponseAsync>d__5")]
public sealed virtual Task HandleResponseAsync(IConnection connection, Message request, IResponseHandler responseHandler, CancellationToken cancellationToken);
    public void SetLogger(ILogger logger);
    public static LogLevel GetLogLevel(ILogger logger);
    private void Log(LogRequest request);
}
public class NuGet.Protocol.Plugins.LogResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public LogResponse(MessageResponseCode responseCode);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
internal class NuGet.Protocol.Plugins.MachineLogMessage : PluginLogMessage {
    private int _logicalProcessorCount;
    internal MachineLogMessage(DateTimeOffset now);
    public virtual string ToString();
}
public class NuGet.Protocol.Plugins.Message : object {
    [CompilerGeneratedAttribute]
private string <RequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private JObject <Payload>k__BackingField;
    [JsonRequiredAttribute]
public string RequestId { get; }
    [JsonRequiredAttribute]
public MessageType Type { get; }
    [JsonRequiredAttribute]
public MessageMethod Method { get; }
    public JObject Payload { get; }
    [JsonConstructorAttribute]
public Message(string requestId, MessageType type, MessageMethod method, JObject payload);
    [CompilerGeneratedAttribute]
public string get_RequestId();
    [CompilerGeneratedAttribute]
public MessageType get_Type();
    [CompilerGeneratedAttribute]
public MessageMethod get_Method();
    [CompilerGeneratedAttribute]
public JObject get_Payload();
}
public class NuGet.Protocol.Plugins.MessageDispatcher : object {
    private IConnection _connection;
    private IIdGenerator _idGenerator;
    private bool _isClosed;
    private bool _isDisposed;
    private ConcurrentDictionary`2<string, InboundRequestContext> _inboundRequestContexts;
    private IPluginLogger _logger;
    private ConcurrentDictionary`2<string, OutboundRequestContext> _outboundRequestContexts;
    private InboundRequestProcessingHandler _inboundRequestProcessingContext;
    [CompilerGeneratedAttribute]
private IRequestHandlers <RequestHandlers>k__BackingField;
    public IRequestHandlers RequestHandlers { get; }
    public MessageDispatcher(IRequestHandlers requestHandlers, IIdGenerator idGenerator);
    internal MessageDispatcher(IRequestHandlers requestHandlers, IIdGenerator idGenerator, InboundRequestProcessingHandler inboundRequestProcessingHandler, IPluginLogger logger);
    [CompilerGeneratedAttribute]
public sealed virtual IRequestHandlers get_RequestHandlers();
    public sealed virtual void Dispose();
    public sealed virtual void Close();
    public sealed virtual Message CreateMessage(MessageType type, MessageMethod method);
    public sealed virtual Message CreateMessage(MessageType type, MessageMethod method, TPayload payload);
    public sealed virtual Task DispatchCancelAsync(Message request, CancellationToken cancellationToken);
    public sealed virtual Task DispatchFaultAsync(Message request, Fault fault, CancellationToken cancellationToken);
    public sealed virtual Task DispatchProgressAsync(Message request, Progress progress, CancellationToken cancellationToken);
    public sealed virtual Task`1<TInbound> DispatchRequestAsync(MessageMethod method, TOutbound payload, CancellationToken cancellationToken);
    public sealed virtual Task DispatchResponseAsync(Message request, TOutbound responsePayload, CancellationToken cancellationToken);
    public sealed virtual void SetConnection(IConnection connection);
    private sealed virtual override Task NuGet.Protocol.Plugins.IResponseHandler.SendResponseAsync(Message request, TPayload payload, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.MessageDispatcher/<DispatchAsync>d__24`1")]
private Task DispatchAsync(IConnection connection, MessageType type, Message request, TOutgoing payload, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.MessageDispatcher/<DispatchCancelAsync>d__25")]
private Task DispatchCancelAsync(IConnection connection, Message request, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.MessageDispatcher/<DispatchFaultAsync>d__26")]
private Task DispatchFaultAsync(IConnection connection, Message request, Fault fault, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.MessageDispatcher/<DispatchProgressAsync>d__27")]
private Task DispatchProgressAsync(IConnection connection, Message request, Progress progress, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.MessageDispatcher/<DispatchWithExistingContextAsync>d__28")]
private Task DispatchWithExistingContextAsync(IConnection connection, Message response, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.MessageDispatcher/<DispatchWithNewContextAsync>d__29`2")]
private Task`1<TIncoming> DispatchWithNewContextAsync(IConnection connection, MessageType type, MessageMethod method, TOutgoing payload, CancellationToken cancellationToken);
    private void OnMessageReceived(object sender, MessageEventArgs e);
    private void HandleInboundCancel(Message message);
    private void HandleInboundFault(Message fault);
    private void HandleInboundRequest(Message message);
    private IRequestHandler GetInboundRequestHandler(MessageMethod method);
    private OutboundRequestContext GetOutboundRequestContext(string requestId);
    private void RemoveInboundRequestContext(string requestId);
    private void RemoveOutboundRequestContext(string requestId);
    private InboundRequestContext CreateInboundRequestContext(Message message, CancellationToken cancellationToken);
    private OutboundRequestContext`1<TIncoming> CreateOutboundRequestContext(Message message, Nullable`1<TimeSpan> timeout, bool isKeepAlive, CancellationToken cancellationToken);
    private static bool GetIsKeepAlive(MessageType type, MessageMethod method);
    private static TimeSpan GetRequestTimeout(IConnection connection, MessageType type, MessageMethod method);
}
public class NuGet.Protocol.Plugins.MessageEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Message <Message>k__BackingField;
    public Message Message { get; }
    public MessageEventArgs(Message message);
    [CompilerGeneratedAttribute]
public Message get_Message();
}
public enum NuGet.Protocol.Plugins.MessageMethod : Enum {
    public int value__;
    public static MessageMethod None;
    public static MessageMethod Close;
    public static MessageMethod CopyFilesInPackage;
    public static MessageMethod CopyNupkgFile;
    public static MessageMethod GetCredentials;
    public static MessageMethod GetFilesInPackage;
    public static MessageMethod GetOperationClaims;
    public static MessageMethod GetPackageHash;
    public static MessageMethod GetPackageVersions;
    public static MessageMethod GetServiceIndex;
    public static MessageMethod Handshake;
    public static MessageMethod Initialize;
    public static MessageMethod Log;
    public static MessageMethod MonitorNuGetProcessExit;
    public static MessageMethod PrefetchPackage;
    public static MessageMethod SetCredentials;
    public static MessageMethod SetLogLevel;
    public static MessageMethod GetAuthenticationCredentials;
}
public enum NuGet.Protocol.Plugins.MessageResponseCode : Enum {
    public int value__;
    public static MessageResponseCode Success;
    public static MessageResponseCode Error;
    public static MessageResponseCode NotFound;
}
internal enum NuGet.Protocol.Plugins.MessageState : Enum {
    public int value__;
    public static MessageState Sending;
    public static MessageState Sent;
    public static MessageState Received;
    public static MessageState Cancelled;
}
public enum NuGet.Protocol.Plugins.MessageType : Enum {
    public int value__;
    public static MessageType Cancel;
    public static MessageType Fault;
    public static MessageType Progress;
    public static MessageType Request;
    public static MessageType Response;
}
public static class NuGet.Protocol.Plugins.MessageUtilities : object {
    public static Message Create(string requestId, MessageType type, MessageMethod method);
    public static Message Create(string requestId, MessageType type, MessageMethod method, TPayload payload);
    public static TPayload DeserializePayload(Message message);
}
public class NuGet.Protocol.Plugins.MonitorNuGetProcessExitRequest : object {
    [CompilerGeneratedAttribute]
private int <ProcessId>k__BackingField;
    [JsonRequiredAttribute]
public int ProcessId { get; }
    [JsonConstructorAttribute]
public MonitorNuGetProcessExitRequest(int processId);
    [CompilerGeneratedAttribute]
public int get_ProcessId();
}
public class NuGet.Protocol.Plugins.MonitorNuGetProcessExitRequestHandler : object {
    private bool _isDisposed;
    private IPlugin _plugin;
    private ConcurrentDictionary`2<int, Process> _processes;
    public CancellationToken CancellationToken { get; }
    public MonitorNuGetProcessExitRequestHandler(IPlugin plugin);
    public sealed virtual CancellationToken get_CancellationToken();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.MonitorNuGetProcessExitRequestHandler/<HandleResponseAsync>d__7")]
public sealed virtual Task HandleResponseAsync(IConnection connection, Message request, IResponseHandler responseHandler, CancellationToken cancellationToken);
    private void OnProcessExited(object sender, EventArgs e);
}
public class NuGet.Protocol.Plugins.MonitorNuGetProcessExitResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public MonitorNuGetProcessExitResponse(MessageResponseCode responseCode);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
public class NuGet.Protocol.Plugins.NoOpDisposePlugin : object {
    private IPlugin _plugin;
    public IConnection Connection { get; }
    public string FilePath { get; }
    public string Id { get; }
    public string Name { get; }
    public NoOpDisposePlugin(IPlugin plugin);
    public sealed virtual void add_BeforeClose(EventHandler value);
    public sealed virtual void remove_BeforeClose(EventHandler value);
    public sealed virtual void add_Closed(EventHandler value);
    public sealed virtual void remove_Closed(EventHandler value);
    public sealed virtual IConnection get_Connection();
    public sealed virtual string get_FilePath();
    public sealed virtual string get_Id();
    public sealed virtual string get_Name();
    public sealed virtual void Dispose();
    public sealed virtual void Close();
}
public enum NuGet.Protocol.Plugins.OperationClaim : Enum {
    public int value__;
    public static OperationClaim DownloadPackage;
    public static OperationClaim Authentication;
}
public abstract class NuGet.Protocol.Plugins.OutboundRequestContext : object {
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RequestId>k__BackingField;
    public CancellationToken CancellationToken { get; protected set; }
    public string RequestId { get; protected set; }
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
protected void set_CancellationToken(CancellationToken value);
    [CompilerGeneratedAttribute]
public string get_RequestId();
    [CompilerGeneratedAttribute]
protected void set_RequestId(string value);
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public abstract virtual void HandleCancelResponse();
    public abstract virtual void HandleProgress(Message progress);
    public abstract virtual void HandleResponse(Message response);
    public abstract virtual void HandleFault(Message fault);
}
public class NuGet.Protocol.Plugins.OutboundRequestContext`1 : OutboundRequestContext {
    private CancellationTokenSource _cancellationTokenSource;
    private IConnection _connection;
    private int _isCancellationRequested;
    private bool _isClosed;
    private bool _isDisposed;
    private bool _isKeepAlive;
    private IPluginLogger _logger;
    private Message _request;
    private TaskCompletionSource`1<TResult> _taskCompletionSource;
    private Nullable`1<TimeSpan> _timeout;
    private Timer _timer;
    public Task`1<TResult> CompletionTask { get; }
    public OutboundRequestContext`1(IConnection connection, Message request, Nullable`1<TimeSpan> timeout, bool isKeepAlive, CancellationToken cancellationToken);
    internal OutboundRequestContext`1(IConnection connection, Message request, Nullable`1<TimeSpan> timeout, bool isKeepAlive, CancellationToken cancellationToken, IPluginLogger logger);
    public Task`1<TResult> get_CompletionTask();
    public virtual void HandleCancelResponse();
    public virtual void HandleProgress(Message progress);
    public virtual void HandleResponse(Message response);
    public virtual void HandleFault(Message fault);
    protected virtual void Dispose(bool disposing);
    private void Close();
    private void OnTimeout(object state);
    private void TryCancel();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.OutboundRequestContext`1/<<TryCancel>b__22_0>d")]
[CompilerGeneratedAttribute]
private Task <TryCancel>b__22_0();
}
public class NuGet.Protocol.Plugins.Plugin : object {
    private bool _isClosed;
    private TimeSpan _idleTimeout;
    private Timer _idleTimer;
    private object _idleTimerLock;
    private bool _isDisposed;
    private bool _isOwnProcess;
    private IPluginProcess _process;
    [CompilerGeneratedAttribute]
private EventHandler BeforeClose;
    [CompilerGeneratedAttribute]
private EventHandler Closed;
    [CompilerGeneratedAttribute]
private EventHandler`1<PluginEventArgs> Exited;
    [CompilerGeneratedAttribute]
private EventHandler`1<FaultedPluginEventArgs> Faulted;
    [CompilerGeneratedAttribute]
private EventHandler`1<PluginEventArgs> Idle;
    [CompilerGeneratedAttribute]
private IConnection <Connection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public IConnection Connection { get; }
    public string FilePath { get; }
    public string Id { get; }
    public string Name { get; }
    public Plugin(string filePath, IConnection connection, IPluginProcess process, bool isOwnProcess, TimeSpan idleTimeout);
    internal Plugin(string filePath, IConnection connection, IPluginProcess process, bool isOwnProcess, TimeSpan idleTimeout, string id);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BeforeClose(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BeforeClose(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_Exited(EventHandler`1<PluginEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Exited(EventHandler`1<PluginEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Faulted(EventHandler`1<FaultedPluginEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Faulted(EventHandler`1<FaultedPluginEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Idle(EventHandler`1<PluginEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Idle(EventHandler`1<PluginEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual IConnection get_Connection();
    [CompilerGeneratedAttribute]
public sealed virtual string get_FilePath();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual void Dispose();
    public sealed virtual void Close();
    internal static string CreateNewId();
    private void FireBeforeClose();
    private void FireClosed();
    private void OnExited(object sender, IPluginProcess pluginProcess);
    private void OnFaulted(object sender, ProtocolErrorEventArgs e);
    private void OnIdleTimer(object state);
    private void OnMessageReceived(object sender, MessageEventArgs e);
}
public class NuGet.Protocol.Plugins.PluginCacheEntry : object {
    [CompilerGeneratedAttribute]
private TimeSpan <MaxAge>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewCacheFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<OperationClaim> <OperationClaims>k__BackingField;
    internal TimeSpan MaxAge { get; internal set; }
    internal string CacheFileName { get; }
    private string RootFolder { get; }
    private string NewCacheFileName { get; }
    public IReadOnlyList`1<OperationClaim> OperationClaims { get; public set; }
    public PluginCacheEntry(string rootCacheFolder, string pluginFilePath, string requestKey);
    [CompilerGeneratedAttribute]
internal TimeSpan get_MaxAge();
    [CompilerGeneratedAttribute]
internal void set_MaxAge(TimeSpan value);
    [CompilerGeneratedAttribute]
internal string get_CacheFileName();
    [CompilerGeneratedAttribute]
private string get_RootFolder();
    [CompilerGeneratedAttribute]
private string get_NewCacheFileName();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<OperationClaim> get_OperationClaims();
    [CompilerGeneratedAttribute]
public void set_OperationClaims(IReadOnlyList`1<OperationClaim> value);
    public void LoadFromFile();
    private void ProcessContent(Stream content);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginCacheEntry/<UpdateCacheFileAsync>d__20")]
public Task UpdateCacheFileAsync();
}
public static class NuGet.Protocol.Plugins.PluginConstants : object {
    public static TimeSpan CloseTimeout;
    public static TimeSpan IdleTimeout;
    public static IEnumerable`1<string> PluginArguments;
    public static TimeSpan ProgressInterval;
    public static TimeSpan RequestTimeout;
    private static PluginConstants();
}
public class NuGet.Protocol.Plugins.PluginCreationResult : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<OperationClaim> <Claims>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private IPlugin <Plugin>k__BackingField;
    [CompilerGeneratedAttribute]
private IPluginMulticlientUtilities <PluginMulticlientUtilities>k__BackingField;
    public IReadOnlyList`1<OperationClaim> Claims { get; }
    public string Message { get; }
    public Exception Exception { get; }
    public IPlugin Plugin { get; }
    public IPluginMulticlientUtilities PluginMulticlientUtilities { get; }
    public PluginCreationResult(IPlugin plugin, IPluginMulticlientUtilities utilities, IReadOnlyList`1<OperationClaim> claims);
    public PluginCreationResult(string message);
    public PluginCreationResult(string message, Exception exception);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<OperationClaim> get_Claims();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public IPlugin get_Plugin();
    [CompilerGeneratedAttribute]
public IPluginMulticlientUtilities get_PluginMulticlientUtilities();
}
public class NuGet.Protocol.Plugins.PluginDiscoverer : object {
    private bool _isDisposed;
    private List`1<PluginFile> _pluginFiles;
    private string _rawPluginPaths;
    private IEnumerable`1<PluginDiscoveryResult> _results;
    private SemaphoreSlim _semaphore;
    private EmbeddedSignatureVerifier _verifier;
    public PluginDiscoverer(string rawPluginPaths, EmbeddedSignatureVerifier verifier);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginDiscoverer/<DiscoverAsync>d__8")]
public sealed virtual Task`1<IEnumerable`1<PluginDiscoveryResult>> DiscoverAsync(CancellationToken cancellationToken);
    private List`1<PluginFile> GetPluginFiles(CancellationToken cancellationToken);
    private IEnumerable`1<string> GetPluginFilePaths();
}
public class NuGet.Protocol.Plugins.PluginDiscoveryResult : object {
    [CompilerGeneratedAttribute]
private PluginFile <PluginFile>k__BackingField;
    private string _message;
    public PluginFile PluginFile { get; }
    public string Message { get; }
    public PluginDiscoveryResult(PluginFile pluginFile);
    [CompilerGeneratedAttribute]
public PluginFile get_PluginFile();
    public string get_Message();
}
public static class NuGet.Protocol.Plugins.PluginDiscoveryUtility : object {
    [CompilerGeneratedAttribute]
private static Lazy`1<string> <InternalPluginDiscoveryRoot>k__BackingField;
    private static string NuGetPluginsDirectory;
    public static Lazy`1<string> InternalPluginDiscoveryRoot { get; public set; }
    private static PluginDiscoveryUtility();
    [CompilerGeneratedAttribute]
public static Lazy`1<string> get_InternalPluginDiscoveryRoot();
    [CompilerGeneratedAttribute]
public static void set_InternalPluginDiscoveryRoot(Lazy`1<string> value);
    public static string GetInternalPlugins();
    public static string GetInternalPluginRelativeToMSBuildDirectory(string msbuildDirectoryPath);
    public static string GetNuGetPluginsDirectoryRelativeToNuGetAssembly(string nugetAssemblyPath);
    public static string GetNuGetHomePluginsPath();
    public static IEnumerable`1<string> GetConventionBasedPlugins(IEnumerable`1<string> directories);
}
public class NuGet.Protocol.Plugins.PluginEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IPlugin <Plugin>k__BackingField;
    public IPlugin Plugin { get; }
    public PluginEventArgs(IPlugin plugin);
    [CompilerGeneratedAttribute]
public IPlugin get_Plugin();
}
public class NuGet.Protocol.Plugins.PluginException : Exception {
    public PluginException(string message);
    public PluginException(string message, Exception innerException);
    private PluginException(SerializationInfo info, StreamingContext context);
}
public class NuGet.Protocol.Plugins.PluginFactory : object {
    private bool _isDisposed;
    private IPluginLogger _logger;
    private TimeSpan _pluginIdleTimeout;
    private ConcurrentDictionary`2<string, Lazy`1<Task`1<IPlugin>>> _plugins;
    public PluginFactory(TimeSpan pluginIdleTimeout);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginFactory/<GetOrCreateAsync>d__6")]
public sealed virtual Task`1<IPlugin> GetOrCreateAsync(string filePath, IEnumerable`1<string> arguments, IRequestHandlers requestHandlers, ConnectionOptions options, CancellationToken sessionCancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginFactory/<CreatePluginAsync>d__7")]
private Task`1<IPlugin> CreatePluginAsync(string filePath, IEnumerable`1<string> arguments, IRequestHandlers requestHandlers, ConnectionOptions options, CancellationToken sessionCancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginFactory/<CreateFromCurrentProcessAsync>d__8")]
public static Task`1<IPlugin> CreateFromCurrentProcessAsync(IRequestHandlers requestHandlers, ConnectionOptions options, CancellationToken sessionCancellationToken);
    private void Dispose(IPlugin plugin);
    private void OnPluginFaulted(object sender, FaultedPluginEventArgs e);
    private void OnPluginExited(object sender, PluginEventArgs e);
    private void OnPluginIdle(object sender, PluginEventArgs e);
    private void OnPluginProcessExited(IPluginProcess pluginProcess, string pluginId);
    private static void SendCloseRequest(IPlugin plugin);
    private void UnregisterEventHandlers(Plugin plugin);
    private static void WriteCommonLogMessages(IPluginLogger logger);
}
public class NuGet.Protocol.Plugins.PluginFile : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<PluginFileState> <State>k__BackingField;
    public string Path { get; }
    public Lazy`1<PluginFileState> State { get; }
    public PluginFile(string filePath, Lazy`1<PluginFileState> state);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public Lazy`1<PluginFileState> get_State();
    public virtual string ToString();
}
public enum NuGet.Protocol.Plugins.PluginFileState : Enum {
    public int value__;
    public static PluginFileState Valid;
    public static PluginFileState NotFound;
    public static PluginFileState InvalidFilePath;
    public static PluginFileState InvalidEmbeddedSignature;
}
internal class NuGet.Protocol.Plugins.PluginInstanceLogMessage : PluginLogMessage {
    private string _pluginId;
    private Nullable`1<int> _processId;
    private PluginState _state;
    internal PluginInstanceLogMessage(DateTimeOffset now, string pluginId, PluginState state);
    internal PluginInstanceLogMessage(DateTimeOffset now, string pluginId, PluginState state, Nullable`1<int> processId);
    public virtual string ToString();
}
internal class NuGet.Protocol.Plugins.PluginLogger : object {
    private bool _isDisposed;
    private Lazy`1<StreamWriter> _streamWriter;
    private string _logDirectoryPath;
    private DateTimeOffset _startTime;
    private Stopwatch _stopwatch;
    private object _streamWriterLock;
    [CompilerGeneratedAttribute]
private static PluginLogger <DefaultInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    internal static PluginLogger DefaultInstance { get; }
    public bool IsEnabled { get; }
    public DateTimeOffset Now { get; }
    internal PluginLogger(IEnvironmentVariableReader environmentVariableReader);
    private static PluginLogger();
    [CompilerGeneratedAttribute]
internal static PluginLogger get_DefaultInstance();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsEnabled();
    public sealed virtual DateTimeOffset get_Now();
    public sealed virtual void Dispose();
    public sealed virtual void Write(IPluginLogMessage message);
    private StreamWriter CreateStreamWriter(IPluginLogMessage message);
}
internal abstract class NuGet.Protocol.Plugins.PluginLogMessage : object {
    private static StringEnumConverter _enumConverter;
    private DateTime _now;
    protected PluginLogMessage(DateTimeOffset now);
    private static PluginLogMessage();
    protected string ToString(string type, JObject message);
}
public class NuGet.Protocol.Plugins.PluginManager : object {
    private static Lazy`1<IPluginManager> _lazy;
    private ConnectionOptions _connectionOptions;
    private Lazy`1<IPluginDiscoverer> _discoverer;
    private bool _isDisposed;
    private IPluginFactory _pluginFactory;
    private ConcurrentDictionary`2<PluginRequestKey, Lazy`1<Task`1<IReadOnlyList`1<OperationClaim>>>> _pluginOperationClaims;
    private ConcurrentDictionary`2<string, Lazy`1<IPluginMulticlientUtilities>> _pluginUtilities;
    private string _rawPluginPaths;
    private static Lazy`1<int> _currentProcessId;
    private Lazy`1<string> _pluginsCacheDirectoryPath;
    [CompilerGeneratedAttribute]
private IEnvironmentVariableReader <EnvironmentVariableReader>k__BackingField;
    public static IPluginManager Instance { get; }
    public IEnvironmentVariableReader EnvironmentVariableReader { get; private set; }
    public PluginManager(IEnvironmentVariableReader reader, Lazy`1<IPluginDiscoverer> pluginDiscoverer, Func`2<TimeSpan, IPluginFactory> pluginFactoryCreator, Lazy`1<string> pluginsCacheDirectoryPath);
    private static PluginManager();
    public static IPluginManager get_Instance();
    [CompilerGeneratedAttribute]
public IEnvironmentVariableReader get_EnvironmentVariableReader();
    [CompilerGeneratedAttribute]
private void set_EnvironmentVariableReader(IEnvironmentVariableReader value);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginManager/<FindAvailablePluginsAsync>d__19")]
public sealed virtual Task`1<IEnumerable`1<PluginDiscoveryResult>> FindAvailablePluginsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginManager/<CreatePluginsAsync>d__20")]
public sealed virtual Task`1<IEnumerable`1<PluginCreationResult>> CreatePluginsAsync(SourceRepository source, CancellationToken cancellationToken);
    public sealed virtual Task`1<Tuple`2<bool, PluginCreationResult>> TryGetSourceAgnosticPluginAsync(PluginDiscoveryResult pluginDiscoveryResult, OperationClaim requestedOperationClaim, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginManager/<TryCreatePluginAsync>d__22")]
private Task`1<Tuple`2<bool, PluginCreationResult>> TryCreatePluginAsync(PluginDiscoveryResult result, OperationClaim requestedOperationClaim, PluginRequestKey requestKey, string packageSourceRepository, JObject serviceIndex, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginManager/<PerformOneTimePluginInitializationAsync>d__23")]
private Task`1<Lazy`1<IPluginMulticlientUtilities>> PerformOneTimePluginInitializationAsync(IPlugin plugin, CancellationToken cancellationToken);
    private void Initialize(IEnvironmentVariableReader reader, Lazy`1<IPluginDiscoverer> pluginDiscoverer, Func`2<TimeSpan, IPluginFactory> pluginFactoryCreator, Lazy`1<string> pluginsCacheDirectoryPath);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginManager/<GetPluginOperationClaimsAsync>d__25")]
private Task`1<IReadOnlyList`1<OperationClaim>> GetPluginOperationClaimsAsync(IPlugin plugin, string packageSourceRepository, JObject serviceIndex, CancellationToken cancellationToken);
    private PluginDiscoverer InitializeDiscoverer();
    private bool IsPluginPossiblyAvailable();
    private void OnPluginClosed(object sender, EventArgs e);
    private static int GetCurrentProcessId();
    private static string GetCurrentCultureName();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginManager/<InitializePluginAsync>d__31")]
private static Task InitializePluginAsync(IPlugin plugin, TimeSpan requestTimeout, CancellationToken cancellationToken);
}
public class NuGet.Protocol.Plugins.PluginMulticlientUtilities : object {
    private ConcurrentDictionary`2<string, Lazy`1<Task>> _actions;
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginMulticlientUtilities/<DoOncePerPluginLifetimeAsync>d__2")]
public sealed virtual Task DoOncePerPluginLifetimeAsync(string key, Func`1<Task> taskFunc, CancellationToken cancellationToken);
}
public class NuGet.Protocol.Plugins.PluginPackageDownloader : object {
    private Func`2<Exception, Task`1<bool>> _handleExceptionAsync;
    private bool _isDisposed;
    private PackageIdentity _packageIdentity;
    private PluginPackageReader _packageReader;
    private string _packageSourceRepository;
    private IPlugin _plugin;
    public IAsyncPackageContentReader ContentReader { get; }
    public IAsyncPackageCoreReader CoreReader { get; }
    public ISignedPackageReader SignedPackageReader { get; }
    public string Source { get; }
    public PluginPackageDownloader(IPlugin plugin, PackageIdentity packageIdentity, PluginPackageReader packageReader, string packageSourceRepository);
    public sealed virtual IAsyncPackageContentReader get_ContentReader();
    public sealed virtual IAsyncPackageCoreReader get_CoreReader();
    public sealed virtual ISignedPackageReader get_SignedPackageReader();
    public sealed virtual string get_Source();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageDownloader/<CopyNupkgFileToAsync>d__16")]
public sealed virtual Task`1<bool> CopyNupkgFileToAsync(string destinationFilePath, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageDownloader/<GetPackageHashAsync>d__17")]
public sealed virtual Task`1<string> GetPackageHashAsync(string hashAlgorithm, CancellationToken cancellationToken);
    public sealed virtual void SetExceptionHandler(Func`2<Exception, Task`1<bool>> handleExceptionAsync);
    public sealed virtual void SetThrottle(SemaphoreSlim throttle);
    private void ThrowIfDisposed();
}
public class NuGet.Protocol.Plugins.PluginPackageReader : PackageReaderBase {
    private ConcurrentDictionary`2<string, Lazy`1<Task`1<FileStreamCreator>>> _fileStreams;
    private IEnumerable`1<string> _files;
    private SemaphoreSlim _getFilesSemaphore;
    private SemaphoreSlim _getNuspecReaderSemaphore;
    private bool _isDisposed;
    private NuspecReader _nuspecReader;
    private PackageIdentity _packageIdentity;
    private string _packageSourceRepository;
    private IPlugin _plugin;
    private Lazy`1<string> _tempDirectoryPath;
    public NuspecReader NuspecReader { get; }
    public PluginPackageReader(IPlugin plugin, PackageIdentity packageIdentity, string packageSourceRepository);
    public virtual Stream GetStream(string path);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetStreamAsync>d__12")]
public virtual Task`1<Stream> GetStreamAsync(string path, CancellationToken cancellationToken);
    public virtual IEnumerable`1<string> GetFiles();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetFilesAsync>d__14")]
public virtual Task`1<IEnumerable`1<string>> GetFilesAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<string> GetFiles(string folder);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetFilesAsync>d__16")]
public virtual Task`1<IEnumerable`1<string>> GetFilesAsync(string folder, CancellationToken cancellationToken);
    public virtual IEnumerable`1<string> CopyFiles(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<CopyFilesAsync>d__18")]
public virtual Task`1<IEnumerable`1<string>> CopyFilesAsync(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken cancellationToken);
    public virtual PackageIdentity GetIdentity();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetIdentityAsync>d__20")]
public virtual Task`1<PackageIdentity> GetIdentityAsync(CancellationToken cancellationToken);
    public virtual NuGetVersion GetMinClientVersion();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetMinClientVersionAsync>d__22")]
public virtual Task`1<NuGetVersion> GetMinClientVersionAsync(CancellationToken cancellationToken);
    public virtual IReadOnlyList`1<PackageType> GetPackageTypes();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetPackageTypesAsync>d__24")]
public virtual Task`1<IReadOnlyList`1<PackageType>> GetPackageTypesAsync(CancellationToken cancellationToken);
    public virtual Stream GetNuspec();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetNuspecAsync>d__26")]
public virtual Task`1<Stream> GetNuspecAsync(CancellationToken cancellationToken);
    public virtual string GetNuspecFile();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetNuspecFileAsync>d__28")]
public virtual Task`1<string> GetNuspecFileAsync(CancellationToken cancellationToken);
    public virtual NuspecReader get_NuspecReader();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetNuspecReaderAsync>d__31")]
public virtual Task`1<NuspecReader> GetNuspecReaderAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<NuGetFramework> GetSupportedFrameworks();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetSupportedFrameworksAsync>d__33")]
public virtual Task`1<IEnumerable`1<NuGetFramework>> GetSupportedFrameworksAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetFrameworkItems();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetFrameworkItemsAsync>d__35")]
public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetFrameworkItemsAsync(CancellationToken cancellationToken);
    public virtual bool IsServiceable();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<IsServiceableAsync>d__37")]
public virtual Task`1<bool> IsServiceableAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetBuildItems();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetBuildItemsAsync>d__39")]
public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetBuildItemsAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetToolItems();
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetToolItemsAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetContentItems();
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetContentItemsAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetItems(string folderName);
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetItemsAsync(string folderName, CancellationToken cancellationToken);
    public virtual IEnumerable`1<PackageDependencyGroup> GetPackageDependencies();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetPackageDependenciesAsync>d__47")]
public virtual Task`1<IEnumerable`1<PackageDependencyGroup>> GetPackageDependenciesAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetLibItems();
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetLibItemsAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetReferenceItems();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetReferenceItemsAsync>d__51")]
public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetReferenceItemsAsync(CancellationToken cancellationToken);
    public virtual bool GetDevelopmentDependency();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetDevelopmentDependencyAsync>d__53")]
public virtual Task`1<bool> GetDevelopmentDependencyAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<CopyNupkgAsync>d__54")]
public virtual Task`1<string> CopyNupkgAsync(string nupkgFilePath, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetFileGroupsAsync>d__56")]
private Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetFileGroupsAsync(string folder, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetStreamInternalAsync>d__57")]
private Task`1<FileStreamCreator> GetStreamInternalAsync(string pathInPackage);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetFilesInternalAsync>d__58")]
private Task`1<IEnumerable`1<string>> GetFilesInternalAsync(CancellationToken cancellationToken);
    private void CreatePackageDownloadMarkerFile(string nupkgFilePath);
    private static string GetTemporaryDirectoryPath();
    public virtual Task`1<PrimarySignature> GetPrimarySignatureAsync(CancellationToken token);
    public virtual Task`1<bool> IsSignedAsync(CancellationToken token);
    public virtual Task ValidateIntegrityAsync(SignatureContent signatureContent, CancellationToken token);
    public virtual Task`1<Byte[]> GetArchiveHashAsync(HashAlgorithmName hashAlgorithm, CancellationToken token);
    public virtual bool CanVerifySignedPackages(SignedPackageVerifierSettings verifierSettings);
    public virtual string GetContentHash(CancellationToken token, Func`1<string> GetUnsignedPackageHash);
    [CompilerGeneratedAttribute]
private Lazy`1<Task`1<FileStreamCreator>> <GetStreamAsync>b__12_0(string p);
}
public class NuGet.Protocol.Plugins.PluginProcess : object {
    private Nullable`1<int> _exitCode;
    private bool _hasStarted;
    private Nullable`1<int> _id;
    private bool _isDisposed;
    private Process _process;
    private ProcessStartInfo _startInfo;
    [CompilerGeneratedAttribute]
private EventHandler`1<IPluginProcess> Exited;
    [CompilerGeneratedAttribute]
private EventHandler`1<LineReadEventArgs> LineRead;
    public Nullable`1<int> ExitCode { get; }
    internal string FilePath { get; }
    public Nullable`1<int> Id { get; }
    internal StreamWriter StandardInput { get; }
    public PluginProcess(ProcessStartInfo startInfo);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Exited(EventHandler`1<IPluginProcess> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Exited(EventHandler`1<IPluginProcess> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_LineRead(EventHandler`1<LineReadEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_LineRead(EventHandler`1<LineReadEventArgs> value);
    public sealed virtual Nullable`1<int> get_ExitCode();
    internal string get_FilePath();
    public sealed virtual Nullable`1<int> get_Id();
    internal StreamWriter get_StandardInput();
    public sealed virtual void Dispose();
    public sealed virtual void BeginReadLine();
    public sealed virtual void CancelRead();
    public sealed virtual void Kill();
    public void Start();
    private void OnOutputDataReceived(object sender, DataReceivedEventArgs e);
    private void OnProcessExited(object sender, EventArgs e);
    private void UpdateExitCodeIfNecessary();
    private void UpdateIdIfNecessary();
}
internal enum NuGet.Protocol.Plugins.PluginState : Enum {
    public int value__;
    public static PluginState Started;
    public static PluginState Idle;
    public static PluginState Exited;
    public static PluginState Disposing;
    public static PluginState Disposed;
}
public class NuGet.Protocol.Plugins.PrefetchPackageRequest : object {
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageVersion>k__BackingField;
    [JsonRequiredAttribute]
public string PackageId { get; }
    [JsonRequiredAttribute]
public string PackageSourceRepository { get; }
    [JsonRequiredAttribute]
public string PackageVersion { get; }
    [JsonConstructorAttribute]
public PrefetchPackageRequest(string packageSourceRepository, string packageId, string packageVersion);
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
    [CompilerGeneratedAttribute]
public string get_PackageVersion();
}
public class NuGet.Protocol.Plugins.PrefetchPackageResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public PrefetchPackageResponse(MessageResponseCode responseCode);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
internal class NuGet.Protocol.Plugins.ProcessLogMessage : PluginLogMessage {
    private int _processId;
    private string _processName;
    private DateTime _processStartTime;
    internal ProcessLogMessage(DateTimeOffset now);
    public virtual string ToString();
}
public class NuGet.Protocol.Plugins.Progress : object {
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Percentage>k__BackingField;
    public Nullable`1<double> Percentage { get; }
    [JsonConstructorAttribute]
public Progress(Nullable`1<double> percentage);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Percentage();
    private static bool IsValidPercentage(Nullable`1<double> percentage);
}
public static class NuGet.Protocol.Plugins.ProtocolConstants : object {
    public static SemanticVersion CurrentVersion;
    public static SemanticVersion Version100;
    public static TimeSpan HandshakeTimeout;
    public static TimeSpan MaxTimeout;
    public static TimeSpan MinTimeout;
    public static TimeSpan RequestTimeout;
    private static ProtocolConstants();
}
public class NuGet.Protocol.Plugins.ProtocolErrorEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private Message <Message>k__BackingField;
    public Exception Exception { get; }
    public Message Message { get; }
    public ProtocolErrorEventArgs(Exception exception);
    public ProtocolErrorEventArgs(Exception exception, Message message);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public Message get_Message();
}
public class NuGet.Protocol.Plugins.ProtocolException : Exception {
    public ProtocolException(string message);
    public ProtocolException(string message, Exception innerException);
    private ProtocolException(SerializationInfo info, StreamingContext context);
}
public abstract class NuGet.Protocol.Plugins.Receiver : object {
    [CompilerGeneratedAttribute]
private bool <IsClosed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<ProtocolErrorEventArgs> Faulted;
    [CompilerGeneratedAttribute]
private EventHandler`1<MessageEventArgs> MessageReceived;
    protected bool IsClosed { get; private set; }
    protected bool IsDisposed { get; protected set; }
    [CompilerGeneratedAttribute]
protected bool get_IsClosed();
    [CompilerGeneratedAttribute]
private void set_IsClosed(bool value);
    [CompilerGeneratedAttribute]
protected bool get_IsDisposed();
    [CompilerGeneratedAttribute]
protected void set_IsDisposed(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Faulted(EventHandler`1<ProtocolErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Faulted(EventHandler`1<ProtocolErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MessageReceived(EventHandler`1<MessageEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MessageReceived(EventHandler`1<MessageEventArgs> value);
    public virtual void Close();
    public abstract virtual void Connect();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    protected void FireFaultEvent(Exception exception, Message message);
    protected void FireMessageReceivedEvent(Message message);
    protected void ThrowIfClosed();
    protected void ThrowIfDisposed();
}
public class NuGet.Protocol.Plugins.RequestHandlers : object {
    private ConcurrentDictionary`2<MessageMethod, IRequestHandler> _handlers;
    public sealed virtual void AddOrUpdate(MessageMethod method, Func`1<IRequestHandler> addHandlerFunc, Func`2<IRequestHandler, IRequestHandler> updateHandlerFunc);
    public sealed virtual bool TryAdd(MessageMethod method, IRequestHandler handler);
    public sealed virtual bool TryGet(MessageMethod method, IRequestHandler& handler);
    public sealed virtual bool TryRemove(MessageMethod method);
}
public class NuGet.Protocol.Plugins.RequestIdGenerator : object {
    public sealed virtual string GenerateUniqueId();
}
public class NuGet.Protocol.Plugins.Sender : object {
    private bool _hasConnected;
    private bool _isClosed;
    private bool _isDisposed;
    private object _sendLock;
    private TextWriter _textWriter;
    public Sender(TextWriter writer);
    public sealed virtual void Dispose();
    public sealed virtual void Close();
    public sealed virtual void Connect();
    public sealed virtual Task SendAsync(Message message, CancellationToken cancellationToken);
    private void ThrowIfDisposed();
}
public class NuGet.Protocol.Plugins.SetCredentialsRequest : object {
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProxyPassword>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProxyUsername>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [JsonRequiredAttribute]
public string PackageSourceRepository { get; }
    public string Password { get; }
    public string ProxyPassword { get; }
    public string ProxyUsername { get; }
    public string Username { get; }
    public SetCredentialsRequest(string packageSourceRepository, string proxyUsername, string proxyPassword, string username, string password);
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public string get_ProxyPassword();
    [CompilerGeneratedAttribute]
public string get_ProxyUsername();
    [CompilerGeneratedAttribute]
public string get_Username();
}
public class NuGet.Protocol.Plugins.SetCredentialsResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public SetCredentialsResponse(MessageResponseCode responseCode);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
public class NuGet.Protocol.Plugins.SetLogLevelRequest : object {
    [CompilerGeneratedAttribute]
private LogLevel <LogLevel>k__BackingField;
    [JsonRequiredAttribute]
public LogLevel LogLevel { get; }
    [JsonConstructorAttribute]
public SetLogLevelRequest(LogLevel logLevel);
    [CompilerGeneratedAttribute]
public LogLevel get_LogLevel();
}
public class NuGet.Protocol.Plugins.SetLogLevelResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public SetLogLevelResponse(MessageResponseCode responseCode);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
public class NuGet.Protocol.Plugins.StandardInputReceiver : Receiver {
    private TextReader _reader;
    private CancellationTokenSource _receiveCancellationTokenSource;
    private Task _receiveThread;
    public StandardInputReceiver(TextReader reader);
    protected virtual void Dispose(bool disposing);
    public virtual void Connect();
    private void Receive(object state);
}
public class NuGet.Protocol.Plugins.StandardOutputReceiver : Receiver {
    private bool _hasConnected;
    private IPluginProcess _process;
    public StandardOutputReceiver(IPluginProcess process);
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    public virtual void Connect();
    private void OnLineRead(object sender, LineReadEventArgs e);
}
internal class NuGet.Protocol.Plugins.StopwatchLogMessage : PluginLogMessage {
    private long _frequency;
    internal StopwatchLogMessage(DateTimeOffset now, long frequency);
    public virtual string ToString();
}
public class NuGet.Protocol.Plugins.SymmetricHandshake : object {
    private IConnection _connection;
    private HandshakeResponse _handshakeFailedResponse;
    private TimeSpan _handshakeTimeout;
    private bool _isDisposed;
    private SemanticVersion _minimumProtocolVersion;
    private HandshakeRequest _outboundHandshakeRequest;
    private SemanticVersion _protocolVersion;
    private TaskCompletionSource`1<int> _responseSentTaskCompletionSource;
    private CancellationTokenSource _timeoutCancellationTokenSource;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public CancellationToken CancellationToken { get; }
    public SymmetricHandshake(IConnection connection, TimeSpan handshakeTimeout, SemanticVersion protocolVersion, SemanticVersion minimumProtocolVersion);
    [CompilerGeneratedAttribute]
public sealed virtual CancellationToken get_CancellationToken();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.SymmetricHandshake/<HandshakeAsync>d__14")]
public Task`1<SemanticVersion> HandshakeAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.SymmetricHandshake/<HandleResponseAsync>d__15")]
public sealed virtual Task HandleResponseAsync(IConnection connection, Message request, IResponseHandler responseHandler, CancellationToken cancellationToken);
    private bool IsSupportedVersion(SemanticVersion requestedProtocolVersion);
    [CompilerGeneratedAttribute]
private void <.ctor>b__12_0();
    [CompilerGeneratedAttribute]
private bool <HandleResponseAsync>b__15_0(Task task);
}
internal class NuGet.Protocol.Plugins.TaskLogMessage : PluginLogMessage {
    private Nullable`1<int> _currentTaskId;
    private MessageMethod _method;
    private string _requestId;
    private TaskState _state;
    private MessageType _type;
    internal TaskLogMessage(DateTimeOffset now, string requestId, MessageMethod method, MessageType type, TaskState state);
    public virtual string ToString();
}
internal enum NuGet.Protocol.Plugins.TaskState : Enum {
    public int value__;
    public static TaskState Queued;
    public static TaskState Executing;
    public static TaskState Completed;
}
internal class NuGet.Protocol.Plugins.ThreadPoolLogMessage : PluginLogMessage {
    private int _maxCompletionPortThreads;
    private int _maxWorkerThreads;
    private int _minCompletionPortThreads;
    private int _minWorkerThreads;
    internal ThreadPoolLogMessage(DateTimeOffset now);
    public virtual string ToString();
}
public static class NuGet.Protocol.Plugins.TimeoutUtilities : object {
    public static TimeSpan GetTimeout(string timeoutInSeconds, TimeSpan fallbackTimeout);
    public static bool IsValid(TimeSpan timeout);
}
public class NuGet.Protocol.Plugins.UnixAndMonoPlatformsEmbeddedSignatureVerifier : EmbeddedSignatureVerifier {
    public virtual bool IsValid(string filePath);
}
public class NuGet.Protocol.Plugins.WindowsEmbeddedSignatureVerifier : EmbeddedSignatureVerifier {
    private static int WinVerifyTrust(IntPtr hwnd, Guid pgActionID, WINTRUST_DATA pWVTData);
    public virtual bool IsValid(string filePath);
}
public static class NuGet.Protocol.ProtocolConstants : object {
    public static string ApiKeyHeader;
    public static string ServerWarningHeader;
    public static string SessionId;
    private static ProtocolConstants();
}
public class NuGet.Protocol.Providers.OwnerDetailsUriResourceV3Provider : ResourceProvider {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("NuGet.Protocol.Providers.OwnerDetailsUriResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.Providers.VulnerabilityInfoResourceV3Provider : ResourceProvider {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("NuGet.Protocol.Providers.VulnerabilityInfoResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.ProxyAuthenticationHandler : DelegatingHandler {
    public static int MaxAuthRetries;
    private static string BasicAuthenticationType;
    private static SemaphoreSlim _credentialPromptLock;
    private HttpClientHandler _clientHandler;
    private ICredentialService _credentialService;
    private IProxyCredentialCache _credentialCache;
    private int _authRetries;
    public ProxyAuthenticationHandler(HttpClientHandler clientHandler, ICredentialService credentialService, IProxyCredentialCache credentialCache);
    private static ProxyAuthenticationHandler();
    [AsyncStateMachineAttribute("NuGet.Protocol.ProxyAuthenticationHandler/<SendAsync>d__8")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    private static bool ProxyAuthenticationRequired(Exception ex);
    private static HttpWebResponse ExtractResponse(Exception ex);
    private static bool IsMonoProxyAuthenticationRequiredError(WebException ex);
    [AsyncStateMachineAttribute("NuGet.Protocol.ProxyAuthenticationHandler/<AcquireCredentialsAsync>d__12")]
private Task`1<bool> AcquireCredentialsAsync(Uri requestUri, Guid cacheVersion, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.ProxyAuthenticationHandler/<PromptForProxyCredentialsAsync>d__13")]
private Task`1<NetworkCredential> PromptForProxyCredentialsAsync(Uri proxyAddress, IWebProxy proxy, ILogger log, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
[ObsoleteAttribute("Use PackageSearchResource instead (via SourceRepository.GetResourceAsync<PackageSearchResource>")]
public class NuGet.Protocol.RawSearchResourceV3 : object {
    private HttpSource _client;
    private Uri[] _searchEndpoints;
    public RawSearchResourceV3(HttpSource client, IEnumerable`1<Uri> searchEndpoints);
    [AsyncStateMachineAttribute("NuGet.Protocol.RawSearchResourceV3/<SearchPage>d__3")]
[ObsoleteAttribute("Use PackageSearchResource instead (via SourceRepository.GetResourceAsync<PackageSearchResource>")]
public virtual Task`1<JObject> SearchPage(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RawSearchResourceV3/<Search>d__4")]
[ObsoleteAttribute("Use PackageSearchResource instead (via SourceRepository.GetResourceAsync<PackageSearchResource>")]
public virtual Task`1<IEnumerable`1<JObject>> Search(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken cancellationToken);
}
[ObsoleteAttribute("Use PackageSearchResource instead (via SourceRepository.GetResourceAsync<PackageSearchResource>")]
public class NuGet.Protocol.RawSearchResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.RawSearchResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.RegistrationInfo : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludePrerelease>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PackageInfo> <Packages>k__BackingField;
    public string Id { get; public set; }
    public bool IncludePrerelease { get; public set; }
    public IList`1<PackageInfo> Packages { get; private set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public bool get_IncludePrerelease();
    [CompilerGeneratedAttribute]
public void set_IncludePrerelease(bool value);
    [CompilerGeneratedAttribute]
public IList`1<PackageInfo> get_Packages();
    [CompilerGeneratedAttribute]
private void set_Packages(IList`1<PackageInfo> value);
    public void Add(PackageInfo packageInfo);
    public virtual string ToString();
}
public class NuGet.Protocol.RegistrationResourceV3 : object {
    private HttpSource _client;
    [CompilerGeneratedAttribute]
private Uri <BaseUri>k__BackingField;
    public Uri BaseUri { get; }
    public RegistrationResourceV3(HttpSource client, Uri baseUrl);
    [CompilerGeneratedAttribute]
public Uri get_BaseUri();
    public virtual Uri GetUri(string packageId);
    public virtual Uri GetUri(string id, NuGetVersion version);
    public virtual Uri GetUri(PackageIdentity package);
    [AsyncStateMachineAttribute("NuGet.Protocol.RegistrationResourceV3/<GetPackageMetadata>d__8")]
public virtual Task`1<JObject> GetPackageMetadata(PackageIdentity identity, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.RegistrationResourceV3/<GetPackageMetadata>d__9")]
public virtual Task`1<IEnumerable`1<JObject>> GetPackageMetadata(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.RegistrationResourceV3/<GetPackageMetadata>d__10")]
public virtual Task`1<IEnumerable`1<JObject>> GetPackageMetadata(string packageId, VersionRange range, bool includePrerelease, bool includeUnlisted, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    public virtual Task`1<IEnumerable`1<JObject>> GetPackageEntries(string packageId, bool includeUnlisted, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.RegistrationResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.RegistrationResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public static class NuGet.Protocol.RegistrationUtility : object {
    public static VersionRange CreateVersionRange(string stringToParse);
    [AsyncStateMachineAttribute("NuGet.Protocol.RegistrationUtility/<LoadRanges>d__1")]
public static Task`1<IEnumerable`1<JObject>> LoadRanges(HttpSource httpSource, Uri registrationUri, string packageId, VersionRange range, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.RemotePackageArchiveDownloader : object {
    private SourceCacheContext _cacheContext;
    private string _destinationFilePath;
    private Func`2<Exception, Task`1<bool>> _handleExceptionAsync;
    private bool _isDisposed;
    private ILogger _logger;
    private PackageIdentity _packageIdentity;
    private Lazy`1<PackageArchiveReader> _packageReader;
    private FindPackageByIdResource _resource;
    private SemaphoreSlim _throttle;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    public IAsyncPackageContentReader ContentReader { get; }
    public IAsyncPackageCoreReader CoreReader { get; }
    public ISignedPackageReader SignedPackageReader { get; }
    public string Source { get; }
    public RemotePackageArchiveDownloader(string source, FindPackageByIdResource resource, PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger);
    public sealed virtual IAsyncPackageContentReader get_ContentReader();
    public sealed virtual IAsyncPackageCoreReader get_CoreReader();
    public sealed virtual ISignedPackageReader get_SignedPackageReader();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Source();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Protocol.RemotePackageArchiveDownloader/<CopyNupkgFileToAsync>d__20")]
public sealed virtual Task`1<bool> CopyNupkgFileToAsync(string destinationFilePath, CancellationToken cancellationToken);
    public sealed virtual Task`1<string> GetPackageHashAsync(string hashAlgorithm, CancellationToken cancellationToken);
    public sealed virtual void SetExceptionHandler(Func`2<Exception, Task`1<bool>> handleExceptionAsync);
    public sealed virtual void SetThrottle(SemaphoreSlim throttle);
    private PackageArchiveReader GetPackageReader();
    private FileStream GetDestinationStream();
    private void ThrowIfDisposed();
}
public class NuGet.Protocol.RemoteV2FindPackageByIdResource : FindPackageByIdResource {
    private static XName _xnameEntry;
    private static XName _xnameContent;
    private static XName _xnameProperties;
    private static XName _xnameId;
    private static XName _xnameVersion;
    private string _baseUri;
    private HttpSource _httpSource;
    private <095eee27-c9f8-4608-aee1-977bdb32e1fa>TaskResultCache`2<string, List`1<PackageInfo>> _packageVersionsCache;
    private FindPackagesByIdNupkgDownloader _nupkgDownloader;
    private V2FeedQueryBuilder _queryBuilder;
    private static string ResourceTypeName;
    private static string ThisTypeName;
    [CompilerGeneratedAttribute]
private PackageSource <PackageSource>k__BackingField;
    public PackageSource PackageSource { get; }
    public RemoteV2FindPackageByIdResource(PackageSource packageSource, HttpSource httpSource);
    private static RemoteV2FindPackageByIdResource();
    [CompilerGeneratedAttribute]
public PackageSource get_PackageSource();
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<GetAllVersionsAsync>d__16")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<GetDependencyInfoAsync>d__17")]
public virtual Task`1<FindPackageByIdDependencyInfo> GetDependencyInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<CopyNupkgToStreamAsync>d__18")]
public virtual Task`1<bool> CopyNupkgToStreamAsync(string id, NuGetVersion version, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<GetPackageDownloaderAsync>d__19")]
public virtual Task`1<IPackageDownloader> GetPackageDownloaderAsync(PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<DoesPackageExistAsync>d__20")]
public virtual Task`1<bool> DoesPackageExistAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<GetPackageInfoAsync>d__21")]
private Task`1<PackageInfo> GetPackageInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<EnsurePackagesAsync>d__22")]
private Task`1<IEnumerable`1<PackageInfo>> EnsurePackagesAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<FindPackagesByIdAsyncCore>d__23")]
private Task`1<List`1<PackageInfo>> FindPackagesByIdAsyncCore(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    private static PackageInfo BuildModel(string id, XElement element);
}
public class NuGet.Protocol.RemoteV2FindPackageByIdResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository sourceRepository, CancellationToken token);
}
public class NuGet.Protocol.RemoteV3FindPackageByIdResource : FindPackageByIdResource {
    private SemaphoreSlim _dependencyInfoSemaphore;
    private <095eee27-c9f8-4608-aee1-977bdb32e1fa>TaskResultCache`2<string, IEnumerable`1<RemoteSourceDependencyInfo>> _packageVersionsCache;
    private HttpSource _httpSource;
    private FindPackagesByIdNupkgDownloader _nupkgDownloader;
    private DependencyInfoResource _dependencyInfoResource;
    private static string ResourceTypeName;
    private static string ThisTypeName;
    [CompilerGeneratedAttribute]
private SourceRepository <SourceRepository>k__BackingField;
    public SourceRepository SourceRepository { get; }
    public RemoteV3FindPackageByIdResource(SourceRepository sourceRepository, HttpSource httpSource);
    [CompilerGeneratedAttribute]
public SourceRepository get_SourceRepository();
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<GetAllVersionsAsync>d__11")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<GetDependencyInfoAsync>d__12")]
public virtual Task`1<FindPackageByIdDependencyInfo> GetDependencyInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<CopyNupkgToStreamAsync>d__13")]
public virtual Task`1<bool> CopyNupkgToStreamAsync(string id, NuGetVersion version, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<GetPackageDownloaderAsync>d__14")]
public virtual Task`1<IPackageDownloader> GetPackageDownloaderAsync(PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<DoesPackageExistAsync>d__15")]
public virtual Task`1<bool> DoesPackageExistAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<GetPackageInfoAsync>d__16")]
private Task`1<RemoteSourceDependencyInfo> GetPackageInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    private Task`1<IEnumerable`1<RemoteSourceDependencyInfo>> EnsurePackagesAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<FindPackagesByIdAsyncCore>d__18")]
private Task`1<IEnumerable`1<RemoteSourceDependencyInfo>> FindPackagesByIdAsyncCore(string id, SourceCacheContext sourceCacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<EnsureDependencyProvider>d__19")]
private Task EnsureDependencyProvider(CancellationToken cancellationToken);
}
public class NuGet.Protocol.RemoteV3FindPackageByIdResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository sourceRepository, CancellationToken token);
}
public class NuGet.Protocol.ReportAbuseResourceV3 : object {
    private string _uriTemplate;
    public ReportAbuseResourceV3(string uriTemplate);
    public Uri GetReportAbuseUrl(string id, NuGetVersion version);
    private static bool IsValidUriTemplate(string uriTemplate);
}
public class NuGet.Protocol.ReportAbuseResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.ReportAbuseResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.RepositoryCertificateInfo : object {
    [CompilerGeneratedAttribute]
private Fingerprints <Fingerprints>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Issuer>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <NotBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <NotAfter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentUrl>k__BackingField;
    [JsonPropertyAttribute]
public Fingerprints Fingerprints { get; private set; }
    [JsonPropertyAttribute]
public string Subject { get; private set; }
    [JsonPropertyAttribute]
public string Issuer { get; private set; }
    [JsonPropertyAttribute]
public DateTimeOffset NotBefore { get; private set; }
    [JsonPropertyAttribute]
public DateTimeOffset NotAfter { get; private set; }
    [JsonPropertyAttribute]
public string ContentUrl { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual Fingerprints get_Fingerprints();
    [CompilerGeneratedAttribute]
private void set_Fingerprints(Fingerprints value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Subject();
    [CompilerGeneratedAttribute]
private void set_Subject(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Issuer();
    [CompilerGeneratedAttribute]
private void set_Issuer(string value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_NotBefore();
    [CompilerGeneratedAttribute]
private void set_NotBefore(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_NotAfter();
    [CompilerGeneratedAttribute]
private void set_NotAfter(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ContentUrl();
    [CompilerGeneratedAttribute]
private void set_ContentUrl(string value);
}
public class NuGet.Protocol.RepositorySignatureResource : object {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllRepositorySigned>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IRepositoryCertificateInfo> <RepositoryCertificateInfos>k__BackingField;
    public string Source { get; }
    public bool AllRepositorySigned { get; }
    public IEnumerable`1<IRepositoryCertificateInfo> RepositoryCertificateInfos { get; }
    public RepositorySignatureResource(JObject repoSignInformationContent, SourceRepository source);
    public RepositorySignatureResource(bool allRepositorySigned, IEnumerable`1<IRepositoryCertificateInfo> repositoryCertInfos);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public bool get_AllRepositorySigned();
    [CompilerGeneratedAttribute]
public IEnumerable`1<IRepositoryCertificateInfo> get_RepositoryCertificateInfos();
    public void UpdateRepositorySignatureInfo();
}
public class NuGet.Protocol.RepositorySignatureResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.RepositorySignatureResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.RepositorySignatureResourceProvider/<GetRepositorySignatureResourceAsync>d__2")]
private Task`1<RepositorySignatureResource> GetRepositorySignatureResourceAsync(SourceRepository source, ServiceIndexEntry serviceEntry, ILogger log, CancellationToken token);
    private static string GenerateCacheKey(ServiceIndexEntry serviceEntry);
}
internal static class NuGet.Protocol.ResolverMetadataClient : object {
    [AsyncStateMachineAttribute("NuGet.Protocol.ResolverMetadataClient/<GetDependencies>d__0")]
public static Task`1<IEnumerable`1<RemoteSourceDependencyInfo>> GetDependencies(HttpSource httpClient, Uri registrationUri, string packageId, VersionRange range, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    private static RemoteSourceDependencyInfo ProcessPackageVersion(JObject packageObj, NuGetVersion version);
    [AsyncStateMachineAttribute("NuGet.Protocol.ResolverMetadataClient/<GetRegistrationInfo>d__2")]
public static Task`1<RegistrationInfo> GetRegistrationInfo(HttpSource httpClient, Uri registrationUri, string packageId, VersionRange range, SourceCacheContext cacheContext, NuGetFramework projectTargetFramework, ILogger log, CancellationToken token);
    private static NuGetFramework GetFramework(JObject dependencyGroupObj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Protocol.Resources.OwnerDetailsUriTemplateResourceV3 : object {
    private string _template;
    private OwnerDetailsUriTemplateResourceV3(string template);
    public static OwnerDetailsUriTemplateResourceV3 CreateOrNull(Uri uriTemplate);
    public Uri GetUri(string owner);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Protocol.Resources.VulnerabilityInfoResourceV3 : object {
    private SourceRepository _sourceRepository;
    internal VulnerabilityInfoResourceV3(SourceRepository sourceRepository);
    [AsyncStateMachineAttribute("NuGet.Protocol.Resources.VulnerabilityInfoResourceV3/<GetVulnerabilityFilesAsync>d__2")]
public Task`1<IReadOnlyList`1<V3VulnerabilityIndexEntry>> GetVulnerabilityFilesAsync(SourceCacheContext cacheContext, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Resources.VulnerabilityInfoResourceV3/<GetVulnerabilityDataAsync>d__3")]
public Task`1<IReadOnlyDictionary`2<string, IReadOnlyList`1<PackageVulnerabilityInfo>>> GetVulnerabilityDataAsync(V3VulnerabilityIndexEntry vulnerabilityPage, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Resources.VulnerabilityInfoResourceV3/<GetVulnerabilityInfoAsync>d__4")]
public sealed virtual Task`1<GetVulnerabilityInfoResult> GetVulnerabilityInfoAsync(SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    private IReadOnlyList`1<V3VulnerabilityIndexEntry> GetValidIndexEntries(IReadOnlyList`1<V3VulnerabilityIndexEntry> indexEntries, List`1& exceptions);
    private static void AddException(Exception exception, List`1& exceptions);
    [AsyncStateMachineAttribute("NuGet.Protocol.Resources.VulnerabilityInfoResourceV3/<<GetVulnerabilityFilesAsync>g__GetIndexUrlAsync|2_0>d")]
[CompilerGeneratedAttribute]
private Task`1<Uri> <GetVulnerabilityFilesAsync>g__GetIndexUrlAsync|2_0(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static AggregateException <GetVulnerabilityInfoAsync>g__ToAggregateException|4_0(IEnumerable`1<Exception> exceptions);
}
public class NuGet.Protocol.SafeBoolConverter : JsonConverter {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NuGet.Protocol.SafeUriConverter : JsonConverter {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NuGet.Protocol.SemanticVersionConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NuGet.Protocol.SemaphoreSlimThrottle : object {
    private SemaphoreSlim _semaphore;
    public int CurrentCount { get; }
    public SemaphoreSlimThrottle(SemaphoreSlim semaphore);
    public int get_CurrentCount();
    [AsyncStateMachineAttribute("NuGet.Protocol.SemaphoreSlimThrottle/<WaitAsync>d__4")]
public sealed virtual Task WaitAsync();
    public sealed virtual void Release();
    public static SemaphoreSlimThrottle CreateBinarySemaphore();
    public static SemaphoreSlimThrottle CreateSemaphoreThrottle(int initialCount);
}
public class NuGet.Protocol.ServerWarningLogHandler : DelegatingHandler {
    public ServerWarningLogHandler(HttpClientHandler clientHandler);
    [AsyncStateMachineAttribute("NuGet.Protocol.ServerWarningLogHandler/<SendAsync>d__1")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
public class NuGet.Protocol.ServiceIndexEntry : object {
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <ClientVersion>k__BackingField;
    public Uri Uri { get; }
    public string Type { get; }
    public SemanticVersion ClientVersion { get; }
    public ServiceIndexEntry(Uri serviceUri, string serviceType, SemanticVersion clientVersion);
    [CompilerGeneratedAttribute]
public Uri get_Uri();
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public SemanticVersion get_ClientVersion();
}
public class NuGet.Protocol.ServiceIndexResourceV3 : object {
    private string _json;
    private IDictionary`2<string, List`1<ServiceIndexEntry>> _index;
    private DateTime _requestTime;
    private static IReadOnlyList`1<ServiceIndexEntry> _emptyEntries;
    private static SemanticVersion _defaultVersion;
    public DateTime RequestTime { get; }
    public IReadOnlyList`1<ServiceIndexEntry> Entries { get; }
    public string Json { get; }
    public ServiceIndexResourceV3(JObject index, DateTime requestTime);
    private static ServiceIndexResourceV3();
    public virtual DateTime get_RequestTime();
    public virtual IReadOnlyList`1<ServiceIndexEntry> get_Entries();
    public virtual string get_Json();
    public virtual IReadOnlyList`1<ServiceIndexEntry> GetServiceEntries(String[] orderedTypes);
    public virtual IReadOnlyList`1<ServiceIndexEntry> GetServiceEntries(NuGetVersion clientVersion, String[] orderedTypes);
    private IReadOnlyList`1<ServiceIndexEntry> GetBestVersionMatchForType(NuGetVersion clientVersion, List`1<ServiceIndexEntry> entries);
    public virtual Uri GetServiceEntryUri(String[] orderedTypes);
    public virtual IReadOnlyList`1<Uri> GetServiceEntryUris(String[] orderedTypes);
    public virtual IReadOnlyList`1<Uri> GetServiceEntryUris(NuGetVersion clientVersion, String[] orderedTypes);
    private static IDictionary`2<string, List`1<ServiceIndexEntry>> MakeLookup(JObject index);
    [IteratorStateMachineAttribute("NuGet.Protocol.ServiceIndexResourceV3/<GetValues>d__19")]
private static IEnumerable`1<string> GetValues(JToken token);
}
public class NuGet.Protocol.ServiceIndexResourceV3Provider : ResourceProvider {
    private static TimeSpan _defaultCacheDuration;
    private ConcurrentDictionary`2<string, ServiceIndexCacheInfo> _cache;
    private SemaphoreSlim _semaphore;
    private EnhancedHttpRetryHelper _enhancedHttpRetryHelper;
    [CompilerGeneratedAttribute]
private TimeSpan <MaxCacheDuration>k__BackingField;
    public TimeSpan MaxCacheDuration { get; protected set; }
    internal ServiceIndexResourceV3Provider(IEnvironmentVariableReader environmentVariableReader);
    private static ServiceIndexResourceV3Provider();
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxCacheDuration();
    [CompilerGeneratedAttribute]
protected void set_MaxCacheDuration(TimeSpan value);
    [AsyncStateMachineAttribute("NuGet.Protocol.ServiceIndexResourceV3Provider/<TryCreate>d__10")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.ServiceIndexResourceV3Provider/<GetServiceIndexResourceV3>d__11")]
private Task`1<ServiceIndexResourceV3> GetServiceIndexResourceV3(SourceRepository source, DateTime utcNow, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.ServiceIndexResourceV3Provider/<ConsumeServiceIndexStreamAsync>d__12")]
private Task`1<ServiceIndexResourceV3> ConsumeServiceIndexStreamAsync(Stream stream, DateTime utcNow, CancellationToken token);
}
public static class NuGet.Protocol.ServiceTypes : object {
    public static string Version200;
    public static string Version300beta;
    public static string Version300rc;
    public static string Version300;
    public static string Version340;
    public static string Version360;
    public static string Versioned;
    public static string Version470;
    public static string Version490;
    public static string Version500;
    public static string Version510;
    internal static string Version670;
    internal static string Version6110;
    public static String[] SearchQueryService;
    public static String[] RegistrationsBaseUrl;
    public static String[] SearchAutocompleteService;
    public static String[] ReportAbuse;
    public static String[] PackageDetailsUriTemplate;
    public static String[] LegacyGallery;
    public static String[] PackagePublish;
    public static String[] PackageBaseAddress;
    public static String[] RepositorySignatures;
    public static String[] SymbolPackagePublish;
    internal static String[] VulnerabilityInfo;
    internal static String[] OwnerDetailsUriTemplate;
    private static ServiceTypes();
}
[ExtensionAttribute]
public static class NuGet.Protocol.StreamExtensions : object {
    public static int BufferSize;
    private static StreamExtensions();
    [AsyncStateMachineAttribute("NuGet.Protocol.StreamExtensions/<CopyToAsync>d__1")]
[ExtensionAttribute]
public static Task CopyToAsync(Stream stream, Stream destination, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.StreamExtensions/<AsJObjectAsync>d__2")]
[ExtensionAttribute]
internal static Task`1<JObject> AsJObjectAsync(Stream stream, CancellationToken token);
    [ExtensionAttribute]
internal static Task`1<Stream> AsSeekableStreamAsync(Stream stream, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.StreamExtensions/<AsSeekableStreamAsync>d__4")]
[ExtensionAttribute]
internal static Task`1<Stream> AsSeekableStreamAsync(Stream stream, bool leaveStreamOpen, CancellationToken token);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Protocol.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AddPackage_ExistingPackageInvalid { get; }
    internal static string AddPackage_PackageAlreadyExists { get; }
    internal static string AddPackage_SuccessfullyAdded { get; }
    internal static string Argument_Cannot_Be_Null_Or_Empty { get; }
    internal static string ArgumentCannotBeNullOrEmpty { get; }
    internal static string DefaultSymbolServer { get; }
    internal static string DeleteCommandCanceled { get; }
    internal static string DeleteCommandConfirm { get; }
    internal static string DeleteCommandDeletedPackage { get; }
    internal static string DeleteCommandDeletingPackage { get; }
    internal static string DeletePackage_NotFound { get; }
    internal static string Error_DownloadTimeout { get; }
    internal static string Http_CredentialsForForbidden { get; }
    internal static string Http_CredentialsForProxy { get; }
    internal static string Http_CredentialsForUnauthorized { get; }
    internal static string Http_RequestLog { get; }
    internal static string Http_ResponseLog { get; }
    internal static string Http_ResponseLogWithRetryAfter { get; }
    internal static string Http_Timeout { get; }
    internal static string InvalidVersionFolder { get; }
    internal static string LiveFeed { get; }
    internal static string LoadFileFromNupkg_FileNotFound { get; }
    internal static string LoadFileFromNupkg_FileTooLarge { get; }
    internal static string LoadFileFromNupkg_UnknownProblemLoadingTheFile { get; }
    internal static string Log_CanceledNupkgDownload { get; }
    internal static string Log_ErrorDownloading { get; }
    internal static string Log_FailedToDownloadPackage { get; }
    internal static string Log_FailedToFetchV2Feed { get; }
    internal static string Log_FailedToFetchV2FeedHttp { get; }
    internal static string Log_FailedToGetNuspecStream { get; }
    internal static string Log_FailedToParseRepoSignInfor { get; }
    internal static string Log_FailedToReadRepositorySignature { get; }
    internal static string Log_FailedToReadServiceIndex { get; }
    internal static string Log_FailedToRetrievePackage { get; }
    internal static string Log_FailedToVerifyRootDirectory { get; }
    internal static string Log_FailedToVerifyValidFile { get; }
    internal static string Log_FileIsCorrupt { get; }
    internal static string Log_InvalidCacheEntry { get; }
    internal static string Log_InvalidNupkgFromUrl { get; }
    internal static string Log_LocalSourceNotExist { get; }
    internal static string Log_RetryingFindPackagesById { get; }
    internal static string Log_RetryingHttp { get; }
    internal static string Log_RetryingRepositorySignature { get; }
    internal static string Log_RetryingServiceIndex { get; }
    internal static string NoApiKeyFound { get; }
    internal static string NuGetLicense_LicenseExpressionVersionTooHigh { get; }
    internal static string NuGetLicenseExpression_NonStandardIdentifier { get; }
    internal static string NupkgPath_Invalid { get; }
    internal static string NupkgPath_InvalidEx { get; }
    internal static string OneOrMoreUrisMustBeSpecified { get; }
    internal static string PackageNotFound { get; }
    internal static string PackageServerEndpoint_NotSupported { get; }
    internal static string Path_Invalid { get; }
    internal static string Path_Invalid_NotFileNotUnc { get; }
    internal static string Plugin_ConnectionAlreadyStarted { get; }
    internal static string Plugin_ConnectionIsClosed { get; }
    internal static string Plugin_DownloadNotSupportedSinceUnsignedNotAllowed { get; }
    internal static string Plugin_Exception { get; }
    internal static string Plugin_FailedOnCreation { get; }
    internal static string Plugin_FailedOperationForPackage { get; }
    internal static string Plugin_FailureQueryingPackageVersions { get; }
    internal static string Plugin_Fault { get; }
    internal static string Plugin_FileNotFound { get; }
    internal static string Plugin_HandshakeFailed { get; }
    internal static string Plugin_HandshakeRequestHandlerAlreadyExists { get; }
    internal static string Plugin_IdleTimeoutMustBeGreaterThanOrEqualToInfiniteTimeSpan { get; }
    internal static string Plugin_InitializationFailed { get; }
    internal static string Plugin_InvalidEmbeddedSignature { get; }
    internal static string Plugin_InvalidMessageType { get; }
    internal static string Plugin_InvalidPluginFilePath { get; }
    internal static string Plugin_NotConnected { get; }
    internal static string Plugin_PackageDownloadFailed { get; }
    internal static string Plugin_ProblemStartingPlugin { get; }
    internal static string Plugin_ProtocolException { get; }
    internal static string Plugin_ProtocolVersionNotSupportedOnError { get; }
    internal static string Plugin_ProtocolVersionOutOfRange { get; }
    internal static string Plugin_RequestContextDoesNotExist { get; }
    internal static string Plugin_RequestHandlerDoesNotExist { get; }
    internal static string Plugin_TimeoutOutOfRange { get; }
    internal static string Plugin_UnrecognizedEnumValue { get; }
    internal static string Plugin_UnrecognizedOperationClaims { get; }
    internal static string Protocol_BadSource { get; }
    internal static string Protocol_duplicateUri { get; }
    internal static string Protocol_InvalidJsonObject { get; }
    internal static string Protocol_InvalidXml { get; }
    internal static string Protocol_MalformedMetadataError { get; }
    internal static string Protocol_MissingSearchService { get; }
    internal static string Protocol_MissingVersion { get; }
    internal static string Protocol_PackageMetadataError { get; }
    internal static string Protocol_Search_LocalSourceNotFound { get; }
    internal static string Protocol_UnsupportedVersion { get; }
    internal static string PushCommandPackagePushed { get; }
    internal static string PushCommandPushingPackage { get; }
    internal static string PushCommandSkipDuplicateAdvertiseDotnetExe { get; }
    internal static string PushCommandSkipDuplicateAdvertiseNuGetExe { get; }
    internal static string PushCommandSkipDuplicateNotImplemented { get; }
    internal static string RepositoryContentUrlMustBeHttps { get; }
    internal static string RepositorySignaturesResourceMustBeHttps { get; }
    internal static string StringCannotBeNullOrEmpty { get; }
    internal static string UnableToFindFile { get; }
    internal static string UnableToParseFolderV3Version { get; }
    internal static string Vulnerability_TooManyPages { get; }
    internal static string VulnerabilityPage_CouldNotLoad { get; }
    internal static string VulnerabilityPage_HasNoName { get; }
    internal static string VulnerabilityPage_NameHasInvalidCharacters { get; }
    internal static string VulnerabilityPage_NameNotUnique { get; }
    internal static string VulnerabilityPage_NameTooLong { get; }
    internal static string VulnerabilityPage_NoUrl { get; }
    internal static string VulnerabilityPage_UrlNotHttp { get; }
    internal static string Warning_HttpServerUsage { get; }
    internal static string Warning_SymbolServerNotConfigured { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AddPackage_ExistingPackageInvalid();
    internal static string get_AddPackage_PackageAlreadyExists();
    internal static string get_AddPackage_SuccessfullyAdded();
    internal static string get_Argument_Cannot_Be_Null_Or_Empty();
    internal static string get_ArgumentCannotBeNullOrEmpty();
    internal static string get_DefaultSymbolServer();
    internal static string get_DeleteCommandCanceled();
    internal static string get_DeleteCommandConfirm();
    internal static string get_DeleteCommandDeletedPackage();
    internal static string get_DeleteCommandDeletingPackage();
    internal static string get_DeletePackage_NotFound();
    internal static string get_Error_DownloadTimeout();
    internal static string get_Http_CredentialsForForbidden();
    internal static string get_Http_CredentialsForProxy();
    internal static string get_Http_CredentialsForUnauthorized();
    internal static string get_Http_RequestLog();
    internal static string get_Http_ResponseLog();
    internal static string get_Http_ResponseLogWithRetryAfter();
    internal static string get_Http_Timeout();
    internal static string get_InvalidVersionFolder();
    internal static string get_LiveFeed();
    internal static string get_LoadFileFromNupkg_FileNotFound();
    internal static string get_LoadFileFromNupkg_FileTooLarge();
    internal static string get_LoadFileFromNupkg_UnknownProblemLoadingTheFile();
    internal static string get_Log_CanceledNupkgDownload();
    internal static string get_Log_ErrorDownloading();
    internal static string get_Log_FailedToDownloadPackage();
    internal static string get_Log_FailedToFetchV2Feed();
    internal static string get_Log_FailedToFetchV2FeedHttp();
    internal static string get_Log_FailedToGetNuspecStream();
    internal static string get_Log_FailedToParseRepoSignInfor();
    internal static string get_Log_FailedToReadRepositorySignature();
    internal static string get_Log_FailedToReadServiceIndex();
    internal static string get_Log_FailedToRetrievePackage();
    internal static string get_Log_FailedToVerifyRootDirectory();
    internal static string get_Log_FailedToVerifyValidFile();
    internal static string get_Log_FileIsCorrupt();
    internal static string get_Log_InvalidCacheEntry();
    internal static string get_Log_InvalidNupkgFromUrl();
    internal static string get_Log_LocalSourceNotExist();
    internal static string get_Log_RetryingFindPackagesById();
    internal static string get_Log_RetryingHttp();
    internal static string get_Log_RetryingRepositorySignature();
    internal static string get_Log_RetryingServiceIndex();
    internal static string get_NoApiKeyFound();
    internal static string get_NuGetLicense_LicenseExpressionVersionTooHigh();
    internal static string get_NuGetLicenseExpression_NonStandardIdentifier();
    internal static string get_NupkgPath_Invalid();
    internal static string get_NupkgPath_InvalidEx();
    internal static string get_OneOrMoreUrisMustBeSpecified();
    internal static string get_PackageNotFound();
    internal static string get_PackageServerEndpoint_NotSupported();
    internal static string get_Path_Invalid();
    internal static string get_Path_Invalid_NotFileNotUnc();
    internal static string get_Plugin_ConnectionAlreadyStarted();
    internal static string get_Plugin_ConnectionIsClosed();
    internal static string get_Plugin_DownloadNotSupportedSinceUnsignedNotAllowed();
    internal static string get_Plugin_Exception();
    internal static string get_Plugin_FailedOnCreation();
    internal static string get_Plugin_FailedOperationForPackage();
    internal static string get_Plugin_FailureQueryingPackageVersions();
    internal static string get_Plugin_Fault();
    internal static string get_Plugin_FileNotFound();
    internal static string get_Plugin_HandshakeFailed();
    internal static string get_Plugin_HandshakeRequestHandlerAlreadyExists();
    internal static string get_Plugin_IdleTimeoutMustBeGreaterThanOrEqualToInfiniteTimeSpan();
    internal static string get_Plugin_InitializationFailed();
    internal static string get_Plugin_InvalidEmbeddedSignature();
    internal static string get_Plugin_InvalidMessageType();
    internal static string get_Plugin_InvalidPluginFilePath();
    internal static string get_Plugin_NotConnected();
    internal static string get_Plugin_PackageDownloadFailed();
    internal static string get_Plugin_ProblemStartingPlugin();
    internal static string get_Plugin_ProtocolException();
    internal static string get_Plugin_ProtocolVersionNotSupportedOnError();
    internal static string get_Plugin_ProtocolVersionOutOfRange();
    internal static string get_Plugin_RequestContextDoesNotExist();
    internal static string get_Plugin_RequestHandlerDoesNotExist();
    internal static string get_Plugin_TimeoutOutOfRange();
    internal static string get_Plugin_UnrecognizedEnumValue();
    internal static string get_Plugin_UnrecognizedOperationClaims();
    internal static string get_Protocol_BadSource();
    internal static string get_Protocol_duplicateUri();
    internal static string get_Protocol_InvalidJsonObject();
    internal static string get_Protocol_InvalidXml();
    internal static string get_Protocol_MalformedMetadataError();
    internal static string get_Protocol_MissingSearchService();
    internal static string get_Protocol_MissingVersion();
    internal static string get_Protocol_PackageMetadataError();
    internal static string get_Protocol_Search_LocalSourceNotFound();
    internal static string get_Protocol_UnsupportedVersion();
    internal static string get_PushCommandPackagePushed();
    internal static string get_PushCommandPushingPackage();
    internal static string get_PushCommandSkipDuplicateAdvertiseDotnetExe();
    internal static string get_PushCommandSkipDuplicateAdvertiseNuGetExe();
    internal static string get_PushCommandSkipDuplicateNotImplemented();
    internal static string get_RepositoryContentUrlMustBeHttps();
    internal static string get_RepositorySignaturesResourceMustBeHttps();
    internal static string get_StringCannotBeNullOrEmpty();
    internal static string get_UnableToFindFile();
    internal static string get_UnableToParseFolderV3Version();
    internal static string get_Vulnerability_TooManyPages();
    internal static string get_VulnerabilityPage_CouldNotLoad();
    internal static string get_VulnerabilityPage_HasNoName();
    internal static string get_VulnerabilityPage_NameHasInvalidCharacters();
    internal static string get_VulnerabilityPage_NameNotUnique();
    internal static string get_VulnerabilityPage_NameTooLong();
    internal static string get_VulnerabilityPage_NoUrl();
    internal static string get_VulnerabilityPage_UrlNotHttp();
    internal static string get_Warning_HttpServerUsage();
    internal static string get_Warning_SymbolServerNotConfigured();
}
public class NuGet.Protocol.StsAuthenticationHandler : DelegatingHandler {
    private static SemaphoreSlim _credentialPromptLock;
    public static string STSEndPointHeader;
    public static string STSRealmHeader;
    public static string STSTokenHeader;
    private Uri _baseUri;
    private TokenStore _tokenStore;
    private Func`3<string, string, string> _tokenFactory;
    public StsAuthenticationHandler(PackageSource packageSource, TokenStore tokenStore);
    public StsAuthenticationHandler(PackageSource packageSource, TokenStore tokenStore, Func`3<string, string, string> tokenFactory);
    private static StsAuthenticationHandler();
    [AsyncStateMachineAttribute("NuGet.Protocol.StsAuthenticationHandler/<SendAsync>d__9")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    private void PrepareSTSRequest(HttpRequestMessage request);
    public bool TryRetrieveSTSToken(HttpResponseMessage response);
    private static string AcquireSTSToken(string endpoint, string realm);
    private static string GetHeader(HttpResponseMessage response, string header);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
public class NuGet.Protocol.SymbolPackageUpdateResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.SymbolPackageUpdateResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public static class NuGet.Protocol.TimeoutUtility : object {
    [AsyncStateMachineAttribute("NuGet.Protocol.TimeoutUtility/<StartWithTimeout>d__0`1")]
public static Task`1<T> StartWithTimeout(Func`2<CancellationToken, Task`1<T>> getTask, TimeSpan timeout, string timeoutMessage, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.TimeoutUtility/<StartWithTimeout>d__1")]
public static Task StartWithTimeout(Func`2<CancellationToken, Task> getTask, TimeSpan timeout, string timeoutMessage, CancellationToken token);
}
public class NuGet.Protocol.TokenStore : object {
    private ConcurrentDictionary`2<Uri, string> _tokenCache;
    [CompilerGeneratedAttribute]
private static TokenStore <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Version>k__BackingField;
    public static TokenStore Instance { get; }
    public Guid Version { get; private set; }
    private static TokenStore();
    [CompilerGeneratedAttribute]
public static TokenStore get_Instance();
    [CompilerGeneratedAttribute]
public Guid get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(Guid value);
    public string GetToken(Uri sourceUri);
    public void AddToken(Uri sourceUri, string token);
    private void StoreToken(Uri uri, string token);
    private static Uri GetRootUri(Uri uri);
}
internal static class NuGet.Protocol.Trim : object {
    public static void TrimByAllowedVersions(RegistrationInfo registrationInfo, IDictionary`2<string, VersionRange> allowedVersions);
    private static void Execute(RegistrationInfo registrationInfo, KeyValuePair`2<string, VersionRange> allowedVersion);
    private static void Pass1(PackageInfo packageInfo, KeyValuePair`2<string, VersionRange> allowedVersion);
    private static void Pass1(RegistrationInfo registrationInfo, KeyValuePair`2<string, VersionRange> allowedVersion);
    private static void Pass2(PackageInfo packageInfo, Boolean& updated);
    private static void Pass2(RegistrationInfo registrationInfo, Boolean& updated);
    private static bool CheckDependenciesExists(PackageInfo packageInfo);
}
internal static class NuGet.Protocol.Types : object {
    public static Uri PackageSearchResult;
    public static Uri PackageIdentity;
    public static Uri PackageDescription;
    public static Uri PackageLicensing;
    public static Uri PackageDependencies;
    public static Uri DependencyGroup;
    public static Uri Dependency;
    public static Uri Stats;
    private static Types();
}
public class NuGet.Protocol.V2FeedListResource : ListResource {
    private ILegacyFeedCapabilityResource _feedCapabilities;
    private IV2FeedParser _feedParser;
    private string _baseAddress;
    private static int Take;
    public string Source { get; }
    public V2FeedListResource(IV2FeedParser feedParser, ILegacyFeedCapabilityResource feedCapabilities, string baseAddress);
    public virtual string get_Source();
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedListResource/<ListAsync>d__7")]
public virtual Task`1<IEnumerableAsync`1<IPackageSearchMetadata>> ListAsync(string searchTerm, bool prerelease, bool allVersions, bool includeDelisted, ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.V2FeedListResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedListResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.V2FeedPackageInfo : PackageIdentity {
    private string _title;
    private string _summary;
    private String[] _authors;
    private string _description;
    private String[] _owners;
    private string _iconUrl;
    private string _licenseUrl;
    private string _projectUrl;
    private string _reportAbuseUrl;
    private string _galleryDetailsUrl;
    private string _tags;
    private string _downloadCount;
    private bool _requireLicenseAcceptance;
    private Nullable`1<DateTimeOffset> _created;
    private Nullable`1<DateTimeOffset> _lastEdited;
    private Nullable`1<DateTimeOffset> _published;
    private string _dependencies;
    private string _downloadUrl;
    private string _packageHash;
    private string _packageHashAlgorithm;
    private NuGetVersion _minClientVersion;
    private static string NullString;
    public string Title { get; }
    public string Summary { get; }
    public string Description { get; }
    public IEnumerable`1<string> Authors { get; }
    public IEnumerable`1<string> Owners { get; }
    public string IconUrl { get; }
    public string LicenseUrl { get; }
    public string ProjectUrl { get; }
    public string DownloadUrl { get; }
    public string ReportAbuseUrl { get; }
    public string GalleryDetailsUrl { get; }
    public string Tags { get; }
    public string DownloadCount { get; }
    public int DownloadCountAsInt { get; }
    public Nullable`1<DateTimeOffset> Created { get; }
    public Nullable`1<DateTimeOffset> LastEdited { get; }
    public Nullable`1<DateTimeOffset> Published { get; }
    public bool IsListed { get; }
    public string Dependencies { get; }
    public IReadOnlyList`1<PackageDependencyGroup> DependencySets { get; }
    public bool RequireLicenseAcceptance { get; }
    public string PackageHash { get; }
    public string PackageHashAlgorithm { get; }
    public NuGetVersion MinClientVersion { get; }
    public V2FeedPackageInfo(PackageIdentity identity, string title, string summary, string description, IEnumerable`1<string> authors, IEnumerable`1<string> owners, string iconUrl, string licenseUrl, string projectUrl, string reportAbuseUrl, string galleryDetailsUrl, string tags, Nullable`1<DateTimeOffset> created, Nullable`1<DateTimeOffset> lastEdited, Nullable`1<DateTimeOffset> published, string dependencies, bool requireLicenseAccept, string downloadUrl, string downloadCount, string packageHash, string packageHashAlgorithm, NuGetVersion minClientVersion);
    public string get_Title();
    public string get_Summary();
    public string get_Description();
    public IEnumerable`1<string> get_Authors();
    public IEnumerable`1<string> get_Owners();
    public string get_IconUrl();
    public string get_LicenseUrl();
    public string get_ProjectUrl();
    public string get_DownloadUrl();
    public string get_ReportAbuseUrl();
    public string get_GalleryDetailsUrl();
    public string get_Tags();
    public string get_DownloadCount();
    public int get_DownloadCountAsInt();
    public Nullable`1<DateTimeOffset> get_Created();
    public Nullable`1<DateTimeOffset> get_LastEdited();
    public Nullable`1<DateTimeOffset> get_Published();
    public bool get_IsListed();
    public string get_Dependencies();
    public IReadOnlyList`1<PackageDependencyGroup> get_DependencySets();
    public bool get_RequireLicenseAcceptance();
    public string get_PackageHash();
    public string get_PackageHashAlgorithm();
    public NuGetVersion get_MinClientVersion();
}
public class NuGet.Protocol.V2FeedPage : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<V2FeedPackageInfo> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NextUri>k__BackingField;
    public IReadOnlyList`1<V2FeedPackageInfo> Items { get; }
    public string NextUri { get; }
    public V2FeedPage(List`1<V2FeedPackageInfo> items, string nextUri);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<V2FeedPackageInfo> get_Items();
    [CompilerGeneratedAttribute]
public string get_NextUri();
}
public class NuGet.Protocol.V2FeedParser : object {
    private static string W3Atom;
    private static string MetadataNS;
    private static string DataServicesNS;
    private static XName _xnameEntry;
    private static XName _xnameTitle;
    private static XName _xnameContent;
    private static XName _xnameLink;
    private static XName _xnameProperties;
    private static XName _xnameId;
    private static XName _xnameVersion;
    private static XName _xnameSummary;
    private static XName _xnameDescription;
    private static XName _xnameIconUrl;
    private static XName _xnameLicenseUrl;
    private static XName _xnameProjectUrl;
    private static XName _xnameTags;
    private static XName _xnameGalleryDetailsUrl;
    private static XName _xnameReportAbuseUrl;
    private static XName _xnameDependencies;
    private static XName _xnameRequireLicenseAcceptance;
    private static XName _xnameDownloadCount;
    private static XName _xnameCreated;
    private static XName _xnameLastEdited;
    private static XName _xnamePublished;
    private static XName _xnameName;
    private static XName _xnameAuthor;
    private static XName _xnamePackageHash;
    private static XName _xnamePackageHashAlgorithm;
    private static XName _xnameMinClientVersion;
    private HttpSource _httpSource;
    private string _baseAddress;
    private V2FeedQueryBuilder _queryBuilder;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    public string Source { get; private set; }
    public V2FeedParser(HttpSource httpSource, string baseAddress);
    public V2FeedParser(HttpSource httpSource, string baseAddress, string source);
    private static V2FeedParser();
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(string value);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<GetPackage>d__38")]
public Task`1<V2FeedPackageInfo> GetPackage(PackageIdentity package, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<FindPackagesByIdAsync>d__39")]
public Task`1<IReadOnlyList`1<V2FeedPackageInfo>> FindPackagesByIdAsync(string id, bool includeUnlisted, bool includePrerelease, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public Task`1<IReadOnlyList`1<V2FeedPackageInfo>> FindPackagesByIdAsync(string id, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<GetPackagesPageAsync>d__41")]
public sealed virtual Task`1<V2FeedPage> GetPackagesPageAsync(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<GetSearchPageAsync>d__42")]
public sealed virtual Task`1<V2FeedPage> GetSearchPageAsync(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<Search>d__43")]
public Task`1<IReadOnlyList`1<V2FeedPackageInfo>> Search(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<DownloadFromUrl>d__44")]
public Task`1<DownloadResourceResult> DownloadFromUrl(PackageIdentity package, Uri downloadUri, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<DownloadFromIdentity>d__45")]
public Task`1<DownloadResourceResult> DownloadFromIdentity(PackageIdentity package, PackageDownloadContext downloadContext, string globalPackagesFolder, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    private IEnumerable`1<V2FeedPackageInfo> ParsePage(XDocument doc, string id, MetadataReferenceCache metadataCache);
    private V2FeedPackageInfo ParsePackage(string id, XElement element, MetadataReferenceCache metadataCache);
    private static string GetString(XElement parent, XName childName);
    private static Nullable`1<DateTimeOffset> GetDate(XElement parent, XName childName);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<QueryV2FeedAsync>d__50")]
public Task`1<V2FeedPage> QueryV2FeedAsync(string relativeUri, string id, int max, bool ignoreNotFounds, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    private string GetCacheKey(string relativeUri, int page);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<LoadXmlAsync>d__52")]
internal Task`1<XDocument> LoadXmlAsync(string uri, string cacheKey, bool ignoreNotFounds, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    internal static string GetNextUrl(XDocument doc);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<LoadXmlAsync>d__54")]
internal static Task`1<XDocument> LoadXmlAsync(Stream stream, CancellationToken token);
}
public class NuGet.Protocol.V2FeedQueryBuilder : object {
    private static string IsLatestVersionFilterFlag;
    private static string IsAbsoluteLatestVersionFilterFlag;
    private static string IdProperty;
    private static string SemVerLevel;
    private static string GetSpecificPackageFormat;
    private static string SearchEndpointFormat;
    private static string QueryDelimiter;
    private static string FindPackagesByIdFormat;
    private static string GetPackagesFormat;
    private static string EndpointParenthesis;
    private static string SearchClauseFormat;
    private static string OrFormat;
    private static string AndFormat;
    private static string FilterFormat;
    private static string OrderByFormat;
    private static string SkipFormat;
    private static string TopFormat;
    private static string TagTermFormat;
    private static string FirstParameterFormat;
    private static string ParameterFormat;
    private static string TagsProperty;
    private static String[] _propertiesToSearch;
    private static V2FeedQueryBuilder();
    public string BuildSearchUri(string searchTerm, SearchFilter filters, int skip, int take);
    public string BuildFindPackagesByIdUri(string id);
    public string BuildGetPackageUri(PackageIdentity package);
    public string BuildGetPackagesUri(string searchTerm, SearchFilter filters, Nullable`1<int> skip, Nullable`1<int> take);
    private string BuildTop(Nullable`1<int> top);
    private string BuildSkip(Nullable`1<int> skip);
    private string BuildFilter(string searchTerm, Nullable`1<SearchFilterType> searchFilterType);
    private string BuildOrderBy(Nullable`1<SearchOrderBy> searchOrderBy);
    private string BuildPropertyFilter(Nullable`1<SearchFilterType> searchFilterType);
    private string BuildFieldSearchFilter(string searchTerm);
    private string BuildFieldSearchClause(string term, string property);
    [CompilerGeneratedAttribute]
private string <BuildFieldSearchFilter>b__31_1(string term, string property);
}
public static class NuGet.Protocol.V2FeedUtilities : object {
    public static IPackageSearchMetadata CreatePackageSearchResult(V2FeedPackageInfo package, MetadataReferenceCache metadataCache, SearchFilter filter, V2FeedParser feedParser, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedUtilities/<GetVersions>d__1")]
private static Task`1<IEnumerable`1<VersionInfo>> GetVersions(V2FeedPackageInfo package, MetadataReferenceCache metadataCache, SearchFilter filter, V2FeedParser feedParser, ILogger log, CancellationToken cancellationToken);
}
public class NuGet.Protocol.V3FeedListResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.V3FeedListResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.VersionInfoConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NuGet.Protocol.VersionRangeConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
[ExtensionAttribute]
public static class NuGet.Protocol.VisualStudio.FactoryExtensionsVS : object {
    [ExtensionAttribute]
public static SourceRepository GetVisualStudio(RepositoryFactory factory, string source);
    [ExtensionAttribute]
public static SourceRepository GetVisualStudio(RepositoryFactory factory, PackageSource source);
    [IteratorStateMachineAttribute("NuGet.Protocol.VisualStudio.FactoryExtensionsVS/<GetVisualStudio>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<Lazy`1<INuGetResourceProvider>> GetVisualStudio(ProviderFactory factory);
}
public class NuGet.Repositories.LocalPackageInfo : object {
    private Lazy`1<NuspecReader> _nuspec;
    private Lazy`1<IReadOnlyList`1<string>> _files;
    private Lazy`1<string> _sha512;
    private Lazy`1<RuntimeGraph> _runtimeGraph;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExpandedPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ManifestPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ZipPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sha512Path>k__BackingField;
    public string Id { get; }
    public NuGetVersion Version { get; }
    public string ExpandedPath { get; public set; }
    public string ManifestPath { get; }
    public string ZipPath { get; }
    public string Sha512Path { get; }
    public NuspecReader Nuspec { get; }
    public IReadOnlyList`1<string> Files { get; }
    public string Sha512 { get; }
    public RuntimeGraph RuntimeGraph { get; }
    public LocalPackageInfo(string packageId, NuGetVersion version, string path, string manifestPath, string zipPath, string sha512Path, Lazy`1<NuspecReader> nuspec, Lazy`1<IReadOnlyList`1<string>> files, Lazy`1<string> sha512, Lazy`1<RuntimeGraph> runtimeGraph);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public string get_ExpandedPath();
    [CompilerGeneratedAttribute]
public void set_ExpandedPath(string value);
    [CompilerGeneratedAttribute]
public string get_ManifestPath();
    [CompilerGeneratedAttribute]
public string get_ZipPath();
    [CompilerGeneratedAttribute]
public string get_Sha512Path();
    public NuspecReader get_Nuspec();
    public IReadOnlyList`1<string> get_Files();
    public string get_Sha512();
    public RuntimeGraph get_RuntimeGraph();
    public virtual string ToString();
}
public class NuGet.Repositories.LocalPackageSourceInfo : object {
    [CompilerGeneratedAttribute]
private NuGetv3LocalRepository <Repository>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalPackageInfo <Package>k__BackingField;
    public NuGetv3LocalRepository Repository { get; }
    public LocalPackageInfo Package { get; }
    public LocalPackageSourceInfo(NuGetv3LocalRepository repository, LocalPackageInfo package);
    [CompilerGeneratedAttribute]
public NuGetv3LocalRepository get_Repository();
    [CompilerGeneratedAttribute]
public LocalPackageInfo get_Package();
}
public class NuGet.Repositories.NuGetv3LocalRepository : object {
    private ConcurrentDictionary`2<string, LocalPackageInfo> _packageCache;
    private ConcurrentDictionary`2<string, List`1<LocalPackageInfo>> _cache;
    private ConcurrentDictionary`2<string, object> _idLocks;
    private LocalPackageFileCache _packageFileCache;
    private bool _isFallbackFolder;
    private bool _updateLastAccessTime;
    [CompilerGeneratedAttribute]
private VersionFolderPathResolver <PathResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RepositoryRoot>k__BackingField;
    public VersionFolderPathResolver PathResolver { get; }
    public string RepositoryRoot { get; }
    public NuGetv3LocalRepository(string path);
    public NuGetv3LocalRepository(string path, LocalPackageFileCache packageFileCache, bool isFallbackFolder);
    public NuGetv3LocalRepository(string path, LocalPackageFileCache packageFileCache, bool isFallbackFolder, bool updateLastAccessTime);
    [CompilerGeneratedAttribute]
public VersionFolderPathResolver get_PathResolver();
    [CompilerGeneratedAttribute]
public string get_RepositoryRoot();
    public bool Exists(string packageId, NuGetVersion version);
    public LocalPackageInfo FindPackage(string packageId, NuGetVersion version);
    public IEnumerable`1<LocalPackageInfo> FindPackagesById(string packageId);
    private List`1<LocalPackageInfo> FindPackagesByIdImpl(string packageId);
    private LocalPackageInfo FindPackageImpl(string packageId, NuGetVersion version);
    private List`1<LocalPackageInfo> GetPackages(string id);
    private LocalPackageInfo GetPackage(string packageId, NuGetVersion version, string path);
    private LocalPackageInfo CreateLocalPackageInfo(string id, NuGetVersion version, string fullVersionDir, string newHashPath, string zipPath);
    public void ClearCacheForIds(IEnumerable`1<string> packageIds);
    private object GetLockObj(string privateId);
    [CompilerGeneratedAttribute]
private List`1<LocalPackageInfo> <FindPackagesByIdImpl>b__18_0(string id);
}
public static class NuGet.Repositories.NuGetv3LocalRepositoryUtility : object {
    public static LocalPackageSourceInfo GetPackage(IReadOnlyList`1<NuGetv3LocalRepository> repositories, string id, NuGetVersion version);
}
public class NuGet.RuntimeModel.CompatibilityProfile : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<FrameworkRuntimePair> <RestoreContexts>k__BackingField;
    public string Name { get; }
    public IList`1<FrameworkRuntimePair> RestoreContexts { get; }
    public CompatibilityProfile(string name);
    public CompatibilityProfile(string name, IEnumerable`1<FrameworkRuntimePair> restoreContexts);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public IList`1<FrameworkRuntimePair> get_RestoreContexts();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CompatibilityProfile other);
    public CompatibilityProfile Clone();
}
public interface NuGet.RuntimeModel.IObjectWriter {
    public abstract virtual void WriteObjectStart();
    public abstract virtual void WriteObjectStart(string name);
    public abstract virtual void WriteObjectEnd();
    public abstract virtual void WriteNameValue(string name, int value);
    public abstract virtual void WriteNameValue(string name, bool value);
    public abstract virtual void WriteNameValue(string name, string value);
    public abstract virtual void WriteNameArray(string name, IEnumerable`1<string> values);
    public abstract virtual void WriteNonEmptyNameArray(string name, IEnumerable`1<string> values);
    public abstract virtual void WriteArrayStart(string name);
    public abstract virtual void WriteArrayEnd();
}
public class NuGet.RuntimeModel.JsonObjectWriter : object {
    private JsonWriter _writer;
    private bool _isDisposed;
    public JsonObjectWriter(JsonWriter writer);
    public sealed virtual void Dispose();
    public sealed virtual void WriteObjectStart();
    public sealed virtual void WriteObjectStart(string name);
    public sealed virtual void WriteArrayStart(string name);
    public sealed virtual void WriteObjectEnd();
    public sealed virtual void WriteArrayEnd();
    public sealed virtual void WriteNameValue(string name, int value);
    public sealed virtual void WriteNameValue(string name, bool value);
    public sealed virtual void WriteNameValue(string name, string value);
    public sealed virtual void WriteNameArray(string name, IEnumerable`1<string> values);
    public sealed virtual void WriteNonEmptyNameArray(string name, IEnumerable`1<string> values);
    private void ThrowIfDisposed();
}
public static class NuGet.RuntimeModel.JsonRuntimeFormat : object {
    public static RuntimeGraph ReadRuntimeGraph(string filePath);
    public static RuntimeGraph ReadRuntimeGraph(Stream stream);
    public static RuntimeGraph ReadRuntimeGraph(TextReader textReader);
    public static void WriteRuntimeGraph(string filePath, RuntimeGraph runtimeGraph);
    public static RuntimeGraph ReadRuntimeGraph(JToken json);
    public static void WriteRuntimeGraph(IObjectWriter writer, RuntimeGraph runtimeGraph);
    private static void WriteRuntimeDescription(IObjectWriter writer, RuntimeDescription data);
    private static void WriteRuntimeDependencySet(IObjectWriter writer, RuntimeDependencySet data);
    private static void WritePackageDependency(IObjectWriter writer, RuntimePackageDependency data);
    private static void WriteCompatibilityProfile(IObjectWriter writer, CompatibilityProfile data);
    private static CompatibilityProfile ReadCompatibilityProfile(KeyValuePair`2<string, JToken> json);
    [IteratorStateMachineAttribute("NuGet.RuntimeModel.JsonRuntimeFormat/<ReadCompatibilitySets>d__11")]
private static IEnumerable`1<FrameworkRuntimePair> ReadCompatibilitySets(KeyValuePair`2<string, JToken> property);
    private static RuntimeDescription ReadRuntimeDescription(KeyValuePair`2<string, JToken> json);
    private static RuntimeDependencySet ReadRuntimeDependencySet(KeyValuePair`2<string, JToken> json);
    private static RuntimePackageDependency ReadRuntimePackageDependency(KeyValuePair`2<string, JToken> json);
    private static IEnumerable`1<KeyValuePair`2<string, JToken>> EachProperty(JToken json);
}
public class NuGet.RuntimeModel.RuntimeDependencySet : object {
    private static IReadOnlyDictionary`2<string, RuntimePackageDependency> EmptyDependencies;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, RuntimePackageDependency> <Dependencies>k__BackingField;
    public string Id { get; }
    public IReadOnlyDictionary`2<string, RuntimePackageDependency> Dependencies { get; }
    public RuntimeDependencySet(string id);
    public RuntimeDependencySet(string id, IEnumerable`1<RuntimePackageDependency> dependencies);
    private RuntimeDependencySet(string id, IReadOnlyDictionary`2<string, RuntimePackageDependency> dependencies);
    private static RuntimeDependencySet();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, RuntimePackageDependency> get_Dependencies();
    public sealed virtual bool Equals(RuntimeDependencySet other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [ObsoleteAttribute("This type is immutable, so there is no need or point to clone it.")]
public RuntimeDependencySet Clone();
    public virtual string ToString();
}
public class NuGet.RuntimeModel.RuntimeDescription : object {
    private static IReadOnlyDictionary`2<string, RuntimeDependencySet> EmptyRuntimeDependencySets;
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <InheritedRuntimes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, RuntimeDependencySet> <RuntimeDependencySets>k__BackingField;
    public string RuntimeIdentifier { get; }
    public IReadOnlyList`1<string> InheritedRuntimes { get; }
    public IReadOnlyDictionary`2<string, RuntimeDependencySet> RuntimeDependencySets { get; }
    public RuntimeDescription(string runtimeIdentifier);
    public RuntimeDescription(string runtimeIdentifier, IEnumerable`1<string> inheritedRuntimes);
    public RuntimeDescription(string runtimeIdentifier, IEnumerable`1<RuntimeDependencySet> runtimeDependencySets);
    public RuntimeDescription(string runtimeIdentifier, IEnumerable`1<string> inheritedRuntimes, IEnumerable`1<RuntimeDependencySet> runtimeDependencySets);
    private RuntimeDescription(string runtimeIdentifier, IReadOnlyList`1<string> inheritedRuntimes, IReadOnlyDictionary`2<string, RuntimeDependencySet> runtimeDependencySets);
    private static RuntimeDescription();
    [CompilerGeneratedAttribute]
public string get_RuntimeIdentifier();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_InheritedRuntimes();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, RuntimeDependencySet> get_RuntimeDependencySets();
    public sealed virtual bool Equals(RuntimeDescription other);
    [ObsoleteAttribute("This type is immutable, so there is no need or point to clone it.")]
public RuntimeDescription Clone();
    public static RuntimeDescription Merge(RuntimeDescription left, RuntimeDescription right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.RuntimeModel.RuntimeGraph : object {
    private static ReadOnlyDictionary`2<string, RuntimeDescription> EmptyRuntimes;
    private static ReadOnlyDictionary`2<string, CompatibilityProfile> EmptySupports;
    [NullableAttribute("2")]
private ConcurrentDictionary`2<RuntimeCompatKey, bool> _areCompatible;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<string, HashSet`1<string>> _expandCache;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<RuntimeDependencyKey, List`1<RuntimePackageDependency>> _dependencyCache;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<string> _packagesWithDependencies;
    public static string RuntimeGraphFileName;
    public static RuntimeGraph Empty;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, RuntimeDescription> <Runtimes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, CompatibilityProfile> <Supports>k__BackingField;
    public IReadOnlyDictionary`2<string, RuntimeDescription> Runtimes { get; }
    public IReadOnlyDictionary`2<string, CompatibilityProfile> Supports { get; }
    internal bool IsEmpty { get; }
    public RuntimeGraph(IEnumerable`1<RuntimeDescription> runtimes);
    public RuntimeGraph(IEnumerable`1<CompatibilityProfile> supports);
    public RuntimeGraph(IEnumerable`1<RuntimeDescription> runtimes, IEnumerable`1<CompatibilityProfile> supports);
    private RuntimeGraph(IReadOnlyDictionary`2<string, RuntimeDescription> runtimes, IReadOnlyDictionary`2<string, CompatibilityProfile> supports);
    private static RuntimeGraph();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, RuntimeDescription> get_Runtimes();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, CompatibilityProfile> get_Supports();
    internal bool get_IsEmpty();
    public RuntimeGraph Clone();
    public static RuntimeGraph Merge(RuntimeGraph left, RuntimeGraph right);
    public IEnumerable`1<string> ExpandRuntime(string runtime);
    private HashSet`1<string> ExpandRuntimeCached(string runtime);
    public bool AreCompatible(string criteria, string provided);
    public IEnumerable`1<RuntimePackageDependency> FindRuntimeDependencies(string runtimeName, string packageId);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(RuntimeGraph other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
internal static IReadOnlyDictionary`2<string, T> <Clone>g__Clone|21_1(IReadOnlyDictionary`2<string, T> source, Func`2<T, T> cloneFunc);
    [CompilerGeneratedAttribute]
private HashSet`1<string> <ExpandRuntimeCached>b__24_0(string r);
    [IteratorStateMachineAttribute("NuGet.RuntimeModel.RuntimeGraph/<<ExpandRuntimeCached>g__ExpandRuntimeInternal|24_1>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<string> <ExpandRuntimeCached>g__ExpandRuntimeInternal|24_1(string runtime);
    [CompilerGeneratedAttribute]
private bool <AreCompatible>g__AreCompatibleInternal|25_0(RuntimeCompatKey key);
    [CompilerGeneratedAttribute]
internal static List`1<RuntimePackageDependency> <FindRuntimeDependencies>g__FindRuntimeDependenciesInternal|26_1(RuntimeDependencyKey key, RuntimeGraph runtimeGraph);
}
public class NuGet.RuntimeModel.RuntimePackageDependency : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <VersionRange>k__BackingField;
    public string Id { get; }
    public VersionRange VersionRange { get; }
    public RuntimePackageDependency(string id, VersionRange versionRange);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public VersionRange get_VersionRange();
    [ObsoleteAttribute("This type is immutable, so there is no need or point to clone it.")]
public RuntimePackageDependency Clone();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(RuntimePackageDependency other);
}
internal static class NuGet.Shared.<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>EncodingUtility : object {
    [NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
    [ExtensionAttribute]
public static void AppendInt(StringBuilder sb, int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.Shared.<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
internal static class NuGet.Shared.<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
internal static class NuGet.Shared.<095eee27-c9f8-4608-aee1-977bdb32e1fa>EncodingUtility : object {
    [NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.<095eee27-c9f8-4608-aee1-977bdb32e1fa>EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.<095eee27-c9f8-4608-aee1-977bdb32e1fa>Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
    [ExtensionAttribute]
public static void AppendInt(StringBuilder sb, int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[<095eee27-c9f8-4608-aee1-977bdb32e1fa>CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.Shared.<095eee27-c9f8-4608-aee1-977bdb32e1fa>HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
internal static class NuGet.Shared.<095eee27-c9f8-4608-aee1-977bdb32e1fa>XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
internal static class NuGet.Shared.<76dee5d5-572c-44bd-8e59-41aaed8a29e3>EncodingUtility : object {
    [NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.<76dee5d5-572c-44bd-8e59-41aaed8a29e3>EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.<76dee5d5-572c-44bd-8e59-41aaed8a29e3>Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
    [ExtensionAttribute]
public static void AppendInt(StringBuilder sb, int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[<76dee5d5-572c-44bd-8e59-41aaed8a29e3>CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.Shared.<76dee5d5-572c-44bd-8e59-41aaed8a29e3>HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
internal static class NuGet.Shared.<76dee5d5-572c-44bd-8e59-41aaed8a29e3>XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
internal static class NuGet.Shared.<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>EncodingUtility : object {
    [NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
    [ExtensionAttribute]
public static void AppendInt(StringBuilder sb, int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.Shared.<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NuGet.Shared.<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
internal static class NuGet.Shared.<9f65e429-7a44-41af-85cb-9a867a352998>EncodingUtility : object {
    [NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.<9f65e429-7a44-41af-85cb-9a867a352998>EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.<9f65e429-7a44-41af-85cb-9a867a352998>Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
    [ExtensionAttribute]
public static void AppendInt(StringBuilder sb, int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[<9f65e429-7a44-41af-85cb-9a867a352998>CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.Shared.<9f65e429-7a44-41af-85cb-9a867a352998>HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NuGet.Shared.<9f65e429-7a44-41af-85cb-9a867a352998>XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
internal static class NuGet.Shared.<a8b4d782-62ae-4aef-a59e-d702453e5cda>EncodingUtility : object {
    [NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.<a8b4d782-62ae-4aef-a59e-d702453e5cda>EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.<a8b4d782-62ae-4aef-a59e-d702453e5cda>Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
    [ExtensionAttribute]
public static void AppendInt(StringBuilder sb, int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[<a8b4d782-62ae-4aef-a59e-d702453e5cda>CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.Shared.<a8b4d782-62ae-4aef-a59e-d702453e5cda>HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
internal static class NuGet.Shared.<a8b4d782-62ae-4aef-a59e-d702453e5cda>XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
internal static class NuGet.Shared.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>EncodingUtility : object {
    [NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
    [ExtensionAttribute]
public static void AppendInt(StringBuilder sb, int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.Shared.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NuGet.Shared.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
internal static class NuGet.Shared.<cf090466-d32c-4025-b476-cee6b8291f40>EncodingUtility : object {
    [NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.<cf090466-d32c-4025-b476-cee6b8291f40>EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.<cf090466-d32c-4025-b476-cee6b8291f40>Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
    [ExtensionAttribute]
public static void AppendInt(StringBuilder sb, int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[<cf090466-d32c-4025-b476-cee6b8291f40>CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.Shared.<cf090466-d32c-4025-b476-cee6b8291f40>HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NuGet.Shared.<cf090466-d32c-4025-b476-cee6b8291f40>XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
internal static class NuGet.Shared.EncodingUtility : object {
    [NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
    [ExtensionAttribute]
public static void AppendInt(StringBuilder sb, int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.Shared.HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NuGet.Shared.XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.SimplePool`1 : object {
    private object _lockObj;
    private Stack`1<T> _values;
    private Func`1<T> _allocate;
    public SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.StringBuilderPool : object {
    private static int MaxPoolSize;
    private SimplePool`1<StringBuilder> _pool;
    public static StringBuilderPool Shared;
    private static StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NuGet.TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.TaskResultCache`2 : object {
    private ConcurrentDictionary`2<TKey, Task`1<TValue>> _cache;
    private ConcurrentDictionary`2<TKey, object> _perTaskLock;
    public TaskResultCache`2(IEqualityComparer`1<TKey> comparer);
    public Task`1<TValue> GetOrAddAsync(TKey key, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
    public Task`1<TValue> GetOrAddAsync(TKey key, bool refresh, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Versioning.FloatRange : object {
    private NuGetVersion _minVersion;
    private NuGetVersionFloatBehavior _floatBehavior;
    [NullableAttribute("2")]
private string _releasePrefix;
    public bool HasMinVersion { get; }
    public NuGetVersion MinVersion { get; }
    public NuGetVersionFloatBehavior FloatBehavior { get; }
    [NullableAttribute("2")]
public string OriginalReleasePrefix { get; }
    [MemberNotNullWhenAttribute("True", "OriginalReleasePrefix")]
[MemberNotNullWhenAttribute("True", "_releasePrefix")]
public bool IncludePrerelease { get; }
    public FloatRange(NuGetVersionFloatBehavior floatBehavior);
    public FloatRange(NuGetVersionFloatBehavior floatBehavior, NuGetVersion minVersion);
    public FloatRange(NuGetVersionFloatBehavior floatBehavior, NuGetVersion minVersion, string releasePrefix);
    public bool get_HasMinVersion();
    public NuGetVersion get_MinVersion();
    public NuGetVersionFloatBehavior get_FloatBehavior();
    [NullableContextAttribute("2")]
public string get_OriginalReleasePrefix();
    [MemberNotNullWhenAttribute("True", "OriginalReleasePrefix")]
[MemberNotNullWhenAttribute("True", "_releasePrefix")]
public bool get_IncludePrerelease();
    public bool Satisfies(NuGetVersion version);
    public static FloatRange Parse(string versionString);
    public static bool TryParse(string versionString, FloatRange& range);
    private static int CalculateVersionParts(string line);
    public virtual string ToString();
    public void ToString(StringBuilder sb);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(FloatRange other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
internal static int <TryParse>g__IndexOf|18_0(string str, char c);
}
[NullableContextAttribute("1")]
public interface NuGet.Versioning.INuGetVersionable {
    public NuGetVersion Version { get; }
    public abstract virtual NuGetVersion get_Version();
}
public interface NuGet.Versioning.IVersionComparer {
}
public interface NuGet.Versioning.IVersionRangeComparer {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Versioning.NuGetVersion : SemanticVersion {
    [NullableAttribute("2")]
private string _originalString;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Revision>k__BackingField;
    public Version Version { get; }
    public bool IsLegacyVersion { get; }
    public int Revision { get; }
    public bool IsSemVer2 { get; }
    [NullableAttribute("2")]
public string OriginalVersion { get; }
    public NuGetVersion(string version);
    public NuGetVersion(NuGetVersion version);
    [NullableContextAttribute("2")]
public NuGetVersion(Version version, string releaseLabel, string metadata);
    public NuGetVersion(int major, int minor, int patch);
    [NullableContextAttribute("2")]
public NuGetVersion(int major, int minor, int patch, string releaseLabel);
    [NullableContextAttribute("2")]
public NuGetVersion(int major, int minor, int patch, string releaseLabel, string metadata);
    [NullableContextAttribute("2")]
public NuGetVersion(int major, int minor, int patch, IEnumerable`1<string> releaseLabels, string metadata);
    public NuGetVersion(int major, int minor, int patch, int revision);
    public NuGetVersion(int major, int minor, int patch, int revision, string releaseLabel, string metadata);
    [NullableContextAttribute("2")]
public NuGetVersion(int major, int minor, int patch, int revision, IEnumerable`1<string> releaseLabels, string metadata);
    [NullableContextAttribute("2")]
public NuGetVersion(Version version, IEnumerable`1<string> releaseLabels, string metadata, string originalVersion);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public Version get_Version();
    public virtual bool get_IsLegacyVersion();
    [CompilerGeneratedAttribute]
public int get_Revision();
    public bool get_IsSemVer2();
    [NullableContextAttribute("2")]
public string get_OriginalVersion();
    public static NuGetVersion Parse(string value);
    [NullableContextAttribute("2")]
public static bool TryParse(string value, NuGetVersion& version);
    private static bool TryGetNormalizedVersion(string str, Version& version);
    public static bool TryParseStrict(string value, NuGetVersion& version);
    private static string GetLegacyString(Version version, IEnumerable`1<string> releaseLabels, string metadata);
    [NullableContextAttribute("2")]
private static IEnumerable`1<string> ParseReleaseLabels(string releaseLabels);
    [CompilerGeneratedAttribute]
internal static int <TryParse>g__IndexOf|26_0(string str, char c);
    [CompilerGeneratedAttribute]
internal static bool <TryGetNormalizedVersion>g__ParseSection|27_0(string str, int start, Int32& end, Int32& versionNumber);
    [CompilerGeneratedAttribute]
internal static bool <TryGetNormalizedVersion>g__IsDigit|27_1(char c);
}
public enum NuGet.Versioning.NuGetVersionFloatBehavior : Enum {
    public int value__;
    public static NuGetVersionFloatBehavior None;
    public static NuGetVersionFloatBehavior Prerelease;
    public static NuGetVersionFloatBehavior Revision;
    public static NuGetVersionFloatBehavior Patch;
    public static NuGetVersionFloatBehavior Minor;
    public static NuGetVersionFloatBehavior Major;
    public static NuGetVersionFloatBehavior AbsoluteLatest;
    public static NuGetVersionFloatBehavior PrereleaseRevision;
    public static NuGetVersionFloatBehavior PrereleasePatch;
    public static NuGetVersionFloatBehavior PrereleaseMinor;
    public static NuGetVersionFloatBehavior PrereleaseMajor;
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Versioning.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Argument_Cannot_Be_Null_Or_Empty { get; }
    internal static string CannotBeNullWhenParameterIsNotNull { get; }
    internal static string InvalidFloatRangeValue { get; }
    internal static string Invalidvalue { get; }
    internal static string TypeNotSupported { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Argument_Cannot_Be_Null_Or_Empty();
    internal static string get_CannotBeNullWhenParameterIsNotNull();
    internal static string get_InvalidFloatRangeValue();
    internal static string get_Invalidvalue();
    internal static string get_TypeNotSupported();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NuGet.Versioning.ResourcesFormatter : object {
    internal static ArgumentException TypeNotSupported(Type type, string paramName);
    internal static ArgumentNullException CannotBeNullWhenParameterIsNull(string parameterThatIsNull, string parameterThisIsNotNull);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeConverterAttribute("NuGet.Versioning.SemanticVersionConverter")]
public class NuGet.Versioning.SemanticVersion : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal String[] _releaseLabels;
    internal string _metadata;
    [CompilerGeneratedAttribute]
private int <Major>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Minor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Patch>k__BackingField;
    [NullableAttribute("1")]
internal static String[] EmptyReleaseLabels;
    public int Major { get; }
    public int Minor { get; }
    public int Patch { get; }
    [NullableAttribute("1")]
public IEnumerable`1<string> ReleaseLabels { get; }
    [NullableAttribute("1")]
public string Release { get; }
    public bool IsPrerelease { get; }
    [MemberNotNullWhenAttribute("True", "Metadata")]
public bool HasMetadata { get; }
    public string Metadata { get; }
    [NullableContextAttribute("1")]
public SemanticVersion(SemanticVersion version);
    public SemanticVersion(int major, int minor, int patch);
    public SemanticVersion(int major, int minor, int patch, string releaseLabel);
    public SemanticVersion(int major, int minor, int patch, string releaseLabel, string metadata);
    public SemanticVersion(int major, int minor, int patch, IEnumerable`1<string> releaseLabels, string metadata);
    protected SemanticVersion(Version version, string releaseLabel, string metadata);
    protected SemanticVersion(int major, int minor, int patch, int revision, string releaseLabel, string metadata);
    protected SemanticVersion(int major, int minor, int patch, int revision, IEnumerable`1<string> releaseLabels, string metadata);
    [NullableContextAttribute("1")]
protected SemanticVersion(Version version, IEnumerable`1<string> releaseLabels, string metadata);
    private static SemanticVersion();
    [CompilerGeneratedAttribute]
public int get_Major();
    [CompilerGeneratedAttribute]
public int get_Minor();
    [CompilerGeneratedAttribute]
public int get_Patch();
    [NullableContextAttribute("1")]
public IEnumerable`1<string> get_ReleaseLabels();
    [NullableContextAttribute("1")]
public string get_Release();
    public virtual bool get_IsPrerelease();
    [MemberNotNullWhenAttribute("True", "Metadata")]
public virtual bool get_HasMetadata();
    public virtual string get_Metadata();
    [NullableContextAttribute("1")]
public virtual string ToNormalizedString();
    [NullableContextAttribute("1")]
public virtual string ToFullString();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    protected bool TryFormatter(string format, IFormatProvider formatProvider, String& formattedString);
    public virtual int GetHashCode();
    public virtual int CompareTo(object obj);
    public virtual int CompareTo(SemanticVersion other);
    public virtual bool Equals(object obj);
    public virtual bool Equals(SemanticVersion other);
    public virtual bool Equals(SemanticVersion other, VersionComparison versionComparison);
    public virtual int CompareTo(SemanticVersion other, VersionComparison versionComparison);
    public static bool op_Equality(SemanticVersion version1, SemanticVersion version2);
    public static bool op_Inequality(SemanticVersion version1, SemanticVersion version2);
    [NullableContextAttribute("1")]
public static bool op_LessThan(SemanticVersion version1, SemanticVersion version2);
    [NullableContextAttribute("1")]
public static bool op_LessThanOrEqual(SemanticVersion version1, SemanticVersion version2);
    [NullableContextAttribute("1")]
public static bool op_GreaterThan(SemanticVersion version1, SemanticVersion version2);
    [NullableContextAttribute("1")]
public static bool op_GreaterThanOrEqual(SemanticVersion version1, SemanticVersion version2);
    private static int Compare(SemanticVersion version1, SemanticVersion version2);
    [NullableContextAttribute("1")]
public static SemanticVersion Parse(string value);
    [NullableContextAttribute("1")]
public static bool TryParse(string value, SemanticVersion& version);
    internal static bool IsLetterOrDigitOrDash(char c);
    internal static bool IsDigit(char c);
    [NullableContextAttribute("1")]
internal static bool IsValid(string s, bool allowLeadingZeros);
    [NullableContextAttribute("1")]
internal static bool IsValidPart(string s, bool allowLeadingZeros);
    internal static void ParseSections(string value, String& versionString, String[]& releaseLabels, String& buildMetadata);
    [NullableContextAttribute("1")]
internal static Version NormalizeVersionValue(Version version);
    private static String[] ParseReleaseLabels(string releaseLabels);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NuGet.Versioning.SemanticVersionConverter : TypeConverter {
    [NullableContextAttribute("1")]
public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Versioning.VersionComparer : object {
    private VersionComparison _mode;
    public static IVersionComparer Default;
    public static IVersionComparer Version;
    public static IVersionComparer VersionRelease;
    public static IVersionComparer VersionReleaseMetadata;
    public VersionComparer(VersionComparison versionComparison);
    private static VersionComparer();
    public static IVersionComparer Get(VersionComparison versionComparison);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(SemanticVersion x, SemanticVersion y);
    [NullableContextAttribute("2")]
public static int Compare(SemanticVersion version1, SemanticVersion version2, VersionComparison versionComparison);
    public sealed virtual int GetHashCode(SemanticVersion version);
    [NullableContextAttribute("2")]
public sealed virtual int Compare(SemanticVersion x, SemanticVersion y);
    [NullableContextAttribute("2")]
private static int CompareLegacyVersion(NuGetVersion legacyX, NuGetVersion legacyY);
    private static int CompareReleaseLabels(String[] version1, String[] version2);
    private static int CompareRelease(string version1, string version2);
    private static String[] GetReleaseLabelsOrNull(SemanticVersion version);
    private static bool AreReleaseLabelsEqual(SemanticVersion x, SemanticVersion y);
    private static int GetRevisionOrZero(SemanticVersion version);
}
public enum NuGet.Versioning.VersionComparison : Enum {
    public int value__;
    public static VersionComparison Default;
    public static VersionComparison Version;
    public static VersionComparison VersionRelease;
    public static VersionComparison VersionReleaseMetadata;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NuGet.Versioning.VersionExtensions : object {
    [ExtensionAttribute]
public static T FindBestMatch(IEnumerable`1<T> items, VersionRange ideal, Func`2<T, NuGetVersion> selector);
    [ExtensionAttribute]
public static INuGetVersionable FindBestMatch(IEnumerable`1<INuGetVersionable> items, VersionRange ideal);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Versioning.VersionFormatter : object {
    public static VersionFormatter Instance;
    private static VersionFormatter();
    [NullableContextAttribute("2")]
public sealed virtual string Format(string format, object arg, IFormatProvider formatProvider);
    [NullableContextAttribute("2")]
public sealed virtual object GetFormat(Type formatType);
    private static void Format(StringBuilder builder, char c, SemanticVersion version);
    private static void AppendFull(StringBuilder builder, SemanticVersion version);
    internal static void AppendNormalized(StringBuilder builder, SemanticVersion version);
    private static void AppendVersion(StringBuilder builder, SemanticVersion version);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Versioning.VersionRange : VersionRangeBase {
    [NullableAttribute("2")]
private FloatRange _floatRange;
    [NullableAttribute("2")]
private string _originalString;
    public static VersionRange All;
    private static NuGetVersion V0;
    [ObsoleteAttribute("Consider not using this VersionRange. The lack of a proper normalized version means that it is not round trippable in an assets file.")]
public static VersionRange AllFloating;
    public static VersionRange AllStable;
    [ObsoleteAttribute("Consider not using this VersionRange. The lack of a proper normalized version means that it is not round trippable in an assets file.")]
public static VersionRange AllStableFloating;
    public static VersionRange None;
    [MemberNotNullWhenAttribute("True", "MinVersion")]
[MemberNotNullWhenAttribute("True", "Float")]
[MemberNotNullWhenAttribute("True", "_floatRange")]
public bool IsFloating { get; }
    [NullableAttribute("2")]
public NuGetVersion MinVersion { get; }
    [NullableAttribute("2")]
public NuGetVersion MaxVersion { get; }
    [MemberNotNullWhenAttribute("True", "MinVersion")]
public bool HasLowerBound { get; }
    [MemberNotNullWhenAttribute("True", "MinVersion")]
public bool IsMinInclusive { get; }
    [MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool HasUpperBound { get; }
    [MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool IsMaxInclusive { get; }
    [MemberNotNullWhenAttribute("True", "MinVersion")]
[MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool HasLowerAndUpperBounds { get; }
    [NullableAttribute("2")]
public FloatRange Float { get; }
    [NullableAttribute("2")]
public string OriginalString { get; }
    public VersionRange(NuGetVersion minVersion);
    public VersionRange(NuGetVersion minVersion, FloatRange floatRange);
    public VersionRange(VersionRange range, FloatRange floatRange);
    [NullableContextAttribute("2")]
public VersionRange(NuGetVersion minVersion, bool includeMinVersion, NuGetVersion maxVersion, bool includeMaxVersion, FloatRange floatRange, string originalString);
    private static VersionRange();
    [MemberNotNullWhenAttribute("True", "MinVersion")]
[MemberNotNullWhenAttribute("True", "Float")]
[MemberNotNullWhenAttribute("True", "_floatRange")]
public bool get_IsFloating();
    [NullableContextAttribute("2")]
public NuGetVersion get_MinVersion();
    [NullableContextAttribute("2")]
public NuGetVersion get_MaxVersion();
    [MemberNotNullWhenAttribute("True", "MinVersion")]
public bool get_HasLowerBound();
    [MemberNotNullWhenAttribute("True", "MinVersion")]
public bool get_IsMinInclusive();
    [MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool get_HasUpperBound();
    [MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool get_IsMaxInclusive();
    [MemberNotNullWhenAttribute("True", "MinVersion")]
[MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool get_HasLowerAndUpperBounds();
    [NullableContextAttribute("2")]
public FloatRange get_Float();
    [NullableContextAttribute("2")]
public string get_OriginalString();
    public virtual string ToString();
    public virtual string ToNormalizedString();
    public virtual string ToLegacyString();
    public virtual string ToLegacyShortString();
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    [NullableContextAttribute("2")]
protected bool TryFormatter(string format, IFormatProvider formatProvider, String& formattedString);
    public string PrettyPrint();
    [NullableContextAttribute("2")]
public NuGetVersion FindBestMatch(IEnumerable`1<NuGetVersion> versions);
    public bool IsBetter(NuGetVersion current, NuGetVersion considering);
    public VersionRange ToNonSnapshotRange();
    private static NuGetVersion GetNonSnapshotVersion(NuGetVersion version);
    public virtual string ToShortString();
    [NullableContextAttribute("2")]
public bool Equals(VersionRange other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static VersionRange Parse(string value);
    public static VersionRange Parse(string value, bool allowFloating);
    public static bool TryParse(string value, VersionRange& versionRange);
    public static bool TryParse(string value, bool allowFloating, VersionRange& versionRange);
    public static VersionRange Combine(IEnumerable`1<NuGetVersion> versions);
    public static VersionRange Combine(IEnumerable`1<NuGetVersion> versions, IVersionComparer comparer);
    public static VersionRange Combine(IEnumerable`1<VersionRange> ranges);
    public static VersionRange Combine(IEnumerable`1<VersionRange> ranges, IVersionComparer comparer);
    public static VersionRange CommonSubSet(IEnumerable`1<VersionRange> ranges);
    public static VersionRange CommonSubSet(IEnumerable`1<VersionRange> ranges, IVersionComparer comparer);
    private static bool HasValidRange(VersionRange range);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class NuGet.Versioning.VersionRangeBase : object {
    private bool _includeMinVersion;
    private bool _includeMaxVersion;
    private NuGetVersion _minVersion;
    private NuGetVersion _maxVersion;
    [MemberNotNullWhenAttribute("True", "MinVersion")]
public bool HasLowerBound { get; }
    [MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool HasUpperBound { get; }
    [MemberNotNullWhenAttribute("True", "MinVersion")]
[MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool HasLowerAndUpperBounds { get; }
    [MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool IsMinInclusive { get; }
    [MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool IsMaxInclusive { get; }
    public NuGetVersion MaxVersion { get; }
    public NuGetVersion MinVersion { get; }
    protected bool HasPrereleaseBounds { get; }
    public VersionRangeBase(NuGetVersion minVersion, bool includeMinVersion, NuGetVersion maxVersion, bool includeMaxVersion);
    [MemberNotNullWhenAttribute("True", "MinVersion")]
public bool get_HasLowerBound();
    [MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool get_HasUpperBound();
    [MemberNotNullWhenAttribute("True", "MinVersion")]
[MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool get_HasLowerAndUpperBounds();
    [MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool get_IsMinInclusive();
    [MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool get_IsMaxInclusive();
    public NuGetVersion get_MaxVersion();
    public NuGetVersion get_MinVersion();
    [NullableContextAttribute("1")]
public bool Satisfies(NuGetVersion version);
    [NullableContextAttribute("1")]
public bool Satisfies(NuGetVersion version, VersionComparison versionComparison);
    [NullableContextAttribute("1")]
public bool Satisfies(NuGetVersion version, IVersionComparer comparer);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(VersionRangeBase other);
    [NullableContextAttribute("1")]
public bool Equals(VersionRangeBase other, IVersionRangeComparer comparer);
    public bool Equals(VersionRangeBase other, VersionComparison versionComparison);
    [NullableContextAttribute("1")]
public bool Equals(VersionRangeBase other, IVersionComparer versionComparer);
    public bool IsSubSetOrEqualTo(VersionRangeBase possibleSuperSet);
    [NullableContextAttribute("1")]
public bool IsSubSetOrEqualTo(VersionRangeBase possibleSuperSet, IVersionComparer comparer);
    protected bool get_HasPrereleaseBounds();
    private static Nullable`1<bool> IsPrerelease(SemanticVersion version);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Versioning.VersionRangeComparer : object {
    private IVersionComparer _versionComparer;
    [CompilerGeneratedAttribute]
private static IVersionRangeComparer <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private static IVersionRangeComparer <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private static IVersionRangeComparer <VersionRelease>k__BackingField;
    [CompilerGeneratedAttribute]
private static IVersionRangeComparer <VersionReleaseMetadata>k__BackingField;
    public static IVersionRangeComparer Default { get; }
    internal static IVersionRangeComparer Version { get; }
    public static IVersionRangeComparer VersionRelease { get; }
    internal static IVersionRangeComparer VersionReleaseMetadata { get; }
    public VersionRangeComparer(VersionComparison versionComparison);
    public VersionRangeComparer(IVersionComparer versionComparer);
    private static VersionRangeComparer();
    [CompilerGeneratedAttribute]
public static IVersionRangeComparer get_Default();
    [CompilerGeneratedAttribute]
internal static IVersionRangeComparer get_Version();
    [CompilerGeneratedAttribute]
public static IVersionRangeComparer get_VersionRelease();
    [CompilerGeneratedAttribute]
internal static IVersionRangeComparer get_VersionReleaseMetadata();
    public static IVersionRangeComparer Get(VersionComparison versionComparison);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(VersionRangeBase x, VersionRangeBase y);
    public sealed virtual int GetHashCode(VersionRangeBase obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Versioning.VersionRangeFormatter : object {
    public static VersionRangeFormatter Instance;
    private static VersionRangeFormatter();
    [NullableContextAttribute("2")]
public sealed virtual string Format(string format, object arg, IFormatProvider formatProvider);
    [NullableContextAttribute("2")]
public sealed virtual object GetFormat(Type formatType);
    private static void Format(StringBuilder builder, char c, VersionRange range);
    private static void GetShortString(StringBuilder builder, VersionRange range);
    private static void GetNormalizedString(StringBuilder builder, VersionRange range);
    private static void GetToString(StringBuilder builder, VersionRange range);
    private static void GetLegacyShortString(StringBuilder builder, VersionRangeBase range);
    private static void GetLegacyString(StringBuilder builder, VersionRangeBase range);
    private static void PrettyPrint(StringBuilder builder, VersionRange range, bool useParentheses);
    private static void PrettyPrintBound(StringBuilder builder, NuGetVersion version, bool inclusive, string boundChar);
}
internal static class ODataServiceDocumentUtils : object {
    [AsyncStateMachineAttribute("ODataServiceDocumentUtils/<CreateODataServiceDocumentResourceV2>d__0")]
public static Task`1<ODataServiceDocumentResourceV2> CreateODataServiceDocumentResourceV2(string url, HttpSource client, DateTime utcNow, ILogger log, CancellationToken token);
}
public class PostSharp.Compiler.Client.ClientMessage : object {
    [CompilerGeneratedAttribute]
private ClientMessageSeverity <Severity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationFile>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LocationStartLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LocationStartColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LocationEndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LocationEndColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InnerException>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpLink>k__BackingField;
    public ClientMessageSeverity Severity { get; internal set; }
    public string MessageId { get; internal set; }
    public string LocationFile { get; internal set; }
    public int LocationStartLine { get; internal set; }
    public int LocationStartColumn { get; internal set; }
    public int LocationEndLine { get; internal set; }
    public int LocationEndColumn { get; internal set; }
    public string InnerException { get; internal set; }
    public string Source { get; internal set; }
    public string MessageText { get; internal set; }
    public string HelpLink { get; internal set; }
    internal ClientMessage(ClientMessageSeverity severity, string messageId, string messageText, string helpLink, string source, string locationFile, int locationStartLine, int locationStartColumn, int locationEndLine, int locationEndColumn, string innerException);
    [CompilerGeneratedAttribute]
public ClientMessageSeverity get_Severity();
    [CompilerGeneratedAttribute]
internal void set_Severity(ClientMessageSeverity value);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
internal void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public string get_LocationFile();
    [CompilerGeneratedAttribute]
internal void set_LocationFile(string value);
    [CompilerGeneratedAttribute]
public int get_LocationStartLine();
    [CompilerGeneratedAttribute]
internal void set_LocationStartLine(int value);
    [CompilerGeneratedAttribute]
public int get_LocationStartColumn();
    [CompilerGeneratedAttribute]
internal void set_LocationStartColumn(int value);
    [CompilerGeneratedAttribute]
public int get_LocationEndLine();
    [CompilerGeneratedAttribute]
internal void set_LocationEndLine(int value);
    [CompilerGeneratedAttribute]
public int get_LocationEndColumn();
    [CompilerGeneratedAttribute]
internal void set_LocationEndColumn(int value);
    [CompilerGeneratedAttribute]
public string get_InnerException();
    [CompilerGeneratedAttribute]
internal void set_InnerException(string value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
internal void set_Source(string value);
    [CompilerGeneratedAttribute]
public string get_MessageText();
    [CompilerGeneratedAttribute]
internal void set_MessageText(string value);
    [CompilerGeneratedAttribute]
public string get_HelpLink();
    [CompilerGeneratedAttribute]
internal void set_HelpLink(string value);
    public string ToString(string prefix);
    public virtual string ToString();
}
public enum PostSharp.Compiler.Client.ClientMessageSeverity : Enum {
    public int value__;
    public static ClientMessageSeverity Debug;
    public static ClientMessageSeverity Verbose;
    public static ClientMessageSeverity Info;
    public static ClientMessageSeverity ImportantInfo;
    public static ClientMessageSeverity CommandLine;
    public static ClientMessageSeverity Warning;
    public static ClientMessageSeverity Error;
    public static ClientMessageSeverity Fatal;
}
public interface PostSharp.Compiler.Client.ILogger {
    public abstract virtual void LogMessageFromText(string lineOfText);
    public abstract virtual void LogVerbose(string format, Object[] args);
    public abstract virtual void LogMessage(string format, Object[] args);
    public abstract virtual void LogWarning(string format, Object[] args);
    public abstract virtual void LogError(string format, Object[] args);
    public abstract virtual void LogException(Exception e);
    public abstract virtual void LogMessage(ClientMessage message);
}
[ExtensionAttribute]
internal static class PostSharp.Compiler.Client.LoggerExtensions : object {
    [ThreadStaticAttribute]
private static Nullable`1<bool> cachedIsStrict;
    [ExtensionAttribute]
public static void LogDiagnosticMessage(ILogger logger, string format, Object[] args);
    [ExtensionAttribute]
public static void LogDiagnosticWarning(ILogger logger, string format, Object[] args);
    [ExtensionAttribute]
public static void LogRecoverableError(ILogger logger, string format, Object[] args);
    private static bool IsStrict();
}
internal class PostSharp.Compiler.Client.Pipe.PipeAckPacket : PipePacket {
    protected virtual void ReadContent(BinaryReader reader);
    protected virtual void WriteContent(BinaryWriter writer);
}
internal class PostSharp.Compiler.Client.Pipe.PipeClient : object {
    internal static int ConnectionRetryLimit;
    internal static int ConnectionWaitPeriod;
    private AutoResetEvent startedPipeServerExitedEvent;
    private string toolPath;
    private string targetProcessorArchitecture;
    private int pipeTimeout;
    private ILogger logger;
    private int serverProcessId;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) disableAntivirusDetection;
    public PipeClient(ILogger logger, string toolPath, string targetProcessorArchitecture, int pipeTimeout);
    public int Execute(String[] arguments, CancellationToken cancellationToken);
    private PipeClientStatus ExecuteCore(PipeSync sync, PipeEndpointName pipeEndpointName, String[] arguments, Int32& exitCode, CancellationToken cancellationToken);
    private bool StartServerProcess(PipeEndpointName pipeEndpointName, string libraryVersion, Process& pipeServerProcess);
    private void ConnectToServer(String[] arguments, PipeEndpointName pipeEndpointName, Stopwatch stopwatch, PipeEndpoint& pipe, CancellationToken cancellationToken);
    private PipeClientStatus ProcessMessages(PipeEndpoint pipe, Int32& exitCode, CancellationToken cancellationToken);
    private void KillServerProcess();
    private void OnPipeProcessExited(Process process);
    public static string GetCurrentLibraryVersion();
    public static string GetFileVersion(string path);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <StartServerProcess>b__12_0(object s, EventArgs ea);
}
internal class PostSharp.Compiler.Client.Pipe.PipeEndPacket : PipePacket {
    [CompilerGeneratedAttribute]
private int <ReturnCode>k__BackingField;
    public int ReturnCode { get; private set; }
    public PipeEndPacket(int returnCode);
    [CompilerGeneratedAttribute]
public int get_ReturnCode();
    [CompilerGeneratedAttribute]
private void set_ReturnCode(int value);
    protected virtual void ReadContent(BinaryReader reader);
    protected virtual void WriteContent(BinaryWriter writer);
}
internal class PostSharp.Compiler.Client.Pipe.PipeEndpoint : MarshalByRefObject {
    private BinaryReader reader;
    private BinaryWriter writer;
    private PipeStream stream;
    private object sync;
    [CompilerGeneratedAttribute]
private CancellationTokenRegistration <cancellationTokenRegistration>k__BackingField;
    public bool HasClient { get; }
    public CancellationTokenRegistration cancellationTokenRegistration { get; public set; }
    private PipeEndpoint(PipeStream stream, CancellationToken cancellationToken);
    public bool get_HasClient();
    public bool Listen(ThreadStart readyAction);
    public PipePacket ReadPacket();
    public void WritePacket(PipePacket packet);
    public static PipeStream CreateServerPipe(PipeEndpointName pipeName, int writeTimeout);
    public static PipeEndpoint CreateServer(PipeEndpointName pipeName, int writeTimeout, CancellationToken cancellationToken);
    public static PipeEndpoint GetFromPipe(PipeStream pipeStream, CancellationToken cancellationToken);
    public static PipeEndpoint OpenClient(PipeEndpointName pipeName, int openTimeout, int operationTimeout, CancellationToken cancellationToken);
    public void Disconnect();
    public sealed virtual void Dispose();
    public void Abort();
    [CompilerGeneratedAttribute]
public CancellationTokenRegistration get_cancellationTokenRegistration();
    [CompilerGeneratedAttribute]
public void set_cancellationTokenRegistration(CancellationTokenRegistration value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0();
}
internal class PostSharp.Compiler.Client.Pipe.PipeEndpointName : object {
    [CompilerGeneratedAttribute]
private string <PipeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UniqueName>k__BackingField;
    public string PipeName { get; private set; }
    public string UniqueName { get; private set; }
    private PipeEndpointName(string pipeName, string eventName);
    public static PipeEndpointName Create(string platform, string build, string version);
    private static string FormatHex(Byte[] hash);
    private static string GetCurrentUserString();
    [SuppressUnmanagedCodeSecurityAttribute]
private static bool IsUserAnAdmin();
    [CompilerGeneratedAttribute]
public string get_PipeName();
    [CompilerGeneratedAttribute]
private void set_PipeName(string value);
    [CompilerGeneratedAttribute]
public string get_UniqueName();
    [CompilerGeneratedAttribute]
private void set_UniqueName(string value);
}
public class PostSharp.Compiler.Client.Pipe.PipeException : Exception {
    [CompilerGeneratedAttribute]
private int <ErrorCode>k__BackingField;
    public int ErrorCode { get; private set; }
    public PipeException(string message);
    public PipeException(int errorCode, string message);
    public PipeException(string message, Exception inner);
    private PipeException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public int get_ErrorCode();
    [CompilerGeneratedAttribute]
private void set_ErrorCode(int value);
}
internal class PostSharp.Compiler.Client.Pipe.PipeHelloPacket : PipePacket {
    [CompilerGeneratedAttribute]
private int <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public int ProcessId { get; public set; }
    public string Version { get; public set; }
    public PipeHelloPacket(string version, int processId);
    [CompilerGeneratedAttribute]
public int get_ProcessId();
    [CompilerGeneratedAttribute]
public void set_ProcessId(int value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    protected virtual void ReadContent(BinaryReader reader);
    protected virtual void WriteContent(BinaryWriter writer);
}
internal class PostSharp.Compiler.Client.Pipe.PipeMessagePacket : PipePacket {
    [CompilerGeneratedAttribute]
private ClientMessage <Message>k__BackingField;
    public ClientMessage Message { get; private set; }
    public PipeMessagePacket(ClientMessage message);
    protected virtual void ReadContent(BinaryReader reader);
    protected virtual void WriteContent(BinaryWriter writer);
    [CompilerGeneratedAttribute]
public ClientMessage get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(ClientMessage value);
}
internal abstract class PostSharp.Compiler.Client.Pipe.PipePacket : object {
    private static UInt32 startSignature;
    private static UInt32 endSignature;
    [CompilerGeneratedAttribute]
private PipePacketKind <Kind>k__BackingField;
    public PipePacketKind Kind { get; private set; }
    protected PipePacket(PipePacketKind kind);
    [CompilerGeneratedAttribute]
public PipePacketKind get_Kind();
    [CompilerGeneratedAttribute]
private void set_Kind(PipePacketKind value);
    [DebuggerStepThroughAttribute]
public static PipePacket Read(BinaryReader reader);
    public void Write(BinaryWriter writer);
    protected abstract virtual void ReadContent(BinaryReader reader);
    protected abstract virtual void WriteContent(BinaryWriter writer);
}
public enum PostSharp.Compiler.Client.Pipe.PipePacketKind : Enum {
    public byte value__;
    public static PipePacketKind Unknown;
    public static PipePacketKind Start;
    public static PipePacketKind Message;
    public static PipePacketKind End;
    public static PipePacketKind Ack;
    public static PipePacketKind Hello;
    public static PipePacketKind Shutdown;
}
internal class PostSharp.Compiler.Client.Pipe.PipeShutdownPacket : PipePacket {
    protected virtual void ReadContent(BinaryReader reader);
    protected virtual void WriteContent(BinaryWriter writer);
}
internal class PostSharp.Compiler.Client.Pipe.PipeStartPacket : PipePacket {
    [CompilerGeneratedAttribute]
private string <WorkingDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Arguments>k__BackingField;
    public string WorkingDirectory { get; private set; }
    public String[] Arguments { get; private set; }
    public PipeStartPacket(string workingDirectory, String[] arguments);
    [CompilerGeneratedAttribute]
public string get_WorkingDirectory();
    [CompilerGeneratedAttribute]
private void set_WorkingDirectory(string value);
    [CompilerGeneratedAttribute]
public String[] get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(String[] value);
    protected virtual void ReadContent(BinaryReader reader);
    protected virtual void WriteContent(BinaryWriter writer);
}
[SuppressUnmanagedCodeSecurityAttribute]
public class PostSharp.Compiler.Client.Pipe.PipeStream : Stream {
    private static int ERROR_IO_PENDING;
    private static UInt32 GENERIC_READ;
    private static UInt32 GENERIC_WRITE;
    private static int INVALID_HANDLE_VALUE;
    private static UInt32 FILE_FLAG_OVERLAPPED;
    private static UInt32 OPEN_EXISTING;
    private static UInt32 PIPE_ACCESS_OUTBOUND;
    private static UInt32 PIPE_ACCESS_INBOUND;
    private static UInt32 PIPE_WAIT;
    private static UInt32 PIPE_TYPE_BYTE;
    private static UInt32 PIPE_UNLIMITED_INSTANCES;
    private static UInt32 NMPWAIT_WAIT_FOREVER;
    private static int ERROR_PIPE_CONNECTED;
    private ManualResetEvent abortEvent;
    private IntPtr _handle;
    private bool _handleOwned;
    private FileAccess _mode;
    private PipeStreamMode _peerType;
    private IntPtr _overlapped;
    private AutoResetEvent _overlappedEvent;
    private string _name;
    private int timeout;
    [CompilerGeneratedAttribute]
private bool <HasClient>k__BackingField;
    public int Timeout { get; public set; }
    public bool HasClient { get; private set; }
    public bool IsConnected { get; }
    public bool DataAvailable { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    private PipeStream(string name);
    public PipeStream(string pipename, FileAccess mode);
    public PipeStream(string pipename, FileAccess mode, int wait);
    public PipeStream(PipeStreamState state, bool handleOwned);
    private static bool GetOverlappedResult(IntPtr hFile, IntPtr lpOverlapped, UInt32& lpNumberOfBytesTransferred, bool bWait);
    private static bool WaitNamedPipe(string lpNamedPipeName, int nTimeOut);
    private static IntPtr CreateFile(string lpFileName, UInt32 dwDesiredAccess, UInt32 dwShareMode, IntPtr lpSecurityAttributes, UInt32 dwCreationDisposition, UInt32 dwFlagsAndAttributes, IntPtr hTemplateFile);
    private static IntPtr CreateNamedPipe(string lpName, UInt32 dwOpenMode, UInt32 dwPipeMode, UInt32 nMaxInstances, UInt32 nOutBufferSize, UInt32 nInBufferSize, UInt32 nDefaultTimeOut, IntPtr pipeSecurityDescriptor);
    private static bool DisconnectNamedPipe(IntPtr hHandle);
    private static bool ConnectNamedPipe(IntPtr hHandle, IntPtr lpOverlapped);
    private static bool PeekNamedPipe(IntPtr handle, IntPtr buffer, UInt32 nBufferSize, UInt32& bytesRead, UInt32& bytesAvail, UInt32& bytesLeftThisMessage);
    private static bool ReadFile(IntPtr handle, IntPtr buffer, UInt32 toRead, UInt32& read, IntPtr lpOverLapped);
    private static bool WriteFile(IntPtr handle, IntPtr buffer, UInt32 count, UInt32& written, IntPtr lpOverlapped);
    private static bool CloseHandle(IntPtr handle);
    private static bool FlushFileBuffers(IntPtr handle);
    private static bool CancelIo(IntPtr hFile);
    public int get_Timeout();
    public void set_Timeout(int value);
    [CompilerGeneratedAttribute]
public bool get_HasClient();
    [CompilerGeneratedAttribute]
private void set_HasClient(bool value);
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    public void Abort();
    private void ResetOverlapped();
    private void Initialize();
    public void Open(string pipename, FileAccess mode, int waitTimeout);
    public static PipeStream Create(string pipeName, ServerMode mode);
    public bool Listen(ThreadStart readyAction);
    public void Disconnect();
    public bool get_IsConnected();
    public bool get_DataAvailable();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public void ReleaseOwnership();
    public PipeStreamState GetState();
}
public enum PostSharp.Compiler.Client.Pipe.PipeStreamMode : Enum {
    public int value__;
    public static PipeStreamMode Client;
    public static PipeStreamMode Server;
}
public class PostSharp.Compiler.Client.Pipe.PipeStreamState : object {
    [CompilerGeneratedAttribute]
private IntPtr <Handle>k__BackingField;
    [CompilerGeneratedAttribute]
private PipeStreamMode <PeerType>k__BackingField;
    [CompilerGeneratedAttribute]
private FileAccess <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasClient>k__BackingField;
    public IntPtr Handle { get; private set; }
    public PipeStreamMode PeerType { get; private set; }
    public FileAccess Mode { get; private set; }
    public bool HasClient { get; private set; }
    public PipeStreamState(IntPtr handle, PipeStreamMode peerType, FileAccess mode, bool hasClient);
    [CompilerGeneratedAttribute]
public IntPtr get_Handle();
    [CompilerGeneratedAttribute]
private void set_Handle(IntPtr value);
    [CompilerGeneratedAttribute]
public PipeStreamMode get_PeerType();
    [CompilerGeneratedAttribute]
private void set_PeerType(PipeStreamMode value);
    [CompilerGeneratedAttribute]
public FileAccess get_Mode();
    [CompilerGeneratedAttribute]
private void set_Mode(FileAccess value);
    [CompilerGeneratedAttribute]
public bool get_HasClient();
    [CompilerGeneratedAttribute]
private void set_HasClient(bool value);
}
internal class PostSharp.Compiler.Client.Pipe.PipeSync : object {
    public static int MaximumSimultaneouslyConnectingClients;
    [CompilerGeneratedAttribute]
private Mutex <ServerRunningMutex>k__BackingField;
    [CompilerGeneratedAttribute]
private Mutex <ServerStartingMutex>k__BackingField;
    [CompilerGeneratedAttribute]
private Mutex <ClientConnectMutex>k__BackingField;
    [CompilerGeneratedAttribute]
private EventWaitHandle <ServerStartedEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private EventWaitHandle <ClientWaitingEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private EventWaitHandle <PipeAvailableEvent>k__BackingField;
    public Mutex ServerRunningMutex { get; private set; }
    public Mutex ServerStartingMutex { get; private set; }
    public Mutex ClientConnectMutex { get; private set; }
    public EventWaitHandle ServerStartedEvent { get; private set; }
    public EventWaitHandle ClientWaitingEvent { get; private set; }
    public EventWaitHandle PipeAvailableEvent { get; private set; }
    public PipeSync(PipeEndpointName pipeEndpointName);
    [CompilerGeneratedAttribute]
public Mutex get_ServerRunningMutex();
    [CompilerGeneratedAttribute]
private void set_ServerRunningMutex(Mutex value);
    [CompilerGeneratedAttribute]
public Mutex get_ServerStartingMutex();
    [CompilerGeneratedAttribute]
private void set_ServerStartingMutex(Mutex value);
    [CompilerGeneratedAttribute]
public Mutex get_ClientConnectMutex();
    [CompilerGeneratedAttribute]
private void set_ClientConnectMutex(Mutex value);
    [CompilerGeneratedAttribute]
public EventWaitHandle get_ServerStartedEvent();
    [CompilerGeneratedAttribute]
private void set_ServerStartedEvent(EventWaitHandle value);
    [CompilerGeneratedAttribute]
public EventWaitHandle get_ClientWaitingEvent();
    [CompilerGeneratedAttribute]
private void set_ClientWaitingEvent(EventWaitHandle value);
    [CompilerGeneratedAttribute]
public EventWaitHandle get_PipeAvailableEvent();
    [CompilerGeneratedAttribute]
private void set_PipeAvailableEvent(EventWaitHandle value);
    public bool ServerRunningMutexWaitOne(int timeout);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public void Dispose(bool disposing);
    public void Close();
}
public static class PostSharp.Compiler.Client.PlatformFileSystemHelper : object {
    private static bool CreateHardLinkWin32(string newFileName, string exitingFileName, IntPtr securityAttributes);
    private static bool CreateSymbolicLinkWin32(string symlinkFileName, string targetFileName, UInt32 dwFlags);
    private static int CreateHardLinkLinux(string oldpath, string newpath);
    private static int CreateSymbolicLinkLinux(string oldpath, string newpath);
    public static bool CreateHardLink(string existingFileName, string newFileName, Exception& exception);
    public static bool CreateSymbolicLink(string existingFileName, string newFileName, Exception& exception);
}
public abstract class PostSharp.MSBuild.BaseTask : Task {
    [CompilerGeneratedAttribute]
private LogAdapter <Logger>k__BackingField;
    internal LogAdapter Logger { get; }
    private static BaseTask();
    [CompilerGeneratedAttribute]
internal LogAdapter get_Logger();
}
internal class PostSharp.MSBuild.BuildClient : object {
    internal static int AntivirusDetectedErrorCode;
    internal static int InvalidNetFrameworkRuntimeErrorCode;
    internal static int IntermittentRuntimeFailureErrorCode;
    private ILogger logger;
    private BuildToolsHelper buildToolsHelper;
    private string cancellationSemaphoreName;
    internal static NuGetFramework CompilerNetFrameworkTargetFramework;
    internal static NuGetFramework CompilerNetCoreTargetFramework;
    private static Char[] trimmableChars;
    private static bool isProcessUnattended;
    private static string isProcessUnattendedLog;
    [CompilerGeneratedAttribute]
private bool <IgnoreError>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExitCode>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <ExpectedMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <DisabledMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <EscalatedMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FailOnUnexpectedMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InputAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InputReferenceDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Projects>k__BackingField;
    [CompilerGeneratedAttribute]
private Item[] <KnownFrameworkReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private Item[] <FrameworkReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private Item[] <ResolvedTargetingPacks>k__BackingField;
    [CompilerGeneratedAttribute]
private Item[] <WindowsSdkVersions>k__BackingField;
    [CompilerGeneratedAttribute]
private Item[] <ProjectReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private Item[] <OtherReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <StartupPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DependencyRestoreDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ToolsDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BinaryDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SpoolDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DependencyDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserConfigDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TempDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LogDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VsixVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <TraceCategories>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <BenchmarkCategories>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BenchmarkKind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BenchmarkOutputFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoLogo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AttachDebugger>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IntermediateDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsePipeServer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PipeTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MutexTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private string <License>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <AddIns>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProcessorArchitecture>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <ToolsFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ToolsRuntimeVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ToolsRuntimeOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CompatibilityLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MetricsFile>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <HostConfigurationFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresVsix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowRemoteExecution>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SolutionBuildId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppDomainKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NetCoreRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NetCoreSdkVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NetCoreSdkDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NetCoreSdkRuntimeIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReadyToRunDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReadyToRunCrossgen2Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectAssetsFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoProjectAssetsFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AdditionalDepsFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AdditionalProbingPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UnsupportedSdkWarningDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseLinksIfPossible>k__BackingField;
    private string hostAppConfig;
    private static HashSet`1<string> assemblyExtensions;
    public bool IgnoreError { get; public set; }
    public int ExitCode { get; private set; }
    public List`1<string> ExpectedMessages { get; public set; }
    public List`1<string> DisabledMessages { get; public set; }
    public List`1<string> EscalatedMessages { get; public set; }
    public bool FailOnUnexpectedMessage { get; public set; }
    public string InputAssembly { get; public set; }
    public string InputReferenceDirectory { get; public set; }
    public String[] Projects { get; public set; }
    public Item[] KnownFrameworkReferences { get; public set; }
    public Item[] FrameworkReferences { get; public set; }
    public Item[] ResolvedTargetingPacks { get; public set; }
    public Item[] WindowsSdkVersions { get; public set; }
    public Item[] ProjectReferences { get; public set; }
    public Item[] OtherReferences { get; public set; }
    public List`1<string> StartupPath { get; public set; }
    public bool DependencyRestoreDisabled { get; public set; }
    public string ToolsDirectory { get; public set; }
    public string BinaryDirectory { get; public set; }
    public string CacheDirectory { get; public set; }
    public string SpoolDirectory { get; public set; }
    public string DependencyDirectory { get; public set; }
    public string ConfigDirectory { get; public set; }
    public string UserConfigDirectory { get; public set; }
    public string TempDirectory { get; public set; }
    public string LogDirectory { get; public set; }
    public string VsixVersion { get; public set; }
    public string TargetFramework { get; public set; }
    public ILogger Logger { get; }
    public Dictionary`2<string, string> Properties { get; public set; }
    public List`1<string> TraceCategories { get; public set; }
    public List`1<string> BenchmarkCategories { get; public set; }
    public string BenchmarkKind { get; public set; }
    public string BenchmarkOutputFile { get; public set; }
    public bool NoLogo { get; public set; }
    public bool AttachDebugger { get; public set; }
    public string IntermediateDirectory { get; public set; }
    public bool UsePipeServer { get; public set; }
    public int PipeTimeout { get; public set; }
    public int MutexTimeout { get; public set; }
    public string License { get; public set; }
    public String[] AddIns { get; public set; }
    public string ProjectDirectory { get; public set; }
    public string ProcessorArchitecture { get; public set; }
    public string ToolsFrameworkString { get; public set; }
    public NuGetFramework ToolsFramework { get; public set; }
    public string ToolsRuntimeVersion { get; public set; }
    public string ToolsRuntimeOptions { get; public set; }
    public string CompatibilityLevel { get; public set; }
    public string MetricsFile { get; public set; }
    public String[] HostConfigurationFiles { get; public set; }
    public bool RequiresVsix { get; public set; }
    public bool AllowRemoteExecution { get; public set; }
    public string SolutionBuildId { get; public set; }
    public string AppDomainKey { get; public set; }
    public string NetCoreRoot { get; public set; }
    public string NetCoreSdkVersion { get; public set; }
    public string NetCoreSdkDirectory { get; public set; }
    public string NetCoreSdkRuntimeIdentifier { get; public set; }
    public bool ReadyToRunDisabled { get; public set; }
    public bool ReadyToRunCrossgen2Disabled { get; public set; }
    public string ProjectAssetsFile { get; public set; }
    public bool NoProjectAssetsFile { get; public set; }
    public string AdditionalDepsFiles { get; public set; }
    public string AdditionalProbingPaths { get; public set; }
    public bool UnsupportedSdkWarningDisabled { get; public set; }
    public bool UseLinksIfPossible { get; public set; }
    public BuildClient(ILogger logger);
    private static BuildClient();
    [CompilerGeneratedAttribute]
public bool get_IgnoreError();
    [CompilerGeneratedAttribute]
public void set_IgnoreError(bool value);
    [CompilerGeneratedAttribute]
public int get_ExitCode();
    [CompilerGeneratedAttribute]
private void set_ExitCode(int value);
    [CompilerGeneratedAttribute]
public List`1<string> get_ExpectedMessages();
    [CompilerGeneratedAttribute]
public void set_ExpectedMessages(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_DisabledMessages();
    [CompilerGeneratedAttribute]
public void set_DisabledMessages(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_EscalatedMessages();
    [CompilerGeneratedAttribute]
public void set_EscalatedMessages(List`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_FailOnUnexpectedMessage();
    [CompilerGeneratedAttribute]
public void set_FailOnUnexpectedMessage(bool value);
    [CompilerGeneratedAttribute]
public string get_InputAssembly();
    [CompilerGeneratedAttribute]
public void set_InputAssembly(string value);
    [CompilerGeneratedAttribute]
public string get_InputReferenceDirectory();
    [CompilerGeneratedAttribute]
public void set_InputReferenceDirectory(string value);
    [CompilerGeneratedAttribute]
public String[] get_Projects();
    [CompilerGeneratedAttribute]
public void set_Projects(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual Item[] get_KnownFrameworkReferences();
    [CompilerGeneratedAttribute]
public void set_KnownFrameworkReferences(Item[] value);
    [CompilerGeneratedAttribute]
public sealed virtual Item[] get_FrameworkReferences();
    [CompilerGeneratedAttribute]
public void set_FrameworkReferences(Item[] value);
    [CompilerGeneratedAttribute]
public Item[] get_ResolvedTargetingPacks();
    [CompilerGeneratedAttribute]
public void set_ResolvedTargetingPacks(Item[] value);
    [CompilerGeneratedAttribute]
public sealed virtual Item[] get_WindowsSdkVersions();
    [CompilerGeneratedAttribute]
public void set_WindowsSdkVersions(Item[] value);
    [CompilerGeneratedAttribute]
public Item[] get_ProjectReferences();
    [CompilerGeneratedAttribute]
public void set_ProjectReferences(Item[] value);
    [CompilerGeneratedAttribute]
public Item[] get_OtherReferences();
    [CompilerGeneratedAttribute]
public void set_OtherReferences(Item[] value);
    [CompilerGeneratedAttribute]
public List`1<string> get_StartupPath();
    [CompilerGeneratedAttribute]
public void set_StartupPath(List`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DependencyRestoreDisabled();
    [CompilerGeneratedAttribute]
public void set_DependencyRestoreDisabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ToolsDirectory();
    [CompilerGeneratedAttribute]
public void set_ToolsDirectory(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_BinaryDirectory();
    [CompilerGeneratedAttribute]
public void set_BinaryDirectory(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_CacheDirectory();
    [CompilerGeneratedAttribute]
public void set_CacheDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_SpoolDirectory();
    [CompilerGeneratedAttribute]
public void set_SpoolDirectory(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DependencyDirectory();
    [CompilerGeneratedAttribute]
public void set_DependencyDirectory(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ConfigDirectory();
    [CompilerGeneratedAttribute]
public void set_ConfigDirectory(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_UserConfigDirectory();
    [CompilerGeneratedAttribute]
public void set_UserConfigDirectory(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TempDirectory();
    [CompilerGeneratedAttribute]
public void set_TempDirectory(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_LogDirectory();
    [CompilerGeneratedAttribute]
public void set_LogDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_VsixVersion();
    [CompilerGeneratedAttribute]
public void set_VsixVersion(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TargetFramework();
    [CompilerGeneratedAttribute]
public void set_TargetFramework(string value);
    public sealed virtual ILogger get_Logger();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_TraceCategories();
    [CompilerGeneratedAttribute]
public void set_TraceCategories(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_BenchmarkCategories();
    [CompilerGeneratedAttribute]
public void set_BenchmarkCategories(List`1<string> value);
    [CompilerGeneratedAttribute]
public string get_BenchmarkKind();
    [CompilerGeneratedAttribute]
public void set_BenchmarkKind(string value);
    [CompilerGeneratedAttribute]
public string get_BenchmarkOutputFile();
    [CompilerGeneratedAttribute]
public void set_BenchmarkOutputFile(string value);
    [CompilerGeneratedAttribute]
public bool get_NoLogo();
    [CompilerGeneratedAttribute]
public void set_NoLogo(bool value);
    [CompilerGeneratedAttribute]
public bool get_AttachDebugger();
    [CompilerGeneratedAttribute]
public void set_AttachDebugger(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_IntermediateDirectory();
    [CompilerGeneratedAttribute]
public void set_IntermediateDirectory(string value);
    [CompilerGeneratedAttribute]
public bool get_UsePipeServer();
    [CompilerGeneratedAttribute]
public void set_UsePipeServer(bool value);
    [CompilerGeneratedAttribute]
public int get_PipeTimeout();
    [CompilerGeneratedAttribute]
public void set_PipeTimeout(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_MutexTimeout();
    [CompilerGeneratedAttribute]
public void set_MutexTimeout(int value);
    [CompilerGeneratedAttribute]
public string get_License();
    [CompilerGeneratedAttribute]
public void set_License(string value);
    [CompilerGeneratedAttribute]
public String[] get_AddIns();
    [CompilerGeneratedAttribute]
public void set_AddIns(String[] value);
    [CompilerGeneratedAttribute]
public string get_ProjectDirectory();
    [CompilerGeneratedAttribute]
public void set_ProjectDirectory(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProcessorArchitecture();
    [CompilerGeneratedAttribute]
public void set_ProcessorArchitecture(string value);
    public string get_ToolsFrameworkString();
    public void set_ToolsFrameworkString(string value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetFramework get_ToolsFramework();
    [CompilerGeneratedAttribute]
public void set_ToolsFramework(NuGetFramework value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ToolsRuntimeVersion();
    [CompilerGeneratedAttribute]
public void set_ToolsRuntimeVersion(string value);
    [CompilerGeneratedAttribute]
public string get_ToolsRuntimeOptions();
    [CompilerGeneratedAttribute]
public void set_ToolsRuntimeOptions(string value);
    [CompilerGeneratedAttribute]
public string get_CompatibilityLevel();
    [CompilerGeneratedAttribute]
public void set_CompatibilityLevel(string value);
    [CompilerGeneratedAttribute]
public string get_MetricsFile();
    [CompilerGeneratedAttribute]
public void set_MetricsFile(string value);
    [CompilerGeneratedAttribute]
public String[] get_HostConfigurationFiles();
    [CompilerGeneratedAttribute]
public void set_HostConfigurationFiles(String[] value);
    [CompilerGeneratedAttribute]
public bool get_RequiresVsix();
    [CompilerGeneratedAttribute]
public void set_RequiresVsix(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowRemoteExecution();
    [CompilerGeneratedAttribute]
public void set_AllowRemoteExecution(bool value);
    [CompilerGeneratedAttribute]
public string get_SolutionBuildId();
    [CompilerGeneratedAttribute]
public void set_SolutionBuildId(string value);
    [CompilerGeneratedAttribute]
public string get_AppDomainKey();
    [CompilerGeneratedAttribute]
public void set_AppDomainKey(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_NetCoreRoot();
    [CompilerGeneratedAttribute]
public void set_NetCoreRoot(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_NetCoreSdkVersion();
    [CompilerGeneratedAttribute]
public void set_NetCoreSdkVersion(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_NetCoreSdkDirectory();
    [CompilerGeneratedAttribute]
public void set_NetCoreSdkDirectory(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_NetCoreSdkRuntimeIdentifier();
    [CompilerGeneratedAttribute]
public void set_NetCoreSdkRuntimeIdentifier(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ReadyToRunDisabled();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ReadyToRunDisabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ReadyToRunCrossgen2Disabled();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ReadyToRunCrossgen2Disabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProjectAssetsFile();
    [CompilerGeneratedAttribute]
public void set_ProjectAssetsFile(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_NoProjectAssetsFile();
    [CompilerGeneratedAttribute]
public void set_NoProjectAssetsFile(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_AdditionalDepsFiles();
    [CompilerGeneratedAttribute]
public void set_AdditionalDepsFiles(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_AdditionalProbingPaths();
    [CompilerGeneratedAttribute]
public void set_AdditionalProbingPaths(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UnsupportedSdkWarningDisabled();
    [CompilerGeneratedAttribute]
public void set_UnsupportedSdkWarningDisabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseLinksIfPossible();
    [CompilerGeneratedAttribute]
public void set_UseLinksIfPossible(bool value);
    private static bool IsAmd64();
    private static bool IsArm64();
    private static bool IsWow64();
    private static string FormatHex(Byte[] hash);
    private Dictionary`2<string, AssemblyName> LoadDependenciesFile(string dependenciesFilePath);
    private bool MergeAppConfig(string sourceFile, Dictionary`2<string, AssemblyName> dependencies);
    [IteratorStateMachineAttribute("PostSharp.MSBuild.BuildClient/<GetItems>d__285")]
private IEnumerable`1<KeyValuePair`2<string, Item>> GetItems();
    public bool Execute(CancellationToken cancellationToken);
    private void SetImplicitProjectProperties(CancellationToken cancellationToken);
    private string GenerateCompilerCommandLineArgsString(Dictionary`2<string, string> additionalProperties, bool allowIntermittentFailureRecovery, bool disableAntivirusDetection);
    private string GenerateDotNetCliArgsString(NuGetVersion netCoreSdkVersion, string netCoreRootOverride, Nullable`1<NetCoreRollForwardKind> rollForwardBehavior, string finalToolPath);
    private List`1<string> GetProjects();
    private static string EscapeProjectAttribute(string value);
    private string CreateProjectFile();
    private List`1<string> GetCommandLineArguments();
    private static string CleanLicenseString(string s);
}
internal class PostSharp.MSBuild.BuildToolsHelper : object {
    private static Regex VersionRegex;
    private IBuildSettingsProvider buildSettingsProvider;
    private string binDirectory;
    [CompilerGeneratedAttribute]
private string <ArchiveFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UnzipperTool>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <BuildToolsFramework>k__BackingField;
    public string ArchiveFile { get; public set; }
    public string UnzipperTool { get; }
    public NuGetFramework BuildToolsFramework { get; }
    public BuildToolsHelper(IBuildSettingsProvider buildSettingsProvider);
    private static BuildToolsHelper();
    [CompilerGeneratedAttribute]
public string get_ArchiveFile();
    [CompilerGeneratedAttribute]
public void set_ArchiveFile(string value);
    [CompilerGeneratedAttribute]
public string get_UnzipperTool();
    [CompilerGeneratedAttribute]
public NuGetFramework get_BuildToolsFramework();
    public bool Extract(CancellationToken cancellationToken);
    public string GetToolPath(bool usePipeServer, string targetPlatform);
    public string GetToolDepsPath();
    private string GeneratePathToToolCoreDirectory();
    private string GetToolName(bool usePipeServer, string targetPlatform);
    private string GetToolDepsName();
}
internal class PostSharp.MSBuild.CommandLineBuilder : object {
    private List`1<string> arguments;
    private static Regex allowedUnquoted;
    private static CommandLineBuilder();
    public void Append(string argument);
    public void Append(string format, Object[] arguments);
    public void Append(IEnumerable`1<string> arguments);
    public virtual string ToString();
    public string ToString(string separator, bool useQuotes);
    public String[] ToArray();
}
public static class PostSharp.MSBuild.DebuggerHelper : object {
    public static void AttachDebugger(CancellationToken cancellationToken);
}
public class PostSharp.MSBuild.ExtractBuildSettingsProvider : object {
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ToolsDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <ToolsFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MutexTimeout>k__BackingField;
    public ILogger Logger { get; }
    public string ToolsDirectory { get; }
    public NuGetFramework ToolsFramework { get; }
    public int MutexTimeout { get; }
    public ExtractBuildSettingsProvider(ILogger logger, NuGetFramework toolsFramework, string toolsDirectory);
    [CompilerGeneratedAttribute]
public sealed virtual ILogger get_Logger();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ToolsDirectory();
    [CompilerGeneratedAttribute]
public sealed virtual NuGetFramework get_ToolsFramework();
    [CompilerGeneratedAttribute]
public sealed virtual int get_MutexTimeout();
}
internal abstract class PostSharp.MSBuild.FrameworkFileBuilder`1 : object {
    private static string cachedDocumentString;
    private static string cachedDocumentHash;
    private string prefix;
    private IBuildClient buildClient;
    protected FrameworkFileBuilder`1(IBuildClient buildClient, string prefix);
    public string Build(CancellationToken cancellationToken);
    protected abstract virtual XDocument CreateDocument(CancellationToken cancellationToken);
}
internal interface PostSharp.MSBuild.IBuildClient {
    public string TargetFramework { get; }
    public string ProcessorArchitecture { get; }
    public string IntermediateDirectory { get; }
    public string ProjectAssetsFile { get; }
    public string AdditionalDepsFiles { get; }
    public string AdditionalProbingPaths { get; }
    public bool NoProjectAssetsFile { get; }
    public string NetCoreRoot { get; }
    public string NetCoreSdkVersion { get; }
    public string NetCoreSdkDirectory { get; }
    public string NetCoreSdkRuntimeIdentifier { get; }
    public bool ReadyToRunDisabled { get; public set; }
    public bool ReadyToRunCrossgen2Disabled { get; public set; }
    public Item[] KnownFrameworkReferences { get; }
    public Item[] WindowsSdkVersions { get; }
    public Item[] FrameworkReferences { get; }
    public string ToolsRuntimeVersion { get; }
    public string BinaryDirectory { get; }
    public string CacheDirectory { get; }
    public string DependencyDirectory { get; }
    public string ConfigDirectory { get; }
    public string UserConfigDirectory { get; }
    public string TempDirectory { get; }
    public string LogDirectory { get; }
    public bool DependencyRestoreDisabled { get; }
    public bool UnsupportedSdkWarningDisabled { get; }
    public bool UseLinksIfPossible { get; }
    public abstract virtual string get_TargetFramework();
    public abstract virtual string get_ProcessorArchitecture();
    public abstract virtual string get_IntermediateDirectory();
    public abstract virtual string get_ProjectAssetsFile();
    public abstract virtual string get_AdditionalDepsFiles();
    public abstract virtual string get_AdditionalProbingPaths();
    public abstract virtual bool get_NoProjectAssetsFile();
    public abstract virtual string get_NetCoreRoot();
    public abstract virtual string get_NetCoreSdkVersion();
    public abstract virtual string get_NetCoreSdkDirectory();
    public abstract virtual string get_NetCoreSdkRuntimeIdentifier();
    public abstract virtual bool get_ReadyToRunDisabled();
    public abstract virtual void set_ReadyToRunDisabled(bool value);
    public abstract virtual bool get_ReadyToRunCrossgen2Disabled();
    public abstract virtual void set_ReadyToRunCrossgen2Disabled(bool value);
    public abstract virtual Item[] get_KnownFrameworkReferences();
    public abstract virtual Item[] get_WindowsSdkVersions();
    public abstract virtual Item[] get_FrameworkReferences();
    public abstract virtual string get_ToolsRuntimeVersion();
    public abstract virtual string get_BinaryDirectory();
    public abstract virtual string get_CacheDirectory();
    public abstract virtual string get_DependencyDirectory();
    public abstract virtual string get_ConfigDirectory();
    public abstract virtual string get_UserConfigDirectory();
    public abstract virtual string get_TempDirectory();
    public abstract virtual string get_LogDirectory();
    public abstract virtual bool get_DependencyRestoreDisabled();
    public abstract virtual bool get_UnsupportedSdkWarningDisabled();
    public abstract virtual bool get_UseLinksIfPossible();
}
internal interface PostSharp.MSBuild.IBuildSettingsProvider {
    public ILogger Logger { get; }
    public string ToolsDirectory { get; }
    public NuGetFramework ToolsFramework { get; }
    public int MutexTimeout { get; }
    public abstract virtual ILogger get_Logger();
    public abstract virtual string get_ToolsDirectory();
    public abstract virtual NuGetFramework get_ToolsFramework();
    public abstract virtual int get_MutexTimeout();
}
internal class PostSharp.MSBuild.InstalledFrameworksFileBuilder : FrameworkFileBuilder`1<InstalledFrameworksFileBuilder> {
    public InstalledFrameworksFileBuilder(IBuildClient buildClient);
    protected virtual XDocument CreateDocument(CancellationToken cancellationToken);
    private static IEnumerable`1<XElement> GetInstalledFrameworks();
    private static string GetMicrosoftSdkLocation(string frameworkIdentifier, Version frameworkVersion);
    [IteratorStateMachineAttribute("PostSharp.MSBuild.InstalledFrameworksFileBuilder/<GetPathToMicrosoftSdkReferenceAssemblies>d__4")]
private static IEnumerable`1<string> GetPathToMicrosoftSdkReferenceAssemblies(string frameworkIdentifier, Version frameworkVersion);
}
internal static class PostSharp.MSBuild.IORetryUtility : object {
    public static bool ProcessFile(string source, string destination, Action`2<string, string> action, string description, TimeSpan timeout, TimeSpan warningTimeout, ILogger logger, CancellationToken cancellationToken);
    private static void AppendLockingProcesses(IResourceMonitorService resourceMonitor, StringBuilder message, string file, string role);
}
internal class PostSharp.MSBuild.Item : object {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    public string Value { get; public set; }
    public IDictionary`2<string, string> Metadata { get; }
    public Item(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
}
internal class PostSharp.MSBuild.LoggerAdapter : object {
    private ILogger logger;
    private LoggerAdapterMode mode;
    internal LoggerAdapter(ILogger logger, LoggerAdapterMode mode);
    public sealed virtual void LogError(string format, Object[] args);
    public sealed virtual void LogException(Exception e);
    public sealed virtual void LogMessage(string format, Object[] args);
    public sealed virtual void LogMessage(ClientMessage message);
    public sealed virtual void LogMessageFromText(string lineOfText);
    public sealed virtual void LogVerbose(string format, Object[] args);
    public sealed virtual void LogWarning(string format, Object[] args);
    private string CleanMessage(string message);
}
internal enum PostSharp.MSBuild.LoggerAdapterMode : Enum {
    public int value__;
    public static LoggerAdapterMode ErrorsAsWarnings;
    public static LoggerAdapterMode ErrorsAndWarningsAsInfo;
}
internal static class PostSharp.MSBuild.LoggingSystemLock : object {
    public static IDisposable Acquire(ILogger logger, string directory, TimeSpan timeout, CancellationToken cancellationToken, Object[] identifierParts);
}
public abstract class PostSharp.MSBuild.MoveOrCopyWithRetry : BaseTask {
    private CancellationTokenSource cancellationTokenSource;
    private string verb;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <SourceFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <DestinationFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Timeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WarningTimeout>k__BackingField;
    public string Source { get; public set; }
    public ITaskItem[] SourceFiles { get; public set; }
    public string Destination { get; public set; }
    public ITaskItem DestinationFolder { get; public set; }
    public int Timeout { get; public set; }
    public int WarningTimeout { get; public set; }
    internal MoveOrCopyWithRetry(string verb);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_SourceFiles();
    [CompilerGeneratedAttribute]
public void set_SourceFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_Destination();
    [CompilerGeneratedAttribute]
public void set_Destination(string value);
    [CompilerGeneratedAttribute]
public ITaskItem get_DestinationFolder();
    [CompilerGeneratedAttribute]
public void set_DestinationFolder(ITaskItem value);
    [CompilerGeneratedAttribute]
public int get_Timeout();
    [CompilerGeneratedAttribute]
public void set_Timeout(int value);
    [CompilerGeneratedAttribute]
public int get_WarningTimeout();
    [CompilerGeneratedAttribute]
public void set_WarningTimeout(int value);
    public virtual bool Execute();
    internal abstract virtual void Do(string source, string destination);
    public sealed virtual void Cancel();
    [CompilerGeneratedAttribute]
private bool <Execute>g__DoWithRetry|27_0(string source, string destination);
}
internal class PostSharp.MSBuild.NetCore.AssetsFile : object {
    private static ConcurrentDictionary`2<string, AssetsFile> cache;
    private string filePath;
    private DateTime lastWriteTime;
    public int Version;
    public Dictionary`2<FrameworkRidPair, AssetsFileRestoreTarget> Targets;
    public Dictionary`2<NameVersionPair, AssetsFileLibrary> Libraries;
    public HashSet`1<string> PackageFolders;
    public AssetsFile(string filePath, DateTime lastWriteTime);
    private static AssetsFile();
    public static AssetsFile Deserialize(string filePath);
}
internal class PostSharp.MSBuild.NetCore.AssetsFileLibrary : object {
    public string Sha512;
    public string Type;
    public string Path;
    public bool HasTools;
    public String[] Files;
}
internal class PostSharp.MSBuild.NetCore.AssetsFileRestoreTarget : object {
    public Dictionary`2<NameVersionPair, AssetsFileTargetDependency> Dependencies;
}
internal class PostSharp.MSBuild.NetCore.AssetsFileRuntimeTargetsLibrarySpec : object {
    public string AssetType;
    public string Rid;
}
internal class PostSharp.MSBuild.NetCore.AssetsFileTargetDependency : object {
    public string Type;
    public string Framework;
    public Dictionary`2<string, VersionRange> Dependencies;
    public HashSet`1<string> Runtime;
    public Dictionary`2<string, AssetsFileRuntimeTargetsLibrarySpec> RuntimeTargets;
}
internal class PostSharp.MSBuild.NetCore.BuildTimeDependencyRestorer : object {
    private IBuildClient buildClient;
    private string netCoreCliCommand;
    private IBuildTimeDependencySource[] dependencySources;
    public BuildTimeDependencyRestorer(IBuildClient buildClient, string netCoreCliCommand, IBuildTimeDependencySource[] dependencySources);
    public bool Restore(NuGetVersion sdkVersion, string nativeRuntimeIdentifier, string compilerToolsDirectory, NuGetFramework nativeFramework, String& compilerAssetsJsonFilePath, CancellationToken cancellationToken);
    private bool RestoreDependencyProject(string dependencyRestoreProjectDirectory, string dependencyRestoreProjectFilePath, CancellationToken cancellationToken);
    private static string GetRestoreOutputPath(string dependencyRestoreProjectFilePath);
    private static void CreateDependencyRestoreProject(NuGetFramework restoreFramework, HashSet`1<NameVersionPair> allDependencyPackages, string dependencyRestoreProjectFilePath);
    private NuGetFramework DetermineRestoreFramework(NuGetVersion sdkVersion, NuGetFramework nativeFramework);
    private void PrintDependencyList(IEnumerable`1<NameVersionPair> allDependencies);
    [CompilerGeneratedAttribute]
internal static bool <Restore>g__CheckUpToDate|4_0(<>c__DisplayClass4_0& );
}
internal class PostSharp.MSBuild.NetCore.CompilerDependencySource : object {
    private IBuildClient buildClient;
    public CompilerDependencySource(IBuildClient buildClient);
    public sealed virtual string GetCacheId();
    public sealed virtual IEnumerable`1<NameVersionPair> GetDependencyPackages(string compilerToolsDirectory);
    public sealed virtual String[] GetInputFiles(string compilerToolsDirectory);
}
internal class PostSharp.MSBuild.NetCore.CompilerRuntimeDirectoryBuilder : object {
    private IBuildClient buildClient;
    public CompilerRuntimeDirectoryBuilder(IBuildClient buildClient);
    public bool Build(NuGetVersion netCoreSdkVersion, string runtimeIdentifier, NuGetFramework nativeFramework, string compilerDepsJsonFilePath, string compilerAssetsJsonFilePath, string projectDepsJsonFilePath, string projectRuntimeConfigPath, string toolDirectory, string toolPath, CancellationToken cancellationToken);
    private bool LinkOrCopy(string sourcePath, string destinationPath);
    public static string GetProcessCommandLine(Process process);
    private bool LinkOrCopyOnce(string sourcePath, string destinationPath, Boolean& fileIsInUse);
    [CompilerGeneratedAttribute]
private bool <LinkOrCopyOnce>g__Copy|5_0(Boolean& fileIsInUse, <>c__DisplayClass5_0& );
}
internal class PostSharp.MSBuild.NetCore.DependencySet : object {
    [CompilerGeneratedAttribute]
private NuGetFramework <Framework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TargetDependency> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExplicit>k__BackingField;
    public NuGetFramework Framework { get; }
    public string Signature { get; }
    public List`1<TargetDependency> Dependencies { get; }
    public bool IsExplicit { get; }
    public DependencySet(NuGetFramework framework, string signature, bool isExplicit);
    [CompilerGeneratedAttribute]
public NuGetFramework get_Framework();
    [CompilerGeneratedAttribute]
public string get_Signature();
    [CompilerGeneratedAttribute]
public List`1<TargetDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public bool get_IsExplicit();
}
internal class PostSharp.MSBuild.NetCore.DepsFile : object {
    private static ConcurrentDictionary`2<string, DepsFile> cache;
    private string filePath;
    private DateTime lastWriteTime;
    public DepsFileRuntimeTarget RuntimeTarget;
    public Dictionary`2<NuGetFramework, DepsFileTarget> Targets;
    public Dictionary`2<NameVersionPair, DepsFileLibrary> Libraries;
    public DepsFile(string filePath, DateTime lastWriteTime);
    private static DepsFile();
    public static DepsFile Deserialize(string filePath);
    public void Serialize(string filePath);
}
internal class PostSharp.MSBuild.NetCore.DepsFileDependency : object {
    public HashSet`1<NameVersionPair> Dependencies;
    public Dictionary`2<string, DepsFileRuntimeLibrarySpec> Runtime;
    public Dictionary`2<string, DepsFileRuntimeTargetsLibrarySpec> RuntimeTargets;
}
internal class PostSharp.MSBuild.NetCore.DepsFileLibrary : object {
    public string Type;
    public bool Serviceable;
    public string Sha512;
    public string Path;
    public string HashPath;
}
internal class PostSharp.MSBuild.NetCore.DepsFileRuntimeLibrarySpec : object {
    public Version AssemblyVersion;
    public string FileVersion;
}
internal class PostSharp.MSBuild.NetCore.DepsFileRuntimeTarget : object {
    public NuGetFramework Name;
    public string Signature;
}
internal class PostSharp.MSBuild.NetCore.DepsFileRuntimeTargetsLibrarySpec : object {
    public string Rid;
    public string AssetType;
    public Version AssemblyVersion;
    public string FileVersion;
}
internal class PostSharp.MSBuild.NetCore.DepsFileTarget : object {
    public Dictionary`2<NameVersionPair, DepsFileDependency> Dependencies;
}
[ExtensionAttribute]
internal static class PostSharp.MSBuild.NetCore.DictionaryExtensions : object {
    [ExtensionAttribute]
public static TValue GetOrAdd(Dictionary`2<TKey, TValue> dictionary, TKey key);
}
internal class PostSharp.MSBuild.NetCore.FrameworkRidPair : ValueType {
    [CompilerGeneratedAttribute]
private NuGetFramework <Framework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Rid>k__BackingField;
    public NuGetFramework Framework { get; }
    public string Rid { get; }
    public FrameworkRidPair(NuGetFramework framework, string rid);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public NuGetFramework get_Framework();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Rid();
    public static FrameworkRidPair Parse(string frameworkRidString);
    public sealed virtual bool Equals(FrameworkRidPair other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal interface PostSharp.MSBuild.NetCore.IBuildTimeDependencySource {
    public abstract virtual string GetCacheId();
    public abstract virtual String[] GetInputFiles(string compilerToolsDirectory);
    public abstract virtual IEnumerable`1<NameVersionPair> GetDependencyPackages(string compilerToolsDirectory);
}
internal class PostSharp.MSBuild.NetCore.NameVersionPair : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    public string Name { get; }
    public NuGetVersion Version { get; }
    public NameVersionPair(string name, NuGetVersion version);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    public static NameVersionPair Parse(string nameVersionString);
    public sealed virtual bool Equals(NameVersionPair other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class PostSharp.MSBuild.NetCore.NativeImageManager : object {
    private IBuildClient buildClient;
    private NuGetFramework nativeFramework;
    private NuGetVersion sdkVersion;
    private string runtimeIdentifier;
    private string compilerDepsJsonFilePath;
    private string compilerAssetsJsonFilePath;
    private string projectDepsJsonFilePath;
    private string crossgenPath;
    private string clrjitPath;
    private bool usingCrossgen2;
    private String[] nativeAssemblyDirectories;
    private String[] dependendencyAssemblyPaths;
    private String[] crossgenableDependencyAssemblies;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2[] runtimePacks;
    private Dictionary`2<string, string> nativeAssemblyPaths;
    private HashSet`1<string> nativeAssemblyFileNames;
    [CompilerGeneratedAttribute]
private bool <Initialized>k__BackingField;
    public bool Initialized { get; private set; }
    public NativeImageManager(IBuildClient buildClient, NuGetVersion sdkVersion, NuGetFramework nativeFramework, string runtimeIdentifier, string compilerDepsJsonFilePath, string compilerAssetsJsonFilePath, string projectDepsJsonFilePath);
    [CompilerGeneratedAttribute]
public bool get_Initialized();
    [CompilerGeneratedAttribute]
private void set_Initialized(bool value);
    public String[] GetCrossgenableDependencyAssemblies();
    public bool Initialize();
    private bool InitializeNativeAssemblyDirectories();
    private bool InitializeCrossgenableDependencyAssemblies(DepsFile compilerDeps, AssetsFile compilerAssets, DepsFile projectDeps);
    public bool InitializeDependencyDirectories(DepsFile compilerDeps, AssetsFile compilerAssets);
    private bool GetCrossGenPaths(String& crossgenPath, String& clrjitPath, Boolean& isCrossgen2, ValueTuple`2[]& runtimePacks);
    public string GetNativeImagePath(string path, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private void <GetCrossGenPaths>g__ParseJson|26_0(string filePath, String& crossgenPath, String& clrjitPath, Boolean& isCrossgen2, ValueTuple`2[]& runtimePacks);
}
internal class PostSharp.MSBuild.NetCore.NetCoreConstants : object {
    public static string DotNetCliInstallDirectoryName;
    public static string DotNetSdkRuntimeConfig;
    public static string DotNetCliGetVersion;
    public static string DotNetCliListRuntimes;
    public static string DotNetCliListSdks;
    public static string PrimaryBuildRuntimeName;
    public static NuGetVersion MinimumSupportedSdkVersion;
    public static NuGetVersion MaximumSupportedSdkMinorVersion;
    public static NuGetFramework[] MaximumSupportedFrameworks;
    public static NuGetVersion MinimumSupportedRuntimeVersion;
    public static string DotNetCliExecutable { get; }
    private static NetCoreConstants();
    public static string get_DotNetCliExecutable();
}
internal class PostSharp.MSBuild.NetCore.NetCoreResolver : object {
    private IBuildClient buildClient;
    private static SharedState sharedState;
    private string targetDotNetRoot;
    private string targetDotNetCoreCli;
    private string targetRuntimeIdentifier;
    private string sdkRuntimeIdentifier;
    public NetCoreResolver(IBuildClient buildClient);
    private static NetCoreResolver();
    public virtual Architecture GetProcessArchitecture();
    public virtual bool IsOSPlatform(OSPlatform platform);
    public virtual string GetOSDescription();
    public virtual string GetEnvironmentVariable(string variable);
    public bool EnsureProcessorArchitectureCompatible();
    public bool EnsureRuntimePlatformCompatible();
    internal bool InitializeRuntimePlatform(String& dotnetRoot, String& dotnetCliCommand, String& runtimeIdentifier, String& sdkRuntimeIdentifier);
    private static Nullable`1<Architecture> GetArchitectureFromRid(string runtimeIdentifier);
    private string GetSdkRidFromVersionFile();
    private string GetSdkRidFromCurrentProcess();
    public string GetDotNetRoot();
    public virtual string GetDotNetCliCommand();
    public virtual Architecture GetOSArchitecture();
    public bool GetPrimaryBuildRuntime(RuntimeFramework[] frameworks, RuntimeFramework& primaryRuntime);
    public NuGetFramework ResolveNativeFramework(RuntimeFramework primaryRuntimeFramework);
    public virtual string GetRuntimeIdentifier();
    public bool GetNetCoreSdkVersion(NuGetVersion& netCoreSdkVersion, CancellationToken cancellationToken);
    public bool EnsureTargetNetCoreSdkInstalled(NuGetVersion nativeNetCoreSdkVersion, CancellationToken cancellationToken);
    public bool EnsureSdkCompatible(NuGetVersion netCoreSdkVersion);
    public bool EnsureTargetFrameworkCompatible(NuGetFramework targetFramework);
    public bool GetNetCoreSdkDirectory(NuGetVersion netCoreSdkVersion, String& netCoreSdkDirectory, CancellationToken cancellationToken);
    public bool GetRuntimeFrameworkNames(String[]& runtimeFrameworkNames);
    public bool GetRuntimeFrameworkVersion(NuGetVersion netCoreSdkVersion, String[] runtimeFrameworkNames, RuntimeFramework[]& runtimeFrameworks, Nullable`1& rollForwardBehavior, CancellationToken cancellationToken);
    internal bool GetRuntimeFrameworkVersion(NuGetVersion netCoreSdkVersion, string runtimeFrameworkName, Nullable`1& runtimeFramework, Nullable`1& rollForwardBehavior, CancellationToken cancellationToken);
    protected virtual bool InvokeTool(string command, Int32& exitCode, String& commandOutput, CancellationToken cancellationToken, bool useImplicitCli);
    protected virtual SharedState GetSharedState();
    public virtual bool DirectoryExists(string path);
    public virtual bool FileExists(string path);
    public virtual string FileReadAllText(string path);
    private bool RunCliCommand(string command, String& commandOutput, CancellationToken cancellationToken, bool useImplicitCli);
    private bool ReadInstalledSdkVersions(CancellationToken cancellationToken);
    private bool ReadInstalledRuntimeVersions(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private string <InitializeRuntimePlatform>g__GetDefaultDotnetCliPath|13_0();
    [CompilerGeneratedAttribute]
internal static int <ResolveNativeFramework>g__CompareFrameworksByCompatibility|21_6(NuGetFramework x, NuGetFramework y);
    [CompilerGeneratedAttribute]
internal static string <EnsureSdkCompatible>g__GetVersionRangeMessage|25_0();
}
public enum PostSharp.MSBuild.NetCore.NetCoreRollForwardKind : Enum {
    public int value__;
    public static NetCoreRollForwardKind Disable;
    public static NetCoreRollForwardKind LatestPatch;
    public static NetCoreRollForwardKind Minor;
    public static NetCoreRollForwardKind Major;
    public static NetCoreRollForwardKind LatestMinor;
    public static NetCoreRollForwardKind LatestMajor;
}
internal class PostSharp.MSBuild.NetCore.ProjectDepsBuilder : object {
    private IBuildClient buildClient;
    public ProjectDepsBuilder(IBuildClient buildClient);
    private string GetProjectCacheDirectory();
    private string GetRuntimeConfigPath(string runtimeConfigId);
    private string GetDepsJsonPath(string runtimeConfigId);
    private string MakeRuntimeConfigurationIdentifier(RuntimeFramework[] runtimeFrameworks, String[] additionalProbePaths, String[] additionalDepsFilePaths);
    private string MakeInputsSuffix(RuntimeFramework[] runtimeFrameworks, String[] additionalProbePaths, String[] additionalDepsFilePaths);
    public bool Build(RuntimeFramework[] runtimeFrameworks, string compilerDepsFilePath, NuGetFramework nativeFramework, NuGetFramework targetFramework, String& projectRuntimeConfigPath, String& projectDepsFilePath, CancellationToken cancellationToken);
    private NuGetFramework GetDependencyRuntimeFramework(RuntimeFramework[] runtimeFrameworks, NuGetFramework nativeFramework, NuGetFramework targetFramework);
    private static string GetPackageAssemblyPath(String[] packageFolders, string packageName, SemanticVersion packageVersion, string relativePath);
    private static bool IsDependencyImplicit(string dependencyName);
    private static bool IsDependencyImplicit(NameVersionPair dependency);
    private DependencySet GetDependenciesFromTargetFramework(AssetsFile assetsFile, NuGetFramework targetFramework);
    private DependencySet GetDependenciesFromDepsFile(DepsFile depsFile, NuGetFramework runtimeFramework, bool isExplicitDependencySet);
    private DependencySet GetDependenciesFromLibraryList(AssetsFile assetsFile, NuGetFramework restoredFramework, NuGetFramework runtimeFramework);
    private DependencySet Merge(NuGetFramework runtimeFramework, IEnumerable`1<DependencySet> dependencySets);
    private void PruneRuntimeAssemblies(DependencySet dependencySet, RuntimeFramework[] runtimeFrameworks);
    private DepsFile CreateDepsFileFromDependencySet(DependencySet dependencySet, NuGetFramework runtimeFramework);
    private RuntimeConfigFile CreateRuntimeConfigJsonFromAssetsFile(RuntimeFramework[] runtimeFrameworks, AssetsFile assetsFile, string fallbackPackageDirectory, String[] additionalProbePaths, NuGetFramework nativeFramework);
    private AssetsFile DeserializeAssetsFile(string filePath);
    private DepsFile DeserializeDepsFile(string filePath);
    private void SerializeDepsFile(DepsFile file, string filePath);
    private void SerializeRuntimeConfigJson(RuntimeConfigFile file, string filePath);
    [CompilerGeneratedAttribute]
private void <Build>g__WriteFallbackRuntimeConfig|7_0(<>c__DisplayClass7_0& , <>c__DisplayClass7_1& );
    [CompilerGeneratedAttribute]
private bool <Build>g__ShouldGenerateRuntimeConfigFile|7_1(<>c__DisplayClass7_0& , <>c__DisplayClass7_1& );
    [CompilerGeneratedAttribute]
private bool <Build>g__ShouldGenerateDepsFile|7_2(<>c__DisplayClass7_0& , <>c__DisplayClass7_1& );
}
internal class PostSharp.MSBuild.NetCore.RuntimeConfigFile : object {
    private static ConcurrentDictionary`2<string, RuntimeConfigFile> cache;
    private string filePath;
    private DateTime lastWriteTime;
    public RuntimeConfigRuntimeOptions RuntimeOptions;
    public RuntimeConfigFile(string filePath, DateTime lastWriteTime);
    private static RuntimeConfigFile();
    public static RuntimeConfigFile Deserialize(string filePath);
    public void Serialize(string filePath);
}
internal class PostSharp.MSBuild.NetCore.RuntimeConfigFramework : object {
    public string Name;
    public string Version;
}
internal class PostSharp.MSBuild.NetCore.RuntimeConfigRuntimeOptions : object {
    public string Tfm;
    public RuntimeConfigFramework[] Frameworks;
    public String[] AdditionalProbingPaths;
}
internal class PostSharp.MSBuild.NetCore.RuntimeFramework : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Directory>k__BackingField;
    public string Name { get; }
    public NuGetVersion Version { get; }
    public string Directory { get; }
    public RuntimeFramework(string name, NuGetVersion version, string directory);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Directory();
}
internal class PostSharp.MSBuild.NetCore.TargetDependency : object {
    [CompilerGeneratedAttribute]
private NameVersionPair <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetDependencyKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Serviceable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sha512>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HashPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, TargetDependencyImage> <RuntimeDependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, NameVersionPair> <PackageDependencies>k__BackingField;
    public NameVersionPair Id { get; }
    public TargetDependencyKind Kind { get; }
    public string Path { get; }
    public bool Serviceable { get; }
    public string Sha512 { get; }
    public string HashPath { get; }
    public Dictionary`2<string, TargetDependencyImage> RuntimeDependencies { get; }
    public Dictionary`2<string, NameVersionPair> PackageDependencies { get; }
    public TargetDependency(TargetDependencyKind kind, NameVersionPair id, string path, bool serviceable, string sha512, string hashPath);
    [CompilerGeneratedAttribute]
public NameVersionPair get_Id();
    [CompilerGeneratedAttribute]
public TargetDependencyKind get_Kind();
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public bool get_Serviceable();
    [CompilerGeneratedAttribute]
public string get_Sha512();
    [CompilerGeneratedAttribute]
public string get_HashPath();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, TargetDependencyImage> get_RuntimeDependencies();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, NameVersionPair> get_PackageDependencies();
}
internal class PostSharp.MSBuild.NetCore.TargetDependencyImage : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetDependencyImageKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <FileVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <AssemblyVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifier>k__BackingField;
    public string Path { get; }
    public TargetDependencyImageKind Kind { get; }
    public Version FileVersion { get; }
    public Version AssemblyVersion { get; }
    public NuGetFramework TargetFramework { get; }
    public string RuntimeIdentifier { get; }
    public TargetDependencyImage(string path, TargetDependencyImageKind kind, Version fileVersion, Version assemblyVersion, NuGetFramework targetFramework, string runtimeIdentifier);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public TargetDependencyImageKind get_Kind();
    [CompilerGeneratedAttribute]
public Version get_FileVersion();
    [CompilerGeneratedAttribute]
public Version get_AssemblyVersion();
    [CompilerGeneratedAttribute]
public NuGetFramework get_TargetFramework();
    [CompilerGeneratedAttribute]
public string get_RuntimeIdentifier();
    public static bool TryCreate(string localPath, string relativePath, TargetDependencyImage& dependencyImage);
    private static Version GetFileVersion(string path);
    private static Version GetAssemblyVersion(string path);
}
internal enum PostSharp.MSBuild.NetCore.TargetDependencyImageKind : Enum {
    public int value__;
    public static TargetDependencyImageKind Lib;
    public static TargetDependencyImageKind RuntimeLib;
    public static TargetDependencyImageKind RuntimeNative;
}
internal enum PostSharp.MSBuild.NetCore.TargetDependencyKind : Enum {
    public int value__;
    public static TargetDependencyKind Package;
    public static TargetDependencyKind Project;
}
public class PostSharp.MSBuild.PostSharpChangeAppConfig : Task {
    [CompilerGeneratedAttribute]
private string <ConfigFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ClientAttachDebugger>k__BackingField;
    [RequiredAttribute]
public string ConfigFile { get; public set; }
    [RequiredAttribute]
public string Version { get; public set; }
    public bool ClientAttachDebugger { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ConfigFile();
    [CompilerGeneratedAttribute]
public void set_ConfigFile(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public bool get_ClientAttachDebugger();
    [CompilerGeneratedAttribute]
public void set_ClientAttachDebugger(bool value);
    public virtual bool Execute();
    private XmlElement GetOrCreate(XmlNode parent, string elementName, string ns);
}
public class PostSharp.MSBuild.PostSharpCheckPfx : Task {
    private string keyFile;
    private string publicKeyFile;
    private string postSharpKeyFile;
    [RequiredAttribute]
public string KeyFile { get; public set; }
    [OutputAttribute]
public string PublicKeyFile { get; public set; }
    [OutputAttribute]
public string PostSharpKeyFile { get; public set; }
    public string get_KeyFile();
    public void set_KeyFile(string value);
    public string get_PublicKeyFile();
    public void set_PublicKeyFile(string value);
    public string get_PostSharpKeyFile();
    public void set_PostSharpKeyFile(string value);
    public virtual bool Execute();
}
public class PostSharp.MSBuild.PostSharpCompile : BaseTask {
    private CancellationTokenSource cancellationTokenSource;
    private BuildClient buildClient;
    private ITaskItem[] hostConfigurationFiles;
    private ITaskItem[] projects;
    private ITaskItem[] knownFrameworkReferences;
    private ITaskItem[] windowsSdkVersions;
    private ITaskItem[] frameworkReferences;
    private ITaskItem[] resolvedTargetingPacks;
    private ITaskItem[] projectReferences;
    private ITaskItem[] otherReferences;
    private string msBuildProjectFile;
    private ITaskItem[] addIns;
    private ITaskItem[] startupPath;
    private static Char[] trimmableChars;
    [CompilerGeneratedAttribute]
private string <MicrosoftNETBuildExtensionsDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ClientAttachDebugger>k__BackingField;
    public bool IgnoreError { get; public set; }
    [OutputAttribute]
public int ExitCode { get; public set; }
    public string ExpectedMessages { get; public set; }
    public string DisabledMessages { get; public set; }
    public string EscalatedMessages { get; public set; }
    public bool FailOnUnexpectedMessage { get; public set; }
    [RequiredAttribute]
public string Input { get; public set; }
    public string InputReferenceDirectory { get; public set; }
    [RequiredAttribute]
public string IntermediateDirectory { get; public set; }
    public ITaskItem[] Projects { get; public set; }
    public ITaskItem[] KnownFrameworkReferences { get; public set; }
    public ITaskItem[] WindowsSdkVersions { get; public set; }
    public ITaskItem[] FrameworkReferences { get; public set; }
    public ITaskItem[] ResolvedTargetingPacks { get; public set; }
    public ITaskItem[] ProjectReferences { get; public set; }
    public string MicrosoftNETBuildExtensionsDirectory { get; public set; }
    public ITaskItem[] OtherReferences { get; public set; }
    public ITaskItem[] StartupPath { get; public set; }
    public string Properties { get; public set; }
    public string TraceCategories { get; public set; }
    public string BenchmarkCategories { get; public set; }
    public string BenchmarkKind { get; public set; }
    public string BenchmarkOutputFile { get; public set; }
    public bool NoLogo { get; public set; }
    public bool AttachDebugger { get; public set; }
    public bool ClientAttachDebugger { get; public set; }
    public bool UsePipeServer { get; public set; }
    public int PipeTimeout { get; public set; }
    public int MutexTimeout { get; public set; }
    public string License { get; public set; }
    public ITaskItem[] AddIns { get; public set; }
    public string MSBuildProjectFile { get; public set; }
    public string ProcessorArchitecture { get; public set; }
    public string CompatibilityLevel { get; public set; }
    public string MetricsFile { get; public set; }
    public ITaskItem[] HostConfigurationFiles { get; public set; }
    [RequiredAttribute]
public string ToolsDirectory { get; public set; }
    public string ToolsFramework { get; public set; }
    public string ToolsRuntimeVersion { get; public set; }
    public string ToolsRuntimeOptions { get; public set; }
    public bool DependencyRestoreDisabled { get; public set; }
    public string BinaryDirectory { get; public set; }
    public string CacheDirectory { get; public set; }
    public string SpoolDirectory { get; public set; }
    public string DependencyDirectory { get; public set; }
    public string ConfigDirectory { get; public set; }
    public string UserConfigDirectory { get; public set; }
    public string TempDirectory { get; public set; }
    public string LogDirectory { get; public set; }
    public bool RequiresVsix { get; public set; }
    public string VsixVersion { get; public set; }
    public bool AllowRemoteExecution { get; public set; }
    public string SolutionBuildId { get; public set; }
    public string AppDomainKey { get; public set; }
    public string TargetFramework { get; public set; }
    public string NetCoreRoot { get; public set; }
    public string NetCoreSdkVersion { get; public set; }
    public string NetCoreSdkDirectory { get; public set; }
    public string NetCoreSdkRuntimeIdentifier { get; public set; }
    public bool ReadyToRunDisabled { get; public set; }
    public bool ReadyToRunCrossgen2Disabled { get; public set; }
    public bool UnsupportedSdkWarningDisabled { get; public set; }
    public bool UseLinksIfPossible { get; public set; }
    public string ProjectAssetsFile { get; public set; }
    public bool NoProjectAssetsFile { get; public set; }
    public string AdditionalDepsFiles { get; public set; }
    public string AdditionalProbingPaths { get; public set; }
    private static PostSharpCompile();
    public bool get_IgnoreError();
    public void set_IgnoreError(bool value);
    public int get_ExitCode();
    public void set_ExitCode(int value);
    public string get_ExpectedMessages();
    public void set_ExpectedMessages(string value);
    public string get_DisabledMessages();
    public void set_DisabledMessages(string value);
    public string get_EscalatedMessages();
    public void set_EscalatedMessages(string value);
    public bool get_FailOnUnexpectedMessage();
    public void set_FailOnUnexpectedMessage(bool value);
    public string get_Input();
    public void set_Input(string value);
    public string get_InputReferenceDirectory();
    public void set_InputReferenceDirectory(string value);
    public string get_IntermediateDirectory();
    public void set_IntermediateDirectory(string value);
    public ITaskItem[] get_Projects();
    public void set_Projects(ITaskItem[] value);
    public ITaskItem[] get_KnownFrameworkReferences();
    public void set_KnownFrameworkReferences(ITaskItem[] value);
    public ITaskItem[] get_WindowsSdkVersions();
    public void set_WindowsSdkVersions(ITaskItem[] value);
    public ITaskItem[] get_FrameworkReferences();
    public void set_FrameworkReferences(ITaskItem[] value);
    public ITaskItem[] get_ResolvedTargetingPacks();
    public void set_ResolvedTargetingPacks(ITaskItem[] value);
    public ITaskItem[] get_ProjectReferences();
    public void set_ProjectReferences(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_MicrosoftNETBuildExtensionsDirectory();
    [CompilerGeneratedAttribute]
public void set_MicrosoftNETBuildExtensionsDirectory(string value);
    private static Item ToItem(ITaskItem source, String[] copiedMetadata);
    public ITaskItem[] get_OtherReferences();
    public void set_OtherReferences(ITaskItem[] value);
    public ITaskItem[] get_StartupPath();
    public void set_StartupPath(ITaskItem[] value);
    public string get_Properties();
    public void set_Properties(string value);
    public string get_TraceCategories();
    public void set_TraceCategories(string value);
    public string get_BenchmarkCategories();
    public void set_BenchmarkCategories(string value);
    public string get_BenchmarkKind();
    public void set_BenchmarkKind(string value);
    public string get_BenchmarkOutputFile();
    public void set_BenchmarkOutputFile(string value);
    public bool get_NoLogo();
    public void set_NoLogo(bool value);
    public bool get_AttachDebugger();
    public void set_AttachDebugger(bool value);
    [CompilerGeneratedAttribute]
public bool get_ClientAttachDebugger();
    [CompilerGeneratedAttribute]
public void set_ClientAttachDebugger(bool value);
    public bool get_UsePipeServer();
    public void set_UsePipeServer(bool value);
    public int get_PipeTimeout();
    public void set_PipeTimeout(int value);
    public int get_MutexTimeout();
    public void set_MutexTimeout(int value);
    public string get_License();
    public void set_License(string value);
    public ITaskItem[] get_AddIns();
    public void set_AddIns(ITaskItem[] value);
    public string get_MSBuildProjectFile();
    public void set_MSBuildProjectFile(string value);
    public string get_ProcessorArchitecture();
    public void set_ProcessorArchitecture(string value);
    public string get_CompatibilityLevel();
    public void set_CompatibilityLevel(string value);
    public string get_MetricsFile();
    public void set_MetricsFile(string value);
    public ITaskItem[] get_HostConfigurationFiles();
    public void set_HostConfigurationFiles(ITaskItem[] value);
    public string get_ToolsDirectory();
    public void set_ToolsDirectory(string value);
    public string get_ToolsFramework();
    public void set_ToolsFramework(string value);
    public string get_ToolsRuntimeVersion();
    public void set_ToolsRuntimeVersion(string value);
    public string get_ToolsRuntimeOptions();
    public void set_ToolsRuntimeOptions(string value);
    public bool get_DependencyRestoreDisabled();
    public void set_DependencyRestoreDisabled(bool value);
    public string get_BinaryDirectory();
    public void set_BinaryDirectory(string value);
    public string get_CacheDirectory();
    public void set_CacheDirectory(string value);
    public string get_SpoolDirectory();
    public void set_SpoolDirectory(string value);
    public string get_DependencyDirectory();
    public void set_DependencyDirectory(string value);
    public string get_ConfigDirectory();
    public void set_ConfigDirectory(string value);
    public string get_UserConfigDirectory();
    public void set_UserConfigDirectory(string value);
    public string get_TempDirectory();
    public void set_TempDirectory(string value);
    public string get_LogDirectory();
    public void set_LogDirectory(string value);
    public bool get_RequiresVsix();
    public void set_RequiresVsix(bool value);
    public string get_VsixVersion();
    public void set_VsixVersion(string value);
    public bool get_AllowRemoteExecution();
    public void set_AllowRemoteExecution(bool value);
    public string get_SolutionBuildId();
    public void set_SolutionBuildId(string value);
    public string get_AppDomainKey();
    public void set_AppDomainKey(string value);
    public string get_TargetFramework();
    public void set_TargetFramework(string value);
    public string get_NetCoreRoot();
    public void set_NetCoreRoot(string value);
    public string get_NetCoreSdkVersion();
    public void set_NetCoreSdkVersion(string value);
    public string get_NetCoreSdkDirectory();
    public void set_NetCoreSdkDirectory(string value);
    public string get_NetCoreSdkRuntimeIdentifier();
    public void set_NetCoreSdkRuntimeIdentifier(string value);
    public bool get_ReadyToRunDisabled();
    public void set_ReadyToRunDisabled(bool value);
    public bool get_ReadyToRunCrossgen2Disabled();
    public void set_ReadyToRunCrossgen2Disabled(bool value);
    public bool get_UnsupportedSdkWarningDisabled();
    public void set_UnsupportedSdkWarningDisabled(bool value);
    public bool get_UseLinksIfPossible();
    public void set_UseLinksIfPossible(bool value);
    public string get_ProjectAssetsFile();
    public void set_ProjectAssetsFile(string value);
    public bool get_NoProjectAssetsFile();
    public void set_NoProjectAssetsFile(bool value);
    public string get_AdditionalDepsFiles();
    public void set_AdditionalDepsFiles(string value);
    public string get_AdditionalProbingPaths();
    public void set_AdditionalProbingPaths(string value);
    public virtual bool Execute();
    private void PopulateStartupPath();
    public sealed virtual void Cancel();
    private static List`1<string> ParseList(string s, bool strict);
    private static string RenderList(List`1<string> l);
    private static Dictionary`2<string, string> ParseNameValuePairs(string s);
    private static string RenderDictionary(Dictionary`2<string, string> dictionary);
}
public class PostSharp.MSBuild.PostSharpCopyBindingRedirects : BaseTask {
    [CompilerGeneratedAttribute]
private ITaskItem[] <InputFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputFile>k__BackingField;
    public ITaskItem[] InputFiles { get; public set; }
    [RequiredAttribute]
public string OutputFile { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem[] get_InputFiles();
    [CompilerGeneratedAttribute]
public void set_InputFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_OutputFile();
    [CompilerGeneratedAttribute]
public void set_OutputFile(string value);
    public virtual bool Execute();
    private void WriteConfigFile();
    private void CopyBindingRedirects(string inputConfigFile, XmlWriter targetWriter);
    private static void CopyAssemblyBindingSection(XmlReader inputReader, XmlWriter targetWriter);
    private static void CopyDependentAssemblyNode(XmlReader inputReader, XmlWriter targetWriter);
    private static bool StringEquals(string a, string b);
}
public class PostSharp.MSBuild.PostSharpCopyWithRetry : MoveOrCopyWithRetry {
    private static bool entryPointNotFound;
    [CompilerGeneratedAttribute]
private bool <UseHardLink>k__BackingField;
    public bool UseHardLink { get; public set; }
    internal virtual void Do(string source, string destination);
    [CompilerGeneratedAttribute]
public bool get_UseHardLink();
    [CompilerGeneratedAttribute]
public void set_UseHardLink(bool value);
}
public class PostSharp.MSBuild.PostSharpDetectNativeFrameworkVersion : Task {
    private static string cachedNativeFrameworkVersion;
    [CompilerGeneratedAttribute]
private string <NativeFrameworkVersion>k__BackingField;
    [OutputAttribute]
public string NativeFrameworkVersion { get; private set; }
    [CompilerGeneratedAttribute]
public string get_NativeFrameworkVersion();
    [CompilerGeneratedAttribute]
private void set_NativeFrameworkVersion(string value);
    public virtual bool Execute();
}
public class PostSharp.MSBuild.PostSharpExtractTools : BaseTask {
    private CancellationTokenSource cancellationTokenSource;
    [CompilerGeneratedAttribute]
private string <ToolsFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ToolsDirectory>k__BackingField;
    [RequiredAttribute]
public string ToolsFramework { get; public set; }
    [RequiredAttribute]
public string ToolsDirectory { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ToolsFramework();
    [CompilerGeneratedAttribute]
public void set_ToolsFramework(string value);
    [CompilerGeneratedAttribute]
public string get_ToolsDirectory();
    [CompilerGeneratedAttribute]
public void set_ToolsDirectory(string value);
    public virtual bool Execute();
    public sealed virtual void Cancel();
}
public class PostSharp.MSBuild.PostSharpGetDirectory : Task {
    private ITaskItem directory;
    [OutputAttribute]
public ITaskItem Directory { get; public set; }
    public ITaskItem get_Directory();
    public void set_Directory(ITaskItem value);
    public virtual bool Execute();
}
public class PostSharp.MSBuild.PostSharpMoveWithRetry : MoveOrCopyWithRetry {
    internal virtual void Do(string source, string destination);
}
public class PostSharp.MSBuild.PostSharpParseAssemblyNames : Task {
    [CompilerGeneratedAttribute]
private ITaskItem[] <AssemblyNames>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Filter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilterFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <FilteredAssemblyNames>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] AssemblyNames { get; public set; }
    public string Filter { get; public set; }
    [RequiredAttribute]
public string FilterFileName { get; public set; }
    [OutputAttribute]
public ITaskItem[] FilteredAssemblyNames { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem[] get_AssemblyNames();
    [CompilerGeneratedAttribute]
public void set_AssemblyNames(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_Filter();
    [CompilerGeneratedAttribute]
public void set_Filter(string value);
    [CompilerGeneratedAttribute]
public string get_FilterFileName();
    [CompilerGeneratedAttribute]
public void set_FilterFileName(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_FilteredAssemblyNames();
    [CompilerGeneratedAttribute]
public void set_FilteredAssemblyNames(ITaskItem[] value);
    public virtual bool Execute();
}
public class PostSharp.MSBuild.PostSharpParseProjectAssets : Task {
    [CompilerGeneratedAttribute]
private string <AssetsFile>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <OtherReferences>k__BackingField;
    [RequiredAttribute]
public string AssetsFile { get; public set; }
    [OutputAttribute]
public ITaskItem[] OtherReferences { get; private set; }
    [CompilerGeneratedAttribute]
public string get_AssetsFile();
    [CompilerGeneratedAttribute]
public void set_AssetsFile(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_OtherReferences();
    [CompilerGeneratedAttribute]
private void set_OtherReferences(ITaskItem[] value);
    public virtual bool Execute();
}
public class PostSharp.MSBuild.PostSharpProcessFrameworkReferences : Task {
    [CompilerGeneratedAttribute]
private ITaskItem[] <PackagesToDownload>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <KnownFrameworkReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetingPackRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableTargetingPackDownload>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <AdditionalPackagesToDownload>k__BackingField;
    public ITaskItem[] PackagesToDownload { get; public set; }
    public ITaskItem[] KnownFrameworkReferences { get; public set; }
    public string TargetingPackRoot { get; public set; }
    public string TargetFrameworkIdentifier { get; public set; }
    public string TargetFrameworkVersion { get; public set; }
    public bool EnableTargetingPackDownload { get; public set; }
    [OutputAttribute]
public ITaskItem[] AdditionalPackagesToDownload { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem[] get_PackagesToDownload();
    [CompilerGeneratedAttribute]
public void set_PackagesToDownload(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_KnownFrameworkReferences();
    [CompilerGeneratedAttribute]
public void set_KnownFrameworkReferences(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_TargetingPackRoot();
    [CompilerGeneratedAttribute]
public void set_TargetingPackRoot(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkIdentifier();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworkIdentifier(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkVersion();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworkVersion(string value);
    [CompilerGeneratedAttribute]
public bool get_EnableTargetingPackDownload();
    [CompilerGeneratedAttribute]
public void set_EnableTargetingPackDownload(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_AdditionalPackagesToDownload();
    [CompilerGeneratedAttribute]
public void set_AdditionalPackagesToDownload(ITaskItem[] value);
    public virtual bool Execute();
}
public class PostSharp.MSBuild.PostSharpTouchWithDelay : Task {
    private ITaskItem[] files;
    private long delay;
    private ITaskItem referenceFile;
    [RequiredAttribute]
public ITaskItem[] Files { get; public set; }
    public long Delay { get; public set; }
    [RequiredAttribute]
public ITaskItem ReferenceFile { get; public set; }
    public ITaskItem[] get_Files();
    public void set_Files(ITaskItem[] value);
    public long get_Delay();
    public void set_Delay(long value);
    public ITaskItem get_ReferenceFile();
    public void set_ReferenceFile(ITaskItem value);
    public virtual bool Execute();
}
public class PostSharp.MSBuild.PostSharpValidateLanguageVersion : BaseTask {
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LatestSupportedVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VisualStudioVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProgramDataDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EffectiveVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RoslynTargetsPath>k__BackingField;
    private static string versionNotDetectedMessage;
    private static string versionNotSupportedMessage;
    private static string cacheFileRelativePath;
    private static Version version15;
    [RequiredAttribute]
public string Language { get; public set; }
    [RequiredAttribute]
public string LatestSupportedVersion { get; public set; }
    public string CurrentVersion { get; public set; }
    [RequiredAttribute]
public string VisualStudioVersion { get; public set; }
    public string ProgramDataDirectory { get; public set; }
    [OutputAttribute]
public string EffectiveVersion { get; public set; }
    public string RoslynTargetsPath { get; public set; }
    private static PostSharpValidateLanguageVersion();
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public string get_LatestSupportedVersion();
    [CompilerGeneratedAttribute]
public void set_LatestSupportedVersion(string value);
    [CompilerGeneratedAttribute]
public string get_CurrentVersion();
    [CompilerGeneratedAttribute]
public void set_CurrentVersion(string value);
    [CompilerGeneratedAttribute]
public string get_VisualStudioVersion();
    [CompilerGeneratedAttribute]
public void set_VisualStudioVersion(string value);
    [CompilerGeneratedAttribute]
public string get_ProgramDataDirectory();
    [CompilerGeneratedAttribute]
public void set_ProgramDataDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_EffectiveVersion();
    [CompilerGeneratedAttribute]
public void set_EffectiveVersion(string value);
    [CompilerGeneratedAttribute]
public string get_RoslynTargetsPath();
    [CompilerGeneratedAttribute]
public void set_RoslynTargetsPath(string value);
    public virtual bool Execute();
    private VersionInfo ParseLangVersion(string versionString);
    private VersionInfo GetLangVersion(string versionName, Version msBuildToolsVersion);
    private string GetRoslynAssemblyPath(string roslynAssemblyFileName);
    private string GetPathIfFileExists(string path);
    private Assembly LoadAssembly(string assemblyPath);
    private VersionInfo DetectRoslynVersion(string roslynAssemblyPath, string versionName, Version msBuildToolsVersion);
    private VersionInfo ReadVersionFromCache(string roslynAssemblyPath, string versionName);
    private void WriteVersionToCache(string roslynAssemblyPath, string versionName, VersionInfo version);
    private string GetVersionNotDetectedMessage();
}
internal static class PostSharp.MSBuild.ToolInvocationHelper : object {
    public static bool InvokeTool(ILogger logger, string fileName, string commandLine, string workingDirectory, CancellationToken cancellationToken, ValueTuple`2[] environmentVariables);
    public static bool InvokeTool(ILogger logger, string fileName, string commandLine, string workingDirectory, CancellationToken cancellationToken, Int32& exitCode, ValueTuple`2[] environmentVariables);
    public static bool InvokeTool(ILogger logger, string fileName, string commandLine, string workingDirectory, Int32& exitCode, String& output, ValueTuple`2[] environmentVariables);
    private static bool InvokeTool(ILogger logger, string fileName, string commandLine, string workingDirectory, Nullable`1<CancellationToken> cancellationToken, Int32& exitCode, Action`1<string> handleErrorData, Action`1<string> handleOutputData, ValueTuple`2[] environmentVariables);
}
[ExtensionAttribute]
public static class PostSharp.MSBuild.Utils.NuGetExtensions : object {
    [ExtensionAttribute]
public static NuGetFramework StripPlatform(NuGetFramework framework);
    [ExtensionAttribute]
public static NuGetFramework Normalize(NuGetFramework targetFramework);
}
public interface PostSharp.Platform.IContainerDetectionService {
    public abstract virtual bool IsRunningInContainer();
}
public interface PostSharp.Platform.IResourceMonitorService {
    public bool IsGetProcessesUsingFilesSupported { get; }
    public abstract virtual bool get_IsGetProcessesUsingFilesSupported();
    public abstract virtual IList`1<Process> GetProcessesUsingFiles(IList`1<string> filePaths);
}
[ObfuscationAttribute]
public interface PostSharp.Platform.ISystemCancellation {
    public abstract virtual void Cancel();
    public abstract virtual void RegisterHandler(Action action);
}
[ObfuscationAttribute]
public interface PostSharp.Platform.ISystemCancellationProvider {
    public abstract virtual ISystemCancellation Create(string name);
    public abstract virtual ISystemCancellation GetExisting(string name);
}
[ObfuscationAttribute]
public interface PostSharp.Platform.ISystemLock {
    public abstract virtual bool Lock(TimeSpan timeout, CancellationToken cancellationToken);
    public abstract virtual void Unlock();
}
[ObfuscationAttribute]
public interface PostSharp.Platform.ISystemLockProvider {
    public abstract virtual ISystemLock Get(string identifier);
}
[ObfuscationAttribute]
public interface PostSharp.Platform.ISystemSemaphore {
    public abstract virtual bool WaitOne();
    public abstract virtual bool WaitOne(int millisecondsTimeout);
    public abstract virtual int Release();
}
[ObfuscationAttribute]
public interface PostSharp.Platform.ISystemSemaphoreProvider {
    public abstract virtual ISystemSemaphore Get(int initialCount, int maximumCount, string name, Boolean& createdNew);
}
public interface PostSharp.Platform.ISystemService {
}
internal interface PostSharp.Platform.ISystemVersionProvider {
    public string Identifier { get; }
    public Version Version { get; }
    public abstract virtual string get_Identifier();
    public abstract virtual Version get_Version();
}
public static class PostSharp.Platform.NetFramework.NetFrameworkDefaultPlatformServices : object {
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) initialized;
    public static void Initialize();
}
internal class PostSharp.Platform.NetFramework.NetFrameworkSystemSemaphoreProvider : object {
    public sealed virtual ISystemSemaphore Get(int initialCount, int maximumCount, string name, Boolean& createdNew);
    protected virtual Semaphore AccessImpl(int initialCount, int maximumCount, string name, Boolean& createdNew);
    protected static SemaphoreSecurity CreateSemaphoreSecurity();
}
internal class PostSharp.Platform.NetStandard.LinuxInterop : object {
    private static string libpthread;
    public static int RUSAGE_THREAD;
    public static Void* sem_open(string name, int oflag, int mode, UInt32 init_value);
    public static int sem_close(Void* sem);
    public static int sem_wait(Void* sem);
    public static int sem_trywait(Void* sem);
    public static int sem_timedwait(Void* sem, timespec* abs_timeout);
    public static int sem_post(Void* sem);
    public static int sem_getvalue(Void* sem, Int32* sval);
    public static int sem_unlink(string name);
}
internal class PostSharp.Platform.NetStandard.NetStandardDisabledResourceMonitorService : object {
    public bool IsGetProcessesUsingFilesSupported { get; }
    public sealed virtual bool get_IsGetProcessesUsingFilesSupported();
    public sealed virtual IList`1<Process> GetProcessesUsingFiles(IList`1<string> filePaths);
}
internal class PostSharp.Platform.NetStandard.NetStandardDisabledSystemCancellationProvider : object {
    public sealed virtual ISystemCancellation Create(string name);
    public sealed virtual ISystemCancellation GetExisting(string name);
}
internal class PostSharp.Platform.NetStandard.NetStandardDisabledSystemSemaphoreProvider : object {
    public sealed virtual ISystemSemaphore Get(int initialCount, int maximumCount, string name, Boolean& createdNew);
}
internal class PostSharp.Platform.NetStandard.NetStandardMutexLockProvider : object {
    public sealed virtual ISystemLock Get(string identifier);
}
public class PostSharp.Platform.NetStandard.NetStandardOnUnixContainerDetectionService : object {
    public sealed virtual bool IsRunningInContainer();
}
public class PostSharp.Platform.NetStandard.NetStandardOnWindowsContainerDetectionService : object {
    public sealed virtual bool IsRunningInContainer();
}
public class PostSharp.Platform.NetStandard.NetStandardOnWindowsResourceMonitorService : object {
    private static Nullable`1<bool> isGetProcessesUsingFilesSupported;
    private static int RmRebootReasonNone;
    private static int CCH_RM_MAX_APP_NAME;
    private static int CCH_RM_MAX_SVC_NAME;
    public bool IsGetProcessesUsingFilesSupported { get; }
    public sealed virtual bool get_IsGetProcessesUsingFilesSupported();
    [ObfuscationAttribute]
public sealed virtual IList`1<Process> GetProcessesUsingFiles(IList`1<string> filePaths);
    private static int RmStartSession(UInt32& pSessionHandle, int dwSessionFlags, string strSessionKey);
    private static int RmEndSession(UInt32 pSessionHandle);
    private static int RmRegisterResources(UInt32 pSessionHandle, UInt32 nFiles, String[] rgsFilenames, UInt32 nApplications, RM_UNIQUE_PROCESS[] rgApplications, UInt32 nServices, String[] rgsServiceNames);
    private static int RmGetList(UInt32 dwSessionHandle, UInt32& pnProcInfoNeeded, UInt32& pnProcInfo, RM_PROCESS_INFO[] rgAffectedApps, UInt32& lpdwRebootReasons);
}
internal class PostSharp.Platform.NetStandard.NetStandardOnWindowsSystemCancellationProvider : object {
    public sealed virtual ISystemCancellation Create(string name);
    public sealed virtual ISystemCancellation GetExisting(string name);
}
internal class PostSharp.Platform.NetStandard.NetStandardOnWindowsSystemVersionProvider : object {
    private Version version;
    public string Identifier { get; }
    public Version Version { get; }
    public sealed virtual string get_Identifier();
    public sealed virtual Version get_Version();
}
internal class PostSharp.Platform.NetStandard.NetStandardSystemSemaphore : object {
    private Semaphore semaphore;
    public NetStandardSystemSemaphore(Semaphore semaphore);
    public sealed virtual bool WaitOne();
    public sealed virtual bool WaitOne(int millisecondsTimeout);
    public sealed virtual int Release();
    public sealed virtual void Dispose();
}
internal class PostSharp.Platform.NetStandard.OsxInterop : object {
    private static string libpthread;
    private static string libproc;
    public static int MAXTHREADNAMESIZE;
    public static int PROC_PIDTHREADINFO;
    public static Void* sem_open(string name, int oflag, int mode, UInt32 init_value);
    public static int sem_close(Void* sem);
    public static int sem_wait(Void* sem);
    public static int sem_trywait(Void* sem);
    public static int sem_post(Void* sem);
    public static int sem_getvalue(Void* sem, Int32* sval);
    public static int sem_unlink(string name);
    public static int proc_pidinfo(int pid, int flavor, ulong arg, proc_threadinfo* buffer, int bufferSize);
}
internal class PostSharp.Platform.NetStandard.UnixInterop : object {
    private static string libc;
    public static int EINTR;
    public static int EAGAIN;
    public static int EEXIST;
    public static int ETIMEDOUT;
    public static int EWOULDBLOCK;
    public static int O_RDONLY;
    public static int O_WRONLY;
    public static int O_RDWR;
    public static int O_CREAT;
    public static int O_EXCL;
    public static int O_TRUNC;
    public static int S_IRWXU;
    public static int S_IRUSR;
    public static int S_IWUSR;
    public static int S_IXUSR;
    public static int S_IRWXG;
    public static int S_IRGRP;
    public static int S_IWGRP;
    public static int S_IXGRP;
    public static int S_IRWXO;
    public static int S_IROTH;
    public static int S_IWOTH;
    public static int S_IXOTH;
    public static int LOCK_SH;
    public static int LOCK_EX;
    public static int LOCK_NB;
    public static int LOCK_UN;
    public static int open(string pathname, int flags);
    public static int open(string pathname, int flags, int mode);
    public static int close(int fd);
    public static int flock(int fd, int operation);
    public static int getrusage(int who, rusage* usage);
}
public class PostSharp.Platform.SystemLockHandle : object {
    private ISystemLock systemLock;
    public SystemLockHandle(ISystemLock systemLock);
    protected virtual override void Finalize();
    private void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public static class PostSharp.Platform.SystemServiceLocator : object {
    private static Dictionary`2<Type, object> services;
    private static Dictionary`2<Type, object> persistentServices;
    private static SystemServiceLocator();
    public static T GetService(bool required);
    public static bool TryGetService(T& service);
    public static void SetService(T impl, bool persistent);
    public static void RemoveService();
    public static void Reset();
}
public class PostSharp.Platform.SystemServiceNotFoundException : Exception {
    public SystemServiceNotFoundException(Type missingServiceType);
    public SystemServiceNotFoundException(string message);
    public SystemServiceNotFoundException(string message, Exception innerException);
    protected SystemServiceNotFoundException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public static class PostSharp.Platform.Utilities.ArchitectureHelper : object {
    private static Architecture OSArchitecture;
    private static ArchitectureHelper();
    public static Architecture GetOSArchitecture();
    private static Architecture InitializeOSArchitecture();
    [CompilerGeneratedAttribute]
internal static int <InitializeOSArchitecture>g__GetMachineTypeAttributes|2_0(ushort WowGuestMachine, Int32& attributes);
}
internal static class PostSharp.Platform.Utilities.FileSystemHelper : object {
    public static string GetToolsDirectory(string canonicalToolDirectory);
    private static bool IsNetCoreBootstrappingDirectory(string toolDirectory);
    public static string FindDirectoryInPredecessors(string searchedDirectoryPath, string directoryNameToFind);
    public static string FindFileNamePatternInPredecessors(string searchedDirectoryPath, string fileNamePatternToFind);
    public static bool IsLockException(Exception e);
    public static bool IsPathValid(string path, String& errorDescription);
}
internal static class PostSharp.Platform.Utilities.HashHelper : object {
    public static Byte[] GetHash(string str);
    public static Byte[] GetHash(Byte[] bytes);
    public static Byte[] CombineHashes(Byte[] a, Byte[] b);
    public static string GetStringHash(string str);
    public static string FormatHex(Byte[] hash);
    public static string GetIdentifierString(Object[] identifierParts);
}
internal static class PostSharp.Platform.Utilities.HexHelper : object {
    private static Char[] hexChars;
    private static HexHelper();
    public static Byte[] TryParseBytes(string str, int start, int count);
    public static void FormatBytes(Byte[] bytes, StringBuilder builder);
    public static string FormatBytes(Byte[] bytes, string nullString);
}
[ExtensionAttribute]
public static class PostSharp.Platform.Utilities.KeyValuePairExtensions : object {
    [ExtensionAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> kvp, TKey& key, TValue& value);
}
internal class PostSharp.Platform.Utilities.MD5Managed : HashAlgorithm {
    private MD5_CTX _context;
    private Byte[] _digest;
    private bool _hashCoreCalled;
    private bool _hashFinalCalled;
    private static int S11;
    private static int S12;
    private static int S13;
    private static int S14;
    private static int S21;
    private static int S22;
    private static int S23;
    private static int S24;
    private static int S31;
    private static int S32;
    private static int S33;
    private static int S34;
    private static int S41;
    private static int S42;
    private static int S43;
    private static int S44;
    private static Byte[] PADDING;
    public Byte[] Hash { get; }
    public int HashSize { get; }
    private static MD5Managed();
    public virtual void Initialize();
    private void InitializeVariables();
    protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
    public virtual Byte[] get_Hash();
    public virtual int get_HashSize();
    private static UInt32 F(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 G(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 H(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 I(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 ROTATE_LEFT(UInt32 x, int n);
    private static void FF(UInt32& a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, int s, UInt32 ac);
    private static void GG(UInt32& a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, int s, UInt32 ac);
    private static void HH(UInt32& a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, int s, UInt32 ac);
    private static void II(UInt32& a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, int s, UInt32 ac);
    private static void MD5Init(MD5_CTX context);
    private static void MD5Update(MD5_CTX context, Byte[] input, UInt32 inputIndex, UInt32 inputLen);
    private static void MD5Final(Byte[] digest, MD5_CTX context);
    private static void MD5Transform(UInt32[] state, Byte[] block, UInt32 blockIndex);
    private static void Encode(Byte[] output, UInt32[] input, UInt32 len);
    private static void Decode(UInt32[] output, Byte[] input, UInt32 inputIndex, UInt32 len);
}
internal class PostSharp.Platform.Utilities.ProcessInfo : object {
    [CompilerGeneratedAttribute]
private int <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ImagePath>k__BackingField;
    public int ProcessId { get; private set; }
    public string ImagePath { get; private set; }
    public string ProcessName { get; }
    public ProcessInfo(int processId, string imageFileName);
    [CompilerGeneratedAttribute]
public int get_ProcessId();
    [CompilerGeneratedAttribute]
private void set_ProcessId(int value);
    [CompilerGeneratedAttribute]
public string get_ImagePath();
    [CompilerGeneratedAttribute]
private void set_ImagePath(string value);
    public string get_ProcessName();
}
internal static class PostSharp.Platform.Utilities.ProcessUtilities : object {
    private static UInt32 PROCESS_QUERY_INFORMATION;
    private static UInt32 PROCESS_TERMINATE;
    private static int isCurrentProcessUnattended;
    public static bool IsCurrentProcessUnattended { get; public set; }
    private static bool TerminateProcess(IntPtr hProcess, int uExitCode);
    private static IntPtr GetCurrentProcess();
    private static int NtQueryInformationProcess(IntPtr processHandle, int processInformationClass, PROCESS_BASIC_INFORMATION& processInformation, int processInformationLength, Int32& returnLength);
    private static IntPtr OpenProcess(UInt32 dwDesiredAccess, bool bInheritHandle, int dwProcessId);
    private static bool CloseHandle(IntPtr hObject);
    private static int GetProcessImageFileName(IntPtr hProcess, StringBuilder lpImageFileName, int nSize);
    private static bool EnumProcesses(Int32* pProcessIds, int cb, Int32& pBytesReturned);
    private static IntPtr OpenSCManager(StringBuilder lpMachineName, StringBuilder lpDatabaseName, UInt32 dwDesiredAccess);
    private static bool EnumServicesStatus(IntPtr hSCManager, UInt32 dwServiceType, UInt32 dwServiceState, IntPtr lpServices, UInt32 cbBufSize, UInt32* pcbBytesNeeded, UInt32* lpServicesReturned, UInt32* lpResumeHandle);
    public static bool get_IsCurrentProcessUnattended();
    public static void set_IsCurrentProcessUnattended(bool value);
    public static bool DetectUnattendedProcess(String& log);
    public static bool TerminateProcess(int processId);
    public static Int32[] GetAllProcessIds();
    public static string GetProcessName(int processId);
    public static IList`1<ProcessInfo> GetParentProcesses();
}
public static class PostSharp.Platform.Utilities.SystemLockHelper : object {
    public static IDisposable Acquire(string directory, TimeSpan timeout, CancellationToken cancellationToken, Action`2<string, Exception> handleException, Object[] identifierParts);
}
internal class System.Buffers.ArrayPool`1 : object {
    private static int MaxPooledArraySize;
    private <07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>SimplePool`1<T[]> _pool;
    public static ArrayPool`1<T> Shared;
    private static ArrayPool`1();
    public T[] Rent(int minimumLength);
    public void Return(T[] array);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>DeconstructionExtensions : object {
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.<095eee27-c9f8-4608-aee1-977bdb32e1fa>DeconstructionExtensions : object {
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.<76dee5d5-572c-44bd-8e59-41aaed8a29e3>DeconstructionExtensions : object {
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>DeconstructionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.<9f65e429-7a44-41af-85cb-9a867a352998>DeconstructionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.<a8b4d782-62ae-4aef-a59e-d702453e5cda>DeconstructionExtensions : object {
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>DeconstructionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.<cf090466-d32c-4025-b476-cee6b8291f40>DeconstructionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.DeconstructionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public <07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public <07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>MemberNotNullAttribute(string member);
    public <07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public <07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>MemberNotNullWhenAttribute(bool returnValue, string member);
    public <07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public <07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>SetsRequiredMembersAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.<095eee27-c9f8-4608-aee1-977bdb32e1fa>AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.<095eee27-c9f8-4608-aee1-977bdb32e1fa>DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.<095eee27-c9f8-4608-aee1-977bdb32e1fa>DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<095eee27-c9f8-4608-aee1-977bdb32e1fa>DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public <095eee27-c9f8-4608-aee1-977bdb32e1fa>DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.<095eee27-c9f8-4608-aee1-977bdb32e1fa>MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<095eee27-c9f8-4608-aee1-977bdb32e1fa>MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <095eee27-c9f8-4608-aee1-977bdb32e1fa>MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.<095eee27-c9f8-4608-aee1-977bdb32e1fa>MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public <095eee27-c9f8-4608-aee1-977bdb32e1fa>MemberNotNullAttribute(string member);
    public <095eee27-c9f8-4608-aee1-977bdb32e1fa>MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.<095eee27-c9f8-4608-aee1-977bdb32e1fa>MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public <095eee27-c9f8-4608-aee1-977bdb32e1fa>MemberNotNullWhenAttribute(bool returnValue, string member);
    public <095eee27-c9f8-4608-aee1-977bdb32e1fa>MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.<095eee27-c9f8-4608-aee1-977bdb32e1fa>NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.<095eee27-c9f8-4608-aee1-977bdb32e1fa>NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public <095eee27-c9f8-4608-aee1-977bdb32e1fa>NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<095eee27-c9f8-4608-aee1-977bdb32e1fa>NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <095eee27-c9f8-4608-aee1-977bdb32e1fa>NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.<095eee27-c9f8-4608-aee1-977bdb32e1fa>SetsRequiredMembersAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.<76dee5d5-572c-44bd-8e59-41aaed8a29e3>AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.<76dee5d5-572c-44bd-8e59-41aaed8a29e3>DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.<76dee5d5-572c-44bd-8e59-41aaed8a29e3>DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<76dee5d5-572c-44bd-8e59-41aaed8a29e3>DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public <76dee5d5-572c-44bd-8e59-41aaed8a29e3>DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.<76dee5d5-572c-44bd-8e59-41aaed8a29e3>MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<76dee5d5-572c-44bd-8e59-41aaed8a29e3>MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <76dee5d5-572c-44bd-8e59-41aaed8a29e3>MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.<76dee5d5-572c-44bd-8e59-41aaed8a29e3>MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public <76dee5d5-572c-44bd-8e59-41aaed8a29e3>MemberNotNullAttribute(string member);
    public <76dee5d5-572c-44bd-8e59-41aaed8a29e3>MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.<76dee5d5-572c-44bd-8e59-41aaed8a29e3>MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public <76dee5d5-572c-44bd-8e59-41aaed8a29e3>MemberNotNullWhenAttribute(bool returnValue, string member);
    public <76dee5d5-572c-44bd-8e59-41aaed8a29e3>MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.<76dee5d5-572c-44bd-8e59-41aaed8a29e3>NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.<76dee5d5-572c-44bd-8e59-41aaed8a29e3>NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public <76dee5d5-572c-44bd-8e59-41aaed8a29e3>NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<76dee5d5-572c-44bd-8e59-41aaed8a29e3>NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <76dee5d5-572c-44bd-8e59-41aaed8a29e3>NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.<76dee5d5-572c-44bd-8e59-41aaed8a29e3>SetsRequiredMembersAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public <9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public <9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>MemberNotNullAttribute(string member);
    public <9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public <9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>MemberNotNullWhenAttribute(bool returnValue, string member);
    public <9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public <9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>SetsRequiredMembersAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.<9f65e429-7a44-41af-85cb-9a867a352998>AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.<9f65e429-7a44-41af-85cb-9a867a352998>DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.<9f65e429-7a44-41af-85cb-9a867a352998>DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<9f65e429-7a44-41af-85cb-9a867a352998>DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public <9f65e429-7a44-41af-85cb-9a867a352998>DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.<9f65e429-7a44-41af-85cb-9a867a352998>MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<9f65e429-7a44-41af-85cb-9a867a352998>MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <9f65e429-7a44-41af-85cb-9a867a352998>MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.<9f65e429-7a44-41af-85cb-9a867a352998>MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public <9f65e429-7a44-41af-85cb-9a867a352998>MemberNotNullAttribute(string member);
    public <9f65e429-7a44-41af-85cb-9a867a352998>MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.<9f65e429-7a44-41af-85cb-9a867a352998>MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public <9f65e429-7a44-41af-85cb-9a867a352998>MemberNotNullWhenAttribute(bool returnValue, string member);
    public <9f65e429-7a44-41af-85cb-9a867a352998>MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.<9f65e429-7a44-41af-85cb-9a867a352998>NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.<9f65e429-7a44-41af-85cb-9a867a352998>NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public <9f65e429-7a44-41af-85cb-9a867a352998>NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<9f65e429-7a44-41af-85cb-9a867a352998>NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <9f65e429-7a44-41af-85cb-9a867a352998>NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.<9f65e429-7a44-41af-85cb-9a867a352998>SetsRequiredMembersAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.<a8b4d782-62ae-4aef-a59e-d702453e5cda>AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.<a8b4d782-62ae-4aef-a59e-d702453e5cda>DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.<a8b4d782-62ae-4aef-a59e-d702453e5cda>DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<a8b4d782-62ae-4aef-a59e-d702453e5cda>DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public <a8b4d782-62ae-4aef-a59e-d702453e5cda>DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.<a8b4d782-62ae-4aef-a59e-d702453e5cda>MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<a8b4d782-62ae-4aef-a59e-d702453e5cda>MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <a8b4d782-62ae-4aef-a59e-d702453e5cda>MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.<a8b4d782-62ae-4aef-a59e-d702453e5cda>MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public <a8b4d782-62ae-4aef-a59e-d702453e5cda>MemberNotNullAttribute(string member);
    public <a8b4d782-62ae-4aef-a59e-d702453e5cda>MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.<a8b4d782-62ae-4aef-a59e-d702453e5cda>MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public <a8b4d782-62ae-4aef-a59e-d702453e5cda>MemberNotNullWhenAttribute(bool returnValue, string member);
    public <a8b4d782-62ae-4aef-a59e-d702453e5cda>MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.<a8b4d782-62ae-4aef-a59e-d702453e5cda>NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.<a8b4d782-62ae-4aef-a59e-d702453e5cda>NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public <a8b4d782-62ae-4aef-a59e-d702453e5cda>NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<a8b4d782-62ae-4aef-a59e-d702453e5cda>NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <a8b4d782-62ae-4aef-a59e-d702453e5cda>NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.<a8b4d782-62ae-4aef-a59e-d702453e5cda>SetsRequiredMembersAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public <b3265425-ee30-40bd-8eb8-b1f3195bfa4b>DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <b3265425-ee30-40bd-8eb8-b1f3195bfa4b>MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public <b3265425-ee30-40bd-8eb8-b1f3195bfa4b>MemberNotNullAttribute(string member);
    public <b3265425-ee30-40bd-8eb8-b1f3195bfa4b>MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public <b3265425-ee30-40bd-8eb8-b1f3195bfa4b>MemberNotNullWhenAttribute(bool returnValue, string member);
    public <b3265425-ee30-40bd-8eb8-b1f3195bfa4b>MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public <b3265425-ee30-40bd-8eb8-b1f3195bfa4b>NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <b3265425-ee30-40bd-8eb8-b1f3195bfa4b>NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>SetsRequiredMembersAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.<cf090466-d32c-4025-b476-cee6b8291f40>AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.<cf090466-d32c-4025-b476-cee6b8291f40>DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.<cf090466-d32c-4025-b476-cee6b8291f40>DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<cf090466-d32c-4025-b476-cee6b8291f40>DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public <cf090466-d32c-4025-b476-cee6b8291f40>DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.<cf090466-d32c-4025-b476-cee6b8291f40>MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<cf090466-d32c-4025-b476-cee6b8291f40>MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <cf090466-d32c-4025-b476-cee6b8291f40>MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.<cf090466-d32c-4025-b476-cee6b8291f40>MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public <cf090466-d32c-4025-b476-cee6b8291f40>MemberNotNullAttribute(string member);
    public <cf090466-d32c-4025-b476-cee6b8291f40>MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.<cf090466-d32c-4025-b476-cee6b8291f40>MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public <cf090466-d32c-4025-b476-cee6b8291f40>MemberNotNullWhenAttribute(bool returnValue, string member);
    public <cf090466-d32c-4025-b476-cee6b8291f40>MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.<cf090466-d32c-4025-b476-cee6b8291f40>NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.<cf090466-d32c-4025-b476-cee6b8291f40>NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public <cf090466-d32c-4025-b476-cee6b8291f40>NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<cf090466-d32c-4025-b476-cee6b8291f40>NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <cf090466-d32c-4025-b476-cee6b8291f40>NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.<cf090466-d32c-4025-b476-cee6b8291f40>SetsRequiredMembersAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.<dd21e087-47d9-4bce-bed8-b56112226337>AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<dd21e087-47d9-4bce-bed8-b56112226337>DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public <dd21e087-47d9-4bce-bed8-b56112226337>DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.<dd21e087-47d9-4bce-bed8-b56112226337>MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("10688")]
internal class System.Diagnostics.CodeAnalysis.<dd21e087-47d9-4bce-bed8-b56112226337>NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.<dd21e087-47d9-4bce-bed8-b56112226337>NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public <dd21e087-47d9-4bce-bed8-b56112226337>NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public <07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>IsExternalInit) set_IsOptional(bool value);
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>IsExternalInit : object {
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
internal class System.Runtime.CompilerServices.<07a2283b-d5d1-48d6-b9ff-3b736edcbe8d>RequiredMemberAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.<095eee27-c9f8-4608-aee1-977bdb32e1fa>CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public <095eee27-c9f8-4608-aee1-977bdb32e1fa>CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<095eee27-c9f8-4608-aee1-977bdb32e1fa>IsExternalInit) set_IsOptional(bool value);
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.<095eee27-c9f8-4608-aee1-977bdb32e1fa>IsExternalInit : object {
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
internal class System.Runtime.CompilerServices.<095eee27-c9f8-4608-aee1-977bdb32e1fa>RequiredMemberAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.<76dee5d5-572c-44bd-8e59-41aaed8a29e3>CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public <76dee5d5-572c-44bd-8e59-41aaed8a29e3>CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<76dee5d5-572c-44bd-8e59-41aaed8a29e3>IsExternalInit) set_IsOptional(bool value);
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.<76dee5d5-572c-44bd-8e59-41aaed8a29e3>IsExternalInit : object {
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
internal class System.Runtime.CompilerServices.<76dee5d5-572c-44bd-8e59-41aaed8a29e3>RequiredMemberAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public <9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>IsExternalInit) set_IsOptional(bool value);
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>IsExternalInit : object {
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
internal class System.Runtime.CompilerServices.<9c17b6a9-1d4a-46dd-b7e9-fa2c5d3c1a54>RequiredMemberAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.<9f65e429-7a44-41af-85cb-9a867a352998>CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public <9f65e429-7a44-41af-85cb-9a867a352998>CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<9f65e429-7a44-41af-85cb-9a867a352998>IsExternalInit) set_IsOptional(bool value);
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.<9f65e429-7a44-41af-85cb-9a867a352998>IsExternalInit : object {
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
internal class System.Runtime.CompilerServices.<9f65e429-7a44-41af-85cb-9a867a352998>RequiredMemberAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.<a8b4d782-62ae-4aef-a59e-d702453e5cda>CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public <a8b4d782-62ae-4aef-a59e-d702453e5cda>CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<a8b4d782-62ae-4aef-a59e-d702453e5cda>IsExternalInit) set_IsOptional(bool value);
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.<a8b4d782-62ae-4aef-a59e-d702453e5cda>IsExternalInit : object {
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
internal class System.Runtime.CompilerServices.<a8b4d782-62ae-4aef-a59e-d702453e5cda>RequiredMemberAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public <b3265425-ee30-40bd-8eb8-b1f3195bfa4b>CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>IsExternalInit) set_IsOptional(bool value);
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>IsExternalInit : object {
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
internal class System.Runtime.CompilerServices.<b3265425-ee30-40bd-8eb8-b1f3195bfa4b>RequiredMemberAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.<cf090466-d32c-4025-b476-cee6b8291f40>CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public <cf090466-d32c-4025-b476-cee6b8291f40>CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<cf090466-d32c-4025-b476-cee6b8291f40>IsExternalInit) set_IsOptional(bool value);
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.<cf090466-d32c-4025-b476-cee6b8291f40>IsExternalInit : object {
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
internal class System.Runtime.CompilerServices.<cf090466-d32c-4025-b476-cee6b8291f40>RequiredMemberAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsOptional(bool value);
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
internal class System.Runtime.CompilerServices.RequiredMemberAttribute : Attribute {
}
