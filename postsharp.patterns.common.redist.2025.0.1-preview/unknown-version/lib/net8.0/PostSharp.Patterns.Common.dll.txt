[AttributeUsageAttribute("32767")]
[ExplicitCrossPackageInternalAttribute]
internal class PostSharp.ExplicitCrossPackageInternalAttribute : Attribute {
}
public class PostSharp.Patterns.AssertionFailedException : Exception {
    public AssertionFailedException(string message);
    public AssertionFailedException(string message, Exception inner);
    private AssertionFailedException(SerializationInfo info, StreamingContext context);
}
public abstract class PostSharp.Patterns.Collections.Advices.CollectionDynamicAdvice`1 : DynamicAdvice {
    [CompilerGeneratedAttribute]
private AdvisableCollection`1<T> <Collection>k__BackingField;
    protected AdvisableCollection`1<T> Collection { get; private set; }
    protected CollectionDynamicAdvice`1(IQueryInterface parent);
    [CompilerGeneratedAttribute]
protected AdvisableCollection`1<T> get_Collection();
    [CompilerGeneratedAttribute]
private void set_Collection(AdvisableCollection`1<T> value);
    public virtual void InsertItem(int index, T item, AdviceEnumerator`1<ICollectionDynamicAdvice`1<T>> nextAdvices);
    public virtual void RemoveItem(int index, T item, AdviceEnumerator`1<ICollectionDynamicAdvice`1<T>> nextAdvices);
    public virtual void SetItem(int index, T item, T oldItem, AdviceEnumerator`1<ICollectionDynamicAdvice`1<T>> nextAdvices);
    public virtual void ClearItems(AdviceEnumerator`1<ICollectionDynamicAdvice`1<T>> nextAdvices);
    public virtual T[] ToArray(AdviceEnumerator`1<ICollectionDynamicAdvice`1<T>> nextAdvices);
    public virtual void MoveItem(T item, int oldIndex, int newIndex, AdviceEnumerator`1<ICollectionDynamicAdvice`1<T>> nextAdvices);
    public virtual void InsertMany(int index, T[] itemsToAdd, AdviceEnumerator`1<ICollectionDynamicAdvice`1<T>> nextAdvices);
    public virtual void RemoveMany(int index, T[] itemsToRemove, AdviceEnumerator`1<ICollectionDynamicAdvice`1<T>> nextAdvices);
    public virtual bool IsReadOnly(AdviceEnumerator`1<ICollectionDynamicAdviceBase> nextAdvices);
    public virtual bool IsSynchronized(AdviceEnumerator`1<ICollectionDynamicAdviceBase> nextAdvices);
}
public abstract class PostSharp.Patterns.Collections.Advices.DictionaryDynamicAdvice`2 : DynamicAdvice {
    [CompilerGeneratedAttribute]
private AdvisableDictionary`2<TKey, TValue> <Dictionary>k__BackingField;
    protected AdvisableDictionary`2<TKey, TValue> Dictionary { get; private set; }
    protected DictionaryDynamicAdvice`2(IQueryInterface parent);
    [CompilerGeneratedAttribute]
protected AdvisableDictionary`2<TKey, TValue> get_Dictionary();
    [CompilerGeneratedAttribute]
private void set_Dictionary(AdvisableDictionary`2<TKey, TValue> value);
    public virtual void AddItem(TKey key, TValue value, AdviceEnumerator`1<IDictionaryDynamicAdvice`2<TKey, TValue>> nextAdvices);
    public virtual void RemoveItem(TKey key, TValue value, AdviceEnumerator`1<IDictionaryDynamicAdvice`2<TKey, TValue>> nextAdvices);
    public virtual void SetItem(TKey key, TValue value, TValue oldValue, AdviceEnumerator`1<IDictionaryDynamicAdvice`2<TKey, TValue>> nextAdvices);
    public virtual void ClearItems(AdviceEnumerator`1<IDictionaryDynamicAdvice`2<TKey, TValue>> nextAdvices);
    public sealed virtual KeyValuePair`2[] ToArray(AdviceEnumerator`1<IDictionaryDynamicAdvice`2<TKey, TValue>> nextAdvices);
    public virtual bool IsReadOnly(AdviceEnumerator`1<ICollectionDynamicAdviceBase> nextAdvices);
    public virtual bool IsSynchronized(AdviceEnumerator`1<ICollectionDynamicAdviceBase> nextAdvices);
}
public abstract class PostSharp.Patterns.Collections.Advices.HashSetDynamicAdvice`1 : DynamicAdvice {
    [CompilerGeneratedAttribute]
private AdvisableHashSet`1<T> <Set>k__BackingField;
    protected AdvisableHashSet`1<T> Set { get; private set; }
    protected HashSetDynamicAdvice`1(IQueryInterface parent);
    [CompilerGeneratedAttribute]
protected AdvisableHashSet`1<T> get_Set();
    [CompilerGeneratedAttribute]
private void set_Set(AdvisableHashSet`1<T> value);
    public virtual void AddItem(T item, AdviceEnumerator`1<IHashSetDynamicAdvice`1<T>> nextAdvices);
    public virtual void RemoveItem(T item, AdviceEnumerator`1<IHashSetDynamicAdvice`1<T>> nextAdvices);
    public virtual void ClearItems(AdviceEnumerator`1<IHashSetDynamicAdvice`1<T>> nextAdvices);
    public virtual void ChangeMany(AdviceEnumerator`1<IHashSetDynamicAdvice`1<T>> nextAdvices, IList`1<T> itemsToAdd, IList`1<T> itemsToRemove);
    public virtual T[] ToArray(AdviceEnumerator`1<IHashSetDynamicAdvice`1<T>> nextAdvices);
    public virtual bool IsReadOnly(AdviceEnumerator`1<ICollectionDynamicAdviceBase> nextAdvices);
    public virtual bool IsSynchronized(AdviceEnumerator`1<ICollectionDynamicAdviceBase> nextAdvices);
}
public interface PostSharp.Patterns.Collections.Advices.ICollectionDynamicAdvice`1 {
    public abstract virtual void InsertItem(int index, T item, AdviceEnumerator`1<ICollectionDynamicAdvice`1<T>> nextAdvices);
    public abstract virtual void RemoveItem(int index, T item, AdviceEnumerator`1<ICollectionDynamicAdvice`1<T>> nextAdvices);
    public abstract virtual void SetItem(int index, T item, T oldItem, AdviceEnumerator`1<ICollectionDynamicAdvice`1<T>> nextAdvices);
    public abstract virtual void ClearItems(AdviceEnumerator`1<ICollectionDynamicAdvice`1<T>> nextAdvices);
    public abstract virtual T[] ToArray(AdviceEnumerator`1<ICollectionDynamicAdvice`1<T>> nextAdvices);
    public abstract virtual void MoveItem(T item, int oldIndex, int newIndex, AdviceEnumerator`1<ICollectionDynamicAdvice`1<T>> nextAdvices);
    public abstract virtual void InsertMany(int index, T[] itemsToAdd, AdviceEnumerator`1<ICollectionDynamicAdvice`1<T>> nextAdvices);
    public abstract virtual void RemoveMany(int index, T[] itemsToRemove, AdviceEnumerator`1<ICollectionDynamicAdvice`1<T>> nextAdvices);
}
public interface PostSharp.Patterns.Collections.Advices.ICollectionDynamicAdviceBase {
    public abstract virtual bool IsReadOnly(AdviceEnumerator`1<ICollectionDynamicAdviceBase> nextAdvices);
    public abstract virtual bool IsSynchronized(AdviceEnumerator`1<ICollectionDynamicAdviceBase> nextAdvices);
}
public interface PostSharp.Patterns.Collections.Advices.ICollectionDynamicAdviceFactory`1 {
    public abstract virtual IDynamicAdvice Create(IDynamicallyAdvisableCollection collection, TPayload payload);
}
public interface PostSharp.Patterns.Collections.Advices.IDictionaryDynamicAdvice`2 {
    public abstract virtual void AddItem(TKey key, TValue value, AdviceEnumerator`1<IDictionaryDynamicAdvice`2<TKey, TValue>> nextAdvices);
    public abstract virtual void SetItem(TKey key, TValue value, TValue oldValue, AdviceEnumerator`1<IDictionaryDynamicAdvice`2<TKey, TValue>> nextAdvices);
    public abstract virtual void RemoveItem(TKey key, TValue value, AdviceEnumerator`1<IDictionaryDynamicAdvice`2<TKey, TValue>> nextAdvices);
    public abstract virtual void ClearItems(AdviceEnumerator`1<IDictionaryDynamicAdvice`2<TKey, TValue>> nextAdvices);
    public abstract virtual KeyValuePair`2[] ToArray(AdviceEnumerator`1<IDictionaryDynamicAdvice`2<TKey, TValue>> nextAdvices);
}
public interface PostSharp.Patterns.Collections.Advices.IDictionaryDynamicAdviceFactory`1 {
    public abstract virtual IDynamicAdvice Create(IDynamicallyAdvisableDictionary dictionary, TPayload payload);
}
public interface PostSharp.Patterns.Collections.Advices.IDynamicallyAdvisableCollection {
    public Type ItemType { get; }
    public abstract virtual Type get_ItemType();
}
public interface PostSharp.Patterns.Collections.Advices.IDynamicallyAdvisableDictionary {
    public Type KeyType { get; }
    public Type ValueType { get; }
    public abstract virtual Type get_KeyType();
    public abstract virtual Type get_ValueType();
}
public interface PostSharp.Patterns.Collections.Advices.IDynamicallyAdvisableHashSet {
    public Type ItemType { get; }
    public abstract virtual Type get_ItemType();
}
public interface PostSharp.Patterns.Collections.Advices.IHashSetDynamicAdvice`1 {
    public abstract virtual void AddItem(T item, AdviceEnumerator`1<IHashSetDynamicAdvice`1<T>> nextAdvices);
    public abstract virtual void RemoveItem(T item, AdviceEnumerator`1<IHashSetDynamicAdvice`1<T>> nextAdvices);
    public abstract virtual void ClearItems(AdviceEnumerator`1<IHashSetDynamicAdvice`1<T>> nextAdvices);
    public abstract virtual void ChangeMany(AdviceEnumerator`1<IHashSetDynamicAdvice`1<T>> nextAdvices, IList`1<T> itemsToAdd, IList`1<T> itemsToRemove);
    public abstract virtual T[] ToArray(AdviceEnumerator`1<IHashSetDynamicAdvice`1<T>> nextAdvices);
}
public interface PostSharp.Patterns.Collections.Advices.IHashSetDynamicAdviceFactory`1 {
    public abstract virtual IDynamicAdvice Create(IDynamicallyAdvisableHashSet hashSet, TPayload payload);
}
[DefaultMemberAttribute("Item")]
public class PostSharp.Patterns.Collections.AdvisableCollection`1 : DynamicallyAdvisableObject {
    private Storage<T> items;
    private object syncRoot;
    private PortableSpinLock eventLock;
    private ChangedProperties<T> changedProperties;
    private StructList`1<NotifyCollectionChangedEventArgs> collectionChanges;
    private bool raisingEvents;
    private PropertyChangedEventHandler propertyChangedHandlers;
    private NotifyCollectionChangedEventHandler collectionChangedHandlers;
    private object System.Collections.IList.Item { get; private set; }
    public int Count { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    public T Item { get; public set; }
    private Type PostSharp.Patterns.Collections.Advices.IDynamicallyAdvisableCollection.ItemType { get; }
    public AdvisableCollection`1(int capacity);
    public AdvisableCollection`1(IEnumerable`1<T> items);
    protected AdvisableCollection`1(SerializationInfo info, StreamingContext context);
    protected AdviceEnumerator`1<ICollectionDynamicAdvice`1<T>> GetAdviceEnumerator();
    protected virtual void InsertItem(int index, T item);
    protected virtual void InsertItems(int index, T[] collection);
    protected virtual void RemoveItem(int index);
    protected virtual T[] RemoveItems(int index, int count);
    protected T GetItem(int index);
    protected int GetCount();
    protected virtual void SetItem(int index, T item);
    protected virtual void MoveItem(T item, int oldIndex, int newIndex);
    protected virtual void ClearItems();
    protected virtual int IndexOfItem(T item);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Enumerator<T> GetEnumerator();
    public sealed virtual void Add(T item);
    public void AddRange(IEnumerable`1<T> collection);
    public void Move(int oldIndex, int newIndex);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    public sealed virtual void Clear();
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public T[] ToArray();
    internal ArrayEnumerator`1<T> GetSnapshotEnumerator();
    public sealed virtual bool Remove(T item);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public void InsertRange(int index, IEnumerable`1<T> collection);
    private void CheckEventsNotRaising();
    [ExplicitCrossPackageInternalAttribute]
protected internal void RaiseEvents();
    public sealed virtual void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    public List`1<T> GetRange(int index, int count);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private sealed virtual override Type PostSharp.Patterns.Collections.Advices.IDynamicallyAdvisableCollection.get_ItemType();
    public virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private void OnCollectionChanged(NotifyCollectionChangedAction action, object item, int index);
    private void OnCollectionChanged(NotifyCollectionChangedAction action, object item, int index, int oldIndex);
    private void OnCollectionChanged(NotifyCollectionChangedAction action, object oldItem, object newItem, int index);
    private void OnCollectionChanged(NotifyCollectionChangedAction action, IList changedItems, int startingIndex);
    private void OnCollectionReset();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void OnDeserialization(object sender);
    internal virtual void OnDeserialization(object sender, SerializationInfo info);
}
[DefaultMemberAttribute("Item")]
public class PostSharp.Patterns.Collections.AdvisableDictionary`2 : DynamicallyAdvisableObject {
    private Storage<TKey, TValue> innerDictionary;
    private object syncRoot;
    private KeyCollection<TKey, TValue> keys;
    private ValueCollection<TKey, TValue> values;
    private Type PostSharp.Patterns.Collections.Advices.IDynamicallyAdvisableDictionary.KeyType { get; }
    private Type PostSharp.Patterns.Collections.Advices.IDynamicallyAdvisableDictionary.ValueType { get; }
    public TValue Item { get; public set; }
    public KeyCollection<TKey, TValue> Keys { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public AdvisableDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public AdvisableDictionary`2(IEqualityComparer`1<TKey> comparer);
    public AdvisableDictionary`2(int capacity);
    public AdvisableDictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public AdvisableDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    protected AdvisableDictionary`2(SerializationInfo info, StreamingContext context);
    private void SetStorage(Storage<TKey, TValue> storage);
    protected AdviceEnumerator`1<IDictionaryDynamicAdvice`2<TKey, TValue>> GetAdviceEnumerator();
    protected virtual void AddItem(TKey key, TValue value);
    protected virtual void SetItem(TKey key, TValue value, TValue oldValue);
    protected virtual bool RemoveItem(TKey key);
    protected virtual void ClearItems();
    private sealed virtual override Type PostSharp.Patterns.Collections.Advices.IDynamicallyAdvisableDictionary.get_KeyType();
    private sealed virtual override Type PostSharp.Patterns.Collections.Advices.IDynamicallyAdvisableDictionary.get_ValueType();
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public KeyCollection<TKey, TValue> get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private static bool IsCompatibleKey(object key);
    private static void IfNullAndNullsAreIllegalThenThrow(object value, string argName);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual int get_Count();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    internal KeyValuePair`2[] ToKeyValueArray();
    internal ArrayEnumerator`1<KeyValuePair`2<TKey, TValue>> GetSnapshotEnumerator();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void OnDeserialization(object sender);
    private void OnDeserialization(object sender, SerializationInfo info);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Enumerator<TKey, TValue> GetEnumerator();
    [CompilerGeneratedAttribute]
private KeyCollection<TKey, TValue> <get_Keys>b__36_0();
    [CompilerGeneratedAttribute]
private ValueCollection<TKey, TValue> <get_Values>b__38_0();
}
public class PostSharp.Patterns.Collections.AdvisableHashSet`1 : DynamicallyAdvisableObject {
    private Storage<T> items;
    private object syncRoot;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public IEqualityComparer`1<T> Comparer { get; }
    private Type PostSharp.Patterns.Collections.Advices.IDynamicallyAdvisableHashSet.ItemType { get; }
    public AdvisableHashSet`1(IEnumerable`1<T> collection);
    public AdvisableHashSet`1(IEqualityComparer`1<T> comparer);
    public AdvisableHashSet`1(IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer);
    protected AdvisableHashSet`1(SerializationInfo info, StreamingContext context);
    protected AdviceEnumerator`1<IHashSetDynamicAdvice`1<T>> GetAdviceEnumerator();
    protected virtual void AddItem(T item);
    protected virtual void RemoveItem(T item);
    protected virtual void ClearItems();
    protected virtual void ChangeManyItems(IList`1<T> itemsToAdd, IList`1<T> itemsToRemove);
    private T[] ToArray();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    public sealed virtual bool Add(T item);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public void CopyTo(T[] array);
    public void CopyTo(T[] array, int arrayIndex, int count);
    public int RemoveWhere(Predicate`1<T> match);
    public void TrimExcess();
    public IEqualityComparer`1<T> get_Comparer();
    public static IEqualityComparer`1<AdvisableHashSet`1<T>> CreateSetComparer();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Enumerator<T> GetEnumerator();
    internal ArrayEnumerator`1<T> GetSnapshotEnumerator();
    private sealed virtual override Type PostSharp.Patterns.Collections.Advices.IDynamicallyAdvisableHashSet.get_ItemType();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void OnDeserialization(object sender);
    private void OnDeserialization(object sender, SerializationInfo info);
}
[DefaultMemberAttribute("Item")]
public abstract class PostSharp.Patterns.Collections.AdvisableKeyedCollection`2 : AdvisableCollection`1<TItem> {
    private Dictionary`2<TKey, DictionaryItem<TKey, TItem>> dictionary;
    private static string duplicateKeyMessage;
    private static string keyNotFoundMessage;
    private static string invalidKeyMessage;
    [CompilerGeneratedAttribute]
private IEqualityComparer`1<TKey> <Comparer>k__BackingField;
    protected IEqualityComparer`1<TKey> Comparer { get; private set; }
    public TItem Item { get; public set; }
    protected AdvisableKeyedCollection`2(int capacity);
    protected AdvisableKeyedCollection`2(int capacity, IEqualityComparer`1<TKey> comparer);
    protected AdvisableKeyedCollection`2(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal virtual void OnDeserialization(object sender, SerializationInfo info);
    protected abstract virtual TKey GetKeyForItem(TItem item);
    [CompilerGeneratedAttribute]
protected IEqualityComparer`1<TKey> get_Comparer();
    [CompilerGeneratedAttribute]
private void set_Comparer(IEqualityComparer`1<TKey> value);
    protected virtual int IndexOfItem(TItem item);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, TItem item);
    protected virtual void InsertItems(int index, TItem[] collection);
    private void FixIndexes(int index, int increment);
    protected virtual void RemoveItem(int index);
    protected virtual TItem[] RemoveItems(int index, int count);
    protected virtual void SetItem(int index, TItem item);
    protected virtual void MoveItem(TItem item, int oldIndex, int newIndex);
    public bool Contains(TKey item);
    public TItem get_Item(TKey key);
    public void set_Item(TKey key, TItem value);
    public bool TryGetValue(TKey key, TItem& item);
    private void AddDictionaryItem(int index, TItem item, TKey key);
}
internal class PostSharp.Patterns.Collections.ArrayEnumerator`1 : ValueType {
    private T[] array;
    private int currentIndex;
    public bool IsEmpty { get; }
    public T Current { get; }
    public ArrayEnumerator`1(T[] array);
    public bool get_IsEmpty();
    public T get_Current();
    public bool MoveNext();
    public void Reset();
}
internal static class PostSharp.Patterns.Collections.ExceptionMessages : object {
    internal static string Arg_WrongType;
    internal static string Arg_RankMultiDimNotSupported;
    internal static string Arg_NonZeroLowerBound;
    internal static string EnumeratorAccessedFromInvalidThread;
    internal static string CollectionModified;
    internal static string DictionaryModified;
}
[ExtensionAttribute]
public static class PostSharp.Patterns.Collections.Extensions : object {
    [ExtensionAttribute]
public static AdvisableCollection`1<T> ToAdvisableCollection(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static AdvisableHashSet`1<T> ToAdvisableHashSet(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static AdvisableDictionary`2<TKey, TValue> ToAdvisableDictionary(IDictionary`2<TKey, TValue> dictionary);
    [ExtensionAttribute]
public static AdvisableDictionary`2<TKey, TValue> ToAdvisableDictionary(IEnumerable`1<TItem> collection, Func`2<TItem, TKey> getKeyFunc, Func`2<TItem, TValue> getValueFunc);
}
[ExplicitCrossPackageInternalAttribute]
internal class PostSharp.Patterns.Collections.IdentityComparer`1 : object {
    public static IdentityComparer`1<T> Instance;
    private static IdentityComparer`1();
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class PostSharp.Patterns.Collections.ReadOnlyArray`1 : ValueType {
    private T[] array;
    public bool IsNull { get; }
    public T Item { get; }
    public int Length { get; }
    public ReadOnlyArray`1(T[] array);
    public bool get_IsNull();
    public T get_Item(int index);
    public int get_Length();
    public sealed virtual bool Equals(ReadOnlyArray`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ReadOnlyArray`1<T> left, ReadOnlyArray`1<T> right);
    public static bool op_Inequality(ReadOnlyArray`1<T> left, ReadOnlyArray`1<T> right);
}
[DefaultMemberAttribute("Item")]
internal class PostSharp.Patterns.Collections.StructList`1 : ValueType {
    private int size;
    private T[] array;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public T Item { get; public set; }
    private void Resize(int newSize);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override int System.Collections.Generic.IList<T>.IndexOf(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
}
[ExplicitCrossPackageInternalAttribute]
internal class PostSharp.Patterns.Collections.WeakHashSet`1 : object {
    private AwaitableReaderWriterLock lock;
    private Dictionary`2<int, List`1<WeakReference>> dictionary;
    private bool hasCollector;
    private bool requiresCompact;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; private set; }
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public bool Add(T item);
    public bool Remove(T item);
    public bool Contains(T item);
    public void Compact();
    public void ForEach(Action`1<T> action);
}
public static class PostSharp.Patterns.Common.Utilities.FieldValueComparer : object {
    public static bool AreEqual(bool isValueType, T currentValue, T newValue);
    public static bool AreEqual(T currentValue, T newValue);
}
[ExplicitCrossPackageInternalAttribute]
internal static class PostSharp.Patterns.CommonMessageSource : object {
    public static MessageSource Instance;
    private static CommonMessageSource();
}
public abstract class PostSharp.Patterns.Contracts.ContractExceptionFactory : object {
    private ContractExceptionFactory next;
    protected ContractExceptionFactory(ContractExceptionFactory next);
    public virtual Exception CreateException(ContractExceptionInfo exceptionInfo);
}
public class PostSharp.Patterns.Contracts.ContractExceptionInfo : object {
    [CompilerGeneratedAttribute]
private Type <ExceptionType>k__BackingField;
    [CompilerGeneratedAttribute]
private LocationContractAttribute <Aspect>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationName>k__BackingField;
    [CompilerGeneratedAttribute]
private LocationKind <LocationKind>k__BackingField;
    [CompilerGeneratedAttribute]
private LocationValidationContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <MessageArguments>k__BackingField;
    public Type ExceptionType { get; }
    public LocationContractAttribute Aspect { get; }
    public object Value { get; }
    public string LocationName { get; }
    public LocationKind LocationKind { get; }
    public LocationValidationContext Context { get; }
    public string MessageId { get; }
    public Object[] MessageArguments { get; }
    public ContractExceptionInfo(Type exceptionType, LocationContractAttribute aspect, object value, string locationName, LocationKind locationKind, LocationValidationContext context, string messageId, Object[] messageArguments);
    [CompilerGeneratedAttribute]
public Type get_ExceptionType();
    [CompilerGeneratedAttribute]
public LocationContractAttribute get_Aspect();
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public string get_LocationName();
    [CompilerGeneratedAttribute]
public LocationKind get_LocationKind();
    [CompilerGeneratedAttribute]
public LocationValidationContext get_Context();
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public Object[] get_MessageArguments();
}
public class PostSharp.Patterns.Contracts.ContractLocalizedTextProvider : LocalizedTextProvider {
    private Dictionary`2<string, string> messages;
    public static string CreditCardErrorMessage;
    public static string EmailAddressErrorMessage;
    public static string EnumDataTypeErrorMessage;
    public static string GreaterThanErrorMessage;
    public static string LessThanErrorMessage;
    public static string LocationContractErrorMessage;
    public static string NotEmptyErrorMessage;
    public static string NotNullErrorMessage;
    public static string PhoneErrorMessage;
    public static string RangeErrorMessage;
    public static string StrictRangeErrorMessage;
    public static string RegularExpressionErrorMessage;
    public static string RequiredErrorMessage;
    public static string StrictlyGreaterThanErrorMessage;
    public static string StrictlyLessThanErrorMessage;
    public static string StringLengthMinErrorMessage;
    public static string StringLengthMaxErrorMessage;
    public static string StringLengthRangeErrorMessage;
    public static string UrlErrorMessage;
    [ObsoleteAttribute("Use ContractServices.LocalizedTextProvider")]
public static ContractLocalizedTextProvider Current { get; public set; }
    public ContractLocalizedTextProvider(ContractLocalizedTextProvider next);
    public static ContractLocalizedTextProvider get_Current();
    public static void set_Current(ContractLocalizedTextProvider value);
    internal string FormatMessage(string errorMessage, object value, string locationName, LocationKind locationKind, Object[] additionalArguments);
    public static Object[] GetFormattingStringArguments(object value, string locationName, LocationKind locationKind, Object[] additionalArguments);
    public string GetFormattedMessage(ContractExceptionInfo exceptionInfo);
    public virtual string GetMessage(string messageId);
}
public static class PostSharp.Patterns.Contracts.ContractServices : object {
    private static ContractLocalizedTextProvider modreq(System.Runtime.CompilerServices.IsVolatile) localizedTextProvider;
    internal static ContractExceptionFactory DefaultExceptionFactory;
    private static ContractExceptionFactory modreq(System.Runtime.CompilerServices.IsVolatile) exceptionFactory;
    public static ContractLocalizedTextProvider LocalizedTextProvider { get; public set; }
    public static ContractExceptionFactory ExceptionFactory { get; public set; }
    private static ContractServices();
    public static ContractLocalizedTextProvider get_LocalizedTextProvider();
    public static void set_LocalizedTextProvider(ContractLocalizedTextProvider value);
    internal static void ResetExceptionFactory();
    public static ContractExceptionFactory get_ExceptionFactory();
    public static void set_ExceptionFactory(ContractExceptionFactory value);
}
[HasConstraintAttribute]
public class PostSharp.Patterns.Contracts.CreditCardAttribute : LocationContractAttribute {
    [ObsoleteAttribute("Use ContractExceptionFactory and ContractLocalizedTextProvider to generate error messages.")]
protected internal virtual string GetErrorMessage();
    public virtual Exception ValidateValueDynamic(object value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[MethodPointcut("SelectSelfOrNothing")]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(string value, string locationName, LocationKind locationKind, LocationValidationContext context);
}
public class PostSharp.Patterns.Contracts.DefaultContractExceptionFactory : ContractExceptionFactory {
    public DefaultContractExceptionFactory(ContractExceptionFactory next);
    public virtual Exception CreateException(ContractExceptionInfo exceptionInfo);
}
[AspectConfigurationAttribute]
public class PostSharp.Patterns.Contracts.EmailAddressAttribute : RegularExpressionAttribute {
    private static string pattern;
    [ObsoleteAttribute("Use ContractExceptionFactory and ContractLocalizedTextProvider to generate error messages.")]
protected internal virtual string GetErrorMessage();
    private protected virtual Exception CreateException(string value, string locationName, LocationKind locationKind, LocationValidationContext context);
}
[HasConstraintAttribute]
public class PostSharp.Patterns.Contracts.EnumDataTypeAttribute : LocationContractAttribute {
    [CompilerGeneratedAttribute]
private Type <EnumType>k__BackingField;
    public Type EnumType { get; private set; }
    public EnumDataTypeAttribute(Type enumType);
    [ObsoleteAttribute("Use ContractExceptionFactory and ContractLocalizedTextProvider to generate error messages.")]
protected internal virtual string GetErrorMessage();
    [ObsoleteAttribute("Use ContractServices.ExceptionFactory.CreateException to generate error messages.")]
protected virtual Object[] GetErrorMessageArguments();
    [CompilerGeneratedAttribute]
public Type get_EnumType();
    [CompilerGeneratedAttribute]
private void set_EnumType(Type value);
    private Exception CreateException(object value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[MethodPointcut("SelectSelfOrNothing")]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValueString(string value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[MethodPointcut("SelectSelfOrNothing")]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public virtual Exception ValidateValueDynamic(object value, string locationName, LocationKind locationKind, LocationValidationContext context);
    private Exception ValidateEnumValue(object value, string locationName, LocationKind locationKind, LocationValidationContext context);
    private static bool IsEnumTypeInFlagsMode(Type enumType);
    private static string GetUnderlyingTypeValueString(Type enumType, object enumValue);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(Nullable`1<long> value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(Nullable`1<ulong> value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(Nullable`1<int> value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(Nullable`1<UInt32> value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(Nullable`1<short> value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(Nullable`1<byte> value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(Nullable`1<sbyte> value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(Nullable`1<ushort> value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(long value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(ulong value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(int value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(UInt32 value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(short value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(byte value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(sbyte value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(ushort value, string locationName, LocationKind locationKind, LocationValidationContext context);
}
internal static class PostSharp.Patterns.Contracts.FloatingPointHelper : object {
    public static double DoubleTolerance;
    public static decimal DecimalTolerance;
    private static FloatingPointHelper();
    public static double GetDoubleStep(double value);
    public static decimal GetDecimalStep(decimal value);
    private static double GetDoubleTolerance();
    private static decimal GetDecimalTolerance();
}
public class PostSharp.Patterns.Contracts.GreaterThanAttribute : RangeAttribute {
    public GreaterThanAttribute(long min);
    public GreaterThanAttribute(ulong min);
    public GreaterThanAttribute(double min);
    [ObsoleteAttribute("Use ContractExceptionFactory and ContractLocalizedTextProvider to generate error messages.")]
protected internal virtual string GetErrorMessage();
    protected virtual Exception CreateException(object value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [ObsoleteAttribute("Use ContractServices.ExceptionFactory.CreateException to generate error messages.")]
protected virtual Object[] GetErrorMessageArguments();
}
[InternalImplementAttribute]
[HasConstraintAttribute]
public interface PostSharp.Patterns.Contracts.ILocationValidationHandler {
    public abstract virtual void Register(LocationInfo location, LocationContractAttribute contract);
}
public class PostSharp.Patterns.Contracts.LessThanAttribute : RangeAttribute {
    public LessThanAttribute(long max);
    public LessThanAttribute(ulong max);
    public LessThanAttribute(double max);
    [ObsoleteAttribute("Use ContractExceptionFactory and ContractLocalizedTextProvider to generate error messages.")]
protected internal virtual string GetErrorMessage();
    protected virtual Exception CreateException(object value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [ObsoleteAttribute("Use ContractServices.ExceptionFactory.CreateException to generate error messages.")]
protected virtual Object[] GetErrorMessageArguments();
}
[AspectConfigurationAttribute]
[MulticastAttributeUsageAttribute]
[AttributeUsageAttribute("10624")]
[ProvideAspectRoleAttribute("Validation")]
public abstract class PostSharp.Patterns.Contracts.LocationContractAttribute : MulticastAttribute {
    private static Object[] emptyArray;
    private string errorMessage;
    [ObsoleteAttribute("Use ContractExceptionFactory and ContractLocalizedTextProvider to generate error messages.")]
public string ErrorMessage { get; public set; }
    private static LocationContractAttribute();
    protected virtual bool CompileTimeValidate(LocationInfo target);
    [IteratorStateMachineAttribute("PostSharp.Patterns.Contracts.LocationContractAttribute/<SelectSelfOrNothing>d__4")]
protected IEnumerable`1<LocationInfo> SelectSelfOrNothing(LocationInfo target);
    public sealed virtual void RuntimeInitialize(LocationInfo locationInfo);
    public virtual Exception ValidateValueDynamic(object value, string locationName, LocationKind locationKind, LocationValidationContext context);
    public string get_ErrorMessage();
    public void set_ErrorMessage(string value);
    [ObsoleteAttribute("Use ContractServices.ExceptionFactory.CreateException to generate error messages.")]
protected virtual Object[] GetErrorMessageArguments();
    [ObsoleteAttribute("Use ContractExceptionFactory and ContractLocalizedTextProvider to generate error messages.")]
protected internal virtual string GetErrorMessage();
    [ObsoleteAttribute("Use ContractServices.LocalizedTextProvider.GetFormattedMessage.")]
protected string FormatErrorMessage(object value, string locationName, LocationKind locationKind);
    [ObsoleteAttribute("Use ContractServices.ExceptionFactory.CreateException().")]
protected ArgumentException CreateArgumentException(object value, string locationName, LocationKind locationKind);
    [ObsoleteAttribute("Use ContractServices.ExceptionFactory.CreateException().")]
protected ArgumentNullException CreateArgumentNullException(object value, string locationName, LocationKind locationKind);
    [ObsoleteAttribute("Use ContractServices.ExceptionFactory.CreateException().")]
protected ArgumentOutOfRangeException CreateArgumentOutOfRangeException(object value, string locationName, LocationKind locationKind);
    [ObsoleteAttribute("Use ContractServices.ExceptionFactory.CreateException().")]
protected PostconditionFailedException CreatePostconditionFailedException(object value, string locationName, LocationKind locationKind);
    private protected Exception CreateException(Type exceptionType, object value, string locationName, LocationKind locationKind, LocationValidationContext context, string messageId, Object[] additionalArguments);
}
public class PostSharp.Patterns.Contracts.NegativeAttribute : LessThanAttribute {
}
[HasConstraintAttribute]
public class PostSharp.Patterns.Contracts.NotEmptyAttribute : LocationContractAttribute {
    [ObsoleteAttribute("Use ContractExceptionFactory and ContractLocalizedTextProvider to generate error messages.")]
protected internal virtual string GetErrorMessage();
    public virtual Exception ValidateValueDynamic(object value, string locationName, LocationKind locationKind, LocationValidationContext context);
    private Exception CreateNotEmptyException(object value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[MethodPointcut("SelectSelfOrNothing")]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValueString(string value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[MethodPointcut("SelectSelfOrNothing")]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValueCollection(ICollection value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[MethodPointcut("SelectSelfOrNothing")]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValueCollection(ICollection`1<T> value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[MethodPointcut("SelectSelfOrNothing")]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValueCollection(IReadOnlyCollection`1<T> value, string locationName, LocationKind locationKind, LocationValidationContext context);
}
[HasConstraintAttribute]
public class PostSharp.Patterns.Contracts.NotNullAttribute : LocationContractAttribute {
    [ObsoleteAttribute("Use ContractExceptionFactory and ContractLocalizedTextProvider to generate error messages.")]
protected internal virtual string GetErrorMessage();
    [LocationValidationAdvice]
[MethodPointcut("SelectSelfOrNothing")]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public virtual Exception ValidateValueDynamic(object value, string locationName, LocationKind locationKind, LocationValidationContext context);
}
[AspectConfigurationAttribute]
public class PostSharp.Patterns.Contracts.PhoneAttribute : RegularExpressionAttribute {
    private static string pattern;
    [ObsoleteAttribute("Use ContractExceptionFactory and ContractLocalizedTextProvider to generate error messages.")]
protected internal virtual string GetErrorMessage();
    private protected virtual Exception CreateException(string value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [ObsoleteAttribute("Use ContractServices.ExceptionFactory.CreateException to generate error messages.")]
protected virtual Object[] GetErrorMessageArguments();
}
public class PostSharp.Patterns.Contracts.PositiveAttribute : GreaterThanAttribute {
}
public class PostSharp.Patterns.Contracts.PostconditionFailedException : Exception {
    public PostconditionFailedException(string message);
    public PostconditionFailedException(string message, Exception innerException);
    protected PostconditionFailedException(SerializationInfo info, StreamingContext context);
}
[HasConstraintAttribute]
public class PostSharp.Patterns.Contracts.RangeAttribute : LocationContractAttribute {
    [CompilerGeneratedAttribute]
private object <DisplayMinValue>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DisplayMaxValue>k__BackingField;
    private long minInt64;
    private long maxInt64;
    private ulong minUInt64;
    private ulong maxUInt64;
    private double minDouble;
    private double maxDouble;
    private decimal minDecimal;
    private decimal maxDecimal;
    private TypeFlag invalidTypes;
    protected object DisplayMinValue { get; private set; }
    protected object DisplayMaxValue { get; private set; }
    internal RangeAttribute(object displayMin, object displayMax, long minInt64, long maxInt64, ulong minUInt64, ulong maxUInt64, double minDouble, double maxDouble, decimal minDecimal, decimal maxDecimal, TypeFlag invalidTypes);
    public RangeAttribute(long min, long max);
    public RangeAttribute(ulong min, ulong max);
    public RangeAttribute(double min, double max);
    [CompilerGeneratedAttribute]
protected object get_DisplayMinValue();
    [CompilerGeneratedAttribute]
private void set_DisplayMinValue(object value);
    [CompilerGeneratedAttribute]
protected object get_DisplayMaxValue();
    [CompilerGeneratedAttribute]
private void set_DisplayMaxValue(object value);
    [ObsoleteAttribute("Use ContractExceptionFactory and ContractLocalizedTextProvider to generate error messages.")]
protected internal virtual string GetErrorMessage();
    [ObsoleteAttribute("Use ContractServices.ExceptionFactory.CreateException to generate error messages.")]
protected virtual Object[] GetErrorMessageArguments();
    internal static TypeFlag GetInvalidTypes(long min, long max);
    internal static TypeFlag GetInvalidTypes(ulong min);
    internal static TypeFlag GetInvalidTypes(double min, double max);
    internal static TypeFlag GetInvalidTypes(decimal min, decimal max);
    internal static long ConvertUInt64ToInt64(ulong value);
    internal static decimal ConvertDoubleToDecimal(double value);
    internal static long ConvertDoubleToInt64(double value);
    private static ulong ConvertDoubleToUInt64(double value);
    internal static long ConvertDecimalToInt64(decimal value);
    private static ulong ConvertDecimalToUInt64(decimal value);
    public virtual Exception ValidateValueDynamic(object value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(Nullable`1<long> value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(Nullable`1<double> value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(Nullable`1<decimal> value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(Nullable`1<ulong> value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(long value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(ulong value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(double value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(decimal value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(Nullable`1<int> value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(Nullable`1<UInt32> value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(Nullable`1<short> value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(Nullable`1<byte> value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(Nullable`1<sbyte> value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(Nullable`1<ushort> value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(Nullable`1<float> value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValueInt(int value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(UInt32 value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(short value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(byte value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(sbyte value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(ushort value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(float value, string locationName, LocationKind locationKind, LocationValidationContext context);
    protected virtual Exception CreateException(object value, string locationName, LocationKind locationKind, LocationValidationContext context);
    public sealed virtual bool CompileTimeValidate(object target);
    private static TypeFlag GetTypeFlag(Type locationType);
}
[HasConstraintAttribute]
public class PostSharp.Patterns.Contracts.RegularExpressionAttribute : LocationContractAttribute {
    private Regex validator;
    private string pattern;
    public RegularExpressionAttribute(string pattern);
    public RegularExpressionAttribute(string pattern, RegexOptions options);
    [ObsoleteAttribute("Use ContractExceptionFactory and ContractLocalizedTextProvider to generate error messages.")]
protected internal virtual string GetErrorMessage();
    [ObsoleteAttribute("Use ContractServices.ExceptionFactory.CreateException to generate error messages.")]
protected virtual Object[] GetErrorMessageArguments();
    public virtual Exception ValidateValueDynamic(object value, string locationName, LocationKind locationKind, LocationValidationContext context);
    private protected virtual Exception CreateException(string value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[MethodPointcut("SelectSelfOrNothing")]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(string value, string locationName, LocationKind locationKind, LocationValidationContext context);
}
[HasConstraintAttribute]
public class PostSharp.Patterns.Contracts.RequiredAttribute : LocationContractAttribute {
    [ObsoleteAttribute("Use ContractExceptionFactory and ContractLocalizedTextProvider to generate error messages.")]
protected internal virtual string GetErrorMessage();
    public virtual Exception ValidateValueDynamic(object value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[MethodPointcut("SelectSelfOrNothing")]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValueObject(object value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[MethodPointcut("SelectSelfOrNothing")]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValueString(string value, string locationName, LocationKind locationKind, LocationValidationContext context);
}
public class PostSharp.Patterns.Contracts.StrictlyGreaterThanAttribute : RangeAttribute {
    public StrictlyGreaterThanAttribute(long min);
    public StrictlyGreaterThanAttribute(ulong min);
    public StrictlyGreaterThanAttribute(double min);
    [ObsoleteAttribute("Use ContractExceptionFactory and ContractLocalizedTextProvider to generate error messages.")]
protected internal virtual string GetErrorMessage();
    protected virtual Exception CreateException(object value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [ObsoleteAttribute("Use ContractServices.ExceptionFactory.CreateException to generate error messages.")]
protected virtual Object[] GetErrorMessageArguments();
}
public class PostSharp.Patterns.Contracts.StrictlyLessThanAttribute : RangeAttribute {
    public StrictlyLessThanAttribute(long max);
    public StrictlyLessThanAttribute(ulong max);
    public StrictlyLessThanAttribute(double max);
    [ObsoleteAttribute("Use ContractExceptionFactory and ContractLocalizedTextProvider to generate error messages.")]
protected internal virtual string GetErrorMessage();
    protected virtual Exception CreateException(object value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [ObsoleteAttribute("Use ContractServices.ExceptionFactory.CreateException to generate error messages.")]
protected virtual Object[] GetErrorMessageArguments();
}
public class PostSharp.Patterns.Contracts.StrictlyNegativeAttribute : StrictlyLessThanAttribute {
}
public class PostSharp.Patterns.Contracts.StrictlyPositiveAttribute : StrictlyGreaterThanAttribute {
}
public class PostSharp.Patterns.Contracts.StrictRangeAttribute : RangeAttribute {
    public StrictRangeAttribute(long min, long max);
    public StrictRangeAttribute(ulong min, ulong max);
    public StrictRangeAttribute(double min, double max);
    [ObsoleteAttribute("Use ContractExceptionFactory and ContractLocalizedTextProvider to generate error messages.")]
protected internal virtual string GetErrorMessage();
    protected virtual Exception CreateException(object value, string locationName, LocationKind locationKind, LocationValidationContext context);
}
[HasConstraintAttribute]
public class PostSharp.Patterns.Contracts.StringLengthAttribute : LocationContractAttribute {
    [CompilerGeneratedAttribute]
private int <MaximumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinimumLength>k__BackingField;
    public int MaximumLength { get; private set; }
    public int MinimumLength { get; private set; }
    public StringLengthAttribute(int maximumLength);
    public StringLengthAttribute(int minimumLength, int maximumLength);
    [ObsoleteAttribute("Use ContractExceptionFactory and ContractLocalizedTextProvider to generate error messages.")]
protected internal virtual string GetErrorMessage();
    [ObsoleteAttribute("Use ContractServices.ExceptionFactory.CreateException to generate error messages.")]
protected virtual Object[] GetErrorMessageArguments();
    [CompilerGeneratedAttribute]
public int get_MaximumLength();
    [CompilerGeneratedAttribute]
private void set_MaximumLength(int value);
    [CompilerGeneratedAttribute]
public int get_MinimumLength();
    [CompilerGeneratedAttribute]
private void set_MinimumLength(int value);
    public virtual Exception ValidateValueDynamic(object value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [LocationValidationAdvice]
[MethodPointcut("SelectSelfOrNothing")]
[MethodExecutionAdviceOptimizationAttribute]
[InternalAttribute]
[DebuggerAspectMethodAttribute]
public Exception ValidateValue(string value, string locationName, LocationKind locationKind, LocationValidationContext context);
}
[AspectConfigurationAttribute]
public class PostSharp.Patterns.Contracts.UrlAttribute : RegularExpressionAttribute {
    private static string pattern;
    [ObsoleteAttribute("Use ContractExceptionFactory and ContractLocalizedTextProvider to generate error messages.")]
protected internal virtual string GetErrorMessage();
    private protected virtual Exception CreateException(string value, string locationName, LocationKind locationKind, LocationValidationContext context);
    [ObsoleteAttribute("Use ContractServices.ExceptionFactory.CreateException to generate error messages.")]
protected virtual Object[] GetErrorMessageArguments();
}
[EditorBrowsableAttribute("1")]
[AspectDescriptionAttribute("Tracks suspend/resume events on the async method using custom async activities.")]
[ProvideAspectRoleAttribute("AwaitInstrumentationAspect")]
[AspectRoleDependencyAttribute]
[AspectRoleDependencyAttribute]
[LinesOfCodeAvoidedAttribute("0")]
[SerializerAttribute("PostSharp.Patterns.Diagnostics.AwaitInstrumentationAspect/Serializer")]
public class PostSharp.Patterns.Diagnostics.AwaitInstrumentationAspect : MethodLevelAspect {
    [CompilerGeneratedAttribute]
protected AwaitInstrumentationAspect(PortableFormatterConstructorContext context);
    [OnMethodEntryAdvice]
[MethodExecutionAdviceOptimizationAttribute]
[DebuggerAspectMethodAttribute]
public static void OnEntry(AsyncCallId task);
    [OnMethodYieldAdvice]
[SelfPointcut]
[MethodExecutionAdviceOptimizationAttribute]
[DebuggerAspectMethodAttribute]
public static void OnSuspend(AsyncCallId task);
    [OnMethodResumeAdvice]
[MethodExecutionAdviceOptimizationAttribute]
[DebuggerAspectMethodAttribute]
public static void OnResume(AsyncCallId task);
    [OnMethodExitAdvice]
[MethodExecutionAdviceOptimizationAttribute]
[DebuggerAspectMethodAttribute]
public static void OnExit(AsyncCallId task);
}
internal class PostSharp.Patterns.Diagnostics.AwaitInstrumentationAspectProvider : object {
    private static HashSet`1<MethodInfo> targetMethods;
    private static AwaitInstrumentationAspectProvider();
    [IteratorStateMachineAttribute("PostSharp.Patterns.Diagnostics.AwaitInstrumentationAspectProvider/<ProvideAspects>d__1")]
public sealed virtual IEnumerable`1<AspectInstance> ProvideAspects(object targetElement);
}
[ExplicitCrossPackageInternalAttribute]
internal static class PostSharp.Patterns.Diagnostics.AwaitInstrumentationServices : object {
    [CompilerGeneratedAttribute]
private static Action`1<AsyncCallId> AsyncMethodSuspended;
    [CompilerGeneratedAttribute]
private static Action`1<AsyncCallId> AsyncMethodResumed;
    [ThreadStaticAttribute]
private static Stack`1<AsyncCallId> taskStack;
    private static Stack`1<AsyncCallId> TaskStack { get; }
    public static AsyncCallId CurrentTask { get; }
    [CompilerGeneratedAttribute]
public static void add_AsyncMethodSuspended(Action`1<AsyncCallId> value);
    [CompilerGeneratedAttribute]
public static void remove_AsyncMethodSuspended(Action`1<AsyncCallId> value);
    [CompilerGeneratedAttribute]
public static void add_AsyncMethodResumed(Action`1<AsyncCallId> value);
    [CompilerGeneratedAttribute]
public static void remove_AsyncMethodResumed(Action`1<AsyncCallId> value);
    private static Stack`1<AsyncCallId> get_TaskStack();
    private static void Pop(AsyncCallId task);
    private static void Push(AsyncCallId task);
    internal static void OnAsyncMethodSuspended(AsyncCallId task);
    public static AsyncCallId get_CurrentTask();
    internal static void OnAsyncMethodResumed(AsyncCallId task);
    internal static void OnAsyncMethodExit(AsyncCallId task);
    internal static void OnAsyncMethodEntry(AsyncCallId task);
}
public class PostSharp.Patterns.Diagnostics.CloseActivityOptions : ValueType {
    [CompilerGeneratedAttribute]
private LogEventData <Data>k__BackingField;
    [ObsoleteAttribute("Use the Data property.")]
public LoggingProperty[] Properties { get; public set; }
    public LogEventData Data { get; public set; }
    public CloseActivityOptions(object data);
    public CloseActivityOptions(LogEventData& data);
    [IsReadOnlyAttribute]
public LoggingProperty[] get_Properties();
    public void set_Properties(LoggingProperty[] value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public LogEventData get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(LogEventData value);
}
[FlagsAttribute]
public enum PostSharp.Patterns.Diagnostics.Contexts.CallerAttributes : Enum {
    public int value__;
    public static CallerAttributes None;
    public static CallerAttributes IsAsync;
}
public class PostSharp.Patterns.Diagnostics.Contexts.CallerInfo : ValueType {
    private Type sourceType;
    [CompilerGeneratedAttribute]
private CallerAttributes <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeTypeHandle <SourceTypeToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceLineInfo <SourceLineInfo>k__BackingField;
    [ExplicitCrossPackageInternalAttribute]
internal static CallerInfo Null;
    public CallerAttributes Attributes { get; private set; }
    public bool IsAsync { get; }
    public Type SourceType { get; }
    public RuntimeTypeHandle SourceTypeToken { get; }
    public string MethodName { get; private set; }
    public SourceLineInfo SourceLineInfo { get; private set; }
    public bool IsNull { get; }
    [ExplicitCrossPackageInternalAttribute]
internal static CallerInfo Async { get; }
    [DebuggerStepThroughAttribute]
[ObsoleteAttribute("Use the constructor that accepts a CallerAttributes parameter.")]
public CallerInfo(RuntimeTypeHandle sourceTypeToken, string methodName, string file, int line, int column);
    [DebuggerStepThroughAttribute]
public CallerInfo(RuntimeTypeHandle sourceTypeToken, string methodName, string file, int line, int column, CallerAttributes attributes);
    [DebuggerStepThroughAttribute]
[ObsoleteAttribute("Use the constructor that accepts a CallerAttributes parameter.")]
public CallerInfo(Type sourceType, string methodName, string file, int line, int column);
    [DebuggerStepThroughAttribute]
public CallerInfo(Type sourceType, string methodName, string file, int line, int column, CallerAttributes attributes);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CallerAttributes get_Attributes();
    [CompilerGeneratedAttribute]
private void set_Attributes(CallerAttributes value);
    public bool get_IsAsync();
    public Type get_SourceType();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public RuntimeTypeHandle get_SourceTypeToken();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
private void set_MethodName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SourceLineInfo get_SourceLineInfo();
    [CompilerGeneratedAttribute]
private void set_SourceLineInfo(SourceLineInfo value);
    public bool get_IsNull();
    internal static CallerInfo get_Async();
    public virtual string ToString();
    public static CallerInfo GetDynamic(int skipFrames);
}
[InternalImplementAttribute]
[HasConstraintAttribute]
public interface PostSharp.Patterns.Diagnostics.Contexts.ILoggingContext {
    public bool IsDisposed { get; }
    public int RecycleId { get; }
    public bool IsAsync { get; }
    public string SyntheticId { get; }
    public abstract virtual bool get_IsDisposed();
    public abstract virtual int get_RecycleId();
    public abstract virtual bool get_IsAsync();
    public abstract virtual string get_SyntheticId();
    [ObsoleteAttribute("Use LoggingContext.VisitProperties.")]
public abstract virtual void ForEachProperty(LoggingPropertyVisitor`1<object> visitor, bool includeAncestors);
    [ObsoleteAttribute("Use LoggingContext.VisitProperties.")]
public abstract virtual void ForEachProperty(LoggingPropertyVisitor`1<T> visitor, T& state, bool includeAncestors);
}
public class PostSharp.Patterns.Diagnostics.Contexts.LoggingPropertyVisitor`1 : MulticastDelegate {
    public LoggingPropertyVisitor`1(object object, IntPtr method);
    public virtual void Invoke(LoggingProperty property, object value, T& state);
    public virtual IAsyncResult BeginInvoke(LoggingProperty property, object value, T& state, AsyncCallback callback, object object);
    public virtual void EndInvoke(T& state, IAsyncResult result);
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Contexts.SourceLineInfo : ValueType {
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    public string File { get; }
    public int Line { get; }
    public int Column { get; }
    public bool IsNull { get; }
    [DebuggerStepThroughAttribute]
public SourceLineInfo(string file, int line, int column);
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public int get_Column();
    public bool get_IsNull();
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Correlation.IncomingRequestOptions : ValueType {
    private byte isParentSampled;
    public bool IsParentSampled { get; }
    public IncomingRequestOptions(bool isParentSampled);
    public bool get_IsParentSampled();
}
internal static class PostSharp.Patterns.Diagnostics.Custom.AugmentedLogEventData : object {
    private static ConcurrentDictionary`2<ValueTuple`2<Type, Type>, object> delegateCache;
    private static AugmentedLogEventData();
    public static LogEventData Augment(LogEventData& augmented, string propertyName, T propertyValue, LoggingPropertyOptions& options);
    private static CreateMetaDataDelegate`1<TValue> CreateFactory(Type augmentedType);
}
public enum PostSharp.Patterns.Diagnostics.Custom.CustomLogParameterMode : Enum {
    public int value__;
    public static CustomLogParameterMode Default;
    public static CustomLogParameterMode NameValuePair;
    public static CustomLogParameterMode Hidden;
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.CustomLogParameterOptions : ValueType {
    [ExplicitCrossPackageInternalAttribute]
internal static CustomLogParameterOptions FormattedStringParameter;
    internal static CustomLogParameterOptions SemanticParameter;
    [CompilerGeneratedAttribute]
private CustomLogParameterMode <Mode>k__BackingField;
    public CustomLogParameterMode Mode { get; }
    [ExplicitCrossPackageInternalAttribute]
internal FormattingOptions FormattingOptions { get; }
    public CustomLogParameterOptions(CustomLogParameterMode mode);
    private static CustomLogParameterOptions();
    [CompilerGeneratedAttribute]
public CustomLogParameterMode get_Mode();
    internal FormattingOptions get_FormattingOptions();
}
[FlagsAttribute]
public enum PostSharp.Patterns.Diagnostics.Custom.CustomLogRecordAttributes : Enum {
    public int value__;
    public static CustomLogRecordAttributes None;
    public static CustomLogRecordAttributes WriteActivityDescription;
    public static CustomLogRecordAttributes WriteActivityOutcome;
    public static CustomLogRecordAttributes WriteActivityDescriptionAndOutcome;
    public static CustomLogRecordAttributes WriteMessage;
}
public enum PostSharp.Patterns.Diagnostics.Custom.CustomLogRecordItem : Enum {
    public int value__;
    public static CustomLogRecordItem Message;
    public static CustomLogRecordItem ActivityDescription;
    public static CustomLogRecordItem ActivityOutcome;
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.CustomLogRecordOptions : ValueType {
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private LogRecordKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private CustomLogRecordAttributes <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private LogEventData <Data>k__BackingField;
    public LogLevel Level { get; }
    public LogRecordKind Kind { get; }
    public CustomLogRecordAttributes Attributes { get; }
    [ObsoleteAttribute("Provide a LogEventData.")]
public LoggingProperty[] Properties { get; }
    public LogEventData Data { get; }
    internal CustomLogRecordOptions(LogLevel level, LogRecordKind kind, CustomLogRecordAttributes attributes, LogEventData& data);
    [CompilerGeneratedAttribute]
public LogLevel get_Level();
    [CompilerGeneratedAttribute]
public LogRecordKind get_Kind();
    [CompilerGeneratedAttribute]
public CustomLogRecordAttributes get_Attributes();
    public LoggingProperty[] get_Properties();
    [CompilerGeneratedAttribute]
public LogEventData get_Data();
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.CustomLogRecordTextOptions : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ParameterCount>k__BackingField;
    public string Name { get; }
    public int ParameterCount { get; }
    public CustomLogRecordTextOptions(int parameterCount, string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public int get_ParameterCount();
}
internal class PostSharp.Patterns.Diagnostics.Custom.DefaultLogEventMetadata`1 : LogEventMetadata`1<T> {
    private Dictionary`2<string, LoggingPropertyOptions> propertyOptions;
    private bool hasInheritedProperty;
    public static DefaultLogEventMetadata`1<T> Instance;
    private static DefaultLogEventMetadata`1();
    public virtual bool HasInheritedProperty(object data);
    protected internal virtual LoggingPropertyOptions GetPropertyOptions(string name);
}
public class PostSharp.Patterns.Diagnostics.Custom.FormattingStringParser : ValueType {
    private string str;
    private Char[] charArray;
    private int position;
    private bool hasParameter;
    public FormattingStringParser(string formattingString);
    private int GetIndexOf(char separator, Boolean& unescape);
    public ArraySegment`1<char> GetNextSubstring();
    private ArraySegment`1<char> GetUnescapedString(int index, int count, bool unescape);
    public ArraySegment`1<char> GetNextParameter();
}
public interface PostSharp.Patterns.Diagnostics.Custom.IContextLocalLogger {
    public abstract virtual bool IsEnabled(LogLevel level);
    public abstract virtual ILoggingContext OpenActivity(OpenActivityOptions& modreq(System.Runtime.InteropServices.InAttribute) options, CallerInfo& callerInfo);
    public abstract virtual ICustomLogRecordBuilder GetRecordBuilder(CustomLogRecordOptions& modreq(System.Runtime.InteropServices.InAttribute) options, CallerInfo& callerInfo, ILoggingContext context);
    public abstract virtual void ResumeActivity(ILoggingContext context, CallerInfo& callerInfo);
    public abstract virtual void SuspendActivity(ILoggingContext context, CallerInfo& callerInfo);
    public abstract virtual void SetWaitDependency(ILoggingContext context, object waited);
}
public interface PostSharp.Patterns.Diagnostics.Custom.ICustomLogRecordBuilder {
    public abstract virtual void BeginWriteItem(CustomLogRecordItem item, CustomLogRecordTextOptions& modreq(System.Runtime.InteropServices.InAttribute) options);
    public abstract virtual void EndWriteItem(CustomLogRecordItem item);
    public abstract virtual void WriteCustomParameter(int index, CharSpan& modreq(System.Runtime.InteropServices.InAttribute) parameterName, T value, CustomLogParameterOptions& modreq(System.Runtime.InteropServices.InAttribute) options);
    public abstract virtual void WriteCustomString(CharSpan& modreq(System.Runtime.InteropServices.InAttribute) str);
    public abstract virtual void SetException(Exception exception);
    public abstract virtual void SetExecutionTime(double executionTime, bool isOvertime);
    public abstract virtual void Complete();
}
public interface PostSharp.Patterns.Diagnostics.Custom.ILogActivityOptions {
    public LogLevel ActivityLevel { get; }
    public LogLevel FailureLevel { get; }
    public LogLevel ExceptionLevel { get; }
    public abstract virtual LogLevel get_ActivityLevel();
    public abstract virtual LogLevel get_FailureLevel();
    public abstract virtual LogLevel get_ExceptionLevel();
}
public interface PostSharp.Patterns.Diagnostics.Custom.ILogger {
    [ObsoleteAttribute("Don't use the Type property as some logger may have no type assigned depending on the initialization order.")]
public Type Type { get; }
    public string Role { get; }
    public ILogActivityOptions ActivityOptions { get; }
    public bool RequiresSuspendResume { get; }
    public abstract virtual Type get_Type();
    public abstract virtual string get_Role();
    public abstract virtual bool IsEnabled(LogLevel level);
    public abstract virtual ILogActivityOptions get_ActivityOptions();
    public abstract virtual bool get_RequiresSuspendResume();
    public abstract virtual void Write(ILoggingContext context, LogLevel level, LogRecordKind recordKind, string text, Exception exception, CallerInfo& callerInfo);
    public abstract virtual void Write(ILoggingContext context, LogLevel level, LogRecordKind recordKind, string text, Object[] args, Exception exception, CallerInfo& callerInfo);
    public abstract virtual ILoggingContext OpenActivity(LogActivityOptions options, CallerInfo& callerInfo);
    public abstract virtual void ResumeActivity(ILoggingContext context, CallerInfo& callerInfo);
    public abstract virtual void SuspendActivity(ILoggingContext context, CallerInfo& callerInfo);
    public abstract virtual void SetWaitDependency(ILoggingContext context, object waited);
    public abstract virtual void Write(ILoggingContext context, LogLevel level, LogRecordKind recordKind, string text, T1 arg1, Exception exception, CallerInfo& recordInfo);
    public abstract virtual void Write(ILoggingContext context, LogLevel level, LogRecordKind recordKind, string text, T1 arg1, T2 arg2, Exception exception, CallerInfo& recordInfo);
    public abstract virtual void Write(ILoggingContext context, LogLevel level, LogRecordKind recordKind, string text, T1 arg1, T2 arg2, T3 arg3, Exception exception, CallerInfo& recordInfo);
    public abstract virtual void Write(ILoggingContext context, LogLevel level, LogRecordKind recordKind, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, Exception exception, CallerInfo& recordInfo);
    public abstract virtual void Write(ILoggingContext context, LogLevel level, LogRecordKind recordKind, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, Exception exception, CallerInfo& recordInfo);
    public abstract virtual void Write(ILoggingContext context, LogLevel level, LogRecordKind recordKind, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, Exception exception, CallerInfo& recordInfo);
    public abstract virtual void Write(ILoggingContext context, LogLevel level, LogRecordKind recordKind, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, Exception exception, CallerInfo& recordInfo);
    public abstract virtual void Write(ILoggingContext context, LogLevel level, LogRecordKind recordKind, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, Exception exception, CallerInfo& recordInfo);
    public abstract virtual void Write(ILoggingContext context, LogLevel level, LogRecordKind recordKind, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, Exception exception, CallerInfo& recordInfo);
    public abstract virtual void Write(ILoggingContext context, LogLevel level, LogRecordKind recordKind, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, Exception exception, CallerInfo& recordInfo);
}
public interface PostSharp.Patterns.Diagnostics.Custom.ILogger2 {
    [ObsoleteAttribute("Use ILogger3.Factory")]
public ILoggerFactory2 Factory { get; }
    public ILoggingContext CurrentContext { get; }
    public abstract virtual ILoggerFactory2 get_Factory();
    public abstract virtual IContextLocalLogger GetContextLocalLogger();
    public abstract virtual ILoggingContext get_CurrentContext();
}
public interface PostSharp.Patterns.Diagnostics.Custom.ILogger3 {
    public ILoggerFactory3 Factory { get; }
    public abstract virtual ILoggerFactory3 get_Factory();
    public abstract virtual ValueTuple`2<IContextLocalLogger, bool> GetContextLocalLogger(LogLevel level);
}
public interface PostSharp.Patterns.Diagnostics.Custom.ILoggerExceptionHandler {
    public abstract virtual void OnInvalidUserCode(CallerInfo& callerInfo, string format, Object[] args);
    public abstract virtual void OnInternalException(Exception exception);
}
[ObsoleteAttribute("Use ILoggerFactoryProvider3")]
public interface PostSharp.Patterns.Diagnostics.Custom.ILoggerFactory {
    public abstract virtual ILogger GetLogger(string role, Type type);
}
[ObsoleteAttribute("Use ILoggerFactory3")]
public interface PostSharp.Patterns.Diagnostics.Custom.ILoggerFactory2 {
    [ObsoleteAttribute("Use ILoggerFactory3.GetLogger")]
public abstract virtual ILogger2 GetLogger(Type type);
}
public interface PostSharp.Patterns.Diagnostics.Custom.ILoggerFactory3 {
    public abstract virtual ILogger3 GetLogger(Type type);
    public abstract virtual ILogger3 GetLogger(string sourceName);
}
[ObsoleteAttribute("Use ILoggerFactoryProvider3")]
public interface PostSharp.Patterns.Diagnostics.Custom.ILoggerFactoryProvider {
    public abstract virtual ILoggerFactory2 GetLoggerFactory(string role);
}
public interface PostSharp.Patterns.Diagnostics.Custom.ILoggerFactoryProvider3 {
    public abstract virtual ILoggerFactory3 GetLoggerFactory3(string role);
}
public interface PostSharp.Patterns.Diagnostics.Custom.ILoggingPropertyVisitor`1 {
    public abstract virtual void Visit(string name, TValue value, LoggingPropertyOptions& modreq(System.Runtime.InteropServices.InAttribute) options, TState& state);
}
public class PostSharp.Patterns.Diagnostics.Custom.InvalidFormattingStringException : FormatException {
    public InvalidFormattingStringException(string message);
    public InvalidFormattingStringException(string message, Exception inner);
    protected InvalidFormattingStringException(SerializationInfo info, StreamingContext context);
}
internal interface PostSharp.Patterns.Diagnostics.Custom.ITransactionAwareContextLocalLogger {
    public abstract virtual void ApplyTransactionRequirements(OpenActivityOptions& options);
}
public abstract class PostSharp.Patterns.Diagnostics.Custom.LegacySourceLogger : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Role>k__BackingField;
    public ILoggerFactory2 Factory { get; }
    public Type Type { get; }
    public string Role { get; }
    public bool RequiresSuspendResume { get; }
    private bool PostSharp.Patterns.Diagnostics.Custom.ILogger.RequiresSuspendResume { get; }
    private ILogActivityOptions PostSharp.Patterns.Diagnostics.Custom.ILogger.ActivityOptions { get; }
    private LogLevel PostSharp.Patterns.Diagnostics.Custom.ILogActivityOptions.ActivityLevel { get; }
    private LogLevel PostSharp.Patterns.Diagnostics.Custom.ILogActivityOptions.FailureLevel { get; }
    private LogLevel PostSharp.Patterns.Diagnostics.Custom.ILogActivityOptions.ExceptionLevel { get; }
    private Type PostSharp.Patterns.Diagnostics.Custom.ILogger.Type { get; }
    private string PostSharp.Patterns.Diagnostics.Custom.ILogger.Role { get; }
    private ILoggerFactory3 PostSharp.Patterns.Diagnostics.Custom.ILogger3.Factory { get; }
    private ILoggingContext PostSharp.Patterns.Diagnostics.Custom.ILogger2.CurrentContext { get; }
    protected LegacySourceLogger(string role, Type type);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.Write(ILoggingContext context, LogLevel level, LogRecordKind logRecordKind, string text, T1 arg1, Exception exception, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.Write(ILoggingContext context, LogLevel level, LogRecordKind logRecordKind, string text, T1 arg1, T2 arg2, Exception exception, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.Write(ILoggingContext context, LogLevel level, LogRecordKind logRecordKind, string text, T1 arg1, T2 arg2, T3 arg3, Exception exception, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.Write(ILoggingContext context, LogLevel level, LogRecordKind logRecordKind, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, Exception exception, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.Write(ILoggingContext context, LogLevel level, LogRecordKind logRecordKind, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, Exception exception, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.Write(ILoggingContext context, LogLevel level, LogRecordKind logRecordKind, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, Exception exception, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.Write(ILoggingContext context, LogLevel level, LogRecordKind logRecordKind, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, Exception exception, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.Write(ILoggingContext context, LogLevel level, LogRecordKind logRecordKind, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, Exception exception, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.Write(ILoggingContext context, LogLevel level, LogRecordKind logRecordKind, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, Exception exception, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.Write(ILoggingContext context, LogLevel level, LogRecordKind logRecordKind, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, Exception exception, CallerInfo& callerInfo);
    public abstract virtual bool IsEnabled(LogLevel level);
    public abstract virtual ILoggerFactory2 get_Factory();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public string get_Role();
    public bool get_RequiresSuspendResume();
    private static string GetRecordKindText(LogRecordKind recordKind);
    protected abstract virtual void Write(LogLevel level, LogRecordKind recordKind, string text, Exception exception);
    private void WriteFormatted(ILoggingContext context, LogLevel level, LogRecordKind recordKind, string text, Object[] args, Exception exception);
    private static void WriteText(string text, Object[] args, StringBuilder stringBuilder);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.Write(ILoggingContext context, LogLevel level, LogRecordKind recordKind, string text, Object[] args, Exception exception, CallerInfo& recordInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.Write(ILoggingContext context, LogLevel level, LogRecordKind recordKind, string text, Exception exception, CallerInfo& recordInfo);
    private sealed virtual override ILoggingContext PostSharp.Patterns.Diagnostics.Custom.ILogger.OpenActivity(LogActivityOptions options, CallerInfo& callerInfo);
    private sealed virtual override ILoggingContext PostSharp.Patterns.Diagnostics.Custom.IContextLocalLogger.OpenActivity(OpenActivityOptions& modreq(System.Runtime.InteropServices.InAttribute) options, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.ResumeActivity(ILoggingContext context, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.SuspendActivity(ILoggingContext context, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.SetWaitDependency(ILoggingContext context, object waited);
    private sealed virtual override bool PostSharp.Patterns.Diagnostics.Custom.ILogger.get_RequiresSuspendResume();
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.IContextLocalLogger.ResumeActivity(ILoggingContext context, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.IContextLocalLogger.SuspendActivity(ILoggingContext context, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.IContextLocalLogger.SetWaitDependency(ILoggingContext context, object waited);
    private sealed virtual override ILogActivityOptions PostSharp.Patterns.Diagnostics.Custom.ILogger.get_ActivityOptions();
    private sealed virtual override LogLevel PostSharp.Patterns.Diagnostics.Custom.ILogActivityOptions.get_ActivityLevel();
    private sealed virtual override LogLevel PostSharp.Patterns.Diagnostics.Custom.ILogActivityOptions.get_FailureLevel();
    private sealed virtual override LogLevel PostSharp.Patterns.Diagnostics.Custom.ILogActivityOptions.get_ExceptionLevel();
    private sealed virtual override Type PostSharp.Patterns.Diagnostics.Custom.ILogger.get_Type();
    private sealed virtual override string PostSharp.Patterns.Diagnostics.Custom.ILogger.get_Role();
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILoggerExceptionHandler.OnInvalidUserCode(CallerInfo& callerInfo, string format, Object[] args);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILoggerExceptionHandler.OnInternalException(Exception exception);
    private sealed virtual override ICustomLogRecordBuilder PostSharp.Patterns.Diagnostics.Custom.IContextLocalLogger.GetRecordBuilder(CustomLogRecordOptions& modreq(System.Runtime.InteropServices.InAttribute) recordInfo, CallerInfo& callerInfo, ILoggingContext context);
    private sealed virtual override ILoggerFactory3 PostSharp.Patterns.Diagnostics.Custom.ILogger3.get_Factory();
    private sealed virtual override IContextLocalLogger PostSharp.Patterns.Diagnostics.Custom.ILogger2.GetContextLocalLogger();
    private sealed virtual override ValueTuple`2<IContextLocalLogger, bool> PostSharp.Patterns.Diagnostics.Custom.ILogger3.GetContextLocalLogger(LogLevel level);
    private sealed virtual override ILoggingContext PostSharp.Patterns.Diagnostics.Custom.ILogger2.get_CurrentContext();
    private sealed virtual override bool PostSharp.Patterns.Diagnostics.Custom.ILogger.IsEnabled(LogLevel level);
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.LogEventData : ValueType {
    [CompilerGeneratedAttribute]
private LogEventMetadata <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Data>k__BackingField;
    public LogEventMetadata Metadata { get; }
    public object Data { get; }
    [ExplicitCrossPackageInternalAttribute]
internal bool HasInheritedProperty { get; }
    private LogEventData(object data, LogEventMetadata metadata);
    internal LogEventData(IReadOnlyList`1<LoggingProperty> properties);
    [CompilerGeneratedAttribute]
public LogEventMetadata get_Metadata();
    [CompilerGeneratedAttribute]
public object get_Data();
    public static LogEventData Create(object data, LogEventMetadata metadata);
    public static LogEventData Create(object data);
    public static LogEventData Create(T data);
    public void VisitProperties(ILoggingPropertyVisitor`1<TVisitorState> visitor, TVisitorState& visitorState, LoggingPropertyVisitorOptions& visitorOptions);
    public IReadOnlyDictionary`2<string, object> ToDictionary();
    internal bool get_HasInheritedProperty();
    [ExplicitCrossPackageInternalAttribute]
internal T GetExpressionModel();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(LogEventData other);
    public static bool op_Equality(LogEventData left, LogEventData right);
    public static bool op_Inequality(LogEventData left, LogEventData right);
    public LogEventData WithAdditionalProperty(string propertyName, T propertyValue, LoggingPropertyOptions& options);
    public virtual string ToString();
}
public class PostSharp.Patterns.Diagnostics.Custom.LogEventMetadata : object {
    private static LogEventMetadata anonymous;
    private static ConcurrentDictionary`2<Type, LogEventMetadata> defaultInstances;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    internal Type ExpressionModelType { get; }
    public LogEventMetadata(string name);
    private static LogEventMetadata();
    private static LogEventMetadata GetDefaultInstanceImpl();
    internal static LogEventMetadata GetDefaultInstance(Type type);
    [CompilerGeneratedAttribute]
public string get_Name();
    public virtual bool HasInheritedProperty(object data);
    protected internal virtual LoggingPropertyOptions GetPropertyOptions(string name);
    internal virtual Type get_ExpressionModelType();
    public virtual void VisitProperties(object data, ILoggingPropertyVisitor`1<TVisitorState> visitor, TVisitorState& visitorState, LoggingPropertyVisitorOptions& modreq(System.Runtime.InteropServices.InAttribute) visitorOptions);
    internal T GetExpressionModel(object data);
}
public abstract class PostSharp.Patterns.Diagnostics.Custom.LogEventMetadata`1 : LogEventMetadata {
    internal Type ExpressionModelType { get; }
    protected LogEventMetadata`1(string name);
    public virtual TExpressionModel GetExpressionModel(object data);
    internal sealed virtual Type get_ExpressionModelType();
}
internal class PostSharp.Patterns.Diagnostics.Custom.LogEventPropertiesMetadata : LogEventMetadata`1<LoggingPropertiesExpressionModel> {
    internal static LogEventPropertiesMetadata Instance;
    private static LogEventPropertiesMetadata();
    public virtual bool HasInheritedProperty(object data);
    public virtual void VisitProperties(object data, ILoggingPropertyVisitor`1<TVisitorState> visitor, TVisitorState& visitorState, LoggingPropertyVisitorOptions& modreq(System.Runtime.InteropServices.InAttribute) visitorOptions);
    public virtual LoggingPropertiesExpressionModel GetExpressionModel(object data);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class PostSharp.Patterns.Diagnostics.Custom.LoggingPropertiesExpressionModel : ValueType {
    private IReadOnlyList`1<LoggingProperty> properties;
    public object Item { get; }
    internal LoggingPropertiesExpressionModel(IReadOnlyList`1<LoggingProperty> properties);
    public object get_Item(string key);
    public int GetInt32(string property, int defaultValue);
    public long GetInt64(string property, long defaultValue);
    public string GetString(string property, string defaultValue);
    public bool Contains(string property);
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.LoggingPropertyOptions : ValueType {
    private Flags flags;
    [CompilerGeneratedAttribute]
private IFormatter <Formatter>k__BackingField;
    public IFormatter Formatter { get; }
    public bool IsIgnored { get; }
    public bool IsRendered { get; }
    public bool IsInherited { get; }
    public bool IsBaggage { get; }
    private LoggingPropertyOptions(Flags flags, IFormatter formatter);
    public LoggingPropertyOptions(bool isRendered, bool isInherited, bool isBaggage, bool isIgnored, IFormatter formatter);
    [CompilerGeneratedAttribute]
public IFormatter get_Formatter();
    public LoggingPropertyOptions WithFormatter(IFormatter formatter);
    public bool get_IsIgnored();
    public LoggingPropertyOptions WithIsIgnored(bool value);
    public bool get_IsRendered();
    public LoggingPropertyOptions WithIsRendered(bool value);
    public bool get_IsInherited();
    public LoggingPropertyOptions WithIsInherited(bool value);
    public bool get_IsBaggage();
    public LoggingPropertyOptions WithIsBaggage(bool value);
}
[AttributeUsageAttribute("128")]
public class PostSharp.Patterns.Diagnostics.Custom.LoggingPropertyOptionsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <IsIgnored>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRendered>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInherited>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBaggage>k__BackingField;
    public bool IsIgnored { get; public set; }
    public bool IsRendered { get; public set; }
    public bool IsInherited { get; public set; }
    public bool IsBaggage { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsIgnored();
    [CompilerGeneratedAttribute]
public void set_IsIgnored(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsRendered();
    [CompilerGeneratedAttribute]
public void set_IsRendered(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsInherited();
    [CompilerGeneratedAttribute]
public void set_IsInherited(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsBaggage();
    [CompilerGeneratedAttribute]
public void set_IsBaggage(bool value);
    public LoggingPropertyOptions ToOptions();
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.LoggingPropertyVisitorOptions : ValueType {
    private Flags flags;
    public bool OnlyInherited { get; }
    public bool IncludeInherited { get; }
    public bool OnlyRendered { get; }
    private LoggingPropertyVisitorOptions(Flags flags);
    public LoggingPropertyVisitorOptions(bool onlyInherited, bool includeInherited, bool onlyRendered);
    public bool get_OnlyInherited();
    public bool get_IncludeInherited();
    public bool get_OnlyRendered();
    public LoggingPropertyVisitorOptions WithOnlyInherited(bool value);
    public LoggingPropertyVisitorOptions WithOnlyRendered(bool value);
    public LoggingPropertyVisitorOptions WithIncludeInherited(bool value);
    private LoggingPropertyVisitorOptions WithFlag(Flags flag, bool value);
}
[RequirePostSharpAttribute("PostSharp.Patterns.Common.Weaver", "AddCallerInfoTask")]
[RequirePostSharpAttribute("PostSharp.Patterns.Diagnostics.AwaitInstrumentationAspectProvider")]
public class PostSharp.Patterns.Diagnostics.Custom.LogLevelSource : object {
    [CompilerGeneratedAttribute]
private LogSource <LogSource>k__BackingField;
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    internal LogSource LogSource { get; }
    public LogLevel Level { get; }
    public bool IsEnabled { get; }
    public LogLevelSource EnabledOrNull { get; }
    internal LogLevelSource(LogSource logSource, LogLevel level);
    [CompilerGeneratedAttribute]
[DebuggerAspectGeneratedCodeAttribute]
private static LogLevelSource();
    public void Write(T& message, WriteMessageOptions& options);
    [EditorBrowsableAttribute("1")]
public void Write(T& message, WriteMessageOptions& options, CallerInfo& callerInfo);
    public void Write(T& message, Exception exception, WriteMessageOptions& options);
    [EditorBrowsableAttribute("1")]
public void Write(T& message, Exception exception, WriteMessageOptions& options, CallerInfo& callerInfo);
    public LogActivity`1<T> OpenActivity(T& description, OpenActivityOptions& options);
    [EditorBrowsableAttribute("1")]
public LogActivity`1<T> OpenActivity(T& description, OpenActivityOptions& options, CallerInfo& callerInfo);
    public void LogActivity(TDescription& description, Action action, OpenActivityOptions& options);
    [EditorBrowsableAttribute("1")]
public void LogActivity(TDescription& description, Action action, OpenActivityOptions& options, CallerInfo& callerInfo);
    public TResult LogActivity(TDescription& description, Func`1<TResult> action, OpenActivityOptions& options);
    [EditorBrowsableAttribute("1")]
public TResult LogActivity(TDescription& description, Func`1<TResult> action, OpenActivityOptions& options, CallerInfo& callerInfo);
    public Task LogActivityAsync(TDescription& description, Func`1<Task> action, OpenActivityOptions& options);
    [EditorBrowsableAttribute("1")]
public Task LogActivityAsync(TDescription& description, Func`1<Task> action, OpenActivityOptions& options, CallerInfo& callerInfo);
    [AsyncStateMachineAttribute("PostSharp.Patterns.Diagnostics.Custom.LogLevelSource/<LogActivityAsyncImpl>d__13`1")]
private Task LogActivityAsyncImpl(TDescription description, Func`1<Task> action, OpenActivityOptions options, CallerInfo callerInfo);
    public Task`1<TResult> LogActivityAsync(TDescription& description, Func`1<Task`1<TResult>> action, OpenActivityOptions& options);
    [EditorBrowsableAttribute("1")]
public Task`1<TResult> LogActivityAsync(TDescription& description, Func`1<Task`1<TResult>> action, OpenActivityOptions& options, CallerInfo& callerInfo);
    [AsyncStateMachineAttribute("PostSharp.Patterns.Diagnostics.Custom.LogLevelSource/<LogActivityAsyncImpl>d__16`2")]
private Task`1<TResult> LogActivityAsyncImpl(TDescription description, Func`1<Task`1<TResult>> action, OpenActivityOptions options, CallerInfo callerInfo);
    [CompilerGeneratedAttribute]
internal LogSource get_LogSource();
    [CompilerGeneratedAttribute]
public LogLevel get_Level();
    public bool get_IsEnabled();
    public LogLevelSource get_EnabledOrNull();
}
[ExtensionAttribute]
internal static class PostSharp.Patterns.Diagnostics.Custom.Messages.DebugMessageFormatter : object {
    [ExtensionAttribute]
public static string Format(T message);
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.Messages.FormattedMessage : ValueType {
    private string text;
    internal FormattedMessage(string text);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.Messages.IMessage.Write(ICustomLogRecordBuilder recordBuilder, CustomLogRecordItem item);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.Messages.FormattedMessage`1 : ValueType {
    private string formattingString;
    private T1 arg1;
    internal FormattedMessage`1(string formattingString, T1 arg1);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.Messages.IMessage.Write(ICustomLogRecordBuilder recordBuilder, CustomLogRecordItem item);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.Messages.FormattedMessage`10 : ValueType {
    private string formattingString;
    private T1 arg1;
    private T2 arg2;
    private T3 arg3;
    private T4 arg4;
    private T5 arg5;
    private T6 arg6;
    private T7 arg7;
    private T8 arg8;
    private T9 arg9;
    private T10 arg10;
    internal FormattedMessage`10(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.Messages.IMessage.Write(ICustomLogRecordBuilder recordBuilder, CustomLogRecordItem item);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.Messages.FormattedMessage`2 : ValueType {
    private string formattingString;
    private T1 arg1;
    private T2 arg2;
    internal FormattedMessage`2(string formattingString, T1 arg1, T2 arg2);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.Messages.IMessage.Write(ICustomLogRecordBuilder recordBuilder, CustomLogRecordItem item);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.Messages.FormattedMessage`3 : ValueType {
    private string formattingString;
    private T1 arg1;
    private T2 arg2;
    private T3 arg3;
    internal FormattedMessage`3(string formattingString, T1 arg1, T2 arg2, T3 arg3);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.Messages.IMessage.Write(ICustomLogRecordBuilder recordBuilder, CustomLogRecordItem item);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.Messages.FormattedMessage`4 : ValueType {
    private string formattingString;
    private T1 arg1;
    private T2 arg2;
    private T3 arg3;
    private T4 arg4;
    internal FormattedMessage`4(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.Messages.IMessage.Write(ICustomLogRecordBuilder recordBuilder, CustomLogRecordItem item);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.Messages.FormattedMessage`5 : ValueType {
    private string formattingString;
    private T1 arg1;
    private T2 arg2;
    private T3 arg3;
    private T4 arg4;
    private T5 arg5;
    internal FormattedMessage`5(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.Messages.IMessage.Write(ICustomLogRecordBuilder recordBuilder, CustomLogRecordItem item);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.Messages.FormattedMessage`6 : ValueType {
    private string formattingString;
    private T1 arg1;
    private T2 arg2;
    private T3 arg3;
    private T4 arg4;
    private T5 arg5;
    private T6 arg6;
    internal FormattedMessage`6(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.Messages.IMessage.Write(ICustomLogRecordBuilder recordBuilder, CustomLogRecordItem item);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.Messages.FormattedMessage`7 : ValueType {
    private string formattingString;
    private T1 arg1;
    private T2 arg2;
    private T3 arg3;
    private T4 arg4;
    private T5 arg5;
    private T6 arg6;
    private T7 arg7;
    internal FormattedMessage`7(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.Messages.IMessage.Write(ICustomLogRecordBuilder recordBuilder, CustomLogRecordItem item);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.Messages.FormattedMessage`8 : ValueType {
    private string formattingString;
    private T1 arg1;
    private T2 arg2;
    private T3 arg3;
    private T4 arg4;
    private T5 arg5;
    private T6 arg6;
    private T7 arg7;
    private T8 arg8;
    internal FormattedMessage`8(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.Messages.IMessage.Write(ICustomLogRecordBuilder recordBuilder, CustomLogRecordItem item);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.Messages.FormattedMessage`9 : ValueType {
    private string formattingString;
    private T1 arg1;
    private T2 arg2;
    private T3 arg3;
    private T4 arg4;
    private T5 arg5;
    private T6 arg6;
    private T7 arg7;
    private T8 arg8;
    private T9 arg9;
    internal FormattedMessage`9(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.Messages.IMessage.Write(ICustomLogRecordBuilder recordBuilder, CustomLogRecordItem item);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.Messages.FormattedMessageArray : ValueType {
    private string formattingString;
    private Object[] args;
    internal FormattedMessageArray(string formattingString, Object[] args);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.Messages.IMessage.Write(ICustomLogRecordBuilder recordBuilder, CustomLogRecordItem item);
    public virtual string ToString();
}
public interface PostSharp.Patterns.Diagnostics.Custom.Messages.IMessage {
    public abstract virtual void Write(ICustomLogRecordBuilder builder, CustomLogRecordItem kind);
}
internal static class PostSharp.Patterns.Diagnostics.Custom.Messages.MessageHelper : object {
    public static void Write(T& message, ICustomLogRecordBuilder recordBuilder, CustomLogRecordItem item);
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.Messages.SemanticMessage : ValueType {
    private string messageName;
    internal SemanticMessage(string messageName);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.Messages.IMessage.Write(ICustomLogRecordBuilder builder, CustomLogRecordItem item);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.Messages.SemanticMessage`1 : ValueType {
    private string messageName;
    private string name1;
    private T1 value1;
    internal SemanticMessage`1(string messageName, string name1, T1 value1);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.Messages.IMessage.Write(ICustomLogRecordBuilder recordBuilder, CustomLogRecordItem item);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.Messages.SemanticMessage`10 : ValueType {
    private string messageName;
    private string name1;
    private string name2;
    private string name3;
    private string name4;
    private string name5;
    private string name6;
    private string name7;
    private string name8;
    private string name9;
    private string name10;
    private T1 value1;
    private T2 value2;
    private T3 value3;
    private T4 value4;
    private T5 value5;
    private T6 value6;
    private T7 value7;
    private T8 value8;
    private T9 value9;
    private T10 value10;
    internal SemanticMessage`10(string messageName, string name1, T1 value1, string name2, T2 value2, string name3, T3 value3, string name4, T4 value4, string name5, T5 value5, string name6, T6 value6, string name7, T7 value7, string name8, T8 value8, string name9, T9 value9, string name10, T10 value10);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.Messages.IMessage.Write(ICustomLogRecordBuilder recordBuilder, CustomLogRecordItem item);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.Messages.SemanticMessage`2 : ValueType {
    private string messageName;
    private string name1;
    private string name2;
    private T1 value1;
    private T2 value2;
    internal SemanticMessage`2(string messageName, string name1, T1 value1, string name2, T2 value2);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.Messages.IMessage.Write(ICustomLogRecordBuilder recordBuilder, CustomLogRecordItem item);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.Messages.SemanticMessage`3 : ValueType {
    private string messageName;
    private string name1;
    private string name2;
    private string name3;
    private T1 value1;
    private T2 value2;
    private T3 value3;
    internal SemanticMessage`3(string messageName, string name1, T1 value1, string name2, T2 value2, string name3, T3 value3);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.Messages.IMessage.Write(ICustomLogRecordBuilder recordBuilder, CustomLogRecordItem item);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.Messages.SemanticMessage`4 : ValueType {
    private string messageName;
    private string name1;
    private string name2;
    private string name3;
    private string name4;
    private T1 value1;
    private T2 value2;
    private T3 value3;
    private T4 value4;
    internal SemanticMessage`4(string messageName, string name1, T1 value1, string name2, T2 value2, string name3, T3 value3, string name4, T4 value4);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.Messages.IMessage.Write(ICustomLogRecordBuilder recordBuilder, CustomLogRecordItem item);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.Messages.SemanticMessage`5 : ValueType {
    private string messageName;
    private string name1;
    private string name2;
    private string name3;
    private string name4;
    private string name5;
    private T1 value1;
    private T2 value2;
    private T3 value3;
    private T4 value4;
    private T5 value5;
    internal SemanticMessage`5(string messageName, string name1, T1 value1, string name2, T2 value2, string name3, T3 value3, string name4, T4 value4, string name5, T5 value5);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.Messages.IMessage.Write(ICustomLogRecordBuilder recordBuilder, CustomLogRecordItem item);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.Messages.SemanticMessage`6 : ValueType {
    private string messageName;
    private string name1;
    private string name2;
    private string name3;
    private string name4;
    private string name5;
    private string name6;
    private T1 value1;
    private T2 value2;
    private T3 value3;
    private T4 value4;
    private T5 value5;
    private T6 value6;
    internal SemanticMessage`6(string messageName, string name1, T1 value1, string name2, T2 value2, string name3, T3 value3, string name4, T4 value4, string name5, T5 value5, string name6, T6 value6);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.Messages.IMessage.Write(ICustomLogRecordBuilder recordBuilder, CustomLogRecordItem item);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.Messages.SemanticMessage`7 : ValueType {
    private string messageName;
    private string name1;
    private string name2;
    private string name3;
    private string name4;
    private string name5;
    private string name6;
    private string name7;
    private T1 value1;
    private T2 value2;
    private T3 value3;
    private T4 value4;
    private T5 value5;
    private T6 value6;
    private T7 value7;
    internal SemanticMessage`7(string messageName, string name1, T1 value1, string name2, T2 value2, string name3, T3 value3, string name4, T4 value4, string name5, T5 value5, string name6, T6 value6, string name7, T7 value7);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.Messages.IMessage.Write(ICustomLogRecordBuilder recordBuilder, CustomLogRecordItem item);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.Messages.SemanticMessage`8 : ValueType {
    private string messageName;
    private string name1;
    private string name2;
    private string name3;
    private string name4;
    private string name5;
    private string name6;
    private string name7;
    private string name8;
    private T1 value1;
    private T2 value2;
    private T3 value3;
    private T4 value4;
    private T5 value5;
    private T6 value6;
    private T7 value7;
    private T8 value8;
    internal SemanticMessage`8(string messageName, string name1, T1 value1, string name2, T2 value2, string name3, T3 value3, string name4, T4 value4, string name5, T5 value5, string name6, T6 value6, string name7, T7 value7, string name8, T8 value8);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.Messages.IMessage.Write(ICustomLogRecordBuilder recordBuilder, CustomLogRecordItem item);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.Messages.SemanticMessage`9 : ValueType {
    private string messageName;
    private string name1;
    private string name2;
    private string name3;
    private string name4;
    private string name5;
    private string name6;
    private string name7;
    private string name8;
    private string name9;
    private T1 value1;
    private T2 value2;
    private T3 value3;
    private T4 value4;
    private T5 value5;
    private T6 value6;
    private T7 value7;
    private T8 value8;
    private T9 value9;
    internal SemanticMessage`9(string messageName, string name1, T1 value1, string name2, T2 value2, string name3, T3 value3, string name4, T4 value4, string name5, T5 value5, string name6, T6 value6, string name7, T7 value7, string name8, T8 value8, string name9, T9 value9);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.Messages.IMessage.Write(ICustomLogRecordBuilder recordBuilder, CustomLogRecordItem item);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Custom.Messages.SemanticMessageArray : ValueType {
    private string messageName;
    private IReadOnlyList`1<ValueTuple`2<string, object>> parameters;
    internal SemanticMessageArray(string messageName, IReadOnlyList`1<ValueTuple`2<string, object>> parameters);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.Messages.IMessage.Write(ICustomLogRecordBuilder builder, CustomLogRecordItem item);
    public virtual string ToString();
}
internal class PostSharp.Patterns.Diagnostics.Custom.NullLogger : object {
    private static bool warningEmitted;
    private string PostSharp.Patterns.Diagnostics.Custom.ILogger.Role { get; }
    private Type PostSharp.Patterns.Diagnostics.Custom.ILogger.Type { get; }
    private bool PostSharp.Patterns.Diagnostics.Custom.ILogger.RequiresSuspendResume { get; }
    public ILoggingContext CurrentContext { get; }
    private bool PostSharp.Patterns.Diagnostics.Contexts.ILoggingContext.IsDisposed { get; }
    private int PostSharp.Patterns.Diagnostics.Contexts.ILoggingContext.RecycleId { get; }
    private LogLevel PostSharp.Patterns.Diagnostics.Custom.ILogActivityOptions.ActivityLevel { get; }
    private LogLevel PostSharp.Patterns.Diagnostics.Custom.ILogActivityOptions.FailureLevel { get; }
    private LogLevel PostSharp.Patterns.Diagnostics.Custom.ILogActivityOptions.ExceptionLevel { get; }
    [ObsoleteAttribute]
private ILogActivityOptions PostSharp.Patterns.Diagnostics.Custom.ILogger.ActivityOptions { get; }
    private bool PostSharp.Patterns.Diagnostics.Contexts.ILoggingContext.IsAsync { get; }
    private string PostSharp.Patterns.Diagnostics.Contexts.ILoggingContext.SyntheticId { get; }
    private ILoggerFactory2 PostSharp.Patterns.Diagnostics.Custom.ILogger2.Factory { get; }
    private ILoggerFactory3 PostSharp.Patterns.Diagnostics.Custom.ILogger3.Factory { get; }
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.Write(ILoggingContext context, LogLevel level, LogRecordKind logRecordKind, string text, T1 arg1, Exception exception, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.Write(ILoggingContext context, LogLevel level, LogRecordKind logRecordKind, string text, T1 arg1, T2 arg2, Exception exception, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.Write(ILoggingContext context, LogLevel level, LogRecordKind logRecordKind, string text, T1 arg1, T2 arg2, T3 arg3, Exception exception, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.Write(ILoggingContext context, LogLevel level, LogRecordKind logRecordKind, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, Exception exception, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.Write(ILoggingContext context, LogLevel level, LogRecordKind logRecordKind, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, Exception exception, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.Write(ILoggingContext context, LogLevel level, LogRecordKind logRecordKind, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, Exception exception, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.Write(ILoggingContext context, LogLevel level, LogRecordKind logRecordKind, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, Exception exception, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.Write(ILoggingContext context, LogLevel level, LogRecordKind logRecordKind, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, Exception exception, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.Write(ILoggingContext context, LogLevel level, LogRecordKind logRecordKind, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, Exception exception, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.Write(ILoggingContext context, LogLevel level, LogRecordKind logRecordKind, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, Exception exception, CallerInfo& callerInfo);
    private sealed virtual override string PostSharp.Patterns.Diagnostics.Custom.ILogger.get_Role();
    private sealed virtual override Type PostSharp.Patterns.Diagnostics.Custom.ILogger.get_Type();
    private sealed virtual override bool PostSharp.Patterns.Diagnostics.Custom.ILogger.get_RequiresSuspendResume();
    private sealed virtual override ILogger PostSharp.Patterns.Diagnostics.Custom.ILoggerFactory.GetLogger(string role, Type type);
    private sealed virtual override bool PostSharp.Patterns.Diagnostics.Custom.ILogger.IsEnabled(LogLevel level);
    private sealed virtual override bool PostSharp.Patterns.Diagnostics.Custom.IContextLocalLogger.IsEnabled(LogLevel level);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.Write(ILoggingContext context, LogLevel level, LogRecordKind logRecordKind, string text, Exception exception, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.Write(ILoggingContext context, LogLevel level, LogRecordKind recordKind, string text, Object[] args, Exception exception, CallerInfo& callerInfo);
    private sealed virtual override ILoggingContext PostSharp.Patterns.Diagnostics.Custom.ILogger.OpenActivity(LogActivityOptions options, CallerInfo& callerInfo);
    private sealed virtual override ILoggingContext PostSharp.Patterns.Diagnostics.Custom.IContextLocalLogger.OpenActivity(OpenActivityOptions& modreq(System.Runtime.InteropServices.InAttribute) options, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.ResumeActivity(ILoggingContext context, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.SuspendActivity(ILoggingContext context, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.IContextLocalLogger.ResumeActivity(ILoggingContext context, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.IContextLocalLogger.SuspendActivity(ILoggingContext context, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.IContextLocalLogger.SetWaitDependency(ILoggingContext context, object waited);
    public sealed virtual ILoggingContext get_CurrentContext();
    private sealed virtual override bool PostSharp.Patterns.Diagnostics.Contexts.ILoggingContext.get_IsDisposed();
    private sealed virtual override int PostSharp.Patterns.Diagnostics.Contexts.ILoggingContext.get_RecycleId();
    private sealed virtual override LogLevel PostSharp.Patterns.Diagnostics.Custom.ILogActivityOptions.get_ActivityLevel();
    private sealed virtual override LogLevel PostSharp.Patterns.Diagnostics.Custom.ILogActivityOptions.get_FailureLevel();
    private sealed virtual override LogLevel PostSharp.Patterns.Diagnostics.Custom.ILogActivityOptions.get_ExceptionLevel();
    private sealed virtual override ILogActivityOptions PostSharp.Patterns.Diagnostics.Custom.ILogger.get_ActivityOptions();
    private sealed virtual override bool PostSharp.Patterns.Diagnostics.Contexts.ILoggingContext.get_IsAsync();
    private sealed virtual override string PostSharp.Patterns.Diagnostics.Contexts.ILoggingContext.get_SyntheticId();
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Contexts.ILoggingContext.ForEachProperty(LoggingPropertyVisitor`1<object> visitor, bool includeAncestors);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Contexts.ILoggingContext.ForEachProperty(LoggingPropertyVisitor`1<T> visitor, T& state, bool includeAncestors);
    private sealed virtual override ILoggerFactory2 PostSharp.Patterns.Diagnostics.Custom.ILogger2.get_Factory();
    private sealed virtual override ValueTuple`2<IContextLocalLogger, bool> PostSharp.Patterns.Diagnostics.Custom.ILogger3.GetContextLocalLogger(LogLevel level);
    private static void EmitWarning(LogLevel level);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILogger.SetWaitDependency(ILoggingContext context, object waited);
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ICustomLogRecordBuilder.WriteCustomParameter(int index, CharSpan& modreq(System.Runtime.InteropServices.InAttribute) parameterName, T value, CustomLogParameterOptions& modreq(System.Runtime.InteropServices.InAttribute) format);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ICustomLogRecordBuilder.WriteCustomString(CharSpan& modreq(System.Runtime.InteropServices.InAttribute) str);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ICustomLogRecordBuilder.SetException(Exception e);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ICustomLogRecordBuilder.SetExecutionTime(double executionTime, bool isOvertime);
    private sealed virtual override ICustomLogRecordBuilder PostSharp.Patterns.Diagnostics.Custom.IContextLocalLogger.GetRecordBuilder(CustomLogRecordOptions& modreq(System.Runtime.InteropServices.InAttribute) recordInfo, CallerInfo& callerInfo, ILoggingContext context);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILoggerExceptionHandler.OnInvalidUserCode(CallerInfo& callerInfo, string format, Object[] args);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ILoggerExceptionHandler.OnInternalException(Exception exception);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ICustomLogRecordBuilder.Complete();
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ICustomLogRecordBuilder.BeginWriteItem(CustomLogRecordItem item, CustomLogRecordTextOptions& modreq(System.Runtime.InteropServices.InAttribute) options);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.Custom.ICustomLogRecordBuilder.EndWriteItem(CustomLogRecordItem item);
    private sealed virtual override ILoggerFactory3 PostSharp.Patterns.Diagnostics.Custom.ILogger3.get_Factory();
    private sealed virtual override IContextLocalLogger PostSharp.Patterns.Diagnostics.Custom.ILogger2.GetContextLocalLogger();
    private sealed virtual override ILoggerFactory2 PostSharp.Patterns.Diagnostics.Custom.ILoggerFactoryProvider.GetLoggerFactory(string role);
    private sealed virtual override ILogger2 PostSharp.Patterns.Diagnostics.Custom.ILoggerFactory2.GetLogger(Type type);
    private sealed virtual override ILogger3 PostSharp.Patterns.Diagnostics.Custom.ILoggerFactory3.GetLogger(Type type);
    public sealed virtual ILogger3 GetLogger(string sourceName);
    public sealed virtual ILoggerFactory3 GetLoggerFactory3(string role);
}
internal class PostSharp.Patterns.Diagnostics.Custom.TraceSourceLogger : LegacySourceLogger {
    private TraceSource traceSource;
    private static ConcurrentDictionary`2<string, TraceSource> traceSources;
    [CompilerGeneratedAttribute]
private ILoggerFactory2 <Factory>k__BackingField;
    public ILoggerFactory2 Factory { get; }
    internal TraceSourceLogger(ILoggerFactory3 factory, string role, Type type);
    private static TraceSourceLogger();
    [CompilerGeneratedAttribute]
public virtual ILoggerFactory2 get_Factory();
    private static string GetSourceName(string role);
    public static TraceSource GetTraceSource(string role);
    public virtual bool IsEnabled(LogLevel level);
    protected virtual void Write(LogLevel level, LogRecordKind recordKind, string text, Exception exception);
    private static TraceEventType GetTraceEventType(LogLevel level);
}
internal class PostSharp.Patterns.Diagnostics.Custom.TraceSourceLoggerFactory : object {
    private sealed virtual override ILogger PostSharp.Patterns.Diagnostics.Custom.ILoggerFactory.GetLogger(string role, Type type);
    private sealed virtual override ILoggerFactory2 PostSharp.Patterns.Diagnostics.Custom.ILoggerFactoryProvider.GetLoggerFactory(string role);
    private sealed virtual override ILoggerFactory3 PostSharp.Patterns.Diagnostics.Custom.ILoggerFactoryProvider3.GetLoggerFactory3(string role);
}
public static class PostSharp.Patterns.Diagnostics.FormattedMessageBuilder : object {
    public static FormattedMessageArray Formatted(string formattingString, Object[] args);
    public static FormattedMessage Formatted(string text);
    public static FormattedMessage`1<T1> Formatted(string formattingString, T1 arg1);
    public static FormattedMessage`2<T1, T2> Formatted(string formattingString, T1 arg1, T2 arg2);
    public static FormattedMessage`3<T1, T2, T3> Formatted(string formattingString, T1 arg1, T2 arg2, T3 arg3);
    public static FormattedMessage`4<T1, T2, T3, T4> Formatted(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public static FormattedMessage`5<T1, T2, T3, T4, T5> Formatted(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public static FormattedMessage`6<T1, T2, T3, T4, T5, T6> Formatted(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    public static FormattedMessage`7<T1, T2, T3, T4, T5, T6, T7> Formatted(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    public static FormattedMessage`8<T1, T2, T3, T4, T5, T6, T7, T8> Formatted(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    public static FormattedMessage`9<T1, T2, T3, T4, T5, T6, T7, T8, T9> Formatted(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    public static FormattedMessage`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Formatted(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
}
public interface PostSharp.Patterns.Diagnostics.ILogActivity {
    public ILoggingContext Context { get; }
    public abstract virtual ILoggingContext get_Context();
    public abstract virtual void SetSuccess(CloseActivityOptions& modreq(System.Runtime.InteropServices.InAttribute) options);
    [EditorBrowsableAttribute("1")]
public abstract virtual void SetSuccess(CloseActivityOptions& modreq(System.Runtime.InteropServices.InAttribute) options, CallerInfo& callerInfo);
    public abstract virtual void SetResult(TResult result, CloseActivityOptions& modreq(System.Runtime.InteropServices.InAttribute) options);
    [EditorBrowsableAttribute("1")]
public abstract virtual void SetResult(TResult result, CloseActivityOptions& modreq(System.Runtime.InteropServices.InAttribute) options, CallerInfo& callerInfo);
    public abstract virtual void SetOutcome(LogLevel level, TMessage& modreq(System.Runtime.InteropServices.InAttribute) message, Exception exception, CloseActivityOptions& modreq(System.Runtime.InteropServices.InAttribute) options);
    [EditorBrowsableAttribute("1")]
public abstract virtual void SetOutcome(LogLevel level, TMessage& modreq(System.Runtime.InteropServices.InAttribute) message, Exception exception, CloseActivityOptions& modreq(System.Runtime.InteropServices.InAttribute) options, CallerInfo& callerInfo);
    public abstract virtual void SetException(Exception exception, CloseActivityOptions& modreq(System.Runtime.InteropServices.InAttribute) options);
    [EditorBrowsableAttribute("1")]
public abstract virtual void SetException(Exception exception, CloseActivityOptions& modreq(System.Runtime.InteropServices.InAttribute) options, CallerInfo& callerInfo);
    public abstract virtual void Resume();
    [EditorBrowsableAttribute("1")]
public abstract virtual void Resume(CallerInfo& callerInfo);
    public abstract virtual void Suspend();
    [EditorBrowsableAttribute("1")]
public abstract virtual void Suspend(CallerInfo& callerInfo);
}
[RequirePostSharpAttribute("PostSharp.Patterns.Common.Weaver", "AddCallerInfoTask")]
public class PostSharp.Patterns.Diagnostics.LogActivity : Logger {
    [CompilerGeneratedAttribute]
private ILoggingContext <Context>k__BackingField;
    private LogLevel ResolvedSuccessLevel { get; }
    private LogLevel ResolvedExceptionLevel { get; }
    private LogLevel ResolvedFailureLevel { get; }
    public bool IsValid { get; }
    public ILoggingContext Context { get; private set; }
    public LogActivity(ILogger logger, ILoggingContext context);
    private LogLevel get_ResolvedSuccessLevel();
    private LogLevel get_ResolvedExceptionLevel();
    private LogLevel get_ResolvedFailureLevel();
    public bool get_IsValid();
    private bool RequiresCustomActivity(CallerInfo& callerInfo, bool requiresAsync);
    public void SetSuccess();
    [EditorBrowsableAttribute("1")]
public void SetSuccess(CallerInfo& callerInfo);
    public void SetSuccess(string text);
    [EditorBrowsableAttribute("1")]
public void SetSuccess(string text, CallerInfo& callerInfo);
    public void SetSuccess(string text, Object[] args);
    [EditorBrowsableAttribute("1")]
public void SetSuccess(string text, Object[] args, CallerInfo& callerInfo);
    public void SetFailure();
    [EditorBrowsableAttribute("1")]
public void SetFailure(CallerInfo& callerInfo);
    public void SetFailure(string text);
    [EditorBrowsableAttribute("1")]
public void SetFailure(string text, CallerInfo& callerInfo);
    public void SetFailure(string text, Object[] args);
    [EditorBrowsableAttribute("1")]
public void SetFailure(string text, Object[] args, CallerInfo& callerInfo);
    public bool SetException(Exception exception);
    [EditorBrowsableAttribute("1")]
public bool SetException(Exception exception, CallerInfo& callerInfo);
    private void Close(CallerInfo& callerInfo);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public void Resume();
    [EditorBrowsableAttribute("1")]
public void Resume(CallerInfo& callerInfo);
    public void Suspend();
    [EditorBrowsableAttribute("1")]
public void Suspend(CallerInfo& callerInfo);
    [CompilerGeneratedAttribute]
public ILoggingContext get_Context();
    [CompilerGeneratedAttribute]
private void set_Context(ILoggingContext value);
    public void SetSuccess(string formattingString, T1 arg1);
    [EditorBrowsableAttribute("1")]
public void SetSuccess(string formattingString, T1 arg1, CallerInfo& callerInfo);
    public void SetFailure(string formattingString, T1 arg1);
    [EditorBrowsableAttribute("1")]
public void SetFailure(string formattingString, T1 arg1, CallerInfo& callerInfo);
    public void SetSuccess(string formattingString, T1 arg1, T2 arg2);
    [EditorBrowsableAttribute("1")]
public void SetSuccess(string formattingString, T1 arg1, T2 arg2, CallerInfo& callerInfo);
    public void SetFailure(string formattingString, T1 arg1, T2 arg2);
    [EditorBrowsableAttribute("1")]
public void SetFailure(string formattingString, T1 arg1, T2 arg2, CallerInfo& callerInfo);
    public void SetSuccess(string formattingString, T1 arg1, T2 arg2, T3 arg3);
    [EditorBrowsableAttribute("1")]
public void SetSuccess(string formattingString, T1 arg1, T2 arg2, T3 arg3, CallerInfo& callerInfo);
    public void SetFailure(string formattingString, T1 arg1, T2 arg2, T3 arg3);
    [EditorBrowsableAttribute("1")]
public void SetFailure(string formattingString, T1 arg1, T2 arg2, T3 arg3, CallerInfo& callerInfo);
    public void SetSuccess(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [EditorBrowsableAttribute("1")]
public void SetSuccess(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, CallerInfo& callerInfo);
    public void SetFailure(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [EditorBrowsableAttribute("1")]
public void SetFailure(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, CallerInfo& callerInfo);
    public void SetSuccess(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [EditorBrowsableAttribute("1")]
public void SetSuccess(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, CallerInfo& callerInfo);
    public void SetFailure(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [EditorBrowsableAttribute("1")]
public void SetFailure(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, CallerInfo& callerInfo);
    public void SetSuccess(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [EditorBrowsableAttribute("1")]
public void SetSuccess(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, CallerInfo& callerInfo);
    public void SetFailure(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [EditorBrowsableAttribute("1")]
public void SetFailure(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, CallerInfo& callerInfo);
    public void SetSuccess(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    [EditorBrowsableAttribute("1")]
public void SetSuccess(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, CallerInfo& callerInfo);
    public void SetFailure(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    [EditorBrowsableAttribute("1")]
public void SetFailure(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, CallerInfo& callerInfo);
    public void SetSuccess(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    [EditorBrowsableAttribute("1")]
public void SetSuccess(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, CallerInfo& callerInfo);
    public void SetFailure(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    [EditorBrowsableAttribute("1")]
public void SetFailure(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, CallerInfo& callerInfo);
    public void SetSuccess(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    [EditorBrowsableAttribute("1")]
public void SetSuccess(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, CallerInfo& callerInfo);
    public void SetFailure(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    [EditorBrowsableAttribute("1")]
public void SetFailure(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, CallerInfo& callerInfo);
    public void SetSuccess(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    [EditorBrowsableAttribute("1")]
public void SetSuccess(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, CallerInfo& callerInfo);
    public void SetFailure(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    [EditorBrowsableAttribute("1")]
public void SetFailure(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, CallerInfo& callerInfo);
}
[IsReadOnlyAttribute]
[RequirePostSharpAttribute("PostSharp.Patterns.Common.Weaver", "AddCallerInfoTask")]
public class PostSharp.Patterns.Diagnostics.LogActivity`1 : ValueType {
    private TActivityDescription description;
    [CompilerGeneratedAttribute]
private IContextLocalLogger <Logger>k__BackingField;
    private LogLevels levels;
    [CompilerGeneratedAttribute]
private ILoggingContext <Context>k__BackingField;
    internal IContextLocalLogger Logger { get; }
    public ILoggingContext Context { get; }
    internal LogActivity`1(IContextLocalLogger logger, LogLevels levels, ILoggingContext context, TActivityDescription& description);
    [CompilerGeneratedAttribute]
internal IContextLocalLogger get_Logger();
    [CompilerGeneratedAttribute]
public sealed virtual ILoggingContext get_Context();
    private void SetOutcomeImpl(LogLevel level, TMessage& message, Exception exception, CloseActivityOptions& options, CallerInfo& callerInfo, int skipFrames);
    public sealed virtual void Dispose();
    public void SetSuccess(CloseActivityOptions& options);
    [EditorBrowsableAttribute("1")]
public void SetSuccess(CloseActivityOptions& options, CallerInfo& callerInfo);
    public void SetResult(TResult result, CloseActivityOptions& options);
    [EditorBrowsableAttribute("1")]
public void SetResult(TResult result, CloseActivityOptions& options, CallerInfo& callerInfo);
    public void SetOutcome(LogLevel level, TMessage& message, Exception exception, CloseActivityOptions& options);
    [EditorBrowsableAttribute("1")]
public void SetOutcome(LogLevel level, TMessage& message, Exception exception, CloseActivityOptions& options, CallerInfo& callerInfo);
    public void SetException(Exception exception, CloseActivityOptions& options);
    [EditorBrowsableAttribute("1")]
public void SetException(Exception exception, CloseActivityOptions& options, CallerInfo& callerInfo);
    public sealed virtual void Resume();
    [EditorBrowsableAttribute("1")]
public sealed virtual void Resume(CallerInfo& callerInfo);
    public sealed virtual void Suspend();
    [EditorBrowsableAttribute("1")]
public sealed virtual void Suspend(CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.ILogActivity.SetSuccess(CloseActivityOptions& modreq(System.Runtime.InteropServices.InAttribute) options);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.ILogActivity.SetSuccess(CloseActivityOptions& modreq(System.Runtime.InteropServices.InAttribute) options, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.ILogActivity.SetResult(TResult result, CloseActivityOptions& modreq(System.Runtime.InteropServices.InAttribute) options);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.ILogActivity.SetResult(TResult result, CloseActivityOptions& modreq(System.Runtime.InteropServices.InAttribute) options, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.ILogActivity.SetOutcome(LogLevel level, TMessage& modreq(System.Runtime.InteropServices.InAttribute) message, Exception exception, CloseActivityOptions& modreq(System.Runtime.InteropServices.InAttribute) options);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.ILogActivity.SetOutcome(LogLevel level, TMessage& modreq(System.Runtime.InteropServices.InAttribute) message, Exception exception, CloseActivityOptions& modreq(System.Runtime.InteropServices.InAttribute) options, CallerInfo& callerInfo);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.ILogActivity.SetException(Exception exception, CloseActivityOptions& modreq(System.Runtime.InteropServices.InAttribute) options);
    private sealed virtual override void PostSharp.Patterns.Diagnostics.ILogActivity.SetException(Exception exception, CloseActivityOptions& modreq(System.Runtime.InteropServices.InAttribute) options, CallerInfo& callerInfo);
}
public enum PostSharp.Patterns.Diagnostics.LogActivityKind : Enum {
    public int value__;
    public static LogActivityKind Default;
    public static LogActivityKind TaskLauncher;
    public static LogActivityKind Task;
    public static LogActivityKind Wait;
    public static LogActivityKind OutgoingRequest;
    public static LogActivityKind IncomingRequest;
    public static LogActivityKind Transaction;
}
public class PostSharp.Patterns.Diagnostics.LogActivityOptions : ValueType {
    private byte kind;
    private Flags flags;
    public static LogActivityOptions Default { get; }
    public LogActivityKind Kind { get; public set; }
    public bool IsAsync { get; internal set; }
    public static LogActivityOptions get_Default();
    public LogActivityKind get_Kind();
    public void set_Kind(LogActivityKind value);
    public bool get_IsAsync();
    internal void set_IsAsync(bool value);
}
[RequirePostSharpAttribute("PostSharp.Patterns.Diagnostics.AwaitInstrumentationAspectProvider")]
[RequirePostSharpAttribute("PostSharp.Patterns.Common.Weaver", "AddCallerInfoTask")]
public class PostSharp.Patterns.Diagnostics.Logger : object {
    internal ILogger logger;
    internal static CallerInfo nullRecordInfo;
    private LogActivity nullActivity;
    private protected LogLevel DefaultLevel { get; }
    public bool IsOpenActivityEnabled { get; }
    internal ILoggerExceptionHandler ExceptionHandler { get; }
    private protected Logger(ILogger logger);
    private static Logger();
    private LogActivity CreateActivity(ILoggingContext context);
    private LogActivity GetNullActivity();
    private protected LogLevel get_DefaultLevel();
    private void DisposeSafe(IDisposable disposable);
    public bool get_IsOpenActivityEnabled();
    [ObsoleteAttribute("Use the LogSource class with new developments. Disable the warning with #pragma for existing code.")]
public static Logger GetLogger(string role, Type type);
    [ObsoleteAttribute("Use the LogSource class with new developments. Disable the warning with #pragma for existing code.")]
public static Logger GetLogger(string role);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use the LogSource class.")]
public static Logger GetLogger(string role, CallerInfo& callerInfo);
    internal ILoggerExceptionHandler get_ExceptionHandler();
    private bool ValidateLogger(LogLevel level);
    public void Write(LogLevel level, string text);
    [EditorBrowsableAttribute("1")]
public void Write(LogLevel level, string text, CallerInfo& callerInfo);
    public void Write(LogLevel level, string text, Object[] args);
    [EditorBrowsableAttribute("1")]
public void Write(LogLevel level, string text, Object[] args, CallerInfo& callerInfo);
    public void WriteException(LogLevel level, Exception exception, string text);
    [EditorBrowsableAttribute("1")]
public void WriteException(LogLevel level, Exception exception, string text, CallerInfo& callerInfo);
    public void WriteException(LogLevel level, Exception exception, string text, Object[] args);
    [EditorBrowsableAttribute("1")]
public void WriteException(LogLevel level, Exception exception, string text, Object[] args, CallerInfo& callerInfo);
    private static void SetOptions(LogActivityOptions& options, CallerInfo& callerInfo);
    public LogActivity OpenActivity(LogActivityOptions options, string text);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenActivity(LogActivityOptions options, string text, CallerInfo& callerInfo);
    public LogActivity OpenActivity(LogActivityOptions options, string text, Object[] args);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenActivity(LogActivityOptions options, string text, Object[] args, CallerInfo& callerInfo);
    [ObsoleteAttribute("Use OpenActivity. It now automatically detects async callers.")]
[EditorBrowsableAttribute("1")]
public LogActivity OpenAsyncActivity(LogActivityOptions options, string text);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenAsyncActivity(LogActivityOptions options, string text, CallerInfo& callerInfo);
    [ObsoleteAttribute("Use OpenActivity.")]
[EditorBrowsableAttribute("1")]
public LogActivity OpenAsyncActivity(LogActivityOptions options, string text, Object[] args);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use OpenActivity. It now automatically detects async callers.")]
public LogActivity OpenAsyncActivity(LogActivityOptions options, string text, Object[] args, CallerInfo& callerInfo);
    public LogActivity OpenActivity(string text);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenActivity(string text, CallerInfo& callerInfo);
    public LogActivity OpenActivity(string text, Object[] args);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenActivity(string text, Object[] args, CallerInfo& callerInfo);
    [ObsoleteAttribute("Use OpenActivity. It now automatically detects async callers.")]
[EditorBrowsableAttribute("1")]
public LogActivity OpenAsyncActivity(string text);
    [ObsoleteAttribute("Use OpenActivity. It now automatically detects async callers.")]
[EditorBrowsableAttribute("1")]
public LogActivity OpenAsyncActivity(string text, CallerInfo& callerInfo);
    [ObsoleteAttribute("Use OpenActivity. It now automatically detects async callers.")]
[EditorBrowsableAttribute("1")]
public LogActivity OpenAsyncActivity(string text, Object[] args);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use OpenActivity. It now automatically detects async callers.")]
public LogActivity OpenAsyncActivity(string text, Object[] args, CallerInfo& callerInfo);
    [ObsoleteAttribute("This method has no effect and returns the current Logger.")]
[EditorBrowsableAttribute("1")]
public virtual Logger ForCurrentContext();
    public bool IsEnabled(LogLevel level);
    public void WriteExecutionPoint();
    [EditorBrowsableAttribute("1")]
public void WriteExecutionPoint(CallerInfo& callerInfo);
    public LogSource ToLogSource();
    public void Write(LogLevel level, string formattingString, T1 arg1);
    [EditorBrowsableAttribute("1")]
public void Write(LogLevel level, string formattingString, T1 arg1, CallerInfo& callerInfo);
    public void WriteException(LogLevel level, Exception exception, string formattingString, T1 arg1);
    [EditorBrowsableAttribute("1")]
public void WriteException(LogLevel level, Exception exception, string formattingString, T1 arg1, CallerInfo& callerInfo);
    public LogActivity OpenActivity(LogActivityOptions options, string formattingString, T1 arg1);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenActivity(LogActivityOptions options, string formattingString, T1 arg1, CallerInfo& callerInfo);
    [ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(LogActivityOptions options, string text, T1 arg1);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenAsyncActivity(LogActivityOptions options, string formattingString, T1 arg1, CallerInfo& callerInfo);
    public LogActivity OpenActivity(string formattingString, T1 arg1);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenActivity(string formattingString, T1 arg1, CallerInfo& callerInfo);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(string text, T1 arg1);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(string formattingString, T1 arg1, CallerInfo& callerInfo);
    public void Write(LogLevel level, string formattingString, T1 arg1, T2 arg2);
    [EditorBrowsableAttribute("1")]
public void Write(LogLevel level, string formattingString, T1 arg1, T2 arg2, CallerInfo& callerInfo);
    public void WriteException(LogLevel level, Exception exception, string formattingString, T1 arg1, T2 arg2);
    [EditorBrowsableAttribute("1")]
public void WriteException(LogLevel level, Exception exception, string formattingString, T1 arg1, T2 arg2, CallerInfo& callerInfo);
    public LogActivity OpenActivity(LogActivityOptions options, string formattingString, T1 arg1, T2 arg2);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenActivity(LogActivityOptions options, string formattingString, T1 arg1, T2 arg2, CallerInfo& callerInfo);
    [ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(LogActivityOptions options, string text, T1 arg1, T2 arg2);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenAsyncActivity(LogActivityOptions options, string formattingString, T1 arg1, T2 arg2, CallerInfo& callerInfo);
    public LogActivity OpenActivity(string formattingString, T1 arg1, T2 arg2);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenActivity(string formattingString, T1 arg1, T2 arg2, CallerInfo& callerInfo);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(string text, T1 arg1, T2 arg2);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(string formattingString, T1 arg1, T2 arg2, CallerInfo& callerInfo);
    public void Write(LogLevel level, string formattingString, T1 arg1, T2 arg2, T3 arg3);
    [EditorBrowsableAttribute("1")]
public void Write(LogLevel level, string formattingString, T1 arg1, T2 arg2, T3 arg3, CallerInfo& callerInfo);
    public void WriteException(LogLevel level, Exception exception, string formattingString, T1 arg1, T2 arg2, T3 arg3);
    [EditorBrowsableAttribute("1")]
public void WriteException(LogLevel level, Exception exception, string formattingString, T1 arg1, T2 arg2, T3 arg3, CallerInfo& callerInfo);
    public LogActivity OpenActivity(LogActivityOptions options, string formattingString, T1 arg1, T2 arg2, T3 arg3);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenActivity(LogActivityOptions options, string formattingString, T1 arg1, T2 arg2, T3 arg3, CallerInfo& callerInfo);
    [ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(LogActivityOptions options, string text, T1 arg1, T2 arg2, T3 arg3);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenAsyncActivity(LogActivityOptions options, string formattingString, T1 arg1, T2 arg2, T3 arg3, CallerInfo& callerInfo);
    public LogActivity OpenActivity(string formattingString, T1 arg1, T2 arg2, T3 arg3);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenActivity(string formattingString, T1 arg1, T2 arg2, T3 arg3, CallerInfo& callerInfo);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(string text, T1 arg1, T2 arg2, T3 arg3);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(string formattingString, T1 arg1, T2 arg2, T3 arg3, CallerInfo& callerInfo);
    public void Write(LogLevel level, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [EditorBrowsableAttribute("1")]
public void Write(LogLevel level, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, CallerInfo& callerInfo);
    public void WriteException(LogLevel level, Exception exception, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [EditorBrowsableAttribute("1")]
public void WriteException(LogLevel level, Exception exception, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, CallerInfo& callerInfo);
    public LogActivity OpenActivity(LogActivityOptions options, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenActivity(LogActivityOptions options, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, CallerInfo& callerInfo);
    [ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(LogActivityOptions options, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenAsyncActivity(LogActivityOptions options, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, CallerInfo& callerInfo);
    public LogActivity OpenActivity(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenActivity(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, CallerInfo& callerInfo);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, CallerInfo& callerInfo);
    public void Write(LogLevel level, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [EditorBrowsableAttribute("1")]
public void Write(LogLevel level, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, CallerInfo& callerInfo);
    public void WriteException(LogLevel level, Exception exception, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [EditorBrowsableAttribute("1")]
public void WriteException(LogLevel level, Exception exception, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, CallerInfo& callerInfo);
    public LogActivity OpenActivity(LogActivityOptions options, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenActivity(LogActivityOptions options, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, CallerInfo& callerInfo);
    [ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(LogActivityOptions options, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenAsyncActivity(LogActivityOptions options, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, CallerInfo& callerInfo);
    public LogActivity OpenActivity(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenActivity(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, CallerInfo& callerInfo);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, CallerInfo& callerInfo);
    public void Write(LogLevel level, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [EditorBrowsableAttribute("1")]
public void Write(LogLevel level, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, CallerInfo& callerInfo);
    public void WriteException(LogLevel level, Exception exception, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [EditorBrowsableAttribute("1")]
public void WriteException(LogLevel level, Exception exception, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, CallerInfo& callerInfo);
    public LogActivity OpenActivity(LogActivityOptions options, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenActivity(LogActivityOptions options, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, CallerInfo& callerInfo);
    [ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(LogActivityOptions options, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenAsyncActivity(LogActivityOptions options, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, CallerInfo& callerInfo);
    public LogActivity OpenActivity(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenActivity(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, CallerInfo& callerInfo);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, CallerInfo& callerInfo);
    public void Write(LogLevel level, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    [EditorBrowsableAttribute("1")]
public void Write(LogLevel level, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, CallerInfo& callerInfo);
    public void WriteException(LogLevel level, Exception exception, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    [EditorBrowsableAttribute("1")]
public void WriteException(LogLevel level, Exception exception, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, CallerInfo& callerInfo);
    public LogActivity OpenActivity(LogActivityOptions options, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenActivity(LogActivityOptions options, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, CallerInfo& callerInfo);
    [ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(LogActivityOptions options, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenAsyncActivity(LogActivityOptions options, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, CallerInfo& callerInfo);
    public LogActivity OpenActivity(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenActivity(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, CallerInfo& callerInfo);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, CallerInfo& callerInfo);
    public void Write(LogLevel level, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    [EditorBrowsableAttribute("1")]
public void Write(LogLevel level, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, CallerInfo& callerInfo);
    public void WriteException(LogLevel level, Exception exception, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    [EditorBrowsableAttribute("1")]
public void WriteException(LogLevel level, Exception exception, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, CallerInfo& callerInfo);
    public LogActivity OpenActivity(LogActivityOptions options, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenActivity(LogActivityOptions options, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, CallerInfo& callerInfo);
    [ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(LogActivityOptions options, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenAsyncActivity(LogActivityOptions options, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, CallerInfo& callerInfo);
    public LogActivity OpenActivity(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenActivity(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, CallerInfo& callerInfo);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, CallerInfo& callerInfo);
    public void Write(LogLevel level, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    [EditorBrowsableAttribute("1")]
public void Write(LogLevel level, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, CallerInfo& callerInfo);
    public void WriteException(LogLevel level, Exception exception, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    [EditorBrowsableAttribute("1")]
public void WriteException(LogLevel level, Exception exception, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, CallerInfo& callerInfo);
    public LogActivity OpenActivity(LogActivityOptions options, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenActivity(LogActivityOptions options, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, CallerInfo& callerInfo);
    [ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(LogActivityOptions options, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenAsyncActivity(LogActivityOptions options, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, CallerInfo& callerInfo);
    public LogActivity OpenActivity(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenActivity(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, CallerInfo& callerInfo);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, CallerInfo& callerInfo);
    public void Write(LogLevel level, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    [EditorBrowsableAttribute("1")]
public void Write(LogLevel level, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, CallerInfo& callerInfo);
    public void WriteException(LogLevel level, Exception exception, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    [EditorBrowsableAttribute("1")]
public void WriteException(LogLevel level, Exception exception, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, CallerInfo& callerInfo);
    public LogActivity OpenActivity(LogActivityOptions options, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenActivity(LogActivityOptions options, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, CallerInfo& callerInfo);
    [ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(LogActivityOptions options, string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenAsyncActivity(LogActivityOptions options, string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, CallerInfo& callerInfo);
    public LogActivity OpenActivity(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    [EditorBrowsableAttribute("1")]
public LogActivity OpenActivity(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, CallerInfo& callerInfo);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(string text, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use OpenActivity. It now automatically detects async methods.")]
public LogActivity OpenAsyncActivity(string formattingString, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, CallerInfo& callerInfo);
}
[ExtensionAttribute]
public static class PostSharp.Patterns.Diagnostics.LoggerFactoryExtensions : object {
    private static ConcurrentDictionary`2<CacheKey, LogSource> cache;
    private static LoggerFactoryExtensions();
    [ExtensionAttribute]
[ObsoleteAttribute("Provide an ILoggerFactory3.")]
public static LogSource GetLogSource(ILoggerFactory2 factory, Type type);
    [ExtensionAttribute]
public static LogSource GetLogSource(ILoggerFactory3 factory, Type type);
    [ExtensionAttribute]
public static LogSource GetLogSource(ILoggerFactory3 factory, string sourceName);
    [ExtensionAttribute]
[ObsoleteAttribute("Provide an ILoggerFactory3.")]
public static LogSource GetLogSource(ILoggerFactory2 factory);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Provide an ILoggerFactory3.")]
public static LogSource GetLogSource(ILoggerFactory2 factory, CallerInfo& callerInfo);
    [ExtensionAttribute]
public static LogSource GetLogSource(ILoggerFactory3 factory);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static LogSource GetLogSource(ILoggerFactory3 factory, CallerInfo& callerInfo);
}
public class PostSharp.Patterns.Diagnostics.LoggingProperty : object {
    private object value;
    private Func`1<object> func;
    private LoggingPropertyOptions options;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IFormatter <Formatter>k__BackingField;
    public string Name { get; }
    public object Value { get; }
    public IFormatter Formatter { get; public set; }
    public bool IsRendered { get; public set; }
    public bool IsInherited { get; public set; }
    public bool IsBaggage { get; public set; }
    internal LoggingPropertyOptions Options { get; }
    public LoggingProperty(string name, object value);
    internal LoggingProperty(string name, object value, LoggingPropertyOptions options);
    public LoggingProperty(string name, Func`1<object> func);
    [CompilerGeneratedAttribute]
[DebuggerAspectGeneratedCodeAttribute]
private static LoggingProperty();
    [CompilerGeneratedAttribute]
public string get_Name();
    public object get_Value();
    [CompilerGeneratedAttribute]
public IFormatter get_Formatter();
    [CompilerGeneratedAttribute]
public void set_Formatter(IFormatter value);
    public bool get_IsRendered();
    public void set_IsRendered(bool value);
    public bool get_IsInherited();
    public void set_IsInherited(bool value);
    public bool get_IsBaggage();
    public void set_IsBaggage(bool value);
    internal LoggingPropertyOptions get_Options();
    public virtual string ToString();
}
public static class PostSharp.Patterns.Diagnostics.LoggingRoles : object {
    public static string Caching;
    public static string Tracing;
    [ObsoleteAttribute("This feature has been moved to the sample PostSharp.Samples.Logging.Audit.")]
public static string Audit;
    public static string Meta;
    public static string Custom;
    [ExplicitCrossPackageInternalAttribute]
internal static bool IsSystemRole(string role);
}
public enum PostSharp.Patterns.Diagnostics.LogLevel : Enum {
    public int value__;
    public static LogLevel None;
    public static LogLevel Trace;
    public static LogLevel Debug;
    public static LogLevel Info;
    public static LogLevel Warning;
    public static LogLevel Error;
    public static LogLevel Critical;
}
[ExtensionAttribute]
[ExplicitCrossPackageInternalAttribute]
internal static class PostSharp.Patterns.Diagnostics.LogLevelExtensions : object {
    public static LogLevel Force;
    [ExtensionAttribute]
[ExplicitCrossPackageInternalAttribute]
internal static LogLevel WithForce(LogLevel level);
    [ExtensionAttribute]
[ExplicitCrossPackageInternalAttribute]
internal static LogLevel WithoutForce(LogLevel level);
    [ExtensionAttribute]
[ExplicitCrossPackageInternalAttribute]
internal static bool HasForce(LogLevel level);
    [ExtensionAttribute]
[ExplicitCrossPackageInternalAttribute]
internal static LogLevel CopyForce(LogLevel source, LogLevel other);
}
[IsReadOnlyAttribute]
internal class PostSharp.Patterns.Diagnostics.LogLevels : ValueType {
    private sbyte defaultLevel;
    private sbyte failureLevel;
    public LogLevel DefaultLevel { get; }
    public LogLevel FailureLevel { get; }
    public LogLevels(LogLevel defaultLevel, LogLevel failureLevel);
    public LogLevel get_DefaultLevel();
    public LogLevel get_FailureLevel();
}
[FlagsAttribute]
public enum PostSharp.Patterns.Diagnostics.LogRecordKind : Enum {
    public int value__;
    public static LogRecordKind None;
    public static LogRecordKind MethodEntry;
    public static LogRecordKind MethodSuccess;
    public static LogRecordKind MethodException;
    public static LogRecordKind AsyncMethodAwait;
    public static LogRecordKind AsyncMethodResume;
    public static LogRecordKind ValueChanged;
    public static LogRecordKind CustomRecord;
    public static LogRecordKind CustomActivityEntry;
    public static LogRecordKind CustomActivityException;
    public static LogRecordKind CustomActivitySuccess;
    public static LogRecordKind CustomActivityFailure;
    public static LogRecordKind IteratorYield;
    public static LogRecordKind IteratorMoveNext;
    public static LogRecordKind ExecutionPoint;
    public static LogRecordKind MethodOvertime;
    public static LogRecordKind CustomActivityExit;
}
[ExtensionAttribute]
public static class PostSharp.Patterns.Diagnostics.LogRecordKindExtensions : object {
    [ExtensionAttribute]
public static bool IsOpen(LogRecordKind kind);
    [ExtensionAttribute]
public static bool IsClose(LogRecordKind kind);
    [ExtensionAttribute]
public static bool IsCloseCustomActivity(LogRecordKind kind);
    [ExtensionAttribute]
public static bool IsStandalone(LogRecordKind kind);
    [ExtensionAttribute]
public static bool IsCustom(LogRecordKind kind);
}
[RequirePostSharpAttribute("PostSharp.Patterns.Common.Weaver", "AddCallerInfoTask")]
public class PostSharp.Patterns.Diagnostics.LogSource : object {
    private LogLevelSource debugLogLevelSource;
    private LogLevelSource traceLogLevelSource;
    private LogLevelSource infoLogLevelSource;
    private LogLevelSource warningLogLevelSource;
    private LogLevelSource errorLogLevelSource;
    private LogLevelSource criticalLogLevelSource;
    private LogLevelSource noneLogLevelSource;
    [CompilerGeneratedAttribute]
private ILogger3 <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private LogLevel <DefaultLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private LogLevel <FailureLevel>k__BackingField;
    public ILoggingContext CurrentContext { get; }
    internal ILogger3 Logger { get; }
    internal LogLevel DefaultLevel { get; }
    internal LogLevel FailureLevel { get; }
    public LogLevelSource None { get; }
    public LogLevelSource Default { get; }
    public LogLevelSource Failure { get; }
    public LogLevelSource Critical { get; }
    public LogLevelSource Error { get; }
    public LogLevelSource Warning { get; }
    public LogLevelSource Info { get; }
    public LogLevelSource Trace { get; }
    public LogLevelSource Debug { get; }
    internal LogSource(ILogger3 logger, LogLevel defaultLevel, LogLevel failureLevel);
    [CompilerGeneratedAttribute]
[DebuggerAspectGeneratedCodeAttribute]
private static LogSource();
    public ILoggingContext get_CurrentContext();
    [CompilerGeneratedAttribute]
internal ILogger3 get_Logger();
    public LogSource ForType(Type type);
    public LogSource ForSource(string sourceName);
    public LogSource ForCurrentType();
    [EditorBrowsableAttribute("1")]
public LogSource ForCurrentType(CallerInfo& callerInfo);
    public static LogSource Get();
    [EditorBrowsableAttribute("1")]
public static LogSource Get(CallerInfo& callerInfo);
    public static LogSource Get(string sourceName);
    public static LogSource Get(string sourceName, string role);
    public static LogSource Get(Type type, string role);
    public bool IsEnabled(LogLevel level);
    public LogLevelSource WithLevel(LogLevel level);
    [CompilerGeneratedAttribute]
internal LogLevel get_DefaultLevel();
    [CompilerGeneratedAttribute]
internal LogLevel get_FailureLevel();
    public LogSource WithLevels(LogLevel defaultLevel, LogLevel failureLevel);
    private LogLevelSource GetWriteMessage(LogLevelSource& field, LogLevel level);
    public LogLevelSource get_None();
    public LogLevelSource get_Default();
    public LogLevelSource get_Failure();
    public LogLevelSource get_Critical();
    public LogLevelSource get_Error();
    public LogLevelSource get_Warning();
    public LogLevelSource get_Info();
    public LogLevelSource get_Trace();
    public LogLevelSource get_Debug();
    public void WriteExecutionPoint();
    [EditorBrowsableAttribute("1")]
public void WriteExecutionPoint(CallerInfo& callerInfo);
    public void ApplyTransactionRequirements(OpenActivityOptions& openActivityOptions);
}
[ExplicitCrossPackageInternalAttribute]
internal static class PostSharp.Patterns.Diagnostics.LogSourceFactory : object {
    [ObsoleteAttribute("Use Default3")]
public static ILoggerFactory2 Default { get; }
    public static ILoggerFactory3 Default3 { get; }
    public static ILoggerFactory2 get_Default();
    public static ILoggerFactory3 get_Default3();
    [ObsoleteAttribute("Use ForRole3")]
public static ILoggerFactory2 ForRole(string role);
    public static ILoggerFactory3 ForRole3(string role);
}
public class PostSharp.Patterns.Diagnostics.OpenActivityOptions : ValueType {
    private short kind;
    private Flags flags;
    [CompilerGeneratedAttribute]
private TransactionRequirement <TransactionRequirement>k__BackingField;
    [CompilerGeneratedAttribute]
private LogEventData <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SyntheticParentId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SyntheticRootId>k__BackingField;
    [ExplicitCrossPackageInternalAttribute]
internal bool IsHidden { get; internal set; }
    public IncomingRequestOptions IncomingRequestOptions { get; public set; }
    public TransactionRequirement TransactionRequirement { get; public set; }
    public bool IsSyntheticRootId { get; public set; }
    public LogActivityKind Kind { get; public set; }
    [ExplicitCrossPackageInternalAttribute]
internal LogLevel Level { get; internal set; }
    [ObsoleteAttribute("Use the Data property.")]
public LoggingProperty[] Properties { get; public set; }
    public LogEventData Data { get; public set; }
    public string SyntheticParentId { get; public set; }
    public string SyntheticRootId { get; public set; }
    public OpenActivityOptions(object data, LogActivityKind kind);
    public OpenActivityOptions(LogEventData& data, LogActivityKind kind);
    [ExplicitCrossPackageInternalAttribute]
internal OpenActivityOptions(LogActivityOptions& options);
    [IsReadOnlyAttribute]
internal bool get_IsHidden();
    internal void set_IsHidden(bool value);
    [IsReadOnlyAttribute]
public IncomingRequestOptions get_IncomingRequestOptions();
    public void set_IncomingRequestOptions(IncomingRequestOptions value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TransactionRequirement get_TransactionRequirement();
    [CompilerGeneratedAttribute]
public void set_TransactionRequirement(TransactionRequirement value);
    [IsReadOnlyAttribute]
public bool get_IsSyntheticRootId();
    public void set_IsSyntheticRootId(bool value);
    [IsReadOnlyAttribute]
public LogActivityKind get_Kind();
    public void set_Kind(LogActivityKind value);
    [IsReadOnlyAttribute]
internal LogLevel get_Level();
    internal void set_Level(LogLevel value);
    [IsReadOnlyAttribute]
public LoggingProperty[] get_Properties();
    public void set_Properties(LoggingProperty[] value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public LogEventData get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(LogEventData value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_SyntheticParentId();
    [CompilerGeneratedAttribute]
public void set_SyntheticParentId(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_SyntheticRootId();
    [CompilerGeneratedAttribute]
public void set_SyntheticRootId(string value);
}
public static class PostSharp.Patterns.Diagnostics.SemanticMessageBuilder : object {
    public static SemanticMessage`1<T1> Semantic(string name, string parameterName1, T1 parameterValue1);
    public static SemanticMessage`1<T1> Semantic(string name, ValueTuple`2& parameter1);
    public static SemanticMessage`2<T1, T2> Semantic(string name, string parameterName1, T1 parameterValue1, string parameterName2, T2 parameterValue2);
    public static SemanticMessage`2<T1, T2> Semantic(string name, ValueTuple`2& parameter1, ValueTuple`2& parameter2);
    public static SemanticMessage`3<T1, T2, T3> Semantic(string name, string parameterName1, T1 parameterValue1, string parameterName2, T2 parameterValue2, string parameterName3, T3 parameterValue3);
    public static SemanticMessage`3<T1, T2, T3> Semantic(string name, ValueTuple`2& parameter1, ValueTuple`2& parameter2, ValueTuple`2& parameter3);
    public static SemanticMessage`4<T1, T2, T3, T4> Semantic(string name, string parameterName1, T1 parameterValue1, string parameterName2, T2 parameterValue2, string parameterName3, T3 parameterValue3, string parameterName4, T4 parameterValue4);
    public static SemanticMessage`4<T1, T2, T3, T4> Semantic(string name, ValueTuple`2& parameter1, ValueTuple`2& parameter2, ValueTuple`2& parameter3, ValueTuple`2& parameter4);
    public static SemanticMessage`5<T1, T2, T3, T4, T5> Semantic(string name, string parameterName1, T1 parameterValue1, string parameterName2, T2 parameterValue2, string parameterName3, T3 parameterValue3, string parameterName4, T4 parameterValue4, string parameterName5, T5 parameterValue5);
    public static SemanticMessage`5<T1, T2, T3, T4, T5> Semantic(string name, ValueTuple`2& parameter1, ValueTuple`2& parameter2, ValueTuple`2& parameter3, ValueTuple`2& parameter4, ValueTuple`2& parameter5);
    public static SemanticMessage`6<T1, T2, T3, T4, T5, T6> Semantic(string name, string parameterName1, T1 parameterValue1, string parameterName2, T2 parameterValue2, string parameterName3, T3 parameterValue3, string parameterName4, T4 parameterValue4, string parameterName5, T5 parameterValue5, string parameterName6, T6 parameterValue6);
    public static SemanticMessage`6<T1, T2, T3, T4, T5, T6> Semantic(string name, ValueTuple`2& parameter1, ValueTuple`2& parameter2, ValueTuple`2& parameter3, ValueTuple`2& parameter4, ValueTuple`2& parameter5, ValueTuple`2& parameter6);
    public static SemanticMessage`7<T1, T2, T3, T4, T5, T6, T7> Semantic(string name, string parameterName1, T1 parameterValue1, string parameterName2, T2 parameterValue2, string parameterName3, T3 parameterValue3, string parameterName4, T4 parameterValue4, string parameterName5, T5 parameterValue5, string parameterName6, T6 parameterValue6, string parameterName7, T7 parameterValue7);
    public static SemanticMessage`7<T1, T2, T3, T4, T5, T6, T7> Semantic(string name, ValueTuple`2& parameter1, ValueTuple`2& parameter2, ValueTuple`2& parameter3, ValueTuple`2& parameter4, ValueTuple`2& parameter5, ValueTuple`2& parameter6, ValueTuple`2& parameter7);
    public static SemanticMessage`8<T1, T2, T3, T4, T5, T6, T7, T8> Semantic(string name, string parameterName1, T1 parameterValue1, string parameterName2, T2 parameterValue2, string parameterName3, T3 parameterValue3, string parameterName4, T4 parameterValue4, string parameterName5, T5 parameterValue5, string parameterName6, T6 parameterValue6, string parameterName7, T7 parameterValue7, string parameterName8, T8 parameterValue8);
    public static SemanticMessage`8<T1, T2, T3, T4, T5, T6, T7, T8> Semantic(string name, ValueTuple`2& parameter1, ValueTuple`2& parameter2, ValueTuple`2& parameter3, ValueTuple`2& parameter4, ValueTuple`2& parameter5, ValueTuple`2& parameter6, ValueTuple`2& parameter7, ValueTuple`2& parameter8);
    public static SemanticMessage`9<T1, T2, T3, T4, T5, T6, T7, T8, T9> Semantic(string name, string parameterName1, T1 parameterValue1, string parameterName2, T2 parameterValue2, string parameterName3, T3 parameterValue3, string parameterName4, T4 parameterValue4, string parameterName5, T5 parameterValue5, string parameterName6, T6 parameterValue6, string parameterName7, T7 parameterValue7, string parameterName8, T8 parameterValue8, string parameterName9, T9 parameterValue9);
    public static SemanticMessage`9<T1, T2, T3, T4, T5, T6, T7, T8, T9> Semantic(string name, ValueTuple`2& parameter1, ValueTuple`2& parameter2, ValueTuple`2& parameter3, ValueTuple`2& parameter4, ValueTuple`2& parameter5, ValueTuple`2& parameter6, ValueTuple`2& parameter7, ValueTuple`2& parameter8, ValueTuple`2& parameter9);
    public static SemanticMessage`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Semantic(string name, string parameterName1, T1 parameterValue1, string parameterName2, T2 parameterValue2, string parameterName3, T3 parameterValue3, string parameterName4, T4 parameterValue4, string parameterName5, T5 parameterValue5, string parameterName6, T6 parameterValue6, string parameterName7, T7 parameterValue7, string parameterName8, T8 parameterValue8, string parameterName9, T9 parameterValue9, string parameterName10, T10 parameterValue10);
    public static SemanticMessage`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Semantic(string name, ValueTuple`2& parameter1, ValueTuple`2& parameter2, ValueTuple`2& parameter3, ValueTuple`2& parameter4, ValueTuple`2& parameter5, ValueTuple`2& parameter6, ValueTuple`2& parameter7, ValueTuple`2& parameter8, ValueTuple`2& parameter9, ValueTuple`2& parameter10);
    public static SemanticMessageArray Semantic(string messageName, ValueTuple`2[] parameters);
    public static SemanticMessageArray Semantic(string messageName, IReadOnlyList`1<ValueTuple`2<string, object>> parameters);
    public static SemanticMessage Semantic(string messageName);
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Diagnostics.Transactions.TransactionRequirement : ValueType {
    private static short isSampledFlag;
    private short flags;
    [CompilerGeneratedAttribute]
private short <State>k__BackingField;
    internal short State { get; }
    public bool IsSampled { get; }
    public bool RequiresTransaction { get; }
    public static TransactionRequirement SampledTransaction { get; }
    public static TransactionRequirement DeterministicTransaction { get; }
    public static TransactionRequirement NoTransaction { get; }
    [ExplicitCrossPackageInternalAttribute]
internal TransactionRequirement(short state, bool isSampled);
    [CompilerGeneratedAttribute]
[ExplicitCrossPackageInternalAttribute]
internal short get_State();
    public bool get_IsSampled();
    public bool get_RequiresTransaction();
    public static TransactionRequirement get_SampledTransaction();
    public static TransactionRequirement get_DeterministicTransaction();
    public static TransactionRequirement get_NoTransaction();
    public TransactionRequirement WithRequiresTransaction(bool value);
    public virtual string ToString();
}
public class PostSharp.Patterns.Diagnostics.WriteMessageOptions : ValueType {
    [CompilerGeneratedAttribute]
private LogEventData <Data>k__BackingField;
    [ObsoleteAttribute("Provide a LogEventData.")]
public LoggingProperty[] Properties { get; public set; }
    public LogEventData Data { get; public set; }
    public WriteMessageOptions(object data);
    public WriteMessageOptions(LogEventData& data);
    [IsReadOnlyAttribute]
public LoggingProperty[] get_Properties();
    public void set_Properties(LoggingProperty[] value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public LogEventData get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(LogEventData value);
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.DynamicAdvising.AdviceEnumerator`1 : ValueType {
    private T current;
    private IDynamicAdvice[] array;
    private int position;
    public T Current { get; }
    public bool HasValue { get; }
    internal AdviceEnumerator`1(IDynamicAdvice[] array);
    internal AdviceEnumerator`1(IDynamicAdvice[] array, int position);
    public T get_Current();
    public bool get_HasValue();
    public AdviceEnumerator`1<T> GetNext();
}
public abstract class PostSharp.Patterns.DynamicAdvising.DynamicAdvice : object {
    [CompilerGeneratedAttribute]
private IQueryInterface <AdvisedObject>k__BackingField;
    public int Order { get; }
    private object PostSharp.Patterns.DynamicAdvising.IDynamicInterfaceImplementation.AdvisedObject { get; }
    protected IQueryInterface AdvisedObject { get; }
    public Type Identity { get; }
    protected DynamicAdvice(IQueryInterface parent);
    public virtual TInterface QueryInterface();
    public abstract virtual int get_Order();
    private sealed virtual override object PostSharp.Patterns.DynamicAdvising.IDynamicInterfaceImplementation.get_AdvisedObject();
    [CompilerGeneratedAttribute]
protected IQueryInterface get_AdvisedObject();
    public virtual void Dispose();
    public virtual Type get_Identity();
    public virtual void Initialize(IQueryInterface parent, AdviceEnumerator`1<IDynamicAdvice> nextAdvice);
}
internal class PostSharp.Patterns.DynamicAdvising.DynamicAdviceList : ValueType {
    private static IDynamicAdvice[] emptyAdvices;
    private IDynamicAdvice[] modreq(System.Runtime.CompilerServices.IsVolatile) temporaryAdvices;
    private long temporaryAdvicesThreadId;
    private IDynamicAdvice[] modreq(System.Runtime.CompilerServices.IsVolatile) advices;
    private PortableSpinLock spinLock;
    private IQueryInterface parent;
    public DynamicAdviceList(IQueryInterface parent);
    private static DynamicAdviceList();
    public void Initialize(IExecuteActionDynamicAdvice head);
    public bool Advise(Func`2<IQueryInterface, T> createAdvice);
    public void Unadvise();
    private void EnsureInitialized();
    public bool Advise(Type type, Func`2<IQueryInterface, IDynamicAdvice> createAdvice);
    public AdviceEnumerator`1<T> GetEnumerator();
    private IDynamicAdvice[] GetAdvicesForCurrentThread();
    public T QueryInterface();
    public bool Unadvise(Type type);
}
public static class PostSharp.Patterns.DynamicAdvising.DynamicAdviceOrder : object {
    public static int Aggregatable;
    public static int Disposable;
    public static int Threading;
    public static int Recordable;
}
public static class PostSharp.Patterns.DynamicAdvising.DynamicAdvisingServices : object {
    public static object QueryObject(object obj);
    public static T QueryInterface(object obj, bool throwing);
}
public abstract class PostSharp.Patterns.DynamicAdvising.DynamicallyAdvisableObject : object {
    private DynamicAdviceList advices;
    protected DynamicallyAdvisableObject(SerializationInfo info, StreamingContext context);
    protected void InitializeAdvices(IExecuteActionDynamicAdvice advice);
    private sealed virtual override T PostSharp.Patterns.DynamicAdvising.IQueryInterface.QueryInterface();
    public AdviceEnumerator`1<T> GetAdviceEnumerator();
    private sealed virtual override bool PostSharp.Patterns.DynamicAdvising.IDynamicallyAdvisable.Advise(Type type, Func`2<IQueryInterface, IDynamicAdvice> createAdvice);
    private sealed virtual override bool PostSharp.Patterns.DynamicAdvising.IDynamicallyAdvisable.Unadvise(Type type);
    private sealed virtual override T PostSharp.Patterns.DynamicAdvising.IDynamicallyAdvisable.QueryAdvice();
    protected internal TResult ExecuteWithAdvices(ObjectAccessLevel objectAccessLevel, TAction& action);
    private static TResult ExecuteWithAdvices(ObjectAccessLevel objectAccessLevel, TAction& action, AdviceEnumerator`1& adviceEnumerator);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void OnDeserialization(object sender);
}
public interface PostSharp.Patterns.DynamicAdvising.IAction`1 {
    public abstract virtual TResult Execute();
}
public interface PostSharp.Patterns.DynamicAdvising.IDynamicAdvice {
    public int Order { get; }
    public Type Identity { get; }
    public abstract virtual T QueryInterface();
    public abstract virtual int get_Order();
    public abstract virtual void Dispose();
    public abstract virtual Type get_Identity();
    public abstract virtual void Initialize(IQueryInterface parent, AdviceEnumerator`1<IDynamicAdvice> nextAdvice);
}
public interface PostSharp.Patterns.DynamicAdvising.IDynamicallyAdvisable {
    public abstract virtual bool Advise(Type type, Func`2<IQueryInterface, IDynamicAdvice> createAdvice);
    public abstract virtual bool Unadvise(Type type);
    public abstract virtual T QueryAdvice();
}
public interface PostSharp.Patterns.DynamicAdvising.IDynamicInterfaceImplementation {
    public object AdvisedObject { get; }
    public abstract virtual object get_AdvisedObject();
}
public interface PostSharp.Patterns.DynamicAdvising.IExecuteActionDynamicAdvice {
    public abstract virtual TResult Invoke(ObjectAccessLevel objectAccessLevel, AdviceEnumerator`1<IExecuteActionDynamicAdvice> nextAdvice, TAction& action);
}
public interface PostSharp.Patterns.DynamicAdvising.IQueryInterface {
    public abstract virtual T QueryInterface();
}
[ExtensionAttribute]
[ExplicitCrossPackageInternalAttribute]
internal static class PostSharp.Patterns.DynamicAdvising.QueryInterfaceExtensions : object {
    [ExtensionAttribute]
public static T QueryInterface(object obj, bool throwing);
}
public class PostSharp.Patterns.Formatters.AnonymousTypeFormatter`1 : object {
    private Func`2<object, UnknownObjectAccessor> accessorFactory;
    public FormatterAttributes Attributes { get; }
    public AnonymousTypeFormatter`1(Type type);
    public sealed virtual FormatterAttributes get_Attributes();
    public sealed virtual void Write(UnsafeStringBuilder stringBuilder, object value);
}
public class PostSharp.Patterns.Formatters.BooleanFormatter : Formatter`1<bool> {
    public static BooleanFormatter Instance;
    private static BooleanFormatter();
    public virtual void Write(UnsafeStringBuilder stringBuilder, bool value);
}
public class PostSharp.Patterns.Formatters.ByteFormatter : Formatter`1<byte> {
    public static ByteFormatter Instance;
    private static ByteFormatter();
    public virtual void Write(UnsafeStringBuilder stringBuilder, byte value);
}
public class PostSharp.Patterns.Formatters.CharFormatter : Formatter`1<char> {
    public static CharFormatter Instance;
    private static CharFormatter();
    public virtual void Write(UnsafeStringBuilder stringBuilder, char value);
    public virtual IOptionAwareFormatter WithOptions(FormattingOptions options);
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Formatters.CharSpan : ValueType {
    [CompilerGeneratedAttribute]
private int <StartIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Array>k__BackingField;
    internal int StartIndex { get; }
    public int Length { get; }
    public bool IsNull { get; }
    [ExplicitCrossPackageInternalAttribute]
internal object Array { get; }
    public bool IsBackedByCharArray { get; }
    public CharSpan(Char[] array, int start, int length);
    public CharSpan(string str, int start, int length);
    public CharSpan(string str);
    [CompilerGeneratedAttribute]
internal int get_StartIndex();
    [CompilerGeneratedAttribute]
public int get_Length();
    public bool get_IsNull();
    [CompilerGeneratedAttribute]
internal object get_Array();
    public static CharSpan op_Implicit(string str);
    public static CharSpan FromString(string str);
    public static CharSpan op_Implicit(ArraySegment`1<char> str);
    public static CharSpan FromArraySegment(ArraySegment`1<char> str);
    public bool get_IsBackedByCharArray();
    public virtual string ToString();
    public ArraySegment`1<char> ToCharArraySegment();
}
public class PostSharp.Patterns.Formatters.DefaultFormatter`2 : Formatter`1<TValue> {
    private static bool isValueType;
    private static bool hasCustomToStringMethod;
    private static Type valueType;
    private FormattingOptions options;
    private static DefaultFormatter`2<TRole, TValue> unquotedFormatter;
    [CompilerGeneratedAttribute]
private static DefaultFormatter`2<TRole, TValue> <Instance>k__BackingField;
    public static DefaultFormatter`2<TRole, TValue> Instance { get; }
    public FormatterAttributes Attributes { get; }
    private DefaultFormatter`2(FormattingOptions options);
    private static DefaultFormatter`2();
    [CompilerGeneratedAttribute]
public static DefaultFormatter`2<TRole, TValue> get_Instance();
    public virtual FormatterAttributes get_Attributes();
    public virtual IOptionAwareFormatter WithOptions(FormattingOptions options);
    public virtual void Write(UnsafeStringBuilder stringBuilder, TValue value);
}
internal static class PostSharp.Patterns.Formatters.DefaultFormatterHelper : object {
    private static ConcurrentDictionary`2<Type, bool> hasCustomToStringMethod;
    private static DefaultFormatterHelper();
    public static bool HasCustomToStringMethod(Type type);
}
internal class PostSharp.Patterns.Formatters.DynamicFormatter`2 : Formatter`1<TValue> {
    private FormattingOptions options;
    private DynamicFormatter`2<TValue, TRole> otherFormatter;
    public FormatterAttributes Attributes { get; }
    private DynamicFormatter`2(FormattingOptions options);
    public virtual FormatterAttributes get_Attributes();
    public virtual IOptionAwareFormatter WithOptions(FormattingOptions options);
    public virtual void Write(UnsafeStringBuilder stringBuilder, TValue value);
}
public static class PostSharp.Patterns.Formatters.EnumFormatter : object {
    public static string GetString(T value);
}
public class PostSharp.Patterns.Formatters.EnumFormatter`1 : Formatter`1<T> {
    public static EnumFormatter`1<T> Instance;
    private static Dictionary`2<T, string> simpleNames;
    [ThreadStaticAttribute]
private static Dictionary`2<T, string> otherNames;
    private static EnumFormatter`1();
    public virtual void Write(UnsafeStringBuilder stringBuilder, T value);
    public static string GetString(T value);
}
internal class PostSharp.Patterns.Formatters.FormattableFormatter`2 : Formatter`1<TValue> {
    public virtual void Write(UnsafeStringBuilder stringBuilder, TValue value);
}
public abstract class PostSharp.Patterns.Formatters.Formatter`1 : object {
    public FormatterAttributes Attributes { get; }
    public sealed virtual void Write(UnsafeStringBuilder stringBuilder, object value);
    public abstract virtual void Write(UnsafeStringBuilder stringBuilder, T value);
    public virtual IOptionAwareFormatter WithOptions(FormattingOptions options);
    private sealed virtual override IOptionAwareFormatter PostSharp.Patterns.Formatters.IOptionAwareFormatter.WithOptions(FormattingOptions options);
    public virtual FormatterAttributes get_Attributes();
}
[FlagsAttribute]
public enum PostSharp.Patterns.Formatters.FormatterAttributes : Enum {
    public int value__;
    public static FormatterAttributes None;
    public static FormatterAttributes Normal;
    public static FormatterAttributes Dynamic;
    public static FormatterAttributes Converter;
    public static FormatterAttributes Default;
}
internal class PostSharp.Patterns.Formatters.FormatterConverter`1 : Formatter`1<TargetType> {
    private IFormatter wrapped;
    private static ConcurrentDictionary`2<IFormatter, FormatterConverter`1<TargetType>> cache;
    public FormatterAttributes Attributes { get; }
    public FormatterConverter`1(IFormatter wrapped);
    private static FormatterConverter`1();
    public static IFormatter`1<TargetType> Convert(IFormatter formatter);
    public virtual void Write(UnsafeStringBuilder stringBuilder, TargetType value);
    public virtual FormatterAttributes get_Attributes();
}
internal class PostSharp.Patterns.Formatters.FormatterConverter`2 : FormatterConverter`1<TargetType> {
    private IFormatter wrapped;
    public FormatterConverter`2(IFormatter wrapped);
}
[ExtensionAttribute]
public static class PostSharp.Patterns.Formatters.FormatterExtensions : object {
    [ExtensionAttribute]
public static IFormatter`1<T> WithOptions(IFormatter`1<T> formatter, FormattingOptions options);
    [ExtensionAttribute]
public static IFormatter WithOptions(IFormatter formatter, FormattingOptions options);
}
public abstract class PostSharp.Patterns.Formatters.FormatterRepository`1 : object {
    internal static FormattingRole Role;
    private static CovariantTypeExtensionFactory`1<IFormatter> formatterFactory;
    private static CovariantTypeExtensionFactory`1<IFormatter> dynamicFormatterFactory;
    private static PortableConcurrentDictionary`2<Type, TypeExtensionInfo`1<IFormatter>> dynamicFormatterCache;
    private static LogSource logger;
    private static Func`2<Type, TypeExtensionInfo`1<IFormatter>> getFormatterFunc;
    private static FormatterRepository`1();
    private static void RegisterDefaultFormatters();
    public static void SetDynamic();
    public static void Register(IFormatter`1<T> formatter);
    public static void Register(Type targetType, IFormatter formatter);
    public static void Register(Type targetType, Type formatterType);
    public static IFormatter`1<T> Get();
    public static IFormatter Get(Type objectType);
    private static void UpdateFormatterCache(Type objectType, TypeExtensionInfo`1<IFormatter> newFormatterInfo);
    public static void Reset();
    private static IFormatter CreateDefaultFormatter(Type type);
    private static IFormatter CreateDefaultFormatter();
}
public class PostSharp.Patterns.Formatters.FormattingOptions : object {
    [CompilerGeneratedAttribute]
private static FormattingOptions <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private static FormattingOptions <Unquoted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresUnquotedStrings>k__BackingField;
    public static FormattingOptions Default { get; }
    public static FormattingOptions Unquoted { get; }
    public bool RequiresUnquotedStrings { get; }
    protected FormattingOptions(FormattingOptions prototype);
    private FormattingOptions(bool unquotedStrings);
    private static FormattingOptions();
    [CompilerGeneratedAttribute]
public static FormattingOptions get_Default();
    [CompilerGeneratedAttribute]
public static FormattingOptions get_Unquoted();
    [CompilerGeneratedAttribute]
public bool get_RequiresUnquotedStrings();
}
public abstract class PostSharp.Patterns.Formatters.FormattingRole : object {
    public string Name { get; }
    public string LoggingRole { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_LoggingRole();
}
public interface PostSharp.Patterns.Formatters.IFormattable {
    public abstract virtual void Format(UnsafeStringBuilder stringBuilder, FormattingRole role);
}
public interface PostSharp.Patterns.Formatters.IFormatter {
    public FormatterAttributes Attributes { get; }
    public abstract virtual void Write(UnsafeStringBuilder stringBuilder, object value);
    public abstract virtual FormatterAttributes get_Attributes();
}
public interface PostSharp.Patterns.Formatters.IFormatter`1 {
    public abstract virtual void Write(UnsafeStringBuilder stringBuilder, T value);
}
public class PostSharp.Patterns.Formatters.Int16Formatter : Formatter`1<short> {
    public static Int16Formatter Instance;
    private static Int16Formatter();
    public virtual void Write(UnsafeStringBuilder stringBuilder, short value);
}
public class PostSharp.Patterns.Formatters.Int32Formatter : Formatter`1<int> {
    public static Int32Formatter Instance;
    private static Int32Formatter();
    public virtual void Write(UnsafeStringBuilder stringBuilder, int value);
}
public class PostSharp.Patterns.Formatters.Int64Formatter : Formatter`1<long> {
    public static Int64Formatter Instance;
    private static Int64Formatter();
    public virtual void Write(UnsafeStringBuilder stringBuilder, long value);
}
public interface PostSharp.Patterns.Formatters.IOptionAwareFormatter {
    public abstract virtual IOptionAwareFormatter WithOptions(FormattingOptions options);
}
public class PostSharp.Patterns.Formatters.MethodFormatter : Formatter`1<MethodBase> {
    private static RegexOptions regexOptions;
    private static string anonymousMethodRegexPattern;
    private ConcurrentDictionary`2<MethodBase, Match> matchCache;
    public static MethodFormatter Instance;
    private static MethodFormatter();
    public virtual void Write(UnsafeStringBuilder stringBuilder, MethodBase value);
}
internal class PostSharp.Patterns.Formatters.NonQuotingCharFormatter : Formatter`1<char> {
    public static NonQuotingCharFormatter Instance;
    private static NonQuotingCharFormatter();
    public virtual void Write(UnsafeStringBuilder stringBuilder, char value);
}
internal class PostSharp.Patterns.Formatters.NonQuotingStringFormatter : Formatter`1<string> {
    public static NonQuotingStringFormatter Instance;
    private static NonQuotingStringFormatter();
    public virtual void Write(UnsafeStringBuilder stringBuilder, string value);
}
internal class PostSharp.Patterns.Formatters.NullableFormatter`2 : Formatter`1<Nullable`1<T>> {
    public virtual void Write(UnsafeStringBuilder stringBuilder, Nullable`1<T> value);
}
public class PostSharp.Patterns.Formatters.SByteFormatter : Formatter`1<sbyte> {
    public static SByteFormatter Instance;
    private static SByteFormatter();
    public virtual void Write(UnsafeStringBuilder stringBuilder, sbyte value);
}
public class PostSharp.Patterns.Formatters.StringFormatter : Formatter`1<string> {
    public static StringFormatter Instance;
    private static StringFormatter();
    public virtual void Write(UnsafeStringBuilder stringBuilder, string value);
    public virtual IOptionAwareFormatter WithOptions(FormattingOptions options);
}
public class PostSharp.Patterns.Formatters.TypeFormatter : Formatter`1<Type> {
    private bool includeNamespace;
    private static Dictionary`2<Type, string> specialTypeNames;
    public static TypeFormatter Instance;
    public TypeFormatter(bool includeNamespace);
    private static TypeFormatter();
    public virtual void Write(UnsafeStringBuilder stringBuilder, Type value);
    private void WriteCore(UnsafeStringBuilder stringBuilder, Type type, bool removeArity, Type[] genericArguments);
    private string GetTypeName(Type type);
    private bool IsTrivialNamespace(Type type);
    private static string RemoveArity(string typeName, bool condition);
}
public class PostSharp.Patterns.Formatters.UInt16Formatter : Formatter`1<ushort> {
    public static UInt16Formatter Instance;
    private static UInt16Formatter();
    public virtual void Write(UnsafeStringBuilder stringBuilder, ushort value);
}
public class PostSharp.Patterns.Formatters.UInt32Formatter : Formatter`1<UInt32> {
    public static UInt32Formatter Instance;
    private static UInt32Formatter();
    public virtual void Write(UnsafeStringBuilder stringBuilder, UInt32 value);
}
public class PostSharp.Patterns.Formatters.UInt64Formatter : Formatter`1<ulong> {
    public static UInt64Formatter Instance;
    private static UInt64Formatter();
    public virtual void Write(UnsafeStringBuilder stringBuilder, ulong value);
}
public class PostSharp.Patterns.Formatters.UnsafeString : object {
    private int version;
    private Char[] array;
    private string str;
    [CompilerGeneratedAttribute]
private UnsafeStringBuilder <StringBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [ExplicitCrossPackageInternalAttribute]
internal UnsafeStringBuilder StringBuilder { get; private set; }
    public IntPtr Buffer { get; }
    internal Char[] CharArray { get; }
    public bool IsImmutable { get; }
    public int Length { get; private set; }
    internal UnsafeString(UnsafeStringBuilder stringBuilder);
    public UnsafeString(string str);
    public UnsafeString(Char[] array);
    [CompilerGeneratedAttribute]
internal UnsafeStringBuilder get_StringBuilder();
    [CompilerGeneratedAttribute]
private void set_StringBuilder(UnsafeStringBuilder value);
    public IntPtr get_Buffer();
    internal Char[] get_CharArray();
    public bool get_IsImmutable();
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(int value);
    internal bool Recycle();
    public void MakeImmutable();
    public ArraySegment`1<char> ToCharArray();
    private void CheckVersion();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class PostSharp.Patterns.Formatters.UnsafeStringBuilder : object {
    private Char[] array;
    private Char* cursor;
    private Char* start;
    private Char* end;
    private GCHandle gcHandle;
    private UnsafeString unsafeString;
    [CompilerGeneratedAttribute]
private bool <ThrowOnOverflow>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    public bool ThrowOnOverflow { get; }
    public int Capacity { get; }
    public int Version { get; private set; }
    public bool IsDisposed { get; }
    public int Length { get; }
    public IntPtr Buffer { get; }
    internal Char[] CharArray { get; }
    public char Item { get; public set; }
    public UnsafeStringBuilder(int capacity, bool throwOnOverflow);
    public UnsafeStringBuilder(Char* buffer, int size, bool throwOnOverflow);
    [CompilerGeneratedAttribute]
public bool get_ThrowOnOverflow();
    public int get_Capacity();
    private bool OnOverflow();
    public bool Append(char c);
    public bool Append(char c1, char c2);
    public bool Append(char c1, char c2, char c3);
    public bool Append(char c1, char c2, char c3, char c4);
    public bool Append(char c1, char c2, char c3, char c4, char c5);
    public bool Append(Char[] c, int offset, int count);
    public bool Append(Char* c, int count);
    public bool Append(char c, int count);
    public bool Append(Char[] c);
    public bool Append(string str);
    public bool Append(string str, int startIndex, int length);
    public bool Append(CharSpan& span);
    public bool Append(UnsafeString s);
    public bool Append(UnsafeStringBuilder stringBuilder);
    public bool Append(byte value);
    public bool Append(sbyte value);
    private void AppendByte(byte value);
    public bool Append(ushort value);
    public bool Append(short value);
    private void AppendUInt16(ushort value);
    public bool Append(UInt32 value);
    public bool Append(int value);
    private void AppendUInt32(UInt32 value);
    private void AppendPaddedUInt32(UInt32 value);
    public bool Append(ulong value);
    public bool Append(long value);
    private void AppendUInt64(ulong value);
    public bool Append(bool value);
    public void Clear();
    public virtual string ToString();
    public string Substring(int startIndex);
    public string Substring(int startIndex, int length);
    internal string ToStringImpl();
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(int value);
    public bool get_IsDisposed();
    public int get_Length();
    public void Truncate(int length);
    public IntPtr get_Buffer();
    internal Char[] get_CharArray();
    public UnsafeString ToUnsafeString();
    public bool SetNullTermination();
    public char get_Item(int index);
    public void set_Item(int index, char value);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
}
public class PostSharp.Patterns.Formatters.UnsafeStringBuilderPool : object {
    private ConcurrentStack`1<UnsafeStringBuilder> instances;
    [CompilerGeneratedAttribute]
private int <StringBuilderCapacity>k__BackingField;
    private bool throwOnOverflow;
    private int maxInstances;
    public int StringBuilderCapacity { get; }
    public UnsafeStringBuilderPool(int stringBuilderCapacity, bool throwOnOverflow, int maxInstances);
    [CompilerGeneratedAttribute]
public int get_StringBuilderCapacity();
    public UnsafeStringBuilder GetInstance();
    public void ReturnInstance(UnsafeStringBuilder stringBuilder);
    public sealed virtual void Dispose();
}
public enum PostSharp.Patterns.Model.ObjectAccessLevel : Enum {
    public int value__;
    public static ObjectAccessLevel None;
    public static ObjectAccessLevel Unknown;
    public static ObjectAccessLevel Read;
    public static ObjectAccessLevel Write;
    public static ObjectAccessLevel UpgradeableRead;
    public static ObjectAccessLevel Unchecked;
    public static ObjectAccessLevel Yield;
    public static ObjectAccessLevel Inherit;
}
[AttributeUsageAttribute("13")]
public class PostSharp.Patterns.Threading.AssumeImmutableAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <TargetType>k__BackingField;
    public Type TargetType { get; private set; }
    public AssumeImmutableAttribute(Type targetType);
    [CompilerGeneratedAttribute]
public Type get_TargetType();
    [CompilerGeneratedAttribute]
private void set_TargetType(Type value);
}
internal static class PostSharp.Patterns.Threading.ConcurrencyTestingApi : object {
    public static ConcurrencyTestingApiImpl Implementation;
    [ConditionalAttribute("DEBUG")]
public static void TraceEvent(string message);
}
internal abstract class PostSharp.Patterns.Threading.ConcurrencyTestingApiImpl : object {
    public abstract virtual void TraceEvent(string message);
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Threading.ConcurrentAccessAwaiter : ValueType {
    private ConcurrentAccessOperation operation;
    private ConcurrentAccessToken immediateResult;
    public bool IsCompleted { get; }
    [ExplicitCrossPackageInternalAttribute]
internal ConcurrentAccessAwaiter(ConcurrentAccessOperation operation);
    [ExplicitCrossPackageInternalAttribute]
internal ConcurrentAccessAwaiter(ConcurrentAccessToken immediateResult);
    public bool get_IsCompleted();
    public ConcurrentAccessAwaiter GetAwaiter();
    public ConcurrentAccessToken GetResult();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
}
[ExplicitCrossPackageInternalAttribute]
internal abstract class PostSharp.Patterns.Threading.ConcurrentAccessOperation : object {
    public bool IsCompleted { get; }
    public abstract virtual bool get_IsCompleted();
    public abstract virtual ConcurrentAccessToken GetResult();
    public abstract virtual void OnCompleted(Action continuation);
    public abstract virtual void UnsafeOnCompleted(Action continuation);
}
public class PostSharp.Patterns.Threading.ConcurrentAccessToken : ValueType {
    private IConcurrencyControllerStrategy controller;
    private ushort contextId;
    private ushort threadId;
    private short flags;
    [ThreadStaticAttribute]
private static ThreadStaticState threadStaticState;
    [ExplicitCrossPackageInternalAttribute]
internal short Flags { get; internal set; }
    [ExplicitCrossPackageInternalAttribute]
internal IConcurrencyControllerStrategy Controller { get; }
    public static ConcurrentAccessToken Null { get; }
    internal short get_Flags();
    internal void set_Flags(short value);
    internal IConcurrencyControllerStrategy get_Controller();
    private static ThreadStaticState GetThreadStaticState();
    [ExplicitCrossPackageInternalAttribute]
internal static ConcurrentAccessToken Create(IConcurrencyControllerStrategy controller, short flags);
    [ExplicitCrossPackageInternalAttribute]
internal void Initialize(IConcurrencyControllerStrategy controller, short flags);
    [ExplicitCrossPackageInternalAttribute]
internal void Reset();
    private void PushContext();
    private void PopContext();
    public bool CheckContext(bool canBeParentContext);
    private void AssertContext();
    internal void Resume();
    internal void Suspend();
    public void Complete();
    public void Cancel();
    public sealed virtual void Dispose();
    [ExplicitCrossPackageInternalAttribute]
internal ConcurrentAccessAwaiter ResumeAsync();
    private static ConcurrentAccessToken ResumeAsyncContinuation(ConcurrentAccessToken token);
    [ExplicitCrossPackageInternalAttribute]
internal ConcurrentAccessAwaiter SuspendAsync();
    [ExplicitCrossPackageInternalAttribute]
internal ConcurrentAccessAwaiter CompleteAsync();
    [ExplicitCrossPackageInternalAttribute]
internal ConcurrentAccessAwaiter CancelAsync();
    public static ConcurrentAccessToken get_Null();
}
[InternalImplementAttribute]
[HasConstraintAttribute]
public interface PostSharp.Patterns.Threading.IConcurrencyController {
    public bool IsSharable { get; }
    public bool IsReadOnly { get; }
    public ThreadingModel ThreadingModel { get; }
    public abstract virtual bool get_IsSharable();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual void AcquireAccess(ObjectAccessLevel objectAccessLevel, ConcurrentAccessToken& concurrencyAccessToken);
    public abstract virtual ConcurrentAccessAwaiter AcquireAccessAsync(ObjectAccessLevel objectAccessLevel);
    public abstract virtual bool CheckAccess(ObjectAccessLevel objectAccessLevel);
    public abstract virtual void RequireAccess(ObjectAccessLevel objectAccessLevel);
    public abstract virtual ThreadingModel get_ThreadingModel();
}
[ExplicitCrossPackageInternalAttribute]
internal interface PostSharp.Patterns.Threading.IConcurrencyControllerDiagnostics {
    public long Acquisitions { get; }
    public long Waits { get; }
    public long WaitingTicks { get; }
    public long Awaits { get; }
    public long AwaitingTicks { get; }
    public abstract virtual long get_Acquisitions();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Waiting(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Waiting(EventHandler value);
    public abstract virtual long get_Waits();
    public abstract virtual long get_WaitingTicks();
    public abstract virtual long get_Awaits();
    public abstract virtual long get_AwaitingTicks();
}
[ExplicitCrossPackageInternalAttribute]
internal interface PostSharp.Patterns.Threading.IConcurrencyControllerStrategy {
    public abstract virtual void Resume(ConcurrentAccessToken& token);
    public abstract virtual void Suspend(ConcurrentAccessToken& token);
    public abstract virtual void Release(ConcurrentAccessToken& token);
    public abstract virtual ConcurrentAccessAwaiter ResumeAsync(ConcurrentAccessToken token);
    public abstract virtual ConcurrentAccessAwaiter SuspendAsync(ConcurrentAccessToken token);
    public abstract virtual ConcurrentAccessAwaiter ReleaseAsync(ConcurrentAccessToken token);
}
[InternalImplementAttribute]
[HasConstraintAttribute]
public interface PostSharp.Patterns.Threading.IThreadAware {
    public IConcurrencyController ConcurrencyController { get; }
    public abstract virtual void OnParentControllerChanged(IConcurrencyController parentController);
    public abstract virtual IConcurrencyController get_ConcurrencyController();
}
[ExplicitCrossPackageInternalAttribute]
internal class PostSharp.Patterns.Threading.NullConcurrencyController : object {
    public static NullConcurrencyController Instance;
    public bool IsSharable { get; }
    public bool IsReadOnly { get; }
    public ThreadingModel ThreadingModel { get; }
    private static NullConcurrencyController();
    public sealed virtual bool get_IsSharable();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void AcquireAccess(ObjectAccessLevel objectAccessLevel, ConcurrentAccessToken& concurrencyAccessToken);
    public sealed virtual ConcurrentAccessAwaiter AcquireAccessAsync(ObjectAccessLevel objectAccessLevel);
    public sealed virtual bool CheckAccess(ObjectAccessLevel objectAccessLevel);
    public sealed virtual void RequireAccess(ObjectAccessLevel objectAccessLevel);
    public virtual ThreadingModel get_ThreadingModel();
}
[ExplicitCrossPackageInternalAttribute]
internal class PostSharp.Patterns.Threading.NullThreadingModel : ThreadingModel {
    public static NullThreadingModel Instance;
    internal ThreadingModelIdentifier Identifier { get; }
    internal bool RequiresYieldOnEventInvocation { get; }
    internal bool RequiresCheckedReads { get; }
    internal bool RequiresCheckedWrites { get; }
    public bool IsBlocking { get; }
    public bool IsThreadSafe { get; }
    private static NullThreadingModel();
    internal virtual ThreadingModelIdentifier get_Identifier();
    internal virtual bool get_RequiresYieldOnEventInvocation();
    internal virtual bool get_RequiresCheckedReads();
    internal virtual bool get_RequiresCheckedWrites();
    internal virtual bool RequiresAcquire(bool runtimeVerificationEnabled);
    public virtual bool get_IsBlocking();
    public virtual bool get_IsThreadSafe();
    internal virtual ThreadingModelCompatibility GetChildModelCompatibility(ThreadingModel childModel);
}
[ExplicitCrossPackageInternalAttribute]
internal class PostSharp.Patterns.Threading.Primitives.AwaitableEvent : object {
    private static TimeSpan infiniteTimeSpan;
    internal static int NOT_SIGNALED;
    internal static int SIGNALED;
    internal static int CREATED;
    internal static int WAITING;
    internal static int SUCCESS;
    internal static int TIMEOUT;
    private int resetMode;
    internal PortableConcurrentQueue`1<WaitOperationBase> operations;
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) signalState;
    [ThreadStaticAttribute]
private static ManualResetEventSlim modreq(System.Runtime.CompilerServices.IsVolatile) threadLocalEvent;
    public AwaitableEvent(EventResetMode resetMode);
    public AwaitableEvent(EventResetMode resetMode, bool signaled);
    private static AwaitableEvent();
    public bool Wait();
    public bool Wait(TimeSpan timeout);
    public Awaiter WaitAsync();
    public Awaiter WaitAsync(TimeSpan timeout);
    public Awaiter WaitAsync(CancellationToken cancellationToken);
    public Awaiter WaitAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public Awaiter`1<TData> WaitAsync();
    public Awaiter`1<TData> WaitAsync(TimeSpan timeout);
    public Awaiter`1<TData> WaitAsync(CancellationToken cancellationToken);
    public Awaiter`1<TData> WaitAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public void Set();
    private void SetAutoReset();
    private void SetManualReset();
    public void Reset();
    private static ManualResetEventSlim GetThreadLocalEvent();
    private bool WaitInternal(TimeSpan timeout);
    private bool NoWaitAutoReset();
    private bool NoWaitManualReset();
    private bool WaitAutoReset(TimeSpan timeout);
    private bool WaitManualReset(TimeSpan timeout);
    private Awaiter WaitOneAsyncInternal(TimeSpan timeout, CancellationToken cancellationToken);
    private Awaiter`1<TData> WaitOneAsyncInternal(TimeSpan timeout, CancellationToken cancellationToken);
    internal void ScheduleContinuation(WaitOperationAsync op, Action continuation, bool flowContext);
    internal void ScheduleContinuation(WaitOperationAsync`1<TData> op, Action`1<WaitOperationAsync`1<TData>> continuation, bool flowContext);
    private void ScheduleContinuationInner(WaitOperationAsyncBase op);
}
[ExplicitCrossPackageInternalAttribute]
internal class PostSharp.Patterns.Threading.Primitives.AwaitableReaderWriterLock : object {
    private bool fIsReentrant;
    private PortableSpinLock myLock;
    private UInt32 numWriteWaiters;
    private UInt32 numReadWaiters;
    private UInt32 numWriteUpgradeWaiters;
    private UInt32 numUpgradeWaiters;
    private bool fNoWaiters;
    private long upgradeLockOwnerId;
    private long writeLockOwnerId;
    private AwaitableEvent writeEvent;
    private AwaitableEvent readEvent;
    private AwaitableEvent upgradeEvent;
    private AwaitableEvent writeUpgradeEvent;
    private static long nextLockId;
    private long lockId;
    [ThreadStaticAttribute]
private static ReaderWriterCount tRwc;
    private bool fUpgradeThreadHoldingRead;
    private static int maxSpinCount;
    private static int FLOW_RETURN_FALSE;
    private static int FLOW_RETURN_TRUE;
    private static int FLOW_RESTART;
    private static int FLOW_EXIT;
    private static int FLOW_CONTINUE;
    private static int OPTYPE_READ;
    private static int OPTYPE_WRITE;
    private static int OPTYPE_UPGRADE;
    private static int OPTYPE_WRITEUPGRADE;
    private static int OPSTATE_WAITING;
    private static int OPSTATE_SUCCESS;
    private static int OPSTATE_TIMEOUT;
    private UInt32 owners;
    private static UInt32 WRITER_HELD;
    private static UInt32 WAITING_WRITERS;
    private static UInt32 WAITING_UPGRADER;
    private static UInt32 MAX_READER;
    private static UInt32 READER_MASK;
    private static string LockRecursionException_ReadAfterWriteNotAllowed;
    private static string LockRecursionException_RecursiveReadNotAllowed;
    private static string LockRecursionException_RecursiveWriteNotAllowed;
    private static string LockRecursionException_WriteAfterReadNotAllowed;
    private static string LockRecursionException_RecursiveUpgradeNotAllowed;
    private static string LockRecursionException_UpgradeAfterWriteNotAllowed;
    private static string LockRecursionException_UpgradeAfterReadNotAllowed;
    private static string SynchronizationLockException_MisMatchedRead;
    private static string SynchronizationLockException_MisMatchedWrite;
    private static string SynchronizationLockException_MisMatchedUpgrade;
    private static Action`1<WaitOperationAsync`1<EnterLockOperationState>> waitOnEventContinuationDelegate;
    public bool IsReadLockHeld { get; }
    public bool IsUpgradeableReadLockHeld { get; }
    public bool IsWriteLockHeld { get; }
    public LockRecursionPolicy RecursionPolicy { get; }
    public int CurrentReadCount { get; }
    public int RecursiveReadCount { get; }
    public int RecursiveUpgradeCount { get; }
    public int RecursiveWriteCount { get; }
    public int WaitingReadCount { get; }
    public int WaitingUpgradeCount { get; }
    public int WaitingWriteCount { get; }
    public AwaitableReaderWriterLock(LockRecursionPolicy recursionPolicy);
    private static AwaitableReaderWriterLock();
    private void InitializeThreadCounts();
    private static bool IsRwEntryEmpty(ReaderWriterCount rwc);
    private bool IsRwHashEntryChanged(ReaderWriterCount lrwc);
    private ReaderWriterCount GetThreadRwCount(bool dontAllocate);
    private static void SetEnterLockContinuation(Awaiter awaiter, Action continuation, bool flowContext);
    public void EnterReadLock();
    public Awaiter EnterReadLockAsync();
    public bool TryEnterReadLock(TimeSpan timeout);
    public Awaiter TryEnterReadLockAsync(TimeSpan timeout);
    public bool TryEnterReadLock(int millisecondsTimeout);
    public Awaiter TryEnterReadLockAsync(int millisecondsTimeout);
    private bool TryEnterReadLock(TimeoutTracker timeout);
    private Awaiter TryEnterReadLockAsync(TimeoutTracker timeout);
    private bool TryEnterReadLockCore(TimeoutTracker timeout);
    private Awaiter TryEnterReadLockAsyncCore(TimeoutTracker timeout);
    private static void TryEnterReadLockAsyncCoreContinuation(WaitOperationAsync`1<EnterLockOperationState> operation);
    private bool TryEnterReadLockNoWait(ReaderWriterCount& lrwc);
    private int TryEnterReadLockPreWait(ReaderWriterCount& lrwc, Int32& spincount, TimeoutTracker timeout);
    private void TryEnterReadLockPostWait(ReaderWriterCount& lrwc);
    public void EnterWriteLock();
    public Awaiter EnterWriteLockAsync();
    public bool TryEnterWriteLock(TimeSpan timeout);
    public Awaiter TryEnterWriteLockAsync(TimeSpan timeout);
    public bool TryEnterWriteLock(int millisecondsTimeout);
    public Awaiter TryEnterWriteLockAsync(int millisecondsTimeout);
    private bool TryEnterWriteLock(TimeoutTracker timeout);
    private Awaiter TryEnterWriteLockAsync(TimeoutTracker timeout);
    private bool TryEnterWriteLockCore(TimeoutTracker timeout);
    private Awaiter TryEnterWriteLockAsyncCore(TimeoutTracker timeout);
    private static void TryEnterWriteLockAsyncCoreContinuation(bool upgradingToWrite, WaitOperationAsync`1<EnterLockOperationState> operation);
    private bool TryEnterWriteLockCoreNoWait(long id, Boolean& upgradingToWrite, ReaderWriterCount& lrwc);
    private int TryEnterWriteLockPreWait(ReaderWriterCount& lrwc, Int32& spincount, bool upgradingToWrite, TimeoutTracker timeout);
    private void TryEnterWriteLockEnd(ReaderWriterCount& lrwc, long id);
    public void EnterUpgradeableReadLock();
    public Awaiter EnterUpgradeableReadLockAsync();
    public bool TryEnterUpgradeableReadLock(TimeSpan timeout);
    public Awaiter TryEnterUpgradeableReadLockAsync(TimeSpan timeout);
    public bool TryEnterUpgradeableReadLock(int millisecondsTimeout);
    public Awaiter TryEnterUpgradeableReadLockAsync(int millisecondsTimeout);
    private bool TryEnterUpgradeableReadLock(TimeoutTracker timeout);
    private Awaiter TryEnterUpgradeableReadLockAsync(TimeoutTracker timeout);
    private bool TryEnterUpgradeableReadLockCore(TimeoutTracker timeout);
    private Awaiter TryEnterUpgradeableReadLockAsyncCore(TimeoutTracker timeout);
    private static void TryEnterUpgradeableReadLockAsyncCoreContinuation(WaitOperationAsync`1<EnterLockOperationState> operation);
    private static void TryEnterUpgradeableReadLockAsyncCoreContinuation(WaitOperationAsync`1<EnterLockOperationReference> operation);
    private bool TryEnterUpgradeableReadLockNoWait(long id, ReaderWriterCount& lrwc);
    private int TryEnterUpgradeableReadLockPreWait(Int32& spincount, long id, TimeoutTracker timeout);
    private void TryEnterUpgradeableReadLockEnd(ReaderWriterCount& lrwc);
    public void ExitReadLock();
    public void ExitWriteLock();
    public void ExitUpgradeableReadLock();
    private void LazyCreateEvent(AwaitableEvent& waitEvent, bool makeAutoResetEvent);
    private bool WaitOnEvent(AwaitableEvent waitEvent, int operationType, TimeoutTracker timeout);
    private Awaiter`1<EnterLockOperationState> WaitOnEventAsyncInitial(AwaitableEvent waitEvent, int operationType, TimeoutTracker timeout);
    private Awaiter`1<EnterLockOperationReference> WaitOnEventAsyncSubsequent(WaitOperationAsync`1<EnterLockOperationState> initialOperation);
    private static void WaitOnEventContinuation(WaitOperationAsync`1<EnterLockOperationState> operation);
    private static void WaitOnEventContinuation(WaitOperationAsync`1<EnterLockOperationReference> operation);
    private void WaitOnEventPreWait(AwaitableEvent waitEvent, int operationType);
    private void WaitOnEventPostWait(int operationType, bool waitSuccessful);
    private void ExitAndWakeUpAppropriateWaiters();
    private void ExitAndWakeUpAppropriateWaitersPreferringWriters();
    private bool IsWriterAcquired();
    private void SetWriterAcquired();
    private void ClearWriterAcquired();
    private void SetWritersWaiting();
    private void ClearWritersWaiting();
    private void SetUpgraderWaiting();
    private void ClearUpgraderWaiting();
    private UInt32 GetNumReaders();
    private void EnterMyLock();
    private void ExitMyLock();
    private static void SpinWait(int spinCount);
    public bool get_IsReadLockHeld();
    public bool get_IsUpgradeableReadLockHeld();
    public bool get_IsWriteLockHeld();
    public LockRecursionPolicy get_RecursionPolicy();
    public int get_CurrentReadCount();
    public int get_RecursiveReadCount();
    public int get_RecursiveUpgradeCount();
    public int get_RecursiveWriteCount();
    public int get_WaitingReadCount();
    public int get_WaitingUpgradeCount();
    public int get_WaitingWriteCount();
}
[ExplicitCrossPackageInternalAttribute]
internal class PostSharp.Patterns.Threading.Primitives.PortableConcurrentDictionary`2 : ConcurrentDictionary`2<TKey, TValue> {
    public PortableConcurrentDictionary`2(IDictionary`2<TKey, TValue> content);
    public PortableConcurrentDictionary`2(IEqualityComparer`1<TKey> comparer);
}
[ExplicitCrossPackageInternalAttribute]
internal class PostSharp.Patterns.Threading.Primitives.PortableConcurrentQueue`1 : ConcurrentQueue`1<T> {
}
[ExplicitCrossPackageInternalAttribute]
internal static class PostSharp.Patterns.Threading.Primitives.PortableLazyInitializer : object {
    public static void EnsureInitialized(T& target, Func`1<T> valueFactory);
}
[ExplicitCrossPackageInternalAttribute]
internal class PostSharp.Patterns.Threading.Primitives.PortableSpinLock : ValueType {
    private SpinLock spinLock;
    public bool IsHeldByCurrentThread { get; }
    public bool get_IsHeldByCurrentThread();
    public void Enter(Boolean& lockTaken);
    public void Exit(bool useMemoryBarrier);
}
internal class PostSharp.Patterns.Threading.Primitives.PortableSpinWait : object {
    private SpinWait spinWait;
    public void SpinOnce();
}
[ExplicitCrossPackageInternalAttribute]
internal static class PostSharp.Patterns.Threading.Primitives.PortableThreadingApi : object {
    public static long NullThreadId;
    public static Task CompletedTask;
    private static PortableThreadingApi();
    public static void MemoryBarrier();
    public static ThreadInfo GetCurrentThread();
}
[ExplicitCrossPackageInternalAttribute]
internal class PostSharp.Patterns.Threading.Primitives.ThreadInfo : object {
    [ThreadStaticAttribute]
private static ThreadInfo current;
    private long threadId;
    public long ThreadId { get; }
    public long get_ThreadId();
    public static ThreadInfo GetCurrent();
}
[ExtensionAttribute]
public static class PostSharp.Patterns.Threading.ThreadAwareExtensions : object {
    [ExtensionAttribute]
public static ConcurrentAccessToken AcquireAccess(IThreadAware instance, ObjectAccessLevel objectAccessLevel);
    [ExtensionAttribute]
public static void AcquireAccess(IThreadAware instance, ObjectAccessLevel objectAccessLevel, ConcurrentAccessToken& concurrentAccessToken);
    [ExtensionAttribute]
public static ConcurrentAccessAwaiter AcquireAccessAsync(IThreadAware instance, ObjectAccessLevel objectAccessLevel);
    private static void RegisterAcquireAccessAsyncContinuation(AcquireAccessAsyncOperation op, Action continuation, bool flowContext);
    private static void ContinueAcquireAccessAsync(AcquireAccessAsyncOperation op);
}
public abstract class PostSharp.Patterns.Threading.ThreadingException : Exception {
    protected ThreadingException(string message);
    protected ThreadingException(string message, Exception inner);
    protected ThreadingException(SerializationInfo info, StreamingContext context);
}
public abstract class PostSharp.Patterns.Threading.ThreadingModel : object {
    private Dictionary`2<ThreadingModelIdentifier, ThreadingModelCompatibility> compatibleChildModels;
    [ExplicitCrossPackageInternalAttribute]
internal ThreadingModelIdentifier Identifier { get; }
    [ExplicitCrossPackageInternalAttribute]
internal bool RequiresYieldOnEventInvocation { get; }
    [ExplicitCrossPackageInternalAttribute]
internal bool RequiresCheckedReads { get; }
    [ExplicitCrossPackageInternalAttribute]
internal bool RequiresCheckedWrites { get; }
    public bool IsBlocking { get; }
    public bool IsThreadSafe { get; }
    [ExplicitCrossPackageInternalAttribute]
internal void AddCompatibleChildModel(ThreadingModelIdentifier threadingModel, ThreadingModelCompatibility threadingModelCompatibility);
    internal abstract virtual ThreadingModelIdentifier get_Identifier();
    internal abstract virtual bool get_RequiresYieldOnEventInvocation();
    internal abstract virtual bool get_RequiresCheckedReads();
    internal abstract virtual bool get_RequiresCheckedWrites();
    [ExplicitCrossPackageInternalAttribute]
internal virtual bool RequiresPrivateFields();
    [ExplicitCrossPackageInternalAttribute]
internal abstract virtual bool RequiresAcquire(bool runtimeVerificationEnabled);
    public abstract virtual bool get_IsBlocking();
    public abstract virtual bool get_IsThreadSafe();
    [ExplicitCrossPackageInternalAttribute]
internal virtual ThreadingModelCompatibility GetChildModelCompatibility(ThreadingModel childModel);
    public virtual string ToString();
    [ExplicitCrossPackageInternalAttribute]
internal bool IsValidChild(ThreadingModel threadingModel);
}
[ExplicitCrossPackageInternalAttribute]
internal enum PostSharp.Patterns.Threading.ThreadingModelCompatibility : Enum {
    public int value__;
    public static ThreadingModelCompatibility Incompatible;
    public static ThreadingModelCompatibility SharedController;
    public static ThreadingModelCompatibility OwnController;
}
[ExplicitCrossPackageInternalAttribute]
internal enum PostSharp.Patterns.Threading.ThreadingModelIdentifier : Enum {
    public int value__;
    public static ThreadingModelIdentifier None;
    public static ThreadingModelIdentifier Synchronized;
    public static ThreadingModelIdentifier ReaderWriterSynchronized;
    public static ThreadingModelIdentifier Immutable;
    public static ThreadingModelIdentifier Freezable;
    public static ThreadingModelIdentifier Actor;
    public static ThreadingModelIdentifier Private;
    public static ThreadingModelIdentifier ThreadUnsafe;
    public static ThreadingModelIdentifier ThreadAffine;
}
public static class PostSharp.Patterns.Threading.ThreadingPatternsAspectRoles : object {
    public static string ThreadingModel;
}
[ExplicitCrossPackageInternalAttribute]
internal class PostSharp.Patterns.Utilities.ArrayHelper : object {
    public static T[] Empty();
    public static T[] Append(T[] array, T item);
    public static T[] Append(T[] array, T[] additionalItems);
}
[ExplicitCrossPackageInternalAttribute]
internal static class PostSharp.Patterns.Utilities.BufferHelper : object {
    private static Nullable`1<bool> runningOnWindows;
    private static bool RunningOnWindows { get; }
    private static bool get_RunningOnWindows();
    public static void CopyMemory(Void* destination, Void* source, int length);
    public static int HashMemory(Byte* source, int count);
    public static int HashMemory(IntPtr source, int count, int initialHashCode);
    public static int HashMemory(Byte* source, int count, int initialHashCode);
    public static bool CompareMemory(Byte* left, Byte* right, int count);
    private static bool ManagedCompareMemory(Byte* left, Byte* right, int count);
    public static void ZeroMemory(Byte* target, int count);
}
[ExtensionAttribute]
[ExplicitCrossPackageInternalAttribute]
internal static class PostSharp.Patterns.Utilities.CollectionHelpers : object {
    [ExtensionAttribute]
public static bool AddIfNew(IList`1<T> list, T item);
    [ExtensionAttribute]
public static void AddToListValue(Dictionary`2<TKey, List`1<TValue>> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static void AddToListValueUnique(Dictionary`2<TKey, List`1<TValue>> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static TValue GetOrCreate(Dictionary`2<TKey, TValue> dictionary, TKey key, Func`1<TValue> valueFactory);
    [ExtensionAttribute]
public static void AddOrUpdate(Dictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
}
internal class PostSharp.Patterns.Utilities.CovariantTypeExtensionFactory`1 : TypeExtensionFactory`1<T> {
    public CovariantTypeExtensionFactory`1(Type genericInterfaceType, Type converterType, Type roleType, LogSource logger);
    [IteratorStateMachineAttribute("PostSharp.Patterns.Utilities.CovariantTypeExtensionFactory`1/<GetAssignableTypes>d__1")]
protected virtual IEnumerable`1<Type> GetAssignableTypes(Type type);
}
[ExplicitCrossPackageInternalAttribute]
internal static class PostSharp.Patterns.Utilities.DateTimeHelper : object {
    private static TimeSpan offset;
    private static DateTime nextSync;
    private static DateTimeHelper();
    public static DateTimeOffset GetCurrentDateTimeOffset();
    private static void Sync();
}
[ExplicitCrossPackageInternalAttribute]
internal class PostSharp.Patterns.Utilities.DeclarationIdentifierArrayBuilder`1 : object {
    private T[] array;
    private int maxMemberIndex;
    public void Add(MemberInfo member, T value);
    public T[] ToArray();
}
[ExplicitCrossPackageInternalAttribute]
internal static class PostSharp.Patterns.Utilities.DottedNameHelper : object {
    [ExplicitCrossPackageInternalAttribute]
internal static void Split(string fullName, String& shortName, String& parentName);
}
public interface PostSharp.Patterns.Utilities.IUnknownObjectPropertyVisitor`1 {
    public abstract virtual void Visit(string name, TValue value, TState& state);
    public abstract virtual bool MustVisit(string name, TState& state);
}
public abstract class PostSharp.Patterns.Utilities.LocalizedTextProvider : object {
    private LocalizedTextProvider next;
    protected LocalizedTextProvider(LocalizedTextProvider next);
    public virtual string GetMessage(string messageId);
    public virtual string FormatString(string format, Object[] arguments);
}
public class PostSharp.Patterns.Utilities.LocationBindingCollection : KeyedCollection`2<string, ILocationBinding> {
    protected virtual string GetKeyForItem(ILocationBinding item);
}
[ExtensionAttribute]
internal static class PostSharp.Patterns.Utilities.LocationKindExtensions : object {
    [ExtensionAttribute]
public static string GetDisplayName(LocationKind locationKind);
    [ExtensionAttribute]
public static string GetDisplayName(LocationKind locationKind, string locationName);
    [ExtensionAttribute]
public static string GetParameterName(LocationKind locationKind, string locationName);
}
internal static class PostSharp.Patterns.Utilities.ReentranceChecker : object {
    [ThreadStaticAttribute]
private static Node[] nodes;
    public static bool OnEnter(object obj);
    public static bool OnExit(object obj);
}
[ExtensionAttribute]
[ExplicitCrossPackageInternalAttribute]
internal static class PostSharp.Patterns.Utilities.ReflectionHelpers : object {
    [ExtensionAttribute]
public static IList`1<TAttribute> GetCustomAttributesFromMethodOrProperty(MethodInfo methodInfo);
    [IteratorStateMachineAttribute("PostSharp.Patterns.Utilities.ReflectionHelpers/<GetFieldsWithAttributeOnFieldOrProperty>d__1")]
public static IEnumerable`1<FieldInfo> GetFieldsWithAttributeOnFieldOrProperty(Type type, Type attributeType, bool inherit);
    public static bool IsDefinedOnFieldOrProperty(FieldInfo fieldInfo, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static bool IsDefinedOnMethodOrProperty(MethodInfo methodInfo, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static bool IsAnonymous(Type type);
}
[ExtensionAttribute]
[ExplicitCrossPackageInternalAttribute]
internal static class PostSharp.Patterns.Utilities.SerializationHelpers : object {
    private static ConditionalWeakTable`2<object, SerializationInfo> serializationInfoTable;
    internal static ConditionalWeakTable`2<object, SerializationInfo> SerializationInfoTable { get; }
    internal static ConditionalWeakTable`2<object, SerializationInfo> get_SerializationInfoTable();
    [ExtensionAttribute]
public static bool IsSerializable(Type type);
    [ExtensionAttribute]
public static bool IsDataContract(Type type);
}
public static class PostSharp.Patterns.Utilities.ServiceLocator : object {
    [CompilerGeneratedAttribute]
private static EventHandler`1<ServiceRegisteredEventArgs> ServiceRegistered;
    private static ServiceLocator();
    [CompilerGeneratedAttribute]
public static void add_ServiceRegistered(EventHandler`1<ServiceRegisteredEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_ServiceRegistered(EventHandler`1<ServiceRegisteredEventArgs> value);
    public static void RegisterService(T service);
    public static T GetService();
}
public class PostSharp.Patterns.Utilities.ServiceRegisteredEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    public Type ServiceType { get; }
    internal ServiceRegisteredEventArgs(Type type);
    [CompilerGeneratedAttribute]
public Type get_ServiceType();
}
[ExplicitCrossPackageInternalAttribute]
internal class PostSharp.Patterns.Utilities.StackContext : object {
    private Stack`1<object> stackTrace;
    public int Count { get; }
    public void PushOnStack(object o);
    public bool Pop(object o);
    public object Peek();
    public object Pop();
    public int get_Count();
    public sealed virtual IEnumerator`1<object> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExplicitCrossPackageInternalAttribute]
internal class PostSharp.Patterns.Utilities.StringTokenizer : ValueType {
    private string s;
    private int position;
    private char separator;
    public StringTokenizer(string s, char separator);
    public string GetNext();
    public string GetRest();
}
[ExplicitCrossPackageInternalAttribute]
internal class PostSharp.Patterns.Utilities.TypeExtensionCacheUpdateCallback`1 : MulticastDelegate {
    public TypeExtensionCacheUpdateCallback`1(object object, IntPtr method);
    public virtual void Invoke(TypeExtensionInfo`1<T> typeExtension);
    public virtual IAsyncResult BeginInvoke(TypeExtensionInfo`1<T> typeExtension, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ExplicitCrossPackageInternalAttribute]
internal class PostSharp.Patterns.Utilities.TypeExtensionFactory`1 : object {
    private Type genericInterfaceType;
    private Type converterType;
    private Type roleType;
    private LogSource logger;
    private Dictionary`2<Type, T> instances;
    private Dictionary`2<Type, Type> genericExtensionTypes;
    private Dictionary`2<Type, TypeExtensionCacheUpdateCallback`1<T>> cacheInvalidationCallbacks;
    public TypeExtensionFactory`1(Type genericInterfaceType, Type converterType, Type roleType, Logger logger);
    public TypeExtensionFactory`1(Type genericInterfaceType, Type converterType, Type roleType, LogSource logger);
    public void RegisterTypeExtension(Type targetType, T typeExtension);
    public void RegisterTypeExtension(Type targetType, Type typeExtensionType);
    private void TryInitialize(Type typeExtensionTargetType, Type typeExtensionType, Type registrationType, TypeExtensionCacheUpdateCallback`1<T> cacheUpdateCallback);
    private T GetExtensionCore(Type objectType, Boolean& isExtensionGeneric, Type& targetType);
    public void Clear();
    public TypeExtensionInfo`1<T> GetTypeExtension(Type objectType, TypeExtensionCacheUpdateCallback`1<T> cacheUpdateCallback, Func`1<T> createDefault);
    public T Convert(T o, Type targetObjectType);
    public static bool ShouldOverwrite(Type newExtensionTargetType, bool isNewGeneric, Type oldExtensionTargetType, bool isOldGeneric);
    private bool HasRoleTypeParameter(Type typeExtensionType);
    private Type MakeGenericExtensionType(Type extensionType, Type[] genericArguments);
    private static Type GetGenericTypeDefinition(Type type);
    private static Type MakeGenericType(Type type, Type[] typeArguments);
    private static Type[] GetGenericArguments(Type type);
    protected virtual IEnumerable`1<Type> GetAssignableTypes(Type type);
    private Type FindInterfaceGenericInstance(Type derivedType);
    [CompilerGeneratedAttribute]
private bool <FindInterfaceGenericInstance>b__23_0(Type type);
}
[ExplicitCrossPackageInternalAttribute]
internal class PostSharp.Patterns.Utilities.TypeExtensionInfo`1 : ValueType {
    [CompilerGeneratedAttribute]
private T <Extension>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ObjectType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGeneric>k__BackingField;
    public T Extension { get; private set; }
    public Type ObjectType { get; private set; }
    public bool IsGeneric { get; private set; }
    internal TypeExtensionInfo`1(T extension, Type objectType, bool isGeneric);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public T get_Extension();
    [CompilerGeneratedAttribute]
private void set_Extension(T value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Type get_ObjectType();
    [CompilerGeneratedAttribute]
private void set_ObjectType(Type value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsGeneric();
    [CompilerGeneratedAttribute]
private void set_IsGeneric(bool value);
    public bool ShouldOverwrite(TypeExtensionInfo`1<T> typeExtension);
}
[IsReadOnlyAttribute]
public class PostSharp.Patterns.Utilities.UnknownObjectAccessor : ValueType {
    private AccessorType type;
    private object instance;
    private UnknownObjectAccessor(object instance);
    private UnknownObjectAccessor(AccessorType type, object instance);
    public static Func`2<T, UnknownObjectAccessor> GetFactory();
    public static Func`2<object, UnknownObjectAccessor> GetFactory(Type type);
    public static UnknownObjectAccessor GetInstance(object value);
    public bool TryGetProperty(string name, T& value);
    public static bool TryGetProperty(object instance, string name, T& value);
    public IReadOnlyList`1<ValueTuple`2<string, object>> ToTuples();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(UnknownObjectAccessor other);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void VisitProperties(IUnknownObjectPropertyVisitor`1<TState> visitor, TState& state);
    public static bool op_Equality(UnknownObjectAccessor left, UnknownObjectAccessor right);
    public static bool op_Inequality(UnknownObjectAccessor left, UnknownObjectAccessor right);
    [IteratorStateMachineAttribute("PostSharp.Patterns.Utilities.UnknownObjectAccessor/<GetProperties>d__20")]
internal static IEnumerable`1<PropertyInfo> GetProperties(Type type);
}
[ExplicitCrossPackageInternalAttribute]
internal static class PostSharp.Reflection.BindingFlagsSet : object {
    public static BindingFlags AllMembers;
    public static BindingFlags AllInstanceDeclared;
    public static BindingFlags PublicInstanceDeclared;
    public static BindingFlags PublicInstance;
    public static BindingFlags AllInstance;
}
[ExtensionAttribute]
[ExplicitCrossPackageInternalAttribute]
internal static class PostSharp.Reflection.ReflectionApiWrapper : object {
    public static Type[] EmptyTypes;
    private static ReflectionApiWrapper();
    [ExtensionAttribute]
public static PropertyInfo GetProperty(Type type, string propertyName, BindingFlags flags, Type returnType, Type[] parameterTypes);
    [ExtensionAttribute]
public static MethodInfo GetMethod(Type type, string methodName, Type[] parameterTypes, BindingFlags flags);
    [ExtensionAttribute]
public static Assembly GetAssembly(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static bool IsStruct(Type type);
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
public static bool IsGenericTypeDefinition(Type type);
    [ExtensionAttribute]
public static bool IsGenericParameter(Type type);
    [ExtensionAttribute]
public static bool ContainsGenericParameters(Type type);
    [ExtensionAttribute]
public static bool IsSealed(Type type);
    [ExtensionAttribute]
public static bool IsPrimitive(Type type);
    [ExtensionAttribute]
public static bool IsInterface(Type type);
    [ExtensionAttribute]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
public static Type GetBaseType(Type type);
    [ExtensionAttribute]
public static TypeCode GetTypeCode(Type type);
    [ExtensionAttribute]
public static string FullName(MemberInfo memberInfo);
    [ExtensionAttribute]
public static string FullName(Type type);
    [ExtensionAttribute]
public static bool IsEventAccessor(MethodInfo methodInfo);
    [ExtensionAttribute]
public static bool IsPropertyAccessor(MethodInfo methodInfo);
    [ExtensionAttribute]
public static bool IsPropertyGetter(MethodInfo methodInfo);
    [ExtensionAttribute]
public static bool IsPropertySetter(MethodInfo methodInfo);
    [ExtensionAttribute]
public static bool IsInterfaceMethod(MethodInfo methodInfo);
    [ExtensionAttribute]
public static bool IsAsyncMethod(MethodInfo methodInfo);
    [ExtensionAttribute]
public static PropertyInfo GetAccessorProperty(MethodInfo methodInfo);
    [ExtensionAttribute]
public static PropertyInfo GetAccessorProperty(MethodInfo methodInfo, bool inherit);
    public static bool HasCustomAttribute(MemberInfo memberInfo, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static Type GetTypeDefinition(Type type);
    [ExtensionAttribute]
public static bool IsSubclassOf(Type type, Type baseType);
    [ExtensionAttribute]
public static bool ImplementsInterface(Type type, Type interfaceType);
    [ExtensionAttribute]
public static TypeAttributes GetAttributes(Type type);
    [ExtensionAttribute]
public static MethodInfo GetMethodInfo(Delegate d);
    [ExtensionAttribute]
public static Type AsType(MemberInfo memberInfo);
    public static Assembly LoadAssembly(string assemblyName);
    [ExtensionAttribute]
public static MethodBase GetDeclaringMethod(Type type);
    [ExtensionAttribute]
public static Type GetAttributeType(CustomAttributeData attribute);
}
