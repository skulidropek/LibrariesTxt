[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
public class PostSharp.Aspects.AdviceArgs : object {
    internal object InstanceField;
    [CompilerGeneratedAttribute]
private DeclarationIdentifier <DeclarationIdentifier>k__BackingField;
    public object Instance { get; public set; }
    public DeclarationIdentifier DeclarationIdentifier { get; public set; }
    private static AdviceArgs();
    [DebuggerHiddenAttribute]
public AdviceArgs(object instance);
    [DebuggerHiddenAttribute]
public sealed virtual object get_Instance();
    [DebuggerHiddenAttribute]
[InternalAttribute]
public sealed virtual void set_Instance(object value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public DeclarationIdentifier get_DeclarationIdentifier();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
[InternalAttribute]
public void set_DeclarationIdentifier(DeclarationIdentifier value);
}
public abstract class PostSharp.Aspects.Advices.Advice : Attribute {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinesOfCodeAvoided>k__BackingField;
    public string Description { get; public set; }
    public int LinesOfCodeAvoided { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public int get_LinesOfCodeAvoided();
    [CompilerGeneratedAttribute]
public void set_LinesOfCodeAvoided(int value);
}
public abstract class PostSharp.Aspects.Advices.AdviceInstance : object {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinesOfCodeAvoided>k__BackingField;
    public object MasterAspectMember { get; }
    public string Description { get; public set; }
    public int LinesOfCodeAvoided { get; public set; }
    public abstract virtual object get_MasterAspectMember();
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public int get_LinesOfCodeAvoided();
    [CompilerGeneratedAttribute]
public void set_LinesOfCodeAvoided(int value);
}
[AttributeUsageAttribute("2048")]
public abstract class PostSharp.Aspects.Advices.AdviceParameterAttribute : Attribute {
}
public class PostSharp.Aspects.Advices.ArgumentAttribute : AdviceParameterAttribute {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public int Index { get; private set; }
    public ArgumentAttribute(int index);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
private void set_Index(int value);
}
public class PostSharp.Aspects.Advices.ArgumentsAttribute : AdviceParameterAttribute {
}
public enum PostSharp.Aspects.Advices.AspectInitializationReason : Enum {
    public int value__;
    public static AspectInitializationReason None;
    public static AspectInitializationReason Manual;
    public static AspectInitializationReason Constructor;
    public static AspectInitializationReason Clone;
    public static AspectInitializationReason Deserialize;
}
public class PostSharp.Aspects.Advices.AsyncCallIdAttribute : AdviceParameterAttribute {
}
public class PostSharp.Aspects.Advices.AwaitedMethodAttribute : AdviceParameterAttribute {
}
public class PostSharp.Aspects.Advices.AwaitedTaskAttribute : AdviceParameterAttribute {
}
public class PostSharp.Aspects.Advices.AwaiterAttribute : AdviceParameterAttribute {
}
public class PostSharp.Aspects.Advices.BindingAttribute : AdviceParameterAttribute {
}
[AttributeUsageAttribute("708")]
public class PostSharp.Aspects.Advices.CopyCustomAttributesAttribute : Advice {
    [CompilerGeneratedAttribute]
private CustomAttributeOverrideAction <OverrideAction>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <Types>k__BackingField;
    public CustomAttributeOverrideAction OverrideAction { get; public set; }
    public Type[] Types { get; private set; }
    public CopyCustomAttributesAttribute(Type type);
    public CopyCustomAttributesAttribute(Type[] types);
    [CompilerGeneratedAttribute]
public CustomAttributeOverrideAction get_OverrideAction();
    [CompilerGeneratedAttribute]
public void set_OverrideAction(CustomAttributeOverrideAction value);
    [CompilerGeneratedAttribute]
public Type[] get_Types();
    [CompilerGeneratedAttribute]
private void set_Types(Type[] value);
}
public class PostSharp.Aspects.Advices.CurrentTaskAttribute : AdviceParameterAttribute {
}
public enum PostSharp.Aspects.Advices.CustomAttributeOverrideAction : Enum {
    public int value__;
    public static CustomAttributeOverrideAction Default;
    public static CustomAttributeOverrideAction Fail;
    public static CustomAttributeOverrideAction Ignore;
    public static CustomAttributeOverrideAction Add;
    public static CustomAttributeOverrideAction MergeAddProperty;
    public static CustomAttributeOverrideAction MergeReplaceProperty;
}
public class PostSharp.Aspects.Advices.DeclarationIdentifierAttribute : AdviceParameterAttribute {
}
public class PostSharp.Aspects.Advices.DeclarationNameAttribute : AdviceParameterAttribute {
    [CompilerGeneratedAttribute]
private bool <IncludeTypeName>k__BackingField;
    public bool IncludeTypeName { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IncludeTypeName();
    [CompilerGeneratedAttribute]
public void set_IncludeTypeName(bool value);
}
public class PostSharp.Aspects.Advices.Event`1 : object {
    [CompilerGeneratedAttribute]
private EventAccessor`1<TDelegate> <Add>k__BackingField;
    [CompilerGeneratedAttribute]
private EventAccessor`1<TDelegate> <Remove>k__BackingField;
    public EventAccessor`1<TDelegate> Add { get; private set; }
    public EventAccessor`1<TDelegate> Remove { get; private set; }
    public Event`1(EventAccessor`1<TDelegate> addDelegate, EventAccessor`1<TDelegate> removeDelegate);
    [CompilerGeneratedAttribute]
public EventAccessor`1<TDelegate> get_Add();
    [CompilerGeneratedAttribute]
private void set_Add(EventAccessor`1<TDelegate> value);
    [CompilerGeneratedAttribute]
public EventAccessor`1<TDelegate> get_Remove();
    [CompilerGeneratedAttribute]
private void set_Remove(EventAccessor`1<TDelegate> value);
}
public class PostSharp.Aspects.Advices.EventAccessor`1 : MulticastDelegate {
    public EventAccessor`1(object object, IntPtr method);
    public virtual void Invoke(TDelegate delegate);
    public virtual IAsyncResult BeginInvoke(TDelegate delegate, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class PostSharp.Aspects.Advices.FlowBehaviorAttribute : AdviceParameterAttribute {
}
[AttributeUsageAttribute("64")]
public abstract class PostSharp.Aspects.Advices.GroupingAdvice : Advice {
    [CompilerGeneratedAttribute]
private string <Master>k__BackingField;
    public string Master { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Master();
    [CompilerGeneratedAttribute]
public void set_Master(string value);
}
public interface PostSharp.Aspects.Advices.IAdviceProvider {
    public abstract virtual IEnumerable`1<AdviceInstance> ProvideAdvices(object targetElement);
}
internal interface PostSharp.Aspects.Advices.IImportMemberAdviseProperties {
    public bool IsRequired { get; }
    public String[] MemberNames { get; }
    public ImportMemberOrder Order { get; }
    public abstract virtual bool get_IsRequired();
    public abstract virtual String[] get_MemberNames();
    public abstract virtual ImportMemberOrder get_Order();
}
internal interface PostSharp.Aspects.Advices.IIntroduceInterfaceAdviceProperties {
    public InterfaceOverrideAction OverrideAction { get; }
    public InterfaceOverrideAction AncestorOverrideAction { get; }
    public Type InterfaceType { get; }
    public abstract virtual InterfaceOverrideAction get_OverrideAction();
    public abstract virtual InterfaceOverrideAction get_AncestorOverrideAction();
    public abstract virtual Type get_InterfaceType();
}
internal interface PostSharp.Aspects.Advices.IIntroduceMemberAdviceProperties {
    public Visibility Visibility { get; }
    public Nullable`1<bool> IsVirtual { get; }
    public MemberOverrideAction OverrideAction { get; }
    public abstract virtual Visibility get_Visibility();
    public abstract virtual Nullable`1<bool> get_IsVirtual();
    public abstract virtual MemberOverrideAction get_OverrideAction();
}
[FlagsAttribute]
internal enum PostSharp.Aspects.Advices.ImportKind : Enum {
    public int value__;
    public static ImportKind None;
    public static ImportKind Event;
    public static ImportKind LocationBinding;
    public static ImportKind Method;
    public static ImportKind Property;
    public static ImportKind All;
}
public class PostSharp.Aspects.Advices.ImportLocationAdviceInstance : ImportMemberAdviceInstance {
    private String[] memberNames;
    [CompilerGeneratedAttribute]
private LocationInfo <Location>k__BackingField;
    public LocationInfo Location { get; private set; }
    public object Member { get; }
    public String[] MemberNames { get; }
    public ImportLocationAdviceInstance(FieldInfo aspectField, LocationInfo location);
    public ImportLocationAdviceInstance(FieldInfo aspectField, string propertyName, bool isRequired, ImportMemberOrder order);
    public ImportLocationAdviceInstance(FieldInfo aspectField, String[] propertyNames, bool isRequired, ImportMemberOrder order);
    [CompilerGeneratedAttribute]
public LocationInfo get_Location();
    [CompilerGeneratedAttribute]
private void set_Location(LocationInfo value);
    public virtual object get_Member();
    public virtual String[] get_MemberNames();
}
public abstract class PostSharp.Aspects.Advices.ImportMemberAdviceInstance : AdviceInstance {
    [CompilerGeneratedAttribute]
private FieldInfo <AspectField>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private ImportMemberOrder <Order>k__BackingField;
    public FieldInfo AspectField { get; private set; }
    public bool IsRequired { get; private set; }
    public object Member { get; }
    public String[] MemberNames { get; }
    public ImportMemberOrder Order { get; private set; }
    public object MasterAspectMember { get; }
    internal ImportMemberAdviceInstance(FieldInfo aspectField, ImportMemberOrder order, bool isRequired);
    [CompilerGeneratedAttribute]
public FieldInfo get_AspectField();
    [CompilerGeneratedAttribute]
private void set_AspectField(FieldInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsRequired();
    [CompilerGeneratedAttribute]
private void set_IsRequired(bool value);
    public abstract virtual object get_Member();
    public abstract virtual String[] get_MemberNames();
    [CompilerGeneratedAttribute]
public sealed virtual ImportMemberOrder get_Order();
    [CompilerGeneratedAttribute]
private void set_Order(ImportMemberOrder value);
    public virtual object get_MasterAspectMember();
}
[AttributeUsageAttribute("256")]
public class PostSharp.Aspects.Advices.ImportMemberAttribute : Advice {
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <MemberNames>k__BackingField;
    [CompilerGeneratedAttribute]
private ImportMemberOrder <Order>k__BackingField;
    public bool IsRequired { get; public set; }
    public String[] MemberNames { get; private set; }
    public ImportMemberOrder Order { get; public set; }
    public ImportMemberAttribute(String[] memberNames);
    public ImportMemberAttribute(string memberName);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsRequired();
    [CompilerGeneratedAttribute]
public void set_IsRequired(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_MemberNames();
    [CompilerGeneratedAttribute]
private void set_MemberNames(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual ImportMemberOrder get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(ImportMemberOrder value);
}
public enum PostSharp.Aspects.Advices.ImportMemberOrder : Enum {
    public int value__;
    public static ImportMemberOrder Default;
    public static ImportMemberOrder BeforeIntroductions;
    public static ImportMemberOrder AfterIntroductions;
}
public class PostSharp.Aspects.Advices.ImportMethodAdviceInstance : ImportMemberAdviceInstance {
    private String[] memberNames;
    public object Member { get; }
    public String[] MemberNames { get; }
    public ImportMethodAdviceInstance(FieldInfo aspectField, string methodName, bool isRequired, ImportMemberOrder order);
    public ImportMethodAdviceInstance(FieldInfo aspectField, String[] methodNames, bool isRequired, ImportMemberOrder order);
    public virtual object get_Member();
    public virtual String[] get_MemberNames();
}
[AttributeUsageAttribute("64")]
[RequiresDebuggerEnhancementAttribute("2")]
public class PostSharp.Aspects.Advices.InitializeAspectInstanceAdvice : Advice {
}
public enum PostSharp.Aspects.Advices.InterfaceOverrideAction : Enum {
    public int value__;
    public static InterfaceOverrideAction Default;
    public static InterfaceOverrideAction Fail;
    public static InterfaceOverrideAction Ignore;
}
public class PostSharp.Aspects.Advices.IntroduceInterfaceAdviceInstance : AdviceInstance {
    [CompilerGeneratedAttribute]
private Type <InterfaceType>k__BackingField;
    [CompilerGeneratedAttribute]
private InterfaceOverrideAction <OverrideAction>k__BackingField;
    [CompilerGeneratedAttribute]
private InterfaceOverrideAction <AncestorOverrideAction>k__BackingField;
    public Type InterfaceType { get; private set; }
    public InterfaceOverrideAction OverrideAction { get; private set; }
    public InterfaceOverrideAction AncestorOverrideAction { get; private set; }
    public object MasterAspectMember { get; }
    public IntroduceInterfaceAdviceInstance(Type interfaceType, InterfaceOverrideAction overrideAction, InterfaceOverrideAction ancestorOverrideAction);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_InterfaceType();
    [CompilerGeneratedAttribute]
private void set_InterfaceType(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual InterfaceOverrideAction get_OverrideAction();
    [CompilerGeneratedAttribute]
private void set_OverrideAction(InterfaceOverrideAction value);
    [CompilerGeneratedAttribute]
public sealed virtual InterfaceOverrideAction get_AncestorOverrideAction();
    [CompilerGeneratedAttribute]
private void set_AncestorOverrideAction(InterfaceOverrideAction value);
    public virtual object get_MasterAspectMember();
}
[AttributeUsageAttribute("4")]
[RequiresDebuggerEnhancementAttribute("2")]
public class PostSharp.Aspects.Advices.IntroduceInterfaceAttribute : Advice {
    private Type interfaceType;
    [CompilerGeneratedAttribute]
private InterfaceOverrideAction <OverrideAction>k__BackingField;
    [CompilerGeneratedAttribute]
private InterfaceOverrideAction <AncestorOverrideAction>k__BackingField;
    public InterfaceOverrideAction OverrideAction { get; public set; }
    public InterfaceOverrideAction AncestorOverrideAction { get; public set; }
    private Type PostSharp.Aspects.Advices.IIntroduceInterfaceAdviceProperties.InterfaceType { get; }
    public IntroduceInterfaceAttribute(Type interfaceType);
    [CompilerGeneratedAttribute]
public sealed virtual InterfaceOverrideAction get_OverrideAction();
    [CompilerGeneratedAttribute]
public void set_OverrideAction(InterfaceOverrideAction value);
    [CompilerGeneratedAttribute]
public sealed virtual InterfaceOverrideAction get_AncestorOverrideAction();
    [CompilerGeneratedAttribute]
public void set_AncestorOverrideAction(InterfaceOverrideAction value);
    private sealed virtual override Type PostSharp.Aspects.Advices.IIntroduceInterfaceAdviceProperties.get_InterfaceType();
}
public abstract class PostSharp.Aspects.Advices.IntroduceMemberAdviceInstance : AdviceInstance {
    [CompilerGeneratedAttribute]
private Visibility <Visibility>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsVirtual>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberOverrideAction <OverrideAction>k__BackingField;
    public Visibility Visibility { get; private set; }
    public Nullable`1<bool> IsVirtual { get; private set; }
    public MemberOverrideAction OverrideAction { get; private set; }
    internal IntroduceMemberAdviceInstance(Visibility visibility, Nullable`1<bool> isVirtual, MemberOverrideAction overrideAction);
    [CompilerGeneratedAttribute]
public sealed virtual Visibility get_Visibility();
    [CompilerGeneratedAttribute]
private void set_Visibility(Visibility value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<bool> get_IsVirtual();
    [CompilerGeneratedAttribute]
private void set_IsVirtual(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual MemberOverrideAction get_OverrideAction();
    [CompilerGeneratedAttribute]
private void set_OverrideAction(MemberOverrideAction value);
}
[AttributeUsageAttribute("704")]
[RequiresDebuggerEnhancementAttribute("2")]
public class PostSharp.Aspects.Advices.IntroduceMemberAttribute : Advice {
    [CompilerGeneratedAttribute]
private Visibility <Visibility>k__BackingField;
    private Nullable`1<bool> isVirtual;
    [CompilerGeneratedAttribute]
private MemberOverrideAction <OverrideAction>k__BackingField;
    public Visibility Visibility { get; public set; }
    public bool IsVirtual { get; public set; }
    private Nullable`1<bool> PostSharp.Aspects.Advices.IIntroduceMemberAdviceProperties.IsVirtual { get; }
    public bool IsIsVirtualSpecified { get; }
    public MemberOverrideAction OverrideAction { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual Visibility get_Visibility();
    [CompilerGeneratedAttribute]
public void set_Visibility(Visibility value);
    public bool get_IsVirtual();
    public void set_IsVirtual(bool value);
    private sealed virtual override Nullable`1<bool> PostSharp.Aspects.Advices.IIntroduceMemberAdviceProperties.get_IsVirtual();
    public bool get_IsIsVirtualSpecified();
    [CompilerGeneratedAttribute]
public sealed virtual MemberOverrideAction get_OverrideAction();
    [CompilerGeneratedAttribute]
public void set_OverrideAction(MemberOverrideAction value);
}
public class PostSharp.Aspects.Advices.IntroduceMethodAdviceInstance : IntroduceMemberAdviceInstance {
    private MethodInfo method;
    public object MasterAspectMember { get; }
    public IntroduceMethodAdviceInstance(MethodInfo method, Visibility visibility, Nullable`1<bool> isVirtual, MemberOverrideAction overrideAction);
    public virtual object get_MasterAspectMember();
}
public interface PostSharp.Aspects.Advices.IProperty {
    public abstract virtual object GetValue();
    public abstract virtual void SetValue(object value);
}
[AttributeUsageAttribute("64")]
[RequiresMethodExecutionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("2")]
public class PostSharp.Aspects.Advices.LocationValidationAdvice : GroupingAdvice {
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    public int Priority { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(int value);
}
public class PostSharp.Aspects.Advices.LocationValueAttribute : AdviceParameterAttribute {
}
public class PostSharp.Aspects.Advices.MatchPointcut : Pointcut {
    [CompilerGeneratedAttribute]
private bool <MatchParameterCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    public bool MatchParameterCount { get; public set; }
    public string MethodName { get; private set; }
    public MatchPointcut(string methodName);
    [CompilerGeneratedAttribute]
public bool get_MatchParameterCount();
    [CompilerGeneratedAttribute]
public void set_MatchParameterCount(bool value);
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
private void set_MethodName(string value);
}
public enum PostSharp.Aspects.Advices.MemberOverrideAction : Enum {
    public int value__;
    public static MemberOverrideAction Default;
    public static MemberOverrideAction Fail;
    public static MemberOverrideAction Ignore;
    public static MemberOverrideAction OverrideOrFail;
    public static MemberOverrideAction OverrideOrIgnore;
}
public class PostSharp.Aspects.Advices.MethodPointcut : Pointcut {
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    public string MethodName { get; private set; }
    public MethodPointcut(string methodName);
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
private void set_MethodName(string value);
}
public class PostSharp.Aspects.Advices.MulticastPointcut : Pointcut {
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private MulticastTargets <Targets>k__BackingField;
    [CompilerGeneratedAttribute]
private MulticastAttributes <Attributes>k__BackingField;
    public string MemberName { get; public set; }
    public MulticastTargets Targets { get; public set; }
    public MulticastAttributes Attributes { get; public set; }
    [CompilerGeneratedAttribute]
public string get_MemberName();
    [CompilerGeneratedAttribute]
public void set_MemberName(string value);
    [CompilerGeneratedAttribute]
public MulticastTargets get_Targets();
    [CompilerGeneratedAttribute]
public void set_Targets(MulticastTargets value);
    [CompilerGeneratedAttribute]
public MulticastAttributes get_Attributes();
    [CompilerGeneratedAttribute]
public void set_Attributes(MulticastAttributes value);
}
[AttributeUsageAttribute("64")]
[RequiresDebuggerEnhancementAttribute("2")]
public class PostSharp.Aspects.Advices.OnAspectsInitializedAdvice : Advice {
}
[AttributeUsageAttribute("64")]
[RequiresEventInterceptionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("1")]
public class PostSharp.Aspects.Advices.OnEventAddHandlerAdvice : GroupingAdvice {
}
[AttributeUsageAttribute("64")]
[RequiresEventInterceptionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("1")]
public class PostSharp.Aspects.Advices.OnEventInvokeHandlerAdvice : GroupingAdvice {
}
[AttributeUsageAttribute("64")]
[RequiresEventInterceptionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("1")]
public class PostSharp.Aspects.Advices.OnEventRemoveHandlerAdvice : GroupingAdvice {
}
[AttributeUsageAttribute("64")]
[RequiresDebuggerEnhancementAttribute("2")]
public class PostSharp.Aspects.Advices.OnInstanceConstructedAdvice : Advice {
}
[AttributeUsageAttribute("64")]
[RequiresLocationInterceptionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("1")]
public class PostSharp.Aspects.Advices.OnInstanceLocationInitializedAdvice : GroupingAdvice {
}
[AttributeUsageAttribute("64")]
[RequiresLocationInterceptionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("1")]
public class PostSharp.Aspects.Advices.OnLocationGetValueAdvice : GroupingAdvice {
}
[AttributeUsageAttribute("64")]
[RequiresLocationInterceptionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("1")]
public class PostSharp.Aspects.Advices.OnLocationSetValueAdvice : GroupingAdvice {
}
public abstract class PostSharp.Aspects.Advices.OnMethodBoundaryAdvice : GroupingAdvice {
    private SemanticallyAdvisedMethodKinds semanticallyAdvisedMethods;
    private UnsupportedTargetAction unsupportedTargetAction;
    public SemanticallyAdvisedMethodKinds SemanticallyAdvisedMethodKinds { get; public set; }
    public UnsupportedTargetAction UnsupportedTargetAction { get; public set; }
    public SemanticallyAdvisedMethodKinds get_SemanticallyAdvisedMethodKinds();
    public void set_SemanticallyAdvisedMethodKinds(SemanticallyAdvisedMethodKinds value);
    public UnsupportedTargetAction get_UnsupportedTargetAction();
    public void set_UnsupportedTargetAction(UnsupportedTargetAction value);
}
[AttributeUsageAttribute("64")]
[RequiresMethodExecutionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("2")]
public class PostSharp.Aspects.Advices.OnMethodEntryAdvice : OnMethodBoundaryAdvice {
}
[AttributeUsageAttribute("64")]
[RequiresMethodExecutionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("2")]
public class PostSharp.Aspects.Advices.OnMethodExceptionAdvice : OnMethodBoundaryAdvice {
}
[AttributeUsageAttribute("64")]
[RequiresMethodExecutionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("2")]
public class PostSharp.Aspects.Advices.OnMethodExitAdvice : OnMethodBoundaryAdvice {
}
[AttributeUsageAttribute("64")]
[RequiresMethodInterceptionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("1")]
public class PostSharp.Aspects.Advices.OnMethodInvokeAdvice : OnMethodInvokeBaseAdvice {
}
public abstract class PostSharp.Aspects.Advices.OnMethodInvokeBaseAdvice : GroupingAdvice {
    private SemanticallyAdvisedMethodKinds semanticallyAdvisedMethodKinds;
    private UnsupportedTargetAction unsupportedTargetAction;
    public SemanticallyAdvisedMethodKinds SemanticallyAdvisedMethodKinds { get; public set; }
    public UnsupportedTargetAction UnsupportedTargetAction { get; public set; }
    public SemanticallyAdvisedMethodKinds get_SemanticallyAdvisedMethodKinds();
    public void set_SemanticallyAdvisedMethodKinds(SemanticallyAdvisedMethodKinds value);
    public UnsupportedTargetAction get_UnsupportedTargetAction();
    public void set_UnsupportedTargetAction(UnsupportedTargetAction value);
}
[AttributeUsageAttribute("64")]
[RequiresMethodExecutionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("2")]
public class PostSharp.Aspects.Advices.OnMethodResumeAdvice : OnMethodBoundaryAdvice {
}
[AttributeUsageAttribute("64")]
[RequiresMethodExecutionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("2")]
public class PostSharp.Aspects.Advices.OnMethodSuccessAdvice : OnMethodBoundaryAdvice {
}
[AttributeUsageAttribute("64")]
[RequiresMethodExecutionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("2")]
public class PostSharp.Aspects.Advices.OnMethodYieldAdvice : OnMethodBoundaryAdvice {
}
[AttributeUsageAttribute("64")]
public abstract class PostSharp.Aspects.Advices.Pointcut : Attribute {
}
public class PostSharp.Aspects.Advices.Property`1 : object {
    [CompilerGeneratedAttribute]
private PropertyGetter`1<TValue> <Get>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertySetter`1<TValue> <Set>k__BackingField;
    public PropertyGetter`1<TValue> Get { get; private set; }
    public PropertySetter`1<TValue> Set { get; private set; }
    public Property`1(PropertyGetter`1<TValue> getter, PropertySetter`1<TValue> setter);
    [CompilerGeneratedAttribute]
public PropertyGetter`1<TValue> get_Get();
    [CompilerGeneratedAttribute]
private void set_Get(PropertyGetter`1<TValue> value);
    [CompilerGeneratedAttribute]
public PropertySetter`1<TValue> get_Set();
    [CompilerGeneratedAttribute]
private void set_Set(PropertySetter`1<TValue> value);
    private sealed virtual override object PostSharp.Aspects.Advices.IProperty.GetValue();
    private sealed virtual override void PostSharp.Aspects.Advices.IProperty.SetValue(object value);
}
public class PostSharp.Aspects.Advices.Property`2 : object {
    [CompilerGeneratedAttribute]
private PropertyGetter`2<TValue, TIndex> <Get>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertySetter`2<TValue, TIndex> <Set>k__BackingField;
    public PropertyGetter`2<TValue, TIndex> Get { get; private set; }
    public PropertySetter`2<TValue, TIndex> Set { get; private set; }
    public Property`2(PropertyGetter`2<TValue, TIndex> getter, PropertySetter`2<TValue, TIndex> setter);
    [CompilerGeneratedAttribute]
public PropertyGetter`2<TValue, TIndex> get_Get();
    [CompilerGeneratedAttribute]
private void set_Get(PropertyGetter`2<TValue, TIndex> value);
    [CompilerGeneratedAttribute]
public PropertySetter`2<TValue, TIndex> get_Set();
    [CompilerGeneratedAttribute]
private void set_Set(PropertySetter`2<TValue, TIndex> value);
}
public class PostSharp.Aspects.Advices.PropertyGetter`1 : MulticastDelegate {
    public PropertyGetter`1(object object, IntPtr method);
    public virtual TValue Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual TValue EndInvoke(IAsyncResult result);
}
public class PostSharp.Aspects.Advices.PropertyGetter`2 : MulticastDelegate {
    public PropertyGetter`2(object object, IntPtr method);
    public virtual TValue Invoke(TIndex index);
    public virtual IAsyncResult BeginInvoke(TIndex index, AsyncCallback callback, object object);
    public virtual TValue EndInvoke(IAsyncResult result);
}
public class PostSharp.Aspects.Advices.PropertySetter`1 : MulticastDelegate {
    public PropertySetter`1(object object, IntPtr method);
    public virtual void Invoke(TValue value);
    public virtual IAsyncResult BeginInvoke(TValue value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class PostSharp.Aspects.Advices.PropertySetter`2 : MulticastDelegate {
    public PropertySetter`2(object object, IntPtr method);
    public virtual void Invoke(TIndex index, TValue value);
    public virtual IAsyncResult BeginInvoke(TIndex index, TValue value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class PostSharp.Aspects.Advices.ReturnValueAttribute : AdviceParameterAttribute {
}
public class PostSharp.Aspects.Advices.SelfPointcut : Pointcut {
}
public class PostSharp.Aspects.Advices.SignaturePointcut : Pointcut {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <ArgumentTypes>k__BackingField;
    public string Name { get; private set; }
    public Type[] ArgumentTypes { get; private set; }
    public SignaturePointcut(string name, Type[] parameterTypes);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public Type[] get_ArgumentTypes();
    [CompilerGeneratedAttribute]
private void set_ArgumentTypes(Type[] value);
}
public class PostSharp.Aspects.Advices.StateAttribute : AdviceParameterAttribute {
    [CompilerGeneratedAttribute]
private StateScope <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SlotName>k__BackingField;
    public StateScope Scope { get; private set; }
    public string SlotName { get; private set; }
    public StateAttribute(StateScope scope);
    public StateAttribute(StateScope scope, string slotName);
    [CompilerGeneratedAttribute]
public StateScope get_Scope();
    [CompilerGeneratedAttribute]
private void set_Scope(StateScope value);
    [CompilerGeneratedAttribute]
public string get_SlotName();
    [CompilerGeneratedAttribute]
private void set_SlotName(string value);
}
public enum PostSharp.Aspects.Advices.StateScope : Enum {
    public int value__;
    public static StateScope MethodInvocation;
}
public class PostSharp.Aspects.Advices.ThisAttribute : AdviceParameterAttribute {
}
[DefaultMemberAttribute("Item")]
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
public class PostSharp.Aspects.Arguments : object {
    private int count;
    public static Arguments Empty;
    public int Count { get; }
    public object Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Object>.IsReadOnly { get; }
    internal Arguments(int count);
    private static Arguments();
    public sealed virtual int get_Count();
    public virtual object GetArgument(int index);
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
    public virtual void SetArgument(int index, object value);
    public virtual void CopyFrom(Object[] array, int index);
    public virtual void CopyTo(Object[] array, int index);
    public Object[] ToArray();
    public Arguments Clone();
    private sealed virtual override object System.ICloneable.Clone();
    public static Arguments Create(T arg0);
    public static Arguments Create(T0 arg0, T1 arg1);
    public static Arguments Create(T0 arg0, T1 arg1, T2 arg2);
    public static Arguments Create(T0 arg0, T1 arg1, T2 arg2, T3 arg3);
    public static Arguments Create(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public static Arguments Create(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 args5);
    public static Arguments Create(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 args5, T6 args6);
    public static Arguments Create(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 args5, T6 args6, T7 args7);
    public static Arguments Create(Object[] array);
    public sealed virtual IEnumerator`1<object> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Object>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Object>.Remove(object item);
    private sealed virtual override int System.Collections.Generic.IList<System.Object>.IndexOf(object item);
    private sealed virtual override void System.Collections.Generic.IList<System.Object>.Insert(int index, object item);
    private sealed virtual override void System.Collections.Generic.IList<System.Object>.RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Object>.Add(object item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Object>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Object>.Contains(object item);
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[AspectConfigurationAttributeTypeAttribute("PostSharp.Aspects.Configuration.AspectConfigurationAttribute")]
[SerializerAttribute("")]
public abstract class PostSharp.Aspects.Aspect : MulticastAttribute {
    [PNonSerializedAttribute]
private Nullable`1<int> aspectPriority;
    [PNonSerializedAttribute]
private Type serializerType;
    [PNonSerializedAttribute]
private Nullable`1<UnsupportedTargetAction> unsupportedTargetAction;
    internal static string XmlNamespace;
    public int AspectPriority { get; public set; }
    protected Type SerializerType { get; protected set; }
    public UnsupportedTargetAction UnsupportedTargetAction { get; public set; }
    public int get_AspectPriority();
    public void set_AspectPriority(int value);
    protected Type get_SerializerType();
    protected void set_SerializerType(Type value);
    public UnsupportedTargetAction get_UnsupportedTargetAction();
    public void set_UnsupportedTargetAction(UnsupportedTargetAction value);
    private sealed virtual override bool PostSharp.Extensibility.IValidableAnnotation.CompileTimeValidate(object target);
    protected virtual AspectConfiguration CreateAspectConfiguration();
    protected virtual void SetAspectConfiguration(AspectConfiguration aspectConfiguration, object targetElement);
    public sealed virtual AspectConfiguration GetAspectConfiguration(object targetElement);
    public virtual bool CompileTimeValidate(object target);
}
[AttributeUsageAttribute("4")]
public class PostSharp.Aspects.AspectDescriptionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Description { get; private set; }
    public AspectDescriptionAttribute(string description);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(string value);
}
public class PostSharp.Aspects.AspectInfo : object {
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
public class PostSharp.Aspects.AspectInstance : AspectSpecification {
    [CompilerGeneratedAttribute]
private object <TargetElement>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RepresentAsStandalone>k__BackingField;
    public object TargetElement { get; private set; }
    public bool RepresentAsStandalone { get; public set; }
    public AspectInstance(object targetElement, IAspect aspect);
    public AspectInstance(object targetElement, IAspect aspect, AspectConfiguration aspectConfiguration);
    public AspectInstance(object targetElement, ObjectConstruction aspectConstruction);
    public AspectInstance(object targetElement, ObjectConstruction aspectConstruction, AspectConfiguration aspectConfiguration);
    [CompilerGeneratedAttribute]
public object get_TargetElement();
    [CompilerGeneratedAttribute]
private void set_TargetElement(object value);
    [CompilerGeneratedAttribute]
public bool get_RepresentAsStandalone();
    [CompilerGeneratedAttribute]
public void set_RepresentAsStandalone(bool value);
    private void CheckTargetElement();
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
public class PostSharp.Aspects.AspectSpecification : object {
    private IAspect aspect;
    private ObjectConstruction aspectConstruction;
    private AspectConfiguration aspectConfiguration;
    public AspectConfiguration AspectConfiguration { get; }
    public ObjectConstruction AspectConstruction { get; }
    public IAspect Aspect { get; }
    public string AspectAssemblyQualifiedTypeName { get; }
    public string AspectTypeName { get; }
    internal AspectSpecification(IAspect aspect, AspectConfiguration aspectConfiguration);
    internal AspectSpecification(IAspect aspect, ObjectConstruction aspectConstruction);
    protected internal AspectSpecification(ObjectConstruction aspectConstruction, AspectConfiguration aspectConfiguration);
    public AspectConfiguration get_AspectConfiguration();
    public ObjectConstruction get_AspectConstruction();
    public IAspect get_Aspect();
    public string get_AspectAssemblyQualifiedTypeName();
    public string get_AspectTypeName();
}
public class PostSharp.Aspects.AspectUtilities : object {
    public static void InitializeCurrentAspects();
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[MulticastAttributeUsageAttribute("2048")]
[AttributeUsageAttribute("1")]
[SerializerAttribute("")]
public abstract class PostSharp.Aspects.AssemblyLevelAspect : Aspect {
    public virtual bool CompileTimeValidate(Assembly assembly);
    public sealed virtual bool CompileTimeValidate(object target);
    public virtual void CompileTimeInitialize(Assembly assembly, AspectInfo aspectInfo);
    protected virtual void SetAspectConfiguration(AspectConfiguration aspectConfiguration, Assembly targetAssembly);
    protected sealed virtual void SetAspectConfiguration(AspectConfiguration aspectConfiguration, object targetElement);
}
public class PostSharp.Aspects.AsyncCallId : ValueType {
    private static long counter;
    private long id;
    public bool IsNull { get; }
    public static AsyncCallId Null { get; }
    private AsyncCallId(long id);
    public bool get_IsNull();
    public static AsyncCallId get_Null();
    [InternalAttribute]
public static AsyncCallId GetNext();
    public sealed virtual bool Equals(AsyncCallId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AsyncCallId left, AsyncCallId right);
    public static bool op_Inequality(AsyncCallId left, AsyncCallId right);
    public virtual string ToString();
}
[AttributeUsageAttribute("13")]
[MulticastAttributeUsageAttribute("3")]
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[AspectConfigurationAttributeTypeAttribute("PostSharp.Aspects.Configuration.CompositionAspectConfigurationAttribute")]
[SerializerAttribute("")]
public abstract class PostSharp.Aspects.CompositionAspect : TypeLevelAspect {
    [PNonSerializedAttribute]
private Nullable`1<InterfaceOverrideAction> overrideAction;
    [PNonSerializedAttribute]
private Nullable`1<InterfaceOverrideAction> ancestorOverrideAction;
    [PNonSerializedAttribute]
private Nullable`1<bool> nonSerializedImplementation;
    [PNonSerializedAttribute]
private Nullable`1<bool> generateImplementationAccessor;
    protected InterfaceOverrideAction OverrideAction { get; protected set; }
    protected InterfaceOverrideAction AncestorOverrideAction { get; protected set; }
    protected bool NonSerializedImplementation { get; protected set; }
    protected bool GenerateImplementationAccessor { get; protected set; }
    public abstract virtual object CreateImplementationObject(AdviceArgs args);
    protected virtual Type[] GetPublicInterfaces(Type targetType);
    protected InterfaceOverrideAction get_OverrideAction();
    protected void set_OverrideAction(InterfaceOverrideAction value);
    protected InterfaceOverrideAction get_AncestorOverrideAction();
    protected void set_AncestorOverrideAction(InterfaceOverrideAction value);
    protected bool get_NonSerializedImplementation();
    protected void set_NonSerializedImplementation(bool value);
    protected bool get_GenerateImplementationAccessor();
    protected void set_GenerateImplementationAccessor(bool value);
    protected sealed virtual AspectConfiguration CreateAspectConfiguration();
    protected virtual void SetAspectConfiguration(AspectConfiguration aspectConfiguration, Type targetType);
}
public class PostSharp.Aspects.Configuration.AspectConfiguration : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <AspectPriority>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeIdentity <SerializerType>k__BackingField;
    [CompilerGeneratedAttribute]
private AspectDependencyAttributeCollection <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UnsupportedTargetAction> <UnsupportedTargetAction>k__BackingField;
    public Nullable`1<int> AspectPriority { get; public set; }
    public TypeIdentity SerializerType { get; public set; }
    public AspectDependencyAttributeCollection Dependencies { get; public set; }
    public Nullable`1<UnsupportedTargetAction> UnsupportedTargetAction { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_AspectPriority();
    [CompilerGeneratedAttribute]
public void set_AspectPriority(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public TypeIdentity get_SerializerType();
    [CompilerGeneratedAttribute]
public void set_SerializerType(TypeIdentity value);
    [CompilerGeneratedAttribute]
public AspectDependencyAttributeCollection get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(AspectDependencyAttributeCollection value);
    [CompilerGeneratedAttribute]
public Nullable`1<UnsupportedTargetAction> get_UnsupportedTargetAction();
    [CompilerGeneratedAttribute]
public void set_UnsupportedTargetAction(Nullable`1<UnsupportedTargetAction> value);
}
[AttributeUsageAttribute("4")]
public class PostSharp.Aspects.Configuration.AspectConfigurationAttribute : Attribute {
    private Nullable`1<int> aspectPriority;
    [CompilerGeneratedAttribute]
private Type <SerializerType>k__BackingField;
    public int AspectPriority { get; public set; }
    public Type SerializerType { get; public set; }
    public int get_AspectPriority();
    public void set_AspectPriority(int value);
    [CompilerGeneratedAttribute]
public Type get_SerializerType();
    [CompilerGeneratedAttribute]
public void set_SerializerType(Type value);
    protected virtual AspectConfiguration CreateAspectConfiguration();
    public AspectConfiguration GetAspectConfiguration();
    protected virtual void SetAspectConfiguration(AspectConfiguration aspectConfiguration);
}
[AttributeUsageAttribute("4")]
public class PostSharp.Aspects.Configuration.AspectConfigurationAttributeTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <AttributeType>k__BackingField;
    public Type AttributeType { get; }
    public AspectConfigurationAttributeTypeAttribute(Type type);
    [CompilerGeneratedAttribute]
public Type get_AttributeType();
}
public class PostSharp.Aspects.Configuration.CompositionAspectConfiguration : AspectConfiguration {
    [CompilerGeneratedAttribute]
private TypeIdentity[] <PublicInterfaces>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<InterfaceOverrideAction> <OverrideAction>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<InterfaceOverrideAction> <AncestorOverrideAction>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <NonSerializedImplementation>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <GenerateImplementationAccessor>k__BackingField;
    public TypeIdentity[] PublicInterfaces { get; public set; }
    public Nullable`1<InterfaceOverrideAction> OverrideAction { get; public set; }
    public Nullable`1<InterfaceOverrideAction> AncestorOverrideAction { get; public set; }
    public Nullable`1<bool> NonSerializedImplementation { get; public set; }
    [ObsoleteAttribute("This property has no effect and will be removed in a future version.")]
public Nullable`1<bool> GenerateImplementationAccessor { get; public set; }
    [CompilerGeneratedAttribute]
public TypeIdentity[] get_PublicInterfaces();
    [CompilerGeneratedAttribute]
public void set_PublicInterfaces(TypeIdentity[] value);
    [CompilerGeneratedAttribute]
public Nullable`1<InterfaceOverrideAction> get_OverrideAction();
    [CompilerGeneratedAttribute]
public void set_OverrideAction(Nullable`1<InterfaceOverrideAction> value);
    [CompilerGeneratedAttribute]
public Nullable`1<InterfaceOverrideAction> get_AncestorOverrideAction();
    [CompilerGeneratedAttribute]
public void set_AncestorOverrideAction(Nullable`1<InterfaceOverrideAction> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_NonSerializedImplementation();
    [CompilerGeneratedAttribute]
public void set_NonSerializedImplementation(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_GenerateImplementationAccessor();
    [CompilerGeneratedAttribute]
public void set_GenerateImplementationAccessor(Nullable`1<bool> value);
}
public class PostSharp.Aspects.Configuration.CompositionAspectConfigurationAttribute : AspectConfigurationAttribute {
    private String[] publicInterfaces;
    private String[] protectedInterfaces;
    private Nullable`1<InterfaceOverrideAction> overrideAction;
    private Nullable`1<InterfaceOverrideAction> ancestorOverrideAction;
    private Nullable`1<bool> nonSerializedImplementation;
    private Nullable`1<bool> generateImplementationAccessor;
    public String[] PublicInterfaces { get; public set; }
    public String[] ProtectedInterfaces { get; public set; }
    public InterfaceOverrideAction OverrideAction { get; public set; }
    public InterfaceOverrideAction AncestorOverrideAction { get; public set; }
    public bool NonSerializedImplementation { get; public set; }
    [ObsoleteAttribute("This property has no effect and will be removed in a future version.")]
public bool GenerateImplementationAccessor { get; public set; }
    public String[] get_PublicInterfaces();
    public void set_PublicInterfaces(String[] value);
    public String[] get_ProtectedInterfaces();
    public void set_ProtectedInterfaces(String[] value);
    public InterfaceOverrideAction get_OverrideAction();
    public void set_OverrideAction(InterfaceOverrideAction value);
    public InterfaceOverrideAction get_AncestorOverrideAction();
    public void set_AncestorOverrideAction(InterfaceOverrideAction value);
    public bool get_NonSerializedImplementation();
    public void set_NonSerializedImplementation(bool value);
    public bool get_GenerateImplementationAccessor();
    public void set_GenerateImplementationAccessor(bool value);
    protected virtual AspectConfiguration CreateAspectConfiguration();
}
public class PostSharp.Aspects.Configuration.CustomAttributeIntroductionAspectConfiguration : AspectConfiguration {
    [CompilerGeneratedAttribute]
private ObjectConstruction <ObjectConstruction>k__BackingField;
    public ObjectConstruction ObjectConstruction { get; public set; }
    [CompilerGeneratedAttribute]
public ObjectConstruction get_ObjectConstruction();
    [CompilerGeneratedAttribute]
public void set_ObjectConstruction(ObjectConstruction value);
}
public class PostSharp.Aspects.Configuration.EventInterceptionAspectConfiguration : AspectConfiguration {
}
public class PostSharp.Aspects.Configuration.EventInterceptionAspectConfigurationAttribute : AspectConfigurationAttribute {
    protected virtual AspectConfiguration CreateAspectConfiguration();
}
public class PostSharp.Aspects.Configuration.LocationInterceptionAspectConfiguration : AspectConfiguration {
}
public class PostSharp.Aspects.Configuration.LocationInterceptionAspectConfigurationAttribute : AspectConfigurationAttribute {
    protected virtual AspectConfiguration CreateAspectConfiguration();
}
public class PostSharp.Aspects.Configuration.ManagedResourceIntroductionAspectConfiguration : AspectConfiguration {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<Byte[]> <DataProvider>k__BackingField;
    public string Name { get; }
    [ObsoleteAttribute("Use DataProvider.")]
public Byte[] Data { get; }
    public Func`1<Byte[]> DataProvider { get; }
    public ManagedResourceIntroductionAspectConfiguration(string name, Byte[] data);
    public ManagedResourceIntroductionAspectConfiguration(string name, Func`1<Byte[]> dataProvider);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Byte[] get_Data();
    [CompilerGeneratedAttribute]
public Func`1<Byte[]> get_DataProvider();
}
public class PostSharp.Aspects.Configuration.MethodInterceptionAspectConfiguration : AspectConfiguration {
    [CompilerGeneratedAttribute]
private Nullable`1<SemanticallyAdvisedMethodKinds> <SemanticallyAdvisedMethodKinds>k__BackingField;
    public Nullable`1<SemanticallyAdvisedMethodKinds> SemanticallyAdvisedMethodKinds { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<SemanticallyAdvisedMethodKinds> get_SemanticallyAdvisedMethodKinds();
    [CompilerGeneratedAttribute]
public void set_SemanticallyAdvisedMethodKinds(Nullable`1<SemanticallyAdvisedMethodKinds> value);
}
public class PostSharp.Aspects.Configuration.MethodInterceptionAspectConfigurationAttribute : AspectConfigurationAttribute {
    protected virtual AspectConfiguration CreateAspectConfiguration();
}
public class PostSharp.Aspects.Configuration.OnExceptionAspectConfiguration : AspectConfiguration {
    [CompilerGeneratedAttribute]
private TypeIdentity <ExceptionType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SemanticallyAdvisedMethodKinds> <SemanticallyAdvisedMethodKinds>k__BackingField;
    public TypeIdentity ExceptionType { get; public set; }
    public Nullable`1<SemanticallyAdvisedMethodKinds> SemanticallyAdvisedMethodKinds { get; public set; }
    [CompilerGeneratedAttribute]
public TypeIdentity get_ExceptionType();
    [CompilerGeneratedAttribute]
public void set_ExceptionType(TypeIdentity value);
    [CompilerGeneratedAttribute]
public Nullable`1<SemanticallyAdvisedMethodKinds> get_SemanticallyAdvisedMethodKinds();
    [CompilerGeneratedAttribute]
public void set_SemanticallyAdvisedMethodKinds(Nullable`1<SemanticallyAdvisedMethodKinds> value);
}
public class PostSharp.Aspects.Configuration.OnExceptionAspectConfigurationAttribute : AspectConfigurationAttribute {
    [CompilerGeneratedAttribute]
private Type <ExceptionType>k__BackingField;
    public Type ExceptionType { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_ExceptionType();
    [CompilerGeneratedAttribute]
public void set_ExceptionType(Type value);
    protected virtual AspectConfiguration CreateAspectConfiguration();
    protected virtual void SetAspectConfiguration(AspectConfiguration aspectConfiguration);
}
public class PostSharp.Aspects.Configuration.OnMethodBoundaryAspectConfiguration : AspectConfiguration {
    [CompilerGeneratedAttribute]
private Nullable`1<SemanticallyAdvisedMethodKinds> <SemanticallyAdvisedMethodKinds>k__BackingField;
    public Nullable`1<SemanticallyAdvisedMethodKinds> SemanticallyAdvisedMethodKinds { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<SemanticallyAdvisedMethodKinds> get_SemanticallyAdvisedMethodKinds();
    [CompilerGeneratedAttribute]
public void set_SemanticallyAdvisedMethodKinds(Nullable`1<SemanticallyAdvisedMethodKinds> value);
}
public class PostSharp.Aspects.Configuration.OnMethodBoundaryAspectConfigurationAttribute : AspectConfigurationAttribute {
    protected virtual AspectConfiguration CreateAspectConfiguration();
}
[InternalAttribute]
[DebuggerStepThroughAttribute]
public class PostSharp.Aspects.ConstructorDepth : ValueType {
    private short level;
    public bool IsZero { get; }
    public static ConstructorDepth Zero { get; }
    private ConstructorDepth(short level);
    public ConstructorDepth Increment();
    public bool get_IsZero();
    public static ConstructorDepth get_Zero();
    public virtual string ToString();
}
[LinesOfCodeAvoidedAttribute("1")]
public class PostSharp.Aspects.CustomAttributeIntroductionAspect : object {
    private ObjectConstruction customAttribute;
    public ObjectConstruction CustomAttribute { get; }
    public CustomAttributeIntroductionAspect(ObjectConstruction attribute);
    public CustomAttributeIntroductionAspect(CustomAttributeData customAttributeData);
    public ObjectConstruction get_CustomAttribute();
    private sealed virtual override bool PostSharp.Extensibility.IValidableAnnotation.CompileTimeValidate(object target);
    private sealed virtual override AspectConfiguration PostSharp.Aspects.IAspectBuildSemantics.GetAspectConfiguration(object targetElement);
}
public class PostSharp.Aspects.Dependencies.AdviceDependencyAttribute : AspectDependencyAttribute {
    [CompilerGeneratedAttribute]
private string <AdviceMethodName>k__BackingField;
    public string AdviceMethodName { get; private set; }
    public AdviceDependencyAttribute(AspectDependencyAction action, AspectDependencyPosition position, string adviceMethodName);
    public AdviceDependencyAttribute(AspectDependencyAction action, string adviceMethodName);
    [CompilerGeneratedAttribute]
public string get_AdviceMethodName();
    [CompilerGeneratedAttribute]
private void set_AdviceMethodName(string value);
}
public enum PostSharp.Aspects.Dependencies.AspectDependencyAction : Enum {
    public int value__;
    public static AspectDependencyAction None;
    public static AspectDependencyAction Order;
    public static AspectDependencyAction Require;
    public static AspectDependencyAction Conflict;
    public static AspectDependencyAction Commute;
}
[AttributeUsageAttribute("69")]
public abstract class PostSharp.Aspects.Dependencies.AspectDependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private AspectDependencyAction <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private AspectDependencyPosition <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private AspectDependencyTarget <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWarning>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <TargetType>k__BackingField;
    public AspectDependencyAction Action { get; private set; }
    public AspectDependencyPosition Position { get; private set; }
    public AspectDependencyTarget Target { get; public set; }
    public bool IsWarning { get; public set; }
    public Type TargetType { get; public set; }
    protected AspectDependencyAttribute(AspectDependencyAction action);
    protected AspectDependencyAttribute(AspectDependencyAction action, AspectDependencyPosition position);
    [CompilerGeneratedAttribute]
public AspectDependencyAction get_Action();
    [CompilerGeneratedAttribute]
private void set_Action(AspectDependencyAction value);
    [CompilerGeneratedAttribute]
public AspectDependencyPosition get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(AspectDependencyPosition value);
    [CompilerGeneratedAttribute]
public AspectDependencyTarget get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(AspectDependencyTarget value);
    [CompilerGeneratedAttribute]
public bool get_IsWarning();
    [CompilerGeneratedAttribute]
public void set_IsWarning(bool value);
    [CompilerGeneratedAttribute]
public Type get_TargetType();
    [CompilerGeneratedAttribute]
public void set_TargetType(Type value);
}
public class PostSharp.Aspects.Dependencies.AspectDependencyAttributeCollection : Collection`1<AspectDependencyAttribute> {
}
public enum PostSharp.Aspects.Dependencies.AspectDependencyPosition : Enum {
    public int value__;
    public static AspectDependencyPosition Any;
    public static AspectDependencyPosition Before;
    public static AspectDependencyPosition After;
}
public enum PostSharp.Aspects.Dependencies.AspectDependencyTarget : Enum {
    public int value__;
    public static AspectDependencyTarget Default;
    public static AspectDependencyTarget Type;
}
public class PostSharp.Aspects.Dependencies.AspectEffectDependencyAttribute : AspectDependencyAttribute {
    [CompilerGeneratedAttribute]
private string <Effect>k__BackingField;
    public string Effect { get; private set; }
    public AspectEffectDependencyAttribute(AspectDependencyAction action, AspectDependencyPosition position, string effect);
    public AspectEffectDependencyAttribute(AspectDependencyAction action, string effect);
    [CompilerGeneratedAttribute]
public string get_Effect();
    [CompilerGeneratedAttribute]
private void set_Effect(string value);
}
public class PostSharp.Aspects.Dependencies.AspectRoleDependencyAttribute : AspectDependencyAttribute {
    [CompilerGeneratedAttribute]
private string <Role>k__BackingField;
    public string Role { get; private set; }
    public AspectRoleDependencyAttribute(AspectDependencyAction action, AspectDependencyPosition position, string role);
    public AspectRoleDependencyAttribute(AspectDependencyAction action, string role);
    [CompilerGeneratedAttribute]
public string get_Role();
    [CompilerGeneratedAttribute]
private void set_Role(string value);
}
public class PostSharp.Aspects.Dependencies.AspectTypeDependencyAttribute : AspectDependencyAttribute {
    [CompilerGeneratedAttribute]
private Type <AspectType>k__BackingField;
    public Type AspectType { get; private set; }
    public AspectTypeDependencyAttribute(AspectDependencyAction action, AspectDependencyPosition position, Type aspectType);
    public AspectTypeDependencyAttribute(AspectDependencyAction action, Type aspectType);
    [CompilerGeneratedAttribute]
public Type get_AspectType();
    [CompilerGeneratedAttribute]
private void set_AspectType(Type value);
}
[AttributeUsageAttribute("68")]
public class PostSharp.Aspects.Dependencies.ProvideAspectRoleAttribute : AspectDependencyAttribute {
    [CompilerGeneratedAttribute]
private string <Role>k__BackingField;
    public string Role { get; private set; }
    public ProvideAspectRoleAttribute(string role);
    [CompilerGeneratedAttribute]
public string get_Role();
    [CompilerGeneratedAttribute]
private void set_Role(string value);
}
public static class PostSharp.Aspects.Dependencies.StandardEffects : object {
    public static string MemberImport;
    public static string CustomAttributeIntroduction;
    public static string InterfaceIntroduction;
    public static string MemberIntroduction;
    public static string Custom;
    public static string ChangeControlFlow;
    public static string GetMemberIntroductionEffect(string memberName);
    public static string GetMemberImportEffect(string memberName);
    public static string GetInterfaceIntroductionEffect(string typeName);
}
public static class PostSharp.Aspects.Dependencies.StandardRoles : object {
    public static string Validation;
    public static string Tracing;
    public static string PerformanceInstrumentation;
    public static string Security;
    public static string Caching;
    public static string TransactionHandling;
    public static string ExceptionHandling;
    public static string DataBinding;
    public static string Persistence;
    public static string EventBroker;
    public static string Threading;
}
[AttributeUsageAttribute("68")]
public class PostSharp.Aspects.Dependencies.WaiveAspectEffectAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Effects>k__BackingField;
    public String[] Effects { get; }
    public WaiveAspectEffectAttribute(String[] effects);
    [CompilerGeneratedAttribute]
public String[] get_Effects();
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
public abstract class PostSharp.Aspects.EventInterceptionArgs : AdviceArgs {
    [CompilerGeneratedAttribute]
private Delegate <Handler>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private EventInfo <Event>k__BackingField;
    [CompilerGeneratedAttribute]
private Arguments <Arguments>k__BackingField;
    public IEventBinding Binding { get; }
    public Delegate Handler { get; private set; }
    public object ReturnValue { get; public set; }
    public EventInfo Event { get; public set; }
    public Arguments Arguments { get; private set; }
    internal EventInterceptionArgs(object instance, Arguments arguments, Delegate handler);
    [DebuggerHiddenAttribute]
public abstract virtual IEventBinding get_Binding();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public Delegate get_Handler();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void set_Handler(Delegate value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public object get_ReturnValue();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public void set_ReturnValue(object value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public EventInfo get_Event();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public void set_Event(EventInfo value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public Arguments get_Arguments();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void set_Arguments(Arguments value);
    public abstract virtual void ProceedAddHandler();
    public abstract virtual void AddHandler(Delegate handler);
    public abstract virtual void ProceedRemoveHandler();
    public abstract virtual void RemoveHandler(Delegate handler);
    public abstract virtual void ProceedInvokeHandler();
    public abstract virtual object InvokeHandler(Delegate handler, Arguments arguments);
}
[HasInheritedAttributeAttribute]
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[MulticastAttributeUsageAttribute("1024")]
[AttributeUsageAttribute("1549")]
[AspectConfigurationAttributeTypeAttribute("PostSharp.Aspects.Configuration.EventInterceptionAspectConfigurationAttribute")]
[SerializerAttribute("")]
public abstract class PostSharp.Aspects.EventInterceptionAspect : EventLevelAspect {
    [RequiresEventInterceptionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("1")]
[HasInheritedAttributeAttribute]
[EventInterceptionAdviceOptimizationAttribute("2048")]
public virtual void OnAddHandler(EventInterceptionArgs args);
    [RequiresEventInterceptionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("1")]
[HasInheritedAttributeAttribute]
[EventInterceptionAdviceOptimizationAttribute("2048")]
public virtual void OnRemoveHandler(EventInterceptionArgs args);
    [RequiresEventInterceptionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("1")]
[HasInheritedAttributeAttribute]
[EventInterceptionAdviceOptimizationAttribute("2048")]
public virtual void OnInvokeHandler(EventInterceptionArgs args);
    protected virtual AspectConfiguration CreateAspectConfiguration();
}
[MulticastAttributeUsageAttribute("1024")]
[AttributeUsageAttribute("517")]
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[SerializerAttribute("")]
public abstract class PostSharp.Aspects.EventLevelAspect : Aspect {
    [RuntimeInitializeOptimizationAttribute("1")]
public virtual void RuntimeInitialize(EventInfo eventInfo);
    public virtual void CompileTimeInitialize(EventInfo targetEvent, AspectInfo aspectInfo);
    public virtual bool CompileTimeValidate(EventInfo targetEvent);
    protected virtual void SetAspectConfiguration(AspectConfiguration aspectConfiguration, EventInfo targetEvent);
    protected sealed virtual void SetAspectConfiguration(AspectConfiguration aspectConfiguration, object targetElement);
    public sealed virtual bool CompileTimeValidate(object target);
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[SerializerAttribute("")]
public abstract class PostSharp.Aspects.FieldLevelAspect : Aspect {
    public virtual bool CompileTimeValidate(FieldInfo field);
    public sealed virtual bool CompileTimeValidate(object target);
    public virtual void CompileTimeInitialize(FieldInfo field, AspectInfo aspectInfo);
    protected virtual void SetAspectConfiguration(AspectConfiguration aspectConfiguration, FieldInfo targetField);
    protected sealed virtual void SetAspectConfiguration(AspectConfiguration aspectConfiguration, object targetElement);
    [RuntimeInitializeOptimizationAttribute("1")]
public virtual void RuntimeInitialize(FieldInfo field);
}
public enum PostSharp.Aspects.FlowBehavior : Enum {
    public int value__;
    public static FlowBehavior Default;
    public static FlowBehavior Continue;
    public static FlowBehavior RethrowException;
    public static FlowBehavior Return;
    public static FlowBehavior ThrowException;
    public static FlowBehavior Yield;
}
[RequirePostSharpAttribute("", "AspectWeaver")]
public interface PostSharp.Aspects.IAspect {
}
[SuppressAnnotationValidationAttribute]
public interface PostSharp.Aspects.IAspectBuildSemantics {
    public abstract virtual AspectConfiguration GetAspectConfiguration(object targetElement);
}
[InternalImplementAttribute]
public interface PostSharp.Aspects.IAspectInstance {
    public AspectConfiguration AspectConfiguration { get; }
    public ObjectConstruction AspectConstruction { get; }
    public IAspect Aspect { get; }
    public Type AspectType { get; }
    public abstract virtual AspectConfiguration get_AspectConfiguration();
    public abstract virtual ObjectConstruction get_AspectConstruction();
    public abstract virtual IAspect get_Aspect();
    public abstract virtual Type get_AspectType();
}
public interface PostSharp.Aspects.IAspectProvider {
    public abstract virtual IEnumerable`1<AspectInstance> ProvideAspects(object targetElement);
}
public interface PostSharp.Aspects.IAspectRepositoryService {
    public abstract virtual IAspectInstance[] GetAspectInstances(object declaration);
    public abstract virtual bool HasAspect(object declaration, Type aspectType);
    [CompilerGeneratedAttribute]
public abstract virtual void add_AspectDiscoveryCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_AspectDiscoveryCompleted(EventHandler value);
}
public interface PostSharp.Aspects.IAssemblyLevelAspect {
}
public interface PostSharp.Aspects.IAssemblyLevelAspectBuildSemantics {
    public abstract virtual void CompileTimeInitialize(Assembly assembly, AspectInfo aspectInfo);
}
public interface PostSharp.Aspects.ICloneAwareAspect {
    [HasInheritedAttributeAttribute]
[RequiresDebuggerEnhancementAttribute("2")]
public abstract virtual void OnCloned(ICloneAwareAspect source);
}
public interface PostSharp.Aspects.ICompositionAspect {
    public abstract virtual object CreateImplementationObject(AdviceArgs args);
}
public interface PostSharp.Aspects.ICustomAttributeIntroductionAspect {
}
[InternalImplementAttribute]
public interface PostSharp.Aspects.IEventBinding {
    public abstract virtual void AddHandler(Object& instance, Delegate handler);
    public abstract virtual void RemoveHandler(Object& instance, Delegate handler);
    public abstract virtual object InvokeHandler(Object& instance, Delegate handler, Arguments arguments);
}
[HasInheritedAttributeAttribute]
public interface PostSharp.Aspects.IEventInterceptionAspect {
    [RequiresEventInterceptionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("1")]
[HasInheritedAttributeAttribute]
public abstract virtual void OnAddHandler(EventInterceptionArgs args);
    [RequiresEventInterceptionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("1")]
[HasInheritedAttributeAttribute]
public abstract virtual void OnRemoveHandler(EventInterceptionArgs args);
    [RequiresEventInterceptionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("1")]
[HasInheritedAttributeAttribute]
public abstract virtual void OnInvokeHandler(EventInterceptionArgs args);
}
public interface PostSharp.Aspects.IEventLevelAspect {
    public abstract virtual void RuntimeInitialize(EventInfo eventInfo);
}
public interface PostSharp.Aspects.IEventLevelAspectBuildSemantics {
    public abstract virtual void CompileTimeInitialize(EventInfo targetEvent, AspectInfo aspectInfo);
}
public interface PostSharp.Aspects.IFieldLevelAspect {
    public abstract virtual void RuntimeInitialize(FieldInfo field);
}
public interface PostSharp.Aspects.IFieldLevelAspectBuildSemantics {
    public abstract virtual void CompileTimeInitialize(FieldInfo field, AspectInfo aspectInfo);
}
[HasInheritedAttributeAttribute]
public interface PostSharp.Aspects.IInstanceScopedAspect {
    [RequiresDebuggerEnhancementAttribute("2")]
[HasInheritedAttributeAttribute]
[RequiresCreateInstanceAnalysisAttribute]
public abstract virtual object CreateInstance(AdviceArgs adviceArgs);
    [RequiresDebuggerEnhancementAttribute("2")]
[HasInheritedAttributeAttribute]
public abstract virtual void RuntimeInitializeInstance();
}
public interface PostSharp.Aspects.ILicensedAspect {
    public abstract virtual string GetLicenseRequirements();
}
[InternalImplementAttribute]
public interface PostSharp.Aspects.ILocationBinding {
    public LocationInfo LocationInfo { get; }
    public Type LocationType { get; }
    public DeclarationIdentifier DeclarationIdentifier { get; }
    public abstract virtual object GetValue(Object& instance, Arguments index);
    public abstract virtual void SetValue(Object& instance, Arguments index, object value);
    public abstract virtual LocationInfo get_LocationInfo();
    public abstract virtual Type get_LocationType();
    public abstract virtual DeclarationIdentifier get_DeclarationIdentifier();
    public abstract virtual void Execute(ILocationBindingAction`1<TPayload> action, TPayload& payload);
}
public interface PostSharp.Aspects.ILocationBinding`1 {
    public abstract virtual T GetValue(Object& instance, Arguments index);
    public abstract virtual void SetValue(Object& instance, Arguments index, T value);
}
public interface PostSharp.Aspects.ILocationBindingAction`1 {
    public abstract virtual void Execute(ILocationBinding`1<TValue> binding, TPayload& payload);
}
public interface PostSharp.Aspects.ILocationInterceptionArgs {
    public ILocationBinding Binding { get; }
    public Arguments Index { get; }
    public object Value { get; public set; }
    public LocationInfo Location { get; public set; }
    public string LocationName { get; public set; }
    public string LocationFullName { get; public set; }
    [DebuggerNonUserCodeAttribute]
public object Instance { get; public set; }
    public abstract virtual ILocationBinding get_Binding();
    public abstract virtual Arguments get_Index();
    public abstract virtual void ProceedGetValue();
    public abstract virtual void ProceedSetValue();
    public abstract virtual object GetCurrentValue();
    public abstract virtual void SetNewValue(object value);
    public abstract virtual void Execute(ILocationInterceptionArgsAction`1<TPayload> action, TPayload& payload);
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
    public abstract virtual LocationInfo get_Location();
    public abstract virtual void set_Location(LocationInfo value);
    public abstract virtual string get_LocationName();
    public abstract virtual void set_LocationName(string value);
    public abstract virtual string get_LocationFullName();
    public abstract virtual void set_LocationFullName(string value);
    public abstract virtual object get_Instance();
    [InternalAttribute]
public abstract virtual void set_Instance(object value);
}
public interface PostSharp.Aspects.ILocationInterceptionArgs`1 {
    public ILocationBinding`1<T> Binding { get; }
    public T Value { get; public set; }
    public abstract virtual ILocationBinding`1<T> get_Binding();
    public abstract virtual T get_Value();
    public abstract virtual void set_Value(T value);
    public abstract virtual T GetCurrentValue();
    public abstract virtual void SetNewValue(T value);
}
public interface PostSharp.Aspects.ILocationInterceptionArgsAction`1 {
    public abstract virtual void Execute(ILocationInterceptionArgs`1<TValue> args, TPayload& payload);
}
[HasInheritedAttributeAttribute]
public interface PostSharp.Aspects.ILocationInterceptionAspect {
    [RequiresLocationInterceptionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("1")]
[HasInheritedAttributeAttribute]
public abstract virtual void OnGetValue(LocationInterceptionArgs args);
    [RequiresLocationInterceptionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("1")]
[HasInheritedAttributeAttribute]
public abstract virtual void OnSetValue(LocationInterceptionArgs args);
}
public interface PostSharp.Aspects.ILocationLevelAspect {
    public abstract virtual void RuntimeInitialize(LocationInfo locationInfo);
}
public interface PostSharp.Aspects.ILocationLevelAspectBuildSemantics {
    public abstract virtual void CompileTimeInitialize(LocationInfo targetLocation, AspectInfo aspectInfo);
}
public interface PostSharp.Aspects.ILocationValidationAspect {
}
[HasInheritedAttributeAttribute]
public interface PostSharp.Aspects.ILocationValidationAspect`1 {
    [RequiresDebuggerEnhancementAttribute("2")]
[HasInheritedAttributeAttribute]
public abstract virtual Exception ValidateValue(T value, string locationName, LocationKind locationKind, LocationValidationContext context);
}
public interface PostSharp.Aspects.IManagedResourceIntroductionAspect {
}
[InternalAttribute]
public interface PostSharp.Aspects.IMethodBinding {
    public abstract virtual object Invoke(Object& instance, Arguments arguments);
}
[HasInheritedAttributeAttribute]
public interface PostSharp.Aspects.IMethodInterceptionAspect {
    [RequiresMethodInterceptionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("1")]
[HasInheritedAttributeAttribute]
public abstract virtual void OnInvoke(MethodInterceptionArgs args);
}
public interface PostSharp.Aspects.IMethodLevelAspect {
    public abstract virtual void RuntimeInitialize(MethodBase method);
}
public interface PostSharp.Aspects.IMethodLevelAspectBuildSemantics {
    public abstract virtual void CompileTimeInitialize(MethodBase method, AspectInfo aspectInfo);
}
[HasInheritedAttributeAttribute]
[MulticastAttributeUsageAttribute("1")]
[AttributeUsageAttribute("1029")]
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[SerializerAttribute("")]
public abstract class PostSharp.Aspects.InstanceLevelAspect : TypeLevelAspect {
    [PNonSerializedAttribute]
private object instance;
    public object Instance { get; }
    [HasInheritedAttributeAttribute]
[RequiresDebuggerEnhancementAttribute("2")]
[RequiresCreateInstanceAnalysisAttribute]
[CreateInstanceOptimizationAttribute("0")]
public virtual object CreateInstance(AdviceArgs adviceArgs);
    [HasInheritedAttributeAttribute]
[RequiresDebuggerEnhancementAttribute("2")]
public virtual void RuntimeInitializeInstance();
    public virtual void OnCloned(ICloneAwareAspect source);
    protected virtual AspectConfiguration CreateAspectConfiguration();
    public object get_Instance();
}
[AttributeUsageAttribute("64")]
[InternalAttribute]
public abstract class PostSharp.Aspects.Internals.AdviceOptimizationAttribute : Attribute {
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[InternalAttribute]
public class PostSharp.Aspects.Internals.Arguments`1 : Arguments {
    private static int count;
    public TArg0 Arg0;
    public virtual object GetArgument(int index);
    public virtual void SetArgument(int index, object value);
    public virtual void CopyTo(Object[] array, int index);
    public virtual void CopyFrom(Object[] array, int index);
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[InternalAttribute]
public class PostSharp.Aspects.Internals.Arguments`2 : Arguments {
    private static int count;
    public TArg0 Arg0;
    public TArg1 Arg1;
    public virtual object GetArgument(int index);
    public virtual void SetArgument(int index, object value);
    public virtual void CopyTo(Object[] array, int index);
    public virtual void CopyFrom(Object[] array, int index);
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[InternalAttribute]
public class PostSharp.Aspects.Internals.Arguments`3 : Arguments {
    private static int count;
    public TArg0 Arg0;
    public TArg1 Arg1;
    public TArg2 Arg2;
    public virtual object GetArgument(int index);
    public virtual void SetArgument(int index, object value);
    public virtual void CopyTo(Object[] array, int index);
    public virtual void CopyFrom(Object[] array, int index);
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[InternalAttribute]
public class PostSharp.Aspects.Internals.Arguments`4 : Arguments {
    private static int count;
    public TArg0 Arg0;
    public TArg1 Arg1;
    public TArg2 Arg2;
    public TArg3 Arg3;
    public virtual object GetArgument(int index);
    public virtual void SetArgument(int index, object value);
    public virtual void CopyTo(Object[] array, int index);
    public virtual void CopyFrom(Object[] array, int index);
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[InternalAttribute]
public class PostSharp.Aspects.Internals.Arguments`5 : Arguments {
    private static int count;
    public TArg0 Arg0;
    public TArg1 Arg1;
    public TArg2 Arg2;
    public TArg3 Arg3;
    public TArg4 Arg4;
    public virtual object GetArgument(int index);
    public virtual void SetArgument(int index, object value);
    public virtual void CopyTo(Object[] array, int index);
    public virtual void CopyFrom(Object[] array, int index);
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[InternalAttribute]
public class PostSharp.Aspects.Internals.Arguments`6 : Arguments {
    private static int count;
    public TArg0 Arg0;
    public TArg1 Arg1;
    public TArg2 Arg2;
    public TArg3 Arg3;
    public TArg4 Arg4;
    public TArg5 Arg5;
    public virtual object GetArgument(int index);
    public virtual void SetArgument(int index, object value);
    public virtual void CopyTo(Object[] array, int index);
    public virtual void CopyFrom(Object[] array, int index);
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[InternalAttribute]
public class PostSharp.Aspects.Internals.Arguments`7 : Arguments {
    private static int count;
    public TArg0 Arg0;
    public TArg1 Arg1;
    public TArg2 Arg2;
    public TArg3 Arg3;
    public TArg4 Arg4;
    public TArg5 Arg5;
    public TArg6 Arg6;
    public virtual object GetArgument(int index);
    public virtual void SetArgument(int index, object value);
    public virtual void CopyTo(Object[] array, int index);
    public virtual void CopyFrom(Object[] array, int index);
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[InternalAttribute]
public class PostSharp.Aspects.Internals.Arguments`8 : Arguments {
    private static int count;
    public TArg0 Arg0;
    public TArg1 Arg1;
    public TArg2 Arg2;
    public TArg3 Arg3;
    public TArg4 Arg4;
    public TArg5 Arg5;
    public TArg6 Arg6;
    public TArg7 Arg7;
    public virtual object GetArgument(int index);
    public virtual void SetArgument(int index, object value);
    public virtual void CopyTo(Object[] array, int index);
    public virtual void CopyFrom(Object[] array, int index);
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[InternalAttribute]
public class PostSharp.Aspects.Internals.ArgumentsArray : Arguments {
    private Object[] arguments;
    public Object[] Arguments { get; public set; }
    public ArgumentsArray(Object[] arguments);
    public Object[] get_Arguments();
    public void set_Arguments(Object[] value);
    public virtual object GetArgument(int index);
    public virtual void SetArgument(int index, object value);
    public virtual void CopyFrom(Object[] array, int index);
    public virtual void CopyTo(Object[] array, int index);
}
[InternalAttribute]
public class PostSharp.Aspects.Internals.CreateInstanceOptimizationAttribute : AdviceOptimizationAttribute {
    [CompilerGeneratedAttribute]
private CreateInstanceOptimizations <Optimizations>k__BackingField;
    public CreateInstanceOptimizations Optimizations { get; private set; }
    public CreateInstanceOptimizationAttribute(CreateInstanceOptimizations optimizations);
    [CompilerGeneratedAttribute]
public CreateInstanceOptimizations get_Optimizations();
    [CompilerGeneratedAttribute]
private void set_Optimizations(CreateInstanceOptimizations value);
}
[FlagsAttribute]
[InternalAttribute]
public enum PostSharp.Aspects.Internals.CreateInstanceOptimizations : Enum {
    public int value__;
    public static CreateInstanceOptimizations None;
    public static CreateInstanceOptimizations IgnoreGetInstance;
    public static CreateInstanceOptimizations IgnoreAllEventArgsMembers;
    public static CreateInstanceOptimizations IgnoreEventArgs;
    public static CreateInstanceOptimizations IgnoreAdvice;
    public static CreateInstanceOptimizations IgnoreAll;
}
[AttributeUsageAttribute("32767")]
public class PostSharp.Aspects.Internals.DebuggerAspectGeneratedCodeAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class PostSharp.Aspects.Internals.DebuggerAspectMethodAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DebuggerStepOverAspectBehavior <StepOverAspectBehavior>k__BackingField;
    private DebuggerStepOverAspectBehavior StepOverAspectBehavior { get; }
    public DebuggerAspectMethodAttribute(DebuggerStepOverAspectBehavior stepOverAspectBehavior);
    [CompilerGeneratedAttribute]
private DebuggerStepOverAspectBehavior get_StepOverAspectBehavior();
}
[AttributeUsageAttribute("64")]
public class PostSharp.Aspects.Internals.DebuggerBindingMethodAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <BindingInvokeMethodToken>k__BackingField;
    public int BindingInvokeMethodToken { get; }
    public DebuggerBindingMethodAttribute(int bindingInvokeMethodToken);
    [CompilerGeneratedAttribute]
public int get_BindingInvokeMethodToken();
}
[AttributeUsageAttribute("64")]
public class PostSharp.Aspects.Internals.DebuggerSourceMethodAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <SourceMethodToken>k__BackingField;
    public int SourceMethodToken { get; }
    public DebuggerSourceMethodAttribute(int sourceMethodToken);
    [CompilerGeneratedAttribute]
public int get_SourceMethodToken();
}
public enum PostSharp.Aspects.Internals.DebuggerStepOverAspectBehavior : Enum {
    public int value__;
    public static DebuggerStepOverAspectBehavior None;
    public static DebuggerStepOverAspectBehavior RunToTarget;
    public static DebuggerStepOverAspectBehavior StepOut;
}
[AttributeUsageAttribute("64")]
public class PostSharp.Aspects.Internals.DebuggerTargetMethodAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <TargetMethodToken>k__BackingField;
    public int TargetMethodToken { get; }
    public DebuggerTargetMethodAttribute(int targetMethodToken);
    [CompilerGeneratedAttribute]
public int get_TargetMethodToken();
}
internal class PostSharp.Aspects.Internals.EmptyNonThrowingEnumerator`1 : object {
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[InternalAttribute]
public abstract class PostSharp.Aspects.Internals.EventBinding : object {
    public virtual void AddHandler(Object& instance, Delegate handler, object reserved);
    public virtual void RemoveHandler(Object& instance, Delegate handler, object reserved);
    public virtual object InvokeHandler(Object& instance, Delegate handler, Arguments arguments, object reserved);
    private sealed virtual override void PostSharp.Aspects.IEventBinding.AddHandler(Object& instance, Delegate handler);
    private sealed virtual override void PostSharp.Aspects.IEventBinding.RemoveHandler(Object& instance, Delegate handler);
    private sealed virtual override object PostSharp.Aspects.IEventBinding.InvokeHandler(Object& instance, Delegate handler, Arguments arguments);
}
[DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
[InternalAttribute]
[ObsoleteAttribute("The SafeEventBroker class is now used by the compiler.")]
public abstract class PostSharp.Aspects.Internals.EventBroker : object {
    private Delegate modreq(System.Runtime.CompilerServices.IsVolatile) handlers;
    [CompilerGeneratedAttribute]
private object <Instance>k__BackingField;
    protected object Instance { get; private set; }
    [DebuggerHiddenAttribute]
protected EventBroker(object instance);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
protected object get_Instance();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void set_Instance(object value);
    protected abstract virtual void SubscribeImpl();
    protected abstract virtual void UnsubscribeImpl();
    protected abstract virtual object OnHandlerInvoked(Delegate handler, Arguments arguments);
    public void AddHandler(Delegate handler);
    public void RemoveHandler(Delegate handler);
    protected object OnEventFired(Arguments arguments);
}
[InternalAttribute]
public class PostSharp.Aspects.Internals.EventInterceptionAdviceOptimizationAttribute : AdviceOptimizationAttribute {
    [CompilerGeneratedAttribute]
private EventInterceptionAdviceOptimizations <Optimizations>k__BackingField;
    public EventInterceptionAdviceOptimizations Optimizations { get; private set; }
    public EventInterceptionAdviceOptimizationAttribute(EventInterceptionAdviceOptimizations optimizations);
    [CompilerGeneratedAttribute]
public EventInterceptionAdviceOptimizations get_Optimizations();
    [CompilerGeneratedAttribute]
private void set_Optimizations(EventInterceptionAdviceOptimizations value);
}
[FlagsAttribute]
[InternalAttribute]
public enum PostSharp.Aspects.Internals.EventInterceptionAdviceOptimizations : Enum {
    public int value__;
    public static EventInterceptionAdviceOptimizations None;
    public static EventInterceptionAdviceOptimizations IgnoreGetEvent;
    public static EventInterceptionAdviceOptimizations IgnoreGetDeclarationIdentifier;
    public static EventInterceptionAdviceOptimizations IgnoreAllEventArgsMembers;
    public static EventInterceptionAdviceOptimizations IgnoreEventArgs;
    public static EventInterceptionAdviceOptimizations IgnoreAdvice;
    public static EventInterceptionAdviceOptimizations IgnoreAll;
}
[InternalAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
public class PostSharp.Aspects.Internals.EventInterceptionArgsImpl : EventInterceptionArgs {
    public EventBinding TypedBinding;
    public IEventBinding Binding { get; }
    public EventInterceptionArgsImpl(object instance, Arguments arguments, Delegate handler);
    public virtual IEventBinding get_Binding();
    public virtual void ProceedAddHandler();
    public virtual void ProceedRemoveHandler();
    public virtual void ProceedInvokeHandler();
    public virtual void AddHandler(Delegate handler);
    public virtual void RemoveHandler(Delegate handler);
    public virtual object InvokeHandler(Delegate handler, Arguments arguments);
}
public abstract class PostSharp.Aspects.Internals.EventInterceptor : object {
    [CompilerGeneratedAttribute]
private Delegate <Handler>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Instance>k__BackingField;
    public Delegate Handler { get; private set; }
    protected object Instance { get; private set; }
    protected EventInterceptor(object instance, Delegate handler);
    [CompilerGeneratedAttribute]
public Delegate get_Handler();
    [CompilerGeneratedAttribute]
private void set_Handler(Delegate value);
    [CompilerGeneratedAttribute]
protected object get_Instance();
    [CompilerGeneratedAttribute]
private void set_Instance(object value);
    public abstract virtual void Subscribe();
    public abstract virtual void Unsubscribe();
}
[InternalAttribute]
[AttributeUsageAttribute("4")]
[MulticastAttributeUsageAttribute("1")]
[RequirePostSharpAttribute("", "AspectInfrastructure.TypeInitialization")]
public class PostSharp.Aspects.Internals.HasOnInstanceConstructedAttribute : MulticastAttribute {
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[InternalAttribute]
public abstract class PostSharp.Aspects.Internals.LocationBinding`1 : object {
    public LocationInfo LocationInfo { get; }
    public Type LocationType { get; }
    public DeclarationIdentifier DeclarationIdentifier { get; }
    public virtual T GetValue(Object& instance, Arguments index, object reserved);
    public virtual void SetValue(Object& instance, Arguments index, T value, object reserved);
    private sealed virtual override object PostSharp.Aspects.ILocationBinding.GetValue(Object& instance, Arguments index);
    private sealed virtual override void PostSharp.Aspects.ILocationBinding<T>.SetValue(Object& instance, Arguments index, T value);
    private sealed virtual override T PostSharp.Aspects.ILocationBinding<T>.GetValue(Object& instance, Arguments index);
    private sealed virtual override void PostSharp.Aspects.ILocationBinding.SetValue(Object& instance, Arguments index, object value);
    public virtual LocationInfo get_LocationInfo();
    public sealed virtual Type get_LocationType();
    public abstract virtual DeclarationIdentifier get_DeclarationIdentifier();
    public sealed virtual void Execute(ILocationBindingAction`1<TPayload> action, TPayload& payload);
}
[InternalAttribute]
public class PostSharp.Aspects.Internals.LocationInterceptionAdviceOptimizationAttribute : AdviceOptimizationAttribute {
    [CompilerGeneratedAttribute]
private LocationInterceptionAdviceOptimizations <Optimizations>k__BackingField;
    public LocationInterceptionAdviceOptimizations Optimizations { get; private set; }
    public LocationInterceptionAdviceOptimizationAttribute(LocationInterceptionAdviceOptimizations optimizations);
    [CompilerGeneratedAttribute]
public LocationInterceptionAdviceOptimizations get_Optimizations();
    [CompilerGeneratedAttribute]
private void set_Optimizations(LocationInterceptionAdviceOptimizations value);
}
[InternalAttribute]
[FlagsAttribute]
public enum PostSharp.Aspects.Internals.LocationInterceptionAdviceOptimizations : Enum {
    public int value__;
    public static LocationInterceptionAdviceOptimizations None;
    public static LocationInterceptionAdviceOptimizations IgnoreGetLocation;
    public static LocationInterceptionAdviceOptimizations IgnoreGetLocationName;
    public static LocationInterceptionAdviceOptimizations IgnoreGetLocationFullName;
    public static LocationInterceptionAdviceOptimizations IgnoreGetDeclarationIdentifier;
    public static LocationInterceptionAdviceOptimizations IgnoreAllEventArgsMembers;
    public static LocationInterceptionAdviceOptimizations IgnoreEventArgs;
    public static LocationInterceptionAdviceOptimizations IgnoreAdvice;
    public static LocationInterceptionAdviceOptimizations IgnoreAll;
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[InternalAttribute]
public class PostSharp.Aspects.Internals.LocationInterceptionArgsImpl`1 : LocationInterceptionArgs {
    public LocationBinding`1<T> TypedBinding;
    public T TypedValue;
    public ILocationBinding Binding { get; }
    private T PostSharp.Aspects.ILocationInterceptionArgs<T>.Value { get; private set; }
    private ILocationBinding`1<T> PostSharp.Aspects.ILocationInterceptionArgs<T>.Binding { get; }
    public object Value { get; public set; }
    public LocationInterceptionArgsImpl`1(object instance, Arguments index);
    public virtual ILocationBinding get_Binding();
    [DebuggerHiddenAttribute]
private sealed virtual override T PostSharp.Aspects.ILocationInterceptionArgs<T>.get_Value();
    [DebuggerHiddenAttribute]
private sealed virtual override void PostSharp.Aspects.ILocationInterceptionArgs<T>.set_Value(T value);
    [DebuggerHiddenAttribute]
private sealed virtual override ILocationBinding`1<T> PostSharp.Aspects.ILocationInterceptionArgs<T>.get_Binding();
    public virtual object get_Value();
    public virtual void set_Value(object value);
    public virtual void ProceedGetValue();
    public virtual void ProceedSetValue();
    private sealed virtual override T PostSharp.Aspects.ILocationInterceptionArgs<T>.GetCurrentValue();
    private T GetCurrentValueCore();
    private sealed virtual override void PostSharp.Aspects.ILocationInterceptionArgs<T>.SetNewValue(T value);
    private void SetNewValueCore(T value);
    public virtual object GetCurrentValue();
    public virtual void SetNewValue(object value);
    public virtual void Execute(ILocationInterceptionArgsAction`1<TPayload> action, TPayload& payload);
}
[InternalAttribute]
public abstract class PostSharp.Aspects.Internals.LocationLevelAdviceArgs : AdviceArgs {
    [CompilerGeneratedAttribute]
private LocationInfo <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationFullName>k__BackingField;
    public object Value { get; public set; }
    public LocationInfo Location { get; public set; }
    public string LocationName { get; public set; }
    public string LocationFullName { get; public set; }
    protected LocationLevelAdviceArgs(object instance);
    [DebuggerHiddenAttribute]
public abstract virtual object get_Value();
    [DebuggerHiddenAttribute]
public abstract virtual void set_Value(object value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public sealed virtual LocationInfo get_Location();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public sealed virtual void set_Location(LocationInfo value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public sealed virtual string get_LocationName();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public sealed virtual void set_LocationName(string value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public sealed virtual string get_LocationFullName();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public sealed virtual void set_LocationFullName(string value);
}
[InternalAttribute]
public abstract class PostSharp.Aspects.Internals.MethodBinding : object {
    private sealed virtual override object PostSharp.Aspects.IMethodBinding.Invoke(Object& instance, Arguments arguments);
    public abstract virtual void Invoke(Object& instance, Arguments arguments, object reserved);
}
[InternalAttribute]
public abstract class PostSharp.Aspects.Internals.MethodBinding`1 : object {
    private sealed virtual override object PostSharp.Aspects.IMethodBinding.Invoke(Object& instance, Arguments arguments);
    public abstract virtual TReturnValue Invoke(Object& instance, Arguments arguments, object reserved);
}
[InternalAttribute]
public class PostSharp.Aspects.Internals.MethodExecutionAdviceOptimizationAttribute : AdviceOptimizationAttribute {
    [CompilerGeneratedAttribute]
private MethodExecutionAdviceOptimizations <Optimizations>k__BackingField;
    public MethodExecutionAdviceOptimizations Optimizations { get; private set; }
    public MethodExecutionAdviceOptimizationAttribute(MethodExecutionAdviceOptimizations optimizations);
    [CompilerGeneratedAttribute]
public MethodExecutionAdviceOptimizations get_Optimizations();
    [CompilerGeneratedAttribute]
private void set_Optimizations(MethodExecutionAdviceOptimizations value);
}
[InternalAttribute]
[FlagsAttribute]
public enum PostSharp.Aspects.Internals.MethodExecutionAdviceOptimizations : Enum {
    public int value__;
    public static MethodExecutionAdviceOptimizations None;
    public static MethodExecutionAdviceOptimizations IgnoreGetMethod;
    public static MethodExecutionAdviceOptimizations IgnoreSetFlowBehavior;
    public static MethodExecutionAdviceOptimizations IgnoreGetArguments;
    public static MethodExecutionAdviceOptimizations IgnoreSetArguments;
    public static MethodExecutionAdviceOptimizations IgnoreGetInstance;
    public static MethodExecutionAdviceOptimizations IgnoreSetInstance;
    public static MethodExecutionAdviceOptimizations IgnoreGetException;
    public static MethodExecutionAdviceOptimizations IgnoreGetReturnValue;
    public static MethodExecutionAdviceOptimizations IgnoreSetReturnValue;
    public static MethodExecutionAdviceOptimizations IgnoreGetMethodExecutionTag;
    public static MethodExecutionAdviceOptimizations IgnoreSetMethodExecutionTag;
    public static MethodExecutionAdviceOptimizations IgnoreGetYieldValue;
    public static MethodExecutionAdviceOptimizations IgnoreSetYieldValue;
    public static MethodExecutionAdviceOptimizations IgnoreGetDeclarationIdentifier;
    public static MethodExecutionAdviceOptimizations IgnoreMethodExecutionTag;
    public static MethodExecutionAdviceOptimizations IgnoreAllEventArgsMembers;
    public static MethodExecutionAdviceOptimizations IgnoreEventArgs;
    public static MethodExecutionAdviceOptimizations IgnoreAdvice;
    public static MethodExecutionAdviceOptimizations IgnoreAll;
}
[InternalAttribute]
public class PostSharp.Aspects.Internals.MethodInterceptionAdviceOptimizationAttribute : AdviceOptimizationAttribute {
    [CompilerGeneratedAttribute]
private MethodInterceptionAdviceOptimizations <Optimizations>k__BackingField;
    public MethodInterceptionAdviceOptimizations Optimizations { get; private set; }
    public MethodInterceptionAdviceOptimizationAttribute(MethodInterceptionAdviceOptimizations optimizations);
    [CompilerGeneratedAttribute]
public MethodInterceptionAdviceOptimizations get_Optimizations();
    [CompilerGeneratedAttribute]
private void set_Optimizations(MethodInterceptionAdviceOptimizations value);
}
[FlagsAttribute]
[InternalAttribute]
public enum PostSharp.Aspects.Internals.MethodInterceptionAdviceOptimizations : Enum {
    public int value__;
    public static MethodInterceptionAdviceOptimizations None;
    public static MethodInterceptionAdviceOptimizations IgnoreGetMethod;
    public static MethodInterceptionAdviceOptimizations IgnoreGetDeclarationIdentifier;
    public static MethodInterceptionAdviceOptimizations IgnoreAllEventArgsMembers;
    public static MethodInterceptionAdviceOptimizations IgnoreEventArgs;
    public static MethodInterceptionAdviceOptimizations IgnoreAdvice;
    public static MethodInterceptionAdviceOptimizations IgnoreAll;
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[InternalAttribute]
public class PostSharp.Aspects.Internals.MethodInterceptionArgsImpl : MethodInterceptionArgs {
    public MethodBinding TypedBinding;
    public IMethodBinding Binding { get; }
    public object ReturnValue { get; public set; }
    public MethodInterceptionArgsImpl(object instance, Arguments arguments);
    public virtual IMethodBinding get_Binding();
    public virtual object get_ReturnValue();
    public virtual void set_ReturnValue(object value);
    [DebuggerAspectGeneratedCodeAttribute]
public virtual void Proceed();
    [DebuggerAspectGeneratedCodeAttribute]
public virtual object Invoke(Arguments arguments);
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[InternalAttribute]
public class PostSharp.Aspects.Internals.MethodInterceptionArgsImpl`1 : MethodInterceptionArgs {
    public MethodBinding`1<TReturnValue> TypedBinding;
    public TReturnValue TypedReturnValue;
    public IMethodBinding Binding { get; }
    public object ReturnValue { get; public set; }
    public MethodInterceptionArgsImpl`1(object instance, Arguments arguments);
    public virtual IMethodBinding get_Binding();
    public virtual object get_ReturnValue();
    public virtual void set_ReturnValue(object value);
    [DebuggerAspectGeneratedCodeAttribute]
public virtual void Proceed();
    [DebuggerAspectGeneratedCodeAttribute]
public virtual object Invoke(Arguments arguments);
}
[AttributeUsageAttribute("68")]
[MulticastAttributeUsageAttribute("65")]
[RequirePostSharpAttribute("", "AdviceAnalyzer")]
[InternalAttribute]
public abstract class PostSharp.Aspects.Internals.RequiresAdviceAnalysisAttribute : MulticastAttribute {
}
[InternalAttribute]
public class PostSharp.Aspects.Internals.RequiresCreateInstanceAnalysisAttribute : RequiresAdviceAnalysisAttribute {
}
[AttributeUsageAttribute("68")]
[MulticastAttributeUsageAttribute("65")]
[InternalAttribute]
public class PostSharp.Aspects.Internals.RequiresDebuggerEnhancementAttribute : MulticastAttribute {
    [CompilerGeneratedAttribute]
private DebuggerStepOverAspectBehavior <Kind>k__BackingField;
    public DebuggerStepOverAspectBehavior Kind { get; private set; }
    public RequiresDebuggerEnhancementAttribute(DebuggerStepOverAspectBehavior kind);
    [CompilerGeneratedAttribute]
public DebuggerStepOverAspectBehavior get_Kind();
    [CompilerGeneratedAttribute]
private void set_Kind(DebuggerStepOverAspectBehavior value);
}
[InternalAttribute]
public class PostSharp.Aspects.Internals.RequiresEventInterceptionAdviceAnalysisAttribute : RequiresAdviceAnalysisAttribute {
}
[InternalAttribute]
public class PostSharp.Aspects.Internals.RequiresLocationInterceptionAdviceAnalysisAttribute : RequiresAdviceAnalysisAttribute {
}
[InternalAttribute]
public class PostSharp.Aspects.Internals.RequiresMethodExecutionAdviceAnalysisAttribute : RequiresAdviceAnalysisAttribute {
}
[InternalAttribute]
public class PostSharp.Aspects.Internals.RequiresMethodInterceptionAdviceAnalysisAttribute : RequiresAdviceAnalysisAttribute {
}
[InternalAttribute]
public class PostSharp.Aspects.Internals.RuntimeInitializeOptimizationAttribute : AdviceOptimizationAttribute {
    [CompilerGeneratedAttribute]
private RuntimeInitializeOptimizations <Optimizations>k__BackingField;
    public RuntimeInitializeOptimizations Optimizations { get; private set; }
    public RuntimeInitializeOptimizationAttribute(RuntimeInitializeOptimizations optimizations);
    [CompilerGeneratedAttribute]
public RuntimeInitializeOptimizations get_Optimizations();
    [CompilerGeneratedAttribute]
private void set_Optimizations(RuntimeInitializeOptimizations value);
}
[FlagsAttribute]
[InternalAttribute]
public enum PostSharp.Aspects.Internals.RuntimeInitializeOptimizations : Enum {
    public int value__;
    public static RuntimeInitializeOptimizations None;
    public static RuntimeInitializeOptimizations Ignore;
}
public abstract class PostSharp.Aspects.Internals.SafeEventBroker : object {
    private EventInterceptor[] modreq(System.Runtime.CompilerServices.IsVolatile) interceptors;
    [CompilerGeneratedAttribute]
private object <Instance>k__BackingField;
    protected object Instance { get; private set; }
    protected SafeEventBroker(object instance);
    [CompilerGeneratedAttribute]
protected object get_Instance();
    [CompilerGeneratedAttribute]
private void set_Instance(object value);
    protected abstract virtual EventInterceptor CreateInterceptor(Delegate handler);
    public void AddHandler(Delegate handler);
    public void RemoveHandler(Delegate handler);
}
[InternalAttribute]
public abstract class PostSharp.Aspects.Internals.StateMachine.BaseGeneratedIteratorStateMachine`1 : object {
    internal static string YieldValueFieldName;
    internal static string IsDisposingFieldName;
    internal static string StateFieldName;
    private IEnumerator originalEnumerator;
    protected TElement yieldValue;
    protected int isDisposing;
    protected int state;
    private bool permanentlyDisposed;
    public TElement Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public sealed virtual void Dispose();
    public virtual IEnumerable CallTargetEnumerableMethod();
    public virtual IEnumerator CallTargetEnumeratorMethod();
    public virtual bool MoveNext();
    public abstract virtual BaseGeneratedIteratorStateMachine`1<TElement> CreateCopy();
    private void ConnectToDecoratedEnumerator();
    public sealed virtual void Reset();
    public sealed virtual TElement get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override IEnumerator`1<TElement> System.Collections.Generic.IEnumerable<TElement>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal static class PostSharp.Aspects.Internals.StateMachine.IteratorStateMachineIsDisposingStatus : object {
    public static int NotDisposing;
    public static int DisposeInProgress;
    public static int AfterDisposeMoveNextInProgress;
}
internal static class PostSharp.Aspects.Internals.StateMachine.IteratorStateMachineState : object {
    public static int EnumeratorNotYetCreated;
    public static int EnumerationEnded;
    public static int BeforeUserCode;
}
[HasInheritedAttributeAttribute]
public interface PostSharp.Aspects.IOnExceptionAspect {
    [RequiresMethodExecutionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("2")]
[HasInheritedAttributeAttribute]
public abstract virtual void OnException(MethodExecutionArgs args);
}
[HasInheritedAttributeAttribute]
public interface PostSharp.Aspects.IOnInstanceLocationInitializedAspect {
    [RequiresLocationInterceptionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("1")]
[HasInheritedAttributeAttribute]
public abstract virtual void OnInstanceLocationInitialized(LocationInitializationArgs args);
}
[HasInheritedAttributeAttribute]
public interface PostSharp.Aspects.IOnMethodBoundaryAspect {
    [RequiresMethodExecutionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("2")]
[HasInheritedAttributeAttribute]
public abstract virtual void OnEntry(MethodExecutionArgs args);
    [RequiresMethodExecutionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("2")]
[HasInheritedAttributeAttribute]
public abstract virtual void OnExit(MethodExecutionArgs args);
    [RequiresMethodExecutionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("2")]
[HasInheritedAttributeAttribute]
public abstract virtual void OnSuccess(MethodExecutionArgs args);
    [RequiresMethodExecutionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("2")]
[HasInheritedAttributeAttribute]
public abstract virtual void OnException(MethodExecutionArgs args);
}
[HasInheritedAttributeAttribute]
public interface PostSharp.Aspects.IOnStateMachineBoundaryAspect {
    [RequiresMethodExecutionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("2")]
[HasInheritedAttributeAttribute]
public abstract virtual void OnResume(MethodExecutionArgs args);
    [RequiresMethodExecutionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("2")]
[HasInheritedAttributeAttribute]
public abstract virtual void OnYield(MethodExecutionArgs args);
}
public interface PostSharp.Aspects.ITypeLevelAspect {
    public abstract virtual void RuntimeInitialize(Type type);
}
public interface PostSharp.Aspects.ITypeLevelAspectBuildSemantics {
    public abstract virtual void CompileTimeInitialize(Type type, AspectInfo aspectInfo);
}
[AttributeUsageAttribute("4")]
public class PostSharp.Aspects.LinesOfCodeAvoidedAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; private set; }
    public LinesOfCodeAvoidedAttribute(int lines);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
}
[ExtensionAttribute]
public static class PostSharp.Aspects.LocationBindingExtensions : object {
    [ExtensionAttribute]
public static object GetValue(ILocationBinding locationBinding, object instance, Arguments index);
    [ExtensionAttribute]
public static T GetValue(ILocationBinding`1<T> locationBinding, object instance, Arguments index);
    [ExtensionAttribute]
public static object GetValue(ILocationBinding locationBinding, object instance);
    [ExtensionAttribute]
public static T GetValue(ILocationBinding`1<T> locationBinding, object instance);
    [ExtensionAttribute]
public static void SetValue(ILocationBinding locationBinding, object instance, Arguments index, object value);
    [ExtensionAttribute]
public static void SetValue(ILocationBinding`1<T> locationBinding, object instance, Arguments index, T value);
    [ExtensionAttribute]
public static void SetValue(ILocationBinding`1<T> locationBinding, object instance, T value);
    [ExtensionAttribute]
public static void SetValue(ILocationBinding locationBinding, object instance, object value);
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[InternalAttribute]
public class PostSharp.Aspects.LocationInitializationArgs : LocationLevelAdviceArgs {
    private object backingFieldValue;
    public object Value { get; public set; }
    [DebuggerHiddenAttribute]
public LocationInitializationArgs(object instance, object backingFieldValue);
    public virtual object get_Value();
    public virtual void set_Value(object value);
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
public abstract class PostSharp.Aspects.LocationInterceptionArgs : LocationLevelAdviceArgs {
    [CompilerGeneratedAttribute]
private Arguments <Index>k__BackingField;
    public ILocationBinding Binding { get; }
    public Arguments Index { get; private set; }
    [DebuggerHiddenAttribute]
internal LocationInterceptionArgs(object instance, Arguments index);
    [DebuggerHiddenAttribute]
public abstract virtual ILocationBinding get_Binding();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public sealed virtual Arguments get_Index();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void set_Index(Arguments value);
    public abstract virtual void ProceedGetValue();
    public abstract virtual void ProceedSetValue();
    public abstract virtual object GetCurrentValue();
    public abstract virtual void SetNewValue(object value);
    public abstract virtual void Execute(ILocationInterceptionArgsAction`1<TPayload> action, TPayload& payload);
}
[MulticastAttributeUsageAttribute("544")]
[HasInheritedAttributeAttribute]
[AttributeUsageAttribute("1421")]
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[AspectConfigurationAttributeTypeAttribute("PostSharp.Aspects.Configuration.LocationInterceptionAspectConfigurationAttribute")]
[SerializerAttribute("")]
public abstract class PostSharp.Aspects.LocationInterceptionAspect : LocationLevelAspect {
    [RequiresLocationInterceptionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("1")]
[HasInheritedAttributeAttribute]
[LocationInterceptionAdviceOptimizationAttribute("2048")]
public virtual void OnGetValue(LocationInterceptionArgs args);
    [RequiresLocationInterceptionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("1")]
[HasInheritedAttributeAttribute]
[LocationInterceptionAdviceOptimizationAttribute("2048")]
public virtual void OnSetValue(LocationInterceptionArgs args);
    [RequiresLocationInterceptionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("1")]
[HasInheritedAttributeAttribute]
[LocationInterceptionAdviceOptimizationAttribute("2048")]
public virtual void OnInstanceLocationInitialized(LocationInitializationArgs args);
    protected sealed virtual AspectConfiguration CreateAspectConfiguration();
}
[MulticastAttributeUsageAttribute("12832")]
[AttributeUsageAttribute("11661")]
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[SerializerAttribute("")]
public abstract class PostSharp.Aspects.LocationLevelAspect : Aspect {
    [RuntimeInitializeOptimizationAttribute("1")]
public virtual void RuntimeInitialize(LocationInfo locationInfo);
    public virtual void CompileTimeInitialize(LocationInfo targetLocation, AspectInfo aspectInfo);
    public virtual bool CompileTimeValidate(LocationInfo locationInfo);
    protected virtual void SetAspectConfiguration(AspectConfiguration aspectConfiguration, LocationInfo targetLocation);
    protected sealed virtual void SetAspectConfiguration(AspectConfiguration aspectConfiguration, object targetElement);
    public sealed virtual bool CompileTimeValidate(object target);
}
public enum PostSharp.Aspects.LocationValidationContext : Enum {
    public int value__;
    public static LocationValidationContext None;
    public static LocationValidationContext Precondition;
    public static LocationValidationContext SuccessPostcondition;
}
public class PostSharp.Aspects.ManagedResourceIntroductionAspect : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<Byte[]> <DataProvider>k__BackingField;
    public string Name { get; }
    public Byte[] Data { get; }
    public Func`1<Byte[]> DataProvider { get; }
    public ManagedResourceIntroductionAspect(string name, Byte[] data);
    public ManagedResourceIntroductionAspect(string name, Func`1<Byte[]> dataProvider);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Byte[] get_Data();
    [CompilerGeneratedAttribute]
public Func`1<Byte[]> get_DataProvider();
    private sealed virtual override bool PostSharp.Extensibility.IValidableAnnotation.CompileTimeValidate(object target);
    private sealed virtual override AspectConfiguration PostSharp.Aspects.IAspectBuildSemantics.GetAspectConfiguration(object targetElement);
}
[DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
public class PostSharp.Aspects.MethodExecutionArgs : AdviceArgs {
    [CompilerGeneratedAttribute]
private MethodBase <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private Arguments <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private object <YieldValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private FlowBehavior <FlowBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private object <MethodExecutionTag>k__BackingField;
    public MethodBase Method { get; public set; }
    public Arguments Arguments { get; public set; }
    public object ReturnValue { get; public set; }
    public object YieldValue { get; public set; }
    public Exception Exception { get; public set; }
    public FlowBehavior FlowBehavior { get; public set; }
    public object MethodExecutionTag { get; public set; }
    [DebuggerHiddenAttribute]
public MethodExecutionArgs(object instance, Arguments arguments);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public MethodBase get_Method();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
[InternalAttribute]
public void set_Method(MethodBase value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public Arguments get_Arguments();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
[InternalAttribute]
public void set_Arguments(Arguments value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public object get_ReturnValue();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public void set_ReturnValue(object value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public object get_YieldValue();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public void set_YieldValue(object value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public void set_Exception(Exception value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public FlowBehavior get_FlowBehavior();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public void set_FlowBehavior(FlowBehavior value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public object get_MethodExecutionTag();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public void set_MethodExecutionTag(object value);
}
[MulticastAttributeUsageAttribute("64")]
[HasInheritedAttributeAttribute]
[AttributeUsageAttribute("1741")]
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[SerializerAttribute("")]
public abstract class PostSharp.Aspects.MethodImplementationAspect : MethodLevelAspect {
    public abstract virtual void OnInvoke(MethodInterceptionArgs args);
    protected virtual AspectConfiguration CreateAspectConfiguration();
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
public abstract class PostSharp.Aspects.MethodInterceptionArgs : AdviceArgs {
    [CompilerGeneratedAttribute]
private MethodBase <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private Arguments <Arguments>k__BackingField;
    public IMethodBinding Binding { get; }
    public object ReturnValue { get; public set; }
    public MethodBase Method { get; public set; }
    public Arguments Arguments { get; protected set; }
    internal MethodInterceptionArgs(object instance, Arguments arguments);
    [DebuggerHiddenAttribute]
public abstract virtual IMethodBinding get_Binding();
    [DebuggerHiddenAttribute]
public abstract virtual object get_ReturnValue();
    [DebuggerHiddenAttribute]
public abstract virtual void set_ReturnValue(object value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public MethodBase get_Method();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public void set_Method(MethodBase value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
public Arguments get_Arguments();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
protected void set_Arguments(Arguments value);
    public abstract virtual void Proceed();
    public abstract virtual object Invoke(Arguments arguments);
}
[MulticastAttributeUsageAttribute("192")]
[HasInheritedAttributeAttribute]
[AttributeUsageAttribute("1741")]
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[AspectConfigurationAttributeTypeAttribute("PostSharp.Aspects.Configuration.MethodInterceptionAspectConfigurationAttribute")]
[SerializerAttribute("")]
public abstract class PostSharp.Aspects.MethodInterceptionAspect : MethodLevelAspect {
    [PNonSerializedAttribute]
private Nullable`1<SemanticallyAdvisedMethodKinds> semanticallyAdvisedMethods;
    protected SemanticallyAdvisedMethodKinds SemanticallyAdvisedMethodKinds { get; protected set; }
    public UnsupportedTargetAction UnsupportedTargetAction { get; public set; }
    protected SemanticallyAdvisedMethodKinds get_SemanticallyAdvisedMethodKinds();
    protected void set_SemanticallyAdvisedMethodKinds(SemanticallyAdvisedMethodKinds value);
    public UnsupportedTargetAction get_UnsupportedTargetAction();
    public void set_UnsupportedTargetAction(UnsupportedTargetAction value);
    [RequiresMethodInterceptionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("1")]
[HasInheritedAttributeAttribute]
[MethodInterceptionAdviceOptimizationAttribute("2048")]
public virtual void OnInvoke(MethodInterceptionArgs args);
    protected virtual AspectConfiguration CreateAspectConfiguration();
    protected virtual void SetAspectConfiguration(AspectConfiguration aspectConfiguration, MethodBase targetMethod);
}
[MulticastAttributeUsageAttribute("448")]
[AttributeUsageAttribute("749")]
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[SerializerAttribute("")]
public abstract class PostSharp.Aspects.MethodLevelAspect : Aspect {
    public virtual bool CompileTimeValidate(MethodBase method);
    public sealed virtual bool CompileTimeValidate(object target);
    public virtual void CompileTimeInitialize(MethodBase method, AspectInfo aspectInfo);
    protected virtual void SetAspectConfiguration(AspectConfiguration aspectConfiguration, MethodBase targetMethod);
    protected sealed virtual void SetAspectConfiguration(AspectConfiguration aspectConfiguration, object targetElement);
    [RuntimeInitializeOptimizationAttribute("1")]
public virtual void RuntimeInitialize(MethodBase method);
}
[AttributeUsageAttribute("64")]
[RequirePostSharpAttribute("", "ModuleInitializer")]
public class PostSharp.Aspects.ModuleInitializerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    public int Order { get; private set; }
    public ModuleInitializerAttribute(int order);
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
private void set_Order(int value);
}
public class PostSharp.Aspects.NullTaskSentinel : object {
    [CompilerGeneratedAttribute]
private static NullTaskSentinel <Instance>k__BackingField;
    public static NullTaskSentinel Instance { get; }
    private static NullTaskSentinel();
    [CompilerGeneratedAttribute]
public static NullTaskSentinel get_Instance();
}
[AttributeUsageAttribute("1773")]
[MulticastAttributeUsageAttribute("448")]
[HasInheritedAttributeAttribute]
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[AspectConfigurationAttributeTypeAttribute("PostSharp.Aspects.Configuration.OnExceptionAspectConfigurationAttribute")]
[SerializerAttribute("")]
public abstract class PostSharp.Aspects.OnExceptionAspect : MethodLevelAspect {
    [PNonSerializedAttribute]
private Nullable`1<SemanticallyAdvisedMethodKinds> semanticallyAdvisedMethods;
    protected SemanticallyAdvisedMethodKinds SemanticallyAdvisedMethodKinds { get; protected set; }
    public UnsupportedTargetAction UnsupportedTargetAction { get; public set; }
    [MethodExecutionAdviceOptimizationAttribute("2048")]
[RequiresMethodExecutionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("2")]
[HasInheritedAttributeAttribute]
public virtual void OnException(MethodExecutionArgs args);
    protected SemanticallyAdvisedMethodKinds get_SemanticallyAdvisedMethodKinds();
    protected void set_SemanticallyAdvisedMethodKinds(SemanticallyAdvisedMethodKinds value);
    public UnsupportedTargetAction get_UnsupportedTargetAction();
    public void set_UnsupportedTargetAction(UnsupportedTargetAction value);
    public virtual Type GetExceptionType(MethodBase targetMethod);
    protected sealed virtual AspectConfiguration CreateAspectConfiguration();
    protected virtual void SetAspectConfiguration(AspectConfiguration aspectConfiguration, MethodBase targetMethod);
}
[AttributeUsageAttribute("1773")]
[MulticastAttributeUsageAttribute("448")]
[HasInheritedAttributeAttribute]
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[AspectConfigurationAttributeTypeAttribute("PostSharp.Aspects.Configuration.OnMethodBoundaryAspectConfigurationAttribute")]
[SerializerAttribute("")]
public abstract class PostSharp.Aspects.OnMethodBoundaryAspect : MethodLevelAspect {
    [PNonSerializedAttribute]
private Nullable`1<SemanticallyAdvisedMethodKinds> semanticallyAdvisedMethods;
    protected SemanticallyAdvisedMethodKinds SemanticallyAdvisedMethodKinds { get; protected set; }
    public UnsupportedTargetAction UnsupportedTargetAction { get; public set; }
    [MethodExecutionAdviceOptimizationAttribute("2048")]
[RequiresMethodExecutionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("2")]
[HasInheritedAttributeAttribute]
public virtual void OnEntry(MethodExecutionArgs args);
    [MethodExecutionAdviceOptimizationAttribute("2048")]
[RequiresMethodExecutionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("2")]
[HasInheritedAttributeAttribute]
public virtual void OnExit(MethodExecutionArgs args);
    [MethodExecutionAdviceOptimizationAttribute("2048")]
[RequiresMethodExecutionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("2")]
[HasInheritedAttributeAttribute]
public virtual void OnSuccess(MethodExecutionArgs args);
    [MethodExecutionAdviceOptimizationAttribute("2048")]
[RequiresMethodExecutionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("2")]
[HasInheritedAttributeAttribute]
public virtual void OnException(MethodExecutionArgs args);
    protected SemanticallyAdvisedMethodKinds get_SemanticallyAdvisedMethodKinds();
    protected void set_SemanticallyAdvisedMethodKinds(SemanticallyAdvisedMethodKinds value);
    public UnsupportedTargetAction get_UnsupportedTargetAction();
    public void set_UnsupportedTargetAction(UnsupportedTargetAction value);
    protected sealed virtual AspectConfiguration CreateAspectConfiguration();
    protected virtual void SetAspectConfiguration(AspectConfiguration aspectConfiguration, MethodBase targetMethod);
    [MethodExecutionAdviceOptimizationAttribute("2048")]
[RequiresMethodExecutionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("2")]
[HasInheritedAttributeAttribute]
public virtual void OnResume(MethodExecutionArgs args);
    [MethodExecutionAdviceOptimizationAttribute("2048")]
[RequiresMethodExecutionAdviceAnalysisAttribute]
[RequiresDebuggerEnhancementAttribute("2")]
[HasInheritedAttributeAttribute]
public virtual void OnYield(MethodExecutionArgs args);
}
[FlagsAttribute]
public enum PostSharp.Aspects.SemanticallyAdvisedMethodKinds : Enum {
    public int value__;
    public static SemanticallyAdvisedMethodKinds None;
    public static SemanticallyAdvisedMethodKinds Async;
    public static SemanticallyAdvisedMethodKinds ReturnsAwaitable;
    public static SemanticallyAdvisedMethodKinds Iterator;
    public static SemanticallyAdvisedMethodKinds ReturnsEnumerable;
    public static SemanticallyAdvisedMethodKinds AsyncIterator;
    public static SemanticallyAdvisedMethodKinds Default;
    public static SemanticallyAdvisedMethodKinds All;
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
public abstract class PostSharp.Aspects.Serialization.AspectSerializer : object {
    public abstract virtual void Serialize(IAspect[] aspects, Stream stream, IMetadataEmitter metadataEmitter);
    protected abstract virtual IAspect[] Deserialize(Stream stream, IMetadataDispenser metadataDispenser);
    public IAspect[] Deserialize(Assembly assembly, string resourceName, IMetadataDispenser metadataDispenser);
}
[AttributeUsageAttribute("384")]
internal class PostSharp.Aspects.Serialization.AspectSerializerIgnoreAttribute : Attribute {
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
public class PostSharp.Aspects.Serialization.BinaryAspectSerializationBinder : SerializationBinder {
    private Dictionary`2<string, Assembly> assemblyCache;
    private Dictionary`2<string, Type> typeCache;
    private Dictionary`2<string, string> policies;
    public virtual Type BindToType(string assemblyName, string typeName);
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
public class PostSharp.Aspects.Serialization.BinaryAspectSerializer : AspectSerializer {
    private static ISurrogateSelector surrogateSelector;
    private static SerializationBinder binder;
    [ThreadStaticAttribute]
private static IMetadataDispenser currentMetadataDispenser;
    internal static IMetadataDispenser CurrentMetadataDispenser { get; }
    private static BinaryAspectSerializer();
    internal static IMetadataDispenser get_CurrentMetadataDispenser();
    protected virtual IAspect[] Deserialize(Stream stream, IMetadataDispenser metadataDispenser);
    public virtual void Serialize(IAspect[] aspects, Stream stream, IMetadataEmitter metadataEmitter);
    public static void ChainSurrogateSelector(ISurrogateSelector selector);
}
public interface PostSharp.Aspects.Serialization.IMetadataAwareSurrogateSelector {
    public abstract virtual void SetMetadataEmitter(IMetadataEmitter metadataEmitter);
}
internal interface PostSharp.Aspects.Serialization.IMetadataBasedSerializationBinderProvider {
    public abstract virtual SerializationBinder GetSerializationBinder(IMetadataEmitter metadataEmitter);
}
internal class PostSharp.Aspects.Serialization.MetadataSerializationHolder : object {
    private int index;
    public MetadataSerializationHolder(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public sealed virtual object GetRealObject(StreamingContext context);
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
public class PostSharp.Aspects.Serialization.MsilAspectSerializer : AspectSerializer {
    public virtual void Serialize(IAspect[] aspects, Stream stream, IMetadataEmitter metadataEmitter);
    protected virtual IAspect[] Deserialize(Stream stream, IMetadataDispenser metadataDispenser);
}
public class PostSharp.Aspects.Serialization.PortableAspectSerializer : AspectSerializer {
    public virtual void Serialize(IAspect[] aspects, Stream stream, IMetadataEmitter metadataEmitter);
    protected virtual IAspect[] Deserialize(Stream stream, IMetadataDispenser metadataDispenser);
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
public class PostSharp.Aspects.TypeIdentity : object {
    private Type type;
    private string typeName;
    public Type Type { get; }
    public string TypeName { get; }
    private TypeIdentity(Type type);
    private TypeIdentity(string typeName);
    public static TypeIdentity FromType(Type type);
    public static TypeIdentity[] FromTypes(Type[] types);
    public Type get_Type();
    public Type ToType();
    public static TypeIdentity FromTypeName(string typeName);
    public static TypeIdentity[] FromTypeNames(String[] typeNames);
    public string get_TypeName();
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
[MulticastAttributeUsageAttribute("19")]
[AttributeUsageAttribute("1037")]
[SerializerAttribute("")]
public abstract class PostSharp.Aspects.TypeLevelAspect : Aspect {
    public virtual bool CompileTimeValidate(Type type);
    public sealed virtual bool CompileTimeValidate(object target);
    protected virtual void SetAspectConfiguration(AspectConfiguration aspectConfiguration, Type targetType);
    protected sealed virtual void SetAspectConfiguration(AspectConfiguration aspectConfiguration, object targetElement);
    public virtual void CompileTimeInitialize(Type type, AspectInfo aspectInfo);
    [RuntimeInitializeOptimizationAttribute("1")]
public virtual void RuntimeInitialize(Type type);
}
public enum PostSharp.Aspects.UnsupportedTargetAction : Enum {
    public int value__;
    public static UnsupportedTargetAction Default;
    public static UnsupportedTargetAction Fail;
    public static UnsupportedTargetAction Ignore;
    public static UnsupportedTargetAction Fallback;
}
internal enum PostSharp.BoolWithDefault : Enum {
    public byte value__;
    public static BoolWithDefault Default;
    public static BoolWithDefault True;
    public static BoolWithDefault False;
}
[InternalImplementAttribute]
public interface PostSharp.Collections.ILinkedListNode`1 {
    public T Value { get; }
    public ILinkedListNode`1<T> Previous { get; }
    public ILinkedListNode`1<T> Next { get; }
    public abstract virtual T get_Value();
    public abstract virtual ILinkedListNode`1<T> get_Previous();
    public abstract virtual ILinkedListNode`1<T> get_Next();
}
[InternalImplementAttribute]
public interface PostSharp.Collections.IReadOnlyLinkedList`1 {
    public ILinkedListNode`1<T> First { get; }
    public ILinkedListNode`1<T> Last { get; }
    public bool IsEmpty { get; }
    public abstract virtual ILinkedListNode`1<T> get_First();
    public abstract virtual ILinkedListNode`1<T> get_Last();
    public abstract virtual bool get_IsEmpty();
}
[InternalImplementAttribute]
public interface PostSharp.Collections.ISinglyLinkedListNode`1 {
    public T Value { get; }
    public ISinglyLinkedListNode`1<T> Next { get; }
    public abstract virtual T get_Value();
    public abstract virtual ISinglyLinkedListNode`1<T> get_Next();
}
public static class PostSharp.Collections.LinkedListExtensions : object {
    public static IEnumerable`1<T> ToEnumerable(IReadOnlyLinkedList`1<T> linkedList);
    public static IEnumerable`1<T> ToEnumerable(ReadOnlyLinkedList`1<T> linkedList);
}
public class PostSharp.Collections.ReadOnlyLinkedList`1 : ValueType {
    [CompilerGeneratedAttribute]
private ILinkedListNode`1<T> <First>k__BackingField;
    [CompilerGeneratedAttribute]
private ILinkedListNode`1<T> <Last>k__BackingField;
    public ILinkedListNode`1<T> First { get; private set; }
    public ILinkedListNode`1<T> Last { get; private set; }
    public bool IsEmpty { get; }
    internal ReadOnlyLinkedList`1(ILinkedListNode`1<T> first, ILinkedListNode`1<T> last);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual ILinkedListNode`1<T> get_First();
    [CompilerGeneratedAttribute]
private void set_First(ILinkedListNode`1<T> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual ILinkedListNode`1<T> get_Last();
    [CompilerGeneratedAttribute]
private void set_Last(ILinkedListNode`1<T> value);
    public sealed virtual bool get_IsEmpty();
}
public class PostSharp.Collections.ReadOnlySinglyLinkedList`1 : ValueType {
    [CompilerGeneratedAttribute]
private ISinglyLinkedListNode`1<T> <FirstNode>k__BackingField;
    public ISinglyLinkedListNode`1<T> FirstNode { get; private set; }
    public bool IsEmpty { get; }
    internal ReadOnlySinglyLinkedList`1(ISinglyLinkedListNode`1<T> node);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ISinglyLinkedListNode`1<T> get_FirstNode();
    [CompilerGeneratedAttribute]
private void set_FirstNode(ISinglyLinkedListNode`1<T> value);
    public bool get_IsEmpty();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Enumerator<T> GetEnumerator();
}
internal class PostSharp.Constraints.ArchitectureMessageSource : MessageSource {
    public static ArchitectureMessageSource Instance;
    private static ArchitectureMessageSource();
}
public class PostSharp.Constraints.ComponentInternalAttribute : ReferenceConstraint {
    private String[] friendNamespaces;
    [CompilerGeneratedAttribute]
private SeverityType <Severity>k__BackingField;
    public SeverityType Severity { get; public set; }
    public ComponentInternalAttribute(Type[] friendTypes);
    public ComponentInternalAttribute(String[] friendNamespaces);
    [CompilerGeneratedAttribute]
public SeverityType get_Severity();
    [CompilerGeneratedAttribute]
public void set_Severity(SeverityType value);
    protected virtual void ValidateReference(ICodeReference codeReference);
}
public abstract class PostSharp.Constraints.Constraint : MulticastAttribute {
    public virtual bool ValidateConstraint(object target);
}
[AttributeUsageAttribute("6143")]
[MulticastAttributeUsageAttribute("127")]
public class PostSharp.Constraints.ExperimentalAttribute : ReferentialConstraint {
    public virtual void ValidateCode(object target, Assembly assembly);
}
[RequirePostSharpAttribute("", "ArchitectureConstraint")]
public interface PostSharp.Constraints.IConstraint {
    public abstract virtual bool ValidateConstraint(object target);
}
[AttributeUsageAttribute("6143")]
[MulticastAttributeUsageAttribute("255")]
public class PostSharp.Constraints.InternalAttribute : ReferentialConstraint {
    [CompilerGeneratedAttribute]
private SeverityType <Severity>k__BackingField;
    public SeverityType Severity { get; public set; }
    public virtual bool ValidateConstraint(object target);
    [CompilerGeneratedAttribute]
public SeverityType get_Severity();
    [CompilerGeneratedAttribute]
public void set_Severity(SeverityType value);
    private void Validate(ICodeReference codeReference, object referencedDeclaration);
    public virtual void ValidateCode(object target, Assembly assembly);
}
[AttributeUsageAttribute("6143")]
[MulticastAttributeUsageAttribute("16")]
public class PostSharp.Constraints.InternalImplementAttribute : ReferentialConstraint {
    [CompilerGeneratedAttribute]
private SeverityType <Severity>k__BackingField;
    public SeverityType Severity { get; public set; }
    [CompilerGeneratedAttribute]
public SeverityType get_Severity();
    [CompilerGeneratedAttribute]
public void set_Severity(SeverityType value);
    public virtual void ValidateCode(object target, Assembly assembly);
}
[AttributeUsageAttribute("4477")]
[MulticastAttributeUsageAttribute("2048")]
[RequirePostSharpAttribute("", "ArchitectureConstraint")]
[InternalAttribute]
public class PostSharp.Constraints.Internals.HasConstraintAttribute : MulticastAttribute {
}
public interface PostSharp.Constraints.IReferentialConstraint {
    public abstract virtual void ValidateCode(object target, Assembly assembly);
}
public interface PostSharp.Constraints.IScalarConstraint {
    public abstract virtual void ValidateCode(object target);
}
[MulticastAttributeUsageAttribute("17")]
[AttributeUsageAttribute("1029")]
public class PostSharp.Constraints.NamingConventionAttribute : ScalarConstraint {
    private static string regexPrefix;
    private string pattern;
    [CompilerGeneratedAttribute]
private SeverityType <Severity>k__BackingField;
    public SeverityType Severity { get; public set; }
    public NamingConventionAttribute(string pattern);
    [CompilerGeneratedAttribute]
public SeverityType get_Severity();
    [CompilerGeneratedAttribute]
public void set_Severity(SeverityType value);
    public virtual bool ValidateConstraint(object target);
    public virtual void ValidateCode(object target);
}
[AttributeUsageAttribute("2048")]
[MulticastAttributeUsageAttribute("4096")]
public abstract class PostSharp.Constraints.ParameterValueConstraint : ReferentialConstraint {
    public sealed virtual bool ValidateConstraint(object target);
    protected virtual bool ValidateTargetParameter(ParameterInfo parameter);
    public sealed virtual void ValidateCode(object target, Assembly assembly);
    protected abstract virtual void ValidateParameterValue(ParameterInfo parameter, IExpression expression);
}
[AttributeUsageAttribute("6143")]
[MulticastAttributeUsageAttribute("255")]
public class PostSharp.Constraints.ProtectedAttribute : ReferentialConstraint {
    [CompilerGeneratedAttribute]
private SeverityType <Severity>k__BackingField;
    public SeverityType Severity { get; public set; }
    [CompilerGeneratedAttribute]
public SeverityType get_Severity();
    [CompilerGeneratedAttribute]
public void set_Severity(SeverityType value);
    public virtual bool ValidateConstraint(object target);
    private void Validate(ICodeReference codeReference, object referencedDeclaration);
    public virtual void ValidateCode(object target, Assembly assembly);
}
[AttributeUsageAttribute("6143")]
[MulticastAttributeUsageAttribute("255")]
public abstract class PostSharp.Constraints.ReferenceConstraint : ReferentialConstraint {
    protected abstract virtual void ValidateReference(ICodeReference reference);
    public sealed virtual void ValidateCode(object target, Assembly assembly);
}
public abstract class PostSharp.Constraints.ReferentialConstraint : Constraint {
    public virtual void ValidateCode(object target, Assembly assembly);
}
public class PostSharp.Constraints.ScalarConstraint : Constraint {
    public virtual void ValidateCode(object target);
}
[AttributeUsageAttribute("32767")]
[ExplicitCrossPackageInternalAttribute]
internal class PostSharp.ExplicitCrossPackageInternalAttribute : Attribute {
}
[InternalAttribute]
[AttributeUsageAttribute("5")]
[ObsoleteAttribute("Licensing is now based on hard-coded assembly name.")]
public class PostSharp.Extensibility.AllowFreeInstancesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <FreeInstanceCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ApplyToType>k__BackingField;
    public string FeatureName { get; private set; }
    public Nullable`1<int> FreeInstanceCount { get; private set; }
    public bool ApplyToType { get; public set; }
    public AllowFreeInstancesAttribute(string featureName);
    public AllowFreeInstancesAttribute(string featureName, int count);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
private void set_FeatureName(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_FreeInstanceCount();
    [CompilerGeneratedAttribute]
private void set_FreeInstanceCount(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_ApplyToType();
    [CompilerGeneratedAttribute]
public void set_ApplyToType(bool value);
}
[AttributeUsageAttribute("1")]
public class PostSharp.Extensibility.AssemblyIdAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <AssemblyId>k__BackingField;
    public int AssemblyId { get; }
    public AssemblyIdAttribute(int id);
    [CompilerGeneratedAttribute]
public int get_AssemblyId();
}
public enum PostSharp.Extensibility.BindingContext : Enum {
    public int value__;
    public static BindingContext None;
    public static BindingContext Reference;
    public static BindingContext Runtime;
}
public class PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogActivity : ValueType {
    private bool dispose;
    internal BuildTimeLogActivity(bool dispose);
    public sealed virtual void Dispose();
}
public class PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger : object {
    private static string indentSpaces;
    private string category;
    private StringBuilder lineBuffer;
    private static int indent;
    private static Char[] eol;
    public static bool IsInitialized { get; }
    private BuildTimeLogger(string category);
    private static BuildTimeLogger();
    private void InternalWrite(string message);
    private void InternalWriteLine(string message);
    public void WriteLine(string message);
    public void WriteLine(string message, Object[] args);
    private static string SafeStringFormat(string format, Object[] args);
    public void Write(string message);
    public void Write(string message, Object[] args);
    public BuildTimeLogActivity Activity(string message);
    public static BuildTimeLogger GetInstance(string category);
    internal static BuildTimeLogger GetDetachedInstance(string category);
    internal static void WhenLoggerEnabled(string category, Action`1<BuildTimeLogger> action);
    internal static void UnindentCore();
    [ObsoleteAttribute("Use Activity.")]
internal void Indent();
    [ObsoleteAttribute("Use Activity.")]
internal void Unindent();
    public static void Initialize(IEnumerable`1<string> enabledCategories);
    public static bool get_IsInitialized();
    public void Write(string format, T1 arg1);
    public void WriteLine(string format, T1 arg1);
    public BuildTimeLogActivity Activity(string format, T1 arg1);
    public void Write(string format, T1 arg1, T2 arg2);
    public void WriteLine(string format, T1 arg1, T2 arg2);
    public BuildTimeLogActivity Activity(string format, T1 arg1, T2 arg2);
    public void Write(string format, T1 arg1, T2 arg2, T3 arg3);
    public void WriteLine(string format, T1 arg1, T2 arg2, T3 arg3);
    public BuildTimeLogActivity Activity(string format, T1 arg1, T2 arg2, T3 arg3);
    public void Write(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public void WriteLine(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public BuildTimeLogActivity Activity(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public void Write(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public void WriteLine(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public BuildTimeLogActivity Activity(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public void Write(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    public void WriteLine(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    public BuildTimeLogActivity Activity(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    public void Write(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    public void WriteLine(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    public BuildTimeLogActivity Activity(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
}
internal static class PostSharp.Extensibility.BuildTimeLogging.BuildTimeLoggingConfiguration : object {
    private static HashSet`1<string> enabledCategories;
    private static Dictionary`2<string, List`1<Action`1<string>>> whenEnabledActions;
    [CompilerGeneratedAttribute]
private static bool <IsInitialized>k__BackingField;
    public static bool IsInitialized { get; private set; }
    private static BuildTimeLoggingConfiguration();
    internal static bool IsEnabled(string category);
    internal static void WhenEnabled(string category, Action`1<string> action);
    public static void Initialize(IEnumerable`1<string> categories);
    [CompilerGeneratedAttribute]
public static bool get_IsInitialized();
    [CompilerGeneratedAttribute]
private static void set_IsInitialized(bool value);
}
public static class PostSharp.Extensibility.DebuggerInterop : object {
    public static long NextStateMachineId;
    public static bool IsInInspectionQuery;
    private static DebuggerInterop();
    internal static void Dummy();
}
[AttributeUsageAttribute("1")]
public class PostSharp.Extensibility.EscalatePostSharpMessageAttribute : Attribute {
    private string messageId;
    public string MessageId { get; }
    public EscalatePostSharpMessageAttribute(string messageId);
    public string get_MessageId();
}
[AttributeUsageAttribute("11333")]
public class PostSharp.Extensibility.HasInheritedAttributeAttribute : Attribute {
    [ObsoleteAttribute("Do not use this custom attribute in user code.", "False")]
public HasInheritedAttributeAttribute(Int64[] ids);
}
public interface PostSharp.Extensibility.ICompatibilityLevelService {
    public Version CompatibilityLevel { get; }
    public abstract virtual Version get_CompatibilityLevel();
}
public interface PostSharp.Extensibility.IFormattingService {
    [ObsoleteAttribute("Pass the IFormatProvider. This helps the analyzers.")]
public abstract virtual string Format(string format, Object[] arguments);
    public abstract virtual string Format(IFormatProvider provider, string format, Object[] arguments);
}
public interface PostSharp.Extensibility.IMessageDispenser {
    public abstract virtual string GetMessage(string key);
}
internal interface PostSharp.Extensibility.IMessageFormatter {
    public abstract virtual bool IsMessageIgnored(string messageNumber, MessageLocation messageLocation);
}
public interface PostSharp.Extensibility.IMessageLocationResolver {
    public abstract virtual MessageLocation GetMessageLocation(object codeElement);
}
public interface PostSharp.Extensibility.IMessageSink {
    public abstract virtual void Write(Message message);
}
[AttributeUsageAttribute("1")]
public class PostSharp.Extensibility.ImplementationBoundAttributeAttribute : Attribute {
    private Type attributeType;
    public Type AttributeType { get; }
    public ImplementationBoundAttributeAttribute(Type attributeType);
    public Type get_AttributeType();
}
public class PostSharp.Extensibility.InvalidAnnotationException : Exception {
    public InvalidAnnotationException(string message);
    public InvalidAnnotationException(string message, Exception inner);
    protected InvalidAnnotationException(SerializationInfo info, StreamingContext context);
}
public interface PostSharp.Extensibility.IPostSharpEnvironment {
    public IProject CurrentProject { get; }
    public abstract virtual IProject get_CurrentProject();
    public abstract virtual Assembly LoadAssemblyFromFile(string fileName);
}
[InternalImplementAttribute]
public interface PostSharp.Extensibility.IProject {
    public IStateStore StateStore { get; }
    public Assembly TargetAssembly { get; }
    public abstract virtual IStateStore get_StateStore();
    public abstract virtual string EvaluateExpression(string expression);
    public abstract virtual Assembly get_TargetAssembly();
    public abstract virtual T GetService(bool throwing);
    public abstract virtual IEnumerable`1<ProjectExtensionElement> GetExtensionElements(string name, string ns);
}
public interface PostSharp.Extensibility.IReflectionBindingManagerService {
    public abstract virtual string ResolveAssembly(Type type);
}
public interface PostSharp.Extensibility.IService {
}
public interface PostSharp.Extensibility.IServiceLocator {
    public abstract virtual T GetService(bool throwing);
}
public interface PostSharp.Extensibility.IStateStore {
    public abstract virtual T Get();
    public abstract virtual void Set(T value);
    public abstract virtual T GetOrAdd(Func`1<T> getter);
    public abstract virtual T GetOrNew();
}
[RequirePostSharpAttribute("", "ValidateAnnotations")]
public interface PostSharp.Extensibility.IValidableAnnotation {
    public abstract virtual bool CompileTimeValidate(object target);
}
[InternalImplementAttribute]
public interface PostSharp.Extensibility.IWeavingSymbolsService {
    public abstract virtual void PushAnnotation(object targetDeclaration, Type annotationClass, string arguments, string description, int linesOfCodeAvoided);
}
public class PostSharp.Extensibility.Message : object {
    public static int NotAvailable;
    private static string customSource;
    private static MessageLocation NullLocation;
    [CompilerGeneratedAttribute]
private SeverityType <Severity>k__BackingField;
    [CompilerGeneratedAttribute]
private SeverityType <OriginalSeverity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    private MessageLocation location;
    [CompilerGeneratedAttribute]
private Exception <InnerException>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpLink>k__BackingField;
    public SeverityType Severity { get; internal set; }
    internal SeverityType OriginalSeverity { get; private set; }
    public string MessageId { get; private set; }
    public MessageLocation Location { get; public set; }
    public Exception InnerException { get; private set; }
    public string Source { get; private set; }
    public string MessageText { get; private set; }
    public string HelpLink { get; private set; }
    public Message(MessageLocation location, SeverityType severity, string messageId, string messageText, string helpLink, string source, Exception innerException);
    public Message(SeverityType severity, string messageId, string messageText, string helpLink, string source, string locationFile, int locationLine, int locationColumn, Exception innerException);
    public Message(SeverityType severity, string messageId, string messageText, string helpLink, string source, string locationFile, int locationStartLine, int locationStartColumn, int locationEndLine, int locationEndColumn, Exception innerException);
    private static Message();
    [CompilerGeneratedAttribute]
public SeverityType get_Severity();
    [CompilerGeneratedAttribute]
internal void set_Severity(SeverityType value);
    [CompilerGeneratedAttribute]
internal SeverityType get_OriginalSeverity();
    [CompilerGeneratedAttribute]
private void set_OriginalSeverity(SeverityType value);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
private void set_MessageId(string value);
    public MessageLocation get_Location();
    public void set_Location(MessageLocation value);
    [CompilerGeneratedAttribute]
public Exception get_InnerException();
    [CompilerGeneratedAttribute]
private void set_InnerException(Exception value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(string value);
    [CompilerGeneratedAttribute]
public string get_MessageText();
    [CompilerGeneratedAttribute]
private void set_MessageText(string value);
    [CompilerGeneratedAttribute]
public string get_HelpLink();
    [CompilerGeneratedAttribute]
private void set_HelpLink(string value);
    public static string GetExceptionStackMessage(Exception outerException);
    public static void Write(Message message);
    public static void Write(MessageLocation messageLocation, SeverityType severity, string errorCode, string message);
    public static void Write(MessageLocation messageLocation, SeverityType severity, string errorCode, string format, Object[] arguments);
    public static void Write(MemberInfo codeElement, SeverityType severity, string errorCode, string format, Object[] arguments);
    public static void Write(Type type, SeverityType severity, string errorCode, string format, Object[] arguments);
    public static void Write(ParameterInfo codeElement, SeverityType severity, string errorCode, string format, Object[] arguments);
    public static void Write(Assembly codeElement, SeverityType severity, string errorCode, string format, Object[] arguments);
    public static void Write(LocationInfo codeElement, SeverityType severity, string errorCode, string format, Object[] arguments);
}
public abstract class PostSharp.Extensibility.MessageDispenser : object {
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    public string Prefix { get; private set; }
    protected MessageDispenser(string prefix);
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
private void set_Prefix(string value);
    public sealed virtual string GetMessage(string key);
    protected abstract virtual string GetMessage(int number);
    protected virtual string GetHelpUrl(int number);
}
public class PostSharp.Extensibility.MessageException : Exception {
    private Message message;
    public Message MessageObject { get; }
    public MessageException(Message message);
    private MessageException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public Message get_MessageObject();
    private static string GetMessageText(Message message);
}
public class PostSharp.Extensibility.MessageLocation : object {
    private object codeElement;
    public static MessageLocation Unknown;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumn>k__BackingField;
    public object CodeElement { get; }
    public string File { get; private set; }
    public int StartLine { get; private set; }
    public int StartColumn { get; private set; }
    public int EndLine { get; private set; }
    public int EndColumn { get; private set; }
    private MessageLocation(object codeElement);
    private MessageLocation(string file, int startLine, int startColumn, int endLine, int endColumn);
    private MessageLocation(string file, int startLine, int startColumn, int endLine, int endColumn, object parentCodeElement);
    public static MessageLocation Of(SymbolSequencePoint symbolSequencePoint);
    public static MessageLocation Explicit(string file, int lineStart, int columnStart, int lineEnd, int columnEnd);
    public static MessageLocation Explicit(string file, int line, int column);
    public static MessageLocation Explicit(string file);
    public static MessageLocation Of(object codeElement);
    public static MessageLocation Of(MemberInfo member);
    public static MessageLocation Of(ParameterInfo parameter);
    public static MessageLocation Of(LocationInfo location);
    public static MessageLocation Of(Assembly assembly);
    public static MessageLocation Of(IExpression expression);
    public object get_CodeElement();
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
private void set_File(string value);
    [CompilerGeneratedAttribute]
public int get_StartLine();
    [CompilerGeneratedAttribute]
private void set_StartLine(int value);
    [CompilerGeneratedAttribute]
public int get_StartColumn();
    [CompilerGeneratedAttribute]
private void set_StartColumn(int value);
    [CompilerGeneratedAttribute]
public int get_EndLine();
    [CompilerGeneratedAttribute]
private void set_EndLine(int value);
    [CompilerGeneratedAttribute]
public int get_EndColumn();
    [CompilerGeneratedAttribute]
private void set_EndColumn(int value);
}
public class PostSharp.Extensibility.MessageSource : MarshalByRefObject {
    private IMessageDispenser messageDispenser;
    private string source;
    [CompilerGeneratedAttribute]
private static IMessageSink <MessageSink>k__BackingField;
    [CompilerGeneratedAttribute]
private static IMessageFormatter <Formatter>k__BackingField;
    public static IMessageSink MessageSink { get; internal set; }
    internal static IMessageFormatter Formatter { get; internal set; }
    public MessageSource(string source, ResourceManager resourceManager);
    public MessageSource(string source, IMessageDispenser messageDispenser);
    public Message CreateMessage(MessageLocation location, SeverityType severity, string messageId, Exception innerException, Object[] arguments);
    private void FormatMessage(string messageId, Object[] arguments, String& messageText, String& helpLink);
    public void Write(MessageLocation location, SeverityType severity, string messageId, Exception innerException, Object[] arguments);
    public void Write(MessageLocation location, SeverityType severity, string messageId, Object[] arguments);
    public void Write(MemberInfo codeElement, SeverityType severity, string messageId, Object[] arguments);
    public void Write(ParameterInfo codeElement, SeverityType severity, string messageId, Object[] arguments);
    public void Write(Assembly codeElement, SeverityType severity, string messageId, Object[] arguments);
    public sealed virtual void Write(Message message);
    [CompilerGeneratedAttribute]
public static IMessageSink get_MessageSink();
    [CompilerGeneratedAttribute]
internal static void set_MessageSink(IMessageSink value);
    [CompilerGeneratedAttribute]
internal static IMessageFormatter get_Formatter();
    [CompilerGeneratedAttribute]
internal static void set_Formatter(IMessageFormatter value);
}
[AttributeUsageAttribute("4")]
public class PostSharp.Extensibility.MetricAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <MetricName>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Operand>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowImplementationMetrics>k__BackingField;
    public string MetricName { get; private set; }
    public object Operand { get; private set; }
    public bool AllowImplementationMetrics { get; public set; }
    public MetricAttribute(string metricName, object operand);
    [CompilerGeneratedAttribute]
public string get_MetricName();
    [CompilerGeneratedAttribute]
private void set_MetricName(string value);
    [CompilerGeneratedAttribute]
public object get_Operand();
    [CompilerGeneratedAttribute]
private void set_Operand(object value);
    [CompilerGeneratedAttribute]
public bool get_AllowImplementationMetrics();
    [CompilerGeneratedAttribute]
public void set_AllowImplementationMetrics(bool value);
}
[SerializerAttribute("")]
public abstract class PostSharp.Extensibility.MulticastAttribute : Attribute {
    [PNonSerializedAttribute]
private Fields fields;
    [AspectSerializerIgnoreAttribute]
public MulticastTargets AttributeTargetElements { get; public set; }
    [AspectSerializerIgnoreAttribute]
public string AttributeTargetAssemblies { get; public set; }
    [AspectSerializerIgnoreAttribute]
public string AttributeTargetTypes { get; public set; }
    [AspectSerializerIgnoreAttribute]
public MulticastAttributes AttributeTargetTypeAttributes { get; public set; }
    [AspectSerializerIgnoreAttribute]
public MulticastAttributes AttributeTargetExternalTypeAttributes { get; public set; }
    [AspectSerializerIgnoreAttribute]
public string AttributeTargetMembers { get; public set; }
    [AspectSerializerIgnoreAttribute]
public MulticastAttributes AttributeTargetMemberAttributes { get; public set; }
    [AspectSerializerIgnoreAttribute]
public MulticastAttributes AttributeTargetExternalMemberAttributes { get; public set; }
    [AspectSerializerIgnoreAttribute]
public string AttributeTargetParameters { get; public set; }
    [AspectSerializerIgnoreAttribute]
public MulticastAttributes AttributeTargetParameterAttributes { get; public set; }
    [AspectSerializerIgnoreAttribute]
public bool AttributeExclude { get; public set; }
    [AspectSerializerIgnoreAttribute]
public int AttributePriority { get; public set; }
    [AspectSerializerIgnoreAttribute]
public bool AttributeReplace { get; public set; }
    [AspectSerializerIgnoreAttribute]
public MulticastInheritance AttributeInheritance { get; public set; }
    [ObsoleteAttribute("Do not use this property in customer code.", "True")]
[AspectSerializerIgnoreAttribute]
public long AttributeId { get; public set; }
    private Fields GetFields();
    public MulticastTargets get_AttributeTargetElements();
    public void set_AttributeTargetElements(MulticastTargets value);
    public string get_AttributeTargetAssemblies();
    public void set_AttributeTargetAssemblies(string value);
    public string get_AttributeTargetTypes();
    public void set_AttributeTargetTypes(string value);
    public MulticastAttributes get_AttributeTargetTypeAttributes();
    public void set_AttributeTargetTypeAttributes(MulticastAttributes value);
    public MulticastAttributes get_AttributeTargetExternalTypeAttributes();
    public void set_AttributeTargetExternalTypeAttributes(MulticastAttributes value);
    public string get_AttributeTargetMembers();
    public void set_AttributeTargetMembers(string value);
    public MulticastAttributes get_AttributeTargetMemberAttributes();
    public void set_AttributeTargetMemberAttributes(MulticastAttributes value);
    public MulticastAttributes get_AttributeTargetExternalMemberAttributes();
    public void set_AttributeTargetExternalMemberAttributes(MulticastAttributes value);
    public string get_AttributeTargetParameters();
    public void set_AttributeTargetParameters(string value);
    public MulticastAttributes get_AttributeTargetParameterAttributes();
    public void set_AttributeTargetParameterAttributes(MulticastAttributes value);
    public bool get_AttributeExclude();
    public void set_AttributeExclude(bool value);
    public int get_AttributePriority();
    public void set_AttributePriority(int value);
    public bool get_AttributeReplace();
    public void set_AttributeReplace(bool value);
    public MulticastInheritance get_AttributeInheritance();
    public void set_AttributeInheritance(MulticastInheritance value);
    public long get_AttributeId();
    public void set_AttributeId(long value);
}
[FlagsAttribute]
public enum PostSharp.Extensibility.MulticastAttributes : Enum {
    public int value__;
    public static MulticastAttributes Default;
    public static MulticastAttributes Private;
    public static MulticastAttributes Protected;
    public static MulticastAttributes Internal;
    public static MulticastAttributes InternalAndProtected;
    public static MulticastAttributes InternalOrProtected;
    public static MulticastAttributes Public;
    public static MulticastAttributes AnyVisibility;
    public static MulticastAttributes Static;
    public static MulticastAttributes Instance;
    public static MulticastAttributes AnyScope;
    public static MulticastAttributes Abstract;
    public static MulticastAttributes NonAbstract;
    public static MulticastAttributes AnyAbstraction;
    public static MulticastAttributes Virtual;
    public static MulticastAttributes NonVirtual;
    public static MulticastAttributes AnyVirtuality;
    public static MulticastAttributes Managed;
    public static MulticastAttributes NonManaged;
    public static MulticastAttributes AnyImplementation;
    public static MulticastAttributes Literal;
    public static MulticastAttributes NonLiteral;
    public static MulticastAttributes AnyLiterality;
    public static MulticastAttributes InParameter;
    public static MulticastAttributes CompilerGenerated;
    public static MulticastAttributes UserGenerated;
    public static MulticastAttributes AnyGeneration;
    public static MulticastAttributes OutParameter;
    public static MulticastAttributes RefParameter;
    public static MulticastAttributes AnyParameter;
    public static MulticastAttributes All;
}
[AttributeUsageAttribute("4")]
public class PostSharp.Extensibility.MulticastAttributeUsageAttribute : Attribute {
    private MulticastTargets validOn;
    private BoolWithDefault allowExternalAssemblies;
    private BoolWithDefault allowMultiple;
    private MulticastInheritance inheritance;
    private bool isInheritanceSpecified;
    private BoolWithDefault persistMetaData;
    private MulticastAttributes targetMemberAttributes;
    private bool isTargetMemberAttributesSpecified;
    private MulticastAttributes targetExternalMemberAttributes;
    private bool isTargetExternalMemberAttributesSpecified;
    private MulticastAttributes targetParameterAttributes;
    private bool isTargetParameterAttributesSpecified;
    private MulticastAttributes targetTypeAttributes;
    private bool isTargetTypeAttributesSpecified;
    private MulticastAttributes targetExternalTypeAttributes;
    private bool isTargetExternalTypeAttributesSpecified;
    public MulticastTargets ValidOn { get; internal set; }
    public bool AllowMultiple { get; public set; }
    internal bool IsAllowMultipleSpecified { get; }
    public MulticastInheritance Inheritance { get; public set; }
    internal bool IsInheritanceSpecified { get; }
    public bool AllowExternalAssemblies { get; public set; }
    internal bool IsAllowExternalAssembliesSpecified { get; }
    public bool PersistMetaData { get; public set; }
    internal bool IsPersistMetaDataSpecified { get; }
    public MulticastAttributes TargetMemberAttributes { get; public set; }
    internal bool IsTargetMemberAttributesSpecified { get; }
    public MulticastAttributes TargetExternalMemberAttributes { get; public set; }
    internal bool IsTargetExternalMemberAttributesSpecified { get; }
    public MulticastAttributes TargetParameterAttributes { get; public set; }
    internal bool IsTargetParameterAttributesSpecified { get; }
    public MulticastAttributes TargetTypeAttributes { get; public set; }
    internal bool IsTargetTypeAttributesSpecified { get; }
    public MulticastAttributes TargetExternalTypeAttributes { get; public set; }
    internal bool IsTargetExternalTypeAttributesSpecified { get; }
    public MulticastAttributeUsageAttribute(MulticastTargets validOn);
    public MulticastTargets get_ValidOn();
    internal void set_ValidOn(MulticastTargets value);
    public bool get_AllowMultiple();
    public void set_AllowMultiple(bool value);
    internal bool get_IsAllowMultipleSpecified();
    public MulticastInheritance get_Inheritance();
    public void set_Inheritance(MulticastInheritance value);
    internal bool get_IsInheritanceSpecified();
    public bool get_AllowExternalAssemblies();
    public void set_AllowExternalAssemblies(bool value);
    internal bool get_IsAllowExternalAssembliesSpecified();
    public bool get_PersistMetaData();
    public void set_PersistMetaData(bool value);
    internal bool get_IsPersistMetaDataSpecified();
    public MulticastAttributes get_TargetMemberAttributes();
    public void set_TargetMemberAttributes(MulticastAttributes value);
    internal bool get_IsTargetMemberAttributesSpecified();
    public MulticastAttributes get_TargetExternalMemberAttributes();
    public void set_TargetExternalMemberAttributes(MulticastAttributes value);
    internal bool get_IsTargetExternalMemberAttributesSpecified();
    public MulticastAttributes get_TargetParameterAttributes();
    public void set_TargetParameterAttributes(MulticastAttributes value);
    internal bool get_IsTargetParameterAttributesSpecified();
    public MulticastAttributes get_TargetTypeAttributes();
    public void set_TargetTypeAttributes(MulticastAttributes value);
    internal bool get_IsTargetTypeAttributesSpecified();
    public MulticastAttributes get_TargetExternalTypeAttributes();
    public void set_TargetExternalTypeAttributes(MulticastAttributes value);
    internal bool get_IsTargetExternalTypeAttributesSpecified();
    internal MulticastAttributeUsageAttribute Clone();
    internal static MulticastAttributeUsageAttribute GetMaximumValue();
}
[AttributeUsageAttribute("1")]
[InternalAttribute]
public class PostSharp.Extensibility.MulticastImplementationDetailsTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <MulticastImplementationDetailsType>k__BackingField;
    public Type MulticastImplementationDetailsType { get; }
    public MulticastImplementationDetailsTypeAttribute(Type type);
    [CompilerGeneratedAttribute]
public Type get_MulticastImplementationDetailsType();
}
public enum PostSharp.Extensibility.MulticastInheritance : Enum {
    public int value__;
    public static MulticastInheritance None;
    public static MulticastInheritance Strict;
    public static MulticastInheritance Multicast;
}
[FlagsAttribute]
public enum PostSharp.Extensibility.MulticastTargets : Enum {
    public int value__;
    public static MulticastTargets Default;
    public static MulticastTargets Class;
    public static MulticastTargets Struct;
    public static MulticastTargets Enum;
    public static MulticastTargets Delegate;
    public static MulticastTargets Interface;
    public static MulticastTargets AnyType;
    public static MulticastTargets Field;
    public static MulticastTargets Method;
    public static MulticastTargets InstanceConstructor;
    public static MulticastTargets StaticConstructor;
    public static MulticastTargets Property;
    public static MulticastTargets Event;
    public static MulticastTargets AnyMember;
    public static MulticastTargets Assembly;
    public static MulticastTargets Parameter;
    public static MulticastTargets ReturnValue;
    public static MulticastTargets All;
}
public static class PostSharp.Extensibility.PostSharpEnvironment : object {
    private static IPostSharpEnvironment currentEnvironment;
    public static IPostSharpEnvironment Current { get; internal set; }
    public static IProject CurrentProject { get; }
    public static bool IsPostSharpRunning { get; }
    public static IPostSharpEnvironment get_Current();
    internal static void set_Current(IPostSharpEnvironment value);
    public static IProject get_CurrentProject();
    public static bool get_IsPostSharpRunning();
}
public class PostSharp.Extensibility.ProjectExtensionElement : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWellKnown>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private object <XElement>k__BackingField;
    public string Name { get; private set; }
    internal Nullable`1<bool> IsEnabled { get; internal set; }
    internal bool IsWellKnown { get; private set; }
    public string Namespace { get; private set; }
    public object XElement { get; private set; }
    internal ProjectExtensionElement(string name, string ns, object xmlElement, bool isWellKnown);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
internal Nullable`1<bool> get_IsEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsEnabled(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
internal bool get_IsWellKnown();
    [CompilerGeneratedAttribute]
private void set_IsWellKnown(bool value);
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
private void set_Namespace(string value);
    [CompilerGeneratedAttribute]
public object get_XElement();
    [CompilerGeneratedAttribute]
private void set_XElement(object value);
}
[AttributeUsageAttribute("1")]
[InternalAttribute]
[ObsoleteAttribute("Licensing is now based on hard-coded assembly name.")]
public class PostSharp.Extensibility.RequireLicenseAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Product>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Features>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public int Product { get; private set; }
    public long Features { get; public set; }
    public string Description { get; public set; }
    public RequireLicenseAttribute(int product);
    [CompilerGeneratedAttribute]
public int get_Product();
    [CompilerGeneratedAttribute]
private void set_Product(int value);
    [CompilerGeneratedAttribute]
public long get_Features();
    [CompilerGeneratedAttribute]
public void set_Features(long value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
}
[AttributeUsageAttribute("1037")]
public class PostSharp.Extensibility.RequirePostSharpAttribute : Attribute {
    private string plugIn;
    private string task;
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AssemblyReferenceOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AnyTypeReference>k__BackingField;
    public string PlugIn { get; }
    public string Task { get; }
    public Type ServiceType { get; }
    public bool AssemblyReferenceOnly { get; public set; }
    public bool AnyTypeReference { get; public set; }
    public RequirePostSharpAttribute(string plugIn, string task);
    public RequirePostSharpAttribute(string plugIn);
    public RequirePostSharpAttribute(Type serviceType);
    public string get_PlugIn();
    public string get_Task();
    [CompilerGeneratedAttribute]
public Type get_ServiceType();
    [CompilerGeneratedAttribute]
public bool get_AssemblyReferenceOnly();
    [CompilerGeneratedAttribute]
public void set_AssemblyReferenceOnly(bool value);
    [CompilerGeneratedAttribute]
public bool get_AnyTypeReference();
    [CompilerGeneratedAttribute]
public void set_AnyTypeReference(bool value);
}
internal class PostSharp.Extensibility.ResourceManagerMessageDispenser : object {
    private ResourceManager resourceManager;
    public ResourceManagerMessageDispenser(ResourceManager resourceManager);
    public sealed virtual string GetMessage(string key);
}
internal class PostSharp.Extensibility.ServiceCache : object {
    private IProject project;
    private IAnnotationRepositoryReflectionService annotationRepositoryService;
    private IMethodUsageIndexReflectionService methodUsageIndexService;
    private ITypeHierarchyReflectionService typeHierarchyService;
    private IMemberTypeIndexReflectionService memberTypeIndexReflectionService;
    private IMethodBodyService syntaxReflectionService;
    private IReflectionHelperService reflectionHelperService;
    internal static ServiceCache Current { get; }
    public IAnnotationRepositoryReflectionService AnnotationRepositoryService { get; }
    public IMethodUsageIndexReflectionService IndexUsageService { get; }
    public ITypeHierarchyReflectionService TypeHierarchyService { get; }
    public IMemberTypeIndexReflectionService MemberTypeIndexService { get; }
    public IMethodBodyService SyntaxReflectionService { get; }
    public IReflectionHelperService ReflectionHelperService { get; }
    public ServiceCache(IProject project);
    internal static ServiceCache get_Current();
    public IAnnotationRepositoryReflectionService get_AnnotationRepositoryService();
    public IMethodUsageIndexReflectionService get_IndexUsageService();
    public ITypeHierarchyReflectionService get_TypeHierarchyService();
    public IMemberTypeIndexReflectionService get_MemberTypeIndexService();
    public IMethodBodyService get_SyntaxReflectionService();
    public IReflectionHelperService get_ReflectionHelperService();
}
[ExtensionAttribute]
internal static class PostSharp.Extensibility.ServiceLocatorExtensions : object {
    [ExtensionAttribute]
internal static T GetServiceChecked(IProject project);
}
public enum PostSharp.Extensibility.SeverityType : Enum {
    public int value__;
    public static SeverityType Debug;
    public static SeverityType Verbose;
    public static SeverityType Info;
    public static SeverityType ImportantInfo;
    public static SeverityType CommandLine;
    public static SeverityType Warning;
    public static SeverityType Error;
    public static SeverityType Fatal;
    public static SeverityType None;
}
[AttributeUsageAttribute("1028")]
public class PostSharp.Extensibility.SuppressAnnotationValidationAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
public class PostSharp.Extensibility.SuppressWarningAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public string MessageId { get; private set; }
    public string Reason { get; public set; }
    public SuppressWarningAttribute(string messageId);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
private void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
}
internal class PostSharp.Extensibility.TargetFrameworkFamily : ValueType {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public static TargetFrameworkFamily NetFramework;
    public static TargetFrameworkFamily NetCore;
    public static TargetFrameworkFamily NETCoreApp;
    public static TargetFrameworkFamily NetPortable;
    public static TargetFrameworkFamily NetStandard;
    public static TargetFrameworkFamily Silverlight;
    public static TargetFrameworkFamily Xamarin_iOS;
    public static TargetFrameworkFamily MonoAndroid;
    public static TargetFrameworkFamily MonoTouch;
    public static TargetFrameworkFamily WindowsPhone;
    public string Value { get; }
    public bool IsNull { get; }
    internal TargetFrameworkFamily(string value);
    private static TargetFrameworkFamily();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Value();
    public virtual int GetHashCode();
    public bool get_IsNull();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TargetFrameworkFamily other);
    public bool Equals(string other);
    public static bool op_Equality(TargetFrameworkFamily x, TargetFrameworkFamily y);
    public static bool op_Inequality(TargetFrameworkFamily x, TargetFrameworkFamily y);
}
internal class PostSharp.Extensibility.VerbatimMessageLocation : object {
    [CompilerGeneratedAttribute]
private object <CodeElement>k__BackingField;
    public object CodeElement { get; }
    public VerbatimMessageLocation(object codeElement);
    [CompilerGeneratedAttribute]
public object get_CodeElement();
}
public static class PostSharp.Post : object {
    public static bool IsTransformed { get; }
    public static TTarget Cast(TSource o);
    public static bool get_IsTransformed();
    public static T& GetMutableRef(T& reference);
    public static T GetValue(T value);
}
public enum PostSharp.Reflection.AssemblyProcessorArchitecture : Enum {
    public int value__;
    public static AssemblyProcessorArchitecture None;
    public static AssemblyProcessorArchitecture MSIL;
    public static AssemblyProcessorArchitecture X86;
    public static AssemblyProcessorArchitecture IA64;
    public static AssemblyProcessorArchitecture Amd64;
    public static AssemblyProcessorArchitecture Arm;
    public static AssemblyProcessorArchitecture Arm64;
    public static AssemblyProcessorArchitecture NoPlatform;
}
[ExplicitCrossPackageInternalAttribute]
internal static class PostSharp.Reflection.BindingFlagsSet : object {
    public static BindingFlags AllMembers;
    public static BindingFlags AllInstanceDeclared;
    public static BindingFlags PublicInstanceDeclared;
    public static BindingFlags PublicInstance;
    public static BindingFlags AllInstance;
}
public enum PostSharp.Reflection.CodeReferenceKind : Enum {
    public int value__;
    public static CodeReferenceKind None;
    public static CodeReferenceKind TypeInheritance;
    public static CodeReferenceKind MemberType;
    public static CodeReferenceKind MethodUsage;
}
public class PostSharp.Reflection.CustomAttributeInstance : object {
    private ObjectConstruction customAttributeData;
    private Attribute customAttributeObject;
    [CompilerGeneratedAttribute]
private object <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Annotation>k__BackingField;
    public ObjectConstruction Construction { get; }
    public Attribute Attribute { get; }
    public object Target { get; private set; }
    internal object Annotation { get; private set; }
    internal CustomAttributeInstance(object target, object annotation);
    public ObjectConstruction get_Construction();
    public Attribute get_Attribute();
    [CompilerGeneratedAttribute]
public object get_Target();
    [CompilerGeneratedAttribute]
private void set_Target(object value);
    [CompilerGeneratedAttribute]
internal object get_Annotation();
    [CompilerGeneratedAttribute]
private void set_Annotation(object value);
}
public class PostSharp.Reflection.CustomReflectionBinder : Binder {
    public static CustomReflectionBinder Instance;
    private static CustomReflectionBinder();
    public virtual FieldInfo BindToField(BindingFlags bindingFlags, FieldInfo[] match, object value, CultureInfo culture);
    public virtual MethodBase BindToMethod(BindingFlags bindingFlags, MethodBase[] match, Object[]& args, ParameterModifier[] modifiers, CultureInfo culture, String[] names, Object& state);
    public virtual object ChangeType(object value, Type type, CultureInfo culture);
    public virtual void ReorderArgumentArray(Object[]& args, object state);
    public virtual MethodBase SelectMethod(BindingFlags bindingFlags, MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo SelectProperty(BindingFlags bindingFlags, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers);
}
[FlagsAttribute]
internal enum PostSharp.Reflection.DeclarationFlags : Enum {
    public int value__;
    public static DeclarationFlags None;
    public static DeclarationFlags CompilerGenerated;
    public static DeclarationFlags NonSelectable;
}
public class PostSharp.Reflection.DeclarationIdentifier : ValueType {
    private ulong value;
    private static int assemblyIdShift;
    private static int typeIndexShift;
    private static int typeIndexMask;
    private static int memberIndexMask;
    public static int MaxTypeIndex;
    public static int MaxMemberIndex;
    public static DeclarationIdentifier Null { get; }
    internal long Value { get; }
    public bool IsNull { get; }
    public int MemberIndex { get; }
    public int TypeIndex { get; }
    public int AssemblyId { get; }
    [InternalAttribute]
[DebuggerStepThroughAttribute]
public DeclarationIdentifier(long value);
    internal DeclarationIdentifier(int assemblyId, int typeIndex, int memberIndex);
    public static DeclarationIdentifier get_Null();
    internal long get_Value();
    public bool get_IsNull();
    public int get_MemberIndex();
    public int get_TypeIndex();
    public int get_AssemblyId();
    public DeclarationIdentifier GetDeclaringTypeIdentifier();
    public static DeclarationIdentifier GetDeclarationIdentifier(MemberInfo declaration);
    public sealed virtual bool Equals(DeclarationIdentifier other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(DeclarationIdentifier left, DeclarationIdentifier right);
    public static bool op_Inequality(DeclarationIdentifier left, DeclarationIdentifier right);
}
internal interface PostSharp.Reflection.IAnnotationRepositoryReflectionService {
    public abstract virtual CustomAttributeInstance[] GetCustomAttributesOfType(Type annotationType, ReflectionSearchOptions options);
    public abstract virtual CustomAttributeInstance[] GetCustomAttributesOnTarget(object target);
    public abstract virtual ObjectConstruction CreateCustomAttributeData(CustomAttributeInstance customAttributeInstance);
    public abstract virtual Attribute CreateCustomAttributeObject(CustomAttributeInstance customAttributeInstance);
}
[InternalImplementAttribute]
public interface PostSharp.Reflection.IAssemblyName {
    public string Name { get; }
    public Version Version { get; }
    public string Culture { get; }
    public bool IsStronglyNamed { get; }
    public bool IsRetargetable { get; }
    public AssemblyProcessorArchitecture ProcessorArchitecture { get; }
    public BindingContext BindingContext { get; }
    public abstract virtual string get_Name();
    public abstract virtual Version get_Version();
    public abstract virtual Byte[] GetPublicKey();
    public abstract virtual Byte[] GetPublicKeyToken();
    public abstract virtual string get_Culture();
    public abstract virtual bool get_IsStronglyNamed();
    public abstract virtual bool get_IsRetargetable();
    public abstract virtual AssemblyProcessorArchitecture get_ProcessorArchitecture();
    public abstract virtual BindingContext get_BindingContext();
}
public interface PostSharp.Reflection.ICodeReference {
    public object ReferencingDeclaration { get; }
    public object ReferencedDeclaration { get; }
    public CodeReferenceKind ReferenceKind { get; }
    public abstract virtual object get_ReferencingDeclaration();
    public abstract virtual object get_ReferencedDeclaration();
    public abstract virtual CodeReferenceKind get_ReferenceKind();
}
internal interface PostSharp.Reflection.IMemberTypeIndexReflectionService {
    public abstract virtual MemberTypeCodeReference[] GetMembersOfType(Type type, ReflectionSearchOptions options);
}
public interface PostSharp.Reflection.IMetadataDispenser {
    public abstract virtual object GetMetadata(int index);
}
public interface PostSharp.Reflection.IMetadataEmitter {
    public abstract virtual int GetMetadataIndex(object metadata);
}
internal interface PostSharp.Reflection.IMethodUsageIndexReflectionService {
    public abstract virtual MethodUsageCodeReference[] GetMembersUsedByMethod(MethodBase method);
    public abstract virtual MethodUsageCodeReference[] GetMethodsUsingMember(MemberInfo member);
}
internal interface PostSharp.Reflection.IReflectionHelperService {
    public abstract virtual bool IsAvailableInTargetFramework(MemberInfo memberInfo);
    public abstract virtual bool IsAvailableInTargetFramework(Type type);
    public abstract virtual StateMachineKind GetStateMachineKind(MethodInfo method);
    public abstract virtual MethodInfo GetStateMachinePublicMethod(MethodInfo method);
    public abstract virtual AssemblyName GetAssemblyName(Assembly assembly);
    public abstract virtual bool AssemblyReferenceMatchesDefinition(AssemblyName reference, AssemblyName definition);
    public abstract virtual bool AssemblyReferenceMatchesDefinition(AssemblyName reference, Assembly definition);
    public abstract virtual DeclarationIdentifier GetDeclarationIdentifier(MemberInfo memberInfo);
    public abstract virtual bool IsCompilerGenerated(MemberInfo memberInfo);
    public abstract virtual bool IsCompilerGenerated(Type type);
    public abstract virtual FieldInfo GetBackingField(PropertyInfo propertyInfo);
    public abstract virtual string GetAutomaticPropertyName(string fieldName);
    public abstract virtual SemanticInfo GetSemanticInfo(MemberInfo member);
    public abstract virtual SemanticInfo GetSemanticInfo(Type member);
}
[InternalImplementAttribute]
public interface PostSharp.Reflection.ISourceDocument {
    public string FileName { get; }
    public Guid Language { get; }
    public abstract virtual string get_FileName();
    public abstract virtual Guid get_Language();
}
internal interface PostSharp.Reflection.ITypeHierarchyReflectionService {
    public abstract virtual TypeInheritanceCodeReference[] GetDerivedTypes(Type baseType, ReflectionSearchOptions options);
}
internal interface PostSharp.Reflection.ITypeWrapper {
    public abstract virtual TypeCode GetTypeCode();
    public abstract virtual bool IsAssignableFrom(Type type);
    public abstract virtual bool IsAssignableTo(Type type);
}
[DebuggerNonUserCodeAttribute]
public class PostSharp.Reflection.LocationInfo : object {
    private object location;
    private MethodInfo getter;
    private MethodInfo setter;
    [CompilerGeneratedAttribute]
private Type <LocationType>k__BackingField;
    [CompilerGeneratedAttribute]
private LocationKind <LocationKind>k__BackingField;
    internal object UnderlyingReflectionObject { get; }
    public Type LocationType { get; private set; }
    public LocationKind LocationKind { get; private set; }
    public PropertyInfo PropertyInfo { get; }
    public FieldInfo FieldInfo { get; }
    public ParameterInfo ParameterInfo { get; }
    public MemberInfo MemberInfo { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public bool IsStatic { get; }
    public LocationInfo(FieldInfo fieldInfo);
    public LocationInfo(PropertyInfo propertyInfo);
    public LocationInfo(ParameterInfo parameterInfo);
    internal LocationInfo(MethodInfo getter, MethodInfo setter);
    private LocationInfo(SerializationInfo serializationInfo, StreamingContext context);
    internal object get_UnderlyingReflectionObject();
    public static LocationInfo ToLocationInfo(object reflectionInfo);
    public static LocationInfo[] ToLocationInfoArray(ICollection`1<FieldInfo> fields);
    public static LocationInfo[] ToLocationInfoArray(ICollection`1<PropertyInfo> properties);
    public static LocationInfo[] ToLocationInfoArray(ICollection`1<ParameterInfo> parameters);
    [CompilerGeneratedAttribute]
public Type get_LocationType();
    [CompilerGeneratedAttribute]
private void set_LocationType(Type value);
    [CompilerGeneratedAttribute]
public LocationKind get_LocationKind();
    [CompilerGeneratedAttribute]
private void set_LocationKind(LocationKind value);
    public PropertyInfo get_PropertyInfo();
    public FieldInfo get_FieldInfo();
    public ParameterInfo get_ParameterInfo();
    public MemberInfo get_MemberInfo();
    public Type get_DeclaringType();
    public string get_Name();
    public bool get_IsStatic();
    public object GetValue(object instance);
    public object GetValue(object instance, Object[] index);
    public void SetValue(object instance, object value);
    public void SetValue(object instance, object value, Object[] index);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual bool Equals(LocationInfo other);
    public static bool op_Equality(LocationInfo left, LocationInfo right);
    public static bool op_Inequality(LocationInfo left, LocationInfo right);
}
public enum PostSharp.Reflection.LocationKind : Enum {
    public int value__;
    public static LocationKind Field;
    public static LocationKind Property;
    public static LocationKind Parameter;
    public static LocationKind ReturnValue;
}
public class PostSharp.Reflection.MemberTypeCodeReference : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Member>k__BackingField;
    public Type Type { get; private set; }
    public object Member { get; private set; }
    private object PostSharp.Reflection.ICodeReference.ReferencingDeclaration { get; }
    private object PostSharp.Reflection.ICodeReference.ReferencedDeclaration { get; }
    private CodeReferenceKind PostSharp.Reflection.ICodeReference.ReferenceKind { get; }
    internal MemberTypeCodeReference(Type type, object member);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    [CompilerGeneratedAttribute]
public object get_Member();
    [CompilerGeneratedAttribute]
private void set_Member(object value);
    private sealed virtual override object PostSharp.Reflection.ICodeReference.get_ReferencingDeclaration();
    private sealed virtual override object PostSharp.Reflection.ICodeReference.get_ReferencedDeclaration();
    private sealed virtual override CodeReferenceKind PostSharp.Reflection.ICodeReference.get_ReferenceKind();
}
public enum PostSharp.Reflection.MethodBody.AddressAlignment : Enum {
    public int value__;
    public static AddressAlignment Default;
    public static AddressAlignment Unaligned1;
    public static AddressAlignment Unaligned2;
    public static AddressAlignment Unaligned4;
}
public enum PostSharp.Reflection.MethodBody.ExceptionHandlerKind : Enum {
    public int value__;
    public static ExceptionHandlerKind None;
    public static ExceptionHandlerKind Catch;
    public static ExceptionHandlerKind Filter;
    public static ExceptionHandlerKind Finally;
}
public interface PostSharp.Reflection.MethodBody.IAddressOfExpression {
    public bool IsReadOnly { get; }
    public abstract virtual bool get_IsReadOnly();
}
[ExperimentalAttribute]
public interface PostSharp.Reflection.MethodBody.IBinaryExpression {
    public IExpression Left { get; }
    public IExpression Right { get; }
    public abstract virtual IExpression get_Left();
    public abstract virtual IExpression get_Right();
}
public interface PostSharp.Reflection.MethodBody.IBlockExpression {
    public string Label { get; }
    public ExceptionHandlerKind ExceptionHandlerKind { get; }
    public IExceptionHandler ParentExceptionHandler { get; }
    public IReadOnlyLinkedList`1<IExpression> Items { get; }
    public IReadOnlyLinkedList`1<IExceptionHandler> ExceptionHandlers { get; }
    public IList`1<ILocalVariable> LocalVariables { get; }
    public abstract virtual string get_Label();
    public abstract virtual ExceptionHandlerKind get_ExceptionHandlerKind();
    public abstract virtual IExceptionHandler get_ParentExceptionHandler();
    public abstract virtual IReadOnlyLinkedList`1<IExpression> get_Items();
    public abstract virtual IReadOnlyLinkedList`1<IExceptionHandler> get_ExceptionHandlers();
    public abstract virtual IList`1<ILocalVariable> get_LocalVariables();
}
public interface PostSharp.Reflection.MethodBody.IConditionalExpression {
    public IExpression Condition { get; }
    public IExpression IfTrue { get; }
    public IExpression IfFalse { get; }
    public abstract virtual IExpression get_Condition();
    public abstract virtual IExpression get_IfTrue();
    public abstract virtual IExpression get_IfFalse();
}
public interface PostSharp.Reflection.MethodBody.IConstantExpression {
    public object Value { get; }
    public abstract virtual object get_Value();
}
public interface PostSharp.Reflection.MethodBody.ICopyBufferExpression {
    public IExpression Source { get; }
    public IExpression Destination { get; }
    public IExpression Length { get; }
    public bool IsVolatile { get; }
    public AddressAlignment Alignment { get; }
    public abstract virtual IExpression get_Source();
    public abstract virtual IExpression get_Destination();
    public abstract virtual IExpression get_Length();
    public abstract virtual bool get_IsVolatile();
    public abstract virtual AddressAlignment get_Alignment();
}
public interface PostSharp.Reflection.MethodBody.IExceptionHandler {
    public Type ExceptionType { get; }
    public IBlockExpression TryBlock { get; }
    public IBlockExpression FilterBlock { get; }
    public IBlockExpression HandlerBlock { get; }
    public ILocalVariable HandlerLocalVariable { get; }
    public ILocalVariable FilterLocalVariable { get; }
    public ExceptionHandlerKind ExceptionHandlerKind { get; }
    public abstract virtual Type get_ExceptionType();
    public abstract virtual IBlockExpression get_TryBlock();
    public abstract virtual IBlockExpression get_FilterBlock();
    public abstract virtual IBlockExpression get_HandlerBlock();
    public abstract virtual ILocalVariable get_HandlerLocalVariable();
    public abstract virtual ILocalVariable get_FilterLocalVariable();
    public abstract virtual ExceptionHandlerKind get_ExceptionHandlerKind();
}
public interface PostSharp.Reflection.MethodBody.IExpression {
    public Type ReturnType { get; }
    public abstract virtual Type get_ReturnType();
}
public interface PostSharp.Reflection.MethodBody.IFieldExpression {
    public IExpression Instance { get; }
    public FieldInfo Field { get; }
    public bool IsVolatile { get; }
    public AddressAlignment Alignment { get; }
    public abstract virtual IExpression get_Instance();
    public abstract virtual FieldInfo get_Field();
    public abstract virtual bool get_IsVolatile();
    public abstract virtual AddressAlignment get_Alignment();
}
public interface PostSharp.Reflection.MethodBody.IGotoExpression {
    public IBlockExpression Target { get; }
    public abstract virtual IBlockExpression get_Target();
}
public interface PostSharp.Reflection.MethodBody.IInitBufferExpression {
    public IExpression Buffer { get; }
    public IExpression Length { get; }
    public bool IsVolatile { get; }
    public AddressAlignment Alignment { get; }
    public abstract virtual IExpression get_Buffer();
    public abstract virtual IExpression get_Length();
    public abstract virtual bool get_IsVolatile();
    public abstract virtual AddressAlignment get_Alignment();
}
public interface PostSharp.Reflection.MethodBody.ILocalVariable {
    public string Name { get; }
    public Type VariableType { get; }
    public Nullable`1<int> Slot { get; }
    public abstract virtual string get_Name();
    public abstract virtual Type get_VariableType();
    public abstract virtual Nullable`1<int> get_Slot();
}
public interface PostSharp.Reflection.MethodBody.ILocalVariableExpression {
    public ILocalVariable LocalVariable { get; }
    public IExpression TrivialValue { get; }
    public abstract virtual ILocalVariable get_LocalVariable();
    public abstract virtual IExpression get_TrivialValue();
    public abstract virtual IList`1<IExpression> GetPossibleAssignments();
}
public interface PostSharp.Reflection.MethodBody.IMetadataExpression {
    public MemberInfo Declaration { get; }
    public abstract virtual MemberInfo get_Declaration();
}
public interface PostSharp.Reflection.MethodBody.IMethodBody {
    public MethodBase Method { get; }
    public IBlockExpression RootBlock { get; }
    public abstract virtual MethodBase get_Method();
    public abstract virtual IBlockExpression get_RootBlock();
}
[InternalImplementAttribute]
public interface PostSharp.Reflection.MethodBody.IMethodBodyElement {
    public IMethodBody ParentMethodBody { get; }
    public IMethodBodyElement ParentElement { get; }
    public MethodBodyElementKind MethodBodyElementKind { get; }
    public abstract virtual IMethodBody get_ParentMethodBody();
    public abstract virtual IMethodBodyElement get_ParentElement();
    public abstract virtual MethodBodyElementKind get_MethodBodyElementKind();
}
public interface PostSharp.Reflection.MethodBody.IMethodBodyService {
    public abstract virtual IMethodBody GetMethodBody(MethodBase method, MethodBodyAbstractionLevel abstractionLevel);
}
public interface PostSharp.Reflection.MethodBody.IMethodCallExpression {
    public IExpression Instance { get; }
    public MethodBase Method { get; }
    public IList`1<IExpression> Arguments { get; }
    public bool IsVirtual { get; }
    public bool IsTail { get; }
    public Type ConstrainedType { get; }
    public abstract virtual IExpression get_Instance();
    public abstract virtual MethodBase get_Method();
    public abstract virtual IList`1<IExpression> get_Arguments();
    public abstract virtual bool get_IsVirtual();
    public abstract virtual bool get_IsTail();
    public abstract virtual Type get_ConstrainedType();
}
public interface PostSharp.Reflection.MethodBody.IMethodPointerExpression {
    public IExpression Instance { get; }
    public MethodBase Method { get; }
    public abstract virtual IExpression get_Instance();
    public abstract virtual MethodBase get_Method();
}
internal class PostSharp.Reflection.MethodBody.IndentedTextWriter : TextWriter {
    private TextWriter underlying;
    private bool newLine;
    [CompilerGeneratedAttribute]
private int <Indent>k__BackingField;
    public int Indent { get; public set; }
    public Encoding Encoding { get; }
    public IndentedTextWriter(TextWriter underlying);
    [CompilerGeneratedAttribute]
public int get_Indent();
    [CompilerGeneratedAttribute]
public void set_Indent(int value);
    public virtual void WriteLine(string value);
    public virtual void Write(char value);
    public virtual void Write(string value);
    private void WriteIndentationIfRequired();
    public virtual Encoding get_Encoding();
}
public interface PostSharp.Reflection.MethodBody.INewArrayExpression {
    public IExpression Length { get; }
    public Type ElementType { get; }
    public abstract virtual IExpression get_Length();
    public abstract virtual Type get_ElementType();
}
public interface PostSharp.Reflection.MethodBody.INewObjectExpression {
    public ConstructorInfo Constructor { get; }
    public IList`1<IExpression> Arguments { get; }
    public abstract virtual ConstructorInfo get_Constructor();
    public abstract virtual IList`1<IExpression> get_Arguments();
}
public interface PostSharp.Reflection.MethodBody.IParameterExpression {
    public ParameterInfo Parameter { get; }
    public abstract virtual ParameterInfo get_Parameter();
}
public interface PostSharp.Reflection.MethodBody.ISequenceExpression {
    public ReadOnlySinglyLinkedList`1<ISequenceExpression> Predecessors { get; }
    public ReadOnlySinglyLinkedList`1<ISequenceExpression> Successors { get; }
    public ReadOnlySinglyLinkedList`1<LocalVariableAssignment> LocalVariableAssignments { get; }
    public abstract virtual ReadOnlySinglyLinkedList`1<ISequenceExpression> get_Predecessors();
    public abstract virtual ReadOnlySinglyLinkedList`1<ISequenceExpression> get_Successors();
    public abstract virtual ReadOnlySinglyLinkedList`1<LocalVariableAssignment> get_LocalVariableAssignments();
}
public interface PostSharp.Reflection.MethodBody.IStatementExpression {
    public IStatementExpression PreviousSibling { get; }
    public IStatementExpression NextSibling { get; }
    public IExpression Expression { get; }
    public abstract virtual IStatementExpression get_PreviousSibling();
    public abstract virtual IStatementExpression get_NextSibling();
    public abstract virtual IExpression get_Expression();
}
public interface PostSharp.Reflection.MethodBody.ISwitchExpression {
    public IExpression Condition { get; }
    public IList`1<IExpression> Targets { get; }
    public abstract virtual IExpression get_Condition();
    public abstract virtual IList`1<IExpression> get_Targets();
}
public interface PostSharp.Reflection.MethodBody.IUnaryExpression {
    public IExpression Value { get; }
    public abstract virtual IExpression get_Value();
}
public interface PostSharp.Reflection.MethodBody.IValueOfExpression {
    public bool IsVolatile { get; }
    public AddressAlignment Alignment { get; }
    public abstract virtual bool get_IsVolatile();
    public abstract virtual AddressAlignment get_Alignment();
}
public interface PostSharp.Reflection.MethodBody.IZeroaryExpression {
}
public class PostSharp.Reflection.MethodBody.LocalVariableAssignment : ValueType {
    [CompilerGeneratedAttribute]
private ILocalVariable <LocalVariable>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpression <Expression>k__BackingField;
    public ILocalVariable LocalVariable { get; private set; }
    public IExpression Expression { get; private set; }
    internal LocalVariableAssignment(ILocalVariable localVariable, IExpression expression);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ILocalVariable get_LocalVariable();
    [CompilerGeneratedAttribute]
private void set_LocalVariable(ILocalVariable value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IExpression get_Expression();
    [CompilerGeneratedAttribute]
private void set_Expression(IExpression value);
}
public enum PostSharp.Reflection.MethodBody.MethodBodyAbstractionLevel : Enum {
    public int value__;
    public static MethodBodyAbstractionLevel Structure;
    public static MethodBodyAbstractionLevel ExpressionTree;
}
public enum PostSharp.Reflection.MethodBody.MethodBodyElementKind : Enum {
    public int value__;
    public static MethodBodyElementKind Add;
    public static MethodBodyElementKind AddChecked;
    public static MethodBodyElementKind And;
    public static MethodBodyElementKind ArrayIndex;
    public static MethodBodyElementKind ArrayLength;
    public static MethodBodyElementKind Assign;
    public static MethodBodyElementKind Goto;
    public static MethodBodyElementKind Variable;
    public static MethodBodyElementKind Conditional;
    public static MethodBodyElementKind Cast;
    public static MethodBodyElementKind Divide;
    public static MethodBodyElementKind LessThan;
    public static MethodBodyElementKind LessThanOrEqual;
    public static MethodBodyElementKind Modulo;
    public static MethodBodyElementKind MultiplyChecked;
    public static MethodBodyElementKind Multiply;
    public static MethodBodyElementKind GreaterThan;
    public static MethodBodyElementKind GreaterThanOrEqual;
    public static MethodBodyElementKind Substract;
    public static MethodBodyElementKind SubstractChecked;
    public static MethodBodyElementKind Parameter;
    public static MethodBodyElementKind This;
    public static MethodBodyElementKind AddressOf;
    public static MethodBodyElementKind Constant;
    public static MethodBodyElementKind Equal;
    public static MethodBodyElementKind Not;
    public static MethodBodyElementKind Different;
    public static MethodBodyElementKind ValueOf;
    public static MethodBodyElementKind Or;
    public static MethodBodyElementKind Xor;
    public static MethodBodyElementKind ShiftLeft;
    public static MethodBodyElementKind ShiftRight;
    public static MethodBodyElementKind Negate;
    public static MethodBodyElementKind SafeCast;
    public static MethodBodyElementKind Unbox;
    public static MethodBodyElementKind Throw;
    public static MethodBodyElementKind Field;
    public static MethodBodyElementKind Box;
    public static MethodBodyElementKind NewArray;
    public static MethodBodyElementKind TypedReferenceValue;
    public static MethodBodyElementKind CheckFinite;
    public static MethodBodyElementKind MakeTypedReference;
    public static MethodBodyElementKind ArgumentList;
    public static MethodBodyElementKind MethodPointer;
    public static MethodBodyElementKind LocalAlloc;
    public static MethodBodyElementKind DefaultValue;
    public static MethodBodyElementKind CopyBuffer;
    public static MethodBodyElementKind InitBuffer;
    public static MethodBodyElementKind LoadToken;
    public static MethodBodyElementKind SizeOf;
    public static MethodBodyElementKind TypedReferenceType;
    public static MethodBodyElementKind ConvertChecked;
    public static MethodBodyElementKind Convert;
    public static MethodBodyElementKind MethodCall;
    public static MethodBodyElementKind Return;
    public static MethodBodyElementKind NewObject;
    public static MethodBodyElementKind Switch;
    public static MethodBodyElementKind Block;
    public static MethodBodyElementKind MethodBody;
    public static MethodBodyElementKind LocalVariableDefinition;
    public static MethodBodyElementKind Statement;
    public static MethodBodyElementKind Rethrow;
}
public class PostSharp.Reflection.MethodBody.MethodBodyFormatter : MethodBodyVisitor {
    private IndentedTextWriter writer;
    public MethodBodyFormatter(TextWriter writer);
    public virtual object VisitBlockExpression(IBlockExpression instructionBlock);
    public virtual object VisitSwitchExpression(ISwitchExpression expression);
    public virtual object VisitZeroaryExpression(IZeroaryExpression expression);
    public virtual object VisitParameterExpression(IParameterExpression expression);
    public virtual object VisitNewArrayExpression(INewArrayExpression expression);
    public virtual object VisitMethodCallExpression(IMethodCallExpression expression);
    public virtual object VisitMetadataExpression(IMetadataExpression expression);
    public virtual object VisitVariableExpression(ILocalVariableExpression expression);
    public virtual object VisitInitBufferExpression(IInitBufferExpression expression);
    public virtual object VisitGotoExpression(IGotoExpression expression);
    public virtual object VisitFieldExpression(IFieldExpression expression);
    public virtual object VisitBinaryExpression(IBinaryExpression expression);
    public virtual object VisitUnaryExpression(IUnaryExpression expression);
    public virtual object VisitConditionalExpression(IConditionalExpression expression);
    public virtual object VisitConstantExpression(IConstantExpression expression);
    public virtual object VisitCopyBufferExpression(ICopyBufferExpression expression);
}
public abstract class PostSharp.Reflection.MethodBody.MethodBodyVisitor : object {
    public virtual object VisitMethodBody(IMethodBody methodBody);
    public virtual object VisitBlockExpression(IBlockExpression instructionBlock);
    public virtual object VisitStatementExpression(IStatementExpression statementExpression);
    public virtual object VisitSyntaxElement(IMethodBodyElement syntaxElement);
    public virtual object VisitAddressOfExpression(IAddressOfExpression expression);
    public virtual object VisitValueOfExpression(IValueOfExpression expression);
    public virtual object VisitLocalVariable(ILocalVariable localVariable);
    public virtual object VisitSwitchExpression(ISwitchExpression expression);
    public virtual object VisitZeroaryExpression(IZeroaryExpression expression);
    public virtual object VisitParameterExpression(IParameterExpression expression);
    public virtual object VisitNewArrayExpression(INewArrayExpression expression);
    public virtual object VisitMethodPointerExpression(IMethodPointerExpression expression);
    public virtual object VisitNewObjectExpression(INewObjectExpression expression);
    public virtual object VisitMethodCallExpression(IMethodCallExpression expression);
    public virtual object VisitMetadataExpression(IMetadataExpression expression);
    public virtual object VisitVariableExpression(ILocalVariableExpression expression);
    public virtual object VisitInitBufferExpression(IInitBufferExpression expression);
    public virtual object VisitGotoExpression(IGotoExpression expression);
    public virtual object VisitFieldExpression(IFieldExpression expression);
    public virtual object VisitBinaryExpression(IBinaryExpression expression);
    public virtual object VisitUnaryExpression(IUnaryExpression expression);
    public virtual object VisitConditionalExpression(IConditionalExpression expression);
    public virtual object VisitConstantExpression(IConstantExpression expression);
    public virtual object VisitCopyBufferExpression(ICopyBufferExpression expression);
}
public class PostSharp.Reflection.MethodUsageCodeReference : object {
    [CompilerGeneratedAttribute]
private MethodBase <UsingMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <UsedDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodUsageInstructions <Instructions>k__BackingField;
    public MethodBase UsingMethod { get; private set; }
    public MemberInfo UsedDeclaration { get; private set; }
    public Type UsedType { get; }
    public MethodUsageInstructions Instructions { get; private set; }
    private object PostSharp.Reflection.ICodeReference.ReferencingDeclaration { get; }
    private object PostSharp.Reflection.ICodeReference.ReferencedDeclaration { get; }
    private CodeReferenceKind PostSharp.Reflection.ICodeReference.ReferenceKind { get; }
    internal MethodUsageCodeReference(MethodBase usingMethod, MemberInfo usedMember, MethodUsageInstructions instructions);
    [CompilerGeneratedAttribute]
public MethodBase get_UsingMethod();
    [CompilerGeneratedAttribute]
private void set_UsingMethod(MethodBase value);
    [CompilerGeneratedAttribute]
public MemberInfo get_UsedDeclaration();
    [CompilerGeneratedAttribute]
private void set_UsedDeclaration(MemberInfo value);
    public Type get_UsedType();
    [CompilerGeneratedAttribute]
public MethodUsageInstructions get_Instructions();
    [CompilerGeneratedAttribute]
private void set_Instructions(MethodUsageInstructions value);
    private sealed virtual override object PostSharp.Reflection.ICodeReference.get_ReferencingDeclaration();
    private sealed virtual override object PostSharp.Reflection.ICodeReference.get_ReferencedDeclaration();
    private sealed virtual override CodeReferenceKind PostSharp.Reflection.ICodeReference.get_ReferenceKind();
}
[FlagsAttribute]
public enum PostSharp.Reflection.MethodUsageInstructions : Enum {
    public int value__;
    public static MethodUsageInstructions None;
    public static MethodUsageInstructions LoadField;
    public static MethodUsageInstructions StoreField;
    public static MethodUsageInstructions Call;
    public static MethodUsageInstructions CallVirtual;
    public static MethodUsageInstructions NewObject;
    public static MethodUsageInstructions LoadFieldAddress;
    public static MethodUsageInstructions LoadMetadata;
    public static MethodUsageInstructions LoadMethodAddress;
    public static MethodUsageInstructions LoadMethodAddressVirtual;
    public static MethodUsageInstructions Cast;
    public static MethodUsageInstructions IsInstance;
    public static MethodUsageInstructions SizeOf;
    public static MethodUsageInstructions NewArray;
}
internal class PostSharp.Reflection.ObfuscatedEventInfo : EventInfo {
    private static Object[] emptyArray;
    private MethodInfo addMethod;
    private MethodInfo removeMethod;
    private MethodInfo raiseMethod;
    private Type declaringType;
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public EventAttributes Attributes { get; }
    internal ObfuscatedEventInfo(Type declaringType, MethodInfo addMethod, MethodInfo removeMethod, MethodInfo raiseMethod);
    private static ObfuscatedEventInfo();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual MethodInfo GetAddMethod(bool nonPublic);
    public virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public virtual MethodInfo GetRaiseMethod(bool nonPublic);
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual EventAttributes get_Attributes();
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
}
internal class PostSharp.Reflection.ObfuscatedPropertyInfo : PropertyInfo {
    private Type declaringType;
    private MethodInfo getter;
    private MethodInfo setter;
    private static Object[] emptyArray;
    private static ParameterInfo[] emptyParameterInfoArray;
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public Type PropertyType { get; }
    public PropertyAttributes Attributes { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    internal ObfuscatedPropertyInfo(Type declaringType, MethodInfo getter, MethodInfo setter);
    private static ObfuscatedPropertyInfo();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual ParameterInfo[] GetIndexParameters();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Type get_PropertyType();
    public virtual PropertyAttributes get_Attributes();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
public class PostSharp.Reflection.ObjectConstruction : object {
    private static Object[] emptyArray;
    private string typeName;
    private ConstructorInfo constructor;
    private ReadOnlyCollection`1<object> constructorArguments;
    private NamedArgumentsCollection namedArguments;
    public string TypeName { get; }
    public ConstructorInfo Constructor { get; }
    public IList`1<object> ConstructorArguments { get; }
    public IDictionary`2<string, object> NamedArguments { get; }
    public ObjectConstruction(string typeName, Object[] constructorArguments);
    public ObjectConstruction(Type type, Object[] constructorArguments);
    public ObjectConstruction(ConstructorInfo constructor, Object[] constructorArguments);
    public ObjectConstruction(CustomAttributeData customAttributeData);
    private static ObjectConstruction();
    private static void VerifyValue(string name, Type type, object value);
    public string get_TypeName();
    public ConstructorInfo get_Constructor();
    public IList`1<object> get_ConstructorArguments();
    public IDictionary`2<string, object> get_NamedArguments();
}
public enum PostSharp.Reflection.ParameterKind : Enum {
    public byte value__;
    public static ParameterKind InValue;
    public static ParameterKind ByRefIn;
    public static ParameterKind ByRefOut;
    public static ParameterKind ByRefInOut;
    public static ParameterKind ReturnValue;
    public static ParameterKind ReturnRef;
}
[ExtensionAttribute]
public static class PostSharp.Reflection.ParameterKindExtensions : object {
    [ExtensionAttribute]
public static bool IsInputParameter(ParameterKind parameterKind);
    [ExtensionAttribute]
public static bool IsOutputParameter(ParameterKind parameterKind);
    [ExtensionAttribute]
public static bool IsReturn(ParameterKind parameterKind);
    [ExtensionAttribute]
public static bool IsByRefParameter(ParameterKind parameterKind);
    [ExtensionAttribute]
public static bool IsParameter(ParameterKind parameterKind);
}
[ExtensionAttribute]
[ExplicitCrossPackageInternalAttribute]
internal static class PostSharp.Reflection.ReflectionApiWrapper : object {
    public static Type[] EmptyTypes;
    private static ReflectionApiWrapper();
    [ExtensionAttribute]
public static PropertyInfo GetProperty(Type type, string propertyName, BindingFlags flags, Type returnType, Type[] parameterTypes);
    [ExtensionAttribute]
public static MethodInfo GetMethod(Type type, string methodName, Type[] parameterTypes, BindingFlags flags);
    [ExtensionAttribute]
public static Assembly GetAssembly(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static bool IsStruct(Type type);
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
public static bool IsGenericTypeDefinition(Type type);
    [ExtensionAttribute]
public static bool IsGenericParameter(Type type);
    [ExtensionAttribute]
public static bool ContainsGenericParameters(Type type);
    [ExtensionAttribute]
public static bool IsSealed(Type type);
    [ExtensionAttribute]
public static bool IsPrimitive(Type type);
    [ExtensionAttribute]
public static bool IsInterface(Type type);
    [ExtensionAttribute]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
public static Type GetBaseType(Type type);
    [ExtensionAttribute]
public static TypeCode GetTypeCode(Type type);
    [ExtensionAttribute]
public static Type GetTypeInfo(Type type);
    [ExtensionAttribute]
public static string FullName(MemberInfo memberInfo);
    [ExtensionAttribute]
public static string FullName(Type type);
    [ExtensionAttribute]
public static bool IsEventAccessor(MethodInfo methodInfo);
    [ExtensionAttribute]
public static bool IsPropertyAccessor(MethodInfo methodInfo);
    [ExtensionAttribute]
public static bool IsPropertyGetter(MethodInfo methodInfo);
    [ExtensionAttribute]
public static bool IsPropertySetter(MethodInfo methodInfo);
    [ExtensionAttribute]
public static bool IsInterfaceMethod(MethodInfo methodInfo);
    [ExtensionAttribute]
public static bool IsAsyncMethod(MethodInfo methodInfo);
    [ExtensionAttribute]
public static PropertyInfo GetAccessorProperty(MethodInfo methodInfo);
    [ExtensionAttribute]
public static PropertyInfo GetAccessorProperty(MethodInfo methodInfo, bool inherit);
    public static bool HasCustomAttribute(MemberInfo memberInfo, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static Type GetTypeDefinition(Type type);
    [ExtensionAttribute]
public static bool IsSubclassOf(Type type, Type baseType);
    [ExtensionAttribute]
public static bool ImplementsInterface(Type type, Type interfaceType);
    [ExtensionAttribute]
public static TypeAttributes GetAttributes(Type type);
    [ExtensionAttribute]
public static MethodInfo GetMethodInfo(Delegate d);
    [ExtensionAttribute]
public static Type AsType(MemberInfo memberInfo);
    public static Assembly LoadAssembly(string assemblyName);
    [ExtensionAttribute]
public static MethodBase GetDeclaringMethod(Type type);
    [ExtensionAttribute]
public static Type GetAttributeType(CustomAttributeData attribute);
}
[ExtensionAttribute]
public static class PostSharp.Reflection.ReflectionExtensions : object {
    [ExtensionAttribute]
public static PropertyInfo GetAutomaticProperty(FieldInfo field);
    internal static string GetAutomaticPropertyName(string fieldName);
    [ExtensionAttribute]
public static PropertyInfo GetAutomaticProperty(FieldInfo field, bool inherit);
    [ExtensionAttribute]
public static bool IsAutomaticProperty(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static FieldInfo GetBackingField(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static StateMachineKind GetStateMachineKind(MethodInfo method);
    [ExtensionAttribute]
public static MethodInfo GetStateMachinePublicMethod(MethodInfo method);
}
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
public static class PostSharp.Reflection.ReflectionHelper : object {
    private static Dictionary`2<AssemblyPair, bool> areInternalsVisibleToCache;
    private static PropertyInfo _isFunctionPointerProperty;
    private static ReflectionHelper();
    internal static IReflectionHelperService GetReflectionHelperService();
    private static MissingMemberException CreateMissingMemberException(Type declaringType, string memberName, string memberType);
    internal static MethodBase GetMethod(Type declaringType, string methodName, string methodSignature);
    private static string GetPropertyName(MethodInfo method);
    [InternalAttribute]
public static PropertyInfo GetProperty(Type declaringType, MethodInfo getter, MethodInfo setter);
    private static string GetShortMemberName(string fullName);
    [InternalAttribute]
public static PropertyInfo GetProperty(Type declaringType, MethodInfo getter, MethodInfo setter, bool throwOnMissingMember);
    [InternalAttribute]
public static EventInfo GetEvent(Type declaringType, MethodInfo addMethod, MethodInfo removeMethod, MethodInfo raiseMethod);
    internal static PropertyInfo GetProperty(Type declaringType, string propertyName, string propertySignature);
    internal static FieldInfo GetField(Type declaringType, string fieldName);
    internal static LocationInfo GetLocation(Type declaringType, string locationName, string locationSignature, LocationKind locationKind);
    [InternalAttribute]
public static LocationInfo GetLocation(Type declaringType, MethodInfo getter, MethodInfo setter);
    internal static string GetReflectionObjectKindName(object obj);
    internal static string GetReflectionObjectName(object obj);
    [ExtensionAttribute]
public static bool IsAvailableInTargetFramework(MemberInfo memberInfo);
    [ExtensionAttribute]
public static bool IsAvailableInTargetFramework(Type type);
    internal static bool IsOnlyFamilyVisible(MemberInfo member);
    internal static bool IsOnlyFamilyVisible(FieldInfo field);
    internal static bool IsOnlyFamilyVisible(MethodBase method);
    internal static bool IsOnlyFamilyVisible(Type type);
    internal static bool IsExported(MemberInfo member);
    internal static bool IsExported(FieldInfo field);
    internal static bool IsExported(MethodBase method);
    internal static bool IsExported(PropertyInfo property);
    internal static bool IsExported(EventInfo event);
    internal static bool IsExported(Type type);
    internal static bool IsPublic(Type type);
    internal static Assembly GetDeclaringAssembly(object obj);
    internal static Type GetDeclaringType(object obj);
    internal static void GetMemberInfo(object obj, Type& declaringType, MemberInfo& declaringMember);
    internal static Type GetNestingType(Type type);
    internal static TypeCode GetTypeCode(Type type);
    internal static bool SafeIsAssignableFrom(Type baseType, Type derivedType);
    private static ReflectionObjectKind GetReflectionObjectKind(object obj);
    internal static void VisitTypeElements(Type type, Action`1<Type> visitor);
    internal static DeclarationIdentifier GetDeclarationIdentifier(MemberInfo member);
    [ExtensionAttribute]
public static bool IsCompilerGenerated(MemberInfo member);
    [ExtensionAttribute]
public static bool IsCompilerGenerated(Type type);
    [ExtensionAttribute]
internal static bool IsFunctionPointer(Type type);
    [ExtensionAttribute]
public static SemanticInfo GetSemanticInfo(MemberInfo member);
    [ExtensionAttribute]
public static SemanticInfo GetSemanticInfo(Type type);
    [ExtensionAttribute]
public static bool AreInternalsVisibleToCurrentProject(Assembly definingAssembly);
    [ExtensionAttribute]
public static bool AreInternalsVisibleTo(Assembly definingAssembly, Assembly referencingAssembly);
    public static string GetAssemblyQualifiedTypeName(string typeName, string assemblyName);
    public static void ParseAssemblyQualifiedTypeName(string assemblyQualifiedTypeName, String& typeName, String& assemblyName);
    [ExtensionAttribute]
internal static bool CanInternalsBeReferenced(Assembly assembly);
    private static string Unescape(string input);
    private static int IndexOfUnescapedComma(string typeName, Boolean& isEscaped);
}
internal enum PostSharp.Reflection.ReflectionObjectKind : Enum {
    public int value__;
    public static ReflectionObjectKind None;
    public static ReflectionObjectKind Type;
    public static ReflectionObjectKind Constructor;
    public static ReflectionObjectKind Method;
    public static ReflectionObjectKind Property;
    public static ReflectionObjectKind Event;
    public static ReflectionObjectKind Field;
    public static ReflectionObjectKind Parameter;
    public static ReflectionObjectKind ReturnValue;
}
public static class PostSharp.Reflection.ReflectionSearch : object {
    public static CustomAttributeInstance[] GetCustomAttributesOfType(Type customAttributeType);
    public static CustomAttributeInstance[] GetCustomAttributesOfType(Type customAttributeType, ReflectionSearchOptions options);
    public static CustomAttributeInstance[] GetCustomAttributesOnTarget(object target);
    public static CustomAttributeInstance[] GetCustomAttributesOnTarget(object target, ReflectionSearchOptions options);
    public static IList`1<T> GetCustomAttributesOnTarget(object target, ReflectionSearchOptions options);
    public static bool HasCustomAttribute(object target, Type type, bool inherit);
    public static MethodUsageCodeReference[] GetDeclarationsUsedByMethod(MethodBase method);
    public static MethodUsageCodeReference[] GetDeclarationsUsedByMethod(MethodBase method, ReflectionSearchOptions options);
    public static MethodUsageCodeReference[] GetMethodsUsingDeclaration(MemberInfo declaration);
    public static MethodUsageCodeReference[] GetMethodsUsingDeclaration(MemberInfo declaration, ReflectionSearchOptions options);
    public static TypeInheritanceCodeReference[] GetDerivedTypes(Type baseType);
    public static TypeInheritanceCodeReference[] GetDerivedTypes(Type baseType, ReflectionSearchOptions options);
    public static MemberTypeCodeReference[] GetMembersOfType(Type memberType);
    public static MemberTypeCodeReference[] GetMembersOfType(Type memberType, ReflectionSearchOptions options);
}
[FlagsAttribute]
public enum PostSharp.Reflection.ReflectionSearchOptions : Enum {
    public int value__;
    public static ReflectionSearchOptions None;
    public static ReflectionSearchOptions IncludeDerivedTypes;
    public static ReflectionSearchOptions IncludeTypeElement;
}
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
public class PostSharp.Reflection.ReflectionTypeComparer : object {
    private Type[] leftGenericTypeParameters;
    private Type[] leftGenericMethodParameters;
    private Type[] rightGenericTypeParameters;
    private Type[] rightGenericMethodParameters;
    private static ReflectionTypeComparer instance;
    private ReflectionTypeComparer(Type[] leftGenericTypeParameters, Type[] leftGenericMethodParameters, Type[] rightGenericTypeParameters, Type[] rightGenericMethodParameters);
    private static ReflectionTypeComparer();
    public static ReflectionTypeComparer GetInstance();
    public static ReflectionTypeComparer GetInstance(Type[] leftGenericTypeParameters, Type[] leftGenericMethodParameters, Type[] rightGenericTypeParameters, Type[] rightGenericMethodParameters);
    private static bool XOr(bool x, bool y);
    private static Type SubstituteGenericParameter(Type type, Type[] genericTypeParameters, Type[] genericMethodParameters);
    public sealed virtual bool Equals(Type x, Type y);
    private static int CombineHash(int x, int y);
    private static void CombineHash(Int32& x, int y);
    public sealed virtual int GetHashCode(Type obj);
    public sealed virtual bool Equals(Type[] x, Type[] y);
    public sealed virtual int GetHashCode(Type[] types);
}
public class PostSharp.Reflection.SemanticInfo : ValueType {
    private static Dictionary`2<Semantics, string> declarationKindNames;
    [CompilerGeneratedAttribute]
private DeclarationFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private Semantics <Semantic>k__BackingField;
    internal DeclarationFlags Flags { get; }
    public Semantics Semantic { get; }
    public bool IsCompilerGenerated { get; }
    public bool IsSelectable { get; }
    public string DisplayName { get; }
    internal SemanticInfo(Semantics semantic, DeclarationFlags flags);
    private static SemanticInfo();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal DeclarationFlags get_Flags();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Semantics get_Semantic();
    public bool get_IsCompilerGenerated();
    public bool get_IsSelectable();
    public string get_DisplayName();
}
[FlagsAttribute]
public enum PostSharp.Reflection.Semantics : Enum {
    public long value__;
    public static Semantics InstanceConstructor;
    public static Semantics StaticConstructor;
    public static Semantics DefaultConstructor;
    public static Semantics Event;
    public static Semantics OtherCompilerGeneratedEvent;
    public static Semantics EventAdder;
    public static Semantics EventRemover;
    public static Semantics EventRaiser;
    public static Semantics AnyEventAccessor;
    public static Semantics PropertyGetter;
    public static Semantics PropertySetter;
    public static Semantics AnyPropertyAccessor;
    public static Semantics Operator;
    public static Semantics AnonymousMethod;
    public static Semantics LocalFunction;
    public static Semantics Method;
    public static Semantics OtherCompilerGeneratedMethod;
    public static Semantics Finalizer;
    public static Semantics OtherSpecialMethod;
    public static Semantics OtherCompilerGeneratedField;
    public static Semantics Field;
    public static Semantics PropertyBackingField;
    public static Semantics EventBackingField;
    public static Semantics AnonymousMethodCacheField;
    public static Semantics Property;
    public static Semantics OtherCompilerGeneratedProperty;
    public static Semantics Type;
    public static Semantics ComClass;
    public static Semantics CompilerGeneratedTypeMember;
    public static Semantics CompilerGeneratedMethodParameter;
    public static Semantics Parameter;
    public static Semantics OtherDeclaration;
    public static Semantics CodeContractsField;
    public static Semantics AsyncStateMachineType;
    public static Semantics IteratorStateMachineType;
    public static Semantics OtherCompilerGeneratedType;
}
public enum PostSharp.Reflection.StateMachineKind : Enum {
    public int value__;
    public static StateMachineKind None;
    public static StateMachineKind Iterator;
    public static StateMachineKind Async;
    public static StateMachineKind AsyncIterator;
}
public class PostSharp.Reflection.SymbolSequencePoint : object {
    private int startLine;
    private int startColumn;
    private int endLine;
    private int endColumn;
    private int offset;
    internal static int HiddenValue;
    internal static int TrampolineValue;
    internal static int BindingValue;
    internal static int StepIntoValue;
    internal static int StepOutValue;
    internal static int FinallyValue;
    internal static int TrampolineWithFinallyValue;
    public static SymbolSequencePoint Hidden;
    internal static SymbolSequencePoint Trampoline;
    internal static SymbolSequencePoint Binding;
    internal static SymbolSequencePoint StepInto;
    internal static SymbolSequencePoint StepOut;
    internal static SymbolSequencePoint Finally;
    internal static SymbolSequencePoint TrampolineWithFinally;
    [CompilerGeneratedAttribute]
private ISourceDocument <SourceDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private object <SourceDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolSequencePointKind <Kind>k__BackingField;
    public bool IsHidden { get; }
    public bool IsSpecial { get; }
    public int StartLine { get; }
    public int EndLine { get; }
    public int StartColumn { get; }
    public int EndColumn { get; }
    internal int Offset { get; }
    public ISourceDocument SourceDocument { get; }
    internal object SourceDeclaration { get; internal set; }
    internal SymbolSequencePointKind Kind { get; internal set; }
    internal SymbolSequencePoint(int offset);
    internal SymbolSequencePoint(int offset, int startLine, int startColumn, int endLine, int endColumn, ISourceDocument document, object sourceDeclaration);
    internal SymbolSequencePoint(int startLine, int startColumn, int endLine, int endColumn, ISourceDocument document, object sourceDeclaration);
    internal SymbolSequencePoint(SymbolSequencePoint other);
    private static SymbolSequencePoint();
    public bool get_IsHidden();
    public bool get_IsSpecial();
    public int get_StartLine();
    public int get_EndLine();
    public int get_StartColumn();
    public int get_EndColumn();
    internal int get_Offset();
    [CompilerGeneratedAttribute]
public ISourceDocument get_SourceDocument();
    [CompilerGeneratedAttribute]
internal object get_SourceDeclaration();
    [CompilerGeneratedAttribute]
internal void set_SourceDeclaration(object value);
    [CompilerGeneratedAttribute]
internal SymbolSequencePointKind get_Kind();
    [CompilerGeneratedAttribute]
internal void set_Kind(SymbolSequencePointKind value);
    public sealed virtual int CompareTo(SymbolSequencePoint other);
    public sealed virtual bool Equals(SymbolSequencePoint other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(SymbolSequencePoint left, SymbolSequencePoint right);
    public static bool op_Inequality(SymbolSequencePoint left, SymbolSequencePoint right);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_LessThan(SymbolSequencePoint left, SymbolSequencePoint right);
    public static bool op_LessThanOrEqual(SymbolSequencePoint left, SymbolSequencePoint right);
    public static bool op_GreaterThan(SymbolSequencePoint left, SymbolSequencePoint right);
    public static bool op_GreaterThanOrEqual(SymbolSequencePoint left, SymbolSequencePoint right);
}
internal enum PostSharp.Reflection.SymbolSequencePointKind : Enum {
    public byte value__;
    public static SymbolSequencePointKind Default;
    public static SymbolSequencePointKind Entry;
    public static SymbolSequencePointKind Exit;
    public static SymbolSequencePointKind Disabled;
}
public class PostSharp.Reflection.TypeInheritanceCodeReference : object {
    [CompilerGeneratedAttribute]
private Type <BaseType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DerivedType>k__BackingField;
    public Type BaseType { get; private set; }
    public Type DerivedType { get; private set; }
    private object PostSharp.Reflection.ICodeReference.ReferencingDeclaration { get; }
    private object PostSharp.Reflection.ICodeReference.ReferencedDeclaration { get; }
    private CodeReferenceKind PostSharp.Reflection.ICodeReference.ReferenceKind { get; }
    internal TypeInheritanceCodeReference(Type baseType, Type derivedType);
    [CompilerGeneratedAttribute]
public Type get_BaseType();
    [CompilerGeneratedAttribute]
private void set_BaseType(Type value);
    [CompilerGeneratedAttribute]
public Type get_DerivedType();
    [CompilerGeneratedAttribute]
private void set_DerivedType(Type value);
    private sealed virtual override object PostSharp.Reflection.ICodeReference.get_ReferencingDeclaration();
    private sealed virtual override object PostSharp.Reflection.ICodeReference.get_ReferencedDeclaration();
    private sealed virtual override CodeReferenceKind PostSharp.Reflection.ICodeReference.get_ReferenceKind();
}
public enum PostSharp.Reflection.Visibility : Enum {
    public int value__;
    public static Visibility Public;
    public static Visibility Family;
    public static Visibility Assembly;
    public static Visibility FamilyOrAssembly;
    public static Visibility FamilyAndAssembly;
    public static Visibility Private;
}
[InternalAttribute]
public class PostSharp.Serialization.ActivatorProvider : object {
    private object sync;
    private Dictionary`2<Assembly, IActivator> assemblyActivators;
    private Dictionary`2<Type, IActivator> typeActivators;
    public IActivator GetActivator(Type type);
    private IActivator GetActivator(Assembly assembly);
}
public class PostSharp.Serialization.ActivatorSecurityToken : object {
    internal static ActivatorSecurityToken Instance;
    private static ActivatorSecurityToken();
}
[AttributeUsageAttribute("1")]
public class PostSharp.Serialization.ActivatorTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <ActivatorType>k__BackingField;
    public Type ActivatorType { get; private set; }
    public ActivatorTypeAttribute(Type activatorType);
    [CompilerGeneratedAttribute]
public Type get_ActivatorType();
    [CompilerGeneratedAttribute]
private void set_ActivatorType(Type value);
}
internal class PostSharp.Serialization.AssemblyTypeName : ValueType {
    public string TypeName;
    public string AssemblyName;
    public AssemblyTypeName(string typeName, string assemblyName);
}
internal class PostSharp.Serialization.BuiltInSerializerFactoryProvider : SerializerFactoryProvider {
    public BuiltInSerializerFactoryProvider(ActivatorProvider activatorProvider);
    public virtual Type GetSurrogateType(Type objectType);
    public virtual ISerializerFactory GetSerializerFactory(Type objectType);
    public static Type GetAbstractReflectionType(Type type);
}
public class PostSharp.Serialization.DottedString : ValueType {
    private string value;
    public static DottedString Null;
    public bool IsNull { get; }
    public string Value { get; }
    public DottedString(string value);
    private static DottedString();
    public bool get_IsNull();
    public string get_Value();
    public static string op_Implicit(DottedString dottedString);
    public static DottedString op_Implicit(string str);
    public sealed virtual bool Equals(DottedString other);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public static bool op_Equality(DottedString left, DottedString right);
    public static bool op_Inequality(DottedString left, DottedString right);
}
public interface PostSharp.Serialization.IActivator {
    public abstract virtual object CreateInstance(Type objectType, ActivatorSecurityToken securityToken);
}
[InternalImplementAttribute]
public interface PostSharp.Serialization.IArgumentsReader {
    public IMetadataDispenser MetadataDispenser { get; }
    public abstract virtual bool TryGetValue(string name, T& value, string scope);
    public abstract virtual T GetValue(string name, string scope);
    public abstract virtual IMetadataDispenser get_MetadataDispenser();
}
[InternalImplementAttribute]
public interface PostSharp.Serialization.IArgumentsWriter {
    public IMetadataEmitter MetadataEmitter { get; }
    public abstract virtual void SetValue(string name, object value, string scope);
    public abstract virtual IMetadataEmitter get_MetadataEmitter();
}
internal interface PostSharp.Serialization.IBuildTimeSerializerLocatorFactory {
    public abstract virtual ISerializerFactoryProvider Create(ISerializerFactoryProvider next);
}
[AttributeUsageAttribute("13")]
public class PostSharp.Serialization.ImportSerializerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <ObjectType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SerializerType>k__BackingField;
    public Type ObjectType { get; private set; }
    public Type SerializerType { get; private set; }
    public ImportSerializerAttribute(Type objectType, Type serializerType);
    [CompilerGeneratedAttribute]
public Type get_ObjectType();
    [CompilerGeneratedAttribute]
private void set_ObjectType(Type value);
    [CompilerGeneratedAttribute]
public Type get_SerializerType();
    [CompilerGeneratedAttribute]
private void set_SerializerType(Type value);
}
internal class PostSharp.Serialization.Integer : ValueType {
    public ulong AbsoluteValue;
    public bool IsNegative;
    public Integer(ulong absoluteValue, bool isNegative);
    public static int op_Implicit(Integer integer);
    public static long op_Implicit(Integer integer);
    public static short op_Implicit(Integer integer);
    public static UInt32 op_Implicit(Integer integer);
    public static ushort op_Implicit(Integer integer);
    public static ulong op_Implicit(Integer integer);
    public static Integer op_Implicit(int integer);
    public static Integer op_Implicit(long integer);
    public static Integer op_Implicit(short integer);
    public static Integer op_Implicit(UInt32 integer);
    public static Integer op_Implicit(ulong integer);
    public static Integer op_Implicit(ushort integer);
}
public interface PostSharp.Serialization.ISerializationCallback {
    public abstract virtual void OnDeserialized();
    public abstract virtual void OnSerializing();
}
[InternalImplementAttribute]
public interface PostSharp.Serialization.ISerializer {
    public bool IsTwoPhase { get; }
    public abstract virtual object Convert(object value, Type targetType);
    public abstract virtual object CreateInstance(Type type, IArgumentsReader constructorArguments);
    public abstract virtual void DeserializeFields(Object& obj, IArgumentsReader initializationArguments);
    public abstract virtual void SerializeObject(object obj, IArgumentsWriter constructorArguments, IArgumentsWriter initializationArguments);
    public abstract virtual bool get_IsTwoPhase();
}
public interface PostSharp.Serialization.ISerializerDiscoverer {
    public abstract virtual void DiscoverSerializers(Type objectType);
}
public interface PostSharp.Serialization.ISerializerFactory {
    public abstract virtual ISerializer CreateSerializer(Type objectType);
}
public interface PostSharp.Serialization.ISerializerFactoryProvider {
    public ISerializerFactoryProvider NextProvider { get; }
    public abstract virtual Type GetSurrogateType(Type objectType);
    public abstract virtual ISerializerFactory GetSerializerFactory(Type objectType);
    public abstract virtual ISerializerFactoryProvider get_NextProvider();
}
[AttributeUsageAttribute("256")]
public class PostSharp.Serialization.PNonSerializedAttribute : Attribute {
}
public class PostSharp.Serialization.PortableFormatter : object {
    private PortableSerializationBinder binder;
    private SerializerProvider serializerProvider;
    [CompilerGeneratedAttribute]
private static PortableSerializationBinder <DefaultBinder>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataDispenser <MetadataDispenser>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataEmitter <MetadataEmitter>k__BackingField;
    public static PortableSerializationBinder DefaultBinder { get; public set; }
    internal PortableSerializationBinder Binder { get; }
    public IMetadataDispenser MetadataDispenser { get; public set; }
    public IMetadataEmitter MetadataEmitter { get; public set; }
    internal SerializerProvider SerializerProvider { get; }
    public PortableFormatter(PortableSerializationBinder binder, ISerializerFactoryProvider serializerProvider);
    [CompilerGeneratedAttribute]
public static PortableSerializationBinder get_DefaultBinder();
    [CompilerGeneratedAttribute]
public static void set_DefaultBinder(PortableSerializationBinder value);
    public void Serialize(object obj, Stream stream);
    public object Deserialize(Stream stream);
    internal PortableSerializationBinder get_Binder();
    [CompilerGeneratedAttribute]
public IMetadataDispenser get_MetadataDispenser();
    [CompilerGeneratedAttribute]
public void set_MetadataDispenser(IMetadataDispenser value);
    [CompilerGeneratedAttribute]
public IMetadataEmitter get_MetadataEmitter();
    [CompilerGeneratedAttribute]
public void set_MetadataEmitter(IMetadataEmitter value);
    internal SerializerProvider get_SerializerProvider();
}
[InternalAttribute]
public class PostSharp.Serialization.PortableFormatterConstructorContext : object {
}
public class PostSharp.Serialization.PortableSerializationBinder : object {
    private IReflectionBindingManagerService reflectionBindingManagerService;
    public virtual Type BindToType(string typeName, string assemblyName);
    public virtual void BindToName(Type type, String& typeName, String& assemblyName);
}
public class PostSharp.Serialization.PortableSerializationException : Exception {
    public PortableSerializationException(string message);
    public PortableSerializationException(string message, Exception inner);
    protected PortableSerializationException(SerializationInfo info, StreamingContext context);
    internal static PortableSerializationException CreateWithCause(string operation, Type type, Exception innerException, SerializationCause cause);
}
[AttributeUsageAttribute("13")]
[MulticastAttributeUsageAttribute("3")]
[RequirePostSharpAttribute("", "PortableSerializer")]
[LinesOfCodeAvoidedAttribute("0")]
public class PostSharp.Serialization.PSerializableAttribute : MulticastAttribute {
}
public abstract class PostSharp.Serialization.ReferenceTypeSerializer : object {
    private bool PostSharp.Serialization.ISerializer.IsTwoPhase { get; }
    private sealed virtual override bool PostSharp.Serialization.ISerializer.get_IsTwoPhase();
    private sealed virtual override void PostSharp.Serialization.ISerializer.DeserializeFields(Object& obj, IArgumentsReader initializationArguments);
    private sealed virtual override void PostSharp.Serialization.ISerializer.SerializeObject(object obj, IArgumentsWriter constructorArguments, IArgumentsWriter initializationArguments);
    public abstract virtual object CreateInstance(Type type, IArgumentsReader constructorArguments);
    public abstract virtual void SerializeObject(object obj, IArgumentsWriter constructorArguments, IArgumentsWriter initializationArguments);
    public abstract virtual void DeserializeFields(object obj, IArgumentsReader initializationArguments);
    public virtual object Convert(object value, Type targetType);
}
internal class PostSharp.Serialization.ReflectionSerializationProvider : object {
    private Dictionary`2<Type, ISerializerFactory> serializerTypes;
    private Dictionary`2<Type, bool> inspectedTypes;
    private Dictionary`2<Assembly, bool> inspectedAssemblies;
    private object sync;
    private ActivatorProvider activatorProvider;
    public ActivatorProvider ActivatorProvider { get; }
    public ISerializerFactoryProvider NextProvider { get; }
    public ReflectionSerializationProvider(ActivatorProvider activatorProvider);
    public ActivatorProvider get_ActivatorProvider();
    public sealed virtual Type GetSurrogateType(Type objectType);
    public sealed virtual ISerializerFactory GetSerializerFactory(Type objectType);
    private void AddSerializer(Type objectType, Type serializerType, ActivatorProvider activatorProvider);
    private void InspectType(Type type);
    private void InspectAssembly(Assembly assembly);
    private void ProcessImport(ImportSerializerAttribute importSerializerAttribute);
    public sealed virtual ISerializerFactoryProvider get_NextProvider();
    public sealed virtual void DiscoverSerializers(Type objectType);
}
internal class PostSharp.Serialization.ReflectionSerializerFactory : object {
    private Type serializerType;
    private ActivatorProvider activatorProvider;
    public Type SerializerType { get; }
    public ReflectionSerializerFactory(Type serializerType, ActivatorProvider activatorProvider);
    public sealed virtual ISerializer CreateSerializer(Type objectType);
    public Type get_SerializerType();
}
internal class PostSharp.Serialization.SerializationBinaryReader : object {
    private BinaryReader reader;
    private Dictionary`2<int, string> strings;
    private Dictionary`2<int, string> dottedStrings;
    public SerializationBinaryReader(BinaryReader reader);
    public byte ReadByte();
    public string ReadString();
    public DottedString ReadDottedString();
    public Integer ReadCompressedInteger();
    public double ReadDouble();
    public float ReadSingle();
    public sbyte ReadSByte();
}
internal class PostSharp.Serialization.SerializationBinaryWriter : object {
    private BinaryWriter writer;
    private Dictionary`2<string, int> strings;
    private Dictionary`2<string, int> dottedStrings;
    public SerializationBinaryWriter(BinaryWriter writer);
    public void WriteCompressedInteger(Integer integer);
    public void WriteByte(byte value);
    public void WriteDouble(double value);
    public void WriteString(string value);
    public void WriteSByte(sbyte value);
    public void WriteDottedString(string value);
    public void WriteSingle(float value);
}
internal class PostSharp.Serialization.SerializationCause : object {
    [CompilerGeneratedAttribute]
private SerializationCause <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public SerializationCause Parent { get; }
    public string Description { get; }
    private SerializationCause(string description, SerializationCause parent);
    [CompilerGeneratedAttribute]
public SerializationCause get_Parent();
    [CompilerGeneratedAttribute]
public string get_Description();
    public static SerializationCause WithTypedValue(SerializationCause parent, string fieldName, Type type);
    public static SerializationCause WithIndices(SerializationCause parent, Int32[] indices);
}
internal enum PostSharp.Serialization.SerializationIntrinsicType : Enum {
    public byte value__;
    public static SerializationIntrinsicType None;
    public static SerializationIntrinsicType Byte;
    public static SerializationIntrinsicType Int16;
    public static SerializationIntrinsicType UInt16;
    public static SerializationIntrinsicType Int32;
    public static SerializationIntrinsicType UInt32;
    public static SerializationIntrinsicType Int64;
    public static SerializationIntrinsicType UInt64;
    public static SerializationIntrinsicType Single;
    public static SerializationIntrinsicType Double;
    public static SerializationIntrinsicType String;
    public static SerializationIntrinsicType DottedString;
    public static SerializationIntrinsicType Char;
    public static SerializationIntrinsicType Boolean;
    public static SerializationIntrinsicType SByte;
    public static SerializationIntrinsicType Struct;
    public static SerializationIntrinsicType Class;
    public static SerializationIntrinsicType Array;
    public static SerializationIntrinsicType ObjRef;
    public static SerializationIntrinsicType Type;
    public static SerializationIntrinsicType GenericTypeParameter;
    public static SerializationIntrinsicType GenericMethodParameter;
    public static SerializationIntrinsicType Enum;
}
internal static class PostSharp.Serialization.SerializationIntrinsicTypeExtensions : object {
    public static bool IsPrimitiveIntrinsic(SerializationIntrinsicType intrinsicType);
    public static SerializationIntrinsicType GetIntrinsicType(Type type, bool useObjRef);
}
internal enum PostSharp.Serialization.SerializationIntrinsicTypeFlags : Enum {
    public int value__;
    public static SerializationIntrinsicTypeFlags Default;
    public static SerializationIntrinsicTypeFlags MetadataIndex;
    public static SerializationIntrinsicTypeFlags Generic;
}
internal class PostSharp.Serialization.SerializationQueueItem`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private SerializationCause <Cause>k__BackingField;
    public T Value { get; }
    public SerializationCause Cause { get; }
    public SerializationQueueItem`1(T o, SerializationCause cause);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public SerializationCause get_Cause();
}
internal class PostSharp.Serialization.SerializationReader : object {
    private Dictionary`2<int, SerializationQueueItem`1<ObjRef>> referenceTypeInstances;
    private SerializationBinaryReader binaryReader;
    private PortableFormatter formatter;
    private bool shouldReportExceptionCause;
    private static byte version;
    internal SerializationReader(Stream stream, PortableFormatter formatter, bool shouldReportExceptionCause);
    public object Deserialize();
    private object ReadObject(int instanceId, bool initializeObject, SerializationCause cause);
    private object ReadObjectInternal(ObjRef objRef, int instanceId, bool initializeObject);
    private void InitializeObject(int instanceId);
    private void TryDeserializeFields(ISerializer serializer, Object& value, InstanceFields fields, SerializationCause cause);
    private InstanceFields ReadInstanceFields(Type type, bool initializeObjects, SerializationCause cause);
    private void ReadType(Type& type, SerializationIntrinsicType& intrinsicType);
    private Type ReadNamedType();
    private Type ReadType();
    private object ReadTypedValue(bool initializeObjects, SerializationCause cause);
    private object ReadValue(SerializationIntrinsicType intrinsicType, Type type, bool initializeObject, SerializationCause cause);
    private Type ReadGenericTypeParameter();
    private Type ReadGenericMethodParameter();
    private MethodBase ReadMethod();
    private Type GetType(AssemblyTypeName typeName);
    private void ReadArray(Array array, SerializationCause cause);
    private void ReadArrayElements(Array array, Type elementType, Int32[] indices, int currentDimension, SerializationCause cause);
    private object ReadObjRef(bool initializeObject, SerializationCause cause);
    private ObjRef GetObjRef(int instanceId, SerializationCause cause);
    private object TryCreateInstance(ISerializer serializer, Type type, InstanceFields fields, SerializationCause cause);
    private object ReadStruct(Type type, SerializationCause cause);
    private AssemblyTypeName ReadTypeName();
}
public static class PostSharp.Serialization.SerializationServices : object {
    public static PortableSerializationException GetSerializationException(MemberInfo memberInfo);
    public static PortableSerializationException GetSerializationException(LocationInfo locationInfo);
    public static PortableSerializationException GetSerializationException(ParameterInfo parameterInfo);
    internal static PortableSerializationException GetSerializationException(object metadata);
}
internal class PostSharp.Serialization.SerializationWriter : object {
    private SerializationBinaryWriter binaryWriter;
    private Queue`1<SerializationQueueItem`1<object>> serializationQueue;
    private PortableFormatter formatter;
    private bool shouldReportExceptionCause;
    private Dictionary`2<Type, AssemblyTypeName> typeNameCache;
    private Dictionary`2<Type, Type> surrogateTypesCache;
    private Dictionary`2<object, ObjectInfo> objects;
    private static int version;
    public SerializationWriter(Stream stream, PortableFormatter formatter, bool shouldReportExceptionCause);
    public void Serialize(object obj);
    private void CallOnSerialization(object obj);
    private ObjectInfo GetObjectInfo(object obj, SerializationCause cause);
    private void TrySerialize(ISerializer serializer, object obj, IArgumentsWriter constructorArguments, IArgumentsWriter initializationArguments, SerializationCause cause);
    private void WriteType(Type type, SerializationCause cause, SerializationIntrinsicType intrinsicType);
    private int GetMetadataIndex(Type metadata, SerializationCause cause);
    private void WriteTypeName(Type type);
    private Type GetSurrogateType(Type type);
    private void WriteTypeName(AssemblyTypeName type);
    private void WriteMethod(MethodBase method, SerializationCause cause);
    private void WriteConstructionData(ObjectInfo objectInfo, SerializationCause cause);
    private void WriteInitializationData(ObjectInfo objectInfo, SerializationCause cause);
    private void WriteTypedValue(object value, bool writeInitializationDataInline, SerializationCause cause);
    private void WriteValue(object value, SerializationIntrinsicType intrinsicType, bool writeInitializationDataInline, SerializationCause cause);
    private void WriteGenericTypeParameter(Type type, SerializationCause cause);
    private void WriteGenericMethodParameter(Type type, SerializationCause cause);
    private void WriteObjectReference(object value, bool writeInitializationDataInline, SerializationCause cause);
    private void WriteStruct(object value, SerializationCause cause);
    private void WriteArguments(Arguments arguments, bool writeInitializationArgumentsInline, SerializationCause cause, Type owningType);
    private void WriteObject(object obj, SerializationCause cause);
    private void WriteArrayElements(Array array, Type elementType, Int32[] indices, int currentDimension, SerializationCause cause);
}
[AttributeUsageAttribute("12")]
public class PostSharp.Serialization.SerializerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <SerializerType>k__BackingField;
    public Type SerializerType { get; private set; }
    public SerializerAttribute(Type serializerType);
    [CompilerGeneratedAttribute]
public Type get_SerializerType();
    [CompilerGeneratedAttribute]
private void set_SerializerType(Type value);
}
public class PostSharp.Serialization.SerializerFactoryProvider : object {
    private bool isReadOnly;
    private Dictionary`2<Type, ISerializerFactory> serializerTypes;
    private ISerializerFactoryProvider nextProvider;
    private ActivatorProvider activatorProvider;
    public static SerializerFactoryProvider BuiltIn;
    public ISerializerFactoryProvider NextProvider { get; }
    public SerializerFactoryProvider(ISerializerFactoryProvider nextProvider, ActivatorProvider activatorProvider);
    private static SerializerFactoryProvider();
    public void MakeReadOnly();
    public sealed virtual ISerializerFactoryProvider get_NextProvider();
    public void AddSerializer();
    public void AddSerializer(Type objectType, Type serializerType);
    public virtual Type GetSurrogateType(Type objectType);
    public virtual ISerializerFactory GetSerializerFactory(Type objectType);
}
internal class PostSharp.Serialization.SerializerProvider : object {
    private ISerializerFactoryProvider provider;
    private SerializerProvider next;
    private Dictionary`2<Type, ISerializer> serializers;
    private object sync;
    public SerializerProvider(ISerializerFactoryProvider provider);
    public Type GetSurrogateType(Type objectType);
    private void DiscoverSerializers(Type objectType);
    public ISerializer GetSerializer(Type objectType);
    public bool TryGetSerializer(Type objectType, ISerializer& serializer);
}
internal class PostSharp.Serialization.Serializers.AssemblyNameSerializer : ReferenceTypeSerializer {
    public virtual object CreateInstance(Type type, IArgumentsReader constructorArguments);
    public virtual void DeserializeFields(object obj, IArgumentsReader initializationArguments);
    public virtual void SerializeObject(object obj, IArgumentsWriter constructorArguments, IArgumentsWriter initializationArguments);
}
internal class PostSharp.Serialization.Serializers.AssemblySerializer : ReferenceTypeSerializer {
    public virtual object CreateInstance(Type type, IArgumentsReader constructorArguments);
    public virtual void DeserializeFields(object obj, IArgumentsReader initializationArguments);
    public virtual void SerializeObject(object obj, IArgumentsWriter constructorArguments, IArgumentsWriter initializationArguments);
}
internal class PostSharp.Serialization.Serializers.BooleanSerializer : IntrinsicSerializer`1<bool> {
    public virtual object Convert(object value, Type targetType);
}
internal class PostSharp.Serialization.Serializers.ByteSerializer : IntrinsicSerializer`1<byte> {
    public virtual object Convert(object value, Type targetType);
}
internal class PostSharp.Serialization.Serializers.CharSerializer : IntrinsicSerializer`1<char> {
    public virtual object Convert(object value, Type targetType);
}
internal static class PostSharp.Serialization.Serializers.ComparerExtensions : object {
    public static byte GetComparerCode(IEqualityComparer`1<T> comparer);
    public static IEqualityComparer`1<string> GetComparerFromCode(byte code);
}
internal class PostSharp.Serialization.Serializers.ConstructorInfoSerializer : MethodBaseSerializer`1<ConstructorInfo> {
}
[InternalAttribute]
public class PostSharp.Serialization.Serializers.CultureInfoSerializer : ReferenceTypeSerializer {
    public virtual object CreateInstance(Type type, IArgumentsReader constructorArguments);
    public virtual void SerializeObject(object obj, IArgumentsWriter constructorArguments, IArgumentsWriter initializationArguments);
    public virtual void DeserializeFields(object obj, IArgumentsReader initializationArguments);
}
internal class PostSharp.Serialization.Serializers.DateTimeSerializer : ValueTypeSerializer`1<DateTime> {
    public virtual void SerializeObject(DateTime value, IArgumentsWriter writer);
    public virtual DateTime DeserializeObject(IArgumentsReader reader);
}
internal class PostSharp.Serialization.Serializers.DecimalSerializer : ValueTypeSerializer`1<decimal> {
    public virtual void SerializeObject(decimal value, IArgumentsWriter writer);
    public virtual decimal DeserializeObject(IArgumentsReader reader);
}
internal class PostSharp.Serialization.Serializers.DeclarationIdentifierSerializer : ValueTypeSerializer`1<DeclarationIdentifier> {
    public virtual void SerializeObject(DeclarationIdentifier value, IArgumentsWriter writer);
    public virtual DeclarationIdentifier DeserializeObject(IArgumentsReader reader);
}
[InternalAttribute]
public class PostSharp.Serialization.Serializers.DictionarySerializer`2 : ReferenceTypeSerializer {
    private static string comparerCodeName;
    private static string comparerName;
    private static string keysName;
    private static string valuesName;
    public virtual object CreateInstance(Type type, IArgumentsReader constructorArguments);
    public virtual void SerializeObject(object obj, IArgumentsWriter constructorArguments, IArgumentsWriter initializationArguments);
    public virtual void DeserializeFields(object obj, IArgumentsReader initializationArguments);
}
internal class PostSharp.Serialization.Serializers.DottedStringSerializer : IntrinsicSerializer`1<DottedString> {
    public virtual object Convert(object value, Type targetType);
}
internal class PostSharp.Serialization.Serializers.DoubleSerializer : IntrinsicSerializer`1<double> {
    public virtual object Convert(object value, Type targetType);
}
internal class PostSharp.Serialization.Serializers.EventInfoSerializer : MetadataSerializer`1<EventInfo> {
    protected virtual object CreateInstanceImpl(Type type, IArgumentsReader constructorArguments);
    protected virtual void SerializeObjectImpl(object obj, IArgumentsWriter argumentsWriter);
}
internal class PostSharp.Serialization.Serializers.FieldInfoSerializer : MetadataSerializer`1<FieldInfo> {
    protected virtual object CreateInstanceImpl(Type type, IArgumentsReader constructorArguments);
    protected virtual void SerializeObjectImpl(object obj, IArgumentsWriter argumentsWriter);
}
internal class PostSharp.Serialization.Serializers.GuidSerializer : ValueTypeSerializer`1<Guid> {
    public virtual void SerializeObject(Guid value, IArgumentsWriter writer);
    public virtual Guid DeserializeObject(IArgumentsReader reader);
}
internal class PostSharp.Serialization.Serializers.Int16Serializer : IntrinsicSerializer`1<short> {
    public virtual object Convert(object value, Type targetType);
}
internal class PostSharp.Serialization.Serializers.Int32Serializer : IntrinsicSerializer`1<int> {
    public virtual object Convert(object value, Type targetType);
}
internal class PostSharp.Serialization.Serializers.Int64Serializer : IntrinsicSerializer`1<long> {
    public virtual object Convert(object value, Type targetType);
}
internal abstract class PostSharp.Serialization.Serializers.IntrinsicSerializer`1 : object {
    public bool IsTwoPhase { get; }
    public abstract virtual object Convert(object value, Type targetType);
    private sealed virtual override object PostSharp.Serialization.ISerializer.CreateInstance(Type type, IArgumentsReader constructorArguments);
    private sealed virtual override void PostSharp.Serialization.ISerializer.DeserializeFields(Object& obj, IArgumentsReader initializationArguments);
    private sealed virtual override void PostSharp.Serialization.ISerializer.SerializeObject(object obj, IArgumentsWriter constructorArguments, IArgumentsWriter initializationArguments);
    public sealed virtual bool get_IsTwoPhase();
    protected void WriteType(SerializationBinaryWriter writer, SerializationIntrinsicType type);
}
[InternalAttribute]
public class PostSharp.Serialization.Serializers.ListSerializer`1 : ReferenceTypeSerializer {
    private static string keyName;
    public virtual object CreateInstance(Type type, IArgumentsReader constructorArguments);
    public virtual void SerializeObject(object obj, IArgumentsWriter constructorArguments, IArgumentsWriter initializationArguments);
    public virtual void DeserializeFields(object obj, IArgumentsReader initializationArguments);
}
internal class PostSharp.Serialization.Serializers.LocationInfoSerializer : MetadataSerializer`1<LocationInfo> {
    protected virtual object CreateInstanceImpl(Type type, IArgumentsReader constructorArguments);
    protected virtual void SerializeObjectImpl(object obj, IArgumentsWriter constructorArguments);
}
internal abstract class PostSharp.Serialization.Serializers.MetadataSerializer`1 : ReferenceTypeSerializer {
    private static string metadataIndexFieldName;
    public sealed virtual object CreateInstance(Type type, IArgumentsReader constructorArguments);
    protected abstract virtual object CreateInstanceImpl(Type type, IArgumentsReader constructorArguments);
    public virtual void DeserializeFields(object obj, IArgumentsReader initializationArguments);
    public sealed virtual void SerializeObject(object obj, IArgumentsWriter constructorArguments, IArgumentsWriter initializationArguments);
    protected abstract virtual void SerializeObjectImpl(object obj, IArgumentsWriter argumentsWriter);
}
internal abstract class PostSharp.Serialization.Serializers.MethodBaseSerializer`1 : MetadataSerializer`1<T> {
    protected virtual object CreateInstanceImpl(Type type, IArgumentsReader constructorArguments);
    protected virtual void SerializeObjectImpl(object obj, IArgumentsWriter constructorArguments);
}
internal class PostSharp.Serialization.Serializers.MethodInfoSerializer : MethodBaseSerializer`1<MethodInfo> {
}
internal class PostSharp.Serialization.Serializers.ParameterInfoSerializer : MetadataSerializer`1<ParameterInfo> {
    protected virtual object CreateInstanceImpl(Type type, IArgumentsReader constructorArguments);
    protected virtual void SerializeObjectImpl(object obj, IArgumentsWriter constructorArguments);
}
internal class PostSharp.Serialization.Serializers.PropertyInfoSerializer : MetadataSerializer`1<PropertyInfo> {
    protected virtual object CreateInstanceImpl(Type type, IArgumentsReader constructorArguments);
    protected virtual void SerializeObjectImpl(object obj, IArgumentsWriter constructorArguments);
}
internal class PostSharp.Serialization.Serializers.SByteSerializer : IntrinsicSerializer`1<sbyte> {
    public virtual object Convert(object value, Type targetType);
}
internal class PostSharp.Serialization.Serializers.SingleSerializer : IntrinsicSerializer`1<float> {
    public virtual object Convert(object value, Type targetType);
}
internal class PostSharp.Serialization.Serializers.StringSerializer : IntrinsicSerializer`1<string> {
    public virtual object Convert(object value, Type targetType);
}
internal class PostSharp.Serialization.Serializers.TimeSpanSerializer : ValueTypeSerializer`1<TimeSpan> {
    public virtual void SerializeObject(TimeSpan value, IArgumentsWriter writer);
    public virtual TimeSpan DeserializeObject(IArgumentsReader reader);
}
internal class PostSharp.Serialization.Serializers.TypeSerializer : IntrinsicSerializer`1<Type> {
    public virtual object Convert(object value, Type targetType);
}
internal class PostSharp.Serialization.Serializers.UInt16Serializer : IntrinsicSerializer`1<ushort> {
    public virtual object Convert(object value, Type targetType);
}
internal class PostSharp.Serialization.Serializers.UInt32Serializer : IntrinsicSerializer`1<UInt32> {
    public virtual object Convert(object value, Type targetType);
}
internal class PostSharp.Serialization.Serializers.UInt64Serializer : IntrinsicSerializer`1<ulong> {
    public virtual object Convert(object value, Type targetType);
}
public abstract class PostSharp.Serialization.ValueTypeSerializer`1 : object {
    private bool PostSharp.Serialization.ISerializer.IsTwoPhase { get; }
    private sealed virtual override bool PostSharp.Serialization.ISerializer.get_IsTwoPhase();
    public abstract virtual void SerializeObject(T obj, IArgumentsWriter constructorArguments);
    public abstract virtual T DeserializeObject(IArgumentsReader constructorArguments);
    private sealed virtual override void PostSharp.Serialization.ISerializer.SerializeObject(object obj, IArgumentsWriter constructorArguments, IArgumentsWriter initializationArguments);
    public virtual object Convert(object value, Type targetType);
    private sealed virtual override object PostSharp.Serialization.ISerializer.CreateInstance(Type type, IArgumentsReader constructorArguments);
    private sealed virtual override void PostSharp.Serialization.ISerializer.DeserializeFields(Object& o, IArgumentsReader initializationArguments);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
