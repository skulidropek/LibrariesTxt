[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class ClearRecycleBinResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ClearRecycleBinContent { get; }
    internal static string ClearRecycleBinContentForDrive { get; }
    internal static string ClearRecycleBinProgressActivity { get; }
    internal static string ClearRecycleBinStatusDescriptionByDrive { get; }
    internal static string ClearRecycleBinStatusDescriptionForAllDrives { get; }
    internal static string DriveNotFound { get; }
    internal static string InvalidDriveNameFormat { get; }
    internal static string InvalidDriveType { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ClearRecycleBinContent();
    internal static string get_ClearRecycleBinContentForDrive();
    internal static string get_ClearRecycleBinProgressActivity();
    internal static string get_ClearRecycleBinStatusDescriptionByDrive();
    internal static string get_ClearRecycleBinStatusDescriptionForAllDrives();
    internal static string get_DriveNotFound();
    internal static string get_InvalidDriveNameFormat();
    internal static string get_InvalidDriveType();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class ClipboardResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string SetClipboardContent { get; }
    internal static string AppendClipboardContent { get; }
    internal static string SetSingleFileToClipboard { get; }
    internal static string AppendSingleFileToClipboard { get; }
    internal static string SetMultipleFilesToClipboard { get; }
    internal static string AppendMultipleFilesToClipboard { get; }
    internal static string NoAppendableClipboardContent { get; }
    internal static string ClipboardCleared { get; }
    internal static string InvalidTypeCombine { get; }
    internal static string InvalidRawCombine { get; }
    internal static string InvalidHtmlCombine { get; }
    internal static string UnsupportedFormat { get; }
    internal static string UnsupportedPlatform { get; }
    internal static string AsHtmlUnsupported { get; }
    internal static string TextFormatUnsupported { get; }
    internal static string PathUnsupported { get; }
    internal static string LiteralPathUnsupported { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_SetClipboardContent();
    internal static string get_AppendClipboardContent();
    internal static string get_SetSingleFileToClipboard();
    internal static string get_AppendSingleFileToClipboard();
    internal static string get_SetMultipleFilesToClipboard();
    internal static string get_AppendMultipleFilesToClipboard();
    internal static string get_NoAppendableClipboardContent();
    internal static string get_ClipboardCleared();
    internal static string get_InvalidTypeCombine();
    internal static string get_InvalidRawCombine();
    internal static string get_InvalidHtmlCombine();
    internal static string get_UnsupportedFormat();
    internal static string get_UnsupportedPlatform();
    internal static string get_AsHtmlUnsupported();
    internal static string get_TextFormatUnsupported();
    internal static string get_PathUnsupported();
    internal static string get_LiteralPathUnsupported();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class CmdletizationResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CimJob_InvalidClassName { get; }
    internal static string CimJob_MethodDescription { get; }
    internal static string CimJob_GenericCimFailure { get; }
    internal static string CimJob_VerboseExecutionMessage { get; }
    internal static string SessionBasedWrapper_ShouldProcessVsJobConflict { get; }
    internal static string CimJob_SafeQueryDescription { get; }
    internal static string CimJob_ErrorCodeFromMethod { get; }
    internal static string CimJob_SafeMethodDescription { get; }
    internal static string CimConversion_CimIntrinsicValue { get; }
    internal static string CimConversion_WqlQuery { get; }
    internal static string CimJob_InvalidOutputParameterName { get; }
    internal static string CimJob_NotFound_ComplexCase { get; }
    internal static string CimJob_NotFound_SimpleGranularCase_Equality { get; }
    internal static string CimJob_MismatchedTypeOfPropertyReturnedByQuery { get; }
    internal static string CimJob_SafeAssociationDescription { get; }
    internal static string CimJob_AssociationDescription { get; }
    internal static string CimJob_SleepAndRetryVerboseMessage { get; }
    internal static string CimJob_BrokenSession { get; }
    internal static string CimCmdletAdapter_DebugInquire { get; }
    internal static string CimCmdletAdapter_WarningInquire { get; }
    internal static string CimCmdletAdapter_WarningStop { get; }
    internal static string CimJob_ComputerNameConcatenationTemplate { get; }
    internal static string CimCmdletAdapter_RemoteDcomDoesntSupportExtendedSemantics { get; }
    internal static string CimJob_NotFound_SimpleGranularCase_Wildcard { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CimJob_InvalidClassName();
    internal static string get_CimJob_MethodDescription();
    internal static string get_CimJob_GenericCimFailure();
    internal static string get_CimJob_VerboseExecutionMessage();
    internal static string get_SessionBasedWrapper_ShouldProcessVsJobConflict();
    internal static string get_CimJob_SafeQueryDescription();
    internal static string get_CimJob_ErrorCodeFromMethod();
    internal static string get_CimJob_SafeMethodDescription();
    internal static string get_CimConversion_CimIntrinsicValue();
    internal static string get_CimConversion_WqlQuery();
    internal static string get_CimJob_InvalidOutputParameterName();
    internal static string get_CimJob_NotFound_ComplexCase();
    internal static string get_CimJob_NotFound_SimpleGranularCase_Equality();
    internal static string get_CimJob_MismatchedTypeOfPropertyReturnedByQuery();
    internal static string get_CimJob_SafeAssociationDescription();
    internal static string get_CimJob_AssociationDescription();
    internal static string get_CimJob_SleepAndRetryVerboseMessage();
    internal static string get_CimJob_BrokenSession();
    internal static string get_CimCmdletAdapter_DebugInquire();
    internal static string get_CimCmdletAdapter_WarningInquire();
    internal static string get_CimCmdletAdapter_WarningStop();
    internal static string get_CimJob_ComputerNameConcatenationTemplate();
    internal static string get_CimCmdletAdapter_RemoteDcomDoesntSupportExtendedSemantics();
    internal static string get_CimJob_NotFound_SimpleGranularCase_Wildcard();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class ComputerInfoResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string LoadingOperationSystemInfo { get; }
    internal static string LoadingHotPatchInfo { get; }
    internal static string LoadingRegistryInfo { get; }
    internal static string LoadingBiosInfo { get; }
    internal static string LoadingMotherboardInfo { get; }
    internal static string LoadingComputerInfo { get; }
    internal static string LoadingProcessorInfo { get; }
    internal static string LoadingNetworkAdapterInfo { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_LoadingOperationSystemInfo();
    internal static string get_LoadingHotPatchInfo();
    internal static string get_LoadingRegistryInfo();
    internal static string get_LoadingBiosInfo();
    internal static string get_LoadingMotherboardInfo();
    internal static string get_LoadingComputerInfo();
    internal static string get_LoadingProcessorInfo();
    internal static string get_LoadingNetworkAdapterInfo();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class ComputerResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string NotSupported { get; }
    internal static string NotEnabled { get; }
    internal static string InvalidDrive { get; }
    internal static string NoSystemDrive { get; }
    internal static string NotValidDrive { get; }
    internal static string NotDisabled { get; }
    internal static string ServiceDisabled { get; }
    internal static string RestorePointNotCreated { get; }
    internal static string RestoreFailed { get; }
    internal static string RestoreSuccess { get; }
    internal static string RestoreInterrupted { get; }
    internal static string NoRestorePoint { get; }
    internal static string DoubleComputerName { get; }
    internal static string RestartcomputerFailed { get; }
    internal static string OperationFailed { get; }
    internal static string StopcomputerFailed { get; }
    internal static string InvalidRestorePoint { get; }
    internal static string RestartNeeded { get; }
    internal static string RemoveComputerConfirm { get; }
    internal static string InvalidComputerNameFormat { get; }
    internal static string InvalidDomainNameFormat { get; }
    internal static string ComputerNamesAreEqual { get; }
    internal static string ResetComputerMachinePassword { get; }
    internal static string SystemRestoreServiceDisabled { get; }
    internal static string ProgressActivity { get; }
    internal static string ProgressStatusCreatingRestorePoint { get; }
    internal static string ProgressStatusCompleted { get; }
    internal static string NetworkPathNotFound { get; }
    internal static string PrivilegeNotEnabled { get; }
    internal static string RestartComputerAction { get; }
    internal static string LocalShutdownPrivilege { get; }
    internal static string RemoteShutdownPrivilege { get; }
    internal static string CannotWaitLocalComputer { get; }
    internal static string RestartComputerInvalidParameter { get; }
    internal static string RestartMultipleComputersActivity { get; }
    internal static string RestartSingleComputerActivity { get; }
    internal static string WaitForMultipleComputers { get; }
    internal static string VerifyRebootStage { get; }
    internal static string WaitForPowerShell { get; }
    internal static string WaitForRestartToBegin { get; }
    internal static string WaitForWinRM { get; }
    internal static string WaitForWMI { get; }
    internal static string RestartComplete { get; }
    internal static string NoSupportForCombinedServiceType { get; }
    internal static string CannotResolveComputerName { get; }
    internal static string IncorrectNewNameNumber { get; }
    internal static string InvalidNewName { get; }
    internal static string NewNameIsOldName { get; }
    internal static string ComputerNotInDomain { get; }
    internal static string FailToJoinWorkGroup { get; }
    internal static string NetworkDown { get; }
    internal static string FailToRename { get; }
    internal static string AddComputerActionDomain { get; }
    internal static string AddComputerActionWorkgroup { get; }
    internal static string AddComputerToSameDomain { get; }
    internal static string AddComputerToSameWorkgroup { get; }
    internal static string FailToRenameAfterJoinWorkgroup { get; }
    internal static string FailToSwitchFromDomainToWorkgroup { get; }
    internal static string FailToUnjoinDomain { get; }
    internal static string FailToConnectToComputer { get; }
    internal static string FailToJoinDomainFromWorkgroup { get; }
    internal static string FailToJoinNewDomainAfterUnjoinOldDomain { get; }
    internal static string FailToRenameAfterJoinDomain { get; }
    internal static string InvalidJoinOptions { get; }
    internal static string CannotRenameMultipleComputers { get; }
    internal static string CannotFindMachineAccountFromDomain { get; }
    internal static string CannotFindMachineAccountFromServer { get; }
    internal static string FailToGetDomainInformation { get; }
    internal static string FailToResetPasswordOnDomain { get; }
    internal static string FailToResetPasswordOnLocalMachine { get; }
    internal static string NeedAdminPrivilegeToResetPassword { get; }
    internal static string ResetComputerNotInDomain { get; }
    internal static string TruncateNetBIOSName { get; }
    internal static string TruncateNetBIOSNameCaption { get; }
    internal static string CannotResolveServerName { get; }
    internal static string CannotCreateRestorePointWarning { get; }
    internal static string CannotGetOperatingSystemObject { get; }
    internal static string RestartComputerSkipped { get; }
    internal static string FailToTestSecureChannel { get; }
    internal static string RepairSecureChannelFail { get; }
    internal static string RepairSecureChannelSucceed { get; }
    internal static string SecureChannelAlive { get; }
    internal static string SecureChannelBroken { get; }
    internal static string TestComputerNotInDomain { get; }
    internal static string SystemRestoreNotSupported { get; }
    internal static string TimeoutError { get; }
    internal static string FailToRetrieveLastRestorePoint { get; }
    internal static string InvalidParameterSetAsJob { get; }
    internal static string InvalidParameterForCoreClr { get; }
    internal static string ShutdownCommandNotFound { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_NotSupported();
    internal static string get_NotEnabled();
    internal static string get_InvalidDrive();
    internal static string get_NoSystemDrive();
    internal static string get_NotValidDrive();
    internal static string get_NotDisabled();
    internal static string get_ServiceDisabled();
    internal static string get_RestorePointNotCreated();
    internal static string get_RestoreFailed();
    internal static string get_RestoreSuccess();
    internal static string get_RestoreInterrupted();
    internal static string get_NoRestorePoint();
    internal static string get_DoubleComputerName();
    internal static string get_RestartcomputerFailed();
    internal static string get_OperationFailed();
    internal static string get_StopcomputerFailed();
    internal static string get_InvalidRestorePoint();
    internal static string get_RestartNeeded();
    internal static string get_RemoveComputerConfirm();
    internal static string get_InvalidComputerNameFormat();
    internal static string get_InvalidDomainNameFormat();
    internal static string get_ComputerNamesAreEqual();
    internal static string get_ResetComputerMachinePassword();
    internal static string get_SystemRestoreServiceDisabled();
    internal static string get_ProgressActivity();
    internal static string get_ProgressStatusCreatingRestorePoint();
    internal static string get_ProgressStatusCompleted();
    internal static string get_NetworkPathNotFound();
    internal static string get_PrivilegeNotEnabled();
    internal static string get_RestartComputerAction();
    internal static string get_LocalShutdownPrivilege();
    internal static string get_RemoteShutdownPrivilege();
    internal static string get_CannotWaitLocalComputer();
    internal static string get_RestartComputerInvalidParameter();
    internal static string get_RestartMultipleComputersActivity();
    internal static string get_RestartSingleComputerActivity();
    internal static string get_WaitForMultipleComputers();
    internal static string get_VerifyRebootStage();
    internal static string get_WaitForPowerShell();
    internal static string get_WaitForRestartToBegin();
    internal static string get_WaitForWinRM();
    internal static string get_WaitForWMI();
    internal static string get_RestartComplete();
    internal static string get_NoSupportForCombinedServiceType();
    internal static string get_CannotResolveComputerName();
    internal static string get_IncorrectNewNameNumber();
    internal static string get_InvalidNewName();
    internal static string get_NewNameIsOldName();
    internal static string get_ComputerNotInDomain();
    internal static string get_FailToJoinWorkGroup();
    internal static string get_NetworkDown();
    internal static string get_FailToRename();
    internal static string get_AddComputerActionDomain();
    internal static string get_AddComputerActionWorkgroup();
    internal static string get_AddComputerToSameDomain();
    internal static string get_AddComputerToSameWorkgroup();
    internal static string get_FailToRenameAfterJoinWorkgroup();
    internal static string get_FailToSwitchFromDomainToWorkgroup();
    internal static string get_FailToUnjoinDomain();
    internal static string get_FailToConnectToComputer();
    internal static string get_FailToJoinDomainFromWorkgroup();
    internal static string get_FailToJoinNewDomainAfterUnjoinOldDomain();
    internal static string get_FailToRenameAfterJoinDomain();
    internal static string get_InvalidJoinOptions();
    internal static string get_CannotRenameMultipleComputers();
    internal static string get_CannotFindMachineAccountFromDomain();
    internal static string get_CannotFindMachineAccountFromServer();
    internal static string get_FailToGetDomainInformation();
    internal static string get_FailToResetPasswordOnDomain();
    internal static string get_FailToResetPasswordOnLocalMachine();
    internal static string get_NeedAdminPrivilegeToResetPassword();
    internal static string get_ResetComputerNotInDomain();
    internal static string get_TruncateNetBIOSName();
    internal static string get_TruncateNetBIOSNameCaption();
    internal static string get_CannotResolveServerName();
    internal static string get_CannotCreateRestorePointWarning();
    internal static string get_CannotGetOperatingSystemObject();
    internal static string get_RestartComputerSkipped();
    internal static string get_FailToTestSecureChannel();
    internal static string get_RepairSecureChannelFail();
    internal static string get_RepairSecureChannelSucceed();
    internal static string get_SecureChannelAlive();
    internal static string get_SecureChannelBroken();
    internal static string get_TestComputerNotInDomain();
    internal static string get_SystemRestoreNotSupported();
    internal static string get_TimeoutError();
    internal static string get_FailToRetrieveLastRestorePoint();
    internal static string get_InvalidParameterSetAsJob();
    internal static string get_InvalidParameterForCoreClr();
    internal static string get_ShutdownCommandNotFound();
}
[ExtensionAttribute]
internal static class Extensions.CIMExtensions : object {
    [ExtensionAttribute]
internal static IEnumerable`1<CimInstance> QueryInstances(CimSession session, string nameSpace, string query);
    [ExtensionAttribute]
internal static CimInstance QueryFirstInstance(CimSession session, string nameSpace, string query);
    [ExtensionAttribute]
internal static CimInstance QueryFirstInstance(CimSession session, string query);
    [ExtensionAttribute]
internal static T GetFirst(CimSession session, string wmiClassName);
    [ExtensionAttribute]
internal static T GetFirst(CimSession session, string wmiNamespace, string wmiClassName);
    [ExtensionAttribute]
internal static T[] GetAll(CimSession session, string wmiClassName);
    [ExtensionAttribute]
internal static T[] GetAll(CimSession session, string wmiNamespace, string wmiClassName);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class HotFixResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string NoEntriesFound { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_NoEntriesFound();
}
internal class Microsoft.PowerShell.Cim.CimSensitiveValueConverter : object {
    private List`1<IDisposable> _trackedDisposables;
    private static string PSCredentialDelimiter;
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    internal object ConvertFromDotNetToCim(object dotNetObject);
    internal static Type GetCimType(Type dotNetType);
}
internal static class Microsoft.PowerShell.Cim.CimValueConverter : object {
    internal static object ConvertFromDotNetToCim(object dotNetObject);
    internal static object ConvertFromCimToDotNet(object cimObject, Type expectedDotNetType);
    internal static CimType GetCimTypeEnum(Type dotNetType);
    internal static Type GetCimType(Type dotNetType);
    private static Type GetConvertibleCimType(Type dotNetType);
    internal static Type GetElementType(Type arrayType);
    internal static PSInvalidCastException GetInvalidCastException(Exception innerException, string errorId, object sourceValue, string descriptionOfTargetType);
    [ConditionalAttribute("DEBUG")]
internal static void AssertIntrinsicCimValue(object value);
    [ConditionalAttribute("DEBUG")]
internal static void AssertIntrinsicCimType(Type type);
}
internal abstract class Microsoft.PowerShell.Cmdletization.Cim.CimChildJobBase`1 : StartableJob {
    private static long s_globalJobNumberCounter;
    private long _myJobNumber;
    private static string CIMJobType;
    private CimJobContext _jobContext;
    private CimSensitiveValueConverter _cimSensitiveValueConverter;
    private static Random s_globalRandom;
    private Random _random;
    private int _sleepAndRetryDelayRangeMs;
    private int _sleepAndRetryExtraDelayMs;
    private static int MaxRetryDelayMs;
    private static int MinRetryDelayMs;
    private Timer _sleepAndRetryTimer;
    private Lazy`1<CimCustomOptionsDictionary> _jobSpecificCustomOptions;
    private CancellationTokenSource _cancellationTokenSource;
    private object _jobStateLock;
    private bool _jobHadErrors;
    private bool _jobWasStarted;
    private bool _jobWasStopped;
    private bool _alreadyReachedCompletedState;
    private ConcurrentDictionary`2<int, ProgressRecord> _activityIdToLastProgressRecord;
    private bool _userWasPromptedForContinuationOfProcessing;
    private bool _userRespondedYesToAtLeastOneShouldProcess;
    internal CimJobContext JobContext { get; }
    internal CimSensitiveValueConverter CimSensitiveValueConverter { get; }
    public string Location { get; }
    public string StatusMessage { get; }
    public bool HasMoreData { get; }
    internal string Description { get; }
    internal string FailSafeDescription { get; }
    internal bool JobHadErrors { get; }
    internal bool DidUserSuppressTheOperation { get; }
    internal CimChildJobBase`1(CimJobContext jobContext);
    private static CimChildJobBase`1();
    internal CimJobContext get_JobContext();
    internal CimSensitiveValueConverter get_CimSensitiveValueConverter();
    internal abstract virtual IObservable`1<T> GetCimOperation();
    public abstract virtual void OnNext(T item);
    private static bool IsWsManQuotaReached(Exception exception);
    public virtual void OnError(Exception exception);
    public virtual void OnCompleted();
    private void SleepAndRetry_OnWakeup(object state);
    private void SleepAndRetry();
    public virtual string get_Location();
    public virtual string get_StatusMessage();
    public virtual bool get_HasMoreData();
    internal void WriteVerboseStartOfCimOperation();
    internal virtual void StartJob();
    internal string GetDescription();
    internal abstract virtual string get_Description();
    internal abstract virtual string get_FailSafeDescription();
    internal void ExceptionSafeWrapper(Action action);
    internal virtual string GetProviderVersionExpectedByJob();
    internal CimOperationOptions CreateOperationOptions();
    internal abstract virtual CimCustomOptionsDictionary CalculateJobSpecificCustomOptions();
    private CimCustomOptionsDictionary GetJobSpecificCustomOptions();
    public virtual void StopJob();
    internal bool get_JobHadErrors();
    internal void ReportJobFailure(IContainsErrorRecord exception);
    internal virtual void WriteWarning(string message);
    internal virtual void WriteVerbose(string message);
    internal virtual void WriteDebug(string message);
    internal void SetCompletedJobState(JobState state, Exception reason);
    internal virtual void WriteProgress(ProgressRecord progressRecord);
    internal void FinishProgressReporting();
    private void WriteProgressCallback(string activity, string currentOperation, string statusDescription, UInt32 percentageCompleted, UInt32 secondsRemaining);
    private void WriteMessageCallback(UInt32 channel, string message);
    private CimResponseType BlockingWriteError(ErrorRecord errorRecord);
    private CimResponseType WriteErrorCallback(CimInstance cimError);
    internal bool get_DidUserSuppressTheOperation();
    internal CimResponseType ShouldProcess(string target, string action);
    internal CimResponseType ShouldProcess(string verboseDescription, string verboseWarning, string caption);
    private CimResponseType PromptUserCallback(string message, CimPromptType promptType);
    internal static bool IsShowComputerNameMarkerPresent(CimInstance cimInstance);
    internal static void AddShowComputerNameMarker(PSObject pso);
    internal virtual void WriteObject(object outputObject);
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private void <OnCompleted>b__15_0();
    [CompilerGeneratedAttribute]
private void <SleepAndRetry_OnWakeup>b__23_0();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void <StartJob>b__32_0(object <p0>);
    [CompilerGeneratedAttribute]
private void <StartJob>b__32_1();
}
public class Microsoft.PowerShell.Cmdletization.Cim.CimCmdletAdapter : SessionBasedCmdletAdapter`2<CimInstance, CimSession> {
    internal static string CreateInstance_MethodName;
    internal static string ModifyInstance_MethodName;
    internal static string DeleteInstance_MethodName;
    private bool _throttleLimitIsSetExplicitly;
    private CimCmdletInvocationContext _cmdletInvocationContext;
    private CimCmdletDefinitionContext _cmdletDefinitionContext;
    private static long s_jobNumber;
    private static ConditionalWeakTable`2<CimInstance, CimSession> s_cimInstanceToSessionOfOrigin;
    private RuntimeDefinedParameterDictionary _dynamicParameters;
    private static string CimNamespaceParameter;
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public CimSession[] CimSession { get; public set; }
    [ParameterAttribute]
public int ThrottleLimit { get; public set; }
    internal CimCmdletInvocationContext CmdletInvocationContext { get; }
    internal CimCmdletDefinitionContext CmdletDefinitionContext { get; }
    internal InvocationInfo CmdletInvocationInfo { get; }
    protected CimSession DefaultSession { get; }
    private static CimCmdletAdapter();
    public CimSession[] get_CimSession();
    public void set_CimSession(CimSession[] value);
    public virtual int get_ThrottleLimit();
    public virtual void set_ThrottleLimit(int value);
    public virtual QueryBuilder GetQueryBuilder();
    internal CimCmdletInvocationContext get_CmdletInvocationContext();
    internal CimCmdletDefinitionContext get_CmdletDefinitionContext();
    internal InvocationInfo get_CmdletInvocationInfo();
    protected virtual string GenerateParentJobName();
    protected virtual CimSession get_DefaultSession();
    private CimJobContext CreateJobContext(CimSession session, object targetObject);
    internal virtual StartableJob CreateQueryJob(CimSession session, QueryBuilder baseQuery);
    internal virtual StartableJob CreateInstanceMethodInvocationJob(CimSession session, CimInstance objectInstance, MethodInvocationInfo methodInvocationInfo, bool passThru);
    private bool IsSupportedSession(CimSession cimSession, TerminatingErrorTracker terminatingErrorTracker);
    internal virtual StartableJob CreateStaticMethodInvocationJob(CimSession session, MethodInvocationInfo methodInvocationInfo);
    internal static void AssociateSessionOfOriginWithInstance(CimInstance cimInstance, CimSession sessionOfOrigin);
    internal static CimSession GetSessionOfOriginFromCimInstance(CimInstance instance);
    internal virtual CimSession GetSessionOfOriginFromInstance(CimInstance instance);
    private string GetDynamicNamespace();
    private sealed virtual override object System.Management.Automation.IDynamicParameters.GetDynamicParameters();
}
internal class Microsoft.PowerShell.Cmdletization.Cim.CimCmdletDefinitionContext : object {
    [CompilerGeneratedAttribute]
private string <CmdletizationClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CmdletizationClassVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <CmdletizationModuleVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportsShouldProcess>k__BackingField;
    private IDictionary`2<string, string> _privateData;
    private static string QueryLanguageKey;
    private Nullable`1<bool> _useEnumerateInstancesInsteadOfWql;
    private static int FallbackDefaultThrottleLimit;
    private Uri _resourceUri;
    private bool _resourceUriHasBeenCalculated;
    private Nullable`1<CimOperationFlags> _schemaConformanceLevel;
    public string CmdletizationClassName { get; }
    public string CmdletizationClassVersion { get; }
    public Version CmdletizationModuleVersion { get; }
    public bool SupportsShouldProcess { get; }
    public bool UseEnumerateInstancesInsteadOfWql { get; }
    public int DefaultThrottleLimit { get; }
    public bool ExposeCimNamespaceParameter { get; }
    public bool ClientSideWriteVerbose { get; }
    public bool ClientSideShouldProcess { get; }
    public Uri ResourceUri { get; }
    public bool SkipTestConnection { get; }
    public CimOperationFlags SchemaConformanceLevel { get; }
    internal CimCmdletDefinitionContext(string cmdletizationClassName, string cmdletizationClassVersion, Version cmdletizationModuleVersion, bool supportsShouldProcess, IDictionary`2<string, string> privateData);
    [CompilerGeneratedAttribute]
public string get_CmdletizationClassName();
    [CompilerGeneratedAttribute]
public string get_CmdletizationClassVersion();
    [CompilerGeneratedAttribute]
public Version get_CmdletizationModuleVersion();
    [CompilerGeneratedAttribute]
public bool get_SupportsShouldProcess();
    public bool get_UseEnumerateInstancesInsteadOfWql();
    public int get_DefaultThrottleLimit();
    public bool get_ExposeCimNamespaceParameter();
    public bool get_ClientSideWriteVerbose();
    public bool get_ClientSideShouldProcess();
    public Uri get_ResourceUri();
    public bool get_SkipTestConnection();
    public CimOperationFlags get_SchemaConformanceLevel();
}
internal class Microsoft.PowerShell.Cmdletization.Cim.CimCmdletInvocationContext : object {
    [CompilerGeneratedAttribute]
private CimCmdletDefinitionContext <CmdletDefinitionContext>k__BackingField;
    [CompilerGeneratedAttribute]
private InvocationInfo <CmdletInvocationInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private ShouldProcessPossibleOptimization <ShouldProcessOptimization>k__BackingField;
    [CompilerGeneratedAttribute]
private ActionPreference <ErrorActionPreference>k__BackingField;
    [CompilerGeneratedAttribute]
private ActionPreference <WarningActionPreference>k__BackingField;
    [CompilerGeneratedAttribute]
private ActionPreference <VerboseActionPreference>k__BackingField;
    [CompilerGeneratedAttribute]
private ActionPreference <DebugActionPreference>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NamespaceOverride>k__BackingField;
    private Lazy`1<CimSession> _defaultCimSession;
    public CimCmdletDefinitionContext CmdletDefinitionContext { get; }
    public InvocationInfo CmdletInvocationInfo { get; }
    public ShouldProcessPossibleOptimization ShouldProcessOptimization { get; }
    public ActionPreference ErrorActionPreference { get; }
    public ActionPreference WarningActionPreference { get; }
    public ActionPreference VerboseActionPreference { get; }
    public ActionPreference DebugActionPreference { get; }
    public string NamespaceOverride { get; }
    public bool IsRunningInBackground { get; }
    public bool ShowComputerName { get; }
    internal CimCmdletInvocationContext(CimCmdletDefinitionContext cmdletDefinitionContext, Cmdlet cmdlet, string namespaceOverride);
    private static void WarnAboutUnsupportedActionPreferences(Cmdlet cmdlet, ActionPreference effectiveActionPreference, string nameOfCommandLineParameter, Func`1<string> inquireMessageGetter, Func`1<string> stopMessageGetter);
    [CompilerGeneratedAttribute]
public CimCmdletDefinitionContext get_CmdletDefinitionContext();
    [CompilerGeneratedAttribute]
public InvocationInfo get_CmdletInvocationInfo();
    [CompilerGeneratedAttribute]
public ShouldProcessPossibleOptimization get_ShouldProcessOptimization();
    [CompilerGeneratedAttribute]
public ActionPreference get_ErrorActionPreference();
    [CompilerGeneratedAttribute]
public ActionPreference get_WarningActionPreference();
    [CompilerGeneratedAttribute]
public ActionPreference get_VerboseActionPreference();
    [CompilerGeneratedAttribute]
public ActionPreference get_DebugActionPreference();
    [CompilerGeneratedAttribute]
public string get_NamespaceOverride();
    public bool get_IsRunningInBackground();
    public bool get_ShowComputerName();
    private static CimSession CreateDefaultCimSession();
    public CimSession GetDefaultCimSession();
}
internal class Microsoft.PowerShell.Cmdletization.Cim.CimCustomOptionsDictionary : object {
    private IDictionary`2<string, object> _dict;
    private object _dictModificationLock;
    private static ConditionalWeakTable`2<CimInstance, CimCustomOptionsDictionary> s_cimInstanceToCustomOptions;
    private CimCustomOptionsDictionary(IEnumerable`1<KeyValuePair`2<string, object>> wrappedDictionary);
    private static CimCustomOptionsDictionary();
    private IEnumerable`1<KeyValuePair`2<string, object>> GetSnapshot();
    internal static CimCustomOptionsDictionary Create(IEnumerable`1<KeyValuePair`2<string, object>> wrappedDictionary);
    internal static void AssociateCimInstanceWithCustomOptions(CimInstance cimInstance, CimCustomOptionsDictionary newCustomOptions);
    internal static CimCustomOptionsDictionary MergeOptions(CimCustomOptionsDictionary optionsFromCommandLine, CimInstance instanceRelatedToThisOperation);
    internal static CimCustomOptionsDictionary MergeOptions(CimCustomOptionsDictionary optionsFromCommandLine, IEnumerable`1<CimInstance> instancesRelatedToThisOperation);
    internal void Apply(CimOperationOptions cimOperationOptions, CimSensitiveValueConverter cimSensitiveValueConverter);
}
internal class Microsoft.PowerShell.Cmdletization.Cim.CimJobContext : object {
    [CompilerGeneratedAttribute]
private CimCmdletInvocationContext <CmdletInvocationContext>k__BackingField;
    [CompilerGeneratedAttribute]
private CimSession <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private object <TargetObject>k__BackingField;
    public CimCmdletInvocationContext CmdletInvocationContext { get; }
    public CimSession Session { get; }
    public object TargetObject { get; }
    public string ClassName { get; }
    public string ClassNameOrNullIfResourceUriIsUsed { get; }
    public string Namespace { get; }
    public InvocationInfo CmdletInvocationInfo { get; }
    public string CmdletizationClassName { get; }
    public Version CmdletizationModuleVersion { get; }
    public ActionPreference ErrorActionPreference { get; }
    public ActionPreference WarningActionPreference { get; }
    public ActionPreference VerboseActionPreference { get; }
    public ActionPreference DebugActionPreference { get; }
    public bool IsRunningInBackground { get; }
    public ShouldProcessPossibleOptimization ShouldProcessOptimization { get; }
    public bool ShowComputerName { get; }
    public bool SupportsShouldProcess { get; }
    internal CimJobContext(CimCmdletInvocationContext cmdletInvocationContext, CimSession session, object targetObject);
    [CompilerGeneratedAttribute]
public CimCmdletInvocationContext get_CmdletInvocationContext();
    [CompilerGeneratedAttribute]
public CimSession get_Session();
    [CompilerGeneratedAttribute]
public object get_TargetObject();
    public string get_ClassName();
    public string get_ClassNameOrNullIfResourceUriIsUsed();
    public string get_Namespace();
    private static void ExtractCimNamespaceAndClassName(string cmdletizationClassName, String& cimNamespace, String& cimClassName);
    private static string GetCimClassName(string cmdletizationClassName);
    private static string GetCimNamespace(string cmdletizationClassName);
    internal string PrependComputerNameToMessage(string message);
    public InvocationInfo get_CmdletInvocationInfo();
    public string get_CmdletizationClassName();
    public Version get_CmdletizationModuleVersion();
    public ActionPreference get_ErrorActionPreference();
    public ActionPreference get_WarningActionPreference();
    public ActionPreference get_VerboseActionPreference();
    public ActionPreference get_DebugActionPreference();
    public bool get_IsRunningInBackground();
    public ShouldProcessPossibleOptimization get_ShouldProcessOptimization();
    public bool get_ShowComputerName();
    public bool get_SupportsShouldProcess();
}
public class Microsoft.PowerShell.Cmdletization.Cim.CimJobException : SystemException {
    private ErrorRecord _errorRecord;
    public ErrorRecord ErrorRecord { get; }
    internal bool IsTerminatingError { get; }
    public CimJobException(string message);
    public CimJobException(string message, Exception inner);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected CimJobException(SerializationInfo info, StreamingContext context);
    internal static CimJobException CreateFromCimException(string jobDescription, CimJobContext jobContext, CimException cimException);
    internal static CimJobException CreateFromAnyException(string jobDescription, CimJobContext jobContext, Exception inner);
    internal static CimJobException CreateWithFullControl(CimJobContext jobContext, string message, string errorId, ErrorCategory errorCategory, Exception inner);
    internal static CimJobException CreateWithoutJobContext(string message, string errorId, ErrorCategory errorCategory, Exception inner);
    internal static CimJobException CreateFromMethodErrorCode(string jobDescription, CimJobContext jobContext, string methodName, string errorCodeFromMethod);
    private static string BuildErrorMessage(string jobDescription, CimJobContext jobContext, string errorMessage);
    private void InitializeErrorRecordCore(CimJobContext jobContext, Exception exception, string errorId, ErrorCategory errorCategory);
    private void InitializeErrorRecord(CimJobContext jobContext, string errorId, ErrorCategory errorCategory);
    private void InitializeErrorRecord(CimJobContext jobContext, CimException cimException);
    private static ErrorCategory ConvertCimExceptionToErrorCategory(CimException cimException);
    private static ErrorCategory ConvertCimNativeErrorCodeToErrorCategory(NativeErrorCode nativeErrorCode);
    private static ErrorCategory ConvertCimErrorToErrorCategory(CimInstance cimError);
    public sealed virtual ErrorRecord get_ErrorRecord();
    internal bool get_IsTerminatingError();
}
internal static class Microsoft.PowerShell.Cmdletization.Cim.CimOperationOptionsHelper : object {
    internal static void SetCustomOptions(CimOperationOptions operationOptions, IEnumerable`1<KeyValuePair`2<string, object>> customOptions, CimSensitiveValueConverter cimSensitiveValueConverter);
    internal static void SetCustomOption(CimOperationOptions operationOptions, string optionName, object optionValue, CimSensitiveValueConverter cimSensitiveValueConverter);
}
internal class Microsoft.PowerShell.Cmdletization.Cim.CimQuery : QueryBuilder {
    private StringBuilder _wqlCondition;
    private CimInstance _associatedObject;
    private string _associationName;
    private string _resultRole;
    private string _sourceRole;
    internal Dictionary`2<string, object> queryOptions;
    [CompilerGeneratedAttribute]
private ClientSideQuery <ClientSideQuery>k__BackingField;
    internal ClientSideQuery ClientSideQuery { get; }
    [CompilerGeneratedAttribute]
internal ClientSideQuery get_ClientSideQuery();
    private void AddWqlCondition(string condition);
    private static string ObjectToWqlLiteral(object o);
    private static string WildcardToWqlLikeOperand(WildcardPattern wildcardPattern, Boolean& needsClientSideFiltering);
    private static string GetMatchConditionForEqualityOperator(string propertyName, object propertyValue);
    private static string GetMatchConditionForLikeOperator(string propertyName, object propertyValue);
    private static string GetMatchCondition(string propertyName, IEnumerable propertyValues, bool wildcardsEnabled);
    public virtual void FilterByProperty(string propertyName, IEnumerable allowedPropertyValues, bool wildcardsEnabled, BehaviorOnNoMatch behaviorOnNoMatch);
    public virtual void ExcludeByProperty(string propertyName, IEnumerable excludedPropertyValues, bool wildcardsEnabled, BehaviorOnNoMatch behaviorOnNoMatch);
    public virtual void FilterByMinPropertyValue(string propertyName, object minPropertyValue, BehaviorOnNoMatch behaviorOnNoMatch);
    public virtual void FilterByMaxPropertyValue(string propertyName, object maxPropertyValue, BehaviorOnNoMatch behaviorOnNoMatch);
    public virtual void FilterByAssociatedInstance(object associatedInstance, string associationName, string sourceRole, string resultRole, BehaviorOnNoMatch behaviorOnNoMatch);
    public virtual void AddQueryOption(string optionName, object optionValue);
    internal StartableJob GetQueryJob(CimJobContext jobContext);
    internal bool IsMatchingResult(CimInstance result);
    internal IEnumerable`1<NotFoundError> GenerateNotFoundErrors();
    private sealed virtual override CimSession Microsoft.PowerShell.Cmdletization.ISessionBoundQueryBuilder<Microsoft.Management.Infrastructure.CimSession>.GetTargetSession();
    public virtual string ToString();
}
internal class Microsoft.PowerShell.Cmdletization.Cim.ClientSideQuery : QueryBuilder {
    private int _numberOfResultsFromMi;
    private int _numberOfMatchingResults;
    private List`1<CimInstanceFilterBase> _filters;
    private object _myLock;
    internal bool IsResultMatchingClientSideQuery(CimInstance result);
    internal IEnumerable`1<NotFoundError> GenerateNotFoundErrors();
    public virtual void FilterByProperty(string propertyName, IEnumerable allowedPropertyValues, bool wildcardsEnabled, BehaviorOnNoMatch behaviorOnNoMatch);
    public virtual void ExcludeByProperty(string propertyName, IEnumerable excludedPropertyValues, bool wildcardsEnabled, BehaviorOnNoMatch behaviorOnNoMatch);
    public virtual void FilterByMinPropertyValue(string propertyName, object minPropertyValue, BehaviorOnNoMatch behaviorOnNoMatch);
    public virtual void FilterByMaxPropertyValue(string propertyName, object maxPropertyValue, BehaviorOnNoMatch behaviorOnNoMatch);
    public virtual void FilterByAssociatedInstance(object associatedInstance, string associationName, string sourceRole, string resultRole, BehaviorOnNoMatch behaviorOnNoMatch);
}
internal class Microsoft.PowerShell.Cmdletization.Cim.CreateInstanceJob : PropertySettingJob`1<CimInstance> {
    private CimInstance _resultFromCreateInstance;
    private CimInstance _resultFromGetInstance;
    internal object PassThruObject { get; }
    internal CreateInstanceJob(CimJobContext jobContext, MethodInvocationInfo methodInvocationInfo);
    private static CimInstance GetEmptyInstance(CimJobContext jobContext);
    private IObservable`1<CimInstance> GetCreateInstanceOperation();
    private IObservable`1<CimInstance> GetGetInstanceOperation();
    internal virtual IObservable`1<CimInstance> GetCimOperation();
    public virtual void OnNext(CimInstance item);
    public virtual void OnError(Exception exception);
    public virtual void OnCompleted();
    internal virtual object get_PassThruObject();
}
internal class Microsoft.PowerShell.Cmdletization.Cim.DeleteInstanceJob : MethodInvocationJobBase`1<object> {
    private CimInstance _objectToDelete;
    internal object PassThruObject { get; }
    internal DeleteInstanceJob(CimJobContext jobContext, bool passThru, CimInstance objectToDelete, MethodInvocationInfo methodInvocationInfo);
    internal virtual IObservable`1<object> GetCimOperation();
    public virtual void OnNext(object item);
    internal virtual object get_PassThruObject();
    internal virtual CimCustomOptionsDictionary CalculateJobSpecificCustomOptions();
}
internal class Microsoft.PowerShell.Cmdletization.Cim.EnumerateAssociatedInstancesJob : QueryJobBase {
    private CimInstance _associatedObject;
    private string _associationName;
    private string _resultRole;
    private string _sourceRole;
    internal string Description { get; }
    internal string FailSafeDescription { get; }
    internal EnumerateAssociatedInstancesJob(CimJobContext jobContext, CimQuery cimQuery, CimInstance associatedObject, string associationName, string resultRole, string sourceRole);
    internal virtual IObservable`1<CimInstance> GetCimOperation();
    internal virtual string get_Description();
    internal virtual string get_FailSafeDescription();
    internal virtual CimCustomOptionsDictionary CalculateJobSpecificCustomOptions();
    internal virtual void WriteObject(object outputObject);
    internal virtual string GetProviderVersionExpectedByJob();
}
internal abstract class Microsoft.PowerShell.Cmdletization.Cim.ExtrinsicMethodInvocationJob : MethodInvocationJobBase`1<CimMethodResultBase> {
    internal ExtrinsicMethodInvocationJob(CimJobContext jobContext, bool passThru, string methodSubject, MethodInvocationInfo methodInvocationInfo);
    internal CimMethodParametersCollection GetCimMethodParametersCollection();
    private void ProcessOutParameter(CimMethodResult methodResult, MethodParameter methodParameter, IDictionary`2<string, MethodParameter> cmdletOutput);
    private void OnNext(CimMethodResult methodResult);
    private void OnNext(CimMethodStreamedResult streamedResult);
    private void WriteObject(object cmdletOutput, MethodParameter methodParameter);
    public virtual void OnNext(CimMethodResultBase item);
}
internal class Microsoft.PowerShell.Cmdletization.Cim.InstanceMethodInvocationJob : ExtrinsicMethodInvocationJob {
    private CimInstance _targetInstance;
    internal object PassThruObject { get; }
    internal InstanceMethodInvocationJob(CimJobContext jobContext, bool passThru, CimInstance targetInstance, MethodInvocationInfo methodInvocationInfo);
    internal virtual IObservable`1<CimMethodResultBase> GetCimOperation();
    internal virtual object get_PassThruObject();
    internal virtual CimCustomOptionsDictionary CalculateJobSpecificCustomOptions();
}
internal abstract class Microsoft.PowerShell.Cmdletization.Cim.MethodInvocationJobBase`1 : CimChildJobBase`1<T> {
    private bool _passThru;
    private MethodInvocationInfo _methodInvocationInfo;
    private static string CustomOperationOptionPrefix;
    [CompilerGeneratedAttribute]
private string <MethodSubject>k__BackingField;
    internal string MethodName { get; }
    internal string MethodSubject { get; }
    internal object PassThruObject { get; }
    internal string Description { get; }
    internal string FailSafeDescription { get; }
    internal MethodInvocationJobBase`1(CimJobContext jobContext, bool passThru, string methodSubject, MethodInvocationInfo methodInvocationInfo);
    internal string get_MethodName();
    private IEnumerable`1<MethodParameter> GetMethodInputParametersCore(Func`2<MethodParameter, bool> filter);
    internal IEnumerable`1<MethodParameter> GetMethodInputParameters();
    internal IEnumerable`1<CimInstance> GetCimInstancesFromArguments();
    internal virtual CimCustomOptionsDictionary CalculateJobSpecificCustomOptions();
    internal IEnumerable`1<MethodParameter> GetMethodOutputParameters();
    [CompilerGeneratedAttribute]
internal string get_MethodSubject();
    internal bool ShouldProcess();
    internal abstract virtual object get_PassThruObject();
    internal bool IsPassThruObjectNeeded();
    public virtual void OnCompleted();
    internal virtual string get_Description();
    internal virtual string get_FailSafeDescription();
    [CompilerGeneratedAttribute]
private void <OnCompleted>b__18_0();
}
internal class Microsoft.PowerShell.Cmdletization.Cim.ModifyInstanceJob : PropertySettingJob`1<CimInstance> {
    private CimInstance _resultFromModifyInstance;
    private bool _resultFromModifyInstanceHasBeenPassedThru;
    private CimInstance _originalInstance;
    private CimInstance _temporaryInstance;
    internal object PassThruObject { get; }
    internal ModifyInstanceJob(CimJobContext jobContext, bool passThru, CimInstance managementObject, MethodInvocationInfo methodInvocationInfo);
    internal virtual IObservable`1<CimInstance> GetCimOperation();
    public virtual void OnNext(CimInstance item);
    public virtual void OnCompleted();
    internal virtual object get_PassThruObject();
    internal virtual CimCustomOptionsDictionary CalculateJobSpecificCustomOptions();
    protected virtual void Dispose(bool disposing);
}
internal abstract class Microsoft.PowerShell.Cmdletization.Cim.PropertySettingJob`1 : MethodInvocationJobBase`1<T> {
    internal PropertySettingJob`1(CimJobContext jobContext, bool passThru, CimInstance objectToModify, MethodInvocationInfo methodInvocationInfo);
    internal void ModifyLocalCimInstance(CimInstance cimInstance);
}
internal class Microsoft.PowerShell.Cmdletization.Cim.QueryInstancesJob : QueryJobBase {
    private string _wqlQuery;
    private bool _useEnumerateInstances;
    internal string Description { get; }
    internal string FailSafeDescription { get; }
    internal QueryInstancesJob(CimJobContext jobContext, CimQuery cimQuery, string wqlCondition);
    internal virtual IObservable`1<CimInstance> GetCimOperation();
    internal virtual string get_Description();
    internal virtual string get_FailSafeDescription();
}
internal abstract class Microsoft.PowerShell.Cmdletization.Cim.QueryJobBase : CimChildJobBase`1<CimInstance> {
    private CimQuery _cimQuery;
    internal QueryJobBase(CimJobContext jobContext, CimQuery cimQuery);
    public virtual void OnNext(CimInstance item);
    public virtual void OnCompleted();
    internal virtual CimCustomOptionsDictionary CalculateJobSpecificCustomOptions();
    [CompilerGeneratedAttribute]
private void <OnCompleted>b__3_0();
}
internal class Microsoft.PowerShell.Cmdletization.Cim.StaticMethodInvocationJob : ExtrinsicMethodInvocationJob {
    internal object PassThruObject { get; }
    internal StaticMethodInvocationJob(CimJobContext jobContext, MethodInvocationInfo methodInvocationInfo);
    internal virtual IObservable`1<CimMethodResultBase> GetCimOperation();
    internal virtual object get_PassThruObject();
    internal virtual CimCustomOptionsDictionary CalculateJobSpecificCustomOptions();
}
internal class Microsoft.PowerShell.Cmdletization.Cim.TerminatingErrorTracker : object {
    private static ConditionalWeakTable`2<InvocationInfo, TerminatingErrorTracker> s_invocationToTracker;
    private int _numberOfSessions;
    private int _numberOfReportedSessionTerminatingErrors;
    private ConcurrentDictionary`2<CimSession, bool> _sessionToIsConnected;
    private ConcurrentDictionary`2<CimSession, bool> _sessionToIsTerminated;
    private TerminatingErrorTracker(int numberOfSessions);
    private static TerminatingErrorTracker();
    private static int GetNumberOfSessions(InvocationInfo invocationInfo);
    internal static TerminatingErrorTracker GetTracker(InvocationInfo invocationInfo, bool isStaticCmdlet);
    internal static TerminatingErrorTracker GetTracker(InvocationInfo invocationInfo);
    internal void MarkSessionAsConnected(CimSession connectedSession);
    internal bool DidSessionAlreadyPassedConnectivityTest(CimSession session);
    internal Exception GetExceptionIfBrokenSession(CimSession potentiallyBrokenSession, bool skipTestConnection, Boolean& sessionWasAlreadyTerminated);
    internal void MarkSessionAsTerminated(CimSession terminatedSession, Boolean& sessionWasAlreadyTerminated);
    internal bool IsSessionTerminated(CimSession session);
    internal CmdletMethodInvoker`1<bool> GetErrorReportingDelegate(ErrorRecord errorRecord);
}
internal interface Microsoft.PowerShell.Cmdletization.ISessionBoundQueryBuilder`1 {
    public abstract virtual TSession GetTargetSession();
}
public abstract class Microsoft.PowerShell.Cmdletization.SessionBasedCmdletAdapter`2 : CmdletAdapter`1<TObjectInstance> {
    private static string CIMJobType;
    private bool _disposed;
    private TSession[] _session;
    private bool _sessionWasSpecified;
    private bool _asJob;
    [CompilerGeneratedAttribute]
private int <ThrottleLimit>k__BackingField;
    private ThrottlingJob _parentJob;
    protected TSession[] Session { get; protected set; }
    [ParameterAttribute]
public SwitchParameter AsJob { get; public set; }
    [ParameterAttribute]
public int ThrottleLimit { get; public set; }
    protected TSession DefaultSession { get; }
    internal PSModuleInfo PSModuleInfo { get; }
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected TSession[] get_Session();
    protected void set_Session(TSession[] value);
    public SwitchParameter get_AsJob();
    public void set_AsJob(SwitchParameter value);
    [CompilerGeneratedAttribute]
public virtual int get_ThrottleLimit();
    [CompilerGeneratedAttribute]
public virtual void set_ThrottleLimit(int value);
    internal abstract virtual StartableJob CreateQueryJob(TSession session, QueryBuilder query);
    private StartableJob DoCreateQueryJob(TSession sessionForJob, QueryBuilder query, Action`2<TSession, TObjectInstance> actionAgainstResults);
    internal abstract virtual StartableJob CreateInstanceMethodInvocationJob(TSession session, TObjectInstance objectInstance, MethodInvocationInfo methodInvocationInfo, bool passThru);
    private StartableJob DoCreateInstanceMethodInvocationJob(TSession sessionForJob, TObjectInstance objectInstance, MethodInvocationInfo methodInvocationInfo, bool passThru, bool asJob);
    internal abstract virtual StartableJob CreateStaticMethodInvocationJob(TSession session, MethodInvocationInfo methodInvocationInfo);
    private StartableJob DoCreateStaticMethodInvocationJob(TSession sessionForJob, MethodInvocationInfo methodInvocationInfo);
    private static void HandleJobOutput(Job job, TSession sessionForJob, bool discardNonPipelineResults, Action`1<PSObject> outputAction);
    internal virtual TSession GetSessionOfOriginFromInstance(TObjectInstance instance);
    protected abstract virtual TSession get_DefaultSession();
    protected abstract virtual string GenerateParentJobName();
    private static void DiscardJobOutputs(PSDataCollection`1<T> psDataCollection);
    private static void DiscardJobOutputs(Job job, JobOutputs<TObjectInstance, TSession> jobOutputsToDiscard);
    public virtual void ProcessRecord(QueryBuilder query);
    public virtual void ProcessRecord(QueryBuilder query, MethodInvocationInfo methodInvocationInfo, bool passThru);
    private IEnumerable`1<TSession> GetSessionsToActAgainst(TObjectInstance objectInstance);
    private TSession GetSessionAssociatedWithPipelineObject();
    private IEnumerable`1<TSession> GetSessionsToActAgainst(QueryBuilder queryBuilder);
    private IEnumerable`1<TSession> GetSessionsToActAgainst(MethodInvocationInfo methodInvocationInfo);
    internal PSModuleInfo get_PSModuleInfo();
    private TSession GetImpliedSession();
    public virtual void ProcessRecord(TObjectInstance objectInstance, MethodInvocationInfo methodInvocationInfo, bool passThru);
    public virtual void ProcessRecord(MethodInvocationInfo methodInvocationInfo);
    public virtual void BeginProcessing();
    public virtual void EndProcessing();
    public virtual void StopProcessing();
}
[CmdletAttribute("Add", "Content")]
public class Microsoft.PowerShell.Commands.AddContentCommand : WriteContentCommandBase {
    internal virtual void SeekContentPosition(List`1<ContentHolder> contentHolders);
    internal virtual bool CallShouldProcess(string path);
}
internal static class Microsoft.PowerShell.Commands.CIMHelper : object {
    internal static string DefaultNamespace;
    internal static string DeviceGuardNamespace;
    internal static string MicrosoftNetworkAdapterNamespace;
    internal static string DefaultQueryDialect;
    internal static string WqlQueryAll(string from);
    internal static T GetFirst(CimSession session, string nameSpace, string wmiClassName);
    internal static T[] GetAll(CimSession session, string nameSpace, string wmiClassName);
    internal static T[] GetAll(CimSession session, string wmiClassName);
    internal static void SetObjectDataMember(object obj, BindingFlags binding, CimProperty cimProperty);
    internal static void SetObjectDataMembers(object obj, BindingFlags binding, CimInstance instance);
    internal static string EscapePath(string path);
}
[CmdletAttribute("Clear", "Content")]
public class Microsoft.PowerShell.Commands.ClearContentCommand : ContentCommandBase {
    protected bool ProviderSupportsShouldProcess { get; }
    protected virtual void ProcessRecord();
    protected virtual bool get_ProviderSupportsShouldProcess();
    internal virtual object GetDynamicParameters(CmdletProviderContext context);
}
[CmdletAttribute("Clear", "Item")]
public class Microsoft.PowerShell.Commands.ClearItemCommand : CoreCommandWithCredentialsBase {
    private static string PathParameterSet;
    private static string LiteralPathParameterSet;
    private String[] _paths;
    [ParameterAttribute]
public String[] Path { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] LiteralPath { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    [ParameterAttribute]
public string Filter { get; public set; }
    [ParameterAttribute]
public String[] Include { get; public set; }
    [ParameterAttribute]
public String[] Exclude { get; public set; }
    protected bool ProviderSupportsShouldProcess { get; }
    public String[] get_Path();
    public void set_Path(String[] value);
    public String[] get_LiteralPath();
    public void set_LiteralPath(String[] value);
    public virtual SwitchParameter get_Force();
    public virtual void set_Force(SwitchParameter value);
    public virtual string get_Filter();
    public virtual void set_Filter(string value);
    public virtual String[] get_Include();
    public virtual void set_Include(String[] value);
    public virtual String[] get_Exclude();
    public virtual void set_Exclude(String[] value);
    internal virtual object GetDynamicParameters(CmdletProviderContext context);
    protected virtual bool get_ProviderSupportsShouldProcess();
    protected virtual void ProcessRecord();
}
[CmdletAttribute("Clear", "ItemProperty")]
public class Microsoft.PowerShell.Commands.ClearItemPropertyCommand : PassThroughItemPropertyCommandBase {
    private string _property;
    [ParameterAttribute]
public String[] Path { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] LiteralPath { get; public set; }
    [ParameterAttribute]
public string Name { get; public set; }
    public String[] get_Path();
    public void set_Path(String[] value);
    public String[] get_LiteralPath();
    public void set_LiteralPath(String[] value);
    public string get_Name();
    public void set_Name(string value);
    internal virtual object GetDynamicParameters(CmdletProviderContext context);
    protected virtual void ProcessRecord();
}
public class Microsoft.PowerShell.Commands.CommandLineCmdletBase : PSCmdlet {
    [NullableAttribute("2")]
private Process _process;
    [NullableAttribute("2")]
private static string shutdownPath;
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual void StopProcessing();
    [NullableContextAttribute("1")]
protected void RunShutdown(string args);
}
public class Microsoft.PowerShell.Commands.ContentCommandBase : CoreCommandWithCredentialsBase {
    [CompilerGeneratedAttribute]
private String[] <Path>k__BackingField;
    internal List`1<ContentHolder> contentStreams;
    private ContentPathsCache _currentContentItem;
    [ParameterAttribute]
public String[] Path { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] LiteralPath { get; public set; }
    [ParameterAttribute]
public string Filter { get; public set; }
    [ParameterAttribute]
public String[] Include { get; public set; }
    [ParameterAttribute]
public String[] Exclude { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    [CompilerGeneratedAttribute]
public String[] get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(String[] value);
    public String[] get_LiteralPath();
    public void set_LiteralPath(String[] value);
    public virtual string get_Filter();
    public virtual void set_Filter(string value);
    public virtual String[] get_Include();
    public virtual void set_Include(String[] value);
    public virtual String[] get_Exclude();
    public virtual void set_Exclude(String[] value);
    public virtual SwitchParameter get_Force();
    public virtual void set_Force(SwitchParameter value);
    internal void WriteContentObject(object content, long readCount, PathInfo pathInfo, CmdletProviderContext context);
    internal void CloseContent(List`1<ContentHolder> contentHolders, bool disposing);
    internal virtual bool CallShouldProcess(string path);
    internal List`1<ContentHolder> GetContentReaders(String[] readerPaths, CmdletProviderContext currentCommandContext);
    internal Collection`1<PathInfo> ResolvePaths(String[] pathsToResolve, bool allowNonexistingPaths, bool allowEmptyResult, CmdletProviderContext currentCommandContext);
    internal void Dispose(bool isDisposing);
    public sealed virtual void Dispose();
}
[CmdletAttribute("Convert", "Path")]
[OutputTypeAttribute("System.String")]
public class Microsoft.PowerShell.Commands.ConvertPathCommand : CoreCommandBase {
    private String[] _paths;
    [ParameterAttribute]
public String[] Path { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] LiteralPath { get; public set; }
    public String[] get_Path();
    public void set_Path(String[] value);
    public String[] get_LiteralPath();
    public void set_LiteralPath(String[] value);
    protected virtual void ProcessRecord();
}
[CmdletAttribute("Copy", "Item")]
public class Microsoft.PowerShell.Commands.CopyItemCommand : CoreCommandWithCredentialsBase {
    private static string PathParameterSet;
    private static string LiteralPathParameterSet;
    [CompilerGeneratedAttribute]
private string <Destination>k__BackingField;
    private String[] _paths;
    private bool _container;
    private bool _containerSpecified;
    private bool _recurse;
    private bool _passThrough;
    [ParameterAttribute]
public String[] Path { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] LiteralPath { get; public set; }
    [ParameterAttribute]
public string Destination { get; public set; }
    [ParameterAttribute]
public SwitchParameter Container { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    [ParameterAttribute]
public string Filter { get; public set; }
    [ParameterAttribute]
public String[] Include { get; public set; }
    [ParameterAttribute]
public String[] Exclude { get; public set; }
    [ParameterAttribute]
public SwitchParameter Recurse { get; public set; }
    [ParameterAttribute]
public SwitchParameter PassThru { get; public set; }
    protected bool ProviderSupportsShouldProcess { get; }
    public String[] get_Path();
    public void set_Path(String[] value);
    public String[] get_LiteralPath();
    public void set_LiteralPath(String[] value);
    [CompilerGeneratedAttribute]
public string get_Destination();
    [CompilerGeneratedAttribute]
public void set_Destination(string value);
    public SwitchParameter get_Container();
    public void set_Container(SwitchParameter value);
    public virtual SwitchParameter get_Force();
    public virtual void set_Force(SwitchParameter value);
    public virtual string get_Filter();
    public virtual void set_Filter(string value);
    public virtual String[] get_Include();
    public virtual void set_Include(String[] value);
    public virtual String[] get_Exclude();
    public virtual void set_Exclude(String[] value);
    public SwitchParameter get_Recurse();
    public void set_Recurse(SwitchParameter value);
    public SwitchParameter get_PassThru();
    public void set_PassThru(SwitchParameter value);
    internal virtual object GetDynamicParameters(CmdletProviderContext context);
    protected virtual bool get_ProviderSupportsShouldProcess();
    protected virtual void ProcessRecord();
}
[CmdletAttribute("Copy", "ItemProperty")]
public class Microsoft.PowerShell.Commands.CopyItemPropertyCommand : PassThroughItemPropertyCommandBase {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Destination>k__BackingField;
    [ParameterAttribute]
public String[] Path { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] LiteralPath { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public string Name { get; public set; }
    [ParameterAttribute]
public string Destination { get; public set; }
    public String[] get_Path();
    public void set_Path(String[] value);
    public String[] get_LiteralPath();
    public void set_LiteralPath(String[] value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Destination();
    [CompilerGeneratedAttribute]
public void set_Destination(string value);
    internal virtual object GetDynamicParameters(CmdletProviderContext context);
    protected virtual void ProcessRecord();
}
public abstract class Microsoft.PowerShell.Commands.CoreCommandBase : PSCmdlet {
    [TraceSourceAttribute("NavigationCommands", "The namespace navigation tracer")]
internal static PSTraceSource tracer;
    private bool _suppressWildcardExpansion;
    private object _dynamicParameters;
    internal Collection`1<CmdletProviderContext> stopContextCollection;
    [CompilerGeneratedAttribute]
private string <Filter>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Exclude>k__BackingField;
    private bool _force;
    internal CmdletProviderContext CmdletProviderContext { get; }
    internal SwitchParameter SuppressWildcardExpansion { get; internal set; }
    protected bool ProviderSupportsShouldProcess { get; }
    protected internal object RetrievedDynamicParameters { get; }
    public string Filter { get; public set; }
    public String[] Include { get; public set; }
    public String[] Exclude { get; public set; }
    public SwitchParameter Force { get; public set; }
    public bool SupportsShouldProcess { get; }
    private static CoreCommandBase();
    internal virtual CmdletProviderContext get_CmdletProviderContext();
    internal virtual SwitchParameter get_SuppressWildcardExpansion();
    internal virtual void set_SuppressWildcardExpansion(SwitchParameter value);
    internal virtual object GetDynamicParameters(CmdletProviderContext context);
    protected virtual bool get_ProviderSupportsShouldProcess();
    protected bool DoesProviderSupportShouldProcess(String[] paths);
    protected internal object get_RetrievedDynamicParameters();
    protected virtual void StopProcessing();
    [CompilerGeneratedAttribute]
public virtual string get_Filter();
    [CompilerGeneratedAttribute]
public virtual void set_Filter(string value);
    [CompilerGeneratedAttribute]
public virtual String[] get_Include();
    [CompilerGeneratedAttribute]
public virtual void set_Include(String[] value);
    [CompilerGeneratedAttribute]
public virtual String[] get_Exclude();
    [CompilerGeneratedAttribute]
public virtual void set_Exclude(String[] value);
    public virtual SwitchParameter get_Force();
    public virtual void set_Force(SwitchParameter value);
    public sealed virtual object GetDynamicParameters();
    public bool get_SupportsShouldProcess();
}
public class Microsoft.PowerShell.Commands.CoreCommandWithCredentialsBase : CoreCommandBase {
    [CompilerGeneratedAttribute]
private PSCredential <Credential>k__BackingField;
    [ParameterAttribute]
[CredentialAttribute]
public PSCredential Credential { get; public set; }
    internal CmdletProviderContext CmdletProviderContext { get; }
    [CompilerGeneratedAttribute]
public PSCredential get_Credential();
    [CompilerGeneratedAttribute]
public void set_Credential(PSCredential value);
    internal virtual CmdletProviderContext get_CmdletProviderContext();
}
[CmdletAttribute("Debug", "Process")]
public class Microsoft.PowerShell.Commands.DebugProcessCommand : ProcessBaseCommand {
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Int32[] Id { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] Name { get; public set; }
    public Int32[] get_Id();
    public void set_Id(Int32[] value);
    public String[] get_Name();
    public void set_Name(String[] value);
    protected virtual void ProcessRecord();
    private void AttachDebuggerToProcess(Process process);
    private static string MapReturnCodeToErrorMessage(int returnCode);
}
public class Microsoft.PowerShell.Commands.DriveMatchingCoreCommandBase : CoreCommandBase {
    internal List`1<PSDriveInfo> GetMatchingDrives(string driveName, String[] providerNames, string scope);
}
[CmdletAttribute("Get", "ChildItem")]
public class Microsoft.PowerShell.Commands.GetChildItemCommand : CoreCommandBase {
    private static string childrenSet;
    private static string literalChildrenSet;
    private String[] _paths;
    private bool _recurse;
    private UInt32 _depth;
    private bool _childNames;
    [ParameterAttribute]
public String[] Path { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] LiteralPath { get; public set; }
    [ParameterAttribute]
public string Filter { get; public set; }
    [ParameterAttribute]
public String[] Include { get; public set; }
    [ParameterAttribute]
public String[] Exclude { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter Recurse { get; public set; }
    [ParameterAttribute]
public UInt32 Depth { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    [ParameterAttribute]
public SwitchParameter Name { get; public set; }
    public String[] get_Path();
    public void set_Path(String[] value);
    public String[] get_LiteralPath();
    public void set_LiteralPath(String[] value);
    public virtual string get_Filter();
    public virtual void set_Filter(string value);
    public virtual String[] get_Include();
    public virtual void set_Include(String[] value);
    public virtual String[] get_Exclude();
    public virtual void set_Exclude(String[] value);
    public SwitchParameter get_Recurse();
    public void set_Recurse(SwitchParameter value);
    public UInt32 get_Depth();
    public void set_Depth(UInt32 value);
    public virtual SwitchParameter get_Force();
    public virtual void set_Force(SwitchParameter value);
    public SwitchParameter get_Name();
    public void set_Name(SwitchParameter value);
    internal virtual object GetDynamicParameters(CmdletProviderContext context);
    protected virtual void ProcessRecord();
}
[CmdletAttribute("Get", "Clipboard")]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[OutputTypeAttribute("System.String")]
public class Microsoft.PowerShell.Commands.GetClipboardCommand : PSCmdlet {
    private bool _raw;
    [ParameterAttribute]
public SwitchParameter Raw { get; public set; }
    public SwitchParameter get_Raw();
    public void set_Raw(SwitchParameter value);
    protected virtual void BeginProcessing();
    private List`1<string> GetClipboardContentAsText();
}
[CmdletAttribute("Get", "Content")]
public class Microsoft.PowerShell.Commands.GetContentCommand : ContentCommandBase {
    [CompilerGeneratedAttribute]
private long <ReadCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Tail>k__BackingField;
    [ParameterAttribute]
public long ReadCount { get; public set; }
    [ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public long TotalCount { get; public set; }
    [ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public int Tail { get; public set; }
    [CompilerGeneratedAttribute]
public long get_ReadCount();
    [CompilerGeneratedAttribute]
public void set_ReadCount(long value);
    [CompilerGeneratedAttribute]
public long get_TotalCount();
    [CompilerGeneratedAttribute]
public void set_TotalCount(long value);
    [CompilerGeneratedAttribute]
public int get_Tail();
    [CompilerGeneratedAttribute]
public void set_Tail(int value);
    internal virtual object GetDynamicParameters(CmdletProviderContext context);
    protected virtual void ProcessRecord();
    private bool ScanForwardsForTail(ContentHolder& holder, CmdletProviderContext currentContext);
    private bool SeekPositionForTail(IContentReader reader);
    protected virtual void EndProcessing();
}
[CmdletAttribute("Get", "Item")]
public class Microsoft.PowerShell.Commands.GetItemCommand : CoreCommandWithCredentialsBase {
    private static string PathParameterSet;
    private static string LiteralPathParameterSet;
    private String[] _paths;
    [ParameterAttribute]
public String[] Path { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] LiteralPath { get; public set; }
    [ParameterAttribute]
public string Filter { get; public set; }
    [ParameterAttribute]
public String[] Include { get; public set; }
    [ParameterAttribute]
public String[] Exclude { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    public String[] get_Path();
    public void set_Path(String[] value);
    public String[] get_LiteralPath();
    public void set_LiteralPath(String[] value);
    public virtual string get_Filter();
    public virtual void set_Filter(string value);
    public virtual String[] get_Include();
    public virtual void set_Include(String[] value);
    public virtual String[] get_Exclude();
    public virtual void set_Exclude(String[] value);
    public virtual SwitchParameter get_Force();
    public virtual void set_Force(SwitchParameter value);
    internal virtual object GetDynamicParameters(CmdletProviderContext context);
    protected virtual void ProcessRecord();
}
[CmdletAttribute("Get", "ItemProperty")]
public class Microsoft.PowerShell.Commands.GetItemPropertyCommand : ItemPropertyCommandBase {
    private String[] _property;
    [ParameterAttribute]
public String[] Path { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] LiteralPath { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] Name { get; public set; }
    public String[] get_Path();
    public void set_Path(String[] value);
    public String[] get_LiteralPath();
    public void set_LiteralPath(String[] value);
    public String[] get_Name();
    public void set_Name(String[] value);
    internal virtual object GetDynamicParameters(CmdletProviderContext context);
    protected virtual void ProcessRecord();
}
[CmdletAttribute("Get", "ItemPropertyValue")]
public class Microsoft.PowerShell.Commands.GetItemPropertyValueCommand : ItemPropertyCommandBase {
    private String[] _property;
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] Path { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] LiteralPath { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] Name { get; public set; }
    public String[] get_Path();
    public void set_Path(String[] value);
    public String[] get_LiteralPath();
    public void set_LiteralPath(String[] value);
    public String[] get_Name();
    public void set_Name(String[] value);
    internal virtual object GetDynamicParameters(CmdletProviderContext context);
    protected virtual void ProcessRecord();
}
[CmdletAttribute("Get", "Location")]
[OutputTypeAttribute("System.Management.Automation.PathInfo")]
[OutputTypeAttribute("System.Management.Automation.PathInfoStack")]
public class Microsoft.PowerShell.Commands.GetLocationCommand : DriveMatchingCoreCommandBase {
    private static string LocationParameterSet;
    private static string StackParameterSet;
    [CompilerGeneratedAttribute]
private String[] <PSDrive>k__BackingField;
    private bool _stackSwitch;
    private String[] _provider;
    private String[] _stackNames;
    [ParameterAttribute]
public String[] PSProvider { get; public set; }
    [ParameterAttribute]
public String[] PSDrive { get; public set; }
    [ParameterAttribute]
public SwitchParameter Stack { get; public set; }
    [ParameterAttribute]
public String[] StackName { get; public set; }
    public String[] get_PSProvider();
    public void set_PSProvider(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_PSDrive();
    [CompilerGeneratedAttribute]
public void set_PSDrive(String[] value);
    public SwitchParameter get_Stack();
    public void set_Stack(SwitchParameter value);
    public String[] get_StackName();
    public void set_StackName(String[] value);
    protected virtual void ProcessRecord();
}
[CmdletAttribute("Get", "Process")]
[OutputTypeAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.PowerShell.Commands.GetProcessCommand : ProcessBaseCommand {
    private static string NameParameterSet;
    private static string IdParameterSet;
    private static string InputObjectParameterSet;
    private static string NameWithUserNameParameterSet;
    private static string IdWithUserNameParameterSet;
    private static string InputObjectWithUserNameParameterSet;
    [CompilerGeneratedAttribute]
private SwitchParameter <IncludeUserName>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <FileVersionInfo>k__BackingField;
    private static string TypeNameForProcessWithUserName;
    [ParameterAttribute]
[ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateNotNullOrEmptyAttribute]
public String[] Name { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Int32[] Id { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
public Process[] InputObject { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public SwitchParameter IncludeUserName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullAttribute]
public SwitchParameter Module { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateNotNullAttribute]
public SwitchParameter FileVersionInfo { get; public set; }
    public String[] get_Name();
    public void set_Name(String[] value);
    public Int32[] get_Id();
    public void set_Id(Int32[] value);
    public virtual Process[] get_InputObject();
    public virtual void set_InputObject(Process[] value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_IncludeUserName();
    [CompilerGeneratedAttribute]
public void set_IncludeUserName(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_Module();
    [CompilerGeneratedAttribute]
public void set_Module(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_FileVersionInfo();
    [CompilerGeneratedAttribute]
public void set_FileVersionInfo(SwitchParameter value);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    private static PSObject AddUserNameToProcess(Process process);
    private static string RetrieveProcessUserName(Process process);
}
[CmdletAttribute("Get", "PSDrive")]
[OutputTypeAttribute("System.Management.Automation.PSDriveInfo")]
public class Microsoft.PowerShell.Commands.GetPSDriveCommand : DriveMatchingCoreCommandBase {
    private static string NameParameterSet;
    private static string LiteralNameParameterSet;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    private String[] _name;
    private String[] _provider;
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] Name { get; public set; }
    [ParameterAttribute]
public String[] LiteralName { get; public set; }
    [ParameterAttribute]
public string Scope { get; public set; }
    [ParameterAttribute]
public String[] PSProvider { get; public set; }
    public String[] get_Name();
    public void set_Name(String[] value);
    public String[] get_LiteralName();
    public void set_LiteralName(String[] value);
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    public String[] get_PSProvider();
    public void set_PSProvider(String[] value);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
}
[CmdletAttribute("Get", "PSProvider")]
[OutputTypeAttribute("System.Management.Automation.ProviderInfo")]
public class Microsoft.PowerShell.Commands.GetPSProviderCommand : CoreCommandBase {
    private String[] _provider;
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] PSProvider { get; public set; }
    public String[] get_PSProvider();
    public void set_PSProvider(String[] value);
    protected virtual void ProcessRecord();
}
[CmdletAttribute("Get", "TimeZone")]
[OutputTypeAttribute("System.TimeZoneInfo")]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.PowerShell.Commands.GetTimeZoneCommand : PSCmdlet {
    [CompilerGeneratedAttribute]
private String[] <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <ListAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Name>k__BackingField;
    [ParameterAttribute]
public String[] Id { get; public set; }
    [ParameterAttribute]
public SwitchParameter ListAvailable { get; public set; }
    [ParameterAttribute]
public String[] Name { get; public set; }
    [CompilerGeneratedAttribute]
public String[] get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(String[] value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_ListAvailable();
    [CompilerGeneratedAttribute]
public void set_ListAvailable(SwitchParameter value);
    [CompilerGeneratedAttribute]
public String[] get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(String[] value);
    protected virtual void ProcessRecord();
}
internal static class Microsoft.PowerShell.Commands.Internal.Clipboard : object {
    private static Nullable`1<bool> _clipboardSupported;
    private static string _internalClipboard;
    private static UInt32 GMEM_MOVEABLE;
    private static UInt32 GMEM_ZEROINIT;
    private static UInt32 GHND;
    private static UInt32 CF_TEXT;
    private static UInt32 CF_UNICODETEXT;
    private static UInt32 s_CF_RTF;
    private static string StartProcess(string tool, string args, string stdin, bool readStdout);
    public static string GetText();
    public static void SetText(string text);
    public static void SetRtf(string plainText, string rtfText);
    [LibraryImportAttribute("kernel32.dll")]
private static IntPtr GlobalAlloc(UInt32 flags, UIntPtr dwBytes);
    [LibraryImportAttribute("kernel32.dll")]
private static IntPtr GlobalFree(IntPtr hMem);
    [LibraryImportAttribute("kernel32.dll")]
private static IntPtr GlobalLock(IntPtr hMem);
    [LibraryImportAttribute("kernel32.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
private static bool GlobalUnlock(IntPtr hMem);
    [LibraryImportAttribute("kernel32.dll")]
private static void CopyMemory(IntPtr dest, IntPtr src, UInt32 count);
    [LibraryImportAttribute("user32.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
private static bool IsClipboardFormatAvailable(UInt32 format);
    [LibraryImportAttribute("user32.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
private static bool OpenClipboard(IntPtr hWndNewOwner);
    [LibraryImportAttribute("user32.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
private static bool CloseClipboard();
    [LibraryImportAttribute("user32.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
private static bool EmptyClipboard();
    [LibraryImportAttribute("user32.dll")]
private static IntPtr GetClipboardData(UInt32 format);
    [LibraryImportAttribute("user32.dll")]
private static IntPtr SetClipboardData(UInt32 format, IntPtr data);
    [LibraryImportAttribute("user32.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
private static UInt32 RegisterClipboardFormat(string lpszFormat);
    private static bool GetTextImpl(String& text);
    private static bool SetClipboardData(Tuple`2[] data);
    private static bool SetSingleClipboardData(string text, UInt32 format);
    private static void ExecuteOnStaThread(Func`1<bool> action);
    [CompilerGeneratedAttribute]
internal static int <GlobalUnlock>g____PInvoke|12_0(IntPtr __hMem_native);
    [CompilerGeneratedAttribute]
internal static int <IsClipboardFormatAvailable>g____PInvoke|14_0(UInt32 __format_native);
    [CompilerGeneratedAttribute]
internal static int <OpenClipboard>g____PInvoke|15_0(IntPtr __hWndNewOwner_native);
    [CompilerGeneratedAttribute]
internal static int <CloseClipboard>g____PInvoke|16_0();
    [CompilerGeneratedAttribute]
internal static int <EmptyClipboard>g____PInvoke|17_0();
    [CompilerGeneratedAttribute]
internal static UInt32 <RegisterClipboardFormat>g____PInvoke|20_0(UInt16* __lpszFormat_native);
}
[CmdletAttribute("Invoke", "Item")]
public class Microsoft.PowerShell.Commands.InvokeItemCommand : CoreCommandWithCredentialsBase {
    private static string PathParameterSet;
    private static string LiteralPathParameterSet;
    private String[] _paths;
    [ParameterAttribute]
public String[] Path { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] LiteralPath { get; public set; }
    [ParameterAttribute]
public string Filter { get; public set; }
    [ParameterAttribute]
public String[] Include { get; public set; }
    [ParameterAttribute]
public String[] Exclude { get; public set; }
    protected bool ProviderSupportsShouldProcess { get; }
    public String[] get_Path();
    public void set_Path(String[] value);
    public String[] get_LiteralPath();
    public void set_LiteralPath(String[] value);
    public virtual string get_Filter();
    public virtual void set_Filter(string value);
    public virtual String[] get_Include();
    public virtual void set_Include(String[] value);
    public virtual String[] get_Exclude();
    public virtual void set_Exclude(String[] value);
    internal virtual object GetDynamicParameters(CmdletProviderContext context);
    protected virtual bool get_ProviderSupportsShouldProcess();
    protected virtual void ProcessRecord();
}
public class Microsoft.PowerShell.Commands.ItemPropertyCommandBase : CoreCommandWithCredentialsBase {
    internal String[] paths;
    [ParameterAttribute]
public string Filter { get; public set; }
    [ParameterAttribute]
public String[] Include { get; public set; }
    [ParameterAttribute]
public String[] Exclude { get; public set; }
    public virtual string get_Filter();
    public virtual void set_Filter(string value);
    public virtual String[] get_Include();
    public virtual void set_Include(String[] value);
    public virtual String[] get_Exclude();
    public virtual void set_Exclude(String[] value);
}
[CmdletAttribute("Join", "Path")]
[OutputTypeAttribute("System.String")]
public class Microsoft.PowerShell.Commands.JoinPathCommand : CoreCommandWithCredentialsBase {
    [CompilerGeneratedAttribute]
private String[] <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChildPath>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <AdditionalChildPath>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <Resolve>k__BackingField;
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] Path { get; public set; }
    [ParameterAttribute]
[AllowNullAttribute]
[AllowEmptyStringAttribute]
public string ChildPath { get; public set; }
    [ParameterAttribute]
[AllowNullAttribute]
[AllowEmptyStringAttribute]
[AllowEmptyCollectionAttribute]
public String[] AdditionalChildPath { get; public set; }
    [ParameterAttribute]
public SwitchParameter Resolve { get; public set; }
    [CompilerGeneratedAttribute]
public String[] get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(String[] value);
    [CompilerGeneratedAttribute]
public string get_ChildPath();
    [CompilerGeneratedAttribute]
public void set_ChildPath(string value);
    [CompilerGeneratedAttribute]
public String[] get_AdditionalChildPath();
    [CompilerGeneratedAttribute]
public void set_AdditionalChildPath(String[] value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_Resolve();
    [CompilerGeneratedAttribute]
public void set_Resolve(SwitchParameter value);
    protected virtual void ProcessRecord();
}
[CmdletAttribute("Move", "Item")]
public class Microsoft.PowerShell.Commands.MoveItemCommand : CoreCommandWithCredentialsBase {
    private static string PathParameterSet;
    private static string LiteralPathParameterSet;
    [CompilerGeneratedAttribute]
private string <Destination>k__BackingField;
    private String[] _paths;
    private bool _passThrough;
    [ParameterAttribute]
public String[] Path { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] LiteralPath { get; public set; }
    [ParameterAttribute]
public string Destination { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    [ParameterAttribute]
public string Filter { get; public set; }
    [ParameterAttribute]
public String[] Include { get; public set; }
    [ParameterAttribute]
public String[] Exclude { get; public set; }
    [ParameterAttribute]
public SwitchParameter PassThru { get; public set; }
    protected bool ProviderSupportsShouldProcess { get; }
    public String[] get_Path();
    public void set_Path(String[] value);
    public String[] get_LiteralPath();
    public void set_LiteralPath(String[] value);
    [CompilerGeneratedAttribute]
public string get_Destination();
    [CompilerGeneratedAttribute]
public void set_Destination(string value);
    public virtual SwitchParameter get_Force();
    public virtual void set_Force(SwitchParameter value);
    public virtual string get_Filter();
    public virtual void set_Filter(string value);
    public virtual String[] get_Include();
    public virtual void set_Include(String[] value);
    public virtual String[] get_Exclude();
    public virtual void set_Exclude(String[] value);
    public SwitchParameter get_PassThru();
    public void set_PassThru(SwitchParameter value);
    internal virtual object GetDynamicParameters(CmdletProviderContext context);
    protected virtual bool get_ProviderSupportsShouldProcess();
    private Collection`1<PathInfo> GetResolvedPaths(string path);
    protected virtual void ProcessRecord();
    private void MoveItem(string path, bool literalPath);
}
[CmdletAttribute("Move", "ItemProperty")]
public class Microsoft.PowerShell.Commands.MoveItemPropertyCommand : PassThroughItemPropertyCommandBase {
    [CompilerGeneratedAttribute]
private string <Destination>k__BackingField;
    private String[] _property;
    [ParameterAttribute]
public String[] Path { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] LiteralPath { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] Name { get; public set; }
    [ParameterAttribute]
public string Destination { get; public set; }
    public String[] get_Path();
    public void set_Path(String[] value);
    public String[] get_LiteralPath();
    public void set_LiteralPath(String[] value);
    public String[] get_Name();
    public void set_Name(String[] value);
    [CompilerGeneratedAttribute]
public string get_Destination();
    [CompilerGeneratedAttribute]
public void set_Destination(string value);
    internal virtual object GetDynamicParameters(CmdletProviderContext context);
    protected virtual void ProcessRecord();
}
[CmdletAttribute("New", "Item")]
public class Microsoft.PowerShell.Commands.NewItemCommand : CoreCommandWithCredentialsBase {
    private static string NameParameterSet;
    private static string PathParameterSet;
    [CompilerGeneratedAttribute]
private String[] <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ItemType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [ParameterAttribute]
[ParameterAttribute]
public String[] Path { get; public set; }
    [ParameterAttribute]
[AllowNullAttribute]
[AllowEmptyStringAttribute]
public string Name { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public string ItemType { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public object Value { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    protected bool ProviderSupportsShouldProcess { get; }
    [CompilerGeneratedAttribute]
public String[] get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(String[] value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_ItemType();
    [CompilerGeneratedAttribute]
public void set_ItemType(string value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
    public virtual SwitchParameter get_Force();
    public virtual void set_Force(SwitchParameter value);
    internal virtual object GetDynamicParameters(CmdletProviderContext context);
    protected virtual bool get_ProviderSupportsShouldProcess();
    protected virtual void ProcessRecord();
}
[CmdletAttribute("New", "ItemProperty")]
public class Microsoft.PowerShell.Commands.NewItemPropertyCommand : ItemPropertyCommandBase {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertyType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [ParameterAttribute]
public String[] Path { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] LiteralPath { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public string Name { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public string PropertyType { get; public set; }
    [ParameterAttribute]
public object Value { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    public String[] get_Path();
    public void set_Path(String[] value);
    public String[] get_LiteralPath();
    public void set_LiteralPath(String[] value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_PropertyType();
    [CompilerGeneratedAttribute]
public void set_PropertyType(string value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
    public virtual SwitchParameter get_Force();
    public virtual void set_Force(SwitchParameter value);
    internal virtual object GetDynamicParameters(CmdletProviderContext context);
    protected virtual void ProcessRecord();
}
[CmdletAttribute("New", "PSDrive")]
public class Microsoft.PowerShell.Commands.NewPSDriveCommand : CoreCommandWithCredentialsBase {
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    private string _name;
    private string _provider;
    private string _root;
    private string _description;
    [ParameterAttribute]
public string Name { get; public set; }
    [ParameterAttribute]
public string PSProvider { get; public set; }
    [ParameterAttribute]
[AllowEmptyStringAttribute]
public string Root { get; public set; }
    [ParameterAttribute]
public string Description { get; public set; }
    [ParameterAttribute]
public string Scope { get; public set; }
    protected bool ProviderSupportsShouldProcess { get; }
    public string get_Name();
    public void set_Name(string value);
    public string get_PSProvider();
    public void set_PSProvider(string value);
    public string get_Root();
    public void set_Root(string value);
    public string get_Description();
    public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    internal virtual object GetDynamicParameters(CmdletProviderContext context);
    protected virtual bool get_ProviderSupportsShouldProcess();
    protected virtual void ProcessRecord();
}
public class Microsoft.PowerShell.Commands.PassThroughContentCommandBase : ContentCommandBase {
    private bool _passThrough;
    [ParameterAttribute]
public SwitchParameter PassThru { get; public set; }
    protected bool ProviderSupportsShouldProcess { get; }
    public SwitchParameter get_PassThru();
    public void set_PassThru(SwitchParameter value);
    protected virtual bool get_ProviderSupportsShouldProcess();
    internal CmdletProviderContext GetCurrentContext();
}
public class Microsoft.PowerShell.Commands.PassThroughItemPropertyCommandBase : ItemPropertyCommandBase {
    private bool _passThrough;
    [ParameterAttribute]
public SwitchParameter PassThru { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    protected bool ProviderSupportsShouldProcess { get; }
    public SwitchParameter get_PassThru();
    public void set_PassThru(SwitchParameter value);
    public virtual SwitchParameter get_Force();
    public virtual void set_Force(SwitchParameter value);
    protected virtual bool get_ProviderSupportsShouldProcess();
    internal CmdletProviderContext GetCurrentContext();
}
[CmdletAttribute("Pop", "Location")]
public class Microsoft.PowerShell.Commands.PopLocationCommand : CoreCommandBase {
    private bool _passThrough;
    private string _stackName;
    [ParameterAttribute]
public SwitchParameter PassThru { get; public set; }
    [ParameterAttribute]
public string StackName { get; public set; }
    public SwitchParameter get_PassThru();
    public void set_PassThru(SwitchParameter value);
    public string get_StackName();
    public void set_StackName(string value);
    protected virtual void ProcessRecord();
}
public abstract class Microsoft.PowerShell.Commands.ProcessBaseCommand : Cmdlet {
    internal MatchMode myMode;
    internal String[] processNames;
    internal Int32[] processIds;
    private Process[] _input;
    private List`1<Process> _matchingProcesses;
    private Dictionary`2<int, Process> _keys;
    private Process[] _allProcesses;
    [ParameterAttribute]
public Process[] InputObject { get; public set; }
    internal Process[] AllProcesses { get; }
    public virtual Process[] get_InputObject();
    public virtual void set_InputObject(Process[] value);
    internal List`1<Process> MatchingProcesses();
    private static int ProcessComparison(Process x, Process y);
    private void RetrieveMatchingProcessesByProcessName();
    private void RetrieveMatchingProcessesById();
    private void RetrieveProcessesByInput();
    internal Process[] get_AllProcesses();
    private void AddIdempotent(Process process);
    internal void WriteNonTerminatingError(Process process, Exception innerException, string resourceId, string errorId, ErrorCategory category);
    internal void WriteNonTerminatingError(string processName, int processId, object targetObject, Exception innerException, string resourceId, string errorId, ErrorCategory category);
    internal static string SafeGetProcessName(Process process);
    internal static int SafeGetProcessId(Process process);
    internal static void SafeRefresh(Process process);
    internal static bool TryHasExited(Process process);
}
public class Microsoft.PowerShell.Commands.ProcessCommandException : SystemException {
    private string _processName;
    public string ProcessName { get; public set; }
    public ProcessCommandException(string message);
    public ProcessCommandException(string message, Exception innerException);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected ProcessCommandException(SerializationInfo info, StreamingContext context);
    public string get_ProcessName();
    public void set_ProcessName(string value);
}
[CmdletAttribute("Push", "Location")]
public class Microsoft.PowerShell.Commands.PushLocationCommand : CoreCommandBase {
    private static string PathParameterSet;
    private static string LiteralPathParameterSet;
    private string _path;
    private bool _passThrough;
    private string _stackName;
    [ParameterAttribute]
public string Path { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public string LiteralPath { get; public set; }
    [ParameterAttribute]
public SwitchParameter PassThru { get; public set; }
    [ParameterAttribute]
public string StackName { get; public set; }
    public string get_Path();
    public void set_Path(string value);
    public string get_LiteralPath();
    public void set_LiteralPath(string value);
    public SwitchParameter get_PassThru();
    public void set_PassThru(SwitchParameter value);
    public string get_StackName();
    public void set_StackName(string value);
    protected virtual void ProcessRecord();
}
[CmdletAttribute("Remove", "Item")]
public class Microsoft.PowerShell.Commands.RemoveItemCommand : CoreCommandWithCredentialsBase {
    private static string PathParameterSet;
    private static string LiteralPathParameterSet;
    private String[] _paths;
    private bool _recurse;
    [ParameterAttribute]
public String[] Path { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] LiteralPath { get; public set; }
    [ParameterAttribute]
public string Filter { get; public set; }
    [ParameterAttribute]
public String[] Include { get; public set; }
    [ParameterAttribute]
public String[] Exclude { get; public set; }
    [ParameterAttribute]
public SwitchParameter Recurse { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    protected bool ProviderSupportsShouldProcess { get; }
    public String[] get_Path();
    public void set_Path(String[] value);
    public String[] get_LiteralPath();
    public void set_LiteralPath(String[] value);
    public virtual string get_Filter();
    public virtual void set_Filter(string value);
    public virtual String[] get_Include();
    public virtual void set_Include(String[] value);
    public virtual String[] get_Exclude();
    public virtual void set_Exclude(String[] value);
    public SwitchParameter get_Recurse();
    public void set_Recurse(SwitchParameter value);
    public virtual SwitchParameter get_Force();
    public virtual void set_Force(SwitchParameter value);
    internal virtual object GetDynamicParameters(CmdletProviderContext context);
    protected virtual bool get_ProviderSupportsShouldProcess();
    protected virtual void ProcessRecord();
}
[CmdletAttribute("Remove", "ItemProperty")]
public class Microsoft.PowerShell.Commands.RemoveItemPropertyCommand : ItemPropertyCommandBase {
    private String[] _property;
    [ParameterAttribute]
public String[] Path { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] LiteralPath { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] Name { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    public String[] get_Path();
    public void set_Path(String[] value);
    public String[] get_LiteralPath();
    public void set_LiteralPath(String[] value);
    public String[] get_Name();
    public void set_Name(String[] value);
    public virtual SwitchParameter get_Force();
    public virtual void set_Force(SwitchParameter value);
    internal virtual object GetDynamicParameters(CmdletProviderContext context);
    protected virtual void ProcessRecord();
}
[CmdletAttribute("Remove", "PSDrive")]
public class Microsoft.PowerShell.Commands.RemovePSDriveCommand : DriveMatchingCoreCommandBase {
    private static string NameParameterSet;
    private static string LiteralNameParameterSet;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    private String[] _names;
    private String[] _provider;
    [ParameterAttribute]
[AllowNullAttribute]
[AllowEmptyCollectionAttribute]
public String[] Name { get; public set; }
    [ParameterAttribute]
public String[] LiteralName { get; public set; }
    [ParameterAttribute]
public String[] PSProvider { get; public set; }
    [ParameterAttribute]
public string Scope { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    protected bool ProviderSupportsShouldProcess { get; }
    public String[] get_Name();
    public void set_Name(String[] value);
    public String[] get_LiteralName();
    public void set_LiteralName(String[] value);
    public String[] get_PSProvider();
    public void set_PSProvider(String[] value);
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    public virtual SwitchParameter get_Force();
    public virtual void set_Force(SwitchParameter value);
    protected virtual bool get_ProviderSupportsShouldProcess();
    protected virtual void ProcessRecord();
}
[CmdletAttribute("Rename", "Item")]
public class Microsoft.PowerShell.Commands.RenameItemCommand : CoreCommandWithCredentialsBase {
    private static string ByPathParameterSet;
    private static string ByLiteralPathParameterSet;
    [CompilerGeneratedAttribute]
private string <NewName>k__BackingField;
    private string _path;
    private bool _passThrough;
    [ParameterAttribute]
public string Path { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public string LiteralPath { get; public set; }
    [ParameterAttribute]
public string NewName { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    [ParameterAttribute]
public SwitchParameter PassThru { get; public set; }
    protected bool ProviderSupportsShouldProcess { get; }
    public string get_Path();
    public void set_Path(string value);
    public string get_LiteralPath();
    public void set_LiteralPath(string value);
    [CompilerGeneratedAttribute]
public string get_NewName();
    [CompilerGeneratedAttribute]
public void set_NewName(string value);
    public virtual SwitchParameter get_Force();
    public virtual void set_Force(SwitchParameter value);
    public SwitchParameter get_PassThru();
    public void set_PassThru(SwitchParameter value);
    internal virtual object GetDynamicParameters(CmdletProviderContext context);
    protected virtual bool get_ProviderSupportsShouldProcess();
    private Collection`1<PathInfo> GetResolvedPaths(string path);
    protected virtual void ProcessRecord();
    private void RenameItem(string path, bool literalPath);
}
[CmdletAttribute("Rename", "ItemProperty")]
public class Microsoft.PowerShell.Commands.RenameItemPropertyCommand : PassThroughItemPropertyCommandBase {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewName>k__BackingField;
    private string _path;
    [ParameterAttribute]
public string Path { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public string LiteralPath { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public string Name { get; public set; }
    [ParameterAttribute]
public string NewName { get; public set; }
    public string get_Path();
    public void set_Path(string value);
    public string get_LiteralPath();
    public void set_LiteralPath(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_NewName();
    [CompilerGeneratedAttribute]
public void set_NewName(string value);
    internal virtual object GetDynamicParameters(CmdletProviderContext context);
    protected virtual void ProcessRecord();
}
[CmdletAttribute("Resolve", "Path")]
public class Microsoft.PowerShell.Commands.ResolvePathCommand : CoreCommandWithCredentialsBase {
    private SwitchParameter _relative;
    private String[] _paths;
    private PSDriveInfo _relativeDrive;
    private string _relativeBasePath;
    [ParameterAttribute]
public String[] Path { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] LiteralPath { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
public SwitchParameter Relative { get; public set; }
    [ParameterAttribute]
public string RelativeBasePath { get; public set; }
    public String[] get_Path();
    public void set_Path(String[] value);
    public String[] get_LiteralPath();
    public void set_LiteralPath(String[] value);
    public SwitchParameter get_Relative();
    public void set_Relative(SwitchParameter value);
    public string get_RelativeBasePath();
    public void set_RelativeBasePath(string value);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
}
[CmdletAttribute("Restart", "Computer")]
public class Microsoft.PowerShell.Commands.RestartComputerCommand : CommandLineCmdletBase {
    protected virtual void BeginProcessing();
}
[CmdletAttribute("Set", "Clipboard")]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[OutputTypeAttribute("System.String")]
public class Microsoft.PowerShell.Commands.SetClipboardCommand : PSCmdlet {
    private List`1<string> _contentList;
    [CompilerGeneratedAttribute]
private String[] <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <Append>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <PassThru>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <AsOSC52>k__BackingField;
    [ParameterAttribute]
[AllowNullAttribute]
[AllowEmptyCollectionAttribute]
[AllowEmptyStringAttribute]
public String[] Value { get; public set; }
    [ParameterAttribute]
public SwitchParameter Append { get; public set; }
    [ParameterAttribute]
public SwitchParameter PassThru { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter AsOSC52 { get; public set; }
    [CompilerGeneratedAttribute]
public String[] get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(String[] value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_Append();
    [CompilerGeneratedAttribute]
public void set_Append(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_PassThru();
    [CompilerGeneratedAttribute]
public void set_PassThru(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_AsOSC52();
    [CompilerGeneratedAttribute]
public void set_AsOSC52(SwitchParameter value);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    protected virtual void EndProcessing();
    private void SetClipboardContent(List`1<string> contentList, bool append);
    private void SetClipboardContent(string content);
}
[CmdletAttribute("Set", "Content")]
public class Microsoft.PowerShell.Commands.SetContentCommand : WriteContentCommandBase {
    internal virtual void BeforeOpenStreams(String[] paths);
    internal virtual bool CallShouldProcess(string path);
}
[CmdletAttribute("Set", "Item")]
public class Microsoft.PowerShell.Commands.SetItemCommand : CoreCommandWithCredentialsBase {
    private static string PathParameterSet;
    private static string LiteralPathParameterSet;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    private String[] _paths;
    private bool _passThrough;
    [ParameterAttribute]
public String[] Path { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] LiteralPath { get; public set; }
    [ParameterAttribute]
public object Value { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    [ParameterAttribute]
public SwitchParameter PassThru { get; public set; }
    [ParameterAttribute]
public string Filter { get; public set; }
    [ParameterAttribute]
public String[] Include { get; public set; }
    [ParameterAttribute]
public String[] Exclude { get; public set; }
    protected bool ProviderSupportsShouldProcess { get; }
    public String[] get_Path();
    public void set_Path(String[] value);
    public String[] get_LiteralPath();
    public void set_LiteralPath(String[] value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
    public virtual SwitchParameter get_Force();
    public virtual void set_Force(SwitchParameter value);
    public SwitchParameter get_PassThru();
    public void set_PassThru(SwitchParameter value);
    public virtual string get_Filter();
    public virtual void set_Filter(string value);
    public virtual String[] get_Include();
    public virtual void set_Include(String[] value);
    public virtual String[] get_Exclude();
    public virtual void set_Exclude(String[] value);
    internal virtual object GetDynamicParameters(CmdletProviderContext context);
    protected virtual bool get_ProviderSupportsShouldProcess();
    protected virtual void ProcessRecord();
}
[CmdletAttribute("Set", "ItemProperty")]
public class Microsoft.PowerShell.Commands.SetItemPropertyCommand : PassThroughItemPropertyCommandBase {
    private static string propertyValuePathSet;
    private static string propertyValueLiteralPathSet;
    private static string propertyPSObjectPathSet;
    private static string propertyPSObjectLiteralPathSet;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private PSObject <InputObject>k__BackingField;
    [ParameterAttribute]
[ParameterAttribute]
public String[] Path { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] LiteralPath { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public string Name { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[AllowNullAttribute]
public object Value { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
public PSObject InputObject { get; public set; }
    public String[] get_Path();
    public void set_Path(String[] value);
    public String[] get_LiteralPath();
    public void set_LiteralPath(String[] value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
    [CompilerGeneratedAttribute]
public PSObject get_InputObject();
    [CompilerGeneratedAttribute]
public void set_InputObject(PSObject value);
    internal virtual object GetDynamicParameters(CmdletProviderContext context);
    protected virtual void ProcessRecord();
}
[CmdletAttribute("Set", "Location")]
[OutputTypeAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.PowerShell.Commands.SetLocationCommand : CoreCommandBase {
    private static string PathParameterSet;
    private static string LiteralPathParameterSet;
    private static string StackParameterSet;
    [CompilerGeneratedAttribute]
private string <StackName>k__BackingField;
    private string _path;
    private bool _passThrough;
    [ParameterAttribute]
public string Path { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public string LiteralPath { get; public set; }
    [ParameterAttribute]
public SwitchParameter PassThru { get; public set; }
    [ParameterAttribute]
public string StackName { get; public set; }
    public string get_Path();
    public void set_Path(string value);
    public string get_LiteralPath();
    public void set_LiteralPath(string value);
    public SwitchParameter get_PassThru();
    public void set_PassThru(SwitchParameter value);
    [CompilerGeneratedAttribute]
public string get_StackName();
    [CompilerGeneratedAttribute]
public void set_StackName(string value);
    protected virtual void ProcessRecord();
}
[CmdletAttribute("Split", "Path")]
[OutputTypeAttribute("System.String")]
[OutputTypeAttribute("System.Boolean")]
public class Microsoft.PowerShell.Commands.SplitPathCommand : CoreCommandWithCredentialsBase {
    private static string parentSet;
    private static string leafSet;
    private static string leafBaseSet;
    private static string extensionSet;
    private static string qualifierSet;
    private static string noQualifierSet;
    private static string isAbsoluteSet;
    private static string literalPathSet;
    [CompilerGeneratedAttribute]
private String[] <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <Qualifier>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <NoQualifier>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <Leaf>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <LeafBase>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <Extension>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <Resolve>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <IsAbsolute>k__BackingField;
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public String[] Path { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] LiteralPath { get; public set; }
    [ParameterAttribute]
public SwitchParameter Qualifier { get; public set; }
    [ParameterAttribute]
public SwitchParameter NoQualifier { get; public set; }
    [ParameterAttribute]
public SwitchParameter Parent { get; public set; }
    [ParameterAttribute]
public SwitchParameter Leaf { get; public set; }
    [ParameterAttribute]
public SwitchParameter LeafBase { get; public set; }
    [ParameterAttribute]
public SwitchParameter Extension { get; public set; }
    [ParameterAttribute]
public SwitchParameter Resolve { get; public set; }
    [ParameterAttribute]
public SwitchParameter IsAbsolute { get; public set; }
    [CompilerGeneratedAttribute]
public String[] get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(String[] value);
    public String[] get_LiteralPath();
    public void set_LiteralPath(String[] value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_Qualifier();
    [CompilerGeneratedAttribute]
public void set_Qualifier(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_NoQualifier();
    [CompilerGeneratedAttribute]
public void set_NoQualifier(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_Parent();
    [CompilerGeneratedAttribute]
public void set_Parent(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_Leaf();
    [CompilerGeneratedAttribute]
public void set_Leaf(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_LeafBase();
    [CompilerGeneratedAttribute]
public void set_LeafBase(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_Extension();
    [CompilerGeneratedAttribute]
public void set_Extension(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_Resolve();
    [CompilerGeneratedAttribute]
public void set_Resolve(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_IsAbsolute();
    [CompilerGeneratedAttribute]
public void set_IsAbsolute(SwitchParameter value);
    protected virtual void ProcessRecord();
    private string RemoveQualifier(string path);
}
[CmdletAttribute("Start", "Process")]
[OutputTypeAttribute("System.Diagnostics.Process")]
public class Microsoft.PowerShell.Commands.StartProcessCommand : PSCmdlet {
    private ManualResetEvent _waithandle;
    private bool _isDefaultSetParameterSpecified;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ArgumentList>k__BackingField;
    private PSCredential _credential;
    [CompilerGeneratedAttribute]
private string <WorkingDirectory>k__BackingField;
    private SwitchParameter _loaduserprofile;
    private SwitchParameter _nonewwindow;
    [CompilerGeneratedAttribute]
private SwitchParameter <PassThru>k__BackingField;
    private string _redirectstandarderror;
    private string _redirectstandardinput;
    private string _redirectstandardoutput;
    [CompilerGeneratedAttribute]
private string <Verb>k__BackingField;
    private ProcessWindowStyle _windowstyle;
    private bool _windowstyleSpecified;
    [CompilerGeneratedAttribute]
private SwitchParameter <Wait>k__BackingField;
    private SwitchParameter _UseNewEnvironment;
    private Hashtable _environment;
    private StreamWriter _outputWriter;
    private StreamWriter _errorWriter;
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public string FilePath { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] ArgumentList { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateNotNullOrEmptyAttribute]
[CredentialAttribute]
public PSCredential Credential { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public string WorkingDirectory { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter LoadUserProfile { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter NoNewWindow { get; public set; }
    [ParameterAttribute]
public SwitchParameter PassThru { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateNotNullOrEmptyAttribute]
public string RedirectStandardError { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateNotNullOrEmptyAttribute]
public string RedirectStandardInput { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateNotNullOrEmptyAttribute]
public string RedirectStandardOutput { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public string Verb { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public ProcessWindowStyle WindowStyle { get; public set; }
    [ParameterAttribute]
public SwitchParameter Wait { get; public set; }
    [ParameterAttribute]
public SwitchParameter UseNewEnvironment { get; public set; }
    [ParameterAttribute]
public Hashtable Environment { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public String[] get_ArgumentList();
    [CompilerGeneratedAttribute]
public void set_ArgumentList(String[] value);
    public PSCredential get_Credential();
    public void set_Credential(PSCredential value);
    [CompilerGeneratedAttribute]
public string get_WorkingDirectory();
    [CompilerGeneratedAttribute]
public void set_WorkingDirectory(string value);
    public SwitchParameter get_LoadUserProfile();
    public void set_LoadUserProfile(SwitchParameter value);
    public SwitchParameter get_NoNewWindow();
    public void set_NoNewWindow(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_PassThru();
    [CompilerGeneratedAttribute]
public void set_PassThru(SwitchParameter value);
    public string get_RedirectStandardError();
    public void set_RedirectStandardError(string value);
    public string get_RedirectStandardInput();
    public void set_RedirectStandardInput(string value);
    public string get_RedirectStandardOutput();
    public void set_RedirectStandardOutput(string value);
    [CompilerGeneratedAttribute]
public string get_Verb();
    [CompilerGeneratedAttribute]
public void set_Verb(string value);
    public ProcessWindowStyle get_WindowStyle();
    public void set_WindowStyle(ProcessWindowStyle value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_Wait();
    [CompilerGeneratedAttribute]
public void set_Wait(SwitchParameter value);
    public SwitchParameter get_UseNewEnvironment();
    public void set_UseNewEnvironment(SwitchParameter value);
    public Hashtable get_Environment();
    public void set_Environment(Hashtable value);
    protected virtual void BeginProcessing();
    protected virtual void StopProcessing();
    public sealed virtual void Dispose();
    private void Dispose(bool isDisposing);
    private string ResolveFilePath(string path);
    private static void LoadEnvironmentVariable(ProcessStartInfo startinfo, IDictionary EnvironmentVariables);
    private void StdOutputHandler(object sendingProcess, DataReceivedEventArgs outLine);
    private void StdErrorHandler(object sendingProcess, DataReceivedEventArgs outLine);
    private void ExitHandler(object sendingProcess, EventArgs e);
    private void StreamClosing();
    private void SetupInputOutputRedirection(Process p);
    private void WriteToStandardInput(Process p);
    private Process StartWithShellExecute(ProcessStartInfo startInfo);
}
[CmdletAttribute("Stop", "Computer")]
public class Microsoft.PowerShell.Commands.StopComputerCommand : CommandLineCmdletBase {
    protected virtual void BeginProcessing();
}
[CmdletAttribute("Stop", "Process")]
[OutputTypeAttribute("System.Diagnostics.Process")]
public class Microsoft.PowerShell.Commands.StopProcessCommand : ProcessBaseCommand {
    private bool _passThru;
    [CompilerGeneratedAttribute]
private SwitchParameter <Force>k__BackingField;
    private bool _shouldKillCurrentProcess;
    private bool _yesToAll;
    private bool _noToAll;
    private string _currentUserName;
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] Name { get; public set; }
    [ParameterAttribute]
public Int32[] Id { get; public set; }
    [ParameterAttribute]
public Process[] InputObject { get; public set; }
    [ParameterAttribute]
public SwitchParameter PassThru { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public SwitchParameter Force { get; public set; }
    public String[] get_Name();
    public void set_Name(String[] value);
    public Int32[] get_Id();
    public void set_Id(Int32[] value);
    public Process[] get_InputObject();
    public void set_InputObject(Process[] value);
    public SwitchParameter get_PassThru();
    public void set_PassThru(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_Force();
    [CompilerGeneratedAttribute]
public void set_Force(SwitchParameter value);
    protected virtual void ProcessRecord();
    protected virtual void EndProcessing();
    private bool IsProcessOwnedByCurrentUser(Process process);
    private void StopDependentService(Process process);
    private void StopProcess(Process process);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[CmdletAttribute("Test", "Connection")]
[OutputTypeAttribute("Microsoft.PowerShell.Commands.TestConnectionCommand/PingStatus")]
[OutputTypeAttribute("Microsoft.PowerShell.Commands.TestConnectionCommand/PingStatus")]
[OutputTypeAttribute("System.Boolean")]
[OutputTypeAttribute("Microsoft.PowerShell.Commands.TestConnectionCommand/PingMtuStatus")]
[OutputTypeAttribute("System.Int32")]
[OutputTypeAttribute("Microsoft.PowerShell.Commands.TestConnectionCommand/TraceStatus")]
[OutputTypeAttribute("Microsoft.PowerShell.Commands.TestConnectionCommand/TcpPortStatus")]
public class Microsoft.PowerShell.Commands.TestConnectionCommand : PSCmdlet {
    private static string DefaultPingParameterSet;
    private static string RepeatPingParameterSet;
    private static string TraceRouteParameterSet;
    private static string TcpPortParameterSet;
    private static string MtuSizeDetectParameterSet;
    private static UInt32 DefaultTraceRoutePingCount;
    private static int DefaultSendBufferSize;
    private static int DefaultMaxHops;
    private static string TestConnectionExceptionId;
    private static Byte[] s_DefaultSendBuffer;
    private CancellationTokenSource _dnsLookupCancel;
    private bool _disposed;
    [NullableAttribute("2")]
private Ping _sender;
    [CompilerGeneratedAttribute]
private SwitchParameter <Ping>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <IPv4>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <IPv6>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <ResolveDestination>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxHops>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Delay>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <DontFragment>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <Repeat>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <Quiet>k__BackingField;
    [ParameterAttribute]
public SwitchParameter Detailed;
    [CompilerGeneratedAttribute]
private int <TimeoutSeconds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <TargetName>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <MtuSize>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <Traceroute>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TcpPort>k__BackingField;
    [ParameterAttribute]
[ParameterAttribute]
public SwitchParameter Ping { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public SwitchParameter IPv4 { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public SwitchParameter IPv6 { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public SwitchParameter ResolveDestination { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public string Source { get; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public int MaxHops { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateRangeAttribute("0")]
public int Count { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ValidateRangeAttribute("0")]
public int Delay { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public int BufferSize { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
public SwitchParameter DontFragment { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter Repeat { get; public set; }
    [ParameterAttribute]
public SwitchParameter Quiet { get; public set; }
    [ParameterAttribute]
[ValidateRangeAttribute("0")]
public int TimeoutSeconds { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] TargetName { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter MtuSize { get; public set; }
    [ParameterAttribute]
public SwitchParameter Traceroute { get; public set; }
    [ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
[ParameterAttribute]
public int TcpPort { get; public set; }
    private static TestConnectionCommand();
    [CompilerGeneratedAttribute]
public SwitchParameter get_Ping();
    [CompilerGeneratedAttribute]
public void set_Ping(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_IPv4();
    [CompilerGeneratedAttribute]
public void set_IPv4(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_IPv6();
    [CompilerGeneratedAttribute]
public void set_IPv6(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_ResolveDestination();
    [CompilerGeneratedAttribute]
public void set_ResolveDestination(SwitchParameter value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public int get_MaxHops();
    [CompilerGeneratedAttribute]
public void set_MaxHops(int value);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(int value);
    [CompilerGeneratedAttribute]
public int get_Delay();
    [CompilerGeneratedAttribute]
public void set_Delay(int value);
    [CompilerGeneratedAttribute]
public int get_BufferSize();
    [CompilerGeneratedAttribute]
public void set_BufferSize(int value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_DontFragment();
    [CompilerGeneratedAttribute]
public void set_DontFragment(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_Repeat();
    [CompilerGeneratedAttribute]
public void set_Repeat(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_Quiet();
    [CompilerGeneratedAttribute]
public void set_Quiet(SwitchParameter value);
    [CompilerGeneratedAttribute]
public int get_TimeoutSeconds();
    [CompilerGeneratedAttribute]
public void set_TimeoutSeconds(int value);
    [CompilerGeneratedAttribute]
public String[] get_TargetName();
    [CompilerGeneratedAttribute]
public void set_TargetName(String[] value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_MtuSize();
    [CompilerGeneratedAttribute]
public void set_MtuSize(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_Traceroute();
    [CompilerGeneratedAttribute]
public void set_Traceroute(SwitchParameter value);
    [CompilerGeneratedAttribute]
public int get_TcpPort();
    [CompilerGeneratedAttribute]
public void set_TcpPort(int value);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    protected virtual void StopProcessing();
    private void SetCountForTcpTest();
    private void ProcessConnectionByTCPPort(string targetNameOrAddress);
    private void ProcessTraceroute(string targetNameOrAddress);
    private void ProcessMTUSize(string targetNameOrAddress);
    private void ProcessPing(string targetNameOrAddress);
    private bool TryResolveNameOrAddress(string targetNameOrAddress, String& resolvedTargetName, IPAddress& targetAddress);
    private IPHostEntry GetCancellableHostEntry(string targetNameOrAddress);
    private IPAddress GetHostAddress(IPHostEntry hostEntry);
    private static Byte[] GetSendBuffer(int bufferSize);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private PingReply SendCancellablePing(IPAddress targetAddress, int timeout, Byte[] buffer, PingOptions pingOptions, Stopwatch timer);
    protected virtual override void Finalize();
}
[CmdletAttribute("Test", "Path")]
[OutputTypeAttribute("System.Boolean")]
public class Microsoft.PowerShell.Commands.TestPathCommand : CoreCommandWithCredentialsBase {
    [CompilerGeneratedAttribute]
private TestPathType <PathType>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <IsValid>k__BackingField;
    private String[] _paths;
    [ParameterAttribute]
[AllowNullAttribute]
[AllowEmptyCollectionAttribute]
[AllowEmptyStringAttribute]
public String[] Path { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[AllowNullAttribute]
[AllowEmptyCollectionAttribute]
[AllowEmptyStringAttribute]
public String[] LiteralPath { get; public set; }
    [ParameterAttribute]
public string Filter { get; public set; }
    [ParameterAttribute]
public String[] Include { get; public set; }
    [ParameterAttribute]
public String[] Exclude { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public TestPathType PathType { get; public set; }
    [ParameterAttribute]
public SwitchParameter IsValid { get; public set; }
    public String[] get_Path();
    public void set_Path(String[] value);
    public String[] get_LiteralPath();
    public void set_LiteralPath(String[] value);
    public virtual string get_Filter();
    public virtual void set_Filter(string value);
    public virtual String[] get_Include();
    public virtual void set_Include(String[] value);
    public virtual String[] get_Exclude();
    public virtual void set_Exclude(String[] value);
    [CompilerGeneratedAttribute]
public TestPathType get_PathType();
    [CompilerGeneratedAttribute]
public void set_PathType(TestPathType value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_IsValid();
    [CompilerGeneratedAttribute]
public void set_IsValid(SwitchParameter value);
    internal virtual object GetDynamicParameters(CmdletProviderContext context);
    protected virtual void ProcessRecord();
}
public enum Microsoft.PowerShell.Commands.TestPathType : Enum {
    public int value__;
    public static TestPathType Any;
    public static TestPathType Container;
    public static TestPathType Leaf;
}
internal static class Microsoft.PowerShell.Commands.TimeZoneHelper : object {
    internal static string TimeZoneNotFoundError;
    internal static string MultipleMatchingTimeZonesError;
    internal static string InsufficientPermissionsError;
    internal static string SetTimeZoneFailedError;
    internal static TimeZoneInfo[] LookupSystemTimeZoneInfoByName(string name);
}
[CmdletAttribute("Wait", "Process")]
[OutputTypeAttribute("System.Diagnostics.Process")]
public class Microsoft.PowerShell.Commands.WaitProcessCommand : ProcessBaseCommand {
    [CompilerGeneratedAttribute]
private SwitchParameter <Any>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <PassThru>k__BackingField;
    private int _timeout;
    private bool _timeOutSpecified;
    private bool _disposed;
    private List`1<Process> _processList;
    private ManualResetEvent _waitHandle;
    private int _numberOfProcessesToWaitFor;
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Int32[] Id { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] Name { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateNotNullOrEmptyAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public int Timeout { get; public set; }
    [ParameterAttribute]
public SwitchParameter Any { get; public set; }
    [ParameterAttribute]
public SwitchParameter PassThru { get; public set; }
    public Int32[] get_Id();
    public void set_Id(Int32[] value);
    public String[] get_Name();
    public void set_Name(String[] value);
    public int get_Timeout();
    public void set_Timeout(int value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_Any();
    [CompilerGeneratedAttribute]
public void set_Any(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_PassThru();
    [CompilerGeneratedAttribute]
public void set_PassThru(SwitchParameter value);
    public void Dispose();
    private void myProcess_Exited(object sender, EventArgs e);
    protected virtual void ProcessRecord();
    protected virtual void EndProcessing();
    protected virtual void StopProcessing();
}
public class Microsoft.PowerShell.Commands.WriteContentCommandBase : PassThroughContentCommandBase {
    private Object[] _content;
    private bool _pipingPaths;
    private bool _contentWritersOpen;
    [ParameterAttribute]
[AllowNullAttribute]
[AllowEmptyCollectionAttribute]
public Object[] Value { get; public set; }
    public Object[] get_Value();
    public void set_Value(Object[] value);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    protected virtual void EndProcessing();
    internal virtual void SeekContentPosition(List`1<ContentHolder> contentHolders);
    internal virtual void BeforeOpenStreams(String[] paths);
    internal virtual object GetDynamicParameters(CmdletProviderContext context);
    internal List`1<ContentHolder> GetContentWriters(String[] writerPaths, CmdletProviderContext currentCommandContext);
    private String[] GetAcceptedPaths(String[] unfilteredPaths, CmdletProviderContext currentContext);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NavigationResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string DeleteHasChildrenPrompt { get; }
    internal static string DeletePrompt { get; }
    internal static string CopyToExistingPrompt { get; }
    internal static string NewDriveConfirmAction { get; }
    internal static string NewDriveConfirmResourceTemplate { get; }
    internal static string RemoveDriveConfirmAction { get; }
    internal static string RemoveDriveConfirmResourceTemplate { get; }
    internal static string RemoveDriveInUse { get; }
    internal static string RemoveItemWithChildren { get; }
    internal static string RemoveItemInUse { get; }
    internal static string ItemNotFound { get; }
    internal static string SetContentAction { get; }
    internal static string SetContentTarget { get; }
    internal static string AddContentAction { get; }
    internal static string AddContentTarget { get; }
    internal static string MoveItemDoesntExist { get; }
    internal static string MoveItemInUse { get; }
    internal static string RenameItemDoesntExist { get; }
    internal static string RenamedItemInUse { get; }
    internal static string ParsePathFormatError { get; }
    internal static string CreateAction { get; }
    internal static string RollbackAction { get; }
    internal static string CommitAction { get; }
    internal static string TransactionResource { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_DeleteHasChildrenPrompt();
    internal static string get_DeletePrompt();
    internal static string get_CopyToExistingPrompt();
    internal static string get_NewDriveConfirmAction();
    internal static string get_NewDriveConfirmResourceTemplate();
    internal static string get_RemoveDriveConfirmAction();
    internal static string get_RemoveDriveConfirmResourceTemplate();
    internal static string get_RemoveDriveInUse();
    internal static string get_RemoveItemWithChildren();
    internal static string get_RemoveItemInUse();
    internal static string get_ItemNotFound();
    internal static string get_SetContentAction();
    internal static string get_SetContentTarget();
    internal static string get_AddContentAction();
    internal static string get_AddContentTarget();
    internal static string get_MoveItemDoesntExist();
    internal static string get_MoveItemInUse();
    internal static string get_RenameItemDoesntExist();
    internal static string get_RenamedItemInUse();
    internal static string get_ParsePathFormatError();
    internal static string get_CreateAction();
    internal static string get_RollbackAction();
    internal static string get_CommitAction();
    internal static string get_TransactionResource();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class ProcessCommandHelpResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string GetProcessShortDescription { get; }
    internal static string GetProcessDetailedDescription { get; }
    internal static string GetProcessNote1 { get; }
    internal static string GetProcessExample1Description { get; }
    internal static string GetProcessExample2Description { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_GetProcessShortDescription();
    internal static string get_GetProcessDetailedDescription();
    internal static string get_GetProcessNote1();
    internal static string get_GetProcessExample1Description();
    internal static string get_GetProcessExample2Description();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class ProcessResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string NoProcessFoundForGivenName { get; }
    internal static string RecommendIdTagForGivenName { get; }
    internal static string NoDebuggerFound { get; }
    internal static string NoProcessFoundForGivenId { get; }
    internal static string CouldNotStopProcess { get; }
    internal static string ProcessNameForConfirmation { get; }
    internal static string StartProcessTarget { get; }
    internal static string CouldNotEnumerateModules { get; }
    internal static string CouldNotEnumerateFileVer { get; }
    internal static string CouldNotEnumerateModuleFileVer { get; }
    internal static string ConfirmStopProcess { get; }
    internal static string UseShell { get; }
    internal static string ProcessIsNotTerminated { get; }
    internal static string RedirectionParams { get; }
    internal static string NoComputerNameWithFileVersion { get; }
    internal static string DebuggerError { get; }
    internal static string WaitOnIdleProcess { get; }
    internal static string WaitOnItself { get; }
    internal static string ProcessNotTerminated { get; }
    internal static string InvalidStartProcess { get; }
    internal static string InvalidApplication { get; }
    internal static string InvalidInput { get; }
    internal static string DuplicateEntry { get; }
    internal static string CannotStarttheProcess { get; }
    internal static string FailedToCreateProcessObject { get; }
    internal static string InvalidUserError { get; }
    internal static string JoinNetworkFailed { get; }
    internal static string RemoveFailed { get; }
    internal static string RenameFailed { get; }
    internal static string ContradictParametersSpecified { get; }
    internal static string IncludeUserNameRequiresElevation { get; }
    internal static string CouldNotDebugProcess { get; }
    internal static string AttachDebuggerReturnCode2 { get; }
    internal static string AttachDebuggerReturnCode21 { get; }
    internal static string AttachDebuggerReturnCode3 { get; }
    internal static string AttachDebuggerReturnCode8 { get; }
    internal static string AttachDebuggerReturnCode9 { get; }
    internal static string ParameterNotSupported { get; }
    internal static string ParameterNotSupportedOnPSEdition { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_NoProcessFoundForGivenName();
    internal static string get_RecommendIdTagForGivenName();
    internal static string get_NoDebuggerFound();
    internal static string get_NoProcessFoundForGivenId();
    internal static string get_CouldNotStopProcess();
    internal static string get_ProcessNameForConfirmation();
    internal static string get_StartProcessTarget();
    internal static string get_CouldNotEnumerateModules();
    internal static string get_CouldNotEnumerateFileVer();
    internal static string get_CouldNotEnumerateModuleFileVer();
    internal static string get_ConfirmStopProcess();
    internal static string get_UseShell();
    internal static string get_ProcessIsNotTerminated();
    internal static string get_RedirectionParams();
    internal static string get_NoComputerNameWithFileVersion();
    internal static string get_DebuggerError();
    internal static string get_WaitOnIdleProcess();
    internal static string get_WaitOnItself();
    internal static string get_ProcessNotTerminated();
    internal static string get_InvalidStartProcess();
    internal static string get_InvalidApplication();
    internal static string get_InvalidInput();
    internal static string get_DuplicateEntry();
    internal static string get_CannotStarttheProcess();
    internal static string get_FailedToCreateProcessObject();
    internal static string get_InvalidUserError();
    internal static string get_JoinNetworkFailed();
    internal static string get_RemoveFailed();
    internal static string get_RenameFailed();
    internal static string get_ContradictParametersSpecified();
    internal static string get_IncludeUserNameRequiresElevation();
    internal static string get_CouldNotDebugProcess();
    internal static string get_AttachDebuggerReturnCode2();
    internal static string get_AttachDebuggerReturnCode21();
    internal static string get_AttachDebuggerReturnCode3();
    internal static string get_AttachDebuggerReturnCode8();
    internal static string get_AttachDebuggerReturnCode9();
    internal static string get_ParameterNotSupported();
    internal static string get_ParameterNotSupportedOnPSEdition();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class ServiceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ServiceNameForConfirmation { get; }
    internal static string NoServiceFoundForGivenName { get; }
    internal static string NoServiceFoundForGivenDisplayName { get; }
    internal static string ServiceHasDependentServices { get; }
    internal static string ServiceHasDependentServicesNoForce { get; }
    internal static string CouldNotStopService { get; }
    internal static string CouldNotStartService { get; }
    internal static string CouldNotSuspendService { get; }
    internal static string CouldNotSuspendServiceNotSupported { get; }
    internal static string CouldNotSuspendServiceNotRunning { get; }
    internal static string CouldNotResumeService { get; }
    internal static string CouldNotResumeServiceNotSupported { get; }
    internal static string CouldNotResumeServiceNotRunning { get; }
    internal static string CouldNotSetService { get; }
    internal static string CouldNotGetServiceInfo { get; }
    internal static string CouldNotSetServiceDescription { get; }
    internal static string CouldNotSetServiceDelayedAutoStart { get; }
    internal static string CouldNotSetServiceSecurityDescriptorSddl { get; }
    internal static string CouldNotNewService { get; }
    internal static string CouldNotNewServiceDescription { get; }
    internal static string CouldNotNewServiceDelayedAutoStart { get; }
    internal static string CouldNotRemoveService { get; }
    internal static string CouldNotAccessDependentServices { get; }
    internal static string StartingService { get; }
    internal static string StoppingService { get; }
    internal static string SuspendingService { get; }
    internal static string ResumingService { get; }
    internal static string StartServiceFailed { get; }
    internal static string StopServiceFailed { get; }
    internal static string SuspendServiceFailed { get; }
    internal static string ResumeServiceFailed { get; }
    internal static string FailToOpenServiceControlManager { get; }
    internal static string UnsupportedStartupType { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ServiceNameForConfirmation();
    internal static string get_NoServiceFoundForGivenName();
    internal static string get_NoServiceFoundForGivenDisplayName();
    internal static string get_ServiceHasDependentServices();
    internal static string get_ServiceHasDependentServicesNoForce();
    internal static string get_CouldNotStopService();
    internal static string get_CouldNotStartService();
    internal static string get_CouldNotSuspendService();
    internal static string get_CouldNotSuspendServiceNotSupported();
    internal static string get_CouldNotSuspendServiceNotRunning();
    internal static string get_CouldNotResumeService();
    internal static string get_CouldNotResumeServiceNotSupported();
    internal static string get_CouldNotResumeServiceNotRunning();
    internal static string get_CouldNotSetService();
    internal static string get_CouldNotGetServiceInfo();
    internal static string get_CouldNotSetServiceDescription();
    internal static string get_CouldNotSetServiceDelayedAutoStart();
    internal static string get_CouldNotSetServiceSecurityDescriptorSddl();
    internal static string get_CouldNotNewService();
    internal static string get_CouldNotNewServiceDescription();
    internal static string get_CouldNotNewServiceDelayedAutoStart();
    internal static string get_CouldNotRemoveService();
    internal static string get_CouldNotAccessDependentServices();
    internal static string get_StartingService();
    internal static string get_StoppingService();
    internal static string get_SuspendingService();
    internal static string get_ResumingService();
    internal static string get_StartServiceFailed();
    internal static string get_StopServiceFailed();
    internal static string get_SuspendServiceFailed();
    internal static string get_ResumeServiceFailed();
    internal static string get_FailToOpenServiceControlManager();
    internal static string get_UnsupportedStartupType();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class TestConnectionResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string NoPingResult { get; }
    internal static string CannotResolveTargetName { get; }
    internal static string TargetAddressAbsent { get; }
    internal static string MaxHopsExceeded { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_NoPingResult();
    internal static string get_CannotResolveTargetName();
    internal static string get_TargetAddressAbsent();
    internal static string get_MaxHopsExceeded();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class TestPathResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string PathIsNullOrEmptyCollection { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_PathIsNullOrEmptyCollection();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class TimeZoneResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string MultipleMatchingTimeZones { get; }
    internal static string TimeZoneNameNotFound { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_MultipleMatchingTimeZones();
    internal static string get_TimeZoneNameNotFound();
}
