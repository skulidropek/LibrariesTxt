[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("additionalItems")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[DependsOnAnnotationsFromAttribute("Json.Schema.ItemsKeyword")]
[JsonConverterAttribute("Json.Schema.AdditionalItemsKeywordJsonConverter")]
public class Json.Schema.AdditionalItemsKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    public JsonSchema Schema { get; }
    public AdditionalItemsKeyword(JsonSchema value);
    [CompilerGeneratedAttribute]
public sealed virtual JsonSchema get_Schema();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.AdditionalItemsKeywordJsonConverter : JsonConverter`1<AdditionalItemsKeyword> {
    public virtual AdditionalItemsKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, AdditionalItemsKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("additionalProperties")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[DependsOnAnnotationsFromAttribute("Json.Schema.PropertiesKeyword")]
[DependsOnAnnotationsFromAttribute("Json.Schema.PatternPropertiesKeyword")]
[JsonConverterAttribute("Json.Schema.AdditionalPropertiesKeywordJsonConverter")]
public class Json.Schema.AdditionalPropertiesKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    public JsonSchema Schema { get; }
    public AdditionalPropertiesKeyword(JsonSchema value);
    [CompilerGeneratedAttribute]
public sealed virtual JsonSchema get_Schema();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.AdditionalPropertiesKeywordJsonConverter : JsonConverter`1<AdditionalPropertiesKeyword> {
    public virtual AdditionalPropertiesKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, AdditionalPropertiesKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("allOf")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[JsonConverterAttribute("Json.Schema.AllOfKeywordJsonConverter")]
public class Json.Schema.AllOfKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<JsonSchema> <Schemas>k__BackingField;
    public IReadOnlyList`1<JsonSchema> Schemas { get; }
    public AllOfKeyword(JsonSchema[] values);
    public AllOfKeyword(IEnumerable`1<JsonSchema> values);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<JsonSchema> get_Schemas();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.AllOfKeywordJsonConverter : JsonConverter`1<AllOfKeyword> {
    public virtual AllOfKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, AllOfKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("$anchor")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/core")]
[JsonConverterAttribute("Json.Schema.AnchorKeywordJsonConverter")]
public class Json.Schema.AnchorKeyword : object {
    public static string Name;
    internal static Regex AnchorPattern;
    [CompilerGeneratedAttribute]
private string <Anchor>k__BackingField;
    public string Anchor { get; }
    public AnchorKeyword(string anchor);
    private static AnchorKeyword();
    [CompilerGeneratedAttribute]
public string get_Anchor();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.AnchorKeywordJsonConverter : JsonConverter`1<AnchorKeyword> {
    public virtual AnchorKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, AnchorKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("anyOf")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[JsonConverterAttribute("Json.Schema.AnyOfKeywordJsonConverter")]
public class Json.Schema.AnyOfKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<JsonSchema> <Schemas>k__BackingField;
    public IReadOnlyList`1<JsonSchema> Schemas { get; }
    public AnyOfKeyword(JsonSchema[] values);
    public AnyOfKeyword(IEnumerable`1<JsonSchema> values);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<JsonSchema> get_Schemas();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.AnyOfKeywordJsonConverter : JsonConverter`1<AnyOfKeyword> {
    public virtual AnyOfKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, AnyOfKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("$comment")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/core")]
[JsonConverterAttribute("Json.Schema.CommentKeywordJsonConverter")]
public class Json.Schema.CommentKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public CommentKeyword(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.CommentKeywordJsonConverter : JsonConverter`1<CommentKeyword> {
    public virtual CommentKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, CommentKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("const")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.ConstKeywordJsonConverter")]
public class Json.Schema.ConstKeyword : object {
    [NullableAttribute("1")]
public static string Name;
    [CompilerGeneratedAttribute]
private JsonNode <Value>k__BackingField;
    public JsonNode Value { get; }
    public ConstKeyword(JsonNode value);
    [CompilerGeneratedAttribute]
public JsonNode get_Value();
    [NullableContextAttribute("1")]
public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    [NullableContextAttribute("1")]
private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.ConstKeywordJsonConverter : JsonConverter`1<ConstKeyword> {
    public virtual ConstKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ConstKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Json.Schema.ConstraintExtensions : object {
    [ExtensionAttribute]
public static KeywordEvaluation GetKeywordEvaluation(KeywordEvaluation evaluation);
    [ExtensionAttribute]
public static KeywordConstraint GetKeywordConstraint(IEnumerable`1<KeywordConstraint> constraints);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("contains")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[DependsOnAnnotationsFromAttribute("Json.Schema.MinContainsKeyword")]
[DependsOnAnnotationsFromAttribute("Json.Schema.MaxContainsKeyword")]
[JsonConverterAttribute("Json.Schema.ContainsKeywordJsonConverter")]
public class Json.Schema.ContainsKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    public JsonSchema Schema { get; }
    public ContainsKeyword(JsonSchema value);
    [CompilerGeneratedAttribute]
public sealed virtual JsonSchema get_Schema();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.ContainsKeywordJsonConverter : JsonConverter`1<ContainsKeyword> {
    public virtual ContainsKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ContainsKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("contentEncoding")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/content")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/content")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/content")]
[JsonConverterAttribute("Json.Schema.ContentEncodingKeywordJsonConverter")]
public class Json.Schema.ContentEncodingKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public ContentEncodingKeyword(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.ContentEncodingKeywordJsonConverter : JsonConverter`1<ContentEncodingKeyword> {
    public virtual ContentEncodingKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ContentEncodingKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("contentMediaType")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/content")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/content")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/content")]
[JsonConverterAttribute("Json.Schema.ContentMediaTypeKeywordJsonConverter")]
public class Json.Schema.ContentMediaTypeKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public ContentMediaTypeKeyword(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.ContentMediaTypeKeywordJsonConverter : JsonConverter`1<ContentMediaTypeKeyword> {
    public virtual ContentMediaTypeKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ContentMediaTypeKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("contentSchema")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/content")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/content")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/content")]
[JsonConverterAttribute("Json.Schema.ContentSchemaKeywordJsonConverter")]
public class Json.Schema.ContentSchemaKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    public JsonSchema Schema { get; }
    public ContentSchemaKeyword(JsonSchema value);
    [CompilerGeneratedAttribute]
public sealed virtual JsonSchema get_Schema();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.ContentSchemaKeywordJsonConverter : JsonConverter`1<ContentSchemaKeyword> {
    public virtual ContentSchemaKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ContentSchemaKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("default")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/meta-data")]
[JsonConverterAttribute("Json.Schema.DefaultKeywordJsonConverter")]
public class Json.Schema.DefaultKeyword : object {
    [NullableAttribute("1")]
public static string Name;
    [CompilerGeneratedAttribute]
private JsonNode <Value>k__BackingField;
    public JsonNode Value { get; }
    public DefaultKeyword(JsonNode value);
    [CompilerGeneratedAttribute]
public JsonNode get_Value();
    [NullableContextAttribute("1")]
public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.DefaultKeywordJsonConverter : JsonConverter`1<DefaultKeyword> {
    public virtual DefaultKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DefaultKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("definitions")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[JsonConverterAttribute("Json.Schema.DefinitionsKeywordJsonConverter")]
public class Json.Schema.DefinitionsKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, JsonSchema> <Definitions>k__BackingField;
    public IReadOnlyDictionary`2<string, JsonSchema> Definitions { get; }
    private IReadOnlyDictionary`2<string, JsonSchema> Json.Schema.IKeyedSchemaCollector.Schemas { get; }
    public DefinitionsKeyword(IReadOnlyDictionary`2<string, JsonSchema> values);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, JsonSchema> get_Definitions();
    private sealed virtual override IReadOnlyDictionary`2<string, JsonSchema> Json.Schema.IKeyedSchemaCollector.get_Schemas();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.DefinitionsKeywordJsonConverter : JsonConverter`1<DefinitionsKeyword> {
    public virtual DefinitionsKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DefinitionsKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("$defs")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/core")]
[JsonConverterAttribute("Json.Schema.DefsKeywordJsonConverter")]
public class Json.Schema.DefsKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, JsonSchema> <Definitions>k__BackingField;
    public IReadOnlyDictionary`2<string, JsonSchema> Definitions { get; }
    private IReadOnlyDictionary`2<string, JsonSchema> Json.Schema.IKeyedSchemaCollector.Schemas { get; }
    public DefsKeyword(IReadOnlyDictionary`2<string, JsonSchema> values);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, JsonSchema> get_Definitions();
    private sealed virtual override IReadOnlyDictionary`2<string, JsonSchema> Json.Schema.IKeyedSchemaCollector.get_Schemas();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.DefsKeywordJsonConverter : JsonConverter`1<DefsKeyword> {
    public virtual DefsKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DefsKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("dependencies")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[JsonConverterAttribute("Json.Schema.DependenciesKeywordJsonConverter")]
public class Json.Schema.DependenciesKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, SchemaOrPropertyList> <Requirements>k__BackingField;
    public IReadOnlyDictionary`2<string, SchemaOrPropertyList> Requirements { get; }
    private IReadOnlyDictionary`2<string, JsonSchema> Json.Schema.IKeyedSchemaCollector.Schemas { get; }
    public DependenciesKeyword(IReadOnlyDictionary`2<string, SchemaOrPropertyList> values);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, SchemaOrPropertyList> get_Requirements();
    private sealed virtual override IReadOnlyDictionary`2<string, JsonSchema> Json.Schema.IKeyedSchemaCollector.get_Schemas();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.DependenciesKeywordJsonConverter : JsonConverter`1<DependenciesKeyword> {
    public virtual DependenciesKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DependenciesKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("dependentRequired")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.DependentRequiredKeywordJsonConverter")]
public class Json.Schema.DependentRequiredKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> <Requirements>k__BackingField;
    public IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> Requirements { get; }
    public DependentRequiredKeyword(IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> values);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> get_Requirements();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.DependentRequiredKeywordJsonConverter : JsonConverter`1<DependentRequiredKeyword> {
    public virtual DependentRequiredKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DependentRequiredKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("dependentSchemas")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[JsonConverterAttribute("Json.Schema.DependentSchemasKeywordJsonConverter")]
public class Json.Schema.DependentSchemasKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, JsonSchema> <Schemas>k__BackingField;
    public IReadOnlyDictionary`2<string, JsonSchema> Schemas { get; }
    public DependentSchemasKeyword(IReadOnlyDictionary`2<string, JsonSchema> values);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyDictionary`2<string, JsonSchema> get_Schemas();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.DependentSchemasKeywordJsonConverter : JsonConverter`1<DependentSchemasKeyword> {
    public virtual DependentSchemasKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DependentSchemasKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("12")]
public class Json.Schema.DependsOnAnnotationsFromAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <DependentType>k__BackingField;
    public Type DependentType { get; }
    public DependsOnAnnotationsFromAttribute(Type type);
    [CompilerGeneratedAttribute]
public Type get_DependentType();
}
[SchemaKeywordAttribute("deprecated")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/meta-data")]
[JsonConverterAttribute("Json.Schema.DeprecatedKeywordJsonConverter")]
public class Json.Schema.DeprecatedKeyword : object {
    [NullableAttribute("1")]
public static string Name;
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public bool Value { get; }
    public DeprecatedKeyword(bool value);
    [CompilerGeneratedAttribute]
public bool get_Value();
    [NullableContextAttribute("1")]
public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.DeprecatedKeywordJsonConverter : JsonConverter`1<DeprecatedKeyword> {
    public virtual DeprecatedKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DeprecatedKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("description")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/meta-data")]
[JsonConverterAttribute("Json.Schema.DescriptionKeywordJsonConverter")]
public class Json.Schema.DescriptionKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public DescriptionKeyword(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.DescriptionKeywordJsonConverter : JsonConverter`1<DescriptionKeyword> {
    public virtual DescriptionKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DescriptionKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Json.Schema.Duration : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <Years>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Months>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Weeks>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Days>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Hours>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Minutes>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Seconds>k__BackingField;
    public UInt32 Years { get; }
    public UInt32 Months { get; }
    public UInt32 Weeks { get; }
    public UInt32 Days { get; }
    public UInt32 Hours { get; }
    public UInt32 Minutes { get; }
    public UInt32 Seconds { get; }
    private Duration(UInt32 years, UInt32 months, UInt32 weeks, UInt32 days, UInt32 hours, UInt32 minutes, UInt32 seconds);
    [CompilerGeneratedAttribute]
public UInt32 get_Years();
    [CompilerGeneratedAttribute]
public UInt32 get_Months();
    [CompilerGeneratedAttribute]
public UInt32 get_Weeks();
    [CompilerGeneratedAttribute]
public UInt32 get_Days();
    [CompilerGeneratedAttribute]
public UInt32 get_Hours();
    [CompilerGeneratedAttribute]
public UInt32 get_Minutes();
    [CompilerGeneratedAttribute]
public UInt32 get_Seconds();
    public static Duration Parse(string source);
    public static bool TryParse(string source, Duration& duration);
    private static bool Require(string source, Int32& index, char ch);
    private static bool TryGetComponent(string source, Int32& index, UInt32& number, char ch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("$dynamicAnchor")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/core")]
[JsonConverterAttribute("Json.Schema.DynamicAnchorKeywordJsonConverter")]
public class Json.Schema.DynamicAnchorKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public DynamicAnchorKeyword(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.DynamicAnchorKeywordJsonConverter : JsonConverter`1<DynamicAnchorKeyword> {
    public virtual DynamicAnchorKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DynamicAnchorKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("$dynamicRef")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/core")]
[JsonConverterAttribute("Json.Schema.DynamicRefKeywordJsonConverter")]
public class Json.Schema.DynamicRefKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private Uri <Reference>k__BackingField;
    public Uri Reference { get; }
    public DynamicRefKeyword(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_Reference();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context, JsonSchema target);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.DynamicRefKeywordJsonConverter : JsonConverter`1<DynamicRefKeyword> {
    public virtual DynamicRefKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DynamicRefKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.DynamicScope : object {
    private Stack`1<Uri> _scope;
    public Uri LocalScope { get; }
    internal DynamicScope(Uri initialScope);
    internal DynamicScope(DynamicScope other);
    public Uri get_LocalScope();
    internal void Push(Uri newLocal);
    internal void Pop();
    public sealed virtual IEnumerator`1<Uri> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(DynamicScope other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("else")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[DependsOnAnnotationsFromAttribute("Json.Schema.IfKeyword")]
[JsonConverterAttribute("Json.Schema.ElseKeywordJsonConverter")]
public class Json.Schema.ElseKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    public JsonSchema Schema { get; }
    public ElseKeyword(JsonSchema value);
    [CompilerGeneratedAttribute]
public sealed virtual JsonSchema get_Schema();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.ElseKeywordJsonConverter : JsonConverter`1<ElseKeyword> {
    public virtual ElseKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ElseKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Json.Schema.EnumerableExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool ContentsEqual(IReadOnlyList`1<T> collection, IReadOnlyList`1<T> other);
    [ExtensionAttribute]
public static bool ContentsEqual(IReadOnlyList`1<T> collection, IReadOnlyList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static int GetStringDictionaryHashCode(IDictionary`2<string, T> collection);
    [ExtensionAttribute]
public static int GetStringDictionaryHashCode(IReadOnlyDictionary`2<string, T> collection);
    [ExtensionAttribute]
public static int GetUnorderedCollectionHashCode(IEnumerable`1<T> collection);
    [ExtensionAttribute]
internal static int GetUnorderedCollectionHashCode(IEnumerable`1<T> collection, Func`2<T, int> getHashCode);
    [ExtensionAttribute]
internal static IReadOnlyList`1<T> ToReadOnlyList(IEnumerable`1<T> values);
    [CompilerGeneratedAttribute]
internal static int <GetStringDictionaryHashCode>g__GetHashCode|2_0(KeyValuePair`2<string, T> kvp);
    [CompilerGeneratedAttribute]
internal static int <GetStringDictionaryHashCode>g__GetHashCode|3_0(KeyValuePair`2<string, T> kvp);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("enum")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.EnumKeywordJsonConverter")]
public class Json.Schema.EnumKeyword : object {
    public static string Name;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonNode[] _values;
    [CompilerGeneratedAttribute]
private static bool <RequireUniqueValues>k__BackingField;
    public static bool RequireUniqueValues { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyCollection`1<JsonNode> Values { get; }
    public EnumKeyword(JsonNode[] values);
    public EnumKeyword(IEnumerable`1<JsonNode> values);
    [CompilerGeneratedAttribute]
public static bool get_RequireUniqueValues();
    [CompilerGeneratedAttribute]
public static void set_RequireUniqueValues(bool value);
    public IReadOnlyCollection`1<JsonNode> get_Values();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.EnumKeywordJsonConverter : JsonConverter`1<EnumKeyword> {
    public virtual EnumKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, EnumKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Json.Schema.ErrorMessages : object {
    [CompilerGeneratedAttribute]
private static string <Const>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ContainsTooFew>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ContainsTooMany>k__BackingField;
    private static string _dependencies;
    [CompilerGeneratedAttribute]
private static string <DependentRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <DependentSchemas>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <Enum>k__BackingField;
    [NullableAttribute("1")]
private static ResourceManager _resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ExclusiveMaximum>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ExclusiveMinimum>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <UnknownFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <FormatWithDetail>k__BackingField;
    private static string _invalidItemsForm;
    private static string _falseSchema;
    [CompilerGeneratedAttribute]
private static string <Maximum>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <MaxItems>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <MaxLength>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <MaxProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <Minimum>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <MinItems>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <MinLength>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <MinProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <MultipleOf>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <OneOf>k__BackingField;
    private static string _invalidPattern;
    [CompilerGeneratedAttribute]
private static string <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <Required>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <MetaSchemaValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <UniqueItems>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <UnknownVocabularies>k__BackingField;
    public static string Const { get; public set; }
    public static string ContainsTooFew { get; public set; }
    public static string ContainsTooMany { get; public set; }
    [NullableAttribute("1")]
[ObsoleteAttribute("Use DependentRequired or DependentSchemas to set the appropriate message.")]
public static string Dependencies { get; public set; }
    public static string DependentRequired { get; public set; }
    public static string DependentSchemas { get; public set; }
    public static string Enum { get; public set; }
    public static CultureInfo Culture { get; public set; }
    public static string ExclusiveMaximum { get; public set; }
    public static string ExclusiveMinimum { get; public set; }
    public static string UnknownFormat { get; public set; }
    public static string Format { get; public set; }
    public static string FormatWithDetail { get; public set; }
    [NullableAttribute("1")]
[ObsoleteAttribute("Invalid use of array-form `items` will result in an exception now.")]
public static string InvalidItemsForm { get; public set; }
    [NullableAttribute("1")]
public static string FalseSchema { get; public set; }
    public static string Maximum { get; public set; }
    public static string MaxItems { get; public set; }
    public static string MaxLength { get; public set; }
    public static string MaxProperties { get; public set; }
    public static string Minimum { get; public set; }
    public static string MinItems { get; public set; }
    public static string MinLength { get; public set; }
    public static string MinProperties { get; public set; }
    public static string MultipleOf { get; public set; }
    public static string OneOf { get; public set; }
    [NullableAttribute("1")]
[ObsoleteAttribute("Unsupported patterns will now throw exceptions.")]
public static string InvalidPattern { get; public set; }
    public static string Pattern { get; public set; }
    public static string Required { get; public set; }
    public static string MetaSchemaValidation { get; public set; }
    public static string Type { get; public set; }
    public static string UniqueItems { get; public set; }
    public static string UnknownVocabularies { get; public set; }
    private static ErrorMessages();
    [CompilerGeneratedAttribute]
public static string get_Const();
    [CompilerGeneratedAttribute]
public static void set_Const(string value);
    [NullableContextAttribute("1")]
public static string GetConst(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_ContainsTooFew();
    [CompilerGeneratedAttribute]
public static void set_ContainsTooFew(string value);
    [NullableContextAttribute("1")]
public static string GetContainsTooFew(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_ContainsTooMany();
    [CompilerGeneratedAttribute]
public static void set_ContainsTooMany(string value);
    [NullableContextAttribute("1")]
public static string GetContainsTooMany(CultureInfo culture);
    [NullableContextAttribute("1")]
public static string get_Dependencies();
    [NullableContextAttribute("1")]
public static void set_Dependencies(string value);
    [CompilerGeneratedAttribute]
public static string get_DependentRequired();
    [CompilerGeneratedAttribute]
public static void set_DependentRequired(string value);
    [NullableContextAttribute("1")]
public static string GetDependentRequired(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_DependentSchemas();
    [CompilerGeneratedAttribute]
public static void set_DependentSchemas(string value);
    [NullableContextAttribute("1")]
public static string GetDependentSchemas(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_Enum();
    [CompilerGeneratedAttribute]
public static void set_Enum(string value);
    [NullableContextAttribute("1")]
public static string GetEnum(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public static void set_Culture(CultureInfo value);
    private static string Get(CultureInfo culture, string key);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ReplaceTokens(string message, ValueTuple`2[] parameters);
    [CompilerGeneratedAttribute]
public static string get_ExclusiveMaximum();
    [CompilerGeneratedAttribute]
public static void set_ExclusiveMaximum(string value);
    [NullableContextAttribute("1")]
public static string GetExclusiveMaximum(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_ExclusiveMinimum();
    [CompilerGeneratedAttribute]
public static void set_ExclusiveMinimum(string value);
    [NullableContextAttribute("1")]
public static string GetExclusiveMinimum(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_UnknownFormat();
    [CompilerGeneratedAttribute]
public static void set_UnknownFormat(string value);
    [NullableContextAttribute("1")]
public static string GetUnknownFormat(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_Format();
    [CompilerGeneratedAttribute]
public static void set_Format(string value);
    [NullableContextAttribute("1")]
public static string GetFormat(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_FormatWithDetail();
    [CompilerGeneratedAttribute]
public static void set_FormatWithDetail(string value);
    [NullableContextAttribute("1")]
public static string GetFormatWithDetail(CultureInfo culture);
    [NullableContextAttribute("1")]
public static string get_InvalidItemsForm();
    [NullableContextAttribute("1")]
public static void set_InvalidItemsForm(string value);
    [NullableContextAttribute("1")]
public static string get_FalseSchema();
    [NullableContextAttribute("1")]
public static void set_FalseSchema(string value);
    [CompilerGeneratedAttribute]
public static string get_Maximum();
    [CompilerGeneratedAttribute]
public static void set_Maximum(string value);
    [NullableContextAttribute("1")]
public static string GetMaximum(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_MaxItems();
    [CompilerGeneratedAttribute]
public static void set_MaxItems(string value);
    [NullableContextAttribute("1")]
public static string GetMaxItems(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_MaxLength();
    [CompilerGeneratedAttribute]
public static void set_MaxLength(string value);
    [NullableContextAttribute("1")]
public static string GetMaxLength(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_MaxProperties();
    [CompilerGeneratedAttribute]
public static void set_MaxProperties(string value);
    [NullableContextAttribute("1")]
public static string GetMaxProperties(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_Minimum();
    [CompilerGeneratedAttribute]
public static void set_Minimum(string value);
    [NullableContextAttribute("1")]
public static string GetMinimum(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_MinItems();
    [CompilerGeneratedAttribute]
public static void set_MinItems(string value);
    [NullableContextAttribute("1")]
public static string GetMinItems(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_MinLength();
    [CompilerGeneratedAttribute]
public static void set_MinLength(string value);
    [NullableContextAttribute("1")]
public static string GetMinLength(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_MinProperties();
    [CompilerGeneratedAttribute]
public static void set_MinProperties(string value);
    [NullableContextAttribute("1")]
public static string GetMinProperties(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_MultipleOf();
    [CompilerGeneratedAttribute]
public static void set_MultipleOf(string value);
    [NullableContextAttribute("1")]
public static string GetMultipleOf(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_OneOf();
    [CompilerGeneratedAttribute]
public static void set_OneOf(string value);
    [NullableContextAttribute("1")]
public static string GetOneOf(CultureInfo culture);
    [NullableContextAttribute("1")]
public static string get_InvalidPattern();
    [NullableContextAttribute("1")]
public static void set_InvalidPattern(string value);
    [CompilerGeneratedAttribute]
public static string get_Pattern();
    [CompilerGeneratedAttribute]
public static void set_Pattern(string value);
    [NullableContextAttribute("1")]
public static string GetPattern(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_Required();
    [CompilerGeneratedAttribute]
public static void set_Required(string value);
    [NullableContextAttribute("1")]
public static string GetRequired(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_MetaSchemaValidation();
    [CompilerGeneratedAttribute]
public static void set_MetaSchemaValidation(string value);
    [NullableContextAttribute("1")]
public static string GetMetaSchemaValidation(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_Type();
    [CompilerGeneratedAttribute]
public static void set_Type(string value);
    [NullableContextAttribute("1")]
public static string GetType(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_UniqueItems();
    [CompilerGeneratedAttribute]
public static void set_UniqueItems(string value);
    [NullableContextAttribute("1")]
public static string GetUniqueItems(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_UnknownVocabularies();
    [CompilerGeneratedAttribute]
public static void set_UnknownVocabularies(string value);
    [NullableContextAttribute("1")]
public static string GetUnknownVocabularies(CultureInfo culture);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.EvaluationContext : object {
    private Stack`1<SpecVersion> _evaluatingAs;
    [CompilerGeneratedAttribute]
private EvaluationOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicScope <Scope>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<Uri, Vocabulary[]> <Dialect>k__BackingField;
    [CompilerGeneratedAttribute]
private SpecVersion <EvaluatingAs>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Stack`1<ValueTuple`2<string, JsonPointer>> <NavigatedReferences>k__BackingField;
    public EvaluationOptions Options { get; }
    public DynamicScope Scope { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<Uri, Vocabulary[]> Dialect { get; }
    public SpecVersion EvaluatingAs { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Stack`1<ValueTuple`2<string, JsonPointer>> NavigatedReferences { get; }
    internal EvaluationContext(EvaluationOptions options, SpecVersion evaluatingAs, Uri initialScope);
    [CompilerGeneratedAttribute]
public EvaluationOptions get_Options();
    [CompilerGeneratedAttribute]
public DynamicScope get_Scope();
    [CompilerGeneratedAttribute]
public Dictionary`2<Uri, Vocabulary[]> get_Dialect();
    [CompilerGeneratedAttribute]
public SpecVersion get_EvaluatingAs();
    [CompilerGeneratedAttribute]
private void set_EvaluatingAs(SpecVersion value);
    [CompilerGeneratedAttribute]
internal Stack`1<ValueTuple`2<string, JsonPointer>> get_NavigatedReferences();
    internal IEnumerable`1<IJsonSchemaKeyword> GetKeywordsToProcess(JsonSchema schema, EvaluationOptions options);
    private bool TryGetVocab(JsonSchema schema, Vocabulary[]& vocab);
    internal void PushEvaluatingAs(SpecVersion version);
    internal void PopEvaluatingAs();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private Vocabulary <TryGetVocab>b__19_2(Uri x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.EvaluationOptions : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<Type> _ignoredAnnotationTypes;
    [CompilerGeneratedAttribute]
private static EvaluationOptions <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private SpecVersion <EvaluateAs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateAgainstMetaSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private OutputFormat <OutputFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private SchemaRegistry <SchemaRegistry>k__BackingField;
    [CompilerGeneratedAttribute]
private VocabularyRegistry <VocabularyRegistry>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireFormatValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OnlyKnownFormats>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ProcessCustomKeywords>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveDroppedAnnotations>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    public static EvaluationOptions Default { get; }
    public SpecVersion EvaluateAs { get; public set; }
    public bool ValidateAgainstMetaSchema { get; public set; }
    public OutputFormat OutputFormat { get; public set; }
    public SchemaRegistry SchemaRegistry { get; }
    public VocabularyRegistry VocabularyRegistry { get; }
    public bool RequireFormatValidation { get; public set; }
    public bool OnlyKnownFormats { get; public set; }
    public bool ProcessCustomKeywords { get; public set; }
    public bool PreserveDroppedAnnotations { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<Type> IgnoredAnnotations { get; }
    [NullableAttribute("2")]
public CultureInfo Culture { get; public set; }
    private static EvaluationOptions();
    [CompilerGeneratedAttribute]
public static EvaluationOptions get_Default();
    [CompilerGeneratedAttribute]
public SpecVersion get_EvaluateAs();
    [CompilerGeneratedAttribute]
public void set_EvaluateAs(SpecVersion value);
    [CompilerGeneratedAttribute]
public bool get_ValidateAgainstMetaSchema();
    [CompilerGeneratedAttribute]
public void set_ValidateAgainstMetaSchema(bool value);
    [CompilerGeneratedAttribute]
public OutputFormat get_OutputFormat();
    [CompilerGeneratedAttribute]
public void set_OutputFormat(OutputFormat value);
    [CompilerGeneratedAttribute]
public SchemaRegistry get_SchemaRegistry();
    [CompilerGeneratedAttribute]
public VocabularyRegistry get_VocabularyRegistry();
    [CompilerGeneratedAttribute]
public bool get_RequireFormatValidation();
    [CompilerGeneratedAttribute]
public void set_RequireFormatValidation(bool value);
    [CompilerGeneratedAttribute]
public bool get_OnlyKnownFormats();
    [CompilerGeneratedAttribute]
public void set_OnlyKnownFormats(bool value);
    [CompilerGeneratedAttribute]
public bool get_ProcessCustomKeywords();
    [CompilerGeneratedAttribute]
public void set_ProcessCustomKeywords(bool value);
    [CompilerGeneratedAttribute]
public bool get_PreserveDroppedAnnotations();
    [CompilerGeneratedAttribute]
public void set_PreserveDroppedAnnotations(bool value);
    public IEnumerable`1<Type> get_IgnoredAnnotations();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Culture(CultureInfo value);
    public static EvaluationOptions From(EvaluationOptions other);
    [NullableContextAttribute("0")]
public void IgnoreAnnotationsFrom();
    public void IgnoreAllAnnotations();
    public void ClearIgnoredAnnotations();
    [NullableContextAttribute("2")]
public void CollectAnnotationsFrom();
    internal static IEnumerable`1<IJsonSchemaKeyword> FilterKeywords(IEnumerable`1<IJsonSchemaKeyword> keywords, SpecVersion declaredVersion);
    private static IEnumerable`1<IJsonSchemaKeyword> DisallowSiblingRef(IEnumerable`1<IJsonSchemaKeyword> keywords, SpecVersion version);
    private static IEnumerable`1<IJsonSchemaKeyword> AllowSiblingRef(IEnumerable`1<IJsonSchemaKeyword> keywords, SpecVersion version);
    private static IEnumerable`1<IJsonSchemaKeyword> FilterBySpecVersion(IEnumerable`1<IJsonSchemaKeyword> keywords, SpecVersion version);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[JsonConverterAttribute("Json.Schema.EvaluationResultsJsonConverter")]
public class Json.Schema.EvaluationResults : object {
    private Uri _currentUri;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<string> _backgroundAnnotations;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<string> _ignoredAnnotations;
    [NullableAttribute("2")]
private JsonPointer _reference;
    [NullableAttribute("2")]
private Uri _schemaLocation;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<EvaluationResults> _details;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, JsonNode> _annotations;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, string> _errors;
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPointer <EvaluationPath>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPointer <InstanceLocation>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EvaluationResults <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private OutputFormat <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeDroppedAnnotations>k__BackingField;
    public bool IsValid { get; private set; }
    public JsonPointer EvaluationPath { get; }
    public JsonPointer InstanceLocation { get; }
    public Uri SchemaLocation { get; }
    public IReadOnlyList`1<EvaluationResults> Details { get; }
    public bool HasDetails { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyDictionary`2<string, JsonNode> Annotations { get; }
    public bool HasAnnotations { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyDictionary`2<string, string> Errors { get; }
    public bool HasErrors { get; }
    [NullableAttribute("2")]
public EvaluationResults Parent { get; private set; }
    internal bool Exclude { get; private set; }
    internal OutputFormat Format { get; private set; }
    internal bool IncludeDroppedAnnotations { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IReadOnlyDictionary`2<string, JsonNode> AnnotationsToSerialize { get; }
    internal EvaluationResults(JsonPointer evaluationPath, Uri schemaLocation, JsonPointer instanceLocation, EvaluationOptions options);
    private EvaluationResults(EvaluationResults other);
    [CompilerGeneratedAttribute]
public bool get_IsValid();
    [CompilerGeneratedAttribute]
private void set_IsValid(bool value);
    [CompilerGeneratedAttribute]
public JsonPointer get_EvaluationPath();
    [CompilerGeneratedAttribute]
public JsonPointer get_InstanceLocation();
    public Uri get_SchemaLocation();
    public IReadOnlyList`1<EvaluationResults> get_Details();
    public bool get_HasDetails();
    public IReadOnlyDictionary`2<string, JsonNode> get_Annotations();
    public bool get_HasAnnotations();
    public IReadOnlyDictionary`2<string, string> get_Errors();
    public bool get_HasErrors();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public EvaluationResults get_Parent();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Parent(EvaluationResults value);
    [CompilerGeneratedAttribute]
internal bool get_Exclude();
    [CompilerGeneratedAttribute]
private void set_Exclude(bool value);
    [CompilerGeneratedAttribute]
internal OutputFormat get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(OutputFormat value);
    [CompilerGeneratedAttribute]
internal bool get_IncludeDroppedAnnotations();
    internal IReadOnlyDictionary`2<string, JsonNode> get_AnnotationsToSerialize();
    internal void SetSchemaReference(JsonPointer pointer);
    private Uri BuildSchemaLocation();
    public void ToList();
    private IEnumerable`1<EvaluationResults> GetAllChildren();
    public void ToFlag();
    public void SetAnnotation(string keyword, JsonNode value);
    public bool TryGetAnnotation(string keyword, JsonNode& annotation);
    [IteratorStateMachineAttribute("Json.Schema.EvaluationResults/<GetAllAnnotations>d__58")]
public IEnumerable`1<JsonNode> GetAllAnnotations(string keyword);
    public void Fail();
    public void Fail(string keyword, string message);
    public void Fail(string keyword, string message, ValueTuple`2[] parameters);
    internal void AddNestedResult(EvaluationResults results);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <get_AnnotationsToSerialize>b__48_0(KeyValuePair`2<string, JsonNode> x);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.EvaluationResultsJsonConverter : JsonConverter`1<EvaluationResults> {
    public virtual EvaluationResults Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, EvaluationResults value, JsonSerializerOptions options);
}
[SchemaKeywordAttribute("examples")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/meta-data")]
[JsonConverterAttribute("Json.Schema.ExamplesKeywordJsonConverter")]
public class Json.Schema.ExamplesKeyword : object {
    [NullableAttribute("1")]
public static string Name;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<JsonNode> <Values>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<JsonNode> Values { get; }
    public ExamplesKeyword(JsonNode[] values);
    public ExamplesKeyword(IEnumerable`1<JsonNode> values);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<JsonNode> get_Values();
    [NullableContextAttribute("1")]
public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.ExamplesKeywordJsonConverter : JsonConverter`1<ExamplesKeyword> {
    public virtual ExamplesKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ExamplesKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("exclusiveMaximum")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.ExclusiveMaximumKeywordJsonConverter")]
public class Json.Schema.ExclusiveMaximumKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private decimal <Value>k__BackingField;
    public decimal Value { get; }
    public ExclusiveMaximumKeyword(decimal value);
    [CompilerGeneratedAttribute]
public decimal get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.ExclusiveMaximumKeywordJsonConverter : JsonConverter`1<ExclusiveMaximumKeyword> {
    public virtual ExclusiveMaximumKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ExclusiveMaximumKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("exclusiveMinimum")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.ExclusiveMinimumKeywordJsonConverter")]
public class Json.Schema.ExclusiveMinimumKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private decimal <Value>k__BackingField;
    public decimal Value { get; }
    public ExclusiveMinimumKeyword(decimal value);
    [CompilerGeneratedAttribute]
public decimal get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.ExclusiveMinimumKeywordJsonConverter : JsonConverter`1<ExclusiveMinimumKeyword> {
    public virtual ExclusiveMinimumKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ExclusiveMinimumKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.Format : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    public string Key { get; }
    public Format(string key);
    [CompilerGeneratedAttribute]
public string get_Key();
    [NullableContextAttribute("2")]
public virtual bool Validate(JsonNode node, String& errorMessage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("format")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/format")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/format-annotation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/format-assertion")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/format-annotation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/format-assertion")]
[JsonConverterAttribute("Json.Schema.FormatKeywordJsonConverter")]
public class Json.Schema.FormatKeyword : object {
    public static string Name;
    private static Uri[] _formatAssertionIds;
    [CompilerGeneratedAttribute]
private Format <Value>k__BackingField;
    public Format Value { get; }
    public FormatKeyword(Format value);
    private static FormatKeyword();
    [CompilerGeneratedAttribute]
public Format get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void AssertionEvaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.FormatKeywordJsonConverter : JsonConverter`1<FormatKeyword> {
    public virtual FormatKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, FormatKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Json.Schema.Formats : object {
    private static ConcurrentDictionary`2<string, Format> _registry;
    private static String[] _timeFormats;
    public static Format Date;
    public static Format DateTime;
    public static Format Duration;
    public static Format Email;
    public static Format Hostname;
    public static Format IdnEmail;
    public static Format IdnHostname;
    public static Format Ipv4;
    public static Format Ipv6;
    public static Format Iri;
    public static Format IriReference;
    public static Format JsonPointer;
    public static Format Regex;
    public static Format RelativeJsonPointer;
    public static Format Time;
    public static Format Uri;
    public static Format UriReference;
    public static Format UriTemplate;
    public static Format Uuid;
    private static Formats();
    public static Format Get(string key);
    public static void Register(Format format);
    public static Format CreateUnknown(string name);
    [NullableContextAttribute("2")]
private static bool CheckAbsoluteUri(JsonNode node);
    [NullableContextAttribute("2")]
private static bool CheckUri(JsonNode node);
    [NullableContextAttribute("2")]
private static bool CheckUriTemplate(JsonNode node);
    [NullableContextAttribute("2")]
private static bool CheckJsonPointer(JsonNode node);
    [NullableContextAttribute("2")]
private static bool CheckRelativeJsonPointer(JsonNode node);
    [NullableContextAttribute("2")]
private static bool CheckEmail(JsonNode node);
    private static string DomainMapper(Match match);
    [NullableContextAttribute("2")]
private static bool CheckUuid(JsonNode node);
    [NullableContextAttribute("2")]
private static bool CheckDate(JsonNode node);
    [NullableContextAttribute("2")]
private static bool CheckTime(JsonNode node);
    [NullableContextAttribute("2")]
private static bool CheckDateTime(JsonNode node);
    private static bool CheckDateFormat(JsonNode node, String[] formats);
    [NullableContextAttribute("2")]
private static bool CheckHostName(JsonNode node);
    [NullableContextAttribute("2")]
private static bool CheckIpv4(JsonNode node);
    [NullableContextAttribute("2")]
private static bool CheckIpv6(JsonNode node);
    [NullableContextAttribute("2")]
private static bool CheckHostName(JsonNode node, UriHostNameType type);
    [NullableContextAttribute("2")]
private static bool CheckDuration(JsonNode node);
    [NullableContextAttribute("2")]
private static bool CheckRegex(JsonNode node);
}
[NullableContextAttribute("1")]
public interface Json.Schema.IBaseDocument {
    public Uri BaseUri { get; }
    public abstract virtual Uri get_BaseUri();
    public abstract virtual JsonSchema FindSubschema(JsonPointer pointer, EvaluationOptions options);
}
[NullableContextAttribute("1")]
public interface Json.Schema.ICustomSchemaCollector {
    public IEnumerable`1<JsonSchema> Schemas { get; }
    public abstract virtual IEnumerable`1<JsonSchema> get_Schemas();
    public abstract virtual ValueTuple`2<JsonSchema, int> FindSubschema(IReadOnlyList`1<PointerSegment> segments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("$id")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/core")]
[JsonConverterAttribute("Json.Schema.IdKeywordJsonConverter")]
public class Json.Schema.IdKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private Uri <Id>k__BackingField;
    public Uri Id { get; }
    public IdKeyword(Uri id);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_Id();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.IdKeywordJsonConverter : JsonConverter`1<IdKeyword> {
    public virtual IdKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, IdKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("if")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[JsonConverterAttribute("Json.Schema.IfKeywordJsonConverter")]
public class Json.Schema.IfKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    public JsonSchema Schema { get; }
    public IfKeyword(JsonSchema value);
    [CompilerGeneratedAttribute]
public sealed virtual JsonSchema get_Schema();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.IfKeywordJsonConverter : JsonConverter`1<IfKeyword> {
    public virtual IfKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, IfKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
public interface Json.Schema.IIdKeyword {
    public Uri Id { get; }
    public abstract virtual Uri get_Id();
}
[NullableContextAttribute("1")]
public interface Json.Schema.IJsonSchemaKeyword {
    public abstract virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
public interface Json.Schema.IKeyedSchemaCollector {
    public IReadOnlyDictionary`2<string, JsonSchema> Schemas { get; }
    public abstract virtual IReadOnlyDictionary`2<string, JsonSchema> get_Schemas();
}
[NullableContextAttribute("1")]
public interface Json.Schema.ISchemaCollector {
    public IReadOnlyList`1<JsonSchema> Schemas { get; }
    public abstract virtual IReadOnlyList`1<JsonSchema> get_Schemas();
}
[NullableContextAttribute("1")]
public interface Json.Schema.ISchemaContainer {
    public JsonSchema Schema { get; }
    public abstract virtual JsonSchema get_Schema();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("items")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[DependsOnAnnotationsFromAttribute("Json.Schema.PrefixItemsKeyword")]
[JsonConverterAttribute("Json.Schema.ItemsKeywordJsonConverter")]
public class Json.Schema.ItemsKeyword : object {
    public static string Name;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonSchema <SingleSchema>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<JsonSchema> <ArraySchemas>k__BackingField;
    [NullableAttribute("2")]
public JsonSchema SingleSchema { get; }
    private JsonSchema Json.Schema.ISchemaContainer.Schema { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<JsonSchema> ArraySchemas { get; }
    private IReadOnlyList`1<JsonSchema> Json.Schema.ISchemaCollector.Schemas { get; }
    public ItemsKeyword(JsonSchema value);
    public ItemsKeyword(JsonSchema[] values);
    public ItemsKeyword(IEnumerable`1<JsonSchema> values);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public JsonSchema get_SingleSchema();
    private sealed virtual override JsonSchema Json.Schema.ISchemaContainer.get_Schema();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<JsonSchema> get_ArraySchemas();
    private sealed virtual override IReadOnlyList`1<JsonSchema> Json.Schema.ISchemaCollector.get_Schemas();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.ItemsKeywordJsonConverter : JsonConverter`1<ItemsKeyword> {
    public virtual ItemsKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ItemsKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.JsonNodeBaseDocument : object {
    private JsonNode _node;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<JsonPointer, JsonSchema> _foundSubschemas;
    [CompilerGeneratedAttribute]
private Uri <BaseUri>k__BackingField;
    public Uri BaseUri { get; }
    public JsonNodeBaseDocument(JsonNode node, Uri baseUri);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_BaseUri();
    public sealed virtual JsonSchema FindSubschema(JsonPointer pointer, EvaluationOptions options);
}
[ExtensionAttribute]
public static class Json.Schema.JsonNodeExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static SchemaValueType GetSchemaValueType(JsonNode node);
    private static SchemaValueType GetSchemaValueType(JsonElement element);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool VerifyJsonObject(JsonObject obj);
}
public static class Json.Schema.JsonPointers : object {
    [NullableAttribute("1")]
public static JsonPointer[] SingleEmptyPointerArray;
    private static JsonPointers();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[JsonConverterAttribute("Json.Schema.SchemaJsonConverter")]
[DebuggerDisplayAttribute("{ToDebugString()}")]
public class Json.Schema.JsonSchema : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, IJsonSchemaKeyword> _keywords;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<DynamicScope, SchemaConstraint>> _constraints;
    public static JsonSchema Empty;
    public static JsonSchema True;
    public static JsonSchema False;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <BoolValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <BaseUri>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsResourceRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private SpecVersion <DeclaredVersion>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, ValueTuple`2<JsonSchema, bool>> <Anchors>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonSchema <RecursiveAnchor>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyCollection`1<IJsonSchemaKeyword> Keywords { get; }
    [NullableAttribute("2")]
public IJsonSchemaKeyword Item { get; }
    public Nullable`1<bool> BoolValue { get; }
    public Uri BaseUri { get; public set; }
    public bool IsResourceRoot { get; private set; }
    public SpecVersion DeclaredVersion { get; private set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Dictionary`2<string, ValueTuple`2<JsonSchema, bool>> Anchors { get; }
    [NullableAttribute("2")]
internal JsonSchema RecursiveAnchor { get; internal set; }
    private JsonSchema(bool value);
    internal JsonSchema(IEnumerable`1<IJsonSchemaKeyword> keywords);
    private static JsonSchema();
    public IReadOnlyCollection`1<IJsonSchemaKeyword> get_Keywords();
    public IJsonSchemaKeyword get_Item(string keyword);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_BoolValue();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_BaseUri();
    [CompilerGeneratedAttribute]
public void set_BaseUri(Uri value);
    [CompilerGeneratedAttribute]
public bool get_IsResourceRoot();
    [CompilerGeneratedAttribute]
private void set_IsResourceRoot(bool value);
    [CompilerGeneratedAttribute]
public SpecVersion get_DeclaredVersion();
    [CompilerGeneratedAttribute]
private void set_DeclaredVersion(SpecVersion value);
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, ValueTuple`2<JsonSchema, bool>> get_Anchors();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal JsonSchema get_RecursiveAnchor();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_RecursiveAnchor(JsonSchema value);
    public static JsonSchema FromFile(string fileName, JsonSerializerOptions options);
    public static JsonSchema FromText(string jsonText, JsonSerializerOptions options);
    public static ValueTask`1<JsonSchema> FromStream(Stream source, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
internal static EvaluationResults AutoEvaluate(JsonNode root, EvaluationOptions options);
    private static Uri GenerateBaseUri();
    [NullableContextAttribute("0")]
public T GetKeyword();
    [NullableContextAttribute("0")]
public bool TryGetKeyword(T& keyword);
    public bool TryGetKeyword(string keywordName, T& keyword);
    [NullableContextAttribute("2")]
public EvaluationResults Evaluate(JsonNode root, EvaluationOptions options);
    private bool IsDynamic();
    public SchemaConstraint GetConstraint(JsonPointer relativeEvaluationPath, JsonPointer baseInstanceLocation, JsonPointer relativeInstanceLocation, EvaluationContext context);
    private SchemaConstraint BuildConstraint(JsonPointer evaluationPath, JsonPointer baseInstanceLocation, JsonPointer relativeInstanceLocation, DynamicScope scope);
    private SchemaConstraint CheckScopedConstraints(DynamicScope scope);
    private void PopulateConstraint(SchemaConstraint constraint, EvaluationContext context);
    internal static void Initialize(JsonSchema schema, SchemaRegistry registry, Uri baseUri);
    private static SpecVersion DetermineSpecVersion(JsonSchema schema, SchemaRegistry registry, SpecVersion desiredDraft);
    private static void PopulateBaseUris(JsonSchema schema, JsonSchema resourceRoot, Uri currentBaseUri, SchemaRegistry registry, SpecVersion evaluatingAs, bool selfRegister);
    [IteratorStateMachineAttribute("Json.Schema.JsonSchema/<GetSubschemas>d__50")]
internal static IEnumerable`1<JsonSchema> GetSubschemas(IJsonSchemaKeyword keyword);
    private sealed virtual override JsonSchema Json.Schema.IBaseDocument.FindSubschema(JsonPointer pointer, EvaluationOptions options);
    public JsonSchema GetAnchor(string anchorName);
    public static JsonSchema op_Implicit(bool value);
    private string ToDebugString();
    [CompilerGeneratedAttribute]
internal static object <Json.Schema.IBaseDocument.FindSubschema>g__ExtractSchemaFromData|51_0(JsonPointer localPointer, JsonNode data, JsonSchema hostSchema, <>c__DisplayClass51_0& );
    [CompilerGeneratedAttribute]
internal static object <Json.Schema.IBaseDocument.FindSubschema>g__CheckResolvable|51_1(object localResolvable, Int32& i, string pointerSegment, JsonSchema& hostSchema, <>c__DisplayClass51_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.JsonSchemaBuilder : object {
    private Dictionary`2<string, IJsonSchemaKeyword> _keywords;
    [NullableAttribute("2")]
private Uri _baseUri;
    internal void TrySetBaseUri(Uri uri);
    public void Add(IJsonSchemaKeyword keyword);
    [NullableContextAttribute("0")]
public T Get();
    public static JsonSchema RefRoot();
    public static JsonSchema RecursiveRefRoot();
    public JsonSchema Build();
    public static JsonSchema op_Implicit(JsonSchemaBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Json.Schema.JsonSchemaBuilderExtensions : object {
    [ExtensionAttribute]
public static JsonSchemaBuilder AdditionalItems(JsonSchemaBuilder builder, JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchemaBuilder AdditionalProperties(JsonSchemaBuilder builder, JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchemaBuilder AllOf(JsonSchemaBuilder builder, JsonSchema[] schemas);
    [ExtensionAttribute]
public static JsonSchemaBuilder AllOf(JsonSchemaBuilder builder, IEnumerable`1<JsonSchema> schemas);
    [ExtensionAttribute]
public static JsonSchemaBuilder Anchor(JsonSchemaBuilder builder, string reference);
    [ExtensionAttribute]
public static JsonSchemaBuilder AnyOf(JsonSchemaBuilder builder, JsonSchema[] schemas);
    [ExtensionAttribute]
public static JsonSchemaBuilder AnyOf(JsonSchemaBuilder builder, IEnumerable`1<JsonSchema> schemas);
    [ExtensionAttribute]
public static JsonSchemaBuilder Comment(JsonSchemaBuilder builder, string comment);
    [ExtensionAttribute]
public static JsonSchemaBuilder Const(JsonSchemaBuilder builder, JsonNode node);
    [ExtensionAttribute]
public static JsonSchemaBuilder Contains(JsonSchemaBuilder builder, JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchemaBuilder Default(JsonSchemaBuilder builder, JsonNode node);
    [ExtensionAttribute]
public static JsonSchemaBuilder Definitions(JsonSchemaBuilder builder, IReadOnlyDictionary`2<string, JsonSchema> defs);
    [ExtensionAttribute]
public static JsonSchemaBuilder Definitions(JsonSchemaBuilder builder, ValueTuple`2[] defs);
    [ExtensionAttribute]
public static JsonSchemaBuilder Defs(JsonSchemaBuilder builder, IReadOnlyDictionary`2<string, JsonSchema> defs);
    [ExtensionAttribute]
public static JsonSchemaBuilder Defs(JsonSchemaBuilder builder, ValueTuple`2[] defs);
    [ExtensionAttribute]
public static JsonSchemaBuilder Dependencies(JsonSchemaBuilder builder, IReadOnlyDictionary`2<string, SchemaOrPropertyList> deps);
    [ExtensionAttribute]
public static JsonSchemaBuilder Dependencies(JsonSchemaBuilder builder, ValueTuple`2[] deps);
    [ExtensionAttribute]
public static JsonSchemaBuilder DependentRequired(JsonSchemaBuilder builder, IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> deps);
    [ExtensionAttribute]
public static JsonSchemaBuilder DependentRequired(JsonSchemaBuilder builder, ValueTuple`2[] deps);
    [ExtensionAttribute]
public static JsonSchemaBuilder DependentSchemas(JsonSchemaBuilder builder, IReadOnlyDictionary`2<string, JsonSchema> deps);
    [ExtensionAttribute]
public static JsonSchemaBuilder DependentSchemas(JsonSchemaBuilder builder, ValueTuple`2[] deps);
    [ExtensionAttribute]
public static JsonSchemaBuilder Deprecated(JsonSchemaBuilder builder, bool deprecated);
    [ExtensionAttribute]
public static JsonSchemaBuilder Description(JsonSchemaBuilder builder, string description);
    [ExtensionAttribute]
public static JsonSchemaBuilder DynamicAnchor(JsonSchemaBuilder builder, string reference);
    [ExtensionAttribute]
public static JsonSchemaBuilder DynamicRef(JsonSchemaBuilder builder, Uri reference);
    [ExtensionAttribute]
public static JsonSchemaBuilder DynamicRef(JsonSchemaBuilder builder, string reference);
    [ExtensionAttribute]
public static JsonSchemaBuilder Else(JsonSchemaBuilder builder, JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchemaBuilder Enum(JsonSchemaBuilder builder, IEnumerable`1<JsonNode> elements);
    [ExtensionAttribute]
public static JsonSchemaBuilder Enum(JsonSchemaBuilder builder, JsonNode[] elements);
    [ExtensionAttribute]
public static JsonSchemaBuilder Enum(JsonSchemaBuilder builder, IEnumerable`1<string> elements);
    [ExtensionAttribute]
public static JsonSchemaBuilder Examples(JsonSchemaBuilder builder, IEnumerable`1<JsonNode> elements);
    [ExtensionAttribute]
public static JsonSchemaBuilder Examples(JsonSchemaBuilder builder, JsonNode[] elements);
    [ExtensionAttribute]
public static JsonSchemaBuilder ExclusiveMaximum(JsonSchemaBuilder builder, decimal max);
    [ExtensionAttribute]
public static JsonSchemaBuilder ExclusiveMinimum(JsonSchemaBuilder builder, decimal min);
    [ExtensionAttribute]
public static JsonSchemaBuilder Format(JsonSchemaBuilder builder, string format);
    [ExtensionAttribute]
public static JsonSchemaBuilder Format(JsonSchemaBuilder builder, Format format);
    [ExtensionAttribute]
public static JsonSchemaBuilder Id(JsonSchemaBuilder builder, Uri id);
    [ExtensionAttribute]
public static JsonSchemaBuilder Id(JsonSchemaBuilder builder, string id);
    [ExtensionAttribute]
public static JsonSchemaBuilder If(JsonSchemaBuilder builder, JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchemaBuilder Items(JsonSchemaBuilder builder, JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchemaBuilder Items(JsonSchemaBuilder builder, IEnumerable`1<JsonSchema> schemas);
    [ExtensionAttribute]
public static JsonSchemaBuilder MaxContains(JsonSchemaBuilder builder, UInt32 value);
    [ExtensionAttribute]
public static JsonSchemaBuilder Maximum(JsonSchemaBuilder builder, decimal value);
    [ExtensionAttribute]
public static JsonSchemaBuilder MaxItems(JsonSchemaBuilder builder, UInt32 value);
    [ExtensionAttribute]
public static JsonSchemaBuilder MaxLength(JsonSchemaBuilder builder, UInt32 value);
    [ExtensionAttribute]
public static JsonSchemaBuilder MaxProperties(JsonSchemaBuilder builder, UInt32 value);
    [ExtensionAttribute]
public static JsonSchemaBuilder MinContains(JsonSchemaBuilder builder, UInt32 value);
    [ExtensionAttribute]
public static JsonSchemaBuilder Minimum(JsonSchemaBuilder builder, decimal value);
    [ExtensionAttribute]
public static JsonSchemaBuilder MinItems(JsonSchemaBuilder builder, UInt32 value);
    [ExtensionAttribute]
public static JsonSchemaBuilder MinLength(JsonSchemaBuilder builder, UInt32 value);
    [ExtensionAttribute]
public static JsonSchemaBuilder MinProperties(JsonSchemaBuilder builder, UInt32 value);
    [ExtensionAttribute]
public static JsonSchemaBuilder MultipleOf(JsonSchemaBuilder builder, decimal value);
    [ExtensionAttribute]
public static JsonSchemaBuilder Not(JsonSchemaBuilder builder, JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchemaBuilder OneOf(JsonSchemaBuilder builder, JsonSchema[] schemas);
    [ExtensionAttribute]
public static JsonSchemaBuilder OneOf(JsonSchemaBuilder builder, IEnumerable`1<JsonSchema> schemas);
    [ExtensionAttribute]
public static JsonSchemaBuilder Pattern(JsonSchemaBuilder builder, Regex pattern);
    [ExtensionAttribute]
public static JsonSchemaBuilder Pattern(JsonSchemaBuilder builder, string pattern);
    [ExtensionAttribute]
public static JsonSchemaBuilder PatternProperties(JsonSchemaBuilder builder, IReadOnlyDictionary`2<Regex, JsonSchema> props);
    [ExtensionAttribute]
public static JsonSchemaBuilder PatternProperties(JsonSchemaBuilder builder, ValueTuple`2[] props);
    [ExtensionAttribute]
public static JsonSchemaBuilder PatternProperties(JsonSchemaBuilder builder, IReadOnlyDictionary`2<string, JsonSchema> props);
    [ExtensionAttribute]
public static JsonSchemaBuilder PatternProperties(JsonSchemaBuilder builder, ValueTuple`2[] props);
    [ExtensionAttribute]
public static JsonSchemaBuilder PrefixItems(JsonSchemaBuilder builder, JsonSchema[] schemas);
    [ExtensionAttribute]
public static JsonSchemaBuilder PrefixItems(JsonSchemaBuilder builder, IEnumerable`1<JsonSchema> schemas);
    [ExtensionAttribute]
public static JsonSchemaBuilder Properties(JsonSchemaBuilder builder, IReadOnlyDictionary`2<string, JsonSchema> props);
    [ExtensionAttribute]
public static JsonSchemaBuilder Properties(JsonSchemaBuilder builder, ValueTuple`2[] props);
    [ExtensionAttribute]
public static JsonSchemaBuilder PropertyDependencies(JsonSchemaBuilder builder, IReadOnlyDictionary`2<string, PropertyDependency> dependencies);
    [ExtensionAttribute]
public static JsonSchemaBuilder PropertyDependencies(JsonSchemaBuilder builder, ValueTuple`2[] dependencies);
    [ExtensionAttribute]
public static JsonSchemaBuilder PropertyNames(JsonSchemaBuilder builder, JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchemaBuilder ReadOnly(JsonSchemaBuilder builder, bool value);
    [ExtensionAttribute]
public static JsonSchemaBuilder RecursiveAnchor(JsonSchemaBuilder builder, bool value);
    [ExtensionAttribute]
public static JsonSchemaBuilder RecursiveRef(JsonSchemaBuilder builder, Uri reference);
    [ExtensionAttribute]
public static JsonSchemaBuilder RecursiveRef(JsonSchemaBuilder builder, string reference);
    [ExtensionAttribute]
public static JsonSchemaBuilder Ref(JsonSchemaBuilder builder, Uri reference);
    [ExtensionAttribute]
public static JsonSchemaBuilder Ref(JsonSchemaBuilder builder, string reference);
    [ExtensionAttribute]
public static JsonSchemaBuilder Required(JsonSchemaBuilder builder, IEnumerable`1<string> properties);
    [ExtensionAttribute]
public static JsonSchemaBuilder Required(JsonSchemaBuilder builder, String[] properties);
    [ExtensionAttribute]
public static JsonSchemaBuilder Schema(JsonSchemaBuilder builder, Uri uri);
    [ExtensionAttribute]
public static JsonSchemaBuilder Schema(JsonSchemaBuilder builder, string uri);
    [ExtensionAttribute]
public static JsonSchemaBuilder Then(JsonSchemaBuilder builder, JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchemaBuilder Title(JsonSchemaBuilder builder, string title);
    [ExtensionAttribute]
public static JsonSchemaBuilder Type(JsonSchemaBuilder builder, SchemaValueType type);
    [ExtensionAttribute]
public static JsonSchemaBuilder Type(JsonSchemaBuilder builder, SchemaValueType[] types);
    [ExtensionAttribute]
public static JsonSchemaBuilder Type(JsonSchemaBuilder builder, IEnumerable`1<SchemaValueType> types);
    [ExtensionAttribute]
public static JsonSchemaBuilder UnevaluatedItems(JsonSchemaBuilder builder, JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchemaBuilder UnevaluatedProperties(JsonSchemaBuilder builder, JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchemaBuilder UniqueItems(JsonSchemaBuilder builder, bool value);
    [ExtensionAttribute]
public static JsonSchemaBuilder Unrecognized(JsonSchemaBuilder builder, string name, JsonNode value);
    [ExtensionAttribute]
public static JsonSchemaBuilder Vocabulary(JsonSchemaBuilder builder, ValueTuple`2[] vocabs);
    [ExtensionAttribute]
public static JsonSchemaBuilder Vocabulary(JsonSchemaBuilder builder, ValueTuple`2[] vocabs);
    [ExtensionAttribute]
public static JsonSchemaBuilder Vocabulary(JsonSchemaBuilder builder, IReadOnlyDictionary`2<Uri, bool> vocabs);
    [ExtensionAttribute]
public static JsonSchemaBuilder Vocabulary(JsonSchemaBuilder builder, IReadOnlyDictionary`2<string, bool> vocabs);
    [ExtensionAttribute]
public static JsonSchemaBuilder WriteOnly(JsonSchemaBuilder builder, bool value);
    [ExtensionAttribute]
public static EvaluationResults Evaluate(JsonSchemaBuilder builder, JsonNode root, EvaluationOptions options);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Evalute() instead.")]
public static EvaluationResults Validate(JsonSchemaBuilder builder, JsonNode root, EvaluationOptions options);
}
public class Json.Schema.JsonSchemaException : Exception {
    [NullableContextAttribute("1")]
public JsonSchemaException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Json.Schema.JsonSchemaExtensions : object {
    [ExtensionAttribute]
public static EvaluationResults Evaluate(JsonSchema jsonSchema, JsonDocument jsonDocument, EvaluationOptions options);
    [ExtensionAttribute]
public static EvaluationResults Evaluate(JsonSchema jsonSchema, JsonElement jsonElement, EvaluationOptions options);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Evaluate() instead.")]
public static EvaluationResults Validate(JsonSchema jsonSchema, JsonNode jsonNode, EvaluationOptions options);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Evaluate() instead.")]
public static EvaluationResults Validate(JsonSchema jsonSchema, JsonDocument jsonDocument, EvaluationOptions options);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Evaluate() instead.")]
public static EvaluationResults Validate(JsonSchema jsonSchema, JsonElement jsonElement, EvaluationOptions options);
    [ExtensionAttribute]
public static JsonSchema Bundle(JsonSchema jsonSchema, EvaluationOptions options);
    [ExtensionAttribute]
public static JsonSchema GetAdditionalItems(JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchema GetAdditionalProperties(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyCollection`1<JsonSchema> GetAllOf(JsonSchema schema);
    [ExtensionAttribute]
public static string GetAnchor(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyCollection`1<JsonSchema> GetAnyOf(JsonSchema schema);
    [ExtensionAttribute]
public static string GetComment(JsonSchema schema);
    [ExtensionAttribute]
public static JsonNode GetConst(JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchema GetContains(JsonSchema schema);
    [ExtensionAttribute]
public static string GetContentEncoding(JsonSchema schema);
    [ExtensionAttribute]
public static string GetContentMediaType(JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchema GetContentSchema(JsonSchema schema);
    [ExtensionAttribute]
public static JsonNode GetDefault(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<string, JsonSchema> GetDefinitions(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<string, JsonSchema> GetDefs(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<string, SchemaOrPropertyList> GetDependencies(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> GetDependentRequired(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<string, JsonSchema> GetDependentSchemas(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<bool> GetDeprecated(JsonSchema schema);
    [ExtensionAttribute]
public static string GetDescription(JsonSchema schema);
    [ExtensionAttribute]
public static string GetDynamicAnchor(JsonSchema schema);
    [ExtensionAttribute]
public static Uri GetDynamicRef(JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchema GetElse(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyCollection`1<JsonNode> GetEnum(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyCollection`1<JsonNode> GetExamples(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<decimal> GetExclusiveMaximum(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<decimal> GetExclusiveMinimum(JsonSchema schema);
    [ExtensionAttribute]
public static Format GetFormat(JsonSchema schema);
    [ExtensionAttribute]
public static Uri GetId(JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchema GetIf(JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchema GetItems(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyCollection`1<JsonSchema> GetItemsArrayForm(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<UInt32> GetMaxContains(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<decimal> GetMaximum(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<UInt32> GetMaxItems(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<UInt32> GetMaxLength(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<UInt32> GetMaxProperties(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<UInt32> GetMinContains(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<decimal> GetMinimum(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<UInt32> GetMinItems(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<UInt32> GetMinLength(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<UInt32> GetMinProperties(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<decimal> GetMultipleOf(JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchema GetNot(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyCollection`1<JsonSchema> GetOneOf(JsonSchema schema);
    [ExtensionAttribute]
public static Regex GetPattern(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<Regex, JsonSchema> GetPatternProperties(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyCollection`1<JsonSchema> GetPrefixItems(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<string, JsonSchema> GetProperties(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<string, PropertyDependency> GetPropertyDependencies(JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchema GetPropertyNames(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<bool> GetReadOnly(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<bool> GetRecursiveAnchor(JsonSchema schema);
    [ExtensionAttribute]
public static Uri GetRecursiveRef(JsonSchema schema);
    [ExtensionAttribute]
public static Uri GetRef(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyList`1<string> GetRequired(JsonSchema schema);
    [ExtensionAttribute]
public static Uri GetSchema(JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchema GetThen(JsonSchema schema);
    [ExtensionAttribute]
public static string GetTitle(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<SchemaValueType> GetJsonType(JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchema GetUnevaluatedItems(JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchema GetUnevaluatedProperties(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<bool> GetUniqueItems(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<Uri, bool> GetVocabulary(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<bool> GetWriteOnly(JsonSchema schema);
}
[ExtensionAttribute]
internal static class Json.Schema.JsonSerializerOptionsExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static object Read(JsonSerializerOptions options, Utf8JsonReader& reader, Type arbitraryType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.KeywordConstraint : object {
    private Guid _id;
    [CompilerGeneratedAttribute]
private static KeywordConstraint <Skip>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Keyword>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<KeywordEvaluation, EvaluationContext> <Evaluator>k__BackingField;
    [CompilerGeneratedAttribute]
private KeywordConstraint[] <SiblingDependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private SchemaConstraint[] <ChildDependencies>k__BackingField;
    public static KeywordConstraint Skip { get; }
    [NullableAttribute("2")]
public string Keyword { get; }
    public Action`2<KeywordEvaluation, EvaluationContext> Evaluator { get; }
    public KeywordConstraint[] SiblingDependencies { get; public set; }
    public SchemaConstraint[] ChildDependencies { get; public set; }
    public KeywordConstraint(string keyword, Action`2<KeywordEvaluation, EvaluationContext> evaluator);
    private static KeywordConstraint();
    [CompilerGeneratedAttribute]
public static KeywordConstraint get_Skip();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Keyword();
    [CompilerGeneratedAttribute]
public Action`2<KeywordEvaluation, EvaluationContext> get_Evaluator();
    [CompilerGeneratedAttribute]
public KeywordConstraint[] get_SiblingDependencies();
    [CompilerGeneratedAttribute]
public void set_SiblingDependencies(KeywordConstraint[] value);
    [CompilerGeneratedAttribute]
public SchemaConstraint[] get_ChildDependencies();
    [CompilerGeneratedAttribute]
public void set_ChildDependencies(SchemaConstraint[] value);
    public static KeywordConstraint SimpleAnnotation(string keyword, JsonNode value);
    internal KeywordEvaluation BuildEvaluation(SchemaEvaluation schemaEvaluation, JsonPointer instanceLocation, JsonPointer evaluationPath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.KeywordEvaluation : object {
    private bool _evaluated;
    private bool _skipped;
    [CompilerGeneratedAttribute]
private static KeywordEvaluation <Skip>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonNode <LocalInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private EvaluationResults <Results>k__BackingField;
    [CompilerGeneratedAttribute]
private KeywordEvaluation[] <SiblingEvaluations>k__BackingField;
    [CompilerGeneratedAttribute]
private SchemaEvaluation[] <ChildEvaluations>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private KeywordConstraint <Constraint>k__BackingField;
    internal static KeywordEvaluation Skip { get; }
    [NullableAttribute("2")]
public JsonNode LocalInstance { get; }
    public EvaluationResults Results { get; }
    public KeywordEvaluation[] SiblingEvaluations { get; internal set; }
    public SchemaEvaluation[] ChildEvaluations { get; public set; }
    internal Guid Id { get; internal set; }
    internal KeywordConstraint Constraint { get; }
    internal KeywordEvaluation(KeywordConstraint constraint, JsonNode localInstance, EvaluationResults results);
    private static KeywordEvaluation();
    [CompilerGeneratedAttribute]
internal static KeywordEvaluation get_Skip();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public JsonNode get_LocalInstance();
    [CompilerGeneratedAttribute]
public EvaluationResults get_Results();
    [CompilerGeneratedAttribute]
public KeywordEvaluation[] get_SiblingEvaluations();
    [CompilerGeneratedAttribute]
internal void set_SiblingEvaluations(KeywordEvaluation[] value);
    [CompilerGeneratedAttribute]
public SchemaEvaluation[] get_ChildEvaluations();
    [CompilerGeneratedAttribute]
public void set_ChildEvaluations(SchemaEvaluation[] value);
    [CompilerGeneratedAttribute]
internal Guid get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(Guid value);
    [CompilerGeneratedAttribute]
internal KeywordConstraint get_Constraint();
    public void MarkAsSkipped();
    internal void Evaluate(EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Json.Schema.KeywordExtensions : object {
    private static Dictionary`2<Type, string> _keywordNames;
    private static Dictionary`2<Type, int> _keywordEvaluationGroups;
    private static Dictionary`2<Type, SpecVersion> _versionDeclarations;
    private static KeywordExtensions();
    private static IEnumerable`1<Type> GetAllKeywordTypes();
    [ExtensionAttribute]
public static string Keyword(IJsonSchemaKeyword keyword);
    [ExtensionAttribute]
public static string Keyword(Type keywordType);
    [ExtensionAttribute]
public static long Priority(IJsonSchemaKeyword keyword);
    [ExtensionAttribute]
public static bool SupportsVersion(IJsonSchemaKeyword keyword, SpecVersion version);
    [ExtensionAttribute]
public static SpecVersion VersionsSupported(IJsonSchemaKeyword keyword);
    [ExtensionAttribute]
internal static bool ProducesDependentAnnotations(Type keywordType);
}
[SchemaKeywordAttribute("maxContains")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.MaxContainsKeywordJsonConverter")]
public class Json.Schema.MaxContainsKeyword : object {
    [NullableAttribute("1")]
public static string Name;
    [CompilerGeneratedAttribute]
private UInt32 <Value>k__BackingField;
    public UInt32 Value { get; }
    public MaxContainsKeyword(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Value();
    [NullableContextAttribute("1")]
public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <GetConstraint>b__5_0(KeywordEvaluation e, EvaluationContext _);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.MaxContainsKeywordJsonConverter : JsonConverter`1<MaxContainsKeyword> {
    public virtual MaxContainsKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, MaxContainsKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("maximum")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.MaximumKeywordJsonConverter")]
public class Json.Schema.MaximumKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private decimal <Value>k__BackingField;
    public decimal Value { get; }
    public MaximumKeyword(decimal value);
    [CompilerGeneratedAttribute]
public decimal get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.MaximumKeywordJsonConverter : JsonConverter`1<MaximumKeyword> {
    public virtual MaximumKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, MaximumKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("maxItems")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.MaxItemsKeywordJsonConverter")]
public class Json.Schema.MaxItemsKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private UInt32 <Value>k__BackingField;
    public UInt32 Value { get; }
    public MaxItemsKeyword(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.MaxItemsKeywordJsonConverter : JsonConverter`1<MaxItemsKeyword> {
    public virtual MaxItemsKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, MaxItemsKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("maxLength")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.MaxLengthKeywordJsonConverter")]
public class Json.Schema.MaxLengthKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private UInt32 <Value>k__BackingField;
    public UInt32 Value { get; }
    public MaxLengthKeyword(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.MaxLengthKeywordJsonConverter : JsonConverter`1<MaxLengthKeyword> {
    public virtual MaxLengthKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, MaxLengthKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("maxProperties")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.MaxPropertiesKeywordJsonConverter")]
public class Json.Schema.MaxPropertiesKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private UInt32 <Value>k__BackingField;
    public UInt32 Value { get; }
    public MaxPropertiesKeyword(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.MaxPropertiesKeywordJsonConverter : JsonConverter`1<MaxPropertiesKeyword> {
    public virtual MaxPropertiesKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, MaxPropertiesKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Json.Schema.MetaSchemas : object {
    internal static string Draft201909IdValue;
    public static Uri Draft201909Id;
    public static Uri Core201909Id;
    public static Uri Applicator201909Id;
    public static Uri Validation201909Id;
    public static Uri Metadata201909Id;
    public static Uri Format201909Id;
    public static Uri Content201909Id;
    public static JsonSchema Draft201909;
    public static JsonSchema Core201909;
    public static JsonSchema Applicator201909;
    public static JsonSchema Validation201909;
    public static JsonSchema Metadata201909;
    public static JsonSchema Format201909;
    public static JsonSchema Content201909;
    internal static string Draft202012IdValue;
    public static Uri Draft202012Id;
    public static Uri Core202012Id;
    public static Uri Unevaluated202012Id;
    public static Uri Applicator202012Id;
    public static Uri Validation202012Id;
    public static Uri Metadata202012Id;
    public static Uri FormatAnnotation202012Id;
    public static Uri FormatAssertion202012Id;
    public static Uri Content202012Id;
    public static JsonSchema Draft202012;
    public static JsonSchema Core202012;
    public static JsonSchema Unevaluated202012;
    public static JsonSchema Applicator202012;
    public static JsonSchema Validation202012;
    public static JsonSchema Metadata202012;
    public static JsonSchema FormatAnnotation202012;
    public static JsonSchema FormatAssertion202012;
    public static JsonSchema Content202012;
    internal static string Draft6IdValue;
    public static Uri Draft6Id;
    public static JsonSchema Draft6;
    internal static string Draft7IdValue;
    public static Uri Draft7Id;
    public static JsonSchema Draft7;
    internal static string DraftNextIdValue;
    public static Uri DraftNextId;
    public static Uri CoreNextId;
    public static Uri UnevaluatedNextId;
    public static Uri ApplicatorNextId;
    public static Uri ValidationNextId;
    public static Uri MetadataNextId;
    public static Uri FormatAnnotationNextId;
    public static Uri FormatAssertionNextId;
    public static Uri ContentNextId;
    public static JsonSchema DraftNext;
    public static JsonSchema CoreNext;
    public static JsonSchema UnevaluatedNext;
    public static JsonSchema ApplicatorNext;
    public static JsonSchema ValidationNext;
    public static JsonSchema MetadataNext;
    public static JsonSchema FormatAnnotationNext;
    public static JsonSchema FormatAssertionNext;
    public static JsonSchema ContentNext;
    private static MetaSchemas();
}
[SchemaKeywordAttribute("minContains")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.MinContainsKeywordJsonConverter")]
public class Json.Schema.MinContainsKeyword : object {
    [NullableAttribute("1")]
public static string Name;
    [CompilerGeneratedAttribute]
private UInt32 <Value>k__BackingField;
    public UInt32 Value { get; }
    public MinContainsKeyword(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Value();
    [NullableContextAttribute("1")]
public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <GetConstraint>b__5_0(KeywordEvaluation e, EvaluationContext _);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.MinContainsKeywordJsonConverter : JsonConverter`1<MinContainsKeyword> {
    public virtual MinContainsKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, MinContainsKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("minimum")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.MinimumKeywordJsonConverter")]
public class Json.Schema.MinimumKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private decimal <Value>k__BackingField;
    public decimal Value { get; }
    public MinimumKeyword(decimal value);
    [CompilerGeneratedAttribute]
public decimal get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.MinimumKeywordJsonConverter : JsonConverter`1<MinimumKeyword> {
    public virtual MinimumKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, MinimumKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("minItems")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.MinItemsKeywordJsonConverter")]
public class Json.Schema.MinItemsKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private UInt32 <Value>k__BackingField;
    public UInt32 Value { get; }
    public MinItemsKeyword(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.MinItemsKeywordJsonConverter : JsonConverter`1<MinItemsKeyword> {
    public virtual MinItemsKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, MinItemsKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("minLength")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.MinLengthKeywordJsonConverter")]
public class Json.Schema.MinLengthKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private UInt32 <Value>k__BackingField;
    public UInt32 Value { get; }
    public MinLengthKeyword(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.MinLengthKeywordJsonConverter : JsonConverter`1<MinLengthKeyword> {
    public virtual MinLengthKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, MinLengthKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("minProperties")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.MinPropertiesKeywordJsonConverter")]
public class Json.Schema.MinPropertiesKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private UInt32 <Value>k__BackingField;
    public UInt32 Value { get; }
    public MinPropertiesKeyword(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.MinPropertiesKeywordJsonConverter : JsonConverter`1<MinPropertiesKeyword> {
    public virtual MinPropertiesKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, MinPropertiesKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("multipleOf")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.MultipleOfKeywordJsonConverter")]
public class Json.Schema.MultipleOfKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private decimal <Value>k__BackingField;
    public decimal Value { get; }
    public MultipleOfKeyword(decimal value);
    [CompilerGeneratedAttribute]
public decimal get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.MultipleOfKeywordJsonConverter : JsonConverter`1<MultipleOfKeyword> {
    public virtual MultipleOfKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, MultipleOfKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("not")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[JsonConverterAttribute("Json.Schema.NotKeywordJsonConverter")]
public class Json.Schema.NotKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    public JsonSchema Schema { get; }
    public NotKeyword(JsonSchema value);
    [CompilerGeneratedAttribute]
public sealed virtual JsonSchema get_Schema();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.NotKeywordJsonConverter : JsonConverter`1<NotKeyword> {
    public virtual NotKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, NotKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("oneOf")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[JsonConverterAttribute("Json.Schema.OneOfKeywordJsonConverter")]
public class Json.Schema.OneOfKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<JsonSchema> <Schemas>k__BackingField;
    public IReadOnlyList`1<JsonSchema> Schemas { get; }
    public OneOfKeyword(JsonSchema[] values);
    public OneOfKeyword(IEnumerable`1<JsonSchema> values);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<JsonSchema> get_Schemas();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.OneOfKeywordJsonConverter : JsonConverter`1<OneOfKeyword> {
    public virtual OneOfKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, OneOfKeyword value, JsonSerializerOptions options);
}
public enum Json.Schema.OutputFormat : Enum {
    public int value__;
    public static OutputFormat Flag;
    public static OutputFormat List;
    public static OutputFormat Hierarchical;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("pattern")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.PatternKeywordJsonConverter")]
public class Json.Schema.PatternKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private Regex <Value>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <InvalidPattern>k__BackingField;
    public Regex Value { get; }
    [NullableAttribute("2")]
public string InvalidPattern { get; }
    public PatternKeyword(Regex value);
    private PatternKeyword(string invalidPattern);
    [CompilerGeneratedAttribute]
public Regex get_Value();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_InvalidPattern();
    internal static PatternKeyword InvalidRegex(string pattern);
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.PatternKeywordJsonConverter : JsonConverter`1<PatternKeyword> {
    public virtual PatternKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, PatternKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("patternProperties")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[JsonConverterAttribute("Json.Schema.PatternPropertiesKeywordJsonConverter")]
public class Json.Schema.PatternPropertiesKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<Regex, JsonSchema> <Patterns>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <InvalidPatterns>k__BackingField;
    public IReadOnlyDictionary`2<Regex, JsonSchema> Patterns { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<string> InvalidPatterns { get; }
    private IReadOnlyDictionary`2<string, JsonSchema> Json.Schema.IKeyedSchemaCollector.Schemas { get; }
    public PatternPropertiesKeyword(IReadOnlyDictionary`2<Regex, JsonSchema> values);
    internal PatternPropertiesKeyword(IReadOnlyDictionary`2<Regex, JsonSchema> values, IReadOnlyList`1<string> invalidPatterns);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<Regex, JsonSchema> get_Patterns();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_InvalidPatterns();
    private sealed virtual override IReadOnlyDictionary`2<string, JsonSchema> Json.Schema.IKeyedSchemaCollector.get_Schemas();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.PatternPropertiesKeywordJsonConverter : JsonConverter`1<PatternPropertiesKeyword> {
    public virtual PatternPropertiesKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, PatternPropertiesKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.Pre202012EvaluationResultsJsonConverter : JsonConverter`1<EvaluationResults> {
    public virtual EvaluationResults Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, EvaluationResults value, JsonSerializerOptions options);
    private static void WriteError(Utf8JsonWriter writer, EvaluationResults value, string keyword, string error, JsonSerializerOptions options);
    private static void WriteAnnotation(Utf8JsonWriter writer, EvaluationResults value, Annotation annotation, JsonSerializerOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Json.Schema.PredicateFormat : Format {
    private Func`2<JsonNode, bool> _predicate;
    private PredicateWithErrorMessage _predicateWithErrorMessage;
    [NullableContextAttribute("1")]
public PredicateFormat(string key, Func`2<JsonNode, bool> predicate);
    [NullableContextAttribute("1")]
public PredicateFormat(string key, PredicateWithErrorMessage predicate);
    public virtual bool Validate(JsonNode element, String& errorMessage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("prefixItems")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[JsonConverterAttribute("Json.Schema.PrefixItemsKeywordJsonConverter")]
public class Json.Schema.PrefixItemsKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<JsonSchema> <ArraySchemas>k__BackingField;
    public IReadOnlyList`1<JsonSchema> ArraySchemas { get; }
    private IReadOnlyList`1<JsonSchema> Json.Schema.ISchemaCollector.Schemas { get; }
    public PrefixItemsKeyword(JsonSchema[] values);
    public PrefixItemsKeyword(IEnumerable`1<JsonSchema> values);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<JsonSchema> get_ArraySchemas();
    private sealed virtual override IReadOnlyList`1<JsonSchema> Json.Schema.ISchemaCollector.get_Schemas();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.PrefixItemsKeywordJsonConverter : JsonConverter`1<PrefixItemsKeyword> {
    public virtual PrefixItemsKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, PrefixItemsKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("properties")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[JsonConverterAttribute("Json.Schema.PropertiesKeywordJsonConverter")]
public class Json.Schema.PropertiesKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, JsonSchema> <Properties>k__BackingField;
    public IReadOnlyDictionary`2<string, JsonSchema> Properties { get; }
    private IReadOnlyDictionary`2<string, JsonSchema> Json.Schema.IKeyedSchemaCollector.Schemas { get; }
    public PropertiesKeyword(IReadOnlyDictionary`2<string, JsonSchema> values);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, JsonSchema> get_Properties();
    private sealed virtual override IReadOnlyDictionary`2<string, JsonSchema> Json.Schema.IKeyedSchemaCollector.get_Schemas();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.PropertiesKeywordJsonConverter : JsonConverter`1<PropertiesKeyword> {
    public virtual PropertiesKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, PropertiesKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("propertyDependencies")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[JsonConverterAttribute("Json.Schema.PropertyDependenciesKeywordJsonConverter")]
public class Json.Schema.PropertyDependenciesKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, PropertyDependency> <Dependencies>k__BackingField;
    public IReadOnlyDictionary`2<string, PropertyDependency> Dependencies { get; }
    private IEnumerable`1<JsonSchema> Json.Schema.ICustomSchemaCollector.Schemas { get; }
    public PropertyDependenciesKeyword(IReadOnlyDictionary`2<string, PropertyDependency> dependencies);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, PropertyDependency> get_Dependencies();
    private sealed virtual override IEnumerable`1<JsonSchema> Json.Schema.ICustomSchemaCollector.get_Schemas();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
    private sealed virtual override ValueTuple`2<JsonSchema, int> Json.Schema.ICustomSchemaCollector.FindSubschema(IReadOnlyList`1<PointerSegment> segments);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.PropertyDependenciesKeywordJsonConverter : JsonConverter`1<PropertyDependenciesKeyword> {
    public virtual PropertyDependenciesKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, PropertyDependenciesKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[JsonConverterAttribute("Json.Schema.PropertyDependencyJsonConverter")]
public class Json.Schema.PropertyDependency : object {
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, JsonSchema> <Schemas>k__BackingField;
    public IReadOnlyDictionary`2<string, JsonSchema> Schemas { get; }
    public PropertyDependency(IReadOnlyDictionary`2<string, JsonSchema> schemas);
    public PropertyDependency(ValueTuple`2[] schemas);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyDictionary`2<string, JsonSchema> get_Schemas();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(PropertyDependency other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static PropertyDependency op_Implicit(Dictionary`2<string, JsonSchema> dependency);
    public static PropertyDependency op_Implicit(ValueTuple`2[] dependency);
    public static PropertyDependency op_Implicit(ValueTuple`2[] dependency);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.PropertyDependencyJsonConverter : JsonConverter`1<PropertyDependency> {
    public virtual PropertyDependency Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, PropertyDependency value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("propertyNames")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[JsonConverterAttribute("Json.Schema.PropertyNamesKeywordJsonConverter")]
public class Json.Schema.PropertyNamesKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    public JsonSchema Schema { get; }
    public PropertyNamesKeyword(JsonSchema value);
    [CompilerGeneratedAttribute]
public sealed virtual JsonSchema get_Schema();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.PropertyNamesKeywordJsonConverter : JsonConverter`1<PropertyNamesKeyword> {
    public virtual PropertyNamesKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, PropertyNamesKeyword value, JsonSerializerOptions options);
}
[SchemaKeywordAttribute("readOnly")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/meta-data")]
[JsonConverterAttribute("Json.Schema.ReadOnlyKeywordJsonConverter")]
public class Json.Schema.ReadOnlyKeyword : object {
    [NullableAttribute("1")]
public static string Name;
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public bool Value { get; }
    public ReadOnlyKeyword(bool value);
    [CompilerGeneratedAttribute]
public bool get_Value();
    [NullableContextAttribute("1")]
public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.ReadOnlyKeywordJsonConverter : JsonConverter`1<ReadOnlyKeyword> {
    public virtual ReadOnlyKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ReadOnlyKeyword value, JsonSerializerOptions options);
}
[SchemaKeywordAttribute("$recursiveAnchor")]
[SchemaSpecVersionAttribute("4")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/core")]
[JsonConverterAttribute("Json.Schema.RecursiveAnchorKeywordJsonConverter")]
public class Json.Schema.RecursiveAnchorKeyword : object {
    [NullableAttribute("1")]
public static string Name;
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public bool Value { get; }
    public RecursiveAnchorKeyword(bool value);
    [CompilerGeneratedAttribute]
public bool get_Value();
    [NullableContextAttribute("1")]
public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.RecursiveAnchorKeywordJsonConverter : JsonConverter`1<RecursiveAnchorKeyword> {
    public virtual RecursiveAnchorKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, RecursiveAnchorKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("$recursiveRef")]
[SchemaSpecVersionAttribute("4")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/core")]
[JsonConverterAttribute("Json.Schema.RecursiveRefKeywordJsonConverter")]
public class Json.Schema.RecursiveRefKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private Uri <Reference>k__BackingField;
    public Uri Reference { get; }
    public RecursiveRefKeyword(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_Reference();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context, JsonSchema target);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.RecursiveRefKeywordJsonConverter : JsonConverter`1<RecursiveRefKeyword> {
    public virtual RecursiveRefKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, RecursiveRefKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("$ref")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/core")]
[JsonConverterAttribute("Json.Schema.RefKeywordJsonConverter")]
public class Json.Schema.RefKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private Uri <Reference>k__BackingField;
    public Uri Reference { get; }
    public RefKeyword(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_Reference();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.RefKeywordJsonConverter : JsonConverter`1<RefKeyword> {
    public virtual RefKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, RefKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.RegexFormat : Format {
    private Regex _regex;
    public RegexFormat(string key, string regex);
    [NullableContextAttribute("2")]
public virtual bool Validate(JsonNode node, String& errorMessage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("required")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.RequiredKeywordJsonConverter")]
public class Json.Schema.RequiredKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Properties>k__BackingField;
    public IReadOnlyList`1<string> Properties { get; }
    public RequiredKeyword(String[] values);
    public RequiredKeyword(IEnumerable`1<string> values);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Properties();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.RequiredKeywordJsonConverter : JsonConverter`1<RequiredKeyword> {
    public virtual RequiredKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, RequiredKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.SchemaConstraint : object {
    private Guid _id;
    private JsonPointer _relativeEvaluationPath;
    [CompilerGeneratedAttribute]
private Uri <SchemaBaseUri>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPointer <BaseInstanceLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPointer <RelativeInstanceLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private KeywordConstraint[] <Constraints>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<KeywordEvaluation, IEnumerable`1<JsonPointer>> <InstanceLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchema <LocalSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPointer <BaseSchemaOffset>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SchemaConstraint <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseLocatorAsInstance>k__BackingField;
    public Uri SchemaBaseUri { get; }
    public JsonPointer BaseInstanceLocation { get; }
    public JsonPointer RelativeInstanceLocation { get; }
    public KeywordConstraint[] Constraints { get; internal set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<KeywordEvaluation, IEnumerable`1<JsonPointer>> InstanceLocator { get; public set; }
    public JsonSchema LocalSchema { get; }
    internal JsonPointer BaseSchemaOffset { get; internal set; }
    [NullableAttribute("2")]
internal SchemaConstraint Source { get; internal set; }
    internal bool UseLocatorAsInstance { get; internal set; }
    internal SchemaConstraint(JsonPointer relativeEvaluationPath, JsonPointer baseInstanceLocation, JsonPointer relativeInstanceLocation, Uri schemaBaseUri, JsonSchema localSchema);
    [CompilerGeneratedAttribute]
public Uri get_SchemaBaseUri();
    [CompilerGeneratedAttribute]
public JsonPointer get_BaseInstanceLocation();
    [CompilerGeneratedAttribute]
public JsonPointer get_RelativeInstanceLocation();
    [CompilerGeneratedAttribute]
public KeywordConstraint[] get_Constraints();
    [CompilerGeneratedAttribute]
internal void set_Constraints(KeywordConstraint[] value);
    [CompilerGeneratedAttribute]
public Func`2<KeywordEvaluation, IEnumerable`1<JsonPointer>> get_InstanceLocator();
    [CompilerGeneratedAttribute]
public void set_InstanceLocator(Func`2<KeywordEvaluation, IEnumerable`1<JsonPointer>> value);
    [CompilerGeneratedAttribute]
public JsonSchema get_LocalSchema();
    [CompilerGeneratedAttribute]
internal JsonPointer get_BaseSchemaOffset();
    [CompilerGeneratedAttribute]
internal void set_BaseSchemaOffset(JsonPointer value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal SchemaConstraint get_Source();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_Source(SchemaConstraint value);
    [CompilerGeneratedAttribute]
internal bool get_UseLocatorAsInstance();
    [CompilerGeneratedAttribute]
internal void set_UseLocatorAsInstance(bool value);
    public SchemaEvaluation BuildEvaluation(JsonNode localInstance, JsonPointer instanceLocation, JsonPointer evaluationPath, EvaluationOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.SchemaEvaluation : object {
    private bool _hasBeenEvaluated;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonNode <LocalInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPointer <RelativeInstanceLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private EvaluationResults <Results>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private KeywordEvaluation[] <KeywordEvaluations>k__BackingField;
    [CompilerGeneratedAttribute]
private EvaluationOptions <Options>k__BackingField;
    [NullableAttribute("2")]
public JsonNode LocalInstance { get; }
    public JsonPointer RelativeInstanceLocation { get; internal set; }
    public EvaluationResults Results { get; }
    internal Guid Id { get; internal set; }
    internal KeywordEvaluation[] KeywordEvaluations { get; }
    internal EvaluationOptions Options { get; }
    internal SchemaEvaluation(JsonNode localInstance, JsonPointer relativeInstanceLocation, EvaluationResults results, KeywordEvaluation[] evaluations, EvaluationOptions options);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public JsonNode get_LocalInstance();
    [CompilerGeneratedAttribute]
public JsonPointer get_RelativeInstanceLocation();
    [CompilerGeneratedAttribute]
internal void set_RelativeInstanceLocation(JsonPointer value);
    [CompilerGeneratedAttribute]
public EvaluationResults get_Results();
    [CompilerGeneratedAttribute]
internal Guid get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(Guid value);
    [CompilerGeneratedAttribute]
internal KeywordEvaluation[] get_KeywordEvaluations();
    [CompilerGeneratedAttribute]
internal EvaluationOptions get_Options();
    public void Evaluate(EvaluationContext context);
    [NullableContextAttribute("2")]
internal KeywordEvaluation FindEvaluation(Guid id);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.SchemaJsonConverter : JsonConverter`1<JsonSchema> {
    public virtual JsonSchema Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, JsonSchema value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("$schema")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/core")]
[JsonConverterAttribute("Json.Schema.SchemaKeywordJsonConverter")]
public class Json.Schema.SchemaKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private Uri <Schema>k__BackingField;
    public Uri Schema { get; }
    public SchemaKeyword(Uri schema);
    [CompilerGeneratedAttribute]
public Uri get_Schema();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("12")]
public class Json.Schema.SchemaKeywordAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public SchemaKeywordAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.SchemaKeywordJsonConverter : JsonConverter`1<SchemaKeyword> {
    public virtual SchemaKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, SchemaKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Json.Schema.SchemaKeywordRegistry : object {
    private static ConcurrentDictionary`2<string, Type> _keywords;
    private static ConcurrentDictionary`2<Type, IJsonSchemaKeyword> _nullKeywords;
    internal static IEnumerable`1<Type> KeywordTypes { get; }
    private static SchemaKeywordRegistry();
    internal static IEnumerable`1<Type> get_KeywordTypes();
    [NullableContextAttribute("0")]
public static void Register();
    [NullableContextAttribute("0")]
public static void Unregister();
    public static Type GetImplementationType(string keyword);
    public static void RegisterNullValue(T nullKeyword);
    internal static IJsonSchemaKeyword GetNullValuedKeyword(Type keywordType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[JsonConverterAttribute("Json.Schema.SchemaOrPropertyListJsonConverter")]
public class Json.Schema.SchemaOrPropertyList : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<string> <Requirements>k__BackingField;
    [NullableAttribute("2")]
public JsonSchema Schema { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<string> Requirements { get; }
    public SchemaOrPropertyList(JsonSchema schema);
    public SchemaOrPropertyList(IEnumerable`1<string> requirements);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public JsonSchema get_Schema();
    [CompilerGeneratedAttribute]
public List`1<string> get_Requirements();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(SchemaOrPropertyList other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static SchemaOrPropertyList op_Implicit(JsonSchema schema);
    public static SchemaOrPropertyList op_Implicit(List`1<string> requirements);
    public static SchemaOrPropertyList op_Implicit(String[] requirements);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.SchemaOrPropertyListJsonConverter : JsonConverter`1<SchemaOrPropertyList> {
    public virtual SchemaOrPropertyList Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, SchemaOrPropertyList value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.SchemaRegistry : object {
    private static Uri _empty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<Uri, Registration> _registered;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<Uri, IBaseDocument> _fetch;
    public static SchemaRegistry Global { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<Uri, IBaseDocument> Fetch { get; public set; }
    private static SchemaRegistry();
    public static SchemaRegistry get_Global();
    public Func`2<Uri, IBaseDocument> get_Fetch();
    public void set_Fetch(Func`2<Uri, IBaseDocument> value);
    internal void InitializeMetaSchemas();
    public void Register(IBaseDocument document);
    public void Register(Uri uri, IBaseDocument document);
    internal void RegisterSchema(Uri uri, IBaseDocument document);
    [NullableContextAttribute("2")]
public IBaseDocument Get(Uri uri);
    [NullableContextAttribute("2")]
private Registration GetRegistration(Uri uri);
    private static Registration CheckRegistry(Dictionary`2<Uri, Registration> lookup, Uri uri);
    [NullableContextAttribute("2")]
internal static string GetFullReference(Uri uri, string fragment);
    private static Uri MakeAbsolute(Uri uri);
    internal void CopyFrom(SchemaRegistry other);
}
[AttributeUsageAttribute("12")]
public class Json.Schema.SchemaSpecVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private SpecVersion <Version>k__BackingField;
    public SpecVersion Version { get; }
    public SchemaSpecVersionAttribute(SpecVersion version);
    [CompilerGeneratedAttribute]
public SpecVersion get_Version();
}
[FlagsAttribute]
[JsonConverterAttribute("Json.More.EnumStringConverter`1<Json.Schema.SchemaValueType>")]
public enum Json.Schema.SchemaValueType : Enum {
    public int value__;
    [DescriptionAttribute("object")]
public static SchemaValueType Object;
    [DescriptionAttribute("array")]
public static SchemaValueType Array;
    [DescriptionAttribute("boolean")]
public static SchemaValueType Boolean;
    [DescriptionAttribute("string")]
public static SchemaValueType String;
    [DescriptionAttribute("number")]
public static SchemaValueType Number;
    [DescriptionAttribute("integer")]
public static SchemaValueType Integer;
    [DescriptionAttribute("null")]
public static SchemaValueType Null;
}
internal interface Json.Schema.Serialization.IValidatingJsonConverter {
    public OutputFormat OutputFormat { get; public set; }
    public bool RequireFormatValidation { get; public set; }
    public abstract virtual OutputFormat get_OutputFormat();
    public abstract virtual void set_OutputFormat(OutputFormat value);
    public abstract virtual bool get_RequireFormatValidation();
    public abstract virtual void set_RequireFormatValidation(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1036")]
public class Json.Schema.Serialization.JsonSchemaAttribute : Attribute {
    [CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    internal JsonSchema Schema { get; }
    public JsonSchemaAttribute(Type declaringType, string memberName);
    [CompilerGeneratedAttribute]
internal JsonSchema get_Schema();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.Serialization.ValidatingJsonConverter : JsonConverterFactory {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<Type, JsonConverter> _cache;
    [CompilerGeneratedAttribute]
private Nullable`1<OutputFormat> <OutputFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <RequireFormatValidation>k__BackingField;
    public Nullable`1<OutputFormat> OutputFormat { get; public set; }
    public Nullable`1<bool> RequireFormatValidation { get; public set; }
    private static ValidatingJsonConverter();
    [CompilerGeneratedAttribute]
public Nullable`1<OutputFormat> get_OutputFormat();
    [CompilerGeneratedAttribute]
public void set_OutputFormat(Nullable`1<OutputFormat> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_RequireFormatValidation();
    [CompilerGeneratedAttribute]
public void set_RequireFormatValidation(Nullable`1<bool> value);
    public virtual bool CanConvert(Type typeToConvert);
    public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
    [CompilerGeneratedAttribute]
private JsonSerializerOptions <CreateConverter>b__10_0(JsonSerializerOptions o);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.Serialization.ValidatingJsonConverter`1 : JsonConverter`1<T> {
    private JsonSchema _schema;
    private Func`2<JsonSerializerOptions, JsonSerializerOptions> _optionsFactory;
    [CompilerGeneratedAttribute]
private OutputFormat <OutputFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireFormatValidation>k__BackingField;
    public OutputFormat OutputFormat { get; public set; }
    public bool RequireFormatValidation { get; public set; }
    public ValidatingJsonConverter`1(JsonSchema schema, Func`2<JsonSerializerOptions, JsonSerializerOptions> optionsFactory);
    [CompilerGeneratedAttribute]
public sealed virtual OutputFormat get_OutputFormat();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OutputFormat(OutputFormat value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequireFormatValidation();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RequireFormatValidation(bool value);
    public virtual T Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
}
[FlagsAttribute]
public enum Json.Schema.SpecVersion : Enum {
    public int value__;
    public static SpecVersion Unspecified;
    public static SpecVersion Draft6;
    public static SpecVersion Draft7;
    public static SpecVersion Draft201909;
    public static SpecVersion Draft202012;
    public static SpecVersion DraftNext;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("then")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[DependsOnAnnotationsFromAttribute("Json.Schema.IfKeyword")]
[JsonConverterAttribute("Json.Schema.ThenKeywordJsonConverter")]
public class Json.Schema.ThenKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    public JsonSchema Schema { get; }
    public ThenKeyword(JsonSchema value);
    [CompilerGeneratedAttribute]
public sealed virtual JsonSchema get_Schema();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.ThenKeywordJsonConverter : JsonConverter`1<ThenKeyword> {
    public virtual ThenKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ThenKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("title")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/meta-data")]
[JsonConverterAttribute("Json.Schema.TitleKeywordJsonConverter")]
public class Json.Schema.TitleKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public TitleKeyword(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.TitleKeywordJsonConverter : JsonConverter`1<TitleKeyword> {
    public virtual TitleKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, TitleKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("type")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.TypeKeywordJsonConverter")]
public class Json.Schema.TypeKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private SchemaValueType <Type>k__BackingField;
    public SchemaValueType Type { get; }
    public TypeKeyword(SchemaValueType type);
    public TypeKeyword(SchemaValueType[] types);
    public TypeKeyword(IEnumerable`1<SchemaValueType> types);
    [CompilerGeneratedAttribute]
public SchemaValueType get_Type();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context, SchemaValueType expectedType);
    [CompilerGeneratedAttribute]
private void <GetConstraint>b__7_0(KeywordEvaluation e, EvaluationContext c);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.TypeKeywordJsonConverter : JsonConverter`1<TypeKeyword> {
    public virtual TypeKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, TypeKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("unevaluatedItems")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[DependsOnAnnotationsFromAttribute("Json.Schema.PrefixItemsKeyword")]
[DependsOnAnnotationsFromAttribute("Json.Schema.ItemsKeyword")]
[DependsOnAnnotationsFromAttribute("Json.Schema.AdditionalItemsKeyword")]
[DependsOnAnnotationsFromAttribute("Json.Schema.ContainsKeyword")]
[DependsOnAnnotationsFromAttribute("Json.Schema.UnevaluatedItemsKeyword")]
[JsonConverterAttribute("Json.Schema.UnevaluatedItemsKeywordJsonConverter")]
public class Json.Schema.UnevaluatedItemsKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    public JsonSchema Schema { get; }
    public UnevaluatedItemsKeyword(JsonSchema value);
    [CompilerGeneratedAttribute]
public sealed virtual JsonSchema get_Schema();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
    [CompilerGeneratedAttribute]
internal static bool <Evaluator>g__CheckAnnotation|6_0(EvaluationResults results);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.UnevaluatedItemsKeywordJsonConverter : JsonConverter`1<UnevaluatedItemsKeyword> {
    public virtual UnevaluatedItemsKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, UnevaluatedItemsKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("unevaluatedProperties")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[DependsOnAnnotationsFromAttribute("Json.Schema.PropertiesKeyword")]
[DependsOnAnnotationsFromAttribute("Json.Schema.PatternPropertiesKeyword")]
[DependsOnAnnotationsFromAttribute("Json.Schema.AdditionalPropertiesKeyword")]
[DependsOnAnnotationsFromAttribute("Json.Schema.ContainsKeyword")]
[DependsOnAnnotationsFromAttribute("Json.Schema.UnevaluatedPropertiesKeyword")]
[JsonConverterAttribute("Json.Schema.UnevaluatedPropertiesKeywordJsonConverter")]
public class Json.Schema.UnevaluatedPropertiesKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    public JsonSchema Schema { get; }
    public UnevaluatedPropertiesKeyword(JsonSchema value);
    [CompilerGeneratedAttribute]
public sealed virtual JsonSchema get_Schema();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<string> <Evaluator>g__GetAnnotation|6_0(EvaluationResults results);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.UnevaluatedPropertiesKeywordJsonConverter : JsonConverter`1<UnevaluatedPropertiesKeyword> {
    public virtual UnevaluatedPropertiesKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, UnevaluatedPropertiesKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("uniqueItems")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.UniqueItemsKeywordJsonConverter")]
public class Json.Schema.UniqueItemsKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public bool Value { get; }
    public UniqueItemsKeyword(bool value);
    [CompilerGeneratedAttribute]
public bool get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.UniqueItemsKeywordJsonConverter : JsonConverter`1<UniqueItemsKeyword> {
    public virtual UniqueItemsKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, UniqueItemsKeyword value, JsonSerializerOptions options);
}
public class Json.Schema.UnknownFormat : Format {
    [NullableContextAttribute("1")]
public UnknownFormat(string key);
    [NullableContextAttribute("2")]
public virtual bool Validate(JsonNode node, String& errorMessage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/core")]
[SchemaSpecVersionAttribute("8")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/core")]
[SchemaSpecVersionAttribute("16")]
[JsonConverterAttribute("Json.Schema.UnrecognizedKeywordJsonConverter")]
public class Json.Schema.UnrecognizedKeyword : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonNode <Value>k__BackingField;
    public string Name { get; }
    [NullableAttribute("2")]
public JsonNode Value { get; }
    public UnrecognizedKeyword(string name, JsonNode value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public JsonNode get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.UnrecognizedKeywordJsonConverter : JsonConverter`1<UnrecognizedKeyword> {
    public virtual UnrecognizedKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, UnrecognizedKeyword value, JsonSerializerOptions options);
}
[ExtensionAttribute]
public static class Json.Schema.UriExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Uri GetParentUri(Uri uri);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Json.Schema.Vocabularies : object {
    public static string Core201909Id;
    public static string Applicator201909Id;
    public static string Validation201909Id;
    public static string Metadata201909Id;
    public static string Format201909Id;
    public static string Content201909Id;
    public static Vocabulary Core201909;
    public static Vocabulary Applicator201909;
    public static Vocabulary Validation201909;
    public static Vocabulary Metadata201909;
    public static Vocabulary Format201909;
    public static Vocabulary Content201909;
    public static string Core202012Id;
    public static string Unevaluated202012Id;
    public static string Applicator202012Id;
    public static string Validation202012Id;
    public static string Metadata202012Id;
    public static string FormatAnnotation202012Id;
    public static string FormatAssertion202012Id;
    public static string Content202012Id;
    public static Vocabulary Core202012;
    public static Vocabulary Unevaluated202012;
    public static Vocabulary Applicator202012;
    public static Vocabulary Validation202012;
    public static Vocabulary Metadata202012;
    public static Vocabulary FormatAnnotation202012;
    public static Vocabulary FormatAssertion202012;
    public static Vocabulary Content202012;
    public static string CoreNextId;
    public static string UnevaluatedNextId;
    public static string ApplicatorNextId;
    public static string ValidationNextId;
    public static string MetadataNextId;
    public static string FormatAnnotationNextId;
    public static string FormatAssertionNextId;
    public static string ContentNextId;
    public static Vocabulary CoreNext;
    public static Vocabulary UnevaluatedNext;
    public static Vocabulary ApplicatorNext;
    public static Vocabulary ValidationNext;
    public static Vocabulary MetadataNext;
    public static Vocabulary FormatAnnotationNext;
    public static Vocabulary FormatAssertionNext;
    public static Vocabulary ContentNext;
    private static Vocabularies();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.Vocabulary : object {
    [CompilerGeneratedAttribute]
private Uri <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<Type> <Keywords>k__BackingField;
    public Uri Id { get; }
    public IReadOnlyCollection`1<Type> Keywords { get; }
    public Vocabulary(string id, Type[] keywords);
    public Vocabulary(string id, IEnumerable`1<Type> keywords);
    [CompilerGeneratedAttribute]
public Uri get_Id();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<Type> get_Keywords();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("12")]
public class Json.Schema.VocabularyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Uri <Id>k__BackingField;
    public Uri Id { get; }
    public VocabularyAttribute(string id);
    [CompilerGeneratedAttribute]
public Uri get_Id();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("$vocabulary")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/core")]
[JsonConverterAttribute("Json.Schema.VocabularyKeywordJsonConverter")]
public class Json.Schema.VocabularyKeyword : object {
    public static string Name;
    private Dictionary`2<Uri, bool> _allVocabularies;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<Uri, bool> <Vocabulary>k__BackingField;
    public IReadOnlyDictionary`2<Uri, bool> Vocabulary { get; }
    public VocabularyKeyword(IReadOnlyDictionary`2<Uri, bool> values);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<Uri, bool> get_Vocabulary();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.VocabularyKeywordJsonConverter : JsonConverter`1<VocabularyKeyword> {
    public virtual VocabularyKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, VocabularyKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.VocabularyRegistry : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<Uri, Vocabulary> _vocabularies;
    [CompilerGeneratedAttribute]
private static VocabularyRegistry <Global>k__BackingField;
    public static VocabularyRegistry Global { get; }
    private static VocabularyRegistry();
    [CompilerGeneratedAttribute]
public static VocabularyRegistry get_Global();
    public void Register(Vocabulary vocabulary);
    public bool IsKnown(Uri vocabularyId);
    public Vocabulary Get(Uri vocabularyId);
    internal void CopyFrom(VocabularyRegistry other);
}
[SchemaKeywordAttribute("writeOnly")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/meta-data")]
[JsonConverterAttribute("Json.Schema.WriteOnlyKeywordJsonConverter")]
public class Json.Schema.WriteOnlyKeyword : object {
    [NullableAttribute("1")]
public static string Name;
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public bool Value { get; }
    public WriteOnlyKeyword(bool value);
    [CompilerGeneratedAttribute]
public bool get_Value();
    [NullableContextAttribute("1")]
public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, IReadOnlyList`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.WriteOnlyKeywordJsonConverter : JsonConverter`1<WriteOnlyKeyword> {
    public virtual WriteOnlyKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, WriteOnlyKeyword value, JsonSerializerOptions options);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
