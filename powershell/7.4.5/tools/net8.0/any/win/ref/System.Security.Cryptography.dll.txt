public abstract class Microsoft.Win32.SafeHandles.SafeNCryptHandle : SafeHandleZeroOrMinusOneIsInvalid {
    [NullableContextAttribute("1")]
[SupportedOSPlatformAttribute("windows")]
protected SafeNCryptHandle(IntPtr handle, SafeHandle parentHandle);
    protected virtual bool ReleaseHandle();
    protected abstract virtual bool ReleaseNativeHandle();
}
public class Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle : SafeNCryptHandle {
    [NullableContextAttribute("1")]
[SupportedOSPlatformAttribute("windows")]
public SafeNCryptKeyHandle(IntPtr handle, SafeHandle parentHandle);
    protected virtual bool ReleaseNativeHandle();
}
public class Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle : SafeNCryptHandle {
    protected virtual bool ReleaseNativeHandle();
}
public class Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle : SafeNCryptHandle {
    protected virtual bool ReleaseNativeHandle();
}
public class Microsoft.Win32.SafeHandles.SafeX509ChainHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual void Dispose(bool disposing);
    protected virtual bool ReleaseHandle();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.Aes : SymmetricAlgorithm {
    [UnsupportedOSPlatformAttribute("browser")]
public static Aes Create();
    [RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
public static Aes Create(string algorithmName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public class System.Security.Cryptography.AesCcm : object {
    public static bool IsSupported { get; }
    public static KeySizes NonceByteSizes { get; }
    public static KeySizes TagByteSizes { get; }
    public AesCcm(Byte[] key);
    [NullableContextAttribute("0")]
public AesCcm(ReadOnlySpan`1<byte> key);
    public static bool get_IsSupported();
    public static KeySizes get_NonceByteSizes();
    public static KeySizes get_TagByteSizes();
    public void Decrypt(Byte[] nonce, Byte[] ciphertext, Byte[] tag, Byte[] plaintext, Byte[] associatedData);
    [NullableContextAttribute("0")]
public void Decrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, ReadOnlySpan`1<byte> associatedData);
    public sealed virtual void Dispose();
    public void Encrypt(Byte[] nonce, Byte[] plaintext, Byte[] ciphertext, Byte[] tag, Byte[] associatedData);
    [NullableContextAttribute("0")]
public void Encrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag, ReadOnlySpan`1<byte> associatedData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.AesCng : Aes {
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    [SupportedOSPlatformAttribute("windows")]
public AesCng(string keyName);
    [SupportedOSPlatformAttribute("windows")]
public AesCng(string keyName, CngProvider provider);
    [SupportedOSPlatformAttribute("windows")]
public AesCng(string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    protected virtual void Dispose(bool disposing);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
    [NullableContextAttribute("0")]
protected virtual bool TryDecryptCbcCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryDecryptCfbCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryDecryptEcbCore(ReadOnlySpan`1<byte> ciphertext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryEncryptCbcCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryEncryptCfbCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryEncryptEcbCore(ReadOnlySpan`1<byte> plaintext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
public class System.Security.Cryptography.AesCryptoServiceProvider : Aes {
    public int BlockSize { get; public set; }
    public int FeedbackSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public KeySizes[] LegalBlockSizes { get; }
    public KeySizes[] LegalKeySizes { get; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual KeySizes[] get_LegalBlockSizes();
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    protected virtual void Dispose(bool disposing);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public class System.Security.Cryptography.AesGcm : object {
    public static bool IsSupported { get; }
    public static KeySizes NonceByteSizes { get; }
    public static KeySizes TagByteSizes { get; }
    public Nullable`1<int> TagSizeInBytes { get; }
    [ObsoleteAttribute("AesGcm should indicate the required tag size for encryption and decryption. Use a constructor that accepts the tag size.")]
public AesGcm(Byte[] key);
    public AesGcm(Byte[] key, int tagSizeInBytes);
    [NullableContextAttribute("0")]
[ObsoleteAttribute("AesGcm should indicate the required tag size for encryption and decryption. Use a constructor that accepts the tag size.")]
public AesGcm(ReadOnlySpan`1<byte> key);
    [NullableContextAttribute("0")]
public AesGcm(ReadOnlySpan`1<byte> key, int tagSizeInBytes);
    public static bool get_IsSupported();
    public static KeySizes get_NonceByteSizes();
    public static KeySizes get_TagByteSizes();
    public Nullable`1<int> get_TagSizeInBytes();
    public void Decrypt(Byte[] nonce, Byte[] ciphertext, Byte[] tag, Byte[] plaintext, Byte[] associatedData);
    [NullableContextAttribute("0")]
public void Decrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, ReadOnlySpan`1<byte> associatedData);
    public sealed virtual void Dispose();
    public void Encrypt(Byte[] nonce, Byte[] plaintext, Byte[] ciphertext, Byte[] tag, Byte[] associatedData);
    [NullableContextAttribute("0")]
public void Encrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag, ReadOnlySpan`1<byte> associatedData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[UnsupportedOSPlatformAttribute("browser")]
public class System.Security.Cryptography.AesManaged : Aes {
    public int BlockSize { get; public set; }
    public int FeedbackSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public KeySizes[] LegalBlockSizes { get; }
    public KeySizes[] LegalKeySizes { get; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual KeySizes[] get_LegalBlockSizes();
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    protected virtual void Dispose(bool disposing);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.AsnEncodedData : object {
    [NullableAttribute("2")]
public Oid Oid { get; public set; }
    public Byte[] RawData { get; public set; }
    public AsnEncodedData(Byte[] rawData);
    [NullableContextAttribute("0")]
public AsnEncodedData(ReadOnlySpan`1<byte> rawData);
    public AsnEncodedData(AsnEncodedData asnEncodedData);
    public AsnEncodedData(Oid oid, Byte[] rawData);
    [NullableContextAttribute("0")]
public AsnEncodedData(Oid oid, ReadOnlySpan`1<byte> rawData);
    public AsnEncodedData(string oid, Byte[] rawData);
    [NullableContextAttribute("0")]
public AsnEncodedData(string oid, ReadOnlySpan`1<byte> rawData);
    [NullableContextAttribute("2")]
public Oid get_Oid();
    [NullableContextAttribute("2")]
public void set_Oid(Oid value);
    public Byte[] get_RawData();
    public void set_RawData(Byte[] value);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    public virtual string Format(bool multiLine);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.AsnEncodedDataCollection : object {
    public int Count { get; }
    public bool IsSynchronized { get; }
    public AsnEncodedData Item { get; }
    public object SyncRoot { get; }
    public AsnEncodedDataCollection(AsnEncodedData asnEncodedData);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public AsnEncodedData get_Item(int index);
    public sealed virtual object get_SyncRoot();
    public int Add(AsnEncodedData asnEncodedData);
    public void CopyTo(AsnEncodedData[] array, int index);
    public AsnEncodedDataEnumerator GetEnumerator();
    public void Remove(AsnEncodedData asnEncodedData);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.AsnEncodedDataEnumerator : object {
    public AsnEncodedData Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public AsnEncodedData get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public abstract class System.Security.Cryptography.AsymmetricAlgorithm : object {
    protected int KeySizeValue;
    [NullableAttribute("1")]
[MaybeNullAttribute]
protected KeySizes[] LegalKeySizesValue;
    [NullableAttribute("2")]
public string KeyExchangeAlgorithm { get; }
    public int KeySize { get; public set; }
    [NullableAttribute("1")]
public KeySizes[] LegalKeySizes { get; }
    [NullableAttribute("2")]
public string SignatureAlgorithm { get; }
    [NullableContextAttribute("2")]
public virtual string get_KeyExchangeAlgorithm();
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    [NullableContextAttribute("1")]
public virtual KeySizes[] get_LegalKeySizes();
    [NullableContextAttribute("2")]
public virtual string get_SignatureAlgorithm();
    public void Clear();
    [NullableContextAttribute("1")]
[ObsoleteAttribute("The default implementation of this cryptography algorithm is not supported.")]
public static AsymmetricAlgorithm Create();
    [NullableContextAttribute("1")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
public static AsymmetricAlgorithm Create(string algName);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("1")]
public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    [NullableContextAttribute("1")]
public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    [NullableContextAttribute("1")]
public string ExportEncryptedPkcs8PrivateKeyPem(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    [NullableContextAttribute("1")]
public string ExportEncryptedPkcs8PrivateKeyPem(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    [NullableContextAttribute("1")]
public virtual Byte[] ExportPkcs8PrivateKey();
    [NullableContextAttribute("1")]
public string ExportPkcs8PrivateKeyPem();
    [NullableContextAttribute("1")]
public virtual Byte[] ExportSubjectPublicKeyInfo();
    [NullableContextAttribute("1")]
public string ExportSubjectPublicKeyInfoPem();
    [NullableContextAttribute("1")]
public virtual void FromXmlString(string xmlString);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<byte> passwordBytes);
    public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> password);
    public virtual void ImportFromPem(ReadOnlySpan`1<char> input);
    public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("1")]
public virtual string ToXmlString(bool includePrivateParameters);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public bool TryExportEncryptedPkcs8PrivateKeyPem(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<char> destination, Int32& charsWritten);
    public bool TryExportEncryptedPkcs8PrivateKeyPem(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<char> destination, Int32& charsWritten);
    public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public bool TryExportPkcs8PrivateKeyPem(Span`1<char> destination, Int32& charsWritten);
    public virtual bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
    public bool TryExportSubjectPublicKeyInfoPem(Span`1<char> destination, Int32& charsWritten);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.AsymmetricKeyExchangeDeformatter : object {
    public string Parameters { get; public set; }
    public abstract virtual string get_Parameters();
    public abstract virtual void set_Parameters(string value);
    [NullableContextAttribute("1")]
public abstract virtual Byte[] DecryptKeyExchange(Byte[] rgb);
    [NullableContextAttribute("1")]
public abstract virtual void SetKey(AsymmetricAlgorithm key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.AsymmetricKeyExchangeFormatter : object {
    [NullableAttribute("2")]
public string Parameters { get; }
    [NullableContextAttribute("2")]
public abstract virtual string get_Parameters();
    public abstract virtual Byte[] CreateKeyExchange(Byte[] data);
    public abstract virtual Byte[] CreateKeyExchange(Byte[] data, Type symAlgType);
    public abstract virtual void SetKey(AsymmetricAlgorithm key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.AsymmetricSignatureDeformatter : object {
    public abstract virtual void SetHashAlgorithm(string strName);
    public abstract virtual void SetKey(AsymmetricAlgorithm key);
    public abstract virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
    public virtual bool VerifySignature(HashAlgorithm hash, Byte[] rgbSignature);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.AsymmetricSignatureFormatter : object {
    public abstract virtual Byte[] CreateSignature(Byte[] rgbHash);
    public virtual Byte[] CreateSignature(HashAlgorithm hash);
    public abstract virtual void SetHashAlgorithm(string strName);
    public abstract virtual void SetKey(AsymmetricAlgorithm key);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.AuthenticationTagMismatchException : CryptographicException {
    public AuthenticationTagMismatchException(string message);
    public AuthenticationTagMismatchException(string message, Exception inner);
}
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public class System.Security.Cryptography.ChaCha20Poly1305 : object {
    public static bool IsSupported { get; }
    [NullableContextAttribute("1")]
public ChaCha20Poly1305(Byte[] key);
    public ChaCha20Poly1305(ReadOnlySpan`1<byte> key);
    public static bool get_IsSupported();
    [NullableContextAttribute("1")]
public void Decrypt(Byte[] nonce, Byte[] ciphertext, Byte[] tag, Byte[] plaintext, Byte[] associatedData);
    public void Decrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, ReadOnlySpan`1<byte> associatedData);
    public sealed virtual void Dispose();
    [NullableContextAttribute("1")]
public void Encrypt(Byte[] nonce, Byte[] plaintext, Byte[] ciphertext, Byte[] tag, Byte[] associatedData);
    public void Encrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag, ReadOnlySpan`1<byte> associatedData);
}
public enum System.Security.Cryptography.CipherMode : Enum {
    public int value__;
    public static CipherMode CBC;
    public static CipherMode ECB;
    [EditorBrowsableAttribute("1")]
public static CipherMode OFB;
    public static CipherMode CFB;
    public static CipherMode CTS;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngAlgorithm : object {
    public string Algorithm { get; }
    public static CngAlgorithm ECDiffieHellman { get; }
    public static CngAlgorithm ECDiffieHellmanP256 { get; }
    public static CngAlgorithm ECDiffieHellmanP384 { get; }
    public static CngAlgorithm ECDiffieHellmanP521 { get; }
    public static CngAlgorithm ECDsa { get; }
    public static CngAlgorithm ECDsaP256 { get; }
    public static CngAlgorithm ECDsaP384 { get; }
    public static CngAlgorithm ECDsaP521 { get; }
    public static CngAlgorithm MD5 { get; }
    public static CngAlgorithm Rsa { get; }
    public static CngAlgorithm Sha1 { get; }
    public static CngAlgorithm Sha256 { get; }
    public static CngAlgorithm Sha384 { get; }
    public static CngAlgorithm Sha512 { get; }
    public CngAlgorithm(string algorithm);
    public string get_Algorithm();
    public static CngAlgorithm get_ECDiffieHellman();
    public static CngAlgorithm get_ECDiffieHellmanP256();
    public static CngAlgorithm get_ECDiffieHellmanP384();
    public static CngAlgorithm get_ECDiffieHellmanP521();
    public static CngAlgorithm get_ECDsa();
    public static CngAlgorithm get_ECDsaP256();
    public static CngAlgorithm get_ECDsaP384();
    public static CngAlgorithm get_ECDsaP521();
    public static CngAlgorithm get_MD5();
    public static CngAlgorithm get_Rsa();
    public static CngAlgorithm get_Sha1();
    public static CngAlgorithm get_Sha256();
    public static CngAlgorithm get_Sha384();
    public static CngAlgorithm get_Sha512();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(CngAlgorithm other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(CngAlgorithm left, CngAlgorithm right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(CngAlgorithm left, CngAlgorithm right);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngAlgorithmGroup : object {
    public string AlgorithmGroup { get; }
    public static CngAlgorithmGroup DiffieHellman { get; }
    public static CngAlgorithmGroup Dsa { get; }
    public static CngAlgorithmGroup ECDiffieHellman { get; }
    public static CngAlgorithmGroup ECDsa { get; }
    public static CngAlgorithmGroup Rsa { get; }
    public CngAlgorithmGroup(string algorithmGroup);
    public string get_AlgorithmGroup();
    public static CngAlgorithmGroup get_DiffieHellman();
    public static CngAlgorithmGroup get_Dsa();
    public static CngAlgorithmGroup get_ECDiffieHellman();
    public static CngAlgorithmGroup get_ECDsa();
    public static CngAlgorithmGroup get_Rsa();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(CngAlgorithmGroup other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(CngAlgorithmGroup left, CngAlgorithmGroup right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(CngAlgorithmGroup left, CngAlgorithmGroup right);
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngExportPolicies : Enum {
    public int value__;
    public static CngExportPolicies None;
    public static CngExportPolicies AllowExport;
    public static CngExportPolicies AllowPlaintextExport;
    public static CngExportPolicies AllowArchiving;
    public static CngExportPolicies AllowPlaintextArchiving;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngKey : object {
    public CngAlgorithm Algorithm { get; }
    [NullableAttribute("2")]
public CngAlgorithmGroup AlgorithmGroup { get; }
    public CngExportPolicies ExportPolicy { get; }
    public SafeNCryptKeyHandle Handle { get; }
    public bool IsEphemeral { get; }
    public bool IsMachineKey { get; }
    [NullableAttribute("2")]
public string KeyName { get; }
    public int KeySize { get; }
    public CngKeyUsages KeyUsage { get; }
    public IntPtr ParentWindowHandle { get; public set; }
    [NullableAttribute("2")]
public CngProvider Provider { get; }
    public SafeNCryptProviderHandle ProviderHandle { get; }
    public CngUIPolicy UIPolicy { get; }
    [NullableAttribute("2")]
public string UniqueName { get; }
    public CngAlgorithm get_Algorithm();
    [NullableContextAttribute("2")]
public CngAlgorithmGroup get_AlgorithmGroup();
    public CngExportPolicies get_ExportPolicy();
    public SafeNCryptKeyHandle get_Handle();
    public bool get_IsEphemeral();
    public bool get_IsMachineKey();
    [NullableContextAttribute("2")]
public string get_KeyName();
    public int get_KeySize();
    public CngKeyUsages get_KeyUsage();
    public IntPtr get_ParentWindowHandle();
    public void set_ParentWindowHandle(IntPtr value);
    [NullableContextAttribute("2")]
public CngProvider get_Provider();
    public SafeNCryptProviderHandle get_ProviderHandle();
    public CngUIPolicy get_UIPolicy();
    [NullableContextAttribute("2")]
public string get_UniqueName();
    [SupportedOSPlatformAttribute("windows")]
public static CngKey Create(CngAlgorithm algorithm);
    [SupportedOSPlatformAttribute("windows")]
public static CngKey Create(CngAlgorithm algorithm, string keyName);
    [SupportedOSPlatformAttribute("windows")]
public static CngKey Create(CngAlgorithm algorithm, string keyName, CngKeyCreationParameters creationParameters);
    public void Delete();
    public sealed virtual void Dispose();
    [SupportedOSPlatformAttribute("windows")]
public static bool Exists(string keyName);
    [SupportedOSPlatformAttribute("windows")]
public static bool Exists(string keyName, CngProvider provider);
    [SupportedOSPlatformAttribute("windows")]
public static bool Exists(string keyName, CngProvider provider, CngKeyOpenOptions options);
    public Byte[] Export(CngKeyBlobFormat format);
    public CngProperty GetProperty(string name, CngPropertyOptions options);
    public bool HasProperty(string name, CngPropertyOptions options);
    [SupportedOSPlatformAttribute("windows")]
public static CngKey Import(Byte[] keyBlob, CngKeyBlobFormat format);
    [SupportedOSPlatformAttribute("windows")]
public static CngKey Import(Byte[] keyBlob, CngKeyBlobFormat format, CngProvider provider);
    [SupportedOSPlatformAttribute("windows")]
public static CngKey Open(SafeNCryptKeyHandle keyHandle, CngKeyHandleOpenOptions keyHandleOpenOptions);
    [SupportedOSPlatformAttribute("windows")]
public static CngKey Open(string keyName);
    [SupportedOSPlatformAttribute("windows")]
public static CngKey Open(string keyName, CngProvider provider);
    [SupportedOSPlatformAttribute("windows")]
public static CngKey Open(string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
    public void SetProperty(CngProperty property);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngKeyBlobFormat : object {
    public static CngKeyBlobFormat EccFullPrivateBlob { get; }
    public static CngKeyBlobFormat EccFullPublicBlob { get; }
    public static CngKeyBlobFormat EccPrivateBlob { get; }
    public static CngKeyBlobFormat EccPublicBlob { get; }
    public string Format { get; }
    public static CngKeyBlobFormat GenericPrivateBlob { get; }
    public static CngKeyBlobFormat GenericPublicBlob { get; }
    public static CngKeyBlobFormat OpaqueTransportBlob { get; }
    public static CngKeyBlobFormat Pkcs8PrivateBlob { get; }
    public CngKeyBlobFormat(string format);
    public static CngKeyBlobFormat get_EccFullPrivateBlob();
    public static CngKeyBlobFormat get_EccFullPublicBlob();
    public static CngKeyBlobFormat get_EccPrivateBlob();
    public static CngKeyBlobFormat get_EccPublicBlob();
    public string get_Format();
    public static CngKeyBlobFormat get_GenericPrivateBlob();
    public static CngKeyBlobFormat get_GenericPublicBlob();
    public static CngKeyBlobFormat get_OpaqueTransportBlob();
    public static CngKeyBlobFormat get_Pkcs8PrivateBlob();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(CngKeyBlobFormat other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(CngKeyBlobFormat left, CngKeyBlobFormat right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(CngKeyBlobFormat left, CngKeyBlobFormat right);
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyCreationOptions : Enum {
    public int value__;
    public static CngKeyCreationOptions None;
    public static CngKeyCreationOptions MachineKey;
    public static CngKeyCreationOptions OverwriteExistingKey;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngKeyCreationParameters : object {
    public Nullable`1<CngExportPolicies> ExportPolicy { get; public set; }
    public CngKeyCreationOptions KeyCreationOptions { get; public set; }
    public Nullable`1<CngKeyUsages> KeyUsage { get; public set; }
    public CngPropertyCollection Parameters { get; }
    public IntPtr ParentWindowHandle { get; public set; }
    public CngProvider Provider { get; public set; }
    [NullableAttribute("2")]
public CngUIPolicy UIPolicy { get; public set; }
    public Nullable`1<CngExportPolicies> get_ExportPolicy();
    public void set_ExportPolicy(Nullable`1<CngExportPolicies> value);
    public CngKeyCreationOptions get_KeyCreationOptions();
    public void set_KeyCreationOptions(CngKeyCreationOptions value);
    public Nullable`1<CngKeyUsages> get_KeyUsage();
    public void set_KeyUsage(Nullable`1<CngKeyUsages> value);
    public CngPropertyCollection get_Parameters();
    public IntPtr get_ParentWindowHandle();
    public void set_ParentWindowHandle(IntPtr value);
    public CngProvider get_Provider();
    public void set_Provider(CngProvider value);
    [NullableContextAttribute("2")]
public CngUIPolicy get_UIPolicy();
    [NullableContextAttribute("2")]
public void set_UIPolicy(CngUIPolicy value);
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyHandleOpenOptions : Enum {
    public int value__;
    public static CngKeyHandleOpenOptions None;
    public static CngKeyHandleOpenOptions EphemeralKey;
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyOpenOptions : Enum {
    public int value__;
    public static CngKeyOpenOptions None;
    public static CngKeyOpenOptions UserKey;
    public static CngKeyOpenOptions MachineKey;
    public static CngKeyOpenOptions Silent;
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyUsages : Enum {
    public int value__;
    public static CngKeyUsages None;
    public static CngKeyUsages Decryption;
    public static CngKeyUsages Signing;
    public static CngKeyUsages KeyAgreement;
    public static CngKeyUsages AllUsages;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngProperty : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public string Name { get; }
    public CngPropertyOptions Options { get; }
    public CngProperty(string name, Byte[] value, CngPropertyOptions options);
    [IsReadOnlyAttribute]
public string get_Name();
    [IsReadOnlyAttribute]
public CngPropertyOptions get_Options();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CngProperty other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public Byte[] GetValue();
    public static bool op_Equality(CngProperty left, CngProperty right);
    public static bool op_Inequality(CngProperty left, CngProperty right);
}
public class System.Security.Cryptography.CngPropertyCollection : Collection`1<CngProperty> {
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngPropertyOptions : Enum {
    public int value__;
    public static CngPropertyOptions Persist;
    public static CngPropertyOptions None;
    public static CngPropertyOptions CustomProperty;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngProvider : object {
    public static CngProvider MicrosoftPlatformCryptoProvider { get; }
    public static CngProvider MicrosoftSmartCardKeyStorageProvider { get; }
    public static CngProvider MicrosoftSoftwareKeyStorageProvider { get; }
    public string Provider { get; }
    public CngProvider(string provider);
    public static CngProvider get_MicrosoftPlatformCryptoProvider();
    public static CngProvider get_MicrosoftSmartCardKeyStorageProvider();
    public static CngProvider get_MicrosoftSoftwareKeyStorageProvider();
    public string get_Provider();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(CngProvider other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(CngProvider left, CngProvider right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(CngProvider left, CngProvider right);
    public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngUIPolicy : object {
    public string CreationTitle { get; }
    public string Description { get; }
    public string FriendlyName { get; }
    public CngUIProtectionLevels ProtectionLevel { get; }
    public string UseContext { get; }
    public CngUIPolicy(CngUIProtectionLevels protectionLevel);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description, string useContext);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description, string useContext, string creationTitle);
    public string get_CreationTitle();
    public string get_Description();
    public string get_FriendlyName();
    public CngUIProtectionLevels get_ProtectionLevel();
    public string get_UseContext();
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngUIProtectionLevels : Enum {
    public int value__;
    public static CngUIProtectionLevels None;
    public static CngUIProtectionLevels ProtectKey;
    public static CngUIProtectionLevels ForceHighProtection;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CryptoConfig : object {
    public static bool AllowOnlyFipsAlgorithms { get; }
    public static bool get_AllowOnlyFipsAlgorithms();
    [UnsupportedOSPlatformAttribute("browser")]
public static void AddAlgorithm(Type algorithm, String[] names);
    [UnsupportedOSPlatformAttribute("browser")]
public static void AddOID(string oid, String[] names);
    [RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static object CreateFromName(string name);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static object CreateFromName(string name, Object[] args);
    [ObsoleteAttribute("EncodeOID is obsolete. Use the ASN.1 functionality provided in System.Formats.Asn1.")]
[UnsupportedOSPlatformAttribute("browser")]
public static Byte[] EncodeOID(string str);
    [UnsupportedOSPlatformAttribute("browser")]
public static string MapNameToOID(string name);
}
public static class System.Security.Cryptography.CryptographicOperations : object {
    public static bool FixedTimeEquals(ReadOnlySpan`1<byte> left, ReadOnlySpan`1<byte> right);
    public static void ZeroMemory(Span`1<byte> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CryptographicUnexpectedOperationException : CryptographicException {
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected CryptographicUnexpectedOperationException(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public CryptographicUnexpectedOperationException(string message);
    [NullableContextAttribute("2")]
public CryptographicUnexpectedOperationException(string message, Exception inner);
    public CryptographicUnexpectedOperationException(string format, string insert);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CryptoStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool HasFlushedFinalBlock { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CryptoStream(Stream stream, ICryptoTransform transform, CryptoStreamMode mode);
    public CryptoStream(Stream stream, ICryptoTransform transform, CryptoStreamMode mode, bool leaveOpen);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public bool get_HasFlushedFinalBlock();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public void Clear();
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public void FlushFinalBlock();
    public ValueTask FlushFinalBlockAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
}
public enum System.Security.Cryptography.CryptoStreamMode : Enum {
    public int value__;
    public static CryptoStreamMode Read;
    public static CryptoStreamMode Write;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[SupportedOSPlatformAttribute("windows")]
public class System.Security.Cryptography.CspKeyContainerInfo : object {
    public bool Accessible { get; }
    public bool Exportable { get; }
    public bool HardwareDevice { get; }
    public string KeyContainerName { get; }
    public KeyNumber KeyNumber { get; }
    public bool MachineKeyStore { get; }
    public bool Protected { get; }
    public string ProviderName { get; }
    public int ProviderType { get; }
    public bool RandomlyGenerated { get; }
    public bool Removable { get; }
    [NullableAttribute("1")]
public string UniqueKeyContainerName { get; }
    [NullableContextAttribute("1")]
public CspKeyContainerInfo(CspParameters parameters);
    public bool get_Accessible();
    public bool get_Exportable();
    public bool get_HardwareDevice();
    public string get_KeyContainerName();
    public KeyNumber get_KeyNumber();
    public bool get_MachineKeyStore();
    public bool get_Protected();
    public string get_ProviderName();
    public int get_ProviderType();
    public bool get_RandomlyGenerated();
    public bool get_Removable();
    [NullableContextAttribute("1")]
public string get_UniqueKeyContainerName();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[SupportedOSPlatformAttribute("windows")]
public class System.Security.Cryptography.CspParameters : object {
    public string KeyContainerName;
    public int KeyNumber;
    public string ProviderName;
    public int ProviderType;
    public CspProviderFlags Flags { get; public set; }
    [CLSCompliantAttribute("False")]
public SecureString KeyPassword { get; public set; }
    public IntPtr ParentWindowHandle { get; public set; }
    public CspParameters(int dwTypeIn);
    public CspParameters(int dwTypeIn, string strProviderNameIn);
    public CspParameters(int dwTypeIn, string strProviderNameIn, string strContainerNameIn);
    public CspProviderFlags get_Flags();
    public void set_Flags(CspProviderFlags value);
    public SecureString get_KeyPassword();
    public void set_KeyPassword(SecureString value);
    public IntPtr get_ParentWindowHandle();
    public void set_ParentWindowHandle(IntPtr value);
}
[FlagsAttribute]
public enum System.Security.Cryptography.CspProviderFlags : Enum {
    public int value__;
    public static CspProviderFlags NoFlags;
    public static CspProviderFlags UseMachineKeyStore;
    public static CspProviderFlags UseDefaultKeyContainer;
    public static CspProviderFlags UseNonExportableKey;
    public static CspProviderFlags UseExistingKey;
    public static CspProviderFlags UseArchivableKey;
    public static CspProviderFlags UseUserProtectedKey;
    public static CspProviderFlags NoPrompt;
    public static CspProviderFlags CreateEphemeralKey;
}
public abstract class System.Security.Cryptography.DeriveBytes : object {
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("1")]
public abstract virtual Byte[] GetBytes(int cb);
    public abstract virtual void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public abstract class System.Security.Cryptography.DES : SymmetricAlgorithm {
    public Byte[] Key { get; public set; }
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    [UnsupportedOSPlatformAttribute("browser")]
public static DES Create();
    [RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
public static DES Create(string algName);
    public static bool IsSemiWeakKey(Byte[] rgbKey);
    public static bool IsWeakKey(Byte[] rgbKey);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
public class System.Security.Cryptography.DESCryptoServiceProvider : DES {
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
}
public abstract class System.Security.Cryptography.DSA : AsymmetricAlgorithm {
    [NullableContextAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public static DSA Create();
    [NullableContextAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public static DSA Create(int keySizeInBits);
    [NullableContextAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public static DSA Create(DSAParameters parameters);
    [NullableContextAttribute("1")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
public static DSA Create(string algName);
    [NullableContextAttribute("1")]
public abstract virtual Byte[] CreateSignature(Byte[] rgbHash);
    [NullableContextAttribute("1")]
public Byte[] CreateSignature(Byte[] rgbHash, DSASignatureFormat signatureFormat);
    protected virtual Byte[] CreateSignatureCore(ReadOnlySpan`1<byte> hash, DSASignatureFormat signatureFormat);
    public abstract virtual DSAParameters ExportParameters(bool includePrivateParameters);
    [NullableContextAttribute("1")]
public virtual void FromXmlString(string xmlString);
    public int GetMaxSignatureSize(DSASignatureFormat signatureFormat);
    [NullableContextAttribute("1")]
protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<byte> passwordBytes);
    public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> password);
    public virtual void ImportFromPem(ReadOnlySpan`1<char> input);
    public abstract virtual void ImportParameters(DSAParameters parameters);
    public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("1")]
public virtual Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("1")]
public Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("1")]
public virtual Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("1")]
protected virtual Byte[] SignDataCore(Stream data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    protected virtual Byte[] SignDataCore(ReadOnlySpan`1<byte> data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("1")]
public virtual string ToXmlString(bool includePrivateParameters);
    public virtual bool TryCreateSignature(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, Int32& bytesWritten);
    public bool TryCreateSignature(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    protected virtual bool TryCreateSignatureCore(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
    protected virtual bool TryHashData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public virtual bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    protected virtual bool TrySignDataCore(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    [NullableContextAttribute("1")]
public bool VerifyData(Byte[] data, Byte[] signature, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public bool VerifyData(Byte[] data, Byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("1")]
public virtual bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("1")]
public virtual bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    public virtual bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm);
    public bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    protected virtual bool VerifyDataCore(Stream data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    protected virtual bool VerifyDataCore(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("1")]
public abstract virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
    [NullableContextAttribute("1")]
public bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature, DSASignatureFormat signatureFormat);
    public virtual bool VerifySignature(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature);
    public bool VerifySignature(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, DSASignatureFormat signatureFormat);
    protected virtual bool VerifySignatureCore(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, DSASignatureFormat signatureFormat);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.DSACng : DSA {
    public CngKey Key { get; }
    [NullableAttribute("2")]
public string KeyExchangeAlgorithm { get; }
    public KeySizes[] LegalKeySizes { get; }
    public string SignatureAlgorithm { get; }
    [SupportedOSPlatformAttribute("windows")]
public DSACng(int keySize);
    [SupportedOSPlatformAttribute("windows")]
public DSACng(CngKey key);
    public CngKey get_Key();
    [NullableContextAttribute("2")]
public virtual string get_KeyExchangeAlgorithm();
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual string get_SignatureAlgorithm();
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
    protected virtual void Dispose(bool disposing);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    public virtual DSAParameters ExportParameters(bool includePrivateParameters);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportParameters(DSAParameters parameters);
    [NullableContextAttribute("0")]
protected virtual bool TryCreateSignatureCore(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
    [NullableContextAttribute("0")]
protected virtual bool VerifySignatureCore(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, DSASignatureFormat signatureFormat);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.DSACryptoServiceProvider : DSA {
    [SupportedOSPlatformAttribute("windows")]
public CspKeyContainerInfo CspKeyContainerInfo { get; }
    [NullableAttribute("2")]
public string KeyExchangeAlgorithm { get; }
    public int KeySize { get; }
    public KeySizes[] LegalKeySizes { get; }
    public bool PersistKeyInCsp { get; public set; }
    public bool PublicOnly { get; }
    public string SignatureAlgorithm { get; }
    public static bool UseMachineKeyStore { get; public set; }
    [UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public DSACryptoServiceProvider(int dwKeySize);
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
public DSACryptoServiceProvider(int dwKeySize, CspParameters parameters);
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
public DSACryptoServiceProvider(CspParameters parameters);
    public sealed virtual CspKeyContainerInfo get_CspKeyContainerInfo();
    [NullableContextAttribute("2")]
public virtual string get_KeyExchangeAlgorithm();
    public virtual int get_KeySize();
    public virtual KeySizes[] get_LegalKeySizes();
    public bool get_PersistKeyInCsp();
    public void set_PersistKeyInCsp(bool value);
    public bool get_PublicOnly();
    public virtual string get_SignatureAlgorithm();
    public static bool get_UseMachineKeyStore();
    public static void set_UseMachineKeyStore(bool value);
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
    protected virtual void Dispose(bool disposing);
    public sealed virtual Byte[] ExportCspBlob(bool includePrivateParameters);
    public virtual DSAParameters ExportParameters(bool includePrivateParameters);
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    public sealed virtual void ImportCspBlob(Byte[] keyBlob);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportParameters(DSAParameters parameters);
    public Byte[] SignData(Byte[] buffer);
    public Byte[] SignData(Byte[] buffer, int offset, int count);
    public Byte[] SignData(Stream inputStream);
    public Byte[] SignHash(Byte[] rgbHash, string str);
    public bool VerifyData(Byte[] rgbData, Byte[] rgbSignature);
    public bool VerifyHash(Byte[] rgbHash, string str, Byte[] rgbSignature);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.DSAOpenSsl : DSA {
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public DSAOpenSsl(int keySize);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public DSAOpenSsl(IntPtr handle);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public DSAOpenSsl(DSAParameters parameters);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public DSAOpenSsl(SafeEvpPKeyHandle pkeyHandle);
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
    public SafeEvpPKeyHandle DuplicateKeyHandle();
    public virtual DSAParameters ExportParameters(bool includePrivateParameters);
    public virtual void ImportParameters(DSAParameters parameters);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.DSAParameters : ValueType {
    public int Counter;
    public Byte[] G;
    public Byte[] J;
    public Byte[] P;
    public Byte[] Q;
    public Byte[] Seed;
    public Byte[] X;
    public Byte[] Y;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.DSASignatureDeformatter : AsymmetricSignatureDeformatter {
    public DSASignatureDeformatter(AsymmetricAlgorithm key);
    public virtual void SetHashAlgorithm(string strName);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
}
public enum System.Security.Cryptography.DSASignatureFormat : Enum {
    public int value__;
    public static DSASignatureFormat IeeeP1363FixedFieldConcatenation;
    public static DSASignatureFormat Rfc3279DerSequence;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.DSASignatureFormatter : AsymmetricSignatureFormatter {
    public DSASignatureFormatter(AsymmetricAlgorithm key);
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
    public virtual void SetHashAlgorithm(string strName);
    public virtual void SetKey(AsymmetricAlgorithm key);
}
public abstract class System.Security.Cryptography.ECAlgorithm : AsymmetricAlgorithm {
    [NullableContextAttribute("1")]
public virtual Byte[] ExportECPrivateKey();
    [NullableContextAttribute("1")]
public string ExportECPrivateKeyPem();
    public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters);
    public virtual ECParameters ExportParameters(bool includePrivateParameters);
    public virtual void GenerateKey(ECCurve curve);
    public virtual void ImportECPrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<byte> passwordBytes);
    public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> password);
    public virtual void ImportFromPem(ReadOnlySpan`1<char> input);
    public virtual void ImportParameters(ECParameters parameters);
    public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual bool TryExportECPrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public bool TryExportECPrivateKeyPem(Span`1<char> destination, Int32& charsWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.ECCurve : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public Byte[] A;
    public Byte[] B;
    public Byte[] Cofactor;
    public ECCurveType CurveType;
    public ECPoint G;
    public Nullable`1<HashAlgorithmName> Hash;
    public Byte[] Order;
    public Byte[] Polynomial;
    public Byte[] Prime;
    public Byte[] Seed;
    public bool IsCharacteristic2 { get; }
    public bool IsExplicit { get; }
    public bool IsNamed { get; }
    public bool IsPrime { get; }
    [NullableAttribute("1")]
public Oid Oid { get; }
    public bool get_IsCharacteristic2();
    public bool get_IsExplicit();
    public bool get_IsNamed();
    public bool get_IsPrime();
    [NullableContextAttribute("1")]
public Oid get_Oid();
    [NullableContextAttribute("1")]
public static ECCurve CreateFromFriendlyName(string oidFriendlyName);
    [NullableContextAttribute("1")]
public static ECCurve CreateFromOid(Oid curveOid);
    [NullableContextAttribute("1")]
public static ECCurve CreateFromValue(string oidValue);
    public void Validate();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.ECDiffieHellman : ECAlgorithm {
    public string KeyExchangeAlgorithm { get; }
    public ECDiffieHellmanPublicKey PublicKey { get; }
    [NullableAttribute("2")]
public string SignatureAlgorithm { get; }
    public virtual string get_KeyExchangeAlgorithm();
    public abstract virtual ECDiffieHellmanPublicKey get_PublicKey();
    [NullableContextAttribute("2")]
public virtual string get_SignatureAlgorithm();
    [UnsupportedOSPlatformAttribute("browser")]
public static ECDiffieHellman Create();
    [UnsupportedOSPlatformAttribute("browser")]
public static ECDiffieHellman Create(ECCurve curve);
    [UnsupportedOSPlatformAttribute("browser")]
public static ECDiffieHellman Create(ECParameters parameters);
    [RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
public static ECDiffieHellman Create(string algorithm);
    public Byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm);
    public virtual Byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] secretPrepend, Byte[] secretAppend);
    public Byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] hmacKey);
    [NullableContextAttribute("2")]
public virtual Byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] hmacKey, Byte[] secretPrepend, Byte[] secretAppend);
    public virtual Byte[] DeriveKeyMaterial(ECDiffieHellmanPublicKey otherPartyPublicKey);
    public virtual Byte[] DeriveKeyTls(ECDiffieHellmanPublicKey otherPartyPublicKey, Byte[] prfLabel, Byte[] prfSeed);
    public virtual Byte[] DeriveRawSecretAgreement(ECDiffieHellmanPublicKey otherPartyPublicKey);
    public virtual void FromXmlString(string xmlString);
    public virtual string ToXmlString(bool includePrivateParameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.ECDiffieHellmanCng : ECDiffieHellman {
    public CngAlgorithm HashAlgorithm { get; public set; }
    [NullableAttribute("2")]
public Byte[] HmacKey { get; public set; }
    public CngKey Key { get; }
    public ECDiffieHellmanKeyDerivationFunction KeyDerivationFunction { get; public set; }
    public int KeySize { get; public set; }
    [NullableAttribute("2")]
public Byte[] Label { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    public ECDiffieHellmanPublicKey PublicKey { get; }
    [NullableAttribute("2")]
public Byte[] SecretAppend { get; public set; }
    [NullableAttribute("2")]
public Byte[] SecretPrepend { get; public set; }
    [NullableAttribute("2")]
public Byte[] Seed { get; public set; }
    public bool UseSecretAgreementAsHmacKey { get; }
    [SupportedOSPlatformAttribute("windows")]
public ECDiffieHellmanCng(int keySize);
    [SupportedOSPlatformAttribute("windows")]
public ECDiffieHellmanCng(CngKey key);
    [SupportedOSPlatformAttribute("windows")]
public ECDiffieHellmanCng(ECCurve curve);
    public CngAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(CngAlgorithm value);
    [NullableContextAttribute("2")]
public Byte[] get_HmacKey();
    [NullableContextAttribute("2")]
public void set_HmacKey(Byte[] value);
    public CngKey get_Key();
    public ECDiffieHellmanKeyDerivationFunction get_KeyDerivationFunction();
    public void set_KeyDerivationFunction(ECDiffieHellmanKeyDerivationFunction value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    [NullableContextAttribute("2")]
public Byte[] get_Label();
    [NullableContextAttribute("2")]
public void set_Label(Byte[] value);
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual ECDiffieHellmanPublicKey get_PublicKey();
    [NullableContextAttribute("2")]
public Byte[] get_SecretAppend();
    [NullableContextAttribute("2")]
public void set_SecretAppend(Byte[] value);
    [NullableContextAttribute("2")]
public Byte[] get_SecretPrepend();
    [NullableContextAttribute("2")]
public void set_SecretPrepend(Byte[] value);
    [NullableContextAttribute("2")]
public Byte[] get_Seed();
    [NullableContextAttribute("2")]
public void set_Seed(Byte[] value);
    public bool get_UseSecretAgreementAsHmacKey();
    public virtual Byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] secretPrepend, Byte[] secretAppend);
    [NullableContextAttribute("2")]
public virtual Byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] hmacKey, Byte[] secretPrepend, Byte[] secretAppend);
    public Byte[] DeriveKeyMaterial(CngKey otherPartyPublicKey);
    public virtual Byte[] DeriveKeyMaterial(ECDiffieHellmanPublicKey otherPartyPublicKey);
    public virtual Byte[] DeriveKeyTls(ECDiffieHellmanPublicKey otherPartyPublicKey, Byte[] prfLabel, Byte[] prfSeed);
    public SafeNCryptSecretHandle DeriveSecretAgreementHandle(CngKey otherPartyPublicKey);
    public SafeNCryptSecretHandle DeriveSecretAgreementHandle(ECDiffieHellmanPublicKey otherPartyPublicKey);
    protected virtual void Dispose(bool disposing);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters);
    public virtual ECParameters ExportParameters(bool includePrivateParameters);
    [ObsoleteAttribute("ToXmlString and FromXmlString have no implementation for ECC types, and are obsolete. Use a standard import and export format such as ExportSubjectPublicKeyInfo or ImportSubjectPublicKeyInfo for public keys and ExportPkcs8PrivateKey or ImportPkcs8PrivateKey for private keys.")]
public void FromXmlString(string xml, ECKeyXmlFormat format);
    public virtual void GenerateKey(ECCurve curve);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportParameters(ECParameters parameters);
    [NullableContextAttribute("0")]
public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [ObsoleteAttribute("ToXmlString and FromXmlString have no implementation for ECC types, and are obsolete. Use a standard import and export format such as ExportSubjectPublicKeyInfo or ImportSubjectPublicKeyInfo for public keys and ExportPkcs8PrivateKey or ImportPkcs8PrivateKey for private keys.")]
public string ToXmlString(ECKeyXmlFormat format);
    [NullableContextAttribute("0")]
public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.ECDiffieHellmanCngPublicKey : ECDiffieHellmanPublicKey {
    public CngKeyBlobFormat BlobFormat { get; }
    public CngKeyBlobFormat get_BlobFormat();
    protected virtual void Dispose(bool disposing);
    public virtual ECParameters ExportExplicitParameters();
    public virtual ECParameters ExportParameters();
    [SupportedOSPlatformAttribute("windows")]
public static ECDiffieHellmanPublicKey FromByteArray(Byte[] publicKeyBlob, CngKeyBlobFormat format);
    [ObsoleteAttribute("ToXmlString and FromXmlString have no implementation for ECC types, and are obsolete. Use a standard import and export format such as ExportSubjectPublicKeyInfo or ImportSubjectPublicKeyInfo for public keys and ExportPkcs8PrivateKey or ImportPkcs8PrivateKey for private keys.")]
public static ECDiffieHellmanCngPublicKey FromXmlString(string xml);
    public CngKey Import();
    [ObsoleteAttribute("ToXmlString and FromXmlString have no implementation for ECC types, and are obsolete. Use a standard import and export format such as ExportSubjectPublicKeyInfo or ImportSubjectPublicKeyInfo for public keys and ExportPkcs8PrivateKey or ImportPkcs8PrivateKey for private keys.")]
public virtual string ToXmlString();
}
public enum System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction : Enum {
    public int value__;
    public static ECDiffieHellmanKeyDerivationFunction Hash;
    public static ECDiffieHellmanKeyDerivationFunction Hmac;
    public static ECDiffieHellmanKeyDerivationFunction Tls;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.ECDiffieHellmanOpenSsl : ECDiffieHellman {
    public ECDiffieHellmanPublicKey PublicKey { get; }
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public ECDiffieHellmanOpenSsl(int keySize);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public ECDiffieHellmanOpenSsl(IntPtr handle);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public ECDiffieHellmanOpenSsl(ECCurve curve);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public ECDiffieHellmanOpenSsl(SafeEvpPKeyHandle pkeyHandle);
    public virtual ECDiffieHellmanPublicKey get_PublicKey();
    public SafeEvpPKeyHandle DuplicateKeyHandle();
    public virtual ECParameters ExportParameters(bool includePrivateParameters);
    public virtual void ImportParameters(ECParameters parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.ECDiffieHellmanPublicKey : object {
    [ObsoleteAttribute("ECDiffieHellmanPublicKey.ToByteArray() and the associated constructor do not have a consistent and interoperable implementation on all platforms. Use ECDiffieHellmanPublicKey.ExportSubjectPublicKeyInfo() instead.")]
protected ECDiffieHellmanPublicKey(Byte[] keyBlob);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual ECParameters ExportExplicitParameters();
    public virtual ECParameters ExportParameters();
    public virtual Byte[] ExportSubjectPublicKeyInfo();
    [ObsoleteAttribute("ECDiffieHellmanPublicKey.ToByteArray() and the associated constructor do not have a consistent and interoperable implementation on all platforms. Use ECDiffieHellmanPublicKey.ExportSubjectPublicKeyInfo() instead.")]
public virtual Byte[] ToByteArray();
    [ObsoleteAttribute("ToXmlString and FromXmlString have no implementation for ECC types, and are obsolete. Use a standard import and export format such as ExportSubjectPublicKeyInfo or ImportSubjectPublicKeyInfo for public keys and ExportPkcs8PrivateKey or ImportPkcs8PrivateKey for private keys.")]
public virtual string ToXmlString();
    [NullableContextAttribute("0")]
public virtual bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.ECDsa : ECAlgorithm {
    [NullableAttribute("2")]
public string KeyExchangeAlgorithm { get; }
    public string SignatureAlgorithm { get; }
    [NullableContextAttribute("2")]
public virtual string get_KeyExchangeAlgorithm();
    public virtual string get_SignatureAlgorithm();
    [UnsupportedOSPlatformAttribute("browser")]
public static ECDsa Create();
    [UnsupportedOSPlatformAttribute("browser")]
public static ECDsa Create(ECCurve curve);
    [UnsupportedOSPlatformAttribute("browser")]
public static ECDsa Create(ECParameters parameters);
    [RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
public static ECDsa Create(string algorithm);
    public virtual void FromXmlString(string xmlString);
    public int GetMaxSignatureSize(DSASignatureFormat signatureFormat);
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    public Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    public virtual Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    public Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    public virtual Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm);
    public Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
public Byte[] SignData(ReadOnlySpan`1<byte> data, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("0")]
public Byte[] SignData(ReadOnlySpan`1<byte> data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
public int SignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("0")]
public int SignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    protected virtual Byte[] SignDataCore(Stream data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
protected virtual Byte[] SignDataCore(ReadOnlySpan`1<byte> data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    public abstract virtual Byte[] SignHash(Byte[] hash);
    public Byte[] SignHash(Byte[] hash, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
public Byte[] SignHash(ReadOnlySpan`1<byte> hash);
    [NullableContextAttribute("0")]
public Byte[] SignHash(ReadOnlySpan`1<byte> hash, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
public int SignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination);
    [NullableContextAttribute("0")]
public int SignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
protected virtual Byte[] SignHashCore(ReadOnlySpan`1<byte> hash, DSASignatureFormat signatureFormat);
    public virtual string ToXmlString(bool includePrivateParameters);
    [NullableContextAttribute("0")]
protected virtual bool TryHashData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TrySignDataCore(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TrySignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public bool TrySignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TrySignHashCore(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    public bool VerifyData(Byte[] data, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public bool VerifyData(Byte[] data, Byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    public virtual bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    public bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
public virtual bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("0")]
public bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
protected virtual bool VerifyDataCore(Stream data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
protected virtual bool VerifyDataCore(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    public abstract virtual bool VerifyHash(Byte[] hash, Byte[] signature);
    public bool VerifyHash(Byte[] hash, Byte[] signature, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
public virtual bool VerifyHash(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature);
    [NullableContextAttribute("0")]
public bool VerifyHash(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
protected virtual bool VerifyHashCore(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, DSASignatureFormat signatureFormat);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.ECDsaCng : ECDsa {
    public CngAlgorithm HashAlgorithm { get; public set; }
    public CngKey Key { get; }
    public int KeySize { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    [SupportedOSPlatformAttribute("windows")]
public ECDsaCng(int keySize);
    [SupportedOSPlatformAttribute("windows")]
public ECDsaCng(CngKey key);
    [SupportedOSPlatformAttribute("windows")]
public ECDsaCng(ECCurve curve);
    public CngAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(CngAlgorithm value);
    public CngKey get_Key();
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual KeySizes[] get_LegalKeySizes();
    protected virtual void Dispose(bool disposing);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters);
    public virtual ECParameters ExportParameters(bool includePrivateParameters);
    [ObsoleteAttribute("ToXmlString and FromXmlString have no implementation for ECC types, and are obsolete. Use a standard import and export format such as ExportSubjectPublicKeyInfo or ImportSubjectPublicKeyInfo for public keys and ExportPkcs8PrivateKey or ImportPkcs8PrivateKey for private keys.")]
public void FromXmlString(string xml, ECKeyXmlFormat format);
    public virtual void GenerateKey(ECCurve curve);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportParameters(ECParameters parameters);
    [NullableContextAttribute("0")]
public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public Byte[] SignData(Byte[] data);
    public Byte[] SignData(Byte[] data, int offset, int count);
    public Byte[] SignData(Stream data);
    public virtual Byte[] SignHash(Byte[] hash);
    [ObsoleteAttribute("ToXmlString and FromXmlString have no implementation for ECC types, and are obsolete. Use a standard import and export format such as ExportSubjectPublicKeyInfo or ImportSubjectPublicKeyInfo for public keys and ExportPkcs8PrivateKey or ImportPkcs8PrivateKey for private keys.")]
public string ToXmlString(ECKeyXmlFormat format);
    [NullableContextAttribute("0")]
public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TrySignHash(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TrySignHashCore(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    public bool VerifyData(Byte[] data, Byte[] signature);
    public bool VerifyData(Byte[] data, int offset, int count, Byte[] signature);
    public bool VerifyData(Stream data, Byte[] signature);
    public virtual bool VerifyHash(Byte[] hash, Byte[] signature);
    [NullableContextAttribute("0")]
public virtual bool VerifyHash(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature);
    [NullableContextAttribute("0")]
protected virtual bool VerifyHashCore(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, DSASignatureFormat signatureFormat);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.ECDsaOpenSsl : ECDsa {
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public ECDsaOpenSsl(int keySize);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public ECDsaOpenSsl(IntPtr handle);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public ECDsaOpenSsl(ECCurve curve);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public ECDsaOpenSsl(SafeEvpPKeyHandle pkeyHandle);
    public SafeEvpPKeyHandle DuplicateKeyHandle();
    public virtual Byte[] SignHash(Byte[] hash);
    public virtual bool VerifyHash(Byte[] hash, Byte[] signature);
}
public enum System.Security.Cryptography.ECKeyXmlFormat : Enum {
    public int value__;
    public static ECKeyXmlFormat Rfc4050;
}
public class System.Security.Cryptography.ECParameters : ValueType {
    public ECCurve Curve;
    [NullableAttribute("2")]
public Byte[] D;
    public ECPoint Q;
    public void Validate();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.ECPoint : ValueType {
    public Byte[] X;
    public Byte[] Y;
}
public class System.Security.Cryptography.FromBase64Transform : object {
    public bool CanReuseTransform { get; }
    public bool CanTransformMultipleBlocks { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public FromBase64Transform(FromBase64TransformMode whitespaces);
    public virtual bool get_CanReuseTransform();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    public void Clear();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    [NullableContextAttribute("1")]
public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    [NullableContextAttribute("1")]
public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
}
public enum System.Security.Cryptography.FromBase64TransformMode : Enum {
    public int value__;
    public static FromBase64TransformMode IgnoreWhiteSpaces;
    public static FromBase64TransformMode DoNotIgnoreWhiteSpaces;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.HashAlgorithm : object {
    protected int HashSizeValue;
    [NullableAttribute("2")]
protected internal Byte[] HashValue;
    protected int State;
    public bool CanReuseTransform { get; }
    public bool CanTransformMultipleBlocks { get; }
    [NullableAttribute("2")]
public Byte[] Hash { get; }
    public int HashSize { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public virtual bool get_CanReuseTransform();
    public virtual bool get_CanTransformMultipleBlocks();
    [NullableContextAttribute("2")]
public virtual Byte[] get_Hash();
    public virtual int get_HashSize();
    public virtual int get_InputBlockSize();
    public virtual int get_OutputBlockSize();
    public void Clear();
    public Byte[] ComputeHash(Byte[] buffer);
    public Byte[] ComputeHash(Byte[] buffer, int offset, int count);
    public Byte[] ComputeHash(Stream inputStream);
    public Task`1<Byte[]> ComputeHashAsync(Stream inputStream, CancellationToken cancellationToken);
    [ObsoleteAttribute("The default implementation of this cryptography algorithm is not supported.")]
public static HashAlgorithm Create();
    [RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
public static HashAlgorithm Create(string hashName);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected abstract virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    [NullableContextAttribute("0")]
protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected abstract virtual Byte[] HashFinal();
    public abstract virtual void Initialize();
    public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    [NullableContextAttribute("0")]
public bool TryComputeHash(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Security.Cryptography.HashAlgorithmName : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public static HashAlgorithmName MD5 { get; }
    public string Name { get; }
    public static HashAlgorithmName SHA1 { get; }
    public static HashAlgorithmName SHA256 { get; }
    public static HashAlgorithmName SHA384 { get; }
    public static HashAlgorithmName SHA3_256 { get; }
    public static HashAlgorithmName SHA3_384 { get; }
    public static HashAlgorithmName SHA3_512 { get; }
    public static HashAlgorithmName SHA512 { get; }
    public HashAlgorithmName(string name);
    public static HashAlgorithmName get_MD5();
    public string get_Name();
    public static HashAlgorithmName get_SHA1();
    public static HashAlgorithmName get_SHA256();
    public static HashAlgorithmName get_SHA384();
    public static HashAlgorithmName get_SHA3_256();
    public static HashAlgorithmName get_SHA3_384();
    public static HashAlgorithmName get_SHA3_512();
    public static HashAlgorithmName get_SHA512();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(HashAlgorithmName other);
    [NullableContextAttribute("1")]
public static HashAlgorithmName FromOid(string oidValue);
    public virtual int GetHashCode();
    public static bool op_Equality(HashAlgorithmName left, HashAlgorithmName right);
    public static bool op_Inequality(HashAlgorithmName left, HashAlgorithmName right);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public static bool TryFromOid(string oidValue, HashAlgorithmName& value);
}
public static class System.Security.Cryptography.HKDF : object {
    [NullableContextAttribute("1")]
public static Byte[] DeriveKey(HashAlgorithmName hashAlgorithmName, Byte[] ikm, int outputLength, Byte[] salt, Byte[] info);
    public static void DeriveKey(HashAlgorithmName hashAlgorithmName, ReadOnlySpan`1<byte> ikm, Span`1<byte> output, ReadOnlySpan`1<byte> salt, ReadOnlySpan`1<byte> info);
    [NullableContextAttribute("1")]
public static Byte[] Expand(HashAlgorithmName hashAlgorithmName, Byte[] prk, int outputLength, Byte[] info);
    public static void Expand(HashAlgorithmName hashAlgorithmName, ReadOnlySpan`1<byte> prk, Span`1<byte> output, ReadOnlySpan`1<byte> info);
    [NullableContextAttribute("1")]
public static Byte[] Extract(HashAlgorithmName hashAlgorithmName, Byte[] ikm, Byte[] salt);
    public static int Extract(HashAlgorithmName hashAlgorithmName, ReadOnlySpan`1<byte> ikm, ReadOnlySpan`1<byte> salt, Span`1<byte> prk);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.HMAC : KeyedHashAlgorithm {
    protected int BlockSizeValue { get; protected set; }
    public string HashName { get; public set; }
    public Byte[] Key { get; public set; }
    protected int get_BlockSizeValue();
    protected void set_BlockSizeValue(int value);
    public string get_HashName();
    public void set_HashName(string value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    [ObsoleteAttribute("The default implementation of this cryptography algorithm is not supported.")]
public static HMAC Create();
    [RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
public static HMAC Create(string algorithmName);
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    [NullableContextAttribute("0")]
protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    [NullableContextAttribute("0")]
protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.HMACMD5 : HMAC {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    public Byte[] Key { get; public set; }
    [UnsupportedOSPlatformAttribute("browser")]
public HMACMD5(Byte[] key);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    [NullableContextAttribute("0")]
protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    [UnsupportedOSPlatformAttribute("browser")]
public static Byte[] HashData(Byte[] key, Byte[] source);
    [UnsupportedOSPlatformAttribute("browser")]
public static Byte[] HashData(Byte[] key, Stream source);
    [UnsupportedOSPlatformAttribute("browser")]
public static Byte[] HashData(ReadOnlySpan`1<byte> key, Stream source);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static int HashData(ReadOnlySpan`1<byte> key, Stream source, Span`1<byte> destination);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static Byte[] HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static int HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    [UnsupportedOSPlatformAttribute("browser")]
public static ValueTask`1<Byte[]> HashDataAsync(Byte[] key, Stream source, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static ValueTask`1<int> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static ValueTask`1<Byte[]> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, CancellationToken cancellationToken);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static bool TryHashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.HMACSHA1 : HMAC {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    public Byte[] Key { get; public set; }
    public HMACSHA1(Byte[] key);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("HMACSHA1 always uses the algorithm implementation provided by the platform. Use a constructor without the useManagedSha1 parameter.")]
public HMACSHA1(Byte[] key, bool useManagedSha1);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    [NullableContextAttribute("0")]
protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    public static Byte[] HashData(Byte[] key, Byte[] source);
    public static Byte[] HashData(Byte[] key, Stream source);
    public static Byte[] HashData(ReadOnlySpan`1<byte> key, Stream source);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, Stream source, Span`1<byte> destination);
    [NullableContextAttribute("0")]
public static Byte[] HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    public static ValueTask`1<Byte[]> HashDataAsync(Byte[] key, Stream source, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static ValueTask`1<int> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static ValueTask`1<Byte[]> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, CancellationToken cancellationToken);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    [NullableContextAttribute("0")]
public static bool TryHashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.HMACSHA256 : HMAC {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    public Byte[] Key { get; public set; }
    public HMACSHA256(Byte[] key);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    [NullableContextAttribute("0")]
protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    public static Byte[] HashData(Byte[] key, Byte[] source);
    public static Byte[] HashData(Byte[] key, Stream source);
    public static Byte[] HashData(ReadOnlySpan`1<byte> key, Stream source);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, Stream source, Span`1<byte> destination);
    [NullableContextAttribute("0")]
public static Byte[] HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    public static ValueTask`1<Byte[]> HashDataAsync(Byte[] key, Stream source, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static ValueTask`1<int> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static ValueTask`1<Byte[]> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, CancellationToken cancellationToken);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    [NullableContextAttribute("0")]
public static bool TryHashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.HMACSHA3_256 : HMAC {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    public static bool IsSupported { get; }
    public Byte[] Key { get; public set; }
    public HMACSHA3_256(Byte[] key);
    public static bool get_IsSupported();
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    [NullableContextAttribute("0")]
protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    public static Byte[] HashData(Byte[] key, Byte[] source);
    public static Byte[] HashData(Byte[] key, Stream source);
    public static Byte[] HashData(ReadOnlySpan`1<byte> key, Stream source);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, Stream source, Span`1<byte> destination);
    [NullableContextAttribute("0")]
public static Byte[] HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    public static ValueTask`1<Byte[]> HashDataAsync(Byte[] key, Stream source, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static ValueTask`1<int> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static ValueTask`1<Byte[]> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, CancellationToken cancellationToken);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    [NullableContextAttribute("0")]
public static bool TryHashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.HMACSHA3_384 : HMAC {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    public static bool IsSupported { get; }
    public Byte[] Key { get; public set; }
    public HMACSHA3_384(Byte[] key);
    public static bool get_IsSupported();
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    [NullableContextAttribute("0")]
protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    public static Byte[] HashData(Byte[] key, Byte[] source);
    public static Byte[] HashData(Byte[] key, Stream source);
    public static Byte[] HashData(ReadOnlySpan`1<byte> key, Stream source);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, Stream source, Span`1<byte> destination);
    [NullableContextAttribute("0")]
public static Byte[] HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    public static ValueTask`1<Byte[]> HashDataAsync(Byte[] key, Stream source, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static ValueTask`1<int> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static ValueTask`1<Byte[]> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, CancellationToken cancellationToken);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    [NullableContextAttribute("0")]
public static bool TryHashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.HMACSHA3_512 : HMAC {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    public static bool IsSupported { get; }
    public Byte[] Key { get; public set; }
    public HMACSHA3_512(Byte[] key);
    public static bool get_IsSupported();
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    [NullableContextAttribute("0")]
protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    public static Byte[] HashData(Byte[] key, Byte[] source);
    public static Byte[] HashData(Byte[] key, Stream source);
    public static Byte[] HashData(ReadOnlySpan`1<byte> key, Stream source);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, Stream source, Span`1<byte> destination);
    [NullableContextAttribute("0")]
public static Byte[] HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    public static ValueTask`1<Byte[]> HashDataAsync(Byte[] key, Stream source, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static ValueTask`1<int> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static ValueTask`1<Byte[]> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, CancellationToken cancellationToken);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    [NullableContextAttribute("0")]
public static bool TryHashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.HMACSHA384 : HMAC {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    public Byte[] Key { get; public set; }
    [ObsoleteAttribute("ProduceLegacyHmacValues is obsolete. Producing legacy HMAC values is not supported.")]
public bool ProduceLegacyHmacValues { get; public set; }
    public HMACSHA384(Byte[] key);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public bool get_ProduceLegacyHmacValues();
    public void set_ProduceLegacyHmacValues(bool value);
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    [NullableContextAttribute("0")]
protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    public static Byte[] HashData(Byte[] key, Byte[] source);
    public static Byte[] HashData(Byte[] key, Stream source);
    public static Byte[] HashData(ReadOnlySpan`1<byte> key, Stream source);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, Stream source, Span`1<byte> destination);
    [NullableContextAttribute("0")]
public static Byte[] HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    public static ValueTask`1<Byte[]> HashDataAsync(Byte[] key, Stream source, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static ValueTask`1<int> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static ValueTask`1<Byte[]> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, CancellationToken cancellationToken);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    [NullableContextAttribute("0")]
public static bool TryHashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.HMACSHA512 : HMAC {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    public Byte[] Key { get; public set; }
    [ObsoleteAttribute("ProduceLegacyHmacValues is obsolete. Producing legacy HMAC values is not supported.")]
public bool ProduceLegacyHmacValues { get; public set; }
    public HMACSHA512(Byte[] key);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public bool get_ProduceLegacyHmacValues();
    public void set_ProduceLegacyHmacValues(bool value);
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    [NullableContextAttribute("0")]
protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    public static Byte[] HashData(Byte[] key, Byte[] source);
    public static Byte[] HashData(Byte[] key, Stream source);
    public static Byte[] HashData(ReadOnlySpan`1<byte> key, Stream source);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, Stream source, Span`1<byte> destination);
    [NullableContextAttribute("0")]
public static Byte[] HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    public static ValueTask`1<Byte[]> HashDataAsync(Byte[] key, Stream source, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static ValueTask`1<int> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static ValueTask`1<Byte[]> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, CancellationToken cancellationToken);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    [NullableContextAttribute("0")]
public static bool TryHashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
[NullableContextAttribute("1")]
public interface System.Security.Cryptography.ICryptoTransform {
    public bool CanReuseTransform { get; }
    public bool CanTransformMultipleBlocks { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public abstract virtual bool get_CanReuseTransform();
    public abstract virtual bool get_CanTransformMultipleBlocks();
    public abstract virtual int get_InputBlockSize();
    public abstract virtual int get_OutputBlockSize();
    public abstract virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public abstract virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
}
[NullableContextAttribute("1")]
public interface System.Security.Cryptography.ICspAsymmetricAlgorithm {
    public CspKeyContainerInfo CspKeyContainerInfo { get; }
    public abstract virtual CspKeyContainerInfo get_CspKeyContainerInfo();
    public abstract virtual Byte[] ExportCspBlob(bool includePrivateParameters);
    public abstract virtual void ImportCspBlob(Byte[] rawData);
}
public class System.Security.Cryptography.IncrementalHash : object {
    public HashAlgorithmName AlgorithmName { get; }
    public int HashLengthInBytes { get; }
    public HashAlgorithmName get_AlgorithmName();
    public int get_HashLengthInBytes();
    [NullableContextAttribute("1")]
public void AppendData(Byte[] data);
    [NullableContextAttribute("1")]
public void AppendData(Byte[] data, int offset, int count);
    public void AppendData(ReadOnlySpan`1<byte> data);
    [NullableContextAttribute("1")]
public static IncrementalHash CreateHash(HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public static IncrementalHash CreateHMAC(HashAlgorithmName hashAlgorithm, Byte[] key);
    public static IncrementalHash CreateHMAC(HashAlgorithmName hashAlgorithm, ReadOnlySpan`1<byte> key);
    public sealed virtual void Dispose();
    [NullableContextAttribute("1")]
public Byte[] GetCurrentHash();
    public int GetCurrentHash(Span`1<byte> destination);
    [NullableContextAttribute("1")]
public Byte[] GetHashAndReset();
    public int GetHashAndReset(Span`1<byte> destination);
    public bool TryGetCurrentHash(Span`1<byte> destination, Int32& bytesWritten);
    public bool TryGetHashAndReset(Span`1<byte> destination, Int32& bytesWritten);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.KeyedHashAlgorithm : HashAlgorithm {
    protected Byte[] KeyValue;
    public Byte[] Key { get; public set; }
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    [ObsoleteAttribute("The default implementation of this cryptography algorithm is not supported.")]
public static KeyedHashAlgorithm Create();
    [RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
public static KeyedHashAlgorithm Create(string algName);
    protected virtual void Dispose(bool disposing);
}
public enum System.Security.Cryptography.KeyNumber : Enum {
    public int value__;
    public static KeyNumber Exchange;
    public static KeyNumber Signature;
}
public class System.Security.Cryptography.KeySizes : object {
    public int MaxSize { get; }
    public int MinSize { get; }
    public int SkipSize { get; }
    public KeySizes(int minSize, int maxSize, int skipSize);
    public int get_MaxSize();
    public int get_MinSize();
    public int get_SkipSize();
}
public abstract class System.Security.Cryptography.MaskGenerationMethod : object {
    [NullableContextAttribute("1")]
public abstract virtual Byte[] GenerateMask(Byte[] rgbSeed, int cbReturn);
}
public abstract class System.Security.Cryptography.MD5 : HashAlgorithm {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    [NullableContextAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
public static MD5 Create();
    [NullableContextAttribute("1")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
public static MD5 Create(string algName);
    [NullableContextAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
public static Byte[] HashData(Byte[] source);
    [NullableContextAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
public static Byte[] HashData(Stream source);
    [UnsupportedOSPlatformAttribute("browser")]
public static int HashData(Stream source, Span`1<byte> destination);
    [UnsupportedOSPlatformAttribute("browser")]
public static Byte[] HashData(ReadOnlySpan`1<byte> source);
    [UnsupportedOSPlatformAttribute("browser")]
public static int HashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    [UnsupportedOSPlatformAttribute("browser")]
public static ValueTask`1<int> HashDataAsync(Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
public static ValueTask`1<Byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken);
    [UnsupportedOSPlatformAttribute("browser")]
public static bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
public class System.Security.Cryptography.MD5CryptoServiceProvider : MD5 {
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("1")]
protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Oid : object {
    public string FriendlyName { get; public set; }
    public string Value { get; public set; }
    [NullableContextAttribute("1")]
public Oid(Oid oid);
    [NullableContextAttribute("1")]
public Oid(string oid);
    public Oid(string value, string friendlyName);
    public string get_FriendlyName();
    public void set_FriendlyName(string value);
    public string get_Value();
    public void set_Value(string value);
    [NullableContextAttribute("1")]
public static Oid FromFriendlyName(string friendlyName, OidGroup group);
    [NullableContextAttribute("1")]
public static Oid FromOidValue(string oidValue, OidGroup group);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.OidCollection : object {
    public int Count { get; }
    public bool IsSynchronized { get; }
    public Oid Item { get; }
    [NullableAttribute("2")]
public Oid Item { get; }
    public object SyncRoot { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public Oid get_Item(int index);
    public Oid get_Item(string oid);
    public sealed virtual object get_SyncRoot();
    public int Add(Oid oid);
    public void CopyTo(Oid[] array, int index);
    public OidEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.OidEnumerator : object {
    public Oid Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public Oid get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public enum System.Security.Cryptography.OidGroup : Enum {
    public int value__;
    public static OidGroup All;
    public static OidGroup HashAlgorithm;
    public static OidGroup EncryptionAlgorithm;
    public static OidGroup PublicKeyAlgorithm;
    public static OidGroup SignatureAlgorithm;
    public static OidGroup Attribute;
    public static OidGroup ExtensionOrAttribute;
    public static OidGroup EnhancedKeyUsage;
    public static OidGroup Policy;
    public static OidGroup Template;
    public static OidGroup KeyDerivationFunction;
}
public enum System.Security.Cryptography.PaddingMode : Enum {
    public int value__;
    public static PaddingMode None;
    public static PaddingMode PKCS7;
    public static PaddingMode Zeros;
    public static PaddingMode ANSIX923;
    public static PaddingMode ISO10126;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.PasswordDeriveBytes : DeriveBytes {
    public string HashName { get; public set; }
    public int IterationCount { get; public set; }
    [NullableAttribute("2")]
public Byte[] Salt { get; public set; }
    public PasswordDeriveBytes(Byte[] password, Byte[] salt);
    [NullableContextAttribute("2")]
public PasswordDeriveBytes(Byte[] password, Byte[] salt, CspParameters cspParams);
    [RequiresUnreferencedCodeAttribute("The hash implementation might be removed. Ensure the referenced hash algorithm is not trimmed.")]
public PasswordDeriveBytes(Byte[] password, Byte[] salt, string hashName, int iterations);
    [RequiresUnreferencedCodeAttribute("The hash implementation might be removed. Ensure the referenced hash algorithm is not trimmed.")]
public PasswordDeriveBytes(Byte[] password, Byte[] salt, string hashName, int iterations, CspParameters cspParams);
    public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt);
    [NullableContextAttribute("2")]
public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt, CspParameters cspParams);
    [RequiresUnreferencedCodeAttribute("The hash implementation might be removed. Ensure the referenced hash algorithm is not trimmed.")]
public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt, string strHashName, int iterations);
    [RequiresUnreferencedCodeAttribute("The hash implementation might be removed. Ensure the referenced hash algorithm is not trimmed.")]
public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt, string strHashName, int iterations, CspParameters cspParams);
    public string get_HashName();
    [RequiresUnreferencedCodeAttribute("The hash implementation might be removed. Ensure the referenced hash algorithm is not trimmed.")]
public void set_HashName(string value);
    public int get_IterationCount();
    public void set_IterationCount(int value);
    [NullableContextAttribute("2")]
public Byte[] get_Salt();
    [NullableContextAttribute("2")]
public void set_Salt(Byte[] value);
    [SupportedOSPlatformAttribute("windows")]
public Byte[] CryptDeriveKey(string algname, string alghashname, int keySize, Byte[] rgbIV);
    protected virtual void Dispose(bool disposing);
    [ObsoleteAttribute("Rfc2898DeriveBytes replaces PasswordDeriveBytes for deriving key material from a password and is preferred in new applications.")]
public virtual Byte[] GetBytes(int cb);
    public virtual void Reset();
}
public enum System.Security.Cryptography.PbeEncryptionAlgorithm : Enum {
    public int value__;
    public static PbeEncryptionAlgorithm Unknown;
    public static PbeEncryptionAlgorithm Aes128Cbc;
    public static PbeEncryptionAlgorithm Aes192Cbc;
    public static PbeEncryptionAlgorithm Aes256Cbc;
    public static PbeEncryptionAlgorithm TripleDes3KeyPkcs12;
}
public class System.Security.Cryptography.PbeParameters : object {
    public PbeEncryptionAlgorithm EncryptionAlgorithm { get; }
    public HashAlgorithmName HashAlgorithm { get; }
    public int IterationCount { get; }
    public PbeParameters(PbeEncryptionAlgorithm encryptionAlgorithm, HashAlgorithmName hashAlgorithm, int iterationCount);
    public PbeEncryptionAlgorithm get_EncryptionAlgorithm();
    public HashAlgorithmName get_HashAlgorithm();
    public int get_IterationCount();
}
public static class System.Security.Cryptography.PemEncoding : object {
    public static PemFields Find(ReadOnlySpan`1<char> pemData);
    public static int GetEncodedSize(int labelLength, int dataLength);
    public static bool TryFind(ReadOnlySpan`1<char> pemData, PemFields& fields);
    public static bool TryWrite(ReadOnlySpan`1<char> label, ReadOnlySpan`1<byte> data, Span`1<char> destination, Int32& charsWritten);
    public static Char[] Write(ReadOnlySpan`1<char> label, ReadOnlySpan`1<byte> data);
    public static string WriteString(ReadOnlySpan`1<char> label, ReadOnlySpan`1<byte> data);
}
[IsReadOnlyAttribute]
public class System.Security.Cryptography.PemFields : ValueType {
    private int _dummyPrimitive;
    public Range Base64Data { get; }
    public int DecodedDataLength { get; }
    public Range Label { get; }
    public Range Location { get; }
    public Range get_Base64Data();
    public int get_DecodedDataLength();
    public Range get_Label();
    public Range get_Location();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.PKCS1MaskGenerationMethod : MaskGenerationMethod {
    public string HashName { get; public set; }
    public string get_HashName();
    public void set_HashName(string value);
    public virtual Byte[] GenerateMask(Byte[] rgbSeed, int cbReturn);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.RandomNumberGenerator : object {
    public static RandomNumberGenerator Create();
    [RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
public static RandomNumberGenerator Create(string rngName);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("0")]
public static void Fill(Span`1<byte> data);
    public abstract virtual void GetBytes(Byte[] data);
    public virtual void GetBytes(Byte[] data, int offset, int count);
    public static Byte[] GetBytes(int count);
    [NullableContextAttribute("0")]
public virtual void GetBytes(Span`1<byte> data);
    public static string GetHexString(int stringLength, bool lowercase);
    [NullableContextAttribute("0")]
public static void GetHexString(Span`1<char> destination, bool lowercase);
    public static int GetInt32(int toExclusive);
    public static int GetInt32(int fromInclusive, int toExclusive);
    public static T[] GetItems(ReadOnlySpan`1<T> choices, int length);
    [NullableContextAttribute("2")]
public static void GetItems(ReadOnlySpan`1<T> choices, Span`1<T> destination);
    public virtual void GetNonZeroBytes(Byte[] data);
    [NullableContextAttribute("0")]
public virtual void GetNonZeroBytes(Span`1<byte> data);
    [NullableContextAttribute("0")]
public static string GetString(ReadOnlySpan`1<char> choices, int length);
    [NullableContextAttribute("2")]
public static void Shuffle(Span`1<T> values);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public abstract class System.Security.Cryptography.RC2 : SymmetricAlgorithm {
    protected int EffectiveKeySizeValue;
    public int EffectiveKeySize { get; public set; }
    public int KeySize { get; public set; }
    public virtual int get_EffectiveKeySize();
    public virtual void set_EffectiveKeySize(int value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
public static RC2 Create();
    [RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
public static RC2 Create(string AlgName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
public class System.Security.Cryptography.RC2CryptoServiceProvider : RC2 {
    public int EffectiveKeySize { get; public set; }
    public bool UseSalt { get; public set; }
    public virtual int get_EffectiveKeySize();
    public virtual void set_EffectiveKeySize(int value);
    public bool get_UseSalt();
    [SupportedOSPlatformAttribute("windows")]
public void set_UseSalt(bool value);
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Rfc2898DeriveBytes : DeriveBytes {
    public HashAlgorithmName HashAlgorithm { get; }
    public int IterationCount { get; public set; }
    public Byte[] Salt { get; public set; }
    [ObsoleteAttribute("The default hash algorithm and iteration counts in Rfc2898DeriveBytes constructors are outdated and insecure. Use a constructor that accepts the hash algorithm and the number of iterations.")]
public Rfc2898DeriveBytes(Byte[] password, Byte[] salt, int iterations);
    public Rfc2898DeriveBytes(Byte[] password, Byte[] salt, int iterations, HashAlgorithmName hashAlgorithm);
    [ObsoleteAttribute("The default hash algorithm and iteration counts in Rfc2898DeriveBytes constructors are outdated and insecure. Use a constructor that accepts the hash algorithm and the number of iterations.")]
public Rfc2898DeriveBytes(string password, Byte[] salt);
    [ObsoleteAttribute("The default hash algorithm and iteration counts in Rfc2898DeriveBytes constructors are outdated and insecure. Use a constructor that accepts the hash algorithm and the number of iterations.")]
public Rfc2898DeriveBytes(string password, Byte[] salt, int iterations);
    public Rfc2898DeriveBytes(string password, Byte[] salt, int iterations, HashAlgorithmName hashAlgorithm);
    [ObsoleteAttribute("The default hash algorithm and iteration counts in Rfc2898DeriveBytes constructors are outdated and insecure. Use a constructor that accepts the hash algorithm and the number of iterations.")]
public Rfc2898DeriveBytes(string password, int saltSize);
    [ObsoleteAttribute("The default hash algorithm and iteration counts in Rfc2898DeriveBytes constructors are outdated and insecure. Use a constructor that accepts the hash algorithm and the number of iterations.")]
public Rfc2898DeriveBytes(string password, int saltSize, int iterations);
    public Rfc2898DeriveBytes(string password, int saltSize, int iterations, HashAlgorithmName hashAlgorithm);
    public HashAlgorithmName get_HashAlgorithm();
    public int get_IterationCount();
    public void set_IterationCount(int value);
    public Byte[] get_Salt();
    public void set_Salt(Byte[] value);
    [ObsoleteAttribute("Rfc2898DeriveBytes.CryptDeriveKey is obsolete and is not supported. Use PasswordDeriveBytes.CryptDeriveKey instead.")]
public Byte[] CryptDeriveKey(string algname, string alghashname, int keySize, Byte[] rgbIV);
    protected virtual void Dispose(bool disposing);
    public virtual Byte[] GetBytes(int cb);
    public static Byte[] Pbkdf2(Byte[] password, Byte[] salt, int iterations, HashAlgorithmName hashAlgorithm, int outputLength);
    [NullableContextAttribute("0")]
public static Byte[] Pbkdf2(ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> salt, int iterations, HashAlgorithmName hashAlgorithm, int outputLength);
    [NullableContextAttribute("0")]
public static void Pbkdf2(ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> salt, Span`1<byte> destination, int iterations, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("0")]
public static Byte[] Pbkdf2(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> salt, int iterations, HashAlgorithmName hashAlgorithm, int outputLength);
    [NullableContextAttribute("0")]
public static void Pbkdf2(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> salt, Span`1<byte> destination, int iterations, HashAlgorithmName hashAlgorithm);
    public static Byte[] Pbkdf2(string password, Byte[] salt, int iterations, HashAlgorithmName hashAlgorithm, int outputLength);
    public virtual void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The Rijndael and RijndaelManaged types are obsolete. Use Aes instead.")]
public abstract class System.Security.Cryptography.Rijndael : SymmetricAlgorithm {
    [UnsupportedOSPlatformAttribute("browser")]
public static Rijndael Create();
    [RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
public static Rijndael Create(string algName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The Rijndael and RijndaelManaged types are obsolete. Use Aes instead.")]
[UnsupportedOSPlatformAttribute("browser")]
public class System.Security.Cryptography.RijndaelManaged : Rijndael {
    public int BlockSize { get; public set; }
    public int FeedbackSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    protected virtual void Dispose(bool disposing);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("RNGCryptoServiceProvider is obsolete. To generate a random number, use one of the RandomNumberGenerator static methods instead.")]
public class System.Security.Cryptography.RNGCryptoServiceProvider : RandomNumberGenerator {
    public RNGCryptoServiceProvider(Byte[] rgb);
    [NullableContextAttribute("2")]
public RNGCryptoServiceProvider(CspParameters cspParams);
    public RNGCryptoServiceProvider(string str);
    protected virtual void Dispose(bool disposing);
    public virtual void GetBytes(Byte[] data);
    public virtual void GetBytes(Byte[] data, int offset, int count);
    [NullableContextAttribute("0")]
public virtual void GetBytes(Span`1<byte> data);
    public virtual void GetNonZeroBytes(Byte[] data);
    [NullableContextAttribute("0")]
public virtual void GetNonZeroBytes(Span`1<byte> data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.RSA : AsymmetricAlgorithm {
    [NullableAttribute("2")]
public string KeyExchangeAlgorithm { get; }
    public string SignatureAlgorithm { get; }
    [NullableContextAttribute("2")]
public virtual string get_KeyExchangeAlgorithm();
    public virtual string get_SignatureAlgorithm();
    [UnsupportedOSPlatformAttribute("browser")]
public static RSA Create();
    [UnsupportedOSPlatformAttribute("browser")]
public static RSA Create(int keySizeInBits);
    [UnsupportedOSPlatformAttribute("browser")]
public static RSA Create(RSAParameters parameters);
    [RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
public static RSA Create(string algName);
    public virtual Byte[] Decrypt(Byte[] data, RSAEncryptionPadding padding);
    public Byte[] Decrypt(ReadOnlySpan`1<byte> data, RSAEncryptionPadding padding);
    [NullableContextAttribute("0")]
public int Decrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("RSA.EncryptValue and DecryptValue are not supported and throw NotSupportedException. Use RSA.Encrypt and RSA.Decrypt instead.")]
public virtual Byte[] DecryptValue(Byte[] rgb);
    public virtual Byte[] Encrypt(Byte[] data, RSAEncryptionPadding padding);
    public Byte[] Encrypt(ReadOnlySpan`1<byte> data, RSAEncryptionPadding padding);
    [NullableContextAttribute("0")]
public int Encrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("RSA.EncryptValue and DecryptValue are not supported and throw NotSupportedException. Use RSA.Encrypt and RSA.Decrypt instead.")]
public virtual Byte[] EncryptValue(Byte[] rgb);
    public abstract virtual RSAParameters ExportParameters(bool includePrivateParameters);
    public virtual Byte[] ExportRSAPrivateKey();
    public string ExportRSAPrivateKeyPem();
    public virtual Byte[] ExportRSAPublicKey();
    public string ExportRSAPublicKeyPem();
    public virtual void FromXmlString(string xmlString);
    public int GetMaxOutputSize();
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<byte> passwordBytes);
    [NullableContextAttribute("0")]
public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> password);
    [NullableContextAttribute("0")]
public virtual void ImportFromPem(ReadOnlySpan`1<char> input);
    public abstract virtual void ImportParameters(RSAParameters parameters);
    [NullableContextAttribute("0")]
public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportRSAPrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportRSAPublicKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public Byte[] SignData(ReadOnlySpan`1<byte> data, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    [NullableContextAttribute("0")]
public int SignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual Byte[] SignHash(Byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public Byte[] SignHash(ReadOnlySpan`1<byte> hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    [NullableContextAttribute("0")]
public int SignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual string ToXmlString(bool includePrivateParameters);
    [NullableContextAttribute("0")]
public virtual bool TryDecrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryEncrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryExportRSAPrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public bool TryExportRSAPrivateKeyPem(Span`1<char> destination, Int32& charsWritten);
    [NullableContextAttribute("0")]
public virtual bool TryExportRSAPublicKey(Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public bool TryExportRSAPublicKeyPem(Span`1<char> destination, Int32& charsWritten);
    [NullableContextAttribute("0")]
public virtual bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryHashData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TrySignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, Int32& bytesWritten);
    public bool VerifyData(Byte[] data, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    [NullableContextAttribute("0")]
public virtual bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool VerifyHash(Byte[] hash, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    [NullableContextAttribute("0")]
public virtual bool VerifyHash(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
}
public class System.Security.Cryptography.RSACng : RSA {
    [NullableAttribute("1")]
public CngKey Key { get; }
    [NullableAttribute("1")]
public KeySizes[] LegalKeySizes { get; }
    [SupportedOSPlatformAttribute("windows")]
public RSACng(int keySize);
    [NullableContextAttribute("1")]
[SupportedOSPlatformAttribute("windows")]
public RSACng(CngKey key);
    [NullableContextAttribute("1")]
public CngKey get_Key();
    [NullableContextAttribute("1")]
public virtual KeySizes[] get_LegalKeySizes();
    [NullableContextAttribute("1")]
public virtual Byte[] Decrypt(Byte[] data, RSAEncryptionPadding padding);
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("1")]
public virtual Byte[] Encrypt(Byte[] data, RSAEncryptionPadding padding);
    [NullableContextAttribute("1")]
public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    [NullableContextAttribute("1")]
public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    public virtual RSAParameters ExportParameters(bool includePrivateParameters);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportParameters(RSAParameters parameters);
    public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("1")]
public virtual Byte[] SignHash(Byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool TryDecrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    public virtual bool TryEncrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TrySignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, Int32& bytesWritten);
    [NullableContextAttribute("1")]
public virtual bool VerifyHash(Byte[] hash, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool VerifyHash(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSACryptoServiceProvider : RSA {
    [SupportedOSPlatformAttribute("windows")]
public CspKeyContainerInfo CspKeyContainerInfo { get; }
    [NullableAttribute("2")]
public string KeyExchangeAlgorithm { get; }
    public int KeySize { get; }
    public KeySizes[] LegalKeySizes { get; }
    public bool PersistKeyInCsp { get; public set; }
    public bool PublicOnly { get; }
    public string SignatureAlgorithm { get; }
    public static bool UseMachineKeyStore { get; public set; }
    [UnsupportedOSPlatformAttribute("browser")]
public RSACryptoServiceProvider(int dwKeySize);
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
public RSACryptoServiceProvider(int dwKeySize, CspParameters parameters);
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
public RSACryptoServiceProvider(CspParameters parameters);
    public sealed virtual CspKeyContainerInfo get_CspKeyContainerInfo();
    [NullableContextAttribute("2")]
public virtual string get_KeyExchangeAlgorithm();
    public virtual int get_KeySize();
    public virtual KeySizes[] get_LegalKeySizes();
    public bool get_PersistKeyInCsp();
    public void set_PersistKeyInCsp(bool value);
    public bool get_PublicOnly();
    public virtual string get_SignatureAlgorithm();
    public static bool get_UseMachineKeyStore();
    public static void set_UseMachineKeyStore(bool value);
    public Byte[] Decrypt(Byte[] rgb, bool fOAEP);
    public virtual Byte[] Decrypt(Byte[] data, RSAEncryptionPadding padding);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("RSA.EncryptValue and DecryptValue are not supported and throw NotSupportedException. Use RSA.Encrypt and RSA.Decrypt instead.")]
public virtual Byte[] DecryptValue(Byte[] rgb);
    protected virtual void Dispose(bool disposing);
    public Byte[] Encrypt(Byte[] rgb, bool fOAEP);
    public virtual Byte[] Encrypt(Byte[] data, RSAEncryptionPadding padding);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("RSA.EncryptValue and DecryptValue are not supported and throw NotSupportedException. Use RSA.Encrypt and RSA.Decrypt instead.")]
public virtual Byte[] EncryptValue(Byte[] rgb);
    public sealed virtual Byte[] ExportCspBlob(bool includePrivateParameters);
    public virtual RSAParameters ExportParameters(bool includePrivateParameters);
    public sealed virtual void ImportCspBlob(Byte[] keyBlob);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportParameters(RSAParameters parameters);
    public Byte[] SignData(Byte[] buffer, int offset, int count, object halg);
    public Byte[] SignData(Byte[] buffer, object halg);
    public Byte[] SignData(Stream inputStream, object halg);
    public virtual Byte[] SignHash(Byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public Byte[] SignHash(Byte[] rgbHash, string str);
    public bool VerifyData(Byte[] buffer, object halg, Byte[] signature);
    public virtual bool VerifyHash(Byte[] hash, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public bool VerifyHash(Byte[] rgbHash, string str, Byte[] rgbSignature);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSAEncryptionPadding : object {
    public RSAEncryptionPaddingMode Mode { get; }
    public HashAlgorithmName OaepHashAlgorithm { get; }
    public static RSAEncryptionPadding OaepSHA1 { get; }
    public static RSAEncryptionPadding OaepSHA256 { get; }
    public static RSAEncryptionPadding OaepSHA384 { get; }
    public static RSAEncryptionPadding OaepSHA3_256 { get; }
    public static RSAEncryptionPadding OaepSHA3_384 { get; }
    public static RSAEncryptionPadding OaepSHA3_512 { get; }
    public static RSAEncryptionPadding OaepSHA512 { get; }
    public static RSAEncryptionPadding Pkcs1 { get; }
    public RSAEncryptionPaddingMode get_Mode();
    public HashAlgorithmName get_OaepHashAlgorithm();
    public static RSAEncryptionPadding get_OaepSHA1();
    public static RSAEncryptionPadding get_OaepSHA256();
    public static RSAEncryptionPadding get_OaepSHA384();
    public static RSAEncryptionPadding get_OaepSHA3_256();
    public static RSAEncryptionPadding get_OaepSHA3_384();
    public static RSAEncryptionPadding get_OaepSHA3_512();
    public static RSAEncryptionPadding get_OaepSHA512();
    public static RSAEncryptionPadding get_Pkcs1();
    public static RSAEncryptionPadding CreateOaep(HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(RSAEncryptionPadding other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(RSAEncryptionPadding left, RSAEncryptionPadding right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(RSAEncryptionPadding left, RSAEncryptionPadding right);
    public virtual string ToString();
}
public enum System.Security.Cryptography.RSAEncryptionPaddingMode : Enum {
    public int value__;
    public static RSAEncryptionPaddingMode Pkcs1;
    public static RSAEncryptionPaddingMode Oaep;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter : AsymmetricKeyExchangeDeformatter {
    [NullableAttribute("2")]
public string Parameters { get; public set; }
    public RSAOAEPKeyExchangeDeformatter(AsymmetricAlgorithm key);
    [NullableContextAttribute("2")]
public virtual string get_Parameters();
    [NullableContextAttribute("2")]
public virtual void set_Parameters(string value);
    public virtual Byte[] DecryptKeyExchange(Byte[] rgbData);
    public virtual void SetKey(AsymmetricAlgorithm key);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSAOAEPKeyExchangeFormatter : AsymmetricKeyExchangeFormatter {
    public Byte[] Parameter { get; public set; }
    public string Parameters { get; }
    public RandomNumberGenerator Rng { get; public set; }
    [NullableContextAttribute("1")]
public RSAOAEPKeyExchangeFormatter(AsymmetricAlgorithm key);
    public Byte[] get_Parameter();
    public void set_Parameter(Byte[] value);
    public virtual string get_Parameters();
    public RandomNumberGenerator get_Rng();
    public void set_Rng(RandomNumberGenerator value);
    [NullableContextAttribute("1")]
public virtual Byte[] CreateKeyExchange(Byte[] rgbData);
    [NullableContextAttribute("1")]
public virtual Byte[] CreateKeyExchange(Byte[] rgbData, Type symAlgType);
    [NullableContextAttribute("1")]
public virtual void SetKey(AsymmetricAlgorithm key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSAOpenSsl : RSA {
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public RSAOpenSsl(int keySize);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public RSAOpenSsl(IntPtr handle);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public RSAOpenSsl(RSAParameters parameters);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public RSAOpenSsl(SafeEvpPKeyHandle pkeyHandle);
    public SafeEvpPKeyHandle DuplicateKeyHandle();
    public virtual RSAParameters ExportParameters(bool includePrivateParameters);
    public virtual void ImportParameters(RSAParameters parameters);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSAParameters : ValueType {
    public Byte[] D;
    public Byte[] DP;
    public Byte[] DQ;
    public Byte[] Exponent;
    public Byte[] InverseQ;
    public Byte[] Modulus;
    public Byte[] P;
    public Byte[] Q;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter : AsymmetricKeyExchangeDeformatter {
    public string Parameters { get; public set; }
    public RandomNumberGenerator RNG { get; public set; }
    [NullableContextAttribute("1")]
public RSAPKCS1KeyExchangeDeformatter(AsymmetricAlgorithm key);
    public virtual string get_Parameters();
    public virtual void set_Parameters(string value);
    public RandomNumberGenerator get_RNG();
    public void set_RNG(RandomNumberGenerator value);
    [NullableContextAttribute("1")]
public virtual Byte[] DecryptKeyExchange(Byte[] rgbIn);
    [NullableContextAttribute("1")]
public virtual void SetKey(AsymmetricAlgorithm key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter : AsymmetricKeyExchangeFormatter {
    public string Parameters { get; }
    [NullableAttribute("2")]
public RandomNumberGenerator Rng { get; public set; }
    public RSAPKCS1KeyExchangeFormatter(AsymmetricAlgorithm key);
    public virtual string get_Parameters();
    [NullableContextAttribute("2")]
public RandomNumberGenerator get_Rng();
    [NullableContextAttribute("2")]
public void set_Rng(RandomNumberGenerator value);
    public virtual Byte[] CreateKeyExchange(Byte[] rgbData);
    public virtual Byte[] CreateKeyExchange(Byte[] rgbData, Type symAlgType);
    public virtual void SetKey(AsymmetricAlgorithm key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public class System.Security.Cryptography.RSAPKCS1SignatureDeformatter : AsymmetricSignatureDeformatter {
    public RSAPKCS1SignatureDeformatter(AsymmetricAlgorithm key);
    public virtual void SetHashAlgorithm(string strName);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public class System.Security.Cryptography.RSAPKCS1SignatureFormatter : AsymmetricSignatureFormatter {
    public RSAPKCS1SignatureFormatter(AsymmetricAlgorithm key);
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
    public virtual void SetHashAlgorithm(string strName);
    public virtual void SetKey(AsymmetricAlgorithm key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSASignaturePadding : object {
    public RSASignaturePaddingMode Mode { get; }
    public static RSASignaturePadding Pkcs1 { get; }
    public static RSASignaturePadding Pss { get; }
    public RSASignaturePaddingMode get_Mode();
    public static RSASignaturePadding get_Pkcs1();
    public static RSASignaturePadding get_Pss();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(RSASignaturePadding other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(RSASignaturePadding left, RSASignaturePadding right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(RSASignaturePadding left, RSASignaturePadding right);
    public virtual string ToString();
}
public enum System.Security.Cryptography.RSASignaturePaddingMode : Enum {
    public int value__;
    public static RSASignaturePaddingMode Pkcs1;
    public static RSASignaturePaddingMode Pss;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.SafeEvpPKeyHandle : SafeHandle {
    public bool IsInvalid { get; }
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public static long OpenSslVersion { get; }
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public SafeEvpPKeyHandle(IntPtr handle, bool ownsHandle);
    public virtual bool get_IsInvalid();
    public static long get_OpenSslVersion();
    public SafeEvpPKeyHandle DuplicateHandle();
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public static SafeEvpPKeyHandle OpenPrivateKeyFromEngine(string engineName, string keyId);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public static SafeEvpPKeyHandle OpenPublicKeyFromEngine(string engineName, string keyId);
    protected virtual bool ReleaseHandle();
}
public abstract class System.Security.Cryptography.SHA1 : HashAlgorithm {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    [NullableContextAttribute("1")]
public static SHA1 Create();
    [NullableContextAttribute("1")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
public static SHA1 Create(string hashName);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Byte[] source);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Stream source);
    public static int HashData(Stream source, Span`1<byte> destination);
    public static Byte[] HashData(ReadOnlySpan`1<byte> source);
    public static int HashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    public static ValueTask`1<int> HashDataAsync(Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public static ValueTask`1<Byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken);
    public static bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
public class System.Security.Cryptography.SHA1CryptoServiceProvider : SHA1 {
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("1")]
protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
public class System.Security.Cryptography.SHA1Managed : SHA1 {
    protected sealed virtual void Dispose(bool disposing);
    [NullableContextAttribute("1")]
protected sealed virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected sealed virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
protected sealed virtual Byte[] HashFinal();
    public sealed virtual void Initialize();
    protected sealed virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
public abstract class System.Security.Cryptography.SHA256 : HashAlgorithm {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    [NullableContextAttribute("1")]
public static SHA256 Create();
    [NullableContextAttribute("1")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
public static SHA256 Create(string hashName);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Byte[] source);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Stream source);
    public static int HashData(Stream source, Span`1<byte> destination);
    public static Byte[] HashData(ReadOnlySpan`1<byte> source);
    public static int HashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    public static ValueTask`1<int> HashDataAsync(Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public static ValueTask`1<Byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken);
    public static bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
public class System.Security.Cryptography.SHA256CryptoServiceProvider : SHA256 {
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("1")]
protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
public class System.Security.Cryptography.SHA256Managed : SHA256 {
    protected sealed virtual void Dispose(bool disposing);
    [NullableContextAttribute("1")]
protected sealed virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected sealed virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
protected sealed virtual Byte[] HashFinal();
    public sealed virtual void Initialize();
    protected sealed virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
public abstract class System.Security.Cryptography.SHA3_256 : HashAlgorithm {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    [NullableContextAttribute("1")]
public static SHA3_256 Create();
    [NullableContextAttribute("1")]
public static Byte[] HashData(Byte[] source);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Stream source);
    public static int HashData(Stream source, Span`1<byte> destination);
    public static Byte[] HashData(ReadOnlySpan`1<byte> source);
    public static int HashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    public static ValueTask`1<int> HashDataAsync(Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public static ValueTask`1<Byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken);
    public static bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
}
public abstract class System.Security.Cryptography.SHA3_384 : HashAlgorithm {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    [NullableContextAttribute("1")]
public static SHA3_384 Create();
    [NullableContextAttribute("1")]
public static Byte[] HashData(Byte[] source);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Stream source);
    public static int HashData(Stream source, Span`1<byte> destination);
    public static Byte[] HashData(ReadOnlySpan`1<byte> source);
    public static int HashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    public static ValueTask`1<int> HashDataAsync(Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public static ValueTask`1<Byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken);
    public static bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
}
public abstract class System.Security.Cryptography.SHA3_512 : HashAlgorithm {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    [NullableContextAttribute("1")]
public static SHA3_512 Create();
    [NullableContextAttribute("1")]
public static Byte[] HashData(Byte[] source);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Stream source);
    public static int HashData(Stream source, Span`1<byte> destination);
    public static Byte[] HashData(ReadOnlySpan`1<byte> source);
    public static int HashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    public static ValueTask`1<int> HashDataAsync(Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public static ValueTask`1<Byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken);
    public static bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
}
public abstract class System.Security.Cryptography.SHA384 : HashAlgorithm {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    [NullableContextAttribute("1")]
public static SHA384 Create();
    [NullableContextAttribute("1")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
public static SHA384 Create(string hashName);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Byte[] source);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Stream source);
    public static int HashData(Stream source, Span`1<byte> destination);
    public static Byte[] HashData(ReadOnlySpan`1<byte> source);
    public static int HashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    public static ValueTask`1<int> HashDataAsync(Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public static ValueTask`1<Byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken);
    public static bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
public class System.Security.Cryptography.SHA384CryptoServiceProvider : SHA384 {
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("1")]
protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
public class System.Security.Cryptography.SHA384Managed : SHA384 {
    protected sealed virtual void Dispose(bool disposing);
    [NullableContextAttribute("1")]
protected sealed virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected sealed virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
protected sealed virtual Byte[] HashFinal();
    public sealed virtual void Initialize();
    protected sealed virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
public abstract class System.Security.Cryptography.SHA512 : HashAlgorithm {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    [NullableContextAttribute("1")]
public static SHA512 Create();
    [NullableContextAttribute("1")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
public static SHA512 Create(string hashName);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Byte[] source);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Stream source);
    public static int HashData(Stream source, Span`1<byte> destination);
    public static Byte[] HashData(ReadOnlySpan`1<byte> source);
    public static int HashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    public static ValueTask`1<int> HashDataAsync(Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public static ValueTask`1<Byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken);
    public static bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
public class System.Security.Cryptography.SHA512CryptoServiceProvider : SHA512 {
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("1")]
protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
public class System.Security.Cryptography.SHA512Managed : SHA512 {
    protected sealed virtual void Dispose(bool disposing);
    [NullableContextAttribute("1")]
protected sealed virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected sealed virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
protected sealed virtual Byte[] HashFinal();
    public sealed virtual void Initialize();
    protected sealed virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
public class System.Security.Cryptography.Shake128 : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    [NullableContextAttribute("1")]
public void AppendData(Byte[] data);
    public void AppendData(ReadOnlySpan`1<byte> data);
    public sealed virtual void Dispose();
    [NullableContextAttribute("1")]
public Byte[] GetCurrentHash(int outputLength);
    public void GetCurrentHash(Span`1<byte> destination);
    [NullableContextAttribute("1")]
public Byte[] GetHashAndReset(int outputLength);
    public void GetHashAndReset(Span`1<byte> destination);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Byte[] source, int outputLength);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Stream source, int outputLength);
    public static void HashData(Stream source, Span`1<byte> destination);
    public static Byte[] HashData(ReadOnlySpan`1<byte> source, int outputLength);
    public static void HashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    [NullableContextAttribute("1")]
public static ValueTask`1<Byte[]> HashDataAsync(Stream source, int outputLength, CancellationToken cancellationToken);
    public static ValueTask HashDataAsync(Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
}
public class System.Security.Cryptography.Shake256 : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    [NullableContextAttribute("1")]
public void AppendData(Byte[] data);
    public void AppendData(ReadOnlySpan`1<byte> data);
    public sealed virtual void Dispose();
    [NullableContextAttribute("1")]
public Byte[] GetCurrentHash(int outputLength);
    public void GetCurrentHash(Span`1<byte> destination);
    [NullableContextAttribute("1")]
public Byte[] GetHashAndReset(int outputLength);
    public void GetHashAndReset(Span`1<byte> destination);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Byte[] source, int outputLength);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Stream source, int outputLength);
    public static void HashData(Stream source, Span`1<byte> destination);
    public static Byte[] HashData(ReadOnlySpan`1<byte> source, int outputLength);
    public static void HashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    [NullableContextAttribute("1")]
public static ValueTask`1<Byte[]> HashDataAsync(Stream source, int outputLength, CancellationToken cancellationToken);
    public static ValueTask HashDataAsync(Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.SignatureDescription : object {
    public string DeformatterAlgorithm { get; public set; }
    public string DigestAlgorithm { get; public set; }
    public string FormatterAlgorithm { get; public set; }
    public string KeyAlgorithm { get; public set; }
    [NullableContextAttribute("1")]
public SignatureDescription(SecurityElement el);
    public string get_DeformatterAlgorithm();
    public void set_DeformatterAlgorithm(string value);
    public string get_DigestAlgorithm();
    public void set_DigestAlgorithm(string value);
    public string get_FormatterAlgorithm();
    public void set_FormatterAlgorithm(string value);
    public string get_KeyAlgorithm();
    public void set_KeyAlgorithm(string value);
    [NullableContextAttribute("1")]
[RequiresUnreferencedCodeAttribute("CreateDeformatter is not trim compatible because the algorithm implementation referenced by DeformatterAlgorithm might be removed.")]
public virtual AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgorithm key);
    [RequiresUnreferencedCodeAttribute("CreateDigest is not trim compatible because the algorithm implementation referenced by DigestAlgorithm might be removed.")]
public virtual HashAlgorithm CreateDigest();
    [NullableContextAttribute("1")]
[RequiresUnreferencedCodeAttribute("CreateFormatter is not trim compatible because the algorithm implementation referenced by FormatterAlgorithm might be removed.")]
public virtual AsymmetricSignatureFormatter CreateFormatter(AsymmetricAlgorithm key);
}
public class System.Security.Cryptography.SP800108HmacCounterKdf : object {
    [NullableContextAttribute("1")]
public SP800108HmacCounterKdf(Byte[] key, HashAlgorithmName hashAlgorithm);
    public SP800108HmacCounterKdf(ReadOnlySpan`1<byte> key, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public static Byte[] DeriveBytes(Byte[] key, HashAlgorithmName hashAlgorithm, Byte[] label, Byte[] context, int derivedKeyLengthInBytes);
    [NullableContextAttribute("1")]
public static Byte[] DeriveBytes(Byte[] key, HashAlgorithmName hashAlgorithm, string label, string context, int derivedKeyLengthInBytes);
    public static Byte[] DeriveBytes(ReadOnlySpan`1<byte> key, HashAlgorithmName hashAlgorithm, ReadOnlySpan`1<byte> label, ReadOnlySpan`1<byte> context, int derivedKeyLengthInBytes);
    public static void DeriveBytes(ReadOnlySpan`1<byte> key, HashAlgorithmName hashAlgorithm, ReadOnlySpan`1<byte> label, ReadOnlySpan`1<byte> context, Span`1<byte> destination);
    public static Byte[] DeriveBytes(ReadOnlySpan`1<byte> key, HashAlgorithmName hashAlgorithm, ReadOnlySpan`1<char> label, ReadOnlySpan`1<char> context, int derivedKeyLengthInBytes);
    public static void DeriveBytes(ReadOnlySpan`1<byte> key, HashAlgorithmName hashAlgorithm, ReadOnlySpan`1<char> label, ReadOnlySpan`1<char> context, Span`1<byte> destination);
    [NullableContextAttribute("1")]
public Byte[] DeriveKey(Byte[] label, Byte[] context, int derivedKeyLengthInBytes);
    public Byte[] DeriveKey(ReadOnlySpan`1<byte> label, ReadOnlySpan`1<byte> context, int derivedKeyLengthInBytes);
    public void DeriveKey(ReadOnlySpan`1<byte> label, ReadOnlySpan`1<byte> context, Span`1<byte> destination);
    public Byte[] DeriveKey(ReadOnlySpan`1<char> label, ReadOnlySpan`1<char> context, int derivedKeyLengthInBytes);
    public void DeriveKey(ReadOnlySpan`1<char> label, ReadOnlySpan`1<char> context, Span`1<byte> destination);
    [NullableContextAttribute("1")]
public Byte[] DeriveKey(string label, string context, int derivedKeyLengthInBytes);
    public sealed virtual void Dispose();
}
public abstract class System.Security.Cryptography.SymmetricAlgorithm : object {
    protected int BlockSizeValue;
    protected int FeedbackSizeValue;
    [NullableAttribute("2")]
protected Byte[] IVValue;
    protected int KeySizeValue;
    [NullableAttribute("2")]
protected Byte[] KeyValue;
    [NullableAttribute("1")]
[MaybeNullAttribute]
protected KeySizes[] LegalBlockSizesValue;
    [NullableAttribute("1")]
[MaybeNullAttribute]
protected KeySizes[] LegalKeySizesValue;
    protected CipherMode ModeValue;
    protected PaddingMode PaddingValue;
    public int BlockSize { get; public set; }
    public int FeedbackSize { get; public set; }
    [NullableAttribute("1")]
public Byte[] IV { get; public set; }
    [NullableAttribute("1")]
public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    [NullableAttribute("1")]
public KeySizes[] LegalBlockSizes { get; }
    [NullableAttribute("1")]
public KeySizes[] LegalKeySizes { get; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    [NullableContextAttribute("1")]
public virtual Byte[] get_IV();
    [NullableContextAttribute("1")]
public virtual void set_IV(Byte[] value);
    [NullableContextAttribute("1")]
public virtual Byte[] get_Key();
    [NullableContextAttribute("1")]
public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    [NullableContextAttribute("1")]
public virtual KeySizes[] get_LegalBlockSizes();
    [NullableContextAttribute("1")]
public virtual KeySizes[] get_LegalKeySizes();
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public void Clear();
    [NullableContextAttribute("1")]
[ObsoleteAttribute("The default implementation of this cryptography algorithm is not supported.")]
public static SymmetricAlgorithm Create();
    [NullableContextAttribute("1")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
public static SymmetricAlgorithm Create(string algName);
    [NullableContextAttribute("1")]
public virtual ICryptoTransform CreateDecryptor();
    [NullableContextAttribute("1")]
public abstract virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    [NullableContextAttribute("1")]
public virtual ICryptoTransform CreateEncryptor();
    [NullableContextAttribute("1")]
public abstract virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    [NullableContextAttribute("1")]
public Byte[] DecryptCbc(Byte[] ciphertext, Byte[] iv, PaddingMode paddingMode);
    public Byte[] DecryptCbc(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, PaddingMode paddingMode);
    public int DecryptCbc(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode);
    [NullableContextAttribute("1")]
public Byte[] DecryptCfb(Byte[] ciphertext, Byte[] iv, PaddingMode paddingMode, int feedbackSizeInBits);
    public Byte[] DecryptCfb(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, PaddingMode paddingMode, int feedbackSizeInBits);
    public int DecryptCfb(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits);
    [NullableContextAttribute("1")]
public Byte[] DecryptEcb(Byte[] ciphertext, PaddingMode paddingMode);
    public Byte[] DecryptEcb(ReadOnlySpan`1<byte> ciphertext, PaddingMode paddingMode);
    public int DecryptEcb(ReadOnlySpan`1<byte> ciphertext, Span`1<byte> destination, PaddingMode paddingMode);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("1")]
public Byte[] EncryptCbc(Byte[] plaintext, Byte[] iv, PaddingMode paddingMode);
    public Byte[] EncryptCbc(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, PaddingMode paddingMode);
    public int EncryptCbc(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode);
    [NullableContextAttribute("1")]
public Byte[] EncryptCfb(Byte[] plaintext, Byte[] iv, PaddingMode paddingMode, int feedbackSizeInBits);
    public Byte[] EncryptCfb(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, PaddingMode paddingMode, int feedbackSizeInBits);
    public int EncryptCfb(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits);
    [NullableContextAttribute("1")]
public Byte[] EncryptEcb(Byte[] plaintext, PaddingMode paddingMode);
    public Byte[] EncryptEcb(ReadOnlySpan`1<byte> plaintext, PaddingMode paddingMode);
    public int EncryptEcb(ReadOnlySpan`1<byte> plaintext, Span`1<byte> destination, PaddingMode paddingMode);
    public abstract virtual void GenerateIV();
    public abstract virtual void GenerateKey();
    public int GetCiphertextLengthCbc(int plaintextLength, PaddingMode paddingMode);
    public int GetCiphertextLengthCfb(int plaintextLength, PaddingMode paddingMode, int feedbackSizeInBits);
    public int GetCiphertextLengthEcb(int plaintextLength, PaddingMode paddingMode);
    public bool TryDecryptCbc(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, Int32& bytesWritten, PaddingMode paddingMode);
    protected virtual bool TryDecryptCbcCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    public bool TryDecryptCfb(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, Int32& bytesWritten, PaddingMode paddingMode, int feedbackSizeInBits);
    protected virtual bool TryDecryptCfbCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    public bool TryDecryptEcb(ReadOnlySpan`1<byte> ciphertext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryDecryptEcbCore(ReadOnlySpan`1<byte> ciphertext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    public bool TryEncryptCbc(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, Int32& bytesWritten, PaddingMode paddingMode);
    protected virtual bool TryEncryptCbcCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    public bool TryEncryptCfb(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, Int32& bytesWritten, PaddingMode paddingMode, int feedbackSizeInBits);
    protected virtual bool TryEncryptCfbCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    public bool TryEncryptEcb(ReadOnlySpan`1<byte> plaintext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryEncryptEcbCore(ReadOnlySpan`1<byte> plaintext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    public bool ValidKeySize(int bitLength);
}
public class System.Security.Cryptography.ToBase64Transform : object {
    public bool CanReuseTransform { get; }
    public bool CanTransformMultipleBlocks { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public virtual bool get_CanReuseTransform();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    public void Clear();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    [NullableContextAttribute("1")]
public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    [NullableContextAttribute("1")]
public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.TripleDES : SymmetricAlgorithm {
    public Byte[] Key { get; public set; }
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    [UnsupportedOSPlatformAttribute("browser")]
public static TripleDES Create();
    [RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
public static TripleDES Create(string str);
    public static bool IsWeakKey(Byte[] rgbKey);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.TripleDESCng : TripleDES {
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    [SupportedOSPlatformAttribute("windows")]
public TripleDESCng(string keyName);
    [SupportedOSPlatformAttribute("windows")]
public TripleDESCng(string keyName, CngProvider provider);
    [SupportedOSPlatformAttribute("windows")]
public TripleDESCng(string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    protected virtual void Dispose(bool disposing);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
    [NullableContextAttribute("0")]
protected virtual bool TryDecryptCbcCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryDecryptCfbCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryDecryptEcbCore(ReadOnlySpan`1<byte> ciphertext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryEncryptCbcCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryEncryptCfbCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryEncryptEcbCore(ReadOnlySpan`1<byte> plaintext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
public class System.Security.Cryptography.TripleDESCryptoServiceProvider : TripleDES {
    public int BlockSize { get; public set; }
    public int FeedbackSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public KeySizes[] LegalBlockSizes { get; }
    public KeySizes[] LegalKeySizes { get; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual KeySizes[] get_LegalBlockSizes();
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    protected virtual void Dispose(bool disposing);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public class System.Security.Cryptography.X509Certificates.CertificateRequest : object {
    public Collection`1<X509Extension> CertificateExtensions { get; }
    public HashAlgorithmName HashAlgorithm { get; }
    public Collection`1<AsnEncodedData> OtherRequestAttributes { get; }
    public PublicKey PublicKey { get; }
    public X500DistinguishedName SubjectName { get; }
    public CertificateRequest(X500DistinguishedName subjectName, ECDsa key, HashAlgorithmName hashAlgorithm);
    public CertificateRequest(X500DistinguishedName subjectName, RSA key, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public CertificateRequest(X500DistinguishedName subjectName, PublicKey publicKey, HashAlgorithmName hashAlgorithm);
    public CertificateRequest(X500DistinguishedName subjectName, PublicKey publicKey, HashAlgorithmName hashAlgorithm, RSASignaturePadding rsaSignaturePadding);
    public CertificateRequest(string subjectName, ECDsa key, HashAlgorithmName hashAlgorithm);
    public CertificateRequest(string subjectName, RSA key, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public Collection`1<X509Extension> get_CertificateExtensions();
    public HashAlgorithmName get_HashAlgorithm();
    public Collection`1<AsnEncodedData> get_OtherRequestAttributes();
    public PublicKey get_PublicKey();
    public X500DistinguishedName get_SubjectName();
    public X509Certificate2 Create(X500DistinguishedName issuerName, X509SignatureGenerator generator, DateTimeOffset notBefore, DateTimeOffset notAfter, Byte[] serialNumber);
    public X509Certificate2 Create(X500DistinguishedName issuerName, X509SignatureGenerator generator, DateTimeOffset notBefore, DateTimeOffset notAfter, ReadOnlySpan`1<byte> serialNumber);
    public X509Certificate2 Create(X509Certificate2 issuerCertificate, DateTimeOffset notBefore, DateTimeOffset notAfter, Byte[] serialNumber);
    public X509Certificate2 Create(X509Certificate2 issuerCertificate, DateTimeOffset notBefore, DateTimeOffset notAfter, ReadOnlySpan`1<byte> serialNumber);
    public X509Certificate2 CreateSelfSigned(DateTimeOffset notBefore, DateTimeOffset notAfter);
    public Byte[] CreateSigningRequest();
    public Byte[] CreateSigningRequest(X509SignatureGenerator signatureGenerator);
    public string CreateSigningRequestPem();
    public string CreateSigningRequestPem(X509SignatureGenerator signatureGenerator);
    public static CertificateRequest LoadSigningRequest(Byte[] pkcs10, HashAlgorithmName signerHashAlgorithm, CertificateRequestLoadOptions options, RSASignaturePadding signerSignaturePadding);
    [NullableContextAttribute("0")]
public static CertificateRequest LoadSigningRequest(ReadOnlySpan`1<byte> pkcs10, HashAlgorithmName signerHashAlgorithm, Int32& bytesConsumed, CertificateRequestLoadOptions options, RSASignaturePadding signerSignaturePadding);
    [NullableContextAttribute("0")]
public static CertificateRequest LoadSigningRequestPem(ReadOnlySpan`1<char> pkcs10Pem, HashAlgorithmName signerHashAlgorithm, CertificateRequestLoadOptions options, RSASignaturePadding signerSignaturePadding);
    public static CertificateRequest LoadSigningRequestPem(string pkcs10Pem, HashAlgorithmName signerHashAlgorithm, CertificateRequestLoadOptions options, RSASignaturePadding signerSignaturePadding);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.CertificateRequestLoadOptions : Enum {
    public int value__;
    public static CertificateRequestLoadOptions Default;
    public static CertificateRequestLoadOptions SkipSignatureValidation;
    public static CertificateRequestLoadOptions UnsafeLoadCertificateExtensions;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.CertificateRevocationListBuilder : object {
    public void AddEntry(Byte[] serialNumber, Nullable`1<DateTimeOffset> revocationTime, Nullable`1<X509RevocationReason> reason);
    [NullableContextAttribute("0")]
public void AddEntry(ReadOnlySpan`1<byte> serialNumber, Nullable`1<DateTimeOffset> revocationTime, Nullable`1<X509RevocationReason> reason);
    public void AddEntry(X509Certificate2 certificate, Nullable`1<DateTimeOffset> revocationTime, Nullable`1<X509RevocationReason> reason);
    public Byte[] Build(X500DistinguishedName issuerName, X509SignatureGenerator generator, BigInteger crlNumber, DateTimeOffset nextUpdate, HashAlgorithmName hashAlgorithm, X509AuthorityKeyIdentifierExtension authorityKeyIdentifier, Nullable`1<DateTimeOffset> thisUpdate);
    public Byte[] Build(X509Certificate2 issuerCertificate, BigInteger crlNumber, DateTimeOffset nextUpdate, HashAlgorithmName hashAlgorithm, RSASignaturePadding rsaSignaturePadding, Nullable`1<DateTimeOffset> thisUpdate);
    public static X509Extension BuildCrlDistributionPointExtension(IEnumerable`1<string> uris, bool critical);
    public static CertificateRevocationListBuilder Load(Byte[] currentCrl, BigInteger& currentCrlNumber);
    [NullableContextAttribute("0")]
public static CertificateRevocationListBuilder Load(ReadOnlySpan`1<byte> currentCrl, BigInteger& currentCrlNumber, Int32& bytesConsumed);
    [NullableContextAttribute("0")]
public static CertificateRevocationListBuilder LoadPem(ReadOnlySpan`1<char> currentCrl, BigInteger& currentCrlNumber);
    public static CertificateRevocationListBuilder LoadPem(string currentCrl, BigInteger& currentCrlNumber);
    public bool RemoveEntry(Byte[] serialNumber);
    [NullableContextAttribute("0")]
public bool RemoveEntry(ReadOnlySpan`1<byte> serialNumber);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public static class System.Security.Cryptography.X509Certificates.DSACertificateExtensions : object {
    [ExtensionAttribute]
public static X509Certificate2 CopyWithPrivateKey(X509Certificate2 certificate, DSA privateKey);
    [ExtensionAttribute]
public static DSA GetDSAPrivateKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static DSA GetDSAPublicKey(X509Certificate2 certificate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Security.Cryptography.X509Certificates.ECDsaCertificateExtensions : object {
    [ExtensionAttribute]
public static X509Certificate2 CopyWithPrivateKey(X509Certificate2 certificate, ECDsa privateKey);
    [ExtensionAttribute]
public static ECDsa GetECDsaPrivateKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static ECDsa GetECDsaPublicKey(X509Certificate2 certificate);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.OpenFlags : Enum {
    public int value__;
    public static OpenFlags ReadOnly;
    public static OpenFlags ReadWrite;
    public static OpenFlags MaxAllowed;
    public static OpenFlags OpenExistingOnly;
    public static OpenFlags IncludeArchived;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.PublicKey : object {
    public AsnEncodedData EncodedKeyValue { get; }
    public AsnEncodedData EncodedParameters { get; }
    [ObsoleteAttribute("PublicKey.Key is obsolete. Use the appropriate method to get the public key, such as GetRSAPublicKey.")]
public AsymmetricAlgorithm Key { get; }
    public Oid Oid { get; }
    public PublicKey(AsymmetricAlgorithm key);
    public PublicKey(Oid oid, AsnEncodedData parameters, AsnEncodedData keyValue);
    public AsnEncodedData get_EncodedKeyValue();
    public AsnEncodedData get_EncodedParameters();
    public AsymmetricAlgorithm get_Key();
    public Oid get_Oid();
    [NullableContextAttribute("0")]
public static PublicKey CreateFromSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public Byte[] ExportSubjectPublicKeyInfo();
    [NullableContextAttribute("2")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public DSA GetDSAPublicKey();
    [NullableContextAttribute("2")]
[UnsupportedOSPlatformAttribute("browser")]
public ECDiffieHellman GetECDiffieHellmanPublicKey();
    [NullableContextAttribute("2")]
[UnsupportedOSPlatformAttribute("browser")]
public ECDsa GetECDsaPublicKey();
    [NullableContextAttribute("2")]
[UnsupportedOSPlatformAttribute("browser")]
public RSA GetRSAPublicKey();
    [NullableContextAttribute("0")]
public bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Security.Cryptography.X509Certificates.RSACertificateExtensions : object {
    [ExtensionAttribute]
public static X509Certificate2 CopyWithPrivateKey(X509Certificate2 certificate, RSA privateKey);
    [ExtensionAttribute]
public static RSA GetRSAPrivateKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static RSA GetRSAPublicKey(X509Certificate2 certificate);
}
public enum System.Security.Cryptography.X509Certificates.StoreLocation : Enum {
    public int value__;
    public static StoreLocation CurrentUser;
    public static StoreLocation LocalMachine;
}
public enum System.Security.Cryptography.X509Certificates.StoreName : Enum {
    public int value__;
    public static StoreName AddressBook;
    public static StoreName AuthRoot;
    public static StoreName CertificateAuthority;
    public static StoreName Disallowed;
    public static StoreName My;
    public static StoreName Root;
    public static StoreName TrustedPeople;
    public static StoreName TrustedPublisher;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.SubjectAlternativeNameBuilder : object {
    public void AddDnsName(string dnsName);
    public void AddEmailAddress(string emailAddress);
    public void AddIpAddress(IPAddress ipAddress);
    public void AddUri(Uri uri);
    public void AddUserPrincipalName(string upn);
    public X509Extension Build(bool critical);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X500DistinguishedName : AsnEncodedData {
    public string Name { get; }
    public X500DistinguishedName(Byte[] encodedDistinguishedName);
    [NullableContextAttribute("0")]
public X500DistinguishedName(ReadOnlySpan`1<byte> encodedDistinguishedName);
    public X500DistinguishedName(AsnEncodedData encodedDistinguishedName);
    public X500DistinguishedName(X500DistinguishedName distinguishedName);
    public X500DistinguishedName(string distinguishedName);
    public X500DistinguishedName(string distinguishedName, X500DistinguishedNameFlags flag);
    public string get_Name();
    public string Decode(X500DistinguishedNameFlags flag);
    public IEnumerable`1<X500RelativeDistinguishedName> EnumerateRelativeDistinguishedNames(bool reversed);
    public virtual string Format(bool multiLine);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X500DistinguishedNameBuilder : object {
    public void Add(Oid oid, string value, Nullable`1<UniversalTagNumber> stringEncodingType);
    public void Add(string oidValue, string value, Nullable`1<UniversalTagNumber> stringEncodingType);
    public void AddCommonName(string commonName);
    public void AddCountryOrRegion(string twoLetterCode);
    public void AddDomainComponent(string domainComponent);
    public void AddEmailAddress(string emailAddress);
    public void AddLocalityName(string localityName);
    public void AddOrganizationalUnitName(string organizationalUnitName);
    public void AddOrganizationName(string organizationName);
    public void AddStateOrProvinceName(string stateOrProvinceName);
    public X500DistinguishedName Build();
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags : Enum {
    public int value__;
    public static X500DistinguishedNameFlags None;
    public static X500DistinguishedNameFlags Reversed;
    public static X500DistinguishedNameFlags UseSemicolons;
    public static X500DistinguishedNameFlags DoNotUsePlusSign;
    public static X500DistinguishedNameFlags DoNotUseQuotes;
    public static X500DistinguishedNameFlags UseCommas;
    public static X500DistinguishedNameFlags UseNewLines;
    public static X500DistinguishedNameFlags UseUTF8Encoding;
    public static X500DistinguishedNameFlags UseT61Encoding;
    public static X500DistinguishedNameFlags ForceUTF8Encoding;
}
public class System.Security.Cryptography.X509Certificates.X500RelativeDistinguishedName : object {
    public bool HasMultipleElements { get; }
    public ReadOnlyMemory`1<byte> RawData { get; }
    public bool get_HasMultipleElements();
    public ReadOnlyMemory`1<byte> get_RawData();
    [NullableContextAttribute("1")]
public Oid GetSingleElementType();
    [NullableContextAttribute("2")]
public string GetSingleElementValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509AuthorityInformationAccessExtension : X509Extension {
    public X509AuthorityInformationAccessExtension(Byte[] rawData, bool critical);
    public X509AuthorityInformationAccessExtension(IEnumerable`1<string> ocspUris, IEnumerable`1<string> caIssuersUris, bool critical);
    [NullableContextAttribute("0")]
public X509AuthorityInformationAccessExtension(ReadOnlySpan`1<byte> rawData, bool critical);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    public IEnumerable`1<string> EnumerateCAIssuersUris();
    public IEnumerable`1<string> EnumerateOcspUris();
    public IEnumerable`1<string> EnumerateUris(Oid accessMethodOid);
    public IEnumerable`1<string> EnumerateUris(string accessMethodOid);
}
public class System.Security.Cryptography.X509Certificates.X509AuthorityKeyIdentifierExtension : X509Extension {
    public Nullable`1<ReadOnlyMemory`1<byte>> KeyIdentifier { get; }
    [NullableAttribute("2")]
public X500DistinguishedName NamedIssuer { get; }
    public Nullable`1<ReadOnlyMemory`1<byte>> RawIssuer { get; }
    public Nullable`1<ReadOnlyMemory`1<byte>> SerialNumber { get; }
    [NullableContextAttribute("1")]
public X509AuthorityKeyIdentifierExtension(Byte[] rawData, bool critical);
    public X509AuthorityKeyIdentifierExtension(ReadOnlySpan`1<byte> rawData, bool critical);
    public Nullable`1<ReadOnlyMemory`1<byte>> get_KeyIdentifier();
    [NullableContextAttribute("2")]
public X500DistinguishedName get_NamedIssuer();
    public Nullable`1<ReadOnlyMemory`1<byte>> get_RawIssuer();
    public Nullable`1<ReadOnlyMemory`1<byte>> get_SerialNumber();
    [NullableContextAttribute("1")]
public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    [NullableContextAttribute("1")]
public static X509AuthorityKeyIdentifierExtension Create(Byte[] keyIdentifier, X500DistinguishedName issuerName, Byte[] serialNumber);
    public static X509AuthorityKeyIdentifierExtension Create(ReadOnlySpan`1<byte> keyIdentifier, X500DistinguishedName issuerName, ReadOnlySpan`1<byte> serialNumber);
    [NullableContextAttribute("1")]
public static X509AuthorityKeyIdentifierExtension CreateFromCertificate(X509Certificate2 certificate, bool includeKeyIdentifier, bool includeIssuerAndSerial);
    [NullableContextAttribute("1")]
public static X509AuthorityKeyIdentifierExtension CreateFromIssuerNameAndSerialNumber(X500DistinguishedName issuerName, Byte[] serialNumber);
    [NullableContextAttribute("1")]
public static X509AuthorityKeyIdentifierExtension CreateFromIssuerNameAndSerialNumber(X500DistinguishedName issuerName, ReadOnlySpan`1<byte> serialNumber);
    [NullableContextAttribute("1")]
public static X509AuthorityKeyIdentifierExtension CreateFromSubjectKeyIdentifier(Byte[] subjectKeyIdentifier);
    public static X509AuthorityKeyIdentifierExtension CreateFromSubjectKeyIdentifier(ReadOnlySpan`1<byte> subjectKeyIdentifier);
    [NullableContextAttribute("1")]
public static X509AuthorityKeyIdentifierExtension CreateFromSubjectKeyIdentifier(X509SubjectKeyIdentifierExtension subjectKeyIdentifier);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509BasicConstraintsExtension : X509Extension {
    public bool CertificateAuthority { get; }
    public bool HasPathLengthConstraint { get; }
    public int PathLengthConstraint { get; }
    public X509BasicConstraintsExtension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint, bool critical);
    public X509BasicConstraintsExtension(AsnEncodedData encodedBasicConstraints, bool critical);
    public bool get_CertificateAuthority();
    public bool get_HasPathLengthConstraint();
    public int get_PathLengthConstraint();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    public static X509BasicConstraintsExtension CreateForCertificateAuthority(Nullable`1<int> pathLengthConstraint);
    public static X509BasicConstraintsExtension CreateForEndEntity(bool critical);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509Certificate : object {
    public IntPtr Handle { get; }
    public string Issuer { get; }
    [NullableAttribute("0")]
public ReadOnlyMemory`1<byte> SerialNumberBytes { get; }
    public string Subject { get; }
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(Byte[] data);
    [CLSCompliantAttribute("False")]
[UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(Byte[] rawData, SecureString password);
    [CLSCompliantAttribute("False")]
[UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(Byte[] rawData, string password);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(IntPtr handle);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public X509Certificate(SerializationInfo info, StreamingContext context);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(X509Certificate cert);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(string fileName);
    [CLSCompliantAttribute("False")]
[UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(string fileName, SecureString password);
    [CLSCompliantAttribute("False")]
[UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(string fileName, string password);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    public IntPtr get_Handle();
    public string get_Issuer();
    [NullableContextAttribute("0")]
public ReadOnlyMemory`1<byte> get_SerialNumberBytes();
    public string get_Subject();
    [UnsupportedOSPlatformAttribute("browser")]
public static X509Certificate CreateFromCertFile(string filename);
    [UnsupportedOSPlatformAttribute("browser")]
public static X509Certificate CreateFromSignedFile(string filename);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(X509Certificate other);
    public virtual Byte[] Export(X509ContentType contentType);
    [CLSCompliantAttribute("False")]
public virtual Byte[] Export(X509ContentType contentType, SecureString password);
    public virtual Byte[] Export(X509ContentType contentType, string password);
    protected static string FormatDate(DateTime date);
    public virtual Byte[] GetCertHash();
    public virtual Byte[] GetCertHash(HashAlgorithmName hashAlgorithm);
    public virtual string GetCertHashString();
    public virtual string GetCertHashString(HashAlgorithmName hashAlgorithm);
    public virtual string GetEffectiveDateString();
    public virtual string GetExpirationDateString();
    public virtual string GetFormat();
    public virtual int GetHashCode();
    [ObsoleteAttribute("X509Certificate.GetIssuerName has been deprecated. Use the Issuer property instead.")]
public virtual string GetIssuerName();
    public virtual string GetKeyAlgorithm();
    public virtual Byte[] GetKeyAlgorithmParameters();
    public virtual string GetKeyAlgorithmParametersString();
    [ObsoleteAttribute("X509Certificate.GetName has been deprecated. Use the Subject property instead.")]
public virtual string GetName();
    public virtual Byte[] GetPublicKey();
    public virtual string GetPublicKeyString();
    public virtual Byte[] GetRawCertData();
    public virtual string GetRawCertDataString();
    public virtual Byte[] GetSerialNumber();
    public virtual string GetSerialNumberString();
    [ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(Byte[] rawData);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    [ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(string fileName);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    [ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    public virtual void Reset();
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    public virtual string ToString(bool fVerbose);
    [NullableContextAttribute("0")]
public virtual bool TryGetCertHash(HashAlgorithmName hashAlgorithm, Span`1<byte> destination, Int32& bytesWritten);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509Certificate2 : X509Certificate {
    public bool Archived { get; public set; }
    public X509ExtensionCollection Extensions { get; }
    public string FriendlyName { get; public set; }
    public bool HasPrivateKey { get; }
    public X500DistinguishedName IssuerName { get; }
    public DateTime NotAfter { get; }
    public DateTime NotBefore { get; }
    [NullableAttribute("2")]
[ObsoleteAttribute("X509Certificate2.PrivateKey is obsolete. Use the appropriate method to get the private key, such as GetRSAPrivateKey, or use the CopyWithPrivateKey method to create a new instance with a private key.")]
public AsymmetricAlgorithm PrivateKey { get; public set; }
    public PublicKey PublicKey { get; }
    public Byte[] RawData { get; }
    [NullableAttribute("0")]
public ReadOnlyMemory`1<byte> RawDataMemory { get; }
    public string SerialNumber { get; }
    public Oid SignatureAlgorithm { get; }
    public X500DistinguishedName SubjectName { get; }
    public string Thumbprint { get; }
    public int Version { get; }
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(Byte[] rawData);
    [CLSCompliantAttribute("False")]
[UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(Byte[] rawData, SecureString password);
    [CLSCompliantAttribute("False")]
[UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(Byte[] rawData, string password);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(IntPtr handle);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(ReadOnlySpan`1<byte> rawData);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(ReadOnlySpan`1<byte> rawData, ReadOnlySpan`1<char> password, X509KeyStorageFlags keyStorageFlags);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected X509Certificate2(SerializationInfo info, StreamingContext context);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(X509Certificate certificate);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(string fileName);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(string fileName, ReadOnlySpan`1<char> password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
[UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(string fileName, SecureString password);
    [CLSCompliantAttribute("False")]
[UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(string fileName, string password);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    public bool get_Archived();
    [SupportedOSPlatformAttribute("windows")]
public void set_Archived(bool value);
    public X509ExtensionCollection get_Extensions();
    public string get_FriendlyName();
    [SupportedOSPlatformAttribute("windows")]
public void set_FriendlyName(string value);
    public bool get_HasPrivateKey();
    public X500DistinguishedName get_IssuerName();
    public DateTime get_NotAfter();
    public DateTime get_NotBefore();
    [NullableContextAttribute("2")]
public AsymmetricAlgorithm get_PrivateKey();
    [NullableContextAttribute("2")]
public void set_PrivateKey(AsymmetricAlgorithm value);
    public PublicKey get_PublicKey();
    public Byte[] get_RawData();
    [NullableContextAttribute("0")]
public ReadOnlyMemory`1<byte> get_RawDataMemory();
    public string get_SerialNumber();
    public Oid get_SignatureAlgorithm();
    public X500DistinguishedName get_SubjectName();
    public string get_Thumbprint();
    public int get_Version();
    public X509Certificate2 CopyWithPrivateKey(ECDiffieHellman privateKey);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static X509Certificate2 CreateFromEncryptedPem(ReadOnlySpan`1<char> certPem, ReadOnlySpan`1<char> keyPem, ReadOnlySpan`1<char> password);
    [UnsupportedOSPlatformAttribute("browser")]
public static X509Certificate2 CreateFromEncryptedPemFile(string certPemFilePath, ReadOnlySpan`1<char> password, string keyPemFilePath);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static X509Certificate2 CreateFromPem(ReadOnlySpan`1<char> certPem);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static X509Certificate2 CreateFromPem(ReadOnlySpan`1<char> certPem, ReadOnlySpan`1<char> keyPem);
    [UnsupportedOSPlatformAttribute("browser")]
public static X509Certificate2 CreateFromPemFile(string certPemFilePath, string keyPemFilePath);
    public string ExportCertificatePem();
    [UnsupportedOSPlatformAttribute("browser")]
public static X509ContentType GetCertContentType(Byte[] rawData);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static X509ContentType GetCertContentType(ReadOnlySpan`1<byte> rawData);
    [UnsupportedOSPlatformAttribute("browser")]
public static X509ContentType GetCertContentType(string fileName);
    [NullableContextAttribute("2")]
public ECDiffieHellman GetECDiffieHellmanPrivateKey();
    [NullableContextAttribute("2")]
public ECDiffieHellman GetECDiffieHellmanPublicKey();
    public string GetNameInfo(X509NameType nameType, bool forIssuer);
    [ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(Byte[] rawData);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    [ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(string fileName);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    [ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    public bool MatchesHostname(string hostname, bool allowWildcards, bool allowCommonName);
    public virtual void Reset();
    public virtual string ToString();
    public virtual string ToString(bool verbose);
    [NullableContextAttribute("0")]
public bool TryExportCertificatePem(Span`1<char> destination, Int32& charsWritten);
    public bool Verify();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509Certificate2Collection : X509CertificateCollection {
    public X509Certificate2 Item { get; public set; }
    public X509Certificate2Collection(X509Certificate2 certificate);
    public X509Certificate2Collection(X509Certificate2Collection certificates);
    public X509Certificate2Collection(X509Certificate2[] certificates);
    public X509Certificate2 get_Item(int index);
    public void set_Item(int index, X509Certificate2 value);
    public int Add(X509Certificate2 certificate);
    public void AddRange(X509Certificate2Collection certificates);
    public void AddRange(X509Certificate2[] certificates);
    public bool Contains(X509Certificate2 certificate);
    [NullableContextAttribute("2")]
public Byte[] Export(X509ContentType contentType);
    [NullableContextAttribute("2")]
public Byte[] Export(X509ContentType contentType, string password);
    public string ExportCertificatePems();
    [UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public string ExportPkcs7Pem();
    public X509Certificate2Collection Find(X509FindType findType, object findValue, bool validOnly);
    public X509Certificate2Enumerator GetEnumerator();
    public void Import(Byte[] rawData);
    public void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [NullableContextAttribute("0")]
public void Import(ReadOnlySpan`1<byte> rawData);
    [NullableContextAttribute("0")]
public void Import(ReadOnlySpan`1<byte> rawData, ReadOnlySpan`1<char> password, X509KeyStorageFlags keyStorageFlags);
    [NullableContextAttribute("0")]
public void Import(ReadOnlySpan`1<byte> rawData, string password, X509KeyStorageFlags keyStorageFlags);
    public void Import(string fileName);
    [NullableContextAttribute("0")]
public void Import(string fileName, ReadOnlySpan`1<char> password, X509KeyStorageFlags keyStorageFlags);
    public void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    [NullableContextAttribute("0")]
public void ImportFromPem(ReadOnlySpan`1<char> certPem);
    public void ImportFromPemFile(string certPemFilePath);
    public void Insert(int index, X509Certificate2 certificate);
    public void Remove(X509Certificate2 certificate);
    public void RemoveRange(X509Certificate2Collection certificates);
    public void RemoveRange(X509Certificate2[] certificates);
    private sealed virtual override IEnumerator`1<X509Certificate2> System.Collections.Generic.IEnumerable<System.Security.Cryptography.X509Certificates.X509Certificate2>.GetEnumerator();
    [NullableContextAttribute("0")]
public bool TryExportCertificatePems(Span`1<char> destination, Int32& charsWritten);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public bool TryExportPkcs7Pem(Span`1<char> destination, Int32& charsWritten);
}
public class System.Security.Cryptography.X509Certificates.X509Certificate2Enumerator : object {
    [NullableAttribute("1")]
public X509Certificate2 Current { get; }
    [NullableAttribute("1")]
private object System.Collections.IEnumerator.Current { get; }
    [NullableContextAttribute("1")]
public sealed virtual X509Certificate2 get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public bool MoveNext();
    public void Reset();
    private sealed virtual override bool System.Collections.IEnumerator.MoveNext();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
    private sealed virtual override void System.IDisposable.Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509CertificateCollection : CollectionBase {
    public X509Certificate Item { get; public set; }
    public X509CertificateCollection(X509CertificateCollection value);
    public X509CertificateCollection(X509Certificate[] value);
    public X509Certificate get_Item(int index);
    public void set_Item(int index, X509Certificate value);
    public int Add(X509Certificate value);
    public void AddRange(X509CertificateCollection value);
    public void AddRange(X509Certificate[] value);
    public bool Contains(X509Certificate value);
    public void CopyTo(X509Certificate[] array, int index);
    public X509CertificateEnumerator GetEnumerator();
    public virtual int GetHashCode();
    public int IndexOf(X509Certificate value);
    public void Insert(int index, X509Certificate value);
    protected virtual void OnValidate(object value);
    public void Remove(X509Certificate value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509Chain : object {
    public IntPtr ChainContext { get; }
    public X509ChainElementCollection ChainElements { get; }
    public X509ChainPolicy ChainPolicy { get; public set; }
    public X509ChainStatus[] ChainStatus { get; }
    [NullableAttribute("2")]
public SafeX509ChainHandle SafeHandle { get; }
    public X509Chain(bool useMachineContext);
    [SupportedOSPlatformAttribute("windows")]
public X509Chain(IntPtr chainContext);
    public IntPtr get_ChainContext();
    public X509ChainElementCollection get_ChainElements();
    public X509ChainPolicy get_ChainPolicy();
    public void set_ChainPolicy(X509ChainPolicy value);
    public X509ChainStatus[] get_ChainStatus();
    [NullableContextAttribute("2")]
public SafeX509ChainHandle get_SafeHandle();
    [UnsupportedOSPlatformAttribute("browser")]
public bool Build(X509Certificate2 certificate);
    public static X509Chain Create();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509ChainElement : object {
    public X509Certificate2 Certificate { get; }
    public X509ChainStatus[] ChainElementStatus { get; }
    public string Information { get; }
    public X509Certificate2 get_Certificate();
    public X509ChainStatus[] get_ChainElementStatus();
    public string get_Information();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509ChainElementCollection : object {
    public int Count { get; }
    public bool IsSynchronized { get; }
    public X509ChainElement Item { get; }
    public object SyncRoot { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public X509ChainElement get_Item(int index);
    public sealed virtual object get_SyncRoot();
    public void CopyTo(X509ChainElement[] array, int index);
    public X509ChainElementEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<X509ChainElement> System.Collections.Generic.IEnumerable<System.Security.Cryptography.X509Certificates.X509ChainElement>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Security.Cryptography.X509Certificates.X509ChainElementEnumerator : object {
    [NullableAttribute("1")]
public X509ChainElement Current { get; }
    [NullableAttribute("1")]
private object System.Collections.IEnumerator.Current { get; }
    [NullableContextAttribute("1")]
public sealed virtual X509ChainElement get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private sealed virtual override void System.IDisposable.Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509ChainPolicy : object {
    public OidCollection ApplicationPolicy { get; }
    public OidCollection CertificatePolicy { get; }
    public X509Certificate2Collection CustomTrustStore { get; }
    public bool DisableCertificateDownloads { get; public set; }
    public X509Certificate2Collection ExtraStore { get; }
    public X509RevocationFlag RevocationFlag { get; public set; }
    public X509RevocationMode RevocationMode { get; public set; }
    public X509ChainTrustMode TrustMode { get; public set; }
    public TimeSpan UrlRetrievalTimeout { get; public set; }
    public X509VerificationFlags VerificationFlags { get; public set; }
    public DateTime VerificationTime { get; public set; }
    public bool VerificationTimeIgnored { get; public set; }
    public OidCollection get_ApplicationPolicy();
    public OidCollection get_CertificatePolicy();
    public X509Certificate2Collection get_CustomTrustStore();
    public bool get_DisableCertificateDownloads();
    public void set_DisableCertificateDownloads(bool value);
    public X509Certificate2Collection get_ExtraStore();
    public X509RevocationFlag get_RevocationFlag();
    public void set_RevocationFlag(X509RevocationFlag value);
    public X509RevocationMode get_RevocationMode();
    public void set_RevocationMode(X509RevocationMode value);
    public X509ChainTrustMode get_TrustMode();
    public void set_TrustMode(X509ChainTrustMode value);
    public TimeSpan get_UrlRetrievalTimeout();
    public void set_UrlRetrievalTimeout(TimeSpan value);
    public X509VerificationFlags get_VerificationFlags();
    public void set_VerificationFlags(X509VerificationFlags value);
    public DateTime get_VerificationTime();
    public void set_VerificationTime(DateTime value);
    public bool get_VerificationTimeIgnored();
    public void set_VerificationTimeIgnored(bool value);
    public X509ChainPolicy Clone();
    public void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509ChainStatus : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public X509ChainStatusFlags Status { get; public set; }
    public string StatusInformation { get; public set; }
    [IsReadOnlyAttribute]
public X509ChainStatusFlags get_Status();
    public void set_Status(X509ChainStatusFlags value);
    public string get_StatusInformation();
    public void set_StatusInformation(string value);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509ChainStatusFlags : Enum {
    public int value__;
    public static X509ChainStatusFlags NoError;
    public static X509ChainStatusFlags NotTimeValid;
    public static X509ChainStatusFlags NotTimeNested;
    public static X509ChainStatusFlags Revoked;
    public static X509ChainStatusFlags NotSignatureValid;
    public static X509ChainStatusFlags NotValidForUsage;
    public static X509ChainStatusFlags UntrustedRoot;
    public static X509ChainStatusFlags RevocationStatusUnknown;
    public static X509ChainStatusFlags Cyclic;
    public static X509ChainStatusFlags InvalidExtension;
    public static X509ChainStatusFlags InvalidPolicyConstraints;
    public static X509ChainStatusFlags InvalidBasicConstraints;
    public static X509ChainStatusFlags InvalidNameConstraints;
    public static X509ChainStatusFlags HasNotSupportedNameConstraint;
    public static X509ChainStatusFlags HasNotDefinedNameConstraint;
    public static X509ChainStatusFlags HasNotPermittedNameConstraint;
    public static X509ChainStatusFlags HasExcludedNameConstraint;
    public static X509ChainStatusFlags PartialChain;
    public static X509ChainStatusFlags CtlNotTimeValid;
    public static X509ChainStatusFlags CtlNotSignatureValid;
    public static X509ChainStatusFlags CtlNotValidForUsage;
    public static X509ChainStatusFlags HasWeakSignature;
    public static X509ChainStatusFlags OfflineRevocation;
    public static X509ChainStatusFlags NoIssuanceChainPolicy;
    public static X509ChainStatusFlags ExplicitDistrust;
    public static X509ChainStatusFlags HasNotSupportedCriticalExtension;
}
public enum System.Security.Cryptography.X509Certificates.X509ChainTrustMode : Enum {
    public int value__;
    public static X509ChainTrustMode System;
    public static X509ChainTrustMode CustomRootTrust;
}
public enum System.Security.Cryptography.X509Certificates.X509ContentType : Enum {
    public int value__;
    public static X509ContentType Unknown;
    public static X509ContentType Cert;
    public static X509ContentType SerializedCert;
    public static X509ContentType Pfx;
    public static X509ContentType Pkcs12;
    public static X509ContentType SerializedStore;
    public static X509ContentType Pkcs7;
    public static X509ContentType Authenticode;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509EnhancedKeyUsageExtension : X509Extension {
    public OidCollection EnhancedKeyUsages { get; }
    public X509EnhancedKeyUsageExtension(AsnEncodedData encodedEnhancedKeyUsages, bool critical);
    public X509EnhancedKeyUsageExtension(OidCollection enhancedKeyUsages, bool critical);
    public OidCollection get_EnhancedKeyUsages();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509Extension : AsnEncodedData {
    public bool Critical { get; public set; }
    public X509Extension(AsnEncodedData encodedExtension, bool critical);
    public X509Extension(Oid oid, Byte[] rawData, bool critical);
    [NullableContextAttribute("0")]
public X509Extension(Oid oid, ReadOnlySpan`1<byte> rawData, bool critical);
    public X509Extension(string oid, Byte[] rawData, bool critical);
    [NullableContextAttribute("0")]
public X509Extension(string oid, ReadOnlySpan`1<byte> rawData, bool critical);
    public bool get_Critical();
    public void set_Critical(bool value);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509ExtensionCollection : object {
    public int Count { get; }
    public bool IsSynchronized { get; }
    public X509Extension Item { get; }
    [NullableAttribute("2")]
public X509Extension Item { get; }
    public object SyncRoot { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public X509Extension get_Item(int index);
    public X509Extension get_Item(string oid);
    public sealed virtual object get_SyncRoot();
    public int Add(X509Extension extension);
    public void CopyTo(X509Extension[] array, int index);
    public X509ExtensionEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<X509Extension> System.Collections.Generic.IEnumerable<System.Security.Cryptography.X509Certificates.X509Extension>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Security.Cryptography.X509Certificates.X509ExtensionEnumerator : object {
    [NullableAttribute("1")]
public X509Extension Current { get; }
    [NullableAttribute("1")]
private object System.Collections.IEnumerator.Current { get; }
    [NullableContextAttribute("1")]
public sealed virtual X509Extension get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private sealed virtual override void System.IDisposable.Dispose();
}
public enum System.Security.Cryptography.X509Certificates.X509FindType : Enum {
    public int value__;
    public static X509FindType FindByThumbprint;
    public static X509FindType FindBySubjectName;
    public static X509FindType FindBySubjectDistinguishedName;
    public static X509FindType FindByIssuerName;
    public static X509FindType FindByIssuerDistinguishedName;
    public static X509FindType FindBySerialNumber;
    public static X509FindType FindByTimeValid;
    public static X509FindType FindByTimeNotYetValid;
    public static X509FindType FindByTimeExpired;
    public static X509FindType FindByTemplateName;
    public static X509FindType FindByApplicationPolicy;
    public static X509FindType FindByCertificatePolicy;
    public static X509FindType FindByExtension;
    public static X509FindType FindByKeyUsage;
    public static X509FindType FindBySubjectKeyIdentifier;
}
public enum System.Security.Cryptography.X509Certificates.X509IncludeOption : Enum {
    public int value__;
    public static X509IncludeOption None;
    public static X509IncludeOption ExcludeRoot;
    public static X509IncludeOption EndCertOnly;
    public static X509IncludeOption WholeChain;
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509KeyStorageFlags : Enum {
    public int value__;
    public static X509KeyStorageFlags DefaultKeySet;
    public static X509KeyStorageFlags UserKeySet;
    public static X509KeyStorageFlags MachineKeySet;
    public static X509KeyStorageFlags Exportable;
    public static X509KeyStorageFlags UserProtected;
    public static X509KeyStorageFlags PersistKeySet;
    public static X509KeyStorageFlags EphemeralKeySet;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509KeyUsageExtension : X509Extension {
    public X509KeyUsageFlags KeyUsages { get; }
    public X509KeyUsageExtension(AsnEncodedData encodedKeyUsage, bool critical);
    public X509KeyUsageExtension(X509KeyUsageFlags keyUsages, bool critical);
    public X509KeyUsageFlags get_KeyUsages();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509KeyUsageFlags : Enum {
    public int value__;
    public static X509KeyUsageFlags None;
    public static X509KeyUsageFlags EncipherOnly;
    public static X509KeyUsageFlags CrlSign;
    public static X509KeyUsageFlags KeyCertSign;
    public static X509KeyUsageFlags KeyAgreement;
    public static X509KeyUsageFlags DataEncipherment;
    public static X509KeyUsageFlags KeyEncipherment;
    public static X509KeyUsageFlags NonRepudiation;
    public static X509KeyUsageFlags DigitalSignature;
    public static X509KeyUsageFlags DecipherOnly;
}
public enum System.Security.Cryptography.X509Certificates.X509NameType : Enum {
    public int value__;
    public static X509NameType SimpleName;
    public static X509NameType EmailName;
    public static X509NameType UpnName;
    public static X509NameType DnsName;
    public static X509NameType DnsFromAlternativeName;
    public static X509NameType UrlName;
}
public enum System.Security.Cryptography.X509Certificates.X509RevocationFlag : Enum {
    public int value__;
    public static X509RevocationFlag EndCertificateOnly;
    public static X509RevocationFlag EntireChain;
    public static X509RevocationFlag ExcludeRoot;
}
public enum System.Security.Cryptography.X509Certificates.X509RevocationMode : Enum {
    public int value__;
    public static X509RevocationMode NoCheck;
    public static X509RevocationMode Online;
    public static X509RevocationMode Offline;
}
public enum System.Security.Cryptography.X509Certificates.X509RevocationReason : Enum {
    public int value__;
    public static X509RevocationReason Unspecified;
    public static X509RevocationReason KeyCompromise;
    public static X509RevocationReason CACompromise;
    public static X509RevocationReason AffiliationChanged;
    public static X509RevocationReason Superseded;
    public static X509RevocationReason CessationOfOperation;
    public static X509RevocationReason CertificateHold;
    public static X509RevocationReason RemoveFromCrl;
    public static X509RevocationReason PrivilegeWithdrawn;
    public static X509RevocationReason AACompromise;
    public static X509RevocationReason WeakAlgorithmOrKey;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.X509Certificates.X509SignatureGenerator : object {
    public PublicKey PublicKey { get; }
    public PublicKey get_PublicKey();
    protected abstract virtual PublicKey BuildPublicKey();
    public static X509SignatureGenerator CreateForECDsa(ECDsa key);
    public static X509SignatureGenerator CreateForRSA(RSA key, RSASignaturePadding signaturePadding);
    public abstract virtual Byte[] GetSignatureAlgorithmIdentifier(HashAlgorithmName hashAlgorithm);
    public abstract virtual Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509Store : object {
    public X509Certificate2Collection Certificates { get; }
    public bool IsOpen { get; }
    public StoreLocation Location { get; }
    [NullableAttribute("2")]
public string Name { get; }
    public IntPtr StoreHandle { get; }
    public X509Store(IntPtr storeHandle);
    public X509Store(StoreLocation storeLocation);
    public X509Store(StoreName storeName);
    public X509Store(StoreName storeName, StoreLocation storeLocation);
    public X509Store(StoreName storeName, StoreLocation storeLocation, OpenFlags flags);
    public X509Store(string storeName);
    public X509Store(string storeName, StoreLocation storeLocation);
    public X509Store(string storeName, StoreLocation storeLocation, OpenFlags flags);
    public X509Certificate2Collection get_Certificates();
    public bool get_IsOpen();
    public StoreLocation get_Location();
    [NullableContextAttribute("2")]
public string get_Name();
    public IntPtr get_StoreHandle();
    public void Add(X509Certificate2 certificate);
    public void AddRange(X509Certificate2Collection certificates);
    public void Close();
    public sealed virtual void Dispose();
    public void Open(OpenFlags flags);
    public void Remove(X509Certificate2 certificate);
    public void RemoveRange(X509Certificate2Collection certificates);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509SubjectAlternativeNameExtension : X509Extension {
    public X509SubjectAlternativeNameExtension(Byte[] rawData, bool critical);
    [NullableContextAttribute("0")]
public X509SubjectAlternativeNameExtension(ReadOnlySpan`1<byte> rawData, bool critical);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    public IEnumerable`1<string> EnumerateDnsNames();
    public IEnumerable`1<IPAddress> EnumerateIPAddresses();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierExtension : X509Extension {
    [NullableAttribute("2")]
public string SubjectKeyIdentifier { get; }
    [NullableAttribute("0")]
public ReadOnlyMemory`1<byte> SubjectKeyIdentifierBytes { get; }
    public X509SubjectKeyIdentifierExtension(Byte[] subjectKeyIdentifier, bool critical);
    [NullableContextAttribute("0")]
public X509SubjectKeyIdentifierExtension(ReadOnlySpan`1<byte> subjectKeyIdentifier, bool critical);
    public X509SubjectKeyIdentifierExtension(AsnEncodedData encodedSubjectKeyIdentifier, bool critical);
    public X509SubjectKeyIdentifierExtension(PublicKey key, bool critical);
    public X509SubjectKeyIdentifierExtension(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm, bool critical);
    public X509SubjectKeyIdentifierExtension(string subjectKeyIdentifier, bool critical);
    [NullableContextAttribute("2")]
public string get_SubjectKeyIdentifier();
    [NullableContextAttribute("0")]
public ReadOnlyMemory`1<byte> get_SubjectKeyIdentifierBytes();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
public enum System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm : Enum {
    public int value__;
    public static X509SubjectKeyIdentifierHashAlgorithm Sha1;
    public static X509SubjectKeyIdentifierHashAlgorithm ShortSha1;
    public static X509SubjectKeyIdentifierHashAlgorithm CapiSha1;
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509VerificationFlags : Enum {
    public int value__;
    public static X509VerificationFlags NoFlag;
    public static X509VerificationFlags IgnoreNotTimeValid;
    public static X509VerificationFlags IgnoreCtlNotTimeValid;
    public static X509VerificationFlags IgnoreNotTimeNested;
    public static X509VerificationFlags IgnoreInvalidBasicConstraints;
    public static X509VerificationFlags AllowUnknownCertificateAuthority;
    public static X509VerificationFlags IgnoreWrongUsage;
    public static X509VerificationFlags IgnoreInvalidName;
    public static X509VerificationFlags IgnoreInvalidPolicy;
    public static X509VerificationFlags IgnoreEndRevocationUnknown;
    public static X509VerificationFlags IgnoreCtlSignerRevocationUnknown;
    public static X509VerificationFlags IgnoreCertificateAuthorityRevocationUnknown;
    public static X509VerificationFlags IgnoreRootRevocationUnknown;
    public static X509VerificationFlags AllFlags;
}
