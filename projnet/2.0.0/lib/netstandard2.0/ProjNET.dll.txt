public class ProjNet.CoordinateSystems.AngularUnit : Info {
    private static double EqualityTolerance;
    private double _RadiansPerUnit;
    public static AngularUnit Degrees { get; }
    public static AngularUnit Radian { get; }
    public static AngularUnit Grad { get; }
    public static AngularUnit Gon { get; }
    public double RadiansPerUnit { get; public set; }
    public string WKT { get; }
    public string XML { get; }
    public AngularUnit(double radiansPerUnit);
    internal AngularUnit(double radiansPerUnit, string name, string authority, long authorityCode, string alias, string abbreviation, string remarks);
    public static AngularUnit get_Degrees();
    public static AngularUnit get_Radian();
    public static AngularUnit get_Grad();
    public static AngularUnit get_Gon();
    public double get_RadiansPerUnit();
    public void set_RadiansPerUnit(double value);
    public virtual string get_WKT();
    public virtual string get_XML();
    public virtual bool EqualParams(object obj);
}
public class ProjNet.CoordinateSystems.AxisInfo : object {
    private string _Name;
    private AxisOrientationEnum _Orientation;
    public string Name { get; public set; }
    public AxisOrientationEnum Orientation { get; public set; }
    public string WKT { get; }
    public string XML { get; }
    public AxisInfo(string name, AxisOrientationEnum orientation);
    public string get_Name();
    public void set_Name(string value);
    public AxisOrientationEnum get_Orientation();
    public void set_Orientation(AxisOrientationEnum value);
    public string get_WKT();
    public string get_XML();
}
public enum ProjNet.CoordinateSystems.AxisOrientationEnum : Enum {
    public short value__;
    public static AxisOrientationEnum Other;
    public static AxisOrientationEnum North;
    public static AxisOrientationEnum South;
    public static AxisOrientationEnum East;
    public static AxisOrientationEnum West;
    public static AxisOrientationEnum Up;
    public static AxisOrientationEnum Down;
}
public abstract class ProjNet.CoordinateSystems.CoordinateSystem : Info {
    private List`1<AxisInfo> _AxisInfo;
    private Double[] _DefaultEnvelope;
    public int Dimension { get; }
    internal List`1<AxisInfo> AxisInfo { get; internal set; }
    public Double[] DefaultEnvelope { get; public set; }
    internal CoordinateSystem(string name, string authority, long authorityCode, string alias, string abbreviation, string remarks);
    public int get_Dimension();
    public abstract virtual IUnit GetUnits(int dimension);
    internal List`1<AxisInfo> get_AxisInfo();
    internal void set_AxisInfo(List`1<AxisInfo> value);
    public AxisInfo GetAxis(int dimension);
    public Double[] get_DefaultEnvelope();
    public void set_DefaultEnvelope(Double[] value);
}
public class ProjNet.CoordinateSystems.CoordinateSystemFactory : object {
    public CoordinateSystem CreateFromXml(string xml);
    public CoordinateSystem CreateFromWkt(string WKT);
    public FittedCoordinateSystem CreateFittedCoordinateSystem(string name, CoordinateSystem baseCoordinateSystem, string toBaseWkt, List`1<AxisInfo> arAxes);
    public Ellipsoid CreateEllipsoid(string name, double semiMajorAxis, double semiMinorAxis, LinearUnit linearUnit);
    public Ellipsoid CreateFlattenedSphere(string name, double semiMajorAxis, double inverseFlattening, LinearUnit linearUnit);
    public ProjectedCoordinateSystem CreateProjectedCoordinateSystem(string name, GeographicCoordinateSystem gcs, IProjection projection, LinearUnit linearUnit, AxisInfo axis0, AxisInfo axis1);
    public IProjection CreateProjection(string name, string wktProjectionClass, List`1<ProjectionParameter> parameters);
    public HorizontalDatum CreateHorizontalDatum(string name, DatumType datumType, Ellipsoid ellipsoid, Wgs84ConversionInfo toWgs84);
    public PrimeMeridian CreatePrimeMeridian(string name, AngularUnit angularUnit, double longitude);
    public GeographicCoordinateSystem CreateGeographicCoordinateSystem(string name, AngularUnit angularUnit, HorizontalDatum datum, PrimeMeridian primeMeridian, AxisInfo axis0, AxisInfo axis1);
    public GeocentricCoordinateSystem CreateGeocentricCoordinateSystem(string name, HorizontalDatum datum, LinearUnit linearUnit, PrimeMeridian primeMeridian);
}
public abstract class ProjNet.CoordinateSystems.Datum : Info {
    [CompilerGeneratedAttribute]
private DatumType <DatumType>k__BackingField;
    public DatumType DatumType { get; public set; }
    internal Datum(DatumType type, string name, string authority, long code, string alias, string remarks, string abbreviation);
    [CompilerGeneratedAttribute]
public DatumType get_DatumType();
    [CompilerGeneratedAttribute]
public void set_DatumType(DatumType value);
    public virtual bool EqualParams(object obj);
}
public enum ProjNet.CoordinateSystems.DatumType : Enum {
    public int value__;
    public static DatumType HD_Min;
    public static DatumType HD_Other;
    public static DatumType HD_Classic;
    public static DatumType HD_Geocentric;
    public static DatumType HD_Max;
    public static DatumType VD_Min;
    public static DatumType VD_Other;
    public static DatumType VD_Orthometric;
    public static DatumType VD_Ellipsoidal;
    public static DatumType VD_AltitudeBarometric;
    public static DatumType VD_Normal;
    public static DatumType VD_GeoidModelDerived;
    public static DatumType VD_Depth;
    public static DatumType VD_Max;
    public static DatumType LD_Min;
    public static DatumType LD_Max;
}
public class ProjNet.CoordinateSystems.Ellipsoid : Info {
    [CompilerGeneratedAttribute]
private double <SemiMajorAxis>k__BackingField;
    [CompilerGeneratedAttribute]
private double <SemiMinorAxis>k__BackingField;
    [CompilerGeneratedAttribute]
private double <InverseFlattening>k__BackingField;
    [CompilerGeneratedAttribute]
private LinearUnit <AxisUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIvfDefinitive>k__BackingField;
    public static Ellipsoid WGS84 { get; }
    public static Ellipsoid WGS72 { get; }
    public static Ellipsoid GRS80 { get; }
    public static Ellipsoid International1924 { get; }
    public static Ellipsoid Clarke1880 { get; }
    public static Ellipsoid Clarke1866 { get; }
    public static Ellipsoid Sphere { get; }
    public double SemiMajorAxis { get; public set; }
    public double SemiMinorAxis { get; public set; }
    public double InverseFlattening { get; public set; }
    public LinearUnit AxisUnit { get; public set; }
    public bool IsIvfDefinitive { get; public set; }
    public string WKT { get; }
    public string XML { get; }
    internal Ellipsoid(double semiMajorAxis, double semiMinorAxis, double inverseFlattening, bool isIvfDefinitive, LinearUnit axisUnit, string name, string authority, long code, string alias, string abbreviation, string remarks);
    public static Ellipsoid get_WGS84();
    public static Ellipsoid get_WGS72();
    public static Ellipsoid get_GRS80();
    public static Ellipsoid get_International1924();
    public static Ellipsoid get_Clarke1880();
    public static Ellipsoid get_Clarke1866();
    public static Ellipsoid get_Sphere();
    [CompilerGeneratedAttribute]
public double get_SemiMajorAxis();
    [CompilerGeneratedAttribute]
public void set_SemiMajorAxis(double value);
    [CompilerGeneratedAttribute]
public double get_SemiMinorAxis();
    [CompilerGeneratedAttribute]
public void set_SemiMinorAxis(double value);
    [CompilerGeneratedAttribute]
public double get_InverseFlattening();
    [CompilerGeneratedAttribute]
public void set_InverseFlattening(double value);
    [CompilerGeneratedAttribute]
public LinearUnit get_AxisUnit();
    [CompilerGeneratedAttribute]
public void set_AxisUnit(LinearUnit value);
    [CompilerGeneratedAttribute]
public bool get_IsIvfDefinitive();
    [CompilerGeneratedAttribute]
public void set_IsIvfDefinitive(bool value);
    public virtual string get_WKT();
    public virtual string get_XML();
    public virtual bool EqualParams(object obj);
}
public class ProjNet.CoordinateSystems.FittedCoordinateSystem : CoordinateSystem {
    [CompilerGeneratedAttribute]
private MathTransform <ToBaseTransform>k__BackingField;
    [CompilerGeneratedAttribute]
private CoordinateSystem <BaseCoordinateSystem>k__BackingField;
    public MathTransform ToBaseTransform { get; }
    public CoordinateSystem BaseCoordinateSystem { get; }
    public string WKT { get; }
    public string XML { get; }
    protected internal FittedCoordinateSystem(CoordinateSystem baseSystem, MathTransform transform, string name, string authority, long code, string alias, string remarks, string abbreviation);
    [CompilerGeneratedAttribute]
public MathTransform get_ToBaseTransform();
    [CompilerGeneratedAttribute]
public CoordinateSystem get_BaseCoordinateSystem();
    public string ToBase();
    public virtual string get_WKT();
    public virtual string get_XML();
    public virtual bool EqualParams(object obj);
    public virtual IUnit GetUnits(int dimension);
}
public class ProjNet.CoordinateSystems.GeocentricCoordinateSystem : CoordinateSystem {
    [CompilerGeneratedAttribute]
private HorizontalDatum <HorizontalDatum>k__BackingField;
    [CompilerGeneratedAttribute]
private LinearUnit <LinearUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private PrimeMeridian <PrimeMeridian>k__BackingField;
    public static GeocentricCoordinateSystem WGS84 { get; }
    public HorizontalDatum HorizontalDatum { get; public set; }
    public LinearUnit LinearUnit { get; public set; }
    public PrimeMeridian PrimeMeridian { get; public set; }
    public string WKT { get; }
    public string XML { get; }
    internal GeocentricCoordinateSystem(HorizontalDatum datum, LinearUnit linearUnit, PrimeMeridian primeMeridian, List`1<AxisInfo> axisInfo, string name, string authority, long code, string alias, string remarks, string abbreviation);
    public static GeocentricCoordinateSystem get_WGS84();
    [CompilerGeneratedAttribute]
public HorizontalDatum get_HorizontalDatum();
    [CompilerGeneratedAttribute]
public void set_HorizontalDatum(HorizontalDatum value);
    [CompilerGeneratedAttribute]
public LinearUnit get_LinearUnit();
    [CompilerGeneratedAttribute]
public void set_LinearUnit(LinearUnit value);
    public virtual IUnit GetUnits(int dimension);
    [CompilerGeneratedAttribute]
public PrimeMeridian get_PrimeMeridian();
    [CompilerGeneratedAttribute]
public void set_PrimeMeridian(PrimeMeridian value);
    public virtual string get_WKT();
    public virtual string get_XML();
    public virtual bool EqualParams(object obj);
}
public class ProjNet.CoordinateSystems.GeographicCoordinateSystem : HorizontalCoordinateSystem {
    [CompilerGeneratedAttribute]
private AngularUnit <AngularUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private PrimeMeridian <PrimeMeridian>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Wgs84ConversionInfo> <WGS84ConversionInfo>k__BackingField;
    public static GeographicCoordinateSystem WGS84 { get; }
    public AngularUnit AngularUnit { get; public set; }
    public PrimeMeridian PrimeMeridian { get; public set; }
    public int NumConversionToWGS84 { get; }
    internal List`1<Wgs84ConversionInfo> WGS84ConversionInfo { get; internal set; }
    public string WKT { get; }
    public string XML { get; }
    internal GeographicCoordinateSystem(AngularUnit angularUnit, HorizontalDatum horizontalDatum, PrimeMeridian primeMeridian, List`1<AxisInfo> axisInfo, string name, string authority, long authorityCode, string alias, string abbreviation, string remarks);
    public static GeographicCoordinateSystem get_WGS84();
    [CompilerGeneratedAttribute]
public AngularUnit get_AngularUnit();
    [CompilerGeneratedAttribute]
public void set_AngularUnit(AngularUnit value);
    public virtual IUnit GetUnits(int dimension);
    [CompilerGeneratedAttribute]
public PrimeMeridian get_PrimeMeridian();
    [CompilerGeneratedAttribute]
public void set_PrimeMeridian(PrimeMeridian value);
    public int get_NumConversionToWGS84();
    [CompilerGeneratedAttribute]
internal List`1<Wgs84ConversionInfo> get_WGS84ConversionInfo();
    [CompilerGeneratedAttribute]
internal void set_WGS84ConversionInfo(List`1<Wgs84ConversionInfo> value);
    public Wgs84ConversionInfo GetWgs84ConversionInfo(int index);
    public virtual string get_WKT();
    public virtual string get_XML();
    public virtual bool EqualParams(object obj);
}
public abstract class ProjNet.CoordinateSystems.HorizontalCoordinateSystem : CoordinateSystem {
    [CompilerGeneratedAttribute]
private HorizontalDatum <HorizontalDatum>k__BackingField;
    public HorizontalDatum HorizontalDatum { get; public set; }
    internal HorizontalCoordinateSystem(HorizontalDatum datum, List`1<AxisInfo> axisInfo, string name, string authority, long code, string alias, string remarks, string abbreviation);
    [CompilerGeneratedAttribute]
public HorizontalDatum get_HorizontalDatum();
    [CompilerGeneratedAttribute]
public void set_HorizontalDatum(HorizontalDatum value);
}
public class ProjNet.CoordinateSystems.HorizontalDatum : Datum {
    [CompilerGeneratedAttribute]
private Ellipsoid <Ellipsoid>k__BackingField;
    [CompilerGeneratedAttribute]
private Wgs84ConversionInfo <Wgs84Parameters>k__BackingField;
    public static HorizontalDatum WGS84 { get; }
    public static HorizontalDatum WGS72 { get; }
    public static HorizontalDatum ETRF89 { get; }
    public static HorizontalDatum ED50 { get; }
    public Ellipsoid Ellipsoid { get; public set; }
    public Wgs84ConversionInfo Wgs84Parameters { get; public set; }
    public string WKT { get; }
    public string XML { get; }
    internal HorizontalDatum(Ellipsoid ellipsoid, Wgs84ConversionInfo toWgs84, DatumType type, string name, string authority, long code, string alias, string remarks, string abbreviation);
    public static HorizontalDatum get_WGS84();
    public static HorizontalDatum get_WGS72();
    public static HorizontalDatum get_ETRF89();
    public static HorizontalDatum get_ED50();
    [CompilerGeneratedAttribute]
public Ellipsoid get_Ellipsoid();
    [CompilerGeneratedAttribute]
public void set_Ellipsoid(Ellipsoid value);
    [CompilerGeneratedAttribute]
public Wgs84ConversionInfo get_Wgs84Parameters();
    [CompilerGeneratedAttribute]
public void set_Wgs84Parameters(Wgs84ConversionInfo value);
    public virtual string get_WKT();
    public virtual string get_XML();
    public virtual bool EqualParams(object obj);
}
public interface ProjNet.CoordinateSystems.IInfo {
    public string Name { get; }
    public string Authority { get; }
    public long AuthorityCode { get; }
    public string Alias { get; }
    public string Abbreviation { get; }
    public string Remarks { get; }
    public string WKT { get; }
    public string XML { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Authority();
    public abstract virtual long get_AuthorityCode();
    public abstract virtual string get_Alias();
    public abstract virtual string get_Abbreviation();
    public abstract virtual string get_Remarks();
    public abstract virtual string get_WKT();
    public abstract virtual string get_XML();
    public abstract virtual bool EqualParams(object obj);
}
public abstract class ProjNet.CoordinateSystems.Info : object {
    private string _Name;
    private string _Authority;
    private long _Code;
    private string _Alias;
    private string _Abbreviation;
    private string _Remarks;
    public string Name { get; public set; }
    public string Authority { get; public set; }
    public long AuthorityCode { get; public set; }
    public string Alias { get; public set; }
    public string Abbreviation { get; public set; }
    public string Remarks { get; public set; }
    public string WKT { get; }
    public string XML { get; }
    internal string InfoXml { get; }
    internal Info(string name, string authority, long code, string alias, string abbreviation, string remarks);
    public sealed virtual string get_Name();
    public void set_Name(string value);
    public sealed virtual string get_Authority();
    public void set_Authority(string value);
    public sealed virtual long get_AuthorityCode();
    public void set_AuthorityCode(long value);
    public sealed virtual string get_Alias();
    public void set_Alias(string value);
    public sealed virtual string get_Abbreviation();
    public void set_Abbreviation(string value);
    public sealed virtual string get_Remarks();
    public void set_Remarks(string value);
    public virtual string ToString();
    public abstract virtual string get_WKT();
    public abstract virtual string get_XML();
    internal string get_InfoXml();
    public abstract virtual bool EqualParams(object obj);
}
public interface ProjNet.CoordinateSystems.IProjection {
    public int NumParameters { get; }
    public string ClassName { get; }
    public abstract virtual int get_NumParameters();
    public abstract virtual string get_ClassName();
    public abstract virtual ProjectionParameter GetParameter(int index);
    public abstract virtual ProjectionParameter GetParameter(string name);
}
public interface ProjNet.CoordinateSystems.IUnit {
}
public class ProjNet.CoordinateSystems.LinearUnit : Info {
    [CompilerGeneratedAttribute]
private double <MetersPerUnit>k__BackingField;
    public static LinearUnit Metre { get; }
    public static LinearUnit Foot { get; }
    public static LinearUnit USSurveyFoot { get; }
    public static LinearUnit NauticalMile { get; }
    public static LinearUnit ClarkesFoot { get; }
    public double MetersPerUnit { get; public set; }
    public string WKT { get; }
    public string XML { get; }
    public LinearUnit(double metersPerUnit, string name, string authority, long authorityCode, string alias, string abbreviation, string remarks);
    public static LinearUnit get_Metre();
    public static LinearUnit get_Foot();
    public static LinearUnit get_USSurveyFoot();
    public static LinearUnit get_NauticalMile();
    public static LinearUnit get_ClarkesFoot();
    [CompilerGeneratedAttribute]
public double get_MetersPerUnit();
    [CompilerGeneratedAttribute]
public void set_MetersPerUnit(double value);
    public virtual string get_WKT();
    public virtual string get_XML();
    public virtual bool EqualParams(object obj);
}
public class ProjNet.CoordinateSystems.Parameter : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    public string Name { get; public set; }
    public double Value { get; public set; }
    public Parameter(string name, double value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public double get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(double value);
}
internal class ProjNet.CoordinateSystems.ParameterInfo : object {
    [CompilerGeneratedAttribute]
private List`1<Parameter> <Parameters>k__BackingField;
    public int NumParameters { get; }
    public List`1<Parameter> Parameters { get; public set; }
    public int get_NumParameters();
    [CompilerGeneratedAttribute]
public List`1<Parameter> get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(List`1<Parameter> value);
    public Parameter[] DefaultParameters();
    public Parameter GetParameterByName(string name);
}
public class ProjNet.CoordinateSystems.PrimeMeridian : Info {
    [CompilerGeneratedAttribute]
private double <Longitude>k__BackingField;
    [CompilerGeneratedAttribute]
private AngularUnit <AngularUnit>k__BackingField;
    public static PrimeMeridian Greenwich { get; }
    public static PrimeMeridian Lisbon { get; }
    public static PrimeMeridian Paris { get; }
    public static PrimeMeridian Bogota { get; }
    public static PrimeMeridian Madrid { get; }
    public static PrimeMeridian Rome { get; }
    public static PrimeMeridian Bern { get; }
    public static PrimeMeridian Jakarta { get; }
    public static PrimeMeridian Ferro { get; }
    public static PrimeMeridian Brussels { get; }
    public static PrimeMeridian Stockholm { get; }
    public static PrimeMeridian Athens { get; }
    public static PrimeMeridian Oslo { get; }
    public double Longitude { get; public set; }
    public AngularUnit AngularUnit { get; public set; }
    public string WKT { get; }
    public string XML { get; }
    internal PrimeMeridian(double longitude, AngularUnit angularUnit, string name, string authority, long authorityCode, string alias, string abbreviation, string remarks);
    public static PrimeMeridian get_Greenwich();
    public static PrimeMeridian get_Lisbon();
    public static PrimeMeridian get_Paris();
    public static PrimeMeridian get_Bogota();
    public static PrimeMeridian get_Madrid();
    public static PrimeMeridian get_Rome();
    public static PrimeMeridian get_Bern();
    public static PrimeMeridian get_Jakarta();
    public static PrimeMeridian get_Ferro();
    public static PrimeMeridian get_Brussels();
    public static PrimeMeridian get_Stockholm();
    public static PrimeMeridian get_Athens();
    public static PrimeMeridian get_Oslo();
    [CompilerGeneratedAttribute]
public double get_Longitude();
    [CompilerGeneratedAttribute]
public void set_Longitude(double value);
    [CompilerGeneratedAttribute]
public AngularUnit get_AngularUnit();
    [CompilerGeneratedAttribute]
public void set_AngularUnit(AngularUnit value);
    public virtual string get_WKT();
    public virtual string get_XML();
    public virtual bool EqualParams(object obj);
}
public class ProjNet.CoordinateSystems.ProjectedCoordinateSystem : HorizontalCoordinateSystem {
    [CompilerGeneratedAttribute]
private GeographicCoordinateSystem <GeographicCoordinateSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private LinearUnit <LinearUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjection <Projection>k__BackingField;
    public static ProjectedCoordinateSystem WebMercator { get; }
    public GeographicCoordinateSystem GeographicCoordinateSystem { get; public set; }
    public LinearUnit LinearUnit { get; public set; }
    public IProjection Projection { get; public set; }
    public string WKT { get; }
    public string XML { get; }
    internal ProjectedCoordinateSystem(HorizontalDatum datum, GeographicCoordinateSystem geographicCoordinateSystem, LinearUnit linearUnit, IProjection projection, List`1<AxisInfo> axisInfo, string name, string authority, long code, string alias, string remarks, string abbreviation);
    public static ProjectedCoordinateSystem WGS84_UTM(int zone, bool zoneIsNorth);
    public static ProjectedCoordinateSystem get_WebMercator();
    [CompilerGeneratedAttribute]
public GeographicCoordinateSystem get_GeographicCoordinateSystem();
    [CompilerGeneratedAttribute]
public void set_GeographicCoordinateSystem(GeographicCoordinateSystem value);
    [CompilerGeneratedAttribute]
public LinearUnit get_LinearUnit();
    [CompilerGeneratedAttribute]
public void set_LinearUnit(LinearUnit value);
    public virtual IUnit GetUnits(int dimension);
    [CompilerGeneratedAttribute]
public IProjection get_Projection();
    [CompilerGeneratedAttribute]
public void set_Projection(IProjection value);
    public virtual string get_WKT();
    public virtual string get_XML();
    public virtual bool EqualParams(object obj);
}
public class ProjNet.CoordinateSystems.Projection : Info {
    private List`1<ProjectionParameter> _parameters;
    private string _ClassName;
    public int NumParameters { get; }
    internal List`1<ProjectionParameter> Parameters { get; internal set; }
    public string ClassName { get; }
    public string WKT { get; }
    public string XML { get; }
    internal Projection(string className, List`1<ProjectionParameter> parameters, string name, string authority, long code, string alias, string remarks, string abbreviation);
    public sealed virtual int get_NumParameters();
    internal List`1<ProjectionParameter> get_Parameters();
    internal void set_Parameters(List`1<ProjectionParameter> value);
    public sealed virtual ProjectionParameter GetParameter(int index);
    public sealed virtual ProjectionParameter GetParameter(string name);
    public sealed virtual string get_ClassName();
    public virtual string get_WKT();
    public virtual string get_XML();
    public virtual bool EqualParams(object obj);
}
public class ProjNet.CoordinateSystems.ProjectionParameter : object {
    private string _Name;
    private double _Value;
    public string Name { get; public set; }
    public double Value { get; public set; }
    public string WKT { get; }
    public string XML { get; }
    public ProjectionParameter(string name, double value);
    public string get_Name();
    public void set_Name(string value);
    public double get_Value();
    public void set_Value(double value);
    public string get_WKT();
    public string get_XML();
    public virtual string ToString();
}
internal class ProjNet.CoordinateSystems.Projections.AlbersProjection : MapProjection {
    private double _c;
    private double _ro0;
    private double _n;
    public AlbersProjection(IEnumerable`1<ProjectionParameter> parameters);
    protected AlbersProjection(IEnumerable`1<ProjectionParameter> parameters, AlbersProjection inverse);
    protected sealed virtual void RadiansToMeters(Double& lon, Double& lat);
    protected sealed virtual void MetersToRadians(Double& x, Double& y);
    public virtual MathTransform Inverse();
    private double alpha(double lat);
    private double Ro(double a);
}
internal class ProjNet.CoordinateSystems.Projections.CassiniSoldnerProjection : MapProjection {
    private static double One6th;
    private static double One120th;
    private static double One24th;
    private static double One3rd;
    private static double One15th;
    private double _cFactor;
    private double _m0;
    private double _reciprocalSemiMajor;
    public CassiniSoldnerProjection(IEnumerable`1<ProjectionParameter> parameters);
    public CassiniSoldnerProjection(IEnumerable`1<ProjectionParameter> parameters, CassiniSoldnerProjection inverse);
    public virtual MathTransform Inverse();
    protected virtual void RadiansToMeters(Double& lon, Double& lat);
    protected virtual void MetersToRadians(Double& x, Double& y);
    private double Phi1(double arg);
}
internal class ProjNet.CoordinateSystems.Projections.HotineObliqueMercatorProjection : MapProjection {
    private double _azimuth;
    private double _sinP20;
    private double _cosP20;
    private double _bl;
    private double _al;
    private double _d;
    private double _el;
    private double _singrid;
    private double _cosgrid;
    private double _singam;
    private double _cosgam;
    private double _sinaz;
    private double _cosaz;
    private double _u;
    private bool NaturalOriginOffsets { get; }
    public HotineObliqueMercatorProjection(IEnumerable`1<ProjectionParameter> parameters);
    public HotineObliqueMercatorProjection(IEnumerable`1<ProjectionParameter> parameters, HotineObliqueMercatorProjection inverse);
    private bool get_NaturalOriginOffsets();
    public virtual MathTransform Inverse();
    protected virtual void RadiansToMeters(Double& lon, Double& lat);
    protected virtual void MetersToRadians(Double& x, Double& y);
}
internal class ProjNet.CoordinateSystems.Projections.KrovakProjection : MapProjection {
    private static int MaximumIterations;
    private static double IterationTolerance;
    private double _azimuth;
    private double _pseudoStandardParallel;
    private double _sinAzim;
    private double _cosAzim;
    private double _n;
    private double _tanS2;
    private double _alfa;
    private double _hae;
    private double _k1;
    private double _ka;
    private double _ro0;
    private double _rop;
    private double _reciprocSemiMajor;
    private static double S45;
    public KrovakProjection(IEnumerable`1<ProjectionParameter> parameters);
    protected KrovakProjection(IEnumerable`1<ProjectionParameter> parameters, KrovakProjection inverse);
    protected virtual void RadiansToMeters(Double& lon, Double& lat);
    protected virtual void MetersToRadians(Double& x, Double& y);
    public virtual MathTransform Inverse();
}
public class ProjNet.CoordinateSystems.Projections.LambertAzimuthalEqualAreaProjection : MapProjection {
    private Transformer _radiansToMeters;
    private Transformer _metersToRadians;
    private Mode _mode;
    private double _qp;
    private double _one_es;
    private Double[] _apa;
    private double _dd;
    private double _sinb1;
    private double _cosb1;
    private double _rq;
    private double _xmf;
    private double _ymf;
    private double _reciprocSemiMajorTimesScaleFactor;
    public LambertAzimuthalEqualAreaProjection(IEnumerable`1<ProjectionParameter> parameters);
    public LambertAzimuthalEqualAreaProjection(IEnumerable`1<ProjectionParameter> parameters, MapProjection inverse);
    public virtual MathTransform Inverse();
    protected virtual void RadiansToMeters(Double& lon, Double& lat);
    private void EllipsoidalRadiansToMeters(Double& lon, Double& lat);
    private void SphericalRadiansToMeters(Double& lon, Double& lat);
    protected virtual void MetersToRadians(Double& x, Double& y);
    private void EllipsoidalMetersToRadians(Double& x, Double& y);
    private void SphericalMetersToRadians(Double& x, Double& y);
}
internal class ProjNet.CoordinateSystems.Projections.LambertConformalConic2SP : MapProjection {
    private double _ns;
    private double _f0;
    private double _rh;
    public LambertConformalConic2SP(IEnumerable`1<ProjectionParameter> parameters);
    protected LambertConformalConic2SP(IEnumerable`1<ProjectionParameter> parameters, LambertConformalConic2SP inverse);
    protected virtual void RadiansToMeters(Double& lon, Double& lat);
    protected virtual void MetersToRadians(Double& x, Double& y);
    public virtual MathTransform Inverse();
}
public abstract class ProjNet.CoordinateSystems.Projections.MapProjection : MathTransform {
    protected static double EPS10;
    protected static double EPS7;
    protected static double HUGE_VAL;
    protected double _e;
    protected double _es;
    protected double _semiMajor;
    protected double _semiMinor;
    protected double _metersPerUnit;
    protected double _reciprocalMetersPerUnit;
    protected double scale_factor;
    protected double central_meridian;
    protected double lat_origin;
    protected double false_northing;
    protected double false_easting;
    protected double en0;
    protected double en1;
    protected double en2;
    protected double en3;
    protected double en4;
    protected ProjectionParameterSet _Parameters;
    protected MathTransform _inverse;
    [CompilerGeneratedAttribute]
private string <Abbreviation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Authority>k__BackingField;
    [CompilerGeneratedAttribute]
private long <AuthorityCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Remarks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInverse>k__BackingField;
    protected static double PI;
    protected static double FORT_PI;
    protected static double HALF_PI;
    protected static double TWO_PI;
    protected static double EPSLN;
    protected static double S2R;
    protected static double MAX_VAL;
    protected static double prjMAXLONG;
    protected static double DBLLONG;
    private static double C00;
    private static double C02;
    private static double C04;
    private static double C06;
    private static double C08;
    private static double C22;
    private static double C44;
    private static double C46;
    private static double C48;
    private static double C66;
    private static double C68;
    private static double C88;
    private static double P00;
    private static double P01;
    private static double P02;
    private static double P10;
    private static double P11;
    private static double P20;
    protected double lon_origin { get; protected set; }
    protected double central_parallel { get; }
    protected double phi0 { get; }
    public string ClassName { get; }
    public int NumParameters { get; }
    public string Abbreviation { get; public set; }
    public string Alias { get; public set; }
    public string Authority { get; public set; }
    public long AuthorityCode { get; public set; }
    public string Name { get; public set; }
    public string Remarks { get; public set; }
    public string WKT { get; }
    public string XML { get; }
    public int DimSource { get; }
    public int DimTarget { get; }
    protected internal bool IsInverse { get; private set; }
    protected MapProjection(IEnumerable`1<ProjectionParameter> parameters, MapProjection inverse);
    protected MapProjection(IEnumerable`1<ProjectionParameter> parameters);
    protected double get_lon_origin();
    protected void set_lon_origin(double value);
    protected double get_central_parallel();
    protected double get_phi0();
    protected internal static List`1<ProjectionParameter> CloneParametersList(IEnumerable`1<ProjectionParameter> projectionParameters);
    public sealed virtual string get_ClassName();
    public sealed virtual ProjectionParameter GetParameter(int index);
    public sealed virtual ProjectionParameter GetParameter(string name);
    public sealed virtual int get_NumParameters();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Abbreviation();
    [CompilerGeneratedAttribute]
public void set_Abbreviation(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Alias();
    [CompilerGeneratedAttribute]
public void set_Alias(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Authority();
    [CompilerGeneratedAttribute]
public void set_Authority(string value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_AuthorityCode();
    [CompilerGeneratedAttribute]
public void set_AuthorityCode(long value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Remarks();
    [CompilerGeneratedAttribute]
public void set_Remarks(string value);
    public virtual string get_WKT();
    public virtual string get_XML();
    public sealed virtual int get_DimSource();
    public sealed virtual int get_DimTarget();
    public sealed virtual void Transform(Double& x, Double& y, Double& z);
    protected sealed virtual void TransformCore(Span`1<double> xs, Span`1<double> ys, Span`1<double> zs, int strideX, int strideY, int strideZ);
    protected abstract virtual void RadiansToMeters(Double& lon, Double& lat);
    protected virtual void RadiansToMeters(Span`1<double> lons, Span`1<double> lats, int strideX, int strideY);
    protected virtual void DegreesToMeters(Double& lon, Double& lat);
    protected virtual void DegreesToMeters(Span`1<double> lons, Span`1<double> lats, int strideX, int strideY);
    protected virtual void DegreesToTarget(Double& lon, Double& lat);
    protected virtual void DegreesToTarget(Span`1<double> lons, Span`1<double> lats, int strideX, int strideY);
    protected void MetersToTarget(Double& x, Double& y);
    protected void MetersToTarget(Span`1<double> xs, Span`1<double> ys, int strideX, int strideY);
    protected abstract virtual void MetersToRadians(Double& x, Double& y);
    protected virtual void MetersToRadians(Span`1<double> xs, Span`1<double> ys, int strideX, int strideY);
    protected virtual void MetersToDegrees(Double& x, Double& y);
    protected virtual void MetersToDegrees(Span`1<double> xs, Span`1<double> ys, int strideX, int strideY);
    protected virtual void SourceToDegrees(Double& x, Double& y);
    protected virtual void SourceToDegrees(Span`1<double> xs, Span`1<double> ys, int strideX, int strideY);
    protected void SourceToMeters(Span`1<double> xs, Span`1<double> ys, int strideX, int strideY);
    protected void SourceToMeters(Double& x, Double& y);
    public virtual void Invert();
    protected void Invert(bool invertInverse);
    [CompilerGeneratedAttribute]
protected internal bool get_IsInverse();
    [CompilerGeneratedAttribute]
private void set_IsInverse(bool value);
    public sealed virtual bool EqualParams(object obj);
    protected static double CUBE(double x);
    protected static double QUAD(double x);
    protected static double GMAX(Double& A, Double& B);
    protected static double GMIN(Double& A, Double& B);
    protected static double IMOD(double A, double B);
    protected static double sign(double x);
    protected static double adjust_lon(double x);
    protected static double msfnz(double eccent, double sinphi, double cosphi);
    protected static double qsfnz(double sinphi, double eccent);
    protected static double qsfn(double sinphi, double eccent, double one_es);
    protected static void sincos(double val, Double& sin_val, Double& cos_val);
    protected static double tsfnz(double eccent, double phi, double sinphi);
    protected static double phi1z(double eccent, double qs, Int64& flag);
    protected static double asinz(double con);
    protected static double phi2z(double eccent, double ts, Int64& flag);
    protected static double e0fn(double x);
    protected static double e1fn(double x);
    protected static double e2fn(double x);
    protected static double e3fn(double x);
    protected static double e4fn(double x);
    protected static double mlfn(double e0, double e1, double e2, double e3, double phi);
    protected double mlfn(double phi, double sphi, double cphi);
    protected double inv_mlfn(double arg);
    private static double FlatteningFactor(double equatorialRadius, double polarRadius);
    private static double EccentricySquared(double equatorialRadius, double polarRadius);
    public static long CalcUtmZone(double lon);
    protected static double LongitudeToRadians(double x, bool edge);
    protected static double LatitudeToRadians(double y, bool edge);
    protected static Double[] authset(double es);
    protected static double authlat(double beta, Double[] APA);
    protected static double hypot(double x, double y);
}
internal class ProjNet.CoordinateSystems.Projections.Mercator : MapProjection {
    private double _k0;
    public Mercator(IEnumerable`1<ProjectionParameter> parameters);
    protected Mercator(IEnumerable`1<ProjectionParameter> parameters, Mercator isInverse);
    protected virtual void RadiansToMeters(Double& lon, Double& lat);
    protected virtual void MetersToRadians(Double& x, Double& y);
    public virtual MathTransform Inverse();
}
internal class ProjNet.CoordinateSystems.Projections.ObliqueMercatorProjection : HotineObliqueMercatorProjection {
    public ObliqueMercatorProjection(IEnumerable`1<ProjectionParameter> parameters);
    public ObliqueMercatorProjection(IEnumerable`1<ProjectionParameter> parameters, ObliqueMercatorProjection inverse);
    public virtual MathTransform Inverse();
}
internal class ProjNet.CoordinateSystems.Projections.ObliqueStereographicProjection : MapProjection {
    private double _globalScale;
    private double _reciprocGlobalScale;
    private static double ITERATION_TOLERANCE;
    private static int MAXIMUM_ITERATIONS;
    private static double EPSILON;
    private double C;
    private double K;
    private double ratexp;
    private double phic0;
    private double cosc0;
    private double sinc0;
    private double R2;
    public ObliqueStereographicProjection(IEnumerable`1<ProjectionParameter> parameters);
    public ObliqueStereographicProjection(IEnumerable`1<ProjectionParameter> parameters, ObliqueStereographicProjection inverse);
    private static ObliqueStereographicProjection();
    protected virtual void MetersToRadians(Double& x, Double& y);
    protected virtual void RadiansToMeters(Double& lon, Double& lat);
    public virtual MathTransform Inverse();
    private double srat(double esinp, double exp);
}
internal class ProjNet.CoordinateSystems.Projections.PolyconicProjection : MapProjection {
    private static double Epsilon;
    private static int MaximumIterations;
    private static double IterationTolerance;
    private double _ml0;
    private double _reciprocSemiMajorTimesScaleFactor;
    public PolyconicProjection(IEnumerable`1<ProjectionParameter> parameters);
    protected PolyconicProjection(IEnumerable`1<ProjectionParameter> parameters, PolyconicProjection inverse);
    protected virtual void RadiansToMeters(Double& lon, Double& lat);
    protected virtual void MetersToRadians(Double& x, Double& y);
    public virtual MathTransform Inverse();
    private double msfn(double s, double c);
}
public class ProjNet.CoordinateSystems.Projections.ProjectionParameterSet : Dictionary`2<string, double> {
    private Dictionary`2<string, string> _originalNames;
    private Dictionary`2<int, string> _originalIndex;
    public ProjectionParameterSet(SerializationInfo info, StreamingContext context);
    public ProjectionParameterSet(IEnumerable`1<ProjectionParameter> parameters);
    [IteratorStateMachineAttribute("ProjNet.CoordinateSystems.Projections.ProjectionParameterSet/<ToProjectionParameter>d__4")]
public IEnumerable`1<ProjectionParameter> ToProjectionParameter();
    public double GetParameterValue(string parameterName, String[] alternateNames);
    public double GetOptionalParameterValue(string name, double value, String[] alternateNames);
    public ProjectionParameter Find(string name);
    public ProjectionParameter GetAtIndex(int index);
    public sealed virtual bool Equals(ProjectionParameterSet other);
    internal void SetParameterValue(string name, double value);
}
public class ProjNet.CoordinateSystems.Projections.ProjectionsRegistry : object {
    private static Dictionary`2<string, Type> TypeRegistry;
    private static Dictionary`2<string, Type> ConstructorRegistry;
    private static object RegistryLock;
    private static ProjectionsRegistry();
    public static void Register(string name, Type type);
    private static Type CheckConstructor(Type type);
    internal static MathTransform CreateProjection(string className, IEnumerable`1<ProjectionParameter> parameters);
}
internal class ProjNet.CoordinateSystems.Projections.PseudoMercator : Mercator {
    public PseudoMercator(IEnumerable`1<ProjectionParameter> parameters);
    protected PseudoMercator(IEnumerable`1<ProjectionParameter> parameters, Mercator inverse);
    private static IEnumerable`1<ProjectionParameter> VerifyParameters(IEnumerable`1<ProjectionParameter> parameters);
    public virtual MathTransform Inverse();
}
internal class ProjNet.CoordinateSystems.Projections.TransverseMercator : MapProjection {
    private static double EPSILON;
    private double _esp;
    private double _ml0;
    private double _reciprocSemiMajor;
    private static double FC1;
    private static double FC2;
    private static double FC3;
    private static double FC4;
    private static double FC5;
    private static double FC6;
    private static double FC7;
    private static double FC8;
    public TransverseMercator(IEnumerable`1<ProjectionParameter> parameters);
    protected TransverseMercator(IEnumerable`1<ProjectionParameter> parameters, TransverseMercator inverse);
    protected virtual void RadiansToMeters(Double& lon, Double& lat);
    protected virtual void MetersToRadians(Double& x, Double& y);
    public virtual MathTransform Inverse();
}
public class ProjNet.CoordinateSystems.Transformations.AffineTransform : MathTransform {
    private MathTransform _inverse;
    private int _dimSource;
    private int _dimTarget;
    private Double[0...,0...] _transformMatrix;
    public string WKT { get; }
    public string XML { get; }
    public int DimSource { get; }
    public int DimTarget { get; }
    public AffineTransform(double m00, double m01, double m02, double m10, double m11, double m12);
    public AffineTransform(Double[0...,0...] matrix);
    public virtual string get_WKT();
    public virtual string get_XML();
    public virtual int get_DimSource();
    public virtual int get_DimTarget();
    private IList`1<ProjectionParameter> GetParameterValues();
    private static Double[] LUPSolve(Double[0...,0...] LU, Int32[] pi, Double[] b);
    private static Int32[] LUPDecomposition(Double[0...,0...] A);
    private static Double[0...,0...] InvertMatrix(Double[0...,0...] A);
    public virtual MathTransform Inverse();
    private ValueTuple`3<double, double, double> TransformAffine(double x, double y, double z);
    public virtual void Transform(Double& x, Double& y, Double& z);
    public virtual void Invert();
    public Double[0...,0...] GetMatrix();
}
internal class ProjNet.CoordinateSystems.Transformations.ConcatenatedTransform : MathTransform {
    private MathTransform _inverse;
    private List`1<ICoordinateTransformationCore> _coordinateTransformationList;
    private static CoordinateTransformationFactory CoordinateTransformationFactory;
    public IList`1<ICoordinateTransformationCore> CoordinateTransformationList { get; }
    public int DimSource { get; }
    public int DimTarget { get; }
    public string WKT { get; }
    public string XML { get; }
    public CoordinateSystem SourceCS { get; }
    public CoordinateSystem TargetCS { get; }
    public ConcatenatedTransform(IEnumerable`1<ICoordinateTransformationCore> transformList);
    private static ConcatenatedTransform();
    public IList`1<ICoordinateTransformationCore> get_CoordinateTransformationList();
    public virtual int get_DimSource();
    public virtual int get_DimTarget();
    public virtual void Transform(Double& x, Double& y, Double& z);
    public virtual MathTransform Inverse();
    public virtual void Invert();
    public ConcatenatedTransform Clone();
    private static ICoordinateTransformationCore CloneCoordinateTransformation(ICoordinateTransformationCore ict);
    public virtual string get_WKT();
    public virtual string get_XML();
    public sealed virtual CoordinateSystem get_SourceCS();
    public sealed virtual CoordinateSystem get_TargetCS();
}
public class ProjNet.CoordinateSystems.Transformations.CoordinateTransformation : object {
    [CompilerGeneratedAttribute]
private string <AreaOfUse>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Authority>k__BackingField;
    [CompilerGeneratedAttribute]
private long <AuthorityCode>k__BackingField;
    [CompilerGeneratedAttribute]
private MathTransform <MathTransform>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Remarks>k__BackingField;
    [CompilerGeneratedAttribute]
private CoordinateSystem <SourceCS>k__BackingField;
    [CompilerGeneratedAttribute]
private CoordinateSystem <TargetCS>k__BackingField;
    [CompilerGeneratedAttribute]
private TransformType <TransformType>k__BackingField;
    public string AreaOfUse { get; }
    public string Authority { get; }
    public long AuthorityCode { get; }
    public MathTransform MathTransform { get; }
    public string Name { get; }
    public string Remarks { get; }
    public CoordinateSystem SourceCS { get; }
    public CoordinateSystem TargetCS { get; }
    public TransformType TransformType { get; }
    internal CoordinateTransformation(CoordinateSystem sourceCS, CoordinateSystem targetCS, TransformType transformType, MathTransform mathTransform, string name, string authority, long authorityCode, string areaOfUse, string remarks);
    [CompilerGeneratedAttribute]
public sealed virtual string get_AreaOfUse();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Authority();
    [CompilerGeneratedAttribute]
public sealed virtual long get_AuthorityCode();
    [CompilerGeneratedAttribute]
public sealed virtual MathTransform get_MathTransform();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Remarks();
    [CompilerGeneratedAttribute]
public sealed virtual CoordinateSystem get_SourceCS();
    [CompilerGeneratedAttribute]
public sealed virtual CoordinateSystem get_TargetCS();
    [CompilerGeneratedAttribute]
public sealed virtual TransformType get_TransformType();
}
public class ProjNet.CoordinateSystems.Transformations.CoordinateTransformationFactory : object {
    public ICoordinateTransformation CreateFromCoordinateSystems(CoordinateSystem sourceCS, CoordinateSystem targetCS);
    private static void SimplifyTrans(ConcatenatedTransform mtrans, List`1& MTs);
    private static CoordinateTransformation Geog2Geoc(GeographicCoordinateSystem source, GeocentricCoordinateSystem target);
    private static CoordinateTransformation Geoc2Geog(GeocentricCoordinateSystem source, GeographicCoordinateSystem target);
    private static CoordinateTransformation Proj2Proj(ProjectedCoordinateSystem source, ProjectedCoordinateSystem target);
    private static CoordinateTransformation Geog2Proj(GeographicCoordinateSystem source, ProjectedCoordinateSystem target);
    private static CoordinateTransformation Proj2Geog(ProjectedCoordinateSystem source, GeographicCoordinateSystem target);
    private static ICoordinateTransformation CreateGeog2Geog(GeographicCoordinateSystem source, GeographicCoordinateSystem target);
    private static void AddIfNotNull(ConcatenatedTransform concatTrans, ICoordinateTransformation trans);
    private static CoordinateTransformation CreateGeoc2Geoc(GeocentricCoordinateSystem source, GeocentricCoordinateSystem target);
    private static CoordinateTransformation Fitt2Any(FittedCoordinateSystem source, CoordinateSystem target);
    private static CoordinateTransformation Any2Fitt(CoordinateSystem source, FittedCoordinateSystem target);
    private static MathTransform CreateFittedTransform(FittedCoordinateSystem fittedSystem);
    private static CoordinateTransformation CreateTransform(CoordinateSystem sourceCS, CoordinateSystem targetCS, TransformType transformType, MathTransform mathTransform);
    private static MathTransform CreateCoordinateOperation(GeocentricCoordinateSystem geo);
    private static MathTransform CreateCoordinateOperation(IProjection projection, Ellipsoid ellipsoid, LinearUnit unit);
}
internal class ProjNet.CoordinateSystems.Transformations.DatumTransform : MathTransform {
    private MathTransform _inverse;
    private Wgs84ConversionInfo _toWgs94;
    private Double[] _v;
    private bool _isInverse;
    public string WKT { get; }
    public string XML { get; }
    public int DimSource { get; }
    public int DimTarget { get; }
    public DatumTransform(Wgs84ConversionInfo towgs84);
    private DatumTransform(Wgs84ConversionInfo towgs84, bool isInverse);
    public virtual string get_WKT();
    public virtual string get_XML();
    public virtual int get_DimSource();
    public virtual int get_DimTarget();
    public virtual MathTransform Inverse();
    public sealed virtual void Transform(Double& x, Double& y, Double& z);
    private ValueTuple`3<double, double, double> Apply(double x, double y, double z);
    private ValueTuple`3<double, double, double> ApplyInverted(double x, double y, double z);
    public virtual void Invert();
}
public enum ProjNet.CoordinateSystems.Transformations.DomainFlags : Enum {
    public int value__;
    public static DomainFlags Inside;
    public static DomainFlags Outside;
    public static DomainFlags Discontinuous;
}
internal class ProjNet.CoordinateSystems.Transformations.GeocentricTransform : MathTransform {
    private static double COS_67P5;
    private static double AD_C;
    private bool _isInverse;
    private MathTransform _inverse;
    private double _es;
    private double _semiMajor;
    private double _semiMinor;
    private double _ses;
    private List`1<ProjectionParameter> _parameters;
    public int DimSource { get; }
    public int DimTarget { get; }
    public string WKT { get; }
    public string XML { get; }
    public GeocentricTransform(List`1<ProjectionParameter> parameters, bool isInverse);
    internal GeocentricTransform(List`1<ProjectionParameter> parameters);
    public virtual int get_DimSource();
    public virtual int get_DimTarget();
    public virtual MathTransform Inverse();
    private void DegreesToMeters(Double& lon, Double& lat, Double& z);
    private void MetersToDegrees(Double& x, Double& y, Double& z);
    public sealed virtual void Transform(Double& x, Double& y, Double& z);
    public virtual void Invert();
    public virtual string get_WKT();
    public virtual string get_XML();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__10_0(ProjectionParameter par);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__10_1(ProjectionParameter par);
}
public class ProjNet.CoordinateSystems.Transformations.GeographicTransform : MathTransform {
    [CompilerGeneratedAttribute]
private GeographicCoordinateSystem <SourceGCS>k__BackingField;
    [CompilerGeneratedAttribute]
private GeographicCoordinateSystem <TargetGCS>k__BackingField;
    public GeographicCoordinateSystem SourceGCS { get; public set; }
    public GeographicCoordinateSystem TargetGCS { get; public set; }
    public string WKT { get; }
    public string XML { get; }
    public int DimSource { get; }
    public int DimTarget { get; }
    internal GeographicTransform(GeographicCoordinateSystem sourceGCS, GeographicCoordinateSystem targetGCS);
    [CompilerGeneratedAttribute]
public GeographicCoordinateSystem get_SourceGCS();
    [CompilerGeneratedAttribute]
public void set_SourceGCS(GeographicCoordinateSystem value);
    [CompilerGeneratedAttribute]
public GeographicCoordinateSystem get_TargetGCS();
    [CompilerGeneratedAttribute]
public void set_TargetGCS(GeographicCoordinateSystem value);
    public virtual string get_WKT();
    public virtual string get_XML();
    public virtual int get_DimSource();
    public virtual int get_DimTarget();
    public virtual MathTransform Inverse();
    public sealed virtual void Transform(Double& x, Double& y, Double& z);
    public virtual void Invert();
}
public interface ProjNet.CoordinateSystems.Transformations.ICoordinateTransformation {
    public string AreaOfUse { get; }
    public string Authority { get; }
    public long AuthorityCode { get; }
    public string Name { get; }
    public string Remarks { get; }
    public MathTransform MathTransform { get; }
    public TransformType TransformType { get; }
    public abstract virtual string get_AreaOfUse();
    public abstract virtual string get_Authority();
    public abstract virtual long get_AuthorityCode();
    public abstract virtual string get_Name();
    public abstract virtual string get_Remarks();
    public abstract virtual MathTransform get_MathTransform();
    public abstract virtual TransformType get_TransformType();
}
public interface ProjNet.CoordinateSystems.Transformations.ICoordinateTransformationCore {
    public CoordinateSystem SourceCS { get; }
    public CoordinateSystem TargetCS { get; }
    public abstract virtual CoordinateSystem get_SourceCS();
    public abstract virtual CoordinateSystem get_TargetCS();
}
public abstract class ProjNet.CoordinateSystems.Transformations.MathTransform : object {
    protected static double D2R;
    protected static double R2D;
    public int DimSource { get; }
    public int DimTarget { get; }
    public string WKT { get; }
    public string XML { get; }
    public abstract virtual int get_DimSource();
    public abstract virtual int get_DimTarget();
    public virtual bool Identity();
    public abstract virtual string get_WKT();
    public abstract virtual string get_XML();
    public virtual Double[0...,0...] Derivative(Double[] point);
    public virtual List`1<double> GetCodomainConvexHull(List`1<double> points);
    public virtual DomainFlags GetDomainFlags(List`1<double> points);
    public abstract virtual MathTransform Inverse();
    public abstract virtual void Invert();
    protected static double DegreesToRadians(double deg);
    protected static void DegreesToRadians(Span`1<double> degrees, int stride);
    protected static double RadiansToDegrees(double rad);
    protected static void RadiansToDegrees(Span`1<double> radians, int stride);
    public Double[] Transform(Double[] point);
    public IList`1<Double[]> TransformList(IList`1<Double[]> points);
    public ValueTuple`2<double, double> Transform(double x, double y);
    public ValueTuple`3<double, double, double> Transform(double x, double y, double z);
    public void Transform(Double& x, Double& y);
    public abstract virtual void Transform(Double& x, Double& y, Double& z);
    protected virtual void TransformCore(Span`1<double> xs, Span`1<double> ys, Span`1<double> zs, int strideX, int strideY, int strideZ);
    public void Transform(Span`1<double> xs, Span`1<double> ys, int strideX, int strideY);
    public void Transform(Span`1<double> xs, Span`1<double> ys, Span`1<double> zs, int strideX, int strideY, int strideZ);
    public void Transform(Span`1<XY> xys, Span`1<double> zs, int strideZ);
    public void Transform(Span`1<XYZ> xyzs);
    protected static void AddInPlace(Span`1<double> vals, int stride, double addend);
    protected static void MultiplyInPlace(Span`1<double> vals, int stride, double multiplier);
    protected static void MultiplyThenAddInPlace(Span`1<double> vals, int stride, double multiplier, double addend);
    protected static void AddThenMultiplyInPlace(Span`1<double> vals, int stride, double addend, double multiplier);
}
internal class ProjNet.CoordinateSystems.Transformations.PrimeMeridianTransform : MathTransform {
    private bool _isInverted;
    private PrimeMeridian _source;
    private PrimeMeridian _target;
    public string WKT { get; }
    public string XML { get; }
    public int DimSource { get; }
    public int DimTarget { get; }
    public PrimeMeridianTransform(PrimeMeridian source, PrimeMeridian target);
    public virtual string get_WKT();
    public virtual string get_XML();
    public virtual int get_DimSource();
    public virtual int get_DimTarget();
    public virtual MathTransform Inverse();
    public sealed virtual void Transform(Double& x, Double& y, Double& z);
    protected sealed virtual void TransformCore(Span`1<double> xs, Span`1<double> ys, Span`1<double> zs, int strideX, int strideY, int strideZ);
    public virtual void Invert();
}
public enum ProjNet.CoordinateSystems.Transformations.TransformType : Enum {
    public int value__;
    public static TransformType Other;
    public static TransformType Conversion;
    public static TransformType Transformation;
    public static TransformType ConversionAndTransformation;
}
public class ProjNet.CoordinateSystems.Unit : Info {
    [CompilerGeneratedAttribute]
private double <ConversionFactor>k__BackingField;
    public double ConversionFactor { get; public set; }
    public string WKT { get; }
    public string XML { get; }
    internal Unit(double conversionFactor, string name, string authority, long authorityCode, string alias, string abbreviation, string remarks);
    internal Unit(string name, double conversionFactor);
    [CompilerGeneratedAttribute]
public double get_ConversionFactor();
    [CompilerGeneratedAttribute]
public void set_ConversionFactor(double value);
    public virtual string get_WKT();
    public virtual string get_XML();
    public virtual bool EqualParams(object obj);
}
public class ProjNet.CoordinateSystems.Wgs84ConversionInfo : object {
    private static double SEC_TO_RAD;
    public double Dx;
    public double Dy;
    public double Dz;
    public double Ex;
    public double Ey;
    public double Ez;
    public double Ppm;
    public string AreaOfUse;
    public string WKT { get; }
    public string XML { get; }
    public bool HasZeroValuesOnly { get; }
    public Wgs84ConversionInfo(double dx, double dy, double dz, double ex, double ey, double ez, double ppm);
    public Wgs84ConversionInfo(double dx, double dy, double dz, double ex, double ey, double ez, double ppm, string areaOfUse);
    public Double[] GetAffineTransform();
    public string get_WKT();
    public string get_XML();
    public virtual string ToString();
    public bool get_HasZeroValuesOnly();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool Equals(Wgs84ConversionInfo obj);
}
public class ProjNet.CoordinateSystemServices : object {
    private Dictionary`2<int, CoordinateSystem> _csBySrid;
    private Dictionary`2<IInfo, int> _sridByCs;
    private CoordinateSystemFactory _coordinateSystemFactory;
    private CoordinateTransformationFactory _ctFactory;
    private ManualResetEvent _initialization;
    protected int Count { get; }
    public CoordinateSystemServices(CoordinateSystemFactory coordinateSystemFactory, CoordinateTransformationFactory coordinateTransformationFactory);
    public CoordinateSystemServices(IEnumerable`1<KeyValuePair`2<int, string>> definitions);
    public CoordinateSystemServices(CoordinateSystemFactory coordinateSystemFactory, CoordinateTransformationFactory coordinateTransformationFactory, IEnumerable`1<KeyValuePair`2<int, string>> enumeration);
    private static CoordinateSystem CreateCoordinateSystem(CoordinateSystemFactory coordinateSystemFactory, string wkt);
    [IteratorStateMachineAttribute("ProjNet.CoordinateSystemServices/<DefaultInitialization>d__12")]
private static IEnumerable`1<KeyValuePair`2<int, CoordinateSystem>> DefaultInitialization();
    private static void FromEnumeration(CoordinateSystemServices css, IEnumerable`1<KeyValuePair`2<int, CoordinateSystem>> enumeration);
    [IteratorStateMachineAttribute("ProjNet.CoordinateSystemServices/<CreateCoordinateSystems>d__14")]
private static IEnumerable`1<KeyValuePair`2<int, CoordinateSystem>> CreateCoordinateSystems(CoordinateSystemFactory factory, IEnumerable`1<KeyValuePair`2<int, string>> enumeration);
    private static void FromEnumeration(CoordinateSystemServices css, IEnumerable`1<KeyValuePair`2<int, string>> enumeration);
    private static void FromEnumeration(object parameter);
    public CoordinateSystem GetCoordinateSystem(int srid);
    public CoordinateSystem GetCoordinateSystem(string authority, long code);
    public Nullable`1<int> GetSRID(string authority, long authorityCode);
    public ICoordinateTransformation CreateTransformation(int sourceSrid, int targetSrid);
    public ICoordinateTransformation CreateTransformation(CoordinateSystem source, CoordinateSystem target);
    protected void AddCoordinateSystem(int srid, CoordinateSystem coordinateSystem);
    protected virtual int AddCoordinateSystem(CoordinateSystem coordinateSystem);
    protected void Clear();
    protected int get_Count();
    public bool RemoveCoordinateSystem(int srid);
    public IEnumerator`1<KeyValuePair`2<int, CoordinateSystem>> GetEnumerator();
}
public class ProjNet.Geometries.XY : ValueType {
    public double X;
    public double Y;
    public XY(double x, double y);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(XY other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class ProjNet.Geometries.XYZ : ValueType {
    public double X;
    public double Y;
    public double Z;
    public XYZ(double x, double y, double z);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(XYZ other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public static class ProjNet.IO.CoordinateSystems.CoordinateSystemWktReader : object {
    public static IInfo Parse(string wkt);
    private static IUnit ReadUnit(WktStreamTokenizer tokenizer);
    private static LinearUnit ReadLinearUnit(WktStreamTokenizer tokenizer);
    private static AngularUnit ReadAngularUnit(WktStreamTokenizer tokenizer);
    private static AxisInfo ReadAxis(WktStreamTokenizer tokenizer);
    private static CoordinateSystem ReadCoordinateSystem(string coordinateSystem, WktStreamTokenizer tokenizer);
    private static Wgs84ConversionInfo ReadWGS84ConversionInfo(WktStreamTokenizer tokenizer);
    private static Ellipsoid ReadEllipsoid(WktStreamTokenizer tokenizer);
    private static IProjection ReadProjection(WktStreamTokenizer tokenizer);
    private static ProjectedCoordinateSystem ReadProjectedCoordinateSystem(WktStreamTokenizer tokenizer);
    private static GeocentricCoordinateSystem ReadGeocentricCoordinateSystem(WktStreamTokenizer tokenizer);
    private static GeographicCoordinateSystem ReadGeographicCoordinateSystem(WktStreamTokenizer tokenizer);
    private static HorizontalDatum ReadHorizontalDatum(WktStreamTokenizer tokenizer);
    private static PrimeMeridian ReadPrimeMeridian(WktStreamTokenizer tokenizer);
    private static FittedCoordinateSystem ReadFittedCoordinateSystem(WktStreamTokenizer tokenizer);
}
public static class ProjNet.IO.CoordinateSystems.MathTransformWktReader : object {
    public static MathTransform Parse(string wkt);
    internal static MathTransform ReadMathTransform(WktStreamTokenizer tokenizer);
    private static ParameterInfo ReadParameters(WktStreamTokenizer tokenizer);
    private static MathTransform ReadAffineTransform(WktStreamTokenizer tokenizer);
}
internal class ProjNet.IO.CoordinateSystems.StreamTokenizer : object {
    private NumberFormatInfo _nfi;
    private TokenType _currentTokenType;
    private TextReader _reader;
    private string _currentToken;
    private int _lineNumber;
    private int _colNumber;
    private bool _ignoreWhitespace;
    public int LineNumber { get; }
    public int Column { get; }
    public bool IgnoreWhitespace { get; }
    public StreamTokenizer(TextReader reader, bool ignoreWhitespace);
    public int get_LineNumber();
    public int get_Column();
    public bool get_IgnoreWhitespace();
    public double GetNumericValue();
    public string GetStringValue();
    public TokenType GetTokenType();
    public TokenType NextToken(bool ignoreWhitespace);
    public TokenType NextToken();
    private TokenType NextTokenAny();
    private static TokenType GetType(char character);
    private TokenType NextNonWhitespaceToken();
}
internal enum ProjNet.IO.CoordinateSystems.TokenType : Enum {
    public int value__;
    public static TokenType Word;
    public static TokenType Number;
    public static TokenType Eol;
    public static TokenType Eof;
    public static TokenType Whitespace;
    public static TokenType Symbol;
}
internal class ProjNet.IO.CoordinateSystems.WktStreamTokenizer : StreamTokenizer {
    private NumberFormatInfo _nfi;
    public WktStreamTokenizer(TextReader reader);
    internal void ReadToken(string expectedToken);
    public string ReadDoubleQuotedWord();
    public void ReadAuthority(String& authority, Int64& authorityCode);
}
