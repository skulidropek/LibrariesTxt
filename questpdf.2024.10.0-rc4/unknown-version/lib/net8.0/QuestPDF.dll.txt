[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class QuestPDF.Companion.CompanionCommands : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class QuestPDF.Companion.CompanionExtensions : object {
    private static CompanionExtensions();
    [ExtensionAttribute]
public static void ShowInCompanion(IDocument document, int port);
    [AsyncStateMachineAttribute("QuestPDF.Companion.CompanionExtensions/<ShowInCompanionAsync>d__2")]
[ExtensionAttribute]
public static Task ShowInCompanionAsync(IDocument document, int port, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("QuestPDF.Companion.CompanionExtensions/<<ShowInCompanionAsync>g__KeepApplicationAlive|2_3>d")]
[CompilerGeneratedAttribute]
internal static Task <ShowInCompanionAsync>g__KeepApplicationAlive|2_3(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class QuestPDF.Companion.CompanionModelHelpers : object {
    [ExtensionAttribute]
internal static DocumentHierarchyElement ExtractHierarchy(Element container);
    [NullableContextAttribute("2")]
private static SourceCodePath GetSourceCodePath(Nullable`1<SourceCodePath> path);
    [ExtensionAttribute]
internal static StackFrame[] ParseStackTrace(string stackTrace);
    [ExtensionAttribute]
internal static DocumentHierarchyElement ImproveHierarchyStructure(DocumentHierarchyElement root);
    [CompilerGeneratedAttribute]
internal static DocumentHierarchyElement <ExtractHierarchy>g__Traverse|0_0(TreeNode`1<LayoutProxy> node);
    [CompilerGeneratedAttribute]
internal static DocumentHierarchyElement <ImproveHierarchyStructure>g__FindDebugPointers|3_2(DocumentHierarchyElement element, <>c__DisplayClass3_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Companion.CompanionService : object {
    [CompilerGeneratedAttribute]
private int <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpClient <HttpClient>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Action OnCompanionStopped;
    private static int RequiredCompanionApiVersion;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private static CompanionDocumentSnapshot <CurrentDocumentSnapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsCompanionAttached>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsDocumentHotReloaded>k__BackingField;
    private JsonSerializerOptions JsonSerializerOptions;
    private int Port { get; }
    private HttpClient HttpClient { get; }
    [NullableAttribute("2")]
private static CompanionDocumentSnapshot CurrentDocumentSnapshot { get; private set; }
    public static bool IsCompanionAttached { get; private set; }
    public static bool IsDocumentHotReloaded { get; public set; }
    public CompanionService(int port);
    [CompilerGeneratedAttribute]
private int get_Port();
    [CompilerGeneratedAttribute]
private HttpClient get_HttpClient();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void add_OnCompanionStopped(Action value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void remove_OnCompanionStopped(Action value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private static CompanionDocumentSnapshot get_CurrentDocumentSnapshot();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private static void set_CurrentDocumentSnapshot(CompanionDocumentSnapshot value);
    [CompilerGeneratedAttribute]
public static bool get_IsCompanionAttached();
    [CompilerGeneratedAttribute]
private static void set_IsCompanionAttached(bool value);
    [CompilerGeneratedAttribute]
public static bool get_IsDocumentHotReloaded();
    [CompilerGeneratedAttribute]
public static void set_IsDocumentHotReloaded(bool value);
    [AsyncStateMachineAttribute("QuestPDF.Companion.CompanionService/<Connect>d__24")]
public Task Connect();
    [AsyncStateMachineAttribute("QuestPDF.Companion.CompanionService/<CheckIfCompanionIsRunning>d__25")]
private Task CheckIfCompanionIsRunning();
    [AsyncStateMachineAttribute("QuestPDF.Companion.CompanionService/<StartNotifyPresenceTask>d__26")]
internal Task StartNotifyPresenceTask();
    [AsyncStateMachineAttribute("QuestPDF.Companion.CompanionService/<CheckCompanionVersionCompatibility>d__27")]
private Task CheckCompanionVersionCompatibility();
    [AsyncStateMachineAttribute("QuestPDF.Companion.CompanionService/<RefreshPreview>d__28")]
public Task RefreshPreview(CompanionDocumentSnapshot companionDocumentSnapshot);
    public void StartRenderRequestedPageSnapshotsTask(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("QuestPDF.Companion.CompanionService/<RenderRequestedPageSnapshots>d__30")]
private Task RenderRequestedPageSnapshots();
    [AsyncStateMachineAttribute("QuestPDF.Companion.CompanionService/<InformAboutGenericException>d__31")]
internal Task InformAboutGenericException(Exception exception);
    [CompilerGeneratedAttribute]
internal static GenericExceptionDetails <InformAboutGenericException>g__Map|31_0(Exception exception);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class QuestPDF.Companion.HotReloadManager : object {
    [CompilerGeneratedAttribute]
private static EventHandler UpdateApplicationRequested;
    [CompilerGeneratedAttribute]
public static void add_UpdateApplicationRequested(EventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_UpdateApplicationRequested(EventHandler value);
    public static void UpdateApplication(Type[] _);
}
internal class QuestPDF.Companion.PageSnapshotIndex : object {
    [CompilerGeneratedAttribute]
private int <PageIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ZoomLevel>k__BackingField;
    public int PageIndex { get; public set; }
    public int ZoomLevel { get; public set; }
    [CompilerGeneratedAttribute]
public int get_PageIndex();
    [CompilerGeneratedAttribute]
public void set_PageIndex(int value);
    [CompilerGeneratedAttribute]
public int get_ZoomLevel();
    [CompilerGeneratedAttribute]
public void set_ZoomLevel(int value);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Drawing.CompanionCanvas : SkiaCanvasBase {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SkPictureRecorder <PictureRecorder>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Size> <CurrentPageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<CompanionPageSnapshot> <PageSnapshots>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentHierarchyElement <Hierarchy>k__BackingField;
    [NullableAttribute("2")]
private SkPictureRecorder PictureRecorder { get; private set; }
    private Nullable`1<Size> CurrentPageSize { get; private set; }
    private ICollection`1<CompanionPageSnapshot> PageSnapshots { get; }
    internal DocumentHierarchyElement Hierarchy { get; internal set; }
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private SkPictureRecorder get_PictureRecorder();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_PictureRecorder(SkPictureRecorder value);
    [CompilerGeneratedAttribute]
private Nullable`1<Size> get_CurrentPageSize();
    [CompilerGeneratedAttribute]
private void set_CurrentPageSize(Nullable`1<Size> value);
    [CompilerGeneratedAttribute]
private ICollection`1<CompanionPageSnapshot> get_PageSnapshots();
    [CompilerGeneratedAttribute]
internal DocumentHierarchyElement get_Hierarchy();
    [CompilerGeneratedAttribute]
internal void set_Hierarchy(DocumentHierarchyElement value);
    public virtual void BeginDocument();
    public virtual void BeginPage(Size size);
    public virtual void EndPage();
    public virtual void EndDocument();
    public CompanionDocumentSnapshot GetContent();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Drawing.CompanionDocumentSnapshot : object {
    [CompilerGeneratedAttribute]
private ICollection`1<CompanionPageSnapshot> <Pictures>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DocumentContentHasLayoutOverflowIssues>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentHierarchyElement <Hierarchy>k__BackingField;
    public ICollection`1<CompanionPageSnapshot> Pictures { get; public set; }
    public bool DocumentContentHasLayoutOverflowIssues { get; public set; }
    public DocumentHierarchyElement Hierarchy { get; public set; }
    [CompilerGeneratedAttribute]
public ICollection`1<CompanionPageSnapshot> get_Pictures();
    [CompilerGeneratedAttribute]
public void set_Pictures(ICollection`1<CompanionPageSnapshot> value);
    [CompilerGeneratedAttribute]
public bool get_DocumentContentHasLayoutOverflowIssues();
    [CompilerGeneratedAttribute]
public void set_DocumentContentHasLayoutOverflowIssues(bool value);
    [CompilerGeneratedAttribute]
public DocumentHierarchyElement get_Hierarchy();
    [CompilerGeneratedAttribute]
public void set_Hierarchy(DocumentHierarchyElement value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Drawing.CompanionPageSnapshot : object {
    [CompilerGeneratedAttribute]
private SkPicture <Picture>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Size>k__BackingField;
    public SkPicture Picture { get; public set; }
    public Size Size { get; public set; }
    public CompanionPageSnapshot(SkPicture picture, Size size);
    [CompilerGeneratedAttribute]
public SkPicture get_Picture();
    [CompilerGeneratedAttribute]
public void set_Picture(SkPicture value);
    [CompilerGeneratedAttribute]
public Size get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(Size value);
    public Byte[] RenderImage(int zoomLevel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Drawing.DocumentContainer : object {
    [CompilerGeneratedAttribute]
private List`1<IComponent> <Pages>k__BackingField;
    internal List`1<IComponent> Pages { get; internal set; }
    [CompilerGeneratedAttribute]
internal List`1<IComponent> get_Pages();
    [CompilerGeneratedAttribute]
internal void set_Pages(List`1<IComponent> value);
    internal Container Compose();
    [CompilerGeneratedAttribute]
private void <Compose>g__ComposeContainer|4_0(IContainer container);
    [CompilerGeneratedAttribute]
private void <Compose>b__4_1(ColumnDescriptor column);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class QuestPDF.Drawing.DocumentGenerator : object {
    private static DocumentGenerator();
    internal static void GeneratePdf(SkWriteStream stream, IDocument document);
    internal static void GenerateXps(SkWriteStream stream, IDocument document);
    internal static ICollection`1<Byte[]> GenerateImages(IDocument document, ImageGenerationSettings imageGenerationSettings);
    internal static ICollection`1<string> GenerateSvg(IDocument document);
    internal static void ValidateLicense();
    internal static CompanionDocumentSnapshot GenerateCompanionContent(IDocument document);
    private static void RenderDocument(TCanvas canvas, IDocument document, DocumentSettings settings);
    private static void RenderSingleDocument(TCanvas canvas, IDocument document, DocumentSettings settings);
    private static void RenderMergedDocument(TCanvas canvas, MergedDocument document, DocumentSettings settings);
    private static Container ConfigureContent(IDocument document, DocumentSettings settings, bool useOriginalImages);
    private static void RenderPass(PageContext pageContext, TCanvas canvas, ContainerElement content);
    [ExtensionAttribute]
internal static void InjectDependencies(Element content, IPageContext pageContext, ICanvas canvas);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static void ApplyCaching(Element content);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static void ApplyContentDirection(Element content, Nullable`1<ContentDirection> direction);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static void ApplyDefaultImageConfiguration(Element content, int imageRasterDpi, ImageCompressionQuality imageCompressionQuality, bool useOriginalImages);
    [ExtensionAttribute]
internal static void ApplyInheritedAndGlobalTexStyle(Element content, TextStyle documentDefaultTextStyle);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static void <RenderPass>g__ApplyLayoutDebugging|11_1(<>c__DisplayClass11_0`1& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static void <RenderPass>g__ThrowLayoutException|11_2(<>c__DisplayClass11_0`1& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static ValueTuple`2<ICollection`1<Element>, TreeNode`1<OverflowDebuggingProxy>> <RenderPass>g__GenerateLayoutExceptionDebuggingInfo|11_3(<>c__DisplayClass11_0`1& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <ApplyCaching>g__Traverse|13_1(Element content);
}
public class QuestPDF.Drawing.Exceptions.DocumentComposeException : Exception {
    [NullableContextAttribute("1")]
internal DocumentComposeException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Drawing.Exceptions.DocumentDrawingException : Exception {
    internal DocumentDrawingException(string message);
    internal DocumentDrawingException(string message, Exception inner);
}
public class QuestPDF.Drawing.Exceptions.DocumentLayoutException : Exception {
    [NullableContextAttribute("1")]
internal DocumentLayoutException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Drawing.Exceptions.InitializationException : Exception {
    internal InitializationException(string message);
    internal InitializationException(string message, Exception inner);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class QuestPDF.Drawing.FontManager : object {
    [CompilerGeneratedAttribute]
private static SkTypefaceProvider <TypefaceProvider>k__BackingField;
    internal static SkTypefaceProvider TypefaceProvider { get; }
    internal static SkFontManager CurrentFontManager { get; }
    private static FontManager();
    [CompilerGeneratedAttribute]
internal static SkTypefaceProvider get_TypefaceProvider();
    internal static SkFontManager get_CurrentFontManager();
    [ObsoleteAttribute("Since version 2022.8 this method has been renamed. Please use the RegisterFontWithCustomName method.")]
public static void RegisterFontType(string fontName, Stream stream);
    public static void RegisterFontWithCustomName(string fontName, Stream stream);
    public static void RegisterFont(Stream stream);
    public static void RegisterFontFromEmbeddedResource(string pathName);
    private static void RegisterLibraryDefaultFonts();
    [CompilerGeneratedAttribute]
internal static ICollection`1<string> <RegisterLibraryDefaultFonts>g__SearchFontFiles|10_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Drawing.FreeCanvas : object {
    [CompilerGeneratedAttribute]
private bool <DocumentContentHasLayoutOverflowIssues>k__BackingField;
    public bool DocumentContentHasLayoutOverflowIssues { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DocumentContentHasLayoutOverflowIssues();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DocumentContentHasLayoutOverflowIssues(bool value);
    public sealed virtual void BeginDocument();
    public sealed virtual void EndDocument();
    public sealed virtual void BeginPage(Size size);
    public sealed virtual void EndPage();
    public sealed virtual void MarkCurrentPageAsHavingLayoutIssues();
    public sealed virtual void Save();
    public sealed virtual void Restore();
    public sealed virtual void Translate(Position vector);
    public sealed virtual void DrawFilledRectangle(Position vector, Size size, Color color);
    public sealed virtual void DrawStrokeRectangle(Position vector, Size size, float strokeWidth, Color color);
    public sealed virtual void DrawParagraph(SkParagraph paragraph);
    public sealed virtual void DrawImage(SkImage image, Size size);
    public sealed virtual void DrawPicture(SkPicture picture);
    public sealed virtual void DrawSvgPath(string path, Color color);
    public sealed virtual void DrawSvg(SkSvgImage svgImage, Size size);
    public sealed virtual void DrawOverflowArea(SkRect area);
    public sealed virtual void ClipOverflowArea(SkRect availableSpace, SkRect requiredSpace);
    public sealed virtual void ClipRectangle(SkRect clipArea);
    public sealed virtual void DrawHyperlink(string url, Size size);
    public sealed virtual void DrawSectionLink(string sectionName, Size size);
    public sealed virtual void DrawSection(string sectionName);
    public sealed virtual void Rotate(float angle);
    public sealed virtual void Scale(float scaleX, float scaleY);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Drawing.ImageCanvas : SkiaCanvasBase {
    [CompilerGeneratedAttribute]
private ImageGenerationSettings <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private SkBitmap <Bitmap>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<Byte[]> <Images>k__BackingField;
    private ImageGenerationSettings Settings { get; }
    private SkBitmap Bitmap { get; private set; }
    internal ICollection`1<Byte[]> Images { get; }
    public ImageCanvas(ImageGenerationSettings settings);
    [CompilerGeneratedAttribute]
private ImageGenerationSettings get_Settings();
    [CompilerGeneratedAttribute]
private SkBitmap get_Bitmap();
    [CompilerGeneratedAttribute]
private void set_Bitmap(SkBitmap value);
    [CompilerGeneratedAttribute]
internal ICollection`1<Byte[]> get_Images();
    protected virtual override void Finalize();
    public virtual void BeginDocument();
    public virtual void EndDocument();
    public virtual void BeginPage(Size size);
    public virtual void EndPage();
    [CompilerGeneratedAttribute]
private SkData <EndPage>g__EncodeBitmap|15_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Drawing.PdfCanvas : SkiaDocumentCanvasBase {
    public PdfCanvas(SkWriteStream stream, DocumentMetadata documentMetadata, DocumentSettings documentSettings);
    private static SkDocument CreatePdf(SkWriteStream stream, DocumentMetadata documentMetadata, DocumentSettings documentSettings);
}
internal class QuestPDF.Drawing.Proxy.ElementProxy : ContainerElement {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class QuestPDF.Drawing.Proxy.LayoutDebugging : object {
    public static string LayoutVisualizationLegend;
    [ExtensionAttribute]
internal static SpacePlan TryMeasureWithOverflow(Element element, Size availableSpace);
    [ExtensionAttribute]
public static void ApplyLayoutOverflowDetection(Element container);
    [ExtensionAttribute]
public static void ApplyLayoutOverflowVisualization(TreeNode`1<OverflowDebuggingProxy> hierarchyRoot);
    [ExtensionAttribute]
public static void RemoveExistingProxies(Element content);
    [ExtensionAttribute]
public static void RemoveExistingProxiesOfType(Element content);
    [ExtensionAttribute]
public static void StopMeasuring(TreeNode`1<OverflowDebuggingProxy> parent);
    [ExtensionAttribute]
public static IEnumerable`1<TreeNode`1<OverflowDebuggingProxy>> FindLayoutOverflowVisualizationNodes(TreeNode`1<OverflowDebuggingProxy> rootNode);
    [ExtensionAttribute]
public static string FormatAncestors(IEnumerable`1<Element> ancestors);
    [ExtensionAttribute]
public static string FormatLayoutSubtree(TreeNode`1<OverflowDebuggingProxy> root);
    [ExtensionAttribute]
public static IEnumerable`1<ValueTuple`2<string, string>> GetElementConfiguration(IElement element);
    [CompilerGeneratedAttribute]
internal static Nullable`1<SpacePlan> <TryMeasureWithOverflow>g__TryOverflow|0_0(Size targetSpace, <>c__DisplayClass0_0& );
    [CompilerGeneratedAttribute]
internal static Nullable`1<SpacePlan> <TryMeasureWithOverflow>g__TryVerticalOverflow|0_1(<>c__DisplayClass0_0& );
    [CompilerGeneratedAttribute]
internal static Nullable`1<SpacePlan> <TryMeasureWithOverflow>g__TryHorizontalOverflow|0_2(<>c__DisplayClass0_0& );
    [CompilerGeneratedAttribute]
internal static Nullable`1<SpacePlan> <TryMeasureWithOverflow>g__TryUnconstrainedOverflow|0_3(<>c__DisplayClass0_0& );
    [CompilerGeneratedAttribute]
internal static void <ApplyLayoutOverflowVisualization>g__Traverse|2_0(TreeNode`1<OverflowDebuggingProxy> element);
    [CompilerGeneratedAttribute]
internal static SpacePlanType <ApplyLayoutOverflowVisualization>g__MeasureElementWithExtendedSpace|2_4(<>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static void <FindLayoutOverflowVisualizationNodes>g__Traverse|6_0(TreeNode`1<OverflowDebuggingProxy> node, <>c__DisplayClass6_0& );
    [CompilerGeneratedAttribute]
internal static void <FormatAncestors>g__Format|7_0(Element node, <>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
internal static void <FormatLayoutSubtree>g__Traverse|8_2(TreeNode`1<OverflowDebuggingProxy> parent, <>c__DisplayClass8_0& );
    [IteratorStateMachineAttribute("QuestPDF.Drawing.Proxy.LayoutDebugging/<<FormatLayoutSubtree>g__Format|8_3>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<string> <FormatLayoutSubtree>g__Format|8_3(OverflowDebuggingProxy proxy);
    [CompilerGeneratedAttribute]
internal static string <FormatLayoutSubtree>g__GetTitle|8_4(<>c__DisplayClass8_1& );
}
internal class QuestPDF.Drawing.Proxy.LayoutOverflowVisualization : ElementProxy {
    private static float BorderThickness;
    private Color LineColor;
    private Color AvailableAreaColor;
    private static byte AreaOpacity;
    [CompilerGeneratedAttribute]
private ContentDirection <ContentDirection>k__BackingField;
    public ContentDirection ContentDirection { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual ContentDirection get_ContentDirection();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ContentDirection(ContentDirection value);
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
    private void DrawOverflowArea(Size availableSpace, Size contentSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Drawing.Proxy.LayoutProxy : ElementProxy {
    [CompilerGeneratedAttribute]
private List`1<PageLocation> <Snapshots>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<LayoutErrorMeasurement> <LayoutErrorMeasurements>k__BackingField;
    public List`1<PageLocation> Snapshots { get; }
    public List`1<LayoutErrorMeasurement> LayoutErrorMeasurements { get; }
    public LayoutProxy(Element child);
    [CompilerGeneratedAttribute]
public List`1<PageLocation> get_Snapshots();
    [CompilerGeneratedAttribute]
public List`1<LayoutErrorMeasurement> get_LayoutErrorMeasurements();
    internal virtual void Draw(Size availableSpace);
    internal void CaptureLayoutErrorMeasurement();
    [CompilerGeneratedAttribute]
private bool <Draw>g__ProvideIntrinsicSize|7_0();
}
internal class QuestPDF.Drawing.Proxy.OverflowDebuggingProxy : ElementProxy {
    [CompilerGeneratedAttribute]
private bool <IsMeasuring>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Size> <AvailableSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SpacePlan> <SpacePlan>k__BackingField;
    public bool IsMeasuring { get; private set; }
    public Nullable`1<Size> AvailableSpace { get; private set; }
    public Nullable`1<SpacePlan> SpacePlan { get; private set; }
    [NullableContextAttribute("1")]
public OverflowDebuggingProxy(Element child);
    [CompilerGeneratedAttribute]
public bool get_IsMeasuring();
    [CompilerGeneratedAttribute]
private void set_IsMeasuring(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<Size> get_AvailableSpace();
    [CompilerGeneratedAttribute]
private void set_AvailableSpace(Nullable`1<Size> value);
    [CompilerGeneratedAttribute]
public Nullable`1<SpacePlan> get_SpacePlan();
    [CompilerGeneratedAttribute]
private void set_SpacePlan(Nullable`1<SpacePlan> value);
    internal virtual SpacePlan Measure(Size availableSpace);
    public void StopMeasuring();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Drawing.Proxy.SnapshotRecorder : ElementProxy {
    [CompilerGeneratedAttribute]
private SnapshotRecorderCanvas <RecorderCanvas>k__BackingField;
    [CompilerGeneratedAttribute]
private SkPictureRecorder <PictureRecorder>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<ValueTuple`3<int, float, float>, SpacePlan> <MeasureCache>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<int, SkPicture> <DrawCache>k__BackingField;
    private SnapshotRecorderCanvas RecorderCanvas { get; }
    private SkPictureRecorder PictureRecorder { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ValueTuple`3<int, float, float>, SpacePlan> MeasureCache { get; }
    private Dictionary`2<int, SkPicture> DrawCache { get; }
    public SnapshotRecorder(Element child);
    [CompilerGeneratedAttribute]
private SnapshotRecorderCanvas get_RecorderCanvas();
    [CompilerGeneratedAttribute]
private SkPictureRecorder get_PictureRecorder();
    [CompilerGeneratedAttribute]
private Dictionary`2<ValueTuple`3<int, float, float>, SpacePlan> get_MeasureCache();
    [CompilerGeneratedAttribute]
private Dictionary`2<int, SkPicture> get_DrawCache();
    protected virtual override void Finalize();
    private void Initialize();
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void <Initialize>b__14_0(Element x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Drawing.Proxy.TreeNode`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private TreeNode`1<T> <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<TreeNode`1<T>> <Children>k__BackingField;
    public T Value { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public TreeNode`1<T> Parent { get; public set; }
    public ICollection`1<TreeNode`1<T>> Children { get; }
    public TreeNode`1(T Value);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public TreeNode`1<T> get_Parent();
    [CompilerGeneratedAttribute]
public void set_Parent(TreeNode`1<T> value);
    [CompilerGeneratedAttribute]
public ICollection`1<TreeNode`1<T>> get_Children();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class QuestPDF.Drawing.Proxy.TreeTraversal : object {
    [IteratorStateMachineAttribute("QuestPDF.Drawing.Proxy.TreeTraversal/<ExtractElementsOfType>d__0`1")]
[ExtensionAttribute]
public static IEnumerable`1<TreeNode`1<T>> ExtractElementsOfType(Element element);
    [IteratorStateMachineAttribute("QuestPDF.Drawing.Proxy.TreeTraversal/<Flatten>d__1`1")]
[ExtensionAttribute]
public static IEnumerable`1<TreeNode`1<T>> Flatten(TreeNode`1<T> element);
    [IteratorStateMachineAttribute("QuestPDF.Drawing.Proxy.TreeTraversal/<ExtractAncestors>d__2`1")]
[ExtensionAttribute]
public static IEnumerable`1<TreeNode`1<T>> ExtractAncestors(TreeNode`1<T> node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Drawing.ProxyCanvas : object {
    [CompilerGeneratedAttribute]
private ICanvas <Target>k__BackingField;
    public ICanvas Target { get; public set; }
    [CompilerGeneratedAttribute]
public ICanvas get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(ICanvas value);
    public sealed virtual void Save();
    public sealed virtual void Restore();
    public sealed virtual void Translate(Position vector);
    public sealed virtual void DrawFilledRectangle(Position vector, Size size, Color color);
    public sealed virtual void DrawStrokeRectangle(Position vector, Size size, float strokeWidth, Color color);
    public sealed virtual void DrawParagraph(SkParagraph paragraph);
    public sealed virtual void DrawImage(SkImage image, Size size);
    public sealed virtual void DrawPicture(SkPicture picture);
    public sealed virtual void DrawSvgPath(string path, Color color);
    public sealed virtual void DrawSvg(SkSvgImage svgImage, Size size);
    public sealed virtual void DrawOverflowArea(SkRect area);
    public sealed virtual void ClipOverflowArea(SkRect availableSpace, SkRect requiredSpace);
    public sealed virtual void ClipRectangle(SkRect clipArea);
    public sealed virtual void DrawHyperlink(string url, Size size);
    public sealed virtual void DrawSectionLink(string sectionName, Size size);
    public sealed virtual void DrawSection(string sectionName);
    public sealed virtual void Rotate(float angle);
    public sealed virtual void Scale(float scaleX, float scaleY);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class QuestPDF.Drawing.SkiaCanvasBase : object {
    [CompilerGeneratedAttribute]
private SkCanvas <Canvas>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DocumentContentHasLayoutOverflowIssues>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <CurrentPageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CurrentPageHasLayoutIssues>k__BackingField;
    internal SkCanvas Canvas { get; internal set; }
    public bool DocumentContentHasLayoutOverflowIssues { get; public set; }
    private Size CurrentPageSize { get; private set; }
    private bool CurrentPageHasLayoutIssues { get; private set; }
    [CompilerGeneratedAttribute]
internal SkCanvas get_Canvas();
    [CompilerGeneratedAttribute]
internal void set_Canvas(SkCanvas value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DocumentContentHasLayoutOverflowIssues();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DocumentContentHasLayoutOverflowIssues(bool value);
    [CompilerGeneratedAttribute]
private Size get_CurrentPageSize();
    [CompilerGeneratedAttribute]
private void set_CurrentPageSize(Size value);
    [CompilerGeneratedAttribute]
private bool get_CurrentPageHasLayoutIssues();
    [CompilerGeneratedAttribute]
private void set_CurrentPageHasLayoutIssues(bool value);
    public abstract virtual void BeginDocument();
    public abstract virtual void EndDocument();
    public virtual void BeginPage(Size size);
    public virtual void EndPage();
    public sealed virtual void MarkCurrentPageAsHavingLayoutIssues();
    private void DrawLayoutIssuesIndicatorOnCurrentPage();
    public sealed virtual void Save();
    public sealed virtual void Restore();
    public sealed virtual void Translate(Position vector);
    public sealed virtual void DrawFilledRectangle(Position vector, Size size, Color color);
    public sealed virtual void DrawStrokeRectangle(Position vector, Size size, float strokeWidth, Color color);
    public sealed virtual void DrawParagraph(SkParagraph paragraph);
    public sealed virtual void DrawImage(SkImage image, Size size);
    public sealed virtual void DrawPicture(SkPicture picture);
    public sealed virtual void DrawSvgPath(string path, Color color);
    public sealed virtual void DrawSvg(SkSvgImage svgImage, Size size);
    public sealed virtual void DrawOverflowArea(SkRect area);
    public sealed virtual void ClipOverflowArea(SkRect availableSpace, SkRect requiredSpace);
    public sealed virtual void ClipRectangle(SkRect clipArea);
    public sealed virtual void DrawHyperlink(string url, Size size);
    public sealed virtual void DrawSectionLink(string sectionName, Size size);
    public sealed virtual void DrawSection(string sectionName);
    public sealed virtual void Rotate(float angle);
    public sealed virtual void Scale(float scaleX, float scaleY);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class QuestPDF.Drawing.SkiaDocumentCanvasBase : SkiaCanvasBase {
    [CompilerGeneratedAttribute]
private SkDocument <Document>k__BackingField;
    private SkDocument Document { get; }
    [NullableContextAttribute("1")]
protected SkiaDocumentCanvasBase(SkDocument document);
    [CompilerGeneratedAttribute]
private SkDocument get_Document();
    protected virtual override void Finalize();
    public virtual void BeginDocument();
    public virtual void EndDocument();
    public virtual void BeginPage(Size size);
    public virtual void EndPage();
}
internal class QuestPDF.Drawing.SnapshotRecorderCanvas : SkiaCanvasBase {
    public virtual void BeginDocument();
    public virtual void EndDocument();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class QuestPDF.Drawing.SpacePlan : ValueType {
    public SpacePlanType Type;
    public float Width;
    public float Height;
    [NullableAttribute("2")]
public string WrapReason;
    [NullableContextAttribute("2")]
internal SpacePlan(SpacePlanType type, float width, float height, string wrapReason);
    internal static SpacePlan Empty();
    internal static SpacePlan Wrap(string reason);
    internal static SpacePlan PartialRender(float width, float height);
    internal static SpacePlan PartialRender(Size size);
    internal static SpacePlan FullRender(float width, float height);
    internal static SpacePlan FullRender(Size size);
    public virtual string ToString();
    public static Size op_Implicit(SpacePlan spacePlan);
}
internal enum QuestPDF.Drawing.SpacePlanType : Enum {
    public int value__;
    public static SpacePlanType Empty;
    public static SpacePlanType Wrap;
    public static SpacePlanType PartialRender;
    public static SpacePlanType FullRender;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Drawing.SvgCanvas : SkiaCanvasBase {
    [CompilerGeneratedAttribute]
private SkWriteStream <WriteStream>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<string> <Images>k__BackingField;
    internal SkWriteStream WriteStream { get; internal set; }
    internal ICollection`1<string> Images { get; }
    [CompilerGeneratedAttribute]
internal SkWriteStream get_WriteStream();
    [CompilerGeneratedAttribute]
internal void set_WriteStream(SkWriteStream value);
    [CompilerGeneratedAttribute]
internal ICollection`1<string> get_Images();
    protected virtual override void Finalize();
    public virtual void BeginDocument();
    public virtual void EndDocument();
    public virtual void BeginPage(Size size);
    public virtual void EndPage();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Drawing.XpsCanvas : SkiaDocumentCanvasBase {
    public XpsCanvas(SkWriteStream stream, DocumentSettings documentSettings);
    private static SkDocument CreateXps(SkWriteStream stream, DocumentSettings documentSettings);
}
internal class QuestPDF.Elements.Alignment : ContainerElement {
    [CompilerGeneratedAttribute]
private Nullable`1<VerticalAlignment> <Vertical>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<HorizontalAlignment> <Horizontal>k__BackingField;
    public Nullable`1<VerticalAlignment> Vertical { get; public set; }
    public Nullable`1<HorizontalAlignment> Horizontal { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<VerticalAlignment> get_Vertical();
    [CompilerGeneratedAttribute]
public void set_Vertical(Nullable`1<VerticalAlignment> value);
    [CompilerGeneratedAttribute]
public Nullable`1<HorizontalAlignment> get_Horizontal();
    [CompilerGeneratedAttribute]
public void set_Horizontal(Nullable`1<HorizontalAlignment> value);
    internal virtual void Draw(Size availableSpace);
    private float GetTopOffset(Size availableSpace, Size childSize);
    private float GetLeftOffset(Size availableSpace, Size childSize);
    [NullableContextAttribute("2")]
internal virtual string GetCompanionHint();
}
internal class QuestPDF.Elements.AspectRatio : ContainerElement {
    [CompilerGeneratedAttribute]
private ContentDirection <ContentDirection>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Ratio>k__BackingField;
    [CompilerGeneratedAttribute]
private AspectRatioOption <Option>k__BackingField;
    public ContentDirection ContentDirection { get; public set; }
    public float Ratio { get; public set; }
    public AspectRatioOption Option { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual ContentDirection get_ContentDirection();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ContentDirection(ContentDirection value);
    [CompilerGeneratedAttribute]
public float get_Ratio();
    [CompilerGeneratedAttribute]
public void set_Ratio(float value);
    [CompilerGeneratedAttribute]
public AspectRatioOption get_Option();
    [CompilerGeneratedAttribute]
public void set_Option(AspectRatioOption value);
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
    private Size GetTargetSize(Size availableSpace);
    [NullableContextAttribute("2")]
internal virtual string GetCompanionHint();
}
internal class QuestPDF.Elements.Background : ContainerElement {
    [CompilerGeneratedAttribute]
private Color <Color>k__BackingField;
    public Color Color { get; public set; }
    [CompilerGeneratedAttribute]
public Color get_Color();
    [CompilerGeneratedAttribute]
public void set_Color(Color value);
    internal virtual void Draw(Size availableSpace);
    [NullableContextAttribute("2")]
internal virtual string GetCompanionHint();
}
internal class QuestPDF.Elements.Border : ContainerElement {
    [CompilerGeneratedAttribute]
private Color <Color>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Top>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Bottom>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Left>k__BackingField;
    public Color Color { get; public set; }
    public float Top { get; public set; }
    public float Right { get; public set; }
    public float Bottom { get; public set; }
    public float Left { get; public set; }
    [CompilerGeneratedAttribute]
public Color get_Color();
    [CompilerGeneratedAttribute]
public void set_Color(Color value);
    [CompilerGeneratedAttribute]
public float get_Top();
    [CompilerGeneratedAttribute]
public void set_Top(float value);
    [CompilerGeneratedAttribute]
public float get_Right();
    [CompilerGeneratedAttribute]
public void set_Right(float value);
    [CompilerGeneratedAttribute]
public float get_Bottom();
    [CompilerGeneratedAttribute]
public void set_Bottom(float value);
    [CompilerGeneratedAttribute]
public float get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(float value);
    internal virtual void Draw(Size availableSpace);
    [NullableContextAttribute("2")]
internal virtual string GetCompanionHint();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private string <GetCompanionHint>g__FormatSides|21_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.Column : Element {
    [CompilerGeneratedAttribute]
private List`1<Element> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Spacing>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentRenderingIndex>k__BackingField;
    internal List`1<Element> Items { get; }
    internal float Spacing { get; internal set; }
    internal int CurrentRenderingIndex { get; internal set; }
    [CompilerGeneratedAttribute]
internal List`1<Element> get_Items();
    [CompilerGeneratedAttribute]
internal float get_Spacing();
    [CompilerGeneratedAttribute]
internal void set_Spacing(float value);
    internal virtual IEnumerable`1<Element> GetChildren();
    internal virtual void CreateProxy(Func`2<Element, Element> create);
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
    private List`1<ColumnItemRenderingCommand> PlanLayout(Size availableSpace);
    [CompilerGeneratedAttribute]
internal int get_CurrentRenderingIndex();
    [CompilerGeneratedAttribute]
internal void set_CurrentRenderingIndex(int value);
    public sealed virtual void ResetState(bool hardReset);
    public sealed virtual object GetState();
    public sealed virtual void SetState(object state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.ColumnItemRenderingCommand : object {
    [CompilerGeneratedAttribute]
private Element <Element>k__BackingField;
    [CompilerGeneratedAttribute]
private SpacePlan <Measurement>k__BackingField;
    [CompilerGeneratedAttribute]
private Position <Offset>k__BackingField;
    public Element Element { get; public set; }
    public SpacePlan Measurement { get; public set; }
    public Position Offset { get; public set; }
    [CompilerGeneratedAttribute]
public Element get_Element();
    [CompilerGeneratedAttribute]
public void set_Element(Element value);
    [CompilerGeneratedAttribute]
public SpacePlan get_Measurement();
    [CompilerGeneratedAttribute]
public void set_Measurement(SpacePlan value);
    [CompilerGeneratedAttribute]
public Position get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(Position value);
}
internal class QuestPDF.Elements.Constrained : ContainerElement {
    [CompilerGeneratedAttribute]
private ContentDirection <ContentDirection>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<float> <MinWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<float> <MaxWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<float> <MinHeight>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<float> <MaxHeight>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnforceSizeWhenEmpty>k__BackingField;
    public ContentDirection ContentDirection { get; public set; }
    public Nullable`1<float> MinWidth { get; public set; }
    public Nullable`1<float> MaxWidth { get; public set; }
    public Nullable`1<float> MinHeight { get; public set; }
    public Nullable`1<float> MaxHeight { get; public set; }
    public bool EnforceSizeWhenEmpty { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual ContentDirection get_ContentDirection();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ContentDirection(ContentDirection value);
    [CompilerGeneratedAttribute]
public Nullable`1<float> get_MinWidth();
    [CompilerGeneratedAttribute]
public void set_MinWidth(Nullable`1<float> value);
    [CompilerGeneratedAttribute]
public Nullable`1<float> get_MaxWidth();
    [CompilerGeneratedAttribute]
public void set_MaxWidth(Nullable`1<float> value);
    [CompilerGeneratedAttribute]
public Nullable`1<float> get_MinHeight();
    [CompilerGeneratedAttribute]
public void set_MinHeight(Nullable`1<float> value);
    [CompilerGeneratedAttribute]
public Nullable`1<float> get_MaxHeight();
    [CompilerGeneratedAttribute]
public void set_MaxHeight(Nullable`1<float> value);
    [CompilerGeneratedAttribute]
public bool get_EnforceSizeWhenEmpty();
    [CompilerGeneratedAttribute]
public void set_EnforceSizeWhenEmpty(bool value);
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
    private static float Min(Nullable`1<float> x, float y);
    private static float Max(Nullable`1<float> x, float y);
    [NullableContextAttribute("2")]
internal virtual string GetCompanionHint();
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("QuestPDF.Elements.Constrained/<<GetCompanionHint>g__FormatRange|28_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<string> <GetCompanionHint>g__FormatRange|28_0(string prefix, Nullable`1<float> min, Nullable`1<float> max);
}
internal class QuestPDF.Elements.Container : ContainerElement {
}
internal class QuestPDF.Elements.ContentDirectionSetter : ContainerElement {
    [CompilerGeneratedAttribute]
private ContentDirection <ContentDirection>k__BackingField;
    public ContentDirection ContentDirection { get; public set; }
    [CompilerGeneratedAttribute]
public ContentDirection get_ContentDirection();
    [CompilerGeneratedAttribute]
public void set_ContentDirection(ContentDirection value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.DebugArea : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IElement <Child>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <Color>k__BackingField;
    [NullableAttribute("2")]
public IElement Child { get; public set; }
    public string Text { get; public set; }
    public Color Color { get; public set; }
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IElement get_Child();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Child(IElement value);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    [CompilerGeneratedAttribute]
public Color get_Color();
    [CompilerGeneratedAttribute]
public void set_Color(Color value);
    public sealed virtual void Compose(IContainer container);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.DebugPointer : ContainerElement {
    [CompilerGeneratedAttribute]
private DebugPointerType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    public DebugPointerType Type { get; public set; }
    public string Label { get; public set; }
    public DebugPointer(DebugPointerType type, string label);
    [CompilerGeneratedAttribute]
public DebugPointerType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(DebugPointerType value);
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
public void set_Label(string value);
    [NullableContextAttribute("2")]
internal virtual string GetCompanionSearchableContent();
    [IteratorStateMachineAttribute("QuestPDF.Elements.DebugPointer/<GetCompanionProperties>d__11")]
internal virtual IEnumerable`1<KeyValuePair`2<string, string>> GetCompanionProperties();
}
internal enum QuestPDF.Elements.DebugPointerType : Enum {
    public int value__;
    public static DebugPointerType DocumentStructure;
    public static DebugPointerType ElementStructure;
    public static DebugPointerType Component;
    public static DebugPointerType Section;
    public static DebugPointerType Dynamic;
    public static DebugPointerType UserDefined;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.Decoration : Element {
    [CompilerGeneratedAttribute]
private ContentDirection <ContentDirection>k__BackingField;
    [CompilerGeneratedAttribute]
private Element <Before>k__BackingField;
    [CompilerGeneratedAttribute]
private Element <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private Element <After>k__BackingField;
    public ContentDirection ContentDirection { get; public set; }
    internal Element Before { get; internal set; }
    internal Element Content { get; internal set; }
    internal Element After { get; internal set; }
    [CompilerGeneratedAttribute]
public sealed virtual ContentDirection get_ContentDirection();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ContentDirection(ContentDirection value);
    [CompilerGeneratedAttribute]
internal Element get_Before();
    [CompilerGeneratedAttribute]
internal void set_Before(Element value);
    [CompilerGeneratedAttribute]
internal Element get_Content();
    [CompilerGeneratedAttribute]
internal void set_Content(Element value);
    [CompilerGeneratedAttribute]
internal Element get_After();
    [CompilerGeneratedAttribute]
internal void set_After(Element value);
    [IteratorStateMachineAttribute("QuestPDF.Elements.Decoration/<GetChildren>d__16")]
internal virtual IEnumerable`1<Element> GetChildren();
    internal virtual void CreateProxy(Func`2<Element, Element> create);
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
    private DecorationElementLayout PlanLayout(Size availableSpace);
    [CompilerGeneratedAttribute]
internal static SpacePlan <PlanLayout>g__GetDecorationMeasurement|20_0(Element element, <>c__DisplayClass20_0& );
}
internal class QuestPDF.Elements.DecorationElementLayout : object {
    [CompilerGeneratedAttribute]
private ItemCommand <Before>k__BackingField;
    [CompilerGeneratedAttribute]
private ItemCommand <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private ItemCommand <After>k__BackingField;
    public ItemCommand Before { get; public set; }
    public ItemCommand Content { get; public set; }
    public ItemCommand After { get; public set; }
    [CompilerGeneratedAttribute]
public ItemCommand get_Before();
    [CompilerGeneratedAttribute]
public void set_Before(ItemCommand value);
    [CompilerGeneratedAttribute]
public ItemCommand get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(ItemCommand value);
    [CompilerGeneratedAttribute]
public ItemCommand get_After();
    [CompilerGeneratedAttribute]
public void set_After(ItemCommand value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.DefaultTextStyle : ContainerElement {
    [CompilerGeneratedAttribute]
private TextStyle <TextStyle>k__BackingField;
    public TextStyle TextStyle { get; public set; }
    [CompilerGeneratedAttribute]
public TextStyle get_TextStyle();
    [CompilerGeneratedAttribute]
public void set_TextStyle(TextStyle value);
}
internal enum QuestPDF.Elements.DocumentStructureTypes : Enum {
    public int value__;
    public static DocumentStructureTypes Document;
    public static DocumentStructureTypes Page;
    public static DocumentStructureTypes Background;
    public static DocumentStructureTypes Foreground;
    public static DocumentStructureTypes Header;
    public static DocumentStructureTypes Content;
    public static DocumentStructureTypes Footer;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Elements.DynamicContext : object {
    [CompilerGeneratedAttribute]
private IPageContext <PageContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ICanvas <Canvas>k__BackingField;
    [CompilerGeneratedAttribute]
private TextStyle <TextStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private ContentDirection <ContentDirection>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ImageTargetDpi>k__BackingField;
    [CompilerGeneratedAttribute]
private ImageCompressionQuality <ImageCompressionQuality>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseOriginalImage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PageNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalPages>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <AvailableSize>k__BackingField;
    internal IPageContext PageContext { get; internal set; }
    internal ICanvas Canvas { get; internal set; }
    internal TextStyle TextStyle { get; internal set; }
    internal ContentDirection ContentDirection { get; internal set; }
    internal int ImageTargetDpi { get; internal set; }
    internal ImageCompressionQuality ImageCompressionQuality { get; internal set; }
    internal bool UseOriginalImage { get; internal set; }
    public int PageNumber { get; internal set; }
    public int TotalPages { get; internal set; }
    public Size AvailableSize { get; internal set; }
    [CompilerGeneratedAttribute]
internal IPageContext get_PageContext();
    [CompilerGeneratedAttribute]
internal void set_PageContext(IPageContext value);
    [CompilerGeneratedAttribute]
internal ICanvas get_Canvas();
    [CompilerGeneratedAttribute]
internal void set_Canvas(ICanvas value);
    [CompilerGeneratedAttribute]
internal TextStyle get_TextStyle();
    [CompilerGeneratedAttribute]
internal void set_TextStyle(TextStyle value);
    [CompilerGeneratedAttribute]
internal ContentDirection get_ContentDirection();
    [CompilerGeneratedAttribute]
internal void set_ContentDirection(ContentDirection value);
    [CompilerGeneratedAttribute]
internal int get_ImageTargetDpi();
    [CompilerGeneratedAttribute]
internal void set_ImageTargetDpi(int value);
    [CompilerGeneratedAttribute]
internal ImageCompressionQuality get_ImageCompressionQuality();
    [CompilerGeneratedAttribute]
internal void set_ImageCompressionQuality(ImageCompressionQuality value);
    [CompilerGeneratedAttribute]
internal bool get_UseOriginalImage();
    [CompilerGeneratedAttribute]
internal void set_UseOriginalImage(bool value);
    [CompilerGeneratedAttribute]
public int get_PageNumber();
    [CompilerGeneratedAttribute]
internal void set_PageNumber(int value);
    [CompilerGeneratedAttribute]
public int get_TotalPages();
    [CompilerGeneratedAttribute]
internal void set_TotalPages(int value);
    [CompilerGeneratedAttribute]
public Size get_AvailableSize();
    [CompilerGeneratedAttribute]
internal void set_AvailableSize(Size value);
    public IDynamicElement CreateElement(Action`1<IContainer> content);
}
internal class QuestPDF.Elements.DynamicElement : ContainerElement {
    [CompilerGeneratedAttribute]
private Size <Size>k__BackingField;
    public Size Size { get; internal set; }
    [CompilerGeneratedAttribute]
public sealed virtual Size get_Size();
    [CompilerGeneratedAttribute]
internal void set_Size(Size value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.DynamicHost : Element {
    [CompilerGeneratedAttribute]
private DynamicComponentProxy <Child>k__BackingField;
    [CompilerGeneratedAttribute]
private object <InitialComponentState>k__BackingField;
    [CompilerGeneratedAttribute]
private TextStyle <TextStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private ContentDirection <ContentDirection>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ImageTargetDpi>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ImageCompressionQuality> <ImageCompressionQuality>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseOriginalImage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRendered>k__BackingField;
    private DynamicComponentProxy Child { get; }
    private object InitialComponentState { get; private set; }
    internal TextStyle TextStyle { get; internal set; }
    public ContentDirection ContentDirection { get; public set; }
    internal Nullable`1<int> ImageTargetDpi { get; internal set; }
    internal Nullable`1<ImageCompressionQuality> ImageCompressionQuality { get; internal set; }
    internal bool UseOriginalImage { get; internal set; }
    private bool IsRendered { get; private set; }
    public DynamicHost(DynamicComponentProxy child);
    [CompilerGeneratedAttribute]
private DynamicComponentProxy get_Child();
    [CompilerGeneratedAttribute]
private object get_InitialComponentState();
    [CompilerGeneratedAttribute]
private void set_InitialComponentState(object value);
    [CompilerGeneratedAttribute]
internal TextStyle get_TextStyle();
    [CompilerGeneratedAttribute]
internal void set_TextStyle(TextStyle value);
    [CompilerGeneratedAttribute]
public sealed virtual ContentDirection get_ContentDirection();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ContentDirection(ContentDirection value);
    [CompilerGeneratedAttribute]
internal Nullable`1<int> get_ImageTargetDpi();
    [CompilerGeneratedAttribute]
internal void set_ImageTargetDpi(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<ImageCompressionQuality> get_ImageCompressionQuality();
    [CompilerGeneratedAttribute]
internal void set_ImageCompressionQuality(Nullable`1<ImageCompressionQuality> value);
    [CompilerGeneratedAttribute]
internal bool get_UseOriginalImage();
    [CompilerGeneratedAttribute]
internal void set_UseOriginalImage(bool value);
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
    private DynamicComponentComposeResult ComposeContent(Size availableSize, bool acceptNewState);
    [CompilerGeneratedAttribute]
private bool get_IsRendered();
    [CompilerGeneratedAttribute]
private void set_IsRendered(bool value);
    public sealed virtual void ResetState(bool hardReset);
    public sealed virtual object GetState();
    public sealed virtual void SetState(object state);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.DynamicImage : Element {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <TargetDpi>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ImageCompressionQuality> <CompressionQuality>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseOriginalImage>k__BackingField;
    [CompilerGeneratedAttribute]
private GenerateDynamicImageDelegate <Source>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<ValueTuple`2<Size, SkImage>> <Cache>k__BackingField;
    [CompilerGeneratedAttribute]
private float <GenerationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DrawnImageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRendered>k__BackingField;
    internal Nullable`1<int> TargetDpi { get; internal set; }
    internal Nullable`1<ImageCompressionQuality> CompressionQuality { get; internal set; }
    internal bool UseOriginalImage { get; internal set; }
    public GenerateDynamicImageDelegate Source { get; public set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<Size, SkImage>> Cache { get; }
    private float GenerationTime { get; private set; }
    private int DrawnImageSize { get; private set; }
    private bool IsRendered { get; private set; }
    [CompilerGeneratedAttribute]
internal Nullable`1<int> get_TargetDpi();
    [CompilerGeneratedAttribute]
internal void set_TargetDpi(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<ImageCompressionQuality> get_CompressionQuality();
    [CompilerGeneratedAttribute]
internal void set_CompressionQuality(Nullable`1<ImageCompressionQuality> value);
    [CompilerGeneratedAttribute]
internal bool get_UseOriginalImage();
    [CompilerGeneratedAttribute]
internal void set_UseOriginalImage(bool value);
    [CompilerGeneratedAttribute]
public GenerateDynamicImageDelegate get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(GenerateDynamicImageDelegate value);
    [CompilerGeneratedAttribute]
private List`1<ValueTuple`2<Size, SkImage>> get_Cache();
    [CompilerGeneratedAttribute]
private float get_GenerationTime();
    [CompilerGeneratedAttribute]
private void set_GenerationTime(float value);
    [CompilerGeneratedAttribute]
private int get_DrawnImageSize();
    [CompilerGeneratedAttribute]
private void set_DrawnImageSize(int value);
    protected virtual override void Finalize();
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
    private SkImage GetImage(Size availableSpace);
    private static ImageSize GetTargetResolution(Size availableSize, int targetDpi);
    [CompilerGeneratedAttribute]
private bool get_IsRendered();
    [CompilerGeneratedAttribute]
private void set_IsRendered(bool value);
    public sealed virtual void ResetState(bool hardReset);
    [NullableContextAttribute("1")]
public sealed virtual object GetState();
    [NullableContextAttribute("1")]
public sealed virtual void SetState(object state);
    internal virtual string GetCompanionHint();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.DynamicSvgImage : Element {
    [CompilerGeneratedAttribute]
private GenerateDynamicSvgDelegate <SvgSource>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<ValueTuple`2<Size, SkSvgImage>> <Cache>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRendered>k__BackingField;
    public GenerateDynamicSvgDelegate SvgSource { get; public set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<Size, SkSvgImage>> Cache { get; }
    private bool IsRendered { get; private set; }
    [CompilerGeneratedAttribute]
public GenerateDynamicSvgDelegate get_SvgSource();
    [CompilerGeneratedAttribute]
public void set_SvgSource(GenerateDynamicSvgDelegate value);
    [CompilerGeneratedAttribute]
private List`1<ValueTuple`2<Size, SkSvgImage>> get_Cache();
    protected virtual override void Finalize();
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
    [NullableContextAttribute("2")]
private SkSvgImage GetImage(Size availableSpace);
    [CompilerGeneratedAttribute]
private bool get_IsRendered();
    [CompilerGeneratedAttribute]
private void set_IsRendered(bool value);
    public sealed virtual void ResetState(bool hardReset);
    public sealed virtual object GetState();
    public sealed virtual void SetState(object state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.Empty : Element {
    [CompilerGeneratedAttribute]
private static Empty <Instance>k__BackingField;
    internal static Empty Instance { get; }
    private static Empty();
    [CompilerGeneratedAttribute]
internal static Empty get_Instance();
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
}
internal class QuestPDF.Elements.EnsureSpace : ContainerElement {
    public static float DefaultMinHeight;
    [CompilerGeneratedAttribute]
private float <MinHeight>k__BackingField;
    public float MinHeight { get; public set; }
    [CompilerGeneratedAttribute]
public float get_MinHeight();
    [CompilerGeneratedAttribute]
public void set_MinHeight(float value);
    internal virtual SpacePlan Measure(Size availableSpace);
    [NullableContextAttribute("2")]
internal virtual string GetCompanionHint();
}
internal class QuestPDF.Elements.Extend : ContainerElement {
    [CompilerGeneratedAttribute]
private bool <ExtendVertical>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExtendHorizontal>k__BackingField;
    public bool ExtendVertical { get; public set; }
    public bool ExtendHorizontal { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ExtendVertical();
    [CompilerGeneratedAttribute]
public void set_ExtendVertical(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExtendHorizontal();
    [CompilerGeneratedAttribute]
public void set_ExtendHorizontal(bool value);
    internal virtual SpacePlan Measure(Size availableSpace);
    private Size GetTargetSize(Size availableSpace, Size childSize);
    [NullableContextAttribute("2")]
internal virtual string GetCompanionHint();
}
public class QuestPDF.Elements.GenerateDynamicImageDelegate : MulticastDelegate {
    public GenerateDynamicImageDelegate(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Byte[] Invoke(GenerateDynamicImageDelegatePayload payload);
    public virtual IAsyncResult BeginInvoke(GenerateDynamicImageDelegatePayload payload, AsyncCallback callback, object object);
    public virtual Byte[] EndInvoke(IAsyncResult result);
}
public class QuestPDF.Elements.GenerateDynamicImageDelegatePayload : object {
    [CompilerGeneratedAttribute]
private Size <AvailableSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private ImageSize <ImageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Dpi>k__BackingField;
    public Size AvailableSpace { get; public set; }
    public ImageSize ImageSize { get; public set; }
    public int Dpi { get; public set; }
    [CompilerGeneratedAttribute]
public Size get_AvailableSpace();
    [CompilerGeneratedAttribute]
public void set_AvailableSpace(Size value);
    [CompilerGeneratedAttribute]
public ImageSize get_ImageSize();
    [CompilerGeneratedAttribute]
public void set_ImageSize(ImageSize value);
    [CompilerGeneratedAttribute]
public int get_Dpi();
    [CompilerGeneratedAttribute]
public void set_Dpi(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.Grid : object {
    public static int DefaultColumnsCount;
    [CompilerGeneratedAttribute]
private List`1<GridElement> <Children>k__BackingField;
    [CompilerGeneratedAttribute]
private Queue`1<GridElement> <ChildrenQueue>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColumnsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private HorizontalAlignment <Alignment>k__BackingField;
    [CompilerGeneratedAttribute]
private float <VerticalSpacing>k__BackingField;
    [CompilerGeneratedAttribute]
private float <HorizontalSpacing>k__BackingField;
    public List`1<GridElement> Children { get; }
    public Queue`1<GridElement> ChildrenQueue { get; public set; }
    public int ColumnsCount { get; public set; }
    public HorizontalAlignment Alignment { get; public set; }
    public float VerticalSpacing { get; public set; }
    public float HorizontalSpacing { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<GridElement> get_Children();
    [CompilerGeneratedAttribute]
public Queue`1<GridElement> get_ChildrenQueue();
    [CompilerGeneratedAttribute]
public void set_ChildrenQueue(Queue`1<GridElement> value);
    [CompilerGeneratedAttribute]
public int get_ColumnsCount();
    [CompilerGeneratedAttribute]
public void set_ColumnsCount(int value);
    [CompilerGeneratedAttribute]
public HorizontalAlignment get_Alignment();
    [CompilerGeneratedAttribute]
public void set_Alignment(HorizontalAlignment value);
    [CompilerGeneratedAttribute]
public float get_VerticalSpacing();
    [CompilerGeneratedAttribute]
public void set_VerticalSpacing(float value);
    [CompilerGeneratedAttribute]
public float get_HorizontalSpacing();
    [CompilerGeneratedAttribute]
public void set_HorizontalSpacing(float value);
    public sealed virtual void Compose(IContainer container);
    [IteratorStateMachineAttribute("QuestPDF.Elements.Grid/<GetRowElements>d__25")]
private IEnumerable`1<GridElement> GetRowElements();
    private void BuildRow(RowDescriptor row);
    [CompilerGeneratedAttribute]
private void <Compose>b__24_0(ColumnDescriptor column);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.GridElement : object {
    [CompilerGeneratedAttribute]
private int <Columns>k__BackingField;
    [CompilerGeneratedAttribute]
private Element <Child>k__BackingField;
    public int Columns { get; public set; }
    public Element Child { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Columns();
    [CompilerGeneratedAttribute]
public void set_Columns(int value);
    [CompilerGeneratedAttribute]
public Element get_Child();
    [CompilerGeneratedAttribute]
public void set_Child(Element value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.Hyperlink : ContainerElement {
    [CompilerGeneratedAttribute]
private ContentDirection <ContentDirection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public ContentDirection ContentDirection { get; public set; }
    public string Url { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual ContentDirection get_ContentDirection();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ContentDirection(ContentDirection value);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    internal virtual void Draw(Size availableSpace);
    [NullableContextAttribute("2")]
internal virtual string GetCompanionHint();
    [IteratorStateMachineAttribute("QuestPDF.Elements.Hyperlink/<GetCompanionProperties>d__10")]
internal virtual IEnumerable`1<KeyValuePair`2<string, string>> GetCompanionProperties();
}
public interface QuestPDF.Elements.IDynamicElement {
    public Size Size { get; }
    public abstract virtual Size get_Size();
}
public interface QuestPDF.Elements.ILine {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.Image : Element {
    [CompilerGeneratedAttribute]
private Image <DocumentImage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseOriginalImage>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <TargetDpi>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ImageCompressionQuality> <CompressionQuality>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DrawnImageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRendered>k__BackingField;
    public Image DocumentImage { get; public set; }
    internal bool UseOriginalImage { get; internal set; }
    internal Nullable`1<int> TargetDpi { get; internal set; }
    internal Nullable`1<ImageCompressionQuality> CompressionQuality { get; internal set; }
    private int DrawnImageSize { get; private set; }
    private bool IsRendered { get; private set; }
    [CompilerGeneratedAttribute]
public Image get_DocumentImage();
    [CompilerGeneratedAttribute]
public void set_DocumentImage(Image value);
    [CompilerGeneratedAttribute]
internal bool get_UseOriginalImage();
    [CompilerGeneratedAttribute]
internal void set_UseOriginalImage(bool value);
    [CompilerGeneratedAttribute]
internal Nullable`1<int> get_TargetDpi();
    [CompilerGeneratedAttribute]
internal void set_TargetDpi(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<ImageCompressionQuality> get_CompressionQuality();
    [CompilerGeneratedAttribute]
internal void set_CompressionQuality(Nullable`1<ImageCompressionQuality> value);
    [CompilerGeneratedAttribute]
private int get_DrawnImageSize();
    [CompilerGeneratedAttribute]
private void set_DrawnImageSize(int value);
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
    [NullableContextAttribute("1")]
private SkImage GetImageToDraw(Size availableSpace);
    private static ImageSize GetTargetResolution(ImageSize imageResolution, Size availableAreaSize, int targetDpi);
    [CompilerGeneratedAttribute]
private bool get_IsRendered();
    [CompilerGeneratedAttribute]
private void set_IsRendered(bool value);
    public sealed virtual void ResetState(bool hardReset);
    [NullableContextAttribute("1")]
public sealed virtual object GetState();
    [NullableContextAttribute("1")]
public sealed virtual void SetState(object state);
    internal virtual string GetCompanionHint();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.Inlined : Element {
    [CompilerGeneratedAttribute]
private List`1<Element> <Elements>k__BackingField;
    [CompilerGeneratedAttribute]
private ContentDirection <ContentDirection>k__BackingField;
    [CompilerGeneratedAttribute]
private float <VerticalSpacing>k__BackingField;
    [CompilerGeneratedAttribute]
private float <HorizontalSpacing>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<InlinedAlignment> <ElementsAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private VerticalAlignment <BaselineAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentRenderingIndex>k__BackingField;
    public List`1<Element> Elements { get; internal set; }
    public ContentDirection ContentDirection { get; public set; }
    internal float VerticalSpacing { get; internal set; }
    internal float HorizontalSpacing { get; internal set; }
    internal Nullable`1<InlinedAlignment> ElementsAlignment { get; internal set; }
    internal VerticalAlignment BaselineAlignment { get; internal set; }
    private int CurrentRenderingIndex { get; private set; }
    [CompilerGeneratedAttribute]
public List`1<Element> get_Elements();
    [CompilerGeneratedAttribute]
internal void set_Elements(List`1<Element> value);
    [CompilerGeneratedAttribute]
public sealed virtual ContentDirection get_ContentDirection();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ContentDirection(ContentDirection value);
    [CompilerGeneratedAttribute]
internal float get_VerticalSpacing();
    [CompilerGeneratedAttribute]
internal void set_VerticalSpacing(float value);
    [CompilerGeneratedAttribute]
internal float get_HorizontalSpacing();
    [CompilerGeneratedAttribute]
internal void set_HorizontalSpacing(float value);
    [CompilerGeneratedAttribute]
internal Nullable`1<InlinedAlignment> get_ElementsAlignment();
    [CompilerGeneratedAttribute]
internal void set_ElementsAlignment(Nullable`1<InlinedAlignment> value);
    [CompilerGeneratedAttribute]
internal VerticalAlignment get_BaselineAlignment();
    [CompilerGeneratedAttribute]
internal void set_BaselineAlignment(VerticalAlignment value);
    internal virtual IEnumerable`1<Element> GetChildren();
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
    private void SetDefaultAlignment();
    private static Size GetLineSize(ICollection`1<InlinedMeasurement> measurements);
    private ICollection`1<ICollection`1<InlinedMeasurement>> Compose(Size availableSize);
    [CompilerGeneratedAttribute]
private int get_CurrentRenderingIndex();
    [CompilerGeneratedAttribute]
private void set_CurrentRenderingIndex(int value);
    public sealed virtual void ResetState(bool hardReset);
    public sealed virtual object GetState();
    public sealed virtual void SetState(object state);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private Size <Measure>b__25_0(ICollection`1<InlinedMeasurement> line);
    [CompilerGeneratedAttribute]
private void <Draw>g__DrawLine|26_1(ICollection`1<InlinedMeasurement> lineMeasurements, <>c__DisplayClass26_0& );
    [CompilerGeneratedAttribute]
private float <Draw>g__ElementOffset|26_3(<>c__DisplayClass26_0& , <>c__DisplayClass26_1& );
    [CompilerGeneratedAttribute]
private float <Draw>g__AlignOffset|26_4(<>c__DisplayClass26_0& , <>c__DisplayClass26_1& );
    [CompilerGeneratedAttribute]
private float <Draw>g__BaselineOffset|26_5(Size elementSize, float lineHeight, <>c__DisplayClass26_0& );
    [CompilerGeneratedAttribute]
private ICollection`1<InlinedMeasurement> <Compose>g__GetNextLine|29_0(<>c__DisplayClass29_0& );
    [CompilerGeneratedAttribute]
private float <Compose>g__GetInitialAlignmentOffset|29_1(<>c__DisplayClass29_0& );
}
internal enum QuestPDF.Elements.InlinedAlignment : Enum {
    public int value__;
    public static InlinedAlignment Left;
    public static InlinedAlignment Center;
    public static InlinedAlignment Right;
    public static InlinedAlignment Justify;
    public static InlinedAlignment SpaceAround;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.InlinedMeasurement : ValueType {
    [CompilerGeneratedAttribute]
private Element <Element>k__BackingField;
    [CompilerGeneratedAttribute]
private SpacePlan <Size>k__BackingField;
    public Element Element { get; public set; }
    public SpacePlan Size { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Element get_Element();
    [CompilerGeneratedAttribute]
public void set_Element(Element value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SpacePlan get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(SpacePlan value);
}
internal class QuestPDF.Elements.Layer : ContainerElement {
    [CompilerGeneratedAttribute]
private bool <IsPrimary>k__BackingField;
    public bool IsPrimary { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsPrimary();
    [CompilerGeneratedAttribute]
public void set_IsPrimary(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.Layers : Element {
    [CompilerGeneratedAttribute]
private List`1<Layer> <Children>k__BackingField;
    public List`1<Layer> Children { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<Layer> get_Children();
    [CompilerGeneratedAttribute]
public void set_Children(List`1<Layer> value);
    internal virtual IEnumerable`1<Element> GetChildren();
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
}
internal class QuestPDF.Elements.Line : Element {
    [CompilerGeneratedAttribute]
private LineType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <Color>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Thickness>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRendered>k__BackingField;
    public LineType Type { get; public set; }
    public Color Color { get; public set; }
    public float Thickness { get; public set; }
    private bool IsRendered { get; private set; }
    [CompilerGeneratedAttribute]
public LineType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(LineType value);
    [CompilerGeneratedAttribute]
public Color get_Color();
    [CompilerGeneratedAttribute]
public void set_Color(Color value);
    [CompilerGeneratedAttribute]
public float get_Thickness();
    [CompilerGeneratedAttribute]
public void set_Thickness(float value);
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
    [CompilerGeneratedAttribute]
private bool get_IsRendered();
    [CompilerGeneratedAttribute]
private void set_IsRendered(bool value);
    public sealed virtual void ResetState(bool hardReset);
    [NullableContextAttribute("1")]
public sealed virtual object GetState();
    [NullableContextAttribute("1")]
public sealed virtual void SetState(object state);
    [NullableContextAttribute("2")]
internal virtual string GetCompanionHint();
}
internal enum QuestPDF.Elements.LineType : Enum {
    public int value__;
    public static LineType Vertical;
    public static LineType Horizontal;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.MultiColumn : Element {
    [CompilerGeneratedAttribute]
private Element <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private Element <Spacer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColumnCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BalanceHeight>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Spacing>k__BackingField;
    [CompilerGeneratedAttribute]
private ContentDirection <ContentDirection>k__BackingField;
    [CompilerGeneratedAttribute]
private ProxyCanvas <ChildrenCanvas>k__BackingField;
    [CompilerGeneratedAttribute]
private TreeNode`1[] <State>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTextOptimizationExecuted>k__BackingField;
    internal Element Content { get; internal set; }
    internal Element Spacer { get; internal set; }
    public int ColumnCount { get; public set; }
    public bool BalanceHeight { get; public set; }
    public float Spacing { get; public set; }
    public ContentDirection ContentDirection { get; public set; }
    private ProxyCanvas ChildrenCanvas { get; }
    private TreeNode`1[] State { get; private set; }
    private bool IsTextOptimizationExecuted { get; private set; }
    [CompilerGeneratedAttribute]
internal Element get_Content();
    [CompilerGeneratedAttribute]
internal void set_Content(Element value);
    [CompilerGeneratedAttribute]
internal Element get_Spacer();
    [CompilerGeneratedAttribute]
internal void set_Spacer(Element value);
    [CompilerGeneratedAttribute]
public int get_ColumnCount();
    [CompilerGeneratedAttribute]
public void set_ColumnCount(int value);
    [CompilerGeneratedAttribute]
public bool get_BalanceHeight();
    [CompilerGeneratedAttribute]
public void set_BalanceHeight(bool value);
    [CompilerGeneratedAttribute]
public float get_Spacing();
    [CompilerGeneratedAttribute]
public void set_Spacing(float value);
    [CompilerGeneratedAttribute]
public sealed virtual ContentDirection get_ContentDirection();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ContentDirection(ContentDirection value);
    [CompilerGeneratedAttribute]
private ProxyCanvas get_ChildrenCanvas();
    [CompilerGeneratedAttribute]
private TreeNode`1[] get_State();
    [CompilerGeneratedAttribute]
private void set_State(TreeNode`1[] value);
    internal virtual void CreateProxy(Func`2<Element, Element> create);
    [IteratorStateMachineAttribute("QuestPDF.Elements.MultiColumn/<GetChildren>d__32")]
internal virtual IEnumerable`1<Element> GetChildren();
    private void BuildState();
    internal virtual SpacePlan Measure(Size availableSpace);
    private Size GetAvailableSpaceForColumn(Size totalSpace);
    internal virtual void Draw(Size availableSpace);
    private void ResetObserverState(bool restoreChildState);
    [CompilerGeneratedAttribute]
private bool get_IsTextOptimizationExecuted();
    [CompilerGeneratedAttribute]
private void set_IsTextOptimizationExecuted(bool value);
    private void OptimizeTextCacheBehavior();
    [CompilerGeneratedAttribute]
private Position <Draw>g__GetTargetOffset|36_0(float contentWidth, <>c__DisplayClass36_0& );
    [CompilerGeneratedAttribute]
internal static void <ResetObserverState>g__Traverse|37_0(TreeNode`1<MultiColumnChildDrawingObserver> node, <>c__DisplayClass37_0& );
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.MultiColumnChildDrawingObserver : ElementProxy {
    [CompilerGeneratedAttribute]
private object <ChildStateBeforeDrawingOperation>k__BackingField;
    public bool HasBeenDrawn { get; }
    public object ChildStateBeforeDrawingOperation { get; private set; }
    public bool get_HasBeenDrawn();
    [CompilerGeneratedAttribute]
public object get_ChildStateBeforeDrawingOperation();
    [CompilerGeneratedAttribute]
private void set_ChildStateBeforeDrawingOperation(object value);
    internal virtual void Draw(Size availableSpace);
    internal void ResetDrawingState();
    internal void RestoreState();
    [NullableContextAttribute("1")]
private Element GetFirstElementChild();
}
internal class QuestPDF.Elements.Padding : ContainerElement {
    [CompilerGeneratedAttribute]
private float <Top>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Bottom>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Left>k__BackingField;
    public float Top { get; public set; }
    public float Right { get; public set; }
    public float Bottom { get; public set; }
    public float Left { get; public set; }
    [CompilerGeneratedAttribute]
public float get_Top();
    [CompilerGeneratedAttribute]
public void set_Top(float value);
    [CompilerGeneratedAttribute]
public float get_Right();
    [CompilerGeneratedAttribute]
public void set_Right(float value);
    [CompilerGeneratedAttribute]
public float get_Bottom();
    [CompilerGeneratedAttribute]
public void set_Bottom(float value);
    [CompilerGeneratedAttribute]
public float get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(float value);
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
    private Size InternalSpace(Size availableSpace);
    [NullableContextAttribute("2")]
internal virtual string GetCompanionHint();
    [IteratorStateMachineAttribute("QuestPDF.Elements.Padding/<<GetCompanionHint>g__GetOptions|19_2>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<ValueTuple`2<string, float>> <GetCompanionHint>g__GetOptions|19_2();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.Page : object {
    [CompilerGeneratedAttribute]
private ContentDirection <ContentDirection>k__BackingField;
    [CompilerGeneratedAttribute]
private TextStyle <DefaultTextStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <MinSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <MaxSize>k__BackingField;
    [CompilerGeneratedAttribute]
private float <MarginLeft>k__BackingField;
    [CompilerGeneratedAttribute]
private float <MarginRight>k__BackingField;
    [CompilerGeneratedAttribute]
private float <MarginTop>k__BackingField;
    [CompilerGeneratedAttribute]
private float <MarginBottom>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <BackgroundColor>k__BackingField;
    [CompilerGeneratedAttribute]
private Element <Background>k__BackingField;
    [CompilerGeneratedAttribute]
private Element <Foreground>k__BackingField;
    [CompilerGeneratedAttribute]
private Element <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private Element <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private Element <Footer>k__BackingField;
    public ContentDirection ContentDirection { get; public set; }
    public TextStyle DefaultTextStyle { get; public set; }
    public Size MinSize { get; public set; }
    public Size MaxSize { get; public set; }
    public float MarginLeft { get; public set; }
    public float MarginRight { get; public set; }
    public float MarginTop { get; public set; }
    public float MarginBottom { get; public set; }
    public Color BackgroundColor { get; public set; }
    public Element Background { get; public set; }
    public Element Foreground { get; public set; }
    public Element Header { get; public set; }
    public Element Content { get; public set; }
    public Element Footer { get; public set; }
    [CompilerGeneratedAttribute]
public ContentDirection get_ContentDirection();
    [CompilerGeneratedAttribute]
public void set_ContentDirection(ContentDirection value);
    [CompilerGeneratedAttribute]
public TextStyle get_DefaultTextStyle();
    [CompilerGeneratedAttribute]
public void set_DefaultTextStyle(TextStyle value);
    [CompilerGeneratedAttribute]
public Size get_MinSize();
    [CompilerGeneratedAttribute]
public void set_MinSize(Size value);
    [CompilerGeneratedAttribute]
public Size get_MaxSize();
    [CompilerGeneratedAttribute]
public void set_MaxSize(Size value);
    [CompilerGeneratedAttribute]
public float get_MarginLeft();
    [CompilerGeneratedAttribute]
public void set_MarginLeft(float value);
    [CompilerGeneratedAttribute]
public float get_MarginRight();
    [CompilerGeneratedAttribute]
public void set_MarginRight(float value);
    [CompilerGeneratedAttribute]
public float get_MarginTop();
    [CompilerGeneratedAttribute]
public void set_MarginTop(float value);
    [CompilerGeneratedAttribute]
public float get_MarginBottom();
    [CompilerGeneratedAttribute]
public void set_MarginBottom(float value);
    [CompilerGeneratedAttribute]
public Color get_BackgroundColor();
    [CompilerGeneratedAttribute]
public void set_BackgroundColor(Color value);
    [CompilerGeneratedAttribute]
public Element get_Background();
    [CompilerGeneratedAttribute]
public void set_Background(Element value);
    [CompilerGeneratedAttribute]
public Element get_Foreground();
    [CompilerGeneratedAttribute]
public void set_Foreground(Element value);
    [CompilerGeneratedAttribute]
public Element get_Header();
    [CompilerGeneratedAttribute]
public void set_Header(Element value);
    [CompilerGeneratedAttribute]
public Element get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(Element value);
    [CompilerGeneratedAttribute]
public Element get_Footer();
    [CompilerGeneratedAttribute]
public void set_Footer(Element value);
    public sealed virtual void Compose(IContainer container);
    [CompilerGeneratedAttribute]
private void <Compose>b__56_0(LayersDescriptor layers);
    [CompilerGeneratedAttribute]
private void <Compose>b__56_2(DecorationDescriptor decoration);
    [CompilerGeneratedAttribute]
private IContainer <Compose>b__56_3(IContainer x);
    [CompilerGeneratedAttribute]
private IContainer <Compose>b__56_4(IContainer x);
    [CompilerGeneratedAttribute]
internal static bool <Compose>g__IsClose|56_1(float x, float y);
}
internal class QuestPDF.Elements.PageBreak : Element {
    [CompilerGeneratedAttribute]
private bool <IsRendered>k__BackingField;
    private bool IsRendered { get; private set; }
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
    [CompilerGeneratedAttribute]
private bool get_IsRendered();
    [CompilerGeneratedAttribute]
private void set_IsRendered(bool value);
    public sealed virtual void ResetState(bool hardReset);
    [NullableContextAttribute("1")]
public sealed virtual object GetState();
    [NullableContextAttribute("1")]
public sealed virtual void SetState(object state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.Placeholder : object {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string Text { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    public sealed virtual void Compose(IContainer container);
    [CompilerGeneratedAttribute]
private void <Compose>b__4_0(IContainer x);
}
internal class QuestPDF.Elements.RepeatContent : ContainerElement {
    [CompilerGeneratedAttribute]
private bool <IsTextOptimizationExecuted>k__BackingField;
    private bool IsTextOptimizationExecuted { get; private set; }
    internal virtual void Draw(Size availableSpace);
    [CompilerGeneratedAttribute]
private bool get_IsTextOptimizationExecuted();
    [CompilerGeneratedAttribute]
private void set_IsTextOptimizationExecuted(bool value);
    private void OptimizeTextCacheBehavior();
}
internal class QuestPDF.Elements.Rotate : ContainerElement {
    [CompilerGeneratedAttribute]
private float <Angle>k__BackingField;
    public float Angle { get; public set; }
    [CompilerGeneratedAttribute]
public float get_Angle();
    [CompilerGeneratedAttribute]
public void set_Angle(float value);
    internal virtual void Draw(Size availableSpace);
    [NullableContextAttribute("2")]
internal virtual string GetCompanionHint();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.Row : Element {
    [CompilerGeneratedAttribute]
private ContentDirection <ContentDirection>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<RowItem> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Spacing>k__BackingField;
    public ContentDirection ContentDirection { get; public set; }
    internal List`1<RowItem> Items { get; }
    internal float Spacing { get; internal set; }
    [CompilerGeneratedAttribute]
public sealed virtual ContentDirection get_ContentDirection();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ContentDirection(ContentDirection value);
    [CompilerGeneratedAttribute]
internal List`1<RowItem> get_Items();
    [CompilerGeneratedAttribute]
internal float get_Spacing();
    [CompilerGeneratedAttribute]
internal void set_Spacing(float value);
    internal virtual IEnumerable`1<Element> GetChildren();
    internal virtual void CreateProxy(Func`2<Element, Element> create);
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
    private void UpdateItemsWidth(float availableWidth);
    private ICollection`1<RowItemRenderingCommand> PlanLayout(Size availableSpace);
    public sealed virtual void ResetState(bool hardReset);
    public sealed virtual object GetState();
    public sealed virtual void SetState(object state);
}
internal class QuestPDF.Elements.RowItem : ContainerElement {
    [CompilerGeneratedAttribute]
private bool <IsRendered>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private RowItemType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Size>k__BackingField;
    public bool IsRendered { get; public set; }
    public float Width { get; public set; }
    public RowItemType Type { get; public set; }
    public float Size { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsRendered();
    [CompilerGeneratedAttribute]
public void set_IsRendered(bool value);
    [CompilerGeneratedAttribute]
public float get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(float value);
    [CompilerGeneratedAttribute]
public RowItemType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(RowItemType value);
    [CompilerGeneratedAttribute]
public float get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(float value);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.RowItemRenderingCommand : object {
    [CompilerGeneratedAttribute]
private RowItem <RowItem>k__BackingField;
    [CompilerGeneratedAttribute]
private SpacePlan <Measurement>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private Position <Offset>k__BackingField;
    public RowItem RowItem { get; public set; }
    public SpacePlan Measurement { get; public set; }
    public Size Size { get; public set; }
    public Position Offset { get; public set; }
    [CompilerGeneratedAttribute]
public RowItem get_RowItem();
    [CompilerGeneratedAttribute]
public void set_RowItem(RowItem value);
    [CompilerGeneratedAttribute]
public SpacePlan get_Measurement();
    [CompilerGeneratedAttribute]
public void set_Measurement(SpacePlan value);
    [CompilerGeneratedAttribute]
public Size get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(Size value);
    [CompilerGeneratedAttribute]
public Position get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(Position value);
}
internal enum QuestPDF.Elements.RowItemType : Enum {
    public int value__;
    public static RowItemType Auto;
    public static RowItemType Constant;
    public static RowItemType Relative;
}
internal class QuestPDF.Elements.Scale : ContainerElement {
    [CompilerGeneratedAttribute]
private float <ScaleX>k__BackingField;
    [CompilerGeneratedAttribute]
private float <ScaleY>k__BackingField;
    public float ScaleX { get; public set; }
    public float ScaleY { get; public set; }
    [CompilerGeneratedAttribute]
public float get_ScaleX();
    [CompilerGeneratedAttribute]
public void set_ScaleX(float value);
    [CompilerGeneratedAttribute]
public float get_ScaleY();
    [CompilerGeneratedAttribute]
public void set_ScaleY(float value);
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
    [NullableContextAttribute("2")]
internal virtual string GetCompanionHint();
    [IteratorStateMachineAttribute("QuestPDF.Elements.Scale/<<GetCompanionHint>g__GetOptions|10_2>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<ValueTuple`2<string, float>> <GetCompanionHint>g__GetOptions|10_2();
}
internal class QuestPDF.Elements.ScaleToFit : ContainerElement {
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
    private static Size ScaleSize(Size size, float factor);
    private Nullable`1<float> FindPerfectScale(Size availableSpace);
    [CompilerGeneratedAttribute]
private bool <FindPerfectScale>g__ChildFits|3_0(float scale, <>c__DisplayClass3_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.Section : ContainerElement {
    [CompilerGeneratedAttribute]
private string <SectionName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRendered>k__BackingField;
    public string SectionName { get; public set; }
    private bool IsRendered { get; private set; }
    [CompilerGeneratedAttribute]
public string get_SectionName();
    [CompilerGeneratedAttribute]
public void set_SectionName(string value);
    internal virtual void Draw(Size availableSpace);
    [CompilerGeneratedAttribute]
private bool get_IsRendered();
    [CompilerGeneratedAttribute]
private void set_IsRendered(bool value);
    public sealed virtual void ResetState(bool hardReset);
    public sealed virtual object GetState();
    public sealed virtual void SetState(object state);
    [NullableContextAttribute("2")]
internal virtual string GetCompanionHint();
    [NullableContextAttribute("2")]
internal virtual string GetCompanionSearchableContent();
    [IteratorStateMachineAttribute("QuestPDF.Elements.Section/<GetCompanionProperties>d__14")]
internal virtual IEnumerable`1<KeyValuePair`2<string, string>> GetCompanionProperties();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.SectionLink : ContainerElement {
    [CompilerGeneratedAttribute]
private string <SectionName>k__BackingField;
    public string SectionName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SectionName();
    [CompilerGeneratedAttribute]
public void set_SectionName(string value);
    internal virtual void Draw(Size availableSpace);
    [NullableContextAttribute("2")]
internal virtual string GetCompanionHint();
    [NullableContextAttribute("2")]
internal virtual string GetCompanionSearchableContent();
    [IteratorStateMachineAttribute("QuestPDF.Elements.SectionLink/<GetCompanionProperties>d__7")]
internal virtual IEnumerable`1<KeyValuePair`2<string, string>> GetCompanionProperties();
}
internal class QuestPDF.Elements.ShowEntire : ContainerElement {
    internal virtual SpacePlan Measure(Size availableSpace);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.ShowIf : ContainerElement {
    [CompilerGeneratedAttribute]
private Predicate`1<ShowIfContext> <VisibilityPredicate>k__BackingField;
    public Predicate`1<ShowIfContext> VisibilityPredicate { get; public set; }
    [CompilerGeneratedAttribute]
public Predicate`1<ShowIfContext> get_VisibilityPredicate();
    [CompilerGeneratedAttribute]
public void set_VisibilityPredicate(Predicate`1<ShowIfContext> value);
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
    private bool CheckVisibility();
}
public class QuestPDF.Elements.ShowIfContext : object {
    [CompilerGeneratedAttribute]
private int <PageNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalPages>k__BackingField;
    public int PageNumber { get; internal set; }
    public int TotalPages { get; internal set; }
    [CompilerGeneratedAttribute]
public int get_PageNumber();
    [CompilerGeneratedAttribute]
internal void set_PageNumber(int value);
    [CompilerGeneratedAttribute]
public int get_TotalPages();
    [CompilerGeneratedAttribute]
internal void set_TotalPages(int value);
}
internal class QuestPDF.Elements.ShowOnce : ContainerElement {
    [CompilerGeneratedAttribute]
private bool <IsRendered>k__BackingField;
    private bool IsRendered { get; private set; }
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
    [CompilerGeneratedAttribute]
private bool get_IsRendered();
    [CompilerGeneratedAttribute]
private void set_IsRendered(bool value);
    public sealed virtual void ResetState(bool hardReset);
    [NullableContextAttribute("1")]
public sealed virtual object GetState();
    [NullableContextAttribute("1")]
public sealed virtual void SetState(object state);
}
internal class QuestPDF.Elements.Shrink : ContainerElement {
    [CompilerGeneratedAttribute]
private bool <Vertical>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Horizontal>k__BackingField;
    [CompilerGeneratedAttribute]
private ContentDirection <ContentDirection>k__BackingField;
    public bool Vertical { get; public set; }
    public bool Horizontal { get; public set; }
    public ContentDirection ContentDirection { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Vertical();
    [CompilerGeneratedAttribute]
public void set_Vertical(bool value);
    [CompilerGeneratedAttribute]
public bool get_Horizontal();
    [CompilerGeneratedAttribute]
public void set_Horizontal(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual ContentDirection get_ContentDirection();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ContentDirection(ContentDirection value);
    internal virtual void Draw(Size availableSpace);
    [NullableContextAttribute("2")]
internal virtual string GetCompanionHint();
}
internal class QuestPDF.Elements.SimpleRotate : ContainerElement {
    [CompilerGeneratedAttribute]
private int <TurnCount>k__BackingField;
    public int TurnCount { get; public set; }
    public int NormalizedTurnCount { get; }
    [CompilerGeneratedAttribute]
public int get_TurnCount();
    [CompilerGeneratedAttribute]
public void set_TurnCount(int value);
    public int get_NormalizedTurnCount();
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
    [NullableContextAttribute("2")]
internal virtual string GetCompanionHint();
}
internal class QuestPDF.Elements.SkipOnce : ContainerElement {
    [CompilerGeneratedAttribute]
private bool <FirstPageWasSkipped>k__BackingField;
    private bool FirstPageWasSkipped { get; private set; }
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
    [CompilerGeneratedAttribute]
private bool get_FirstPageWasSkipped();
    [CompilerGeneratedAttribute]
private void set_FirstPageWasSkipped(bool value);
    public sealed virtual void ResetState(bool hardReset);
    [NullableContextAttribute("1")]
public sealed virtual object GetState();
    [NullableContextAttribute("1")]
public sealed virtual void SetState(object state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.SourceCodePointer : ContainerElement {
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CalledFrom>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    public string MethodName { get; public set; }
    public string CalledFrom { get; public set; }
    public string FilePath { get; public set; }
    public int LineNumber { get; public set; }
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
public void set_MethodName(string value);
    [CompilerGeneratedAttribute]
public string get_CalledFrom();
    [CompilerGeneratedAttribute]
public void set_CalledFrom(string value);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public void set_LineNumber(int value);
    [NullableContextAttribute("2")]
internal virtual string GetCompanionSearchableContent();
    [IteratorStateMachineAttribute("QuestPDF.Elements.SourceCodePointer/<GetCompanionProperties>d__17")]
internal virtual IEnumerable`1<KeyValuePair`2<string, string>> GetCompanionProperties();
}
internal class QuestPDF.Elements.StopPaging : ContainerElement {
    internal virtual SpacePlan Measure(Size availableSpace);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.SvgImage : Element {
    [CompilerGeneratedAttribute]
private SvgImage <Image>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRendered>k__BackingField;
    public SvgImage Image { get; public set; }
    private bool IsRendered { get; private set; }
    [CompilerGeneratedAttribute]
public SvgImage get_Image();
    [CompilerGeneratedAttribute]
public void set_Image(SvgImage value);
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
    [CompilerGeneratedAttribute]
private bool get_IsRendered();
    [CompilerGeneratedAttribute]
private void set_IsRendered(bool value);
    public sealed virtual void ResetState(bool hardReset);
    public sealed virtual object GetState();
    public sealed virtual void SetState(object state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.SvgPath : Element {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <FillColor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRendered>k__BackingField;
    public string Path { get; public set; }
    public Color FillColor { get; public set; }
    private bool IsRendered { get; private set; }
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public Color get_FillColor();
    [CompilerGeneratedAttribute]
public void set_FillColor(Color value);
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
    [CompilerGeneratedAttribute]
private bool get_IsRendered();
    [CompilerGeneratedAttribute]
private void set_IsRendered(bool value);
    public sealed virtual void ResetState(bool hardReset);
    public sealed virtual object GetState();
    public sealed virtual void SetState(object state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class QuestPDF.Elements.Table.DynamicDictionary`2 : object {
    [CompilerGeneratedAttribute]
private TValue <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<TKey, TValue> <Dictionary>k__BackingField;
    private TValue Default { get; }
    private IDictionary`2<TKey, TValue> Dictionary { get; }
    public TValue Item { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<KeyValuePair`2<TKey, TValue>> Items { get; }
    public DynamicDictionary`2(TValue defaultValue);
    [CompilerGeneratedAttribute]
private TValue get_Default();
    [CompilerGeneratedAttribute]
private IDictionary`2<TKey, TValue> get_Dictionary();
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    public List`1<KeyValuePair`2<TKey, TValue>> get_Items();
}
public interface QuestPDF.Elements.Table.ITableCellContainer {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.Table.Table : Element {
    [CompilerGeneratedAttribute]
private List`1<TableColumnDefinition> <Columns>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TableCell> <Cells>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExtendLastCellsToTableBottom>k__BackingField;
    [CompilerGeneratedAttribute]
private ContentDirection <ContentDirection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CacheInitialized>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartingRowsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RowsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxRow>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxRowSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private TableCell[][] <CellsCache>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentRow>k__BackingField;
    public List`1<TableColumnDefinition> Columns { get; public set; }
    public List`1<TableCell> Cells { get; public set; }
    public bool ExtendLastCellsToTableBottom { get; public set; }
    public ContentDirection ContentDirection { get; public set; }
    private bool CacheInitialized { get; private set; }
    private int StartingRowsCount { get; private set; }
    private int RowsCount { get; private set; }
    private int MaxRow { get; private set; }
    private int MaxRowSpan { get; private set; }
    private TableCell[][] CellsCache { get; private set; }
    private bool IsRendered { get; }
    private int CurrentRow { get; private set; }
    [CompilerGeneratedAttribute]
public List`1<TableColumnDefinition> get_Columns();
    [CompilerGeneratedAttribute]
public void set_Columns(List`1<TableColumnDefinition> value);
    [CompilerGeneratedAttribute]
public List`1<TableCell> get_Cells();
    [CompilerGeneratedAttribute]
public void set_Cells(List`1<TableCell> value);
    [CompilerGeneratedAttribute]
public bool get_ExtendLastCellsToTableBottom();
    [CompilerGeneratedAttribute]
public void set_ExtendLastCellsToTableBottom(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual ContentDirection get_ContentDirection();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ContentDirection(ContentDirection value);
    [CompilerGeneratedAttribute]
private bool get_CacheInitialized();
    [CompilerGeneratedAttribute]
private void set_CacheInitialized(bool value);
    [CompilerGeneratedAttribute]
private int get_StartingRowsCount();
    [CompilerGeneratedAttribute]
private void set_StartingRowsCount(int value);
    [CompilerGeneratedAttribute]
private int get_RowsCount();
    [CompilerGeneratedAttribute]
private void set_RowsCount(int value);
    [CompilerGeneratedAttribute]
private int get_MaxRow();
    [CompilerGeneratedAttribute]
private void set_MaxRow(int value);
    [CompilerGeneratedAttribute]
private int get_MaxRowSpan();
    [CompilerGeneratedAttribute]
private void set_MaxRowSpan(int value);
    [CompilerGeneratedAttribute]
private TableCell[][] get_CellsCache();
    [CompilerGeneratedAttribute]
private void set_CellsCache(TableCell[][] value);
    private bool get_IsRendered();
    internal virtual IEnumerable`1<Element> GetChildren();
    private void Initialize();
    private void BuildCache();
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
    private int CalculateCurrentRow(ICollection`1<TableCellRenderingCommand> commands);
    private void UpdateColumnsWidth(float availableWidth);
    private ICollection`1<TableCellRenderingCommand> PlanLayout(Size availableSpace);
    [CompilerGeneratedAttribute]
private int get_CurrentRow();
    [CompilerGeneratedAttribute]
private void set_CurrentRow(int value);
    public sealed virtual void ResetState(bool hardReset);
    public sealed virtual object GetState();
    public sealed virtual void SetState(object state);
    [CompilerGeneratedAttribute]
internal static Single[] <PlanLayout>g__GetColumnLeftOffsets|49_0(IList`1<TableColumnDefinition> columns);
    [CompilerGeneratedAttribute]
internal static void <PlanLayout>g__AdjustCellSizes|49_2(ICollection`1<TableCellRenderingCommand> commands, DynamicDictionary`2<int, float> rowBottomOffsets);
    [CompilerGeneratedAttribute]
internal static void <PlanLayout>g__AdjustLastCellSizes|49_3(float tableHeight, ICollection`1<TableCellRenderingCommand> commands);
}
internal class QuestPDF.Elements.Table.TableCell : ContainerElement {
    [CompilerGeneratedAttribute]
private int <Row>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RowSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColumnSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ZIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRendered>k__BackingField;
    public int Row { get; public set; }
    public int RowSpan { get; public set; }
    public int Column { get; public set; }
    public int ColumnSpan { get; public set; }
    public int ZIndex { get; public set; }
    public bool IsRendered { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Row();
    [CompilerGeneratedAttribute]
public void set_Row(int value);
    [CompilerGeneratedAttribute]
public int get_RowSpan();
    [CompilerGeneratedAttribute]
public void set_RowSpan(int value);
    [CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
public void set_Column(int value);
    [CompilerGeneratedAttribute]
public int get_ColumnSpan();
    [CompilerGeneratedAttribute]
public void set_ColumnSpan(int value);
    [CompilerGeneratedAttribute]
public int get_ZIndex();
    [CompilerGeneratedAttribute]
public void set_ZIndex(int value);
    [CompilerGeneratedAttribute]
public bool get_IsRendered();
    [CompilerGeneratedAttribute]
public void set_IsRendered(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.Table.TableCellRenderingCommand : object {
    [CompilerGeneratedAttribute]
private TableCell <Cell>k__BackingField;
    [CompilerGeneratedAttribute]
private SpacePlan <Measurement>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private Position <Offset>k__BackingField;
    public TableCell Cell { get; public set; }
    public SpacePlan Measurement { get; public set; }
    public Size Size { get; public set; }
    public Position Offset { get; public set; }
    [CompilerGeneratedAttribute]
public TableCell get_Cell();
    [CompilerGeneratedAttribute]
public void set_Cell(TableCell value);
    [CompilerGeneratedAttribute]
public SpacePlan get_Measurement();
    [CompilerGeneratedAttribute]
public void set_Measurement(SpacePlan value);
    [CompilerGeneratedAttribute]
public Size get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(Size value);
    [CompilerGeneratedAttribute]
public Position get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(Position value);
}
internal class QuestPDF.Elements.Table.TableColumnDefinition : object {
    [CompilerGeneratedAttribute]
private float <ConstantSize>k__BackingField;
    [CompilerGeneratedAttribute]
private float <RelativeSize>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Width>k__BackingField;
    public float ConstantSize { get; }
    public float RelativeSize { get; }
    internal float Width { get; internal set; }
    public TableColumnDefinition(float constantSize, float relativeSize);
    [CompilerGeneratedAttribute]
public float get_ConstantSize();
    [CompilerGeneratedAttribute]
public float get_RelativeSize();
    [CompilerGeneratedAttribute]
internal float get_Width();
    [CompilerGeneratedAttribute]
internal void set_Width(float value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class QuestPDF.Elements.Table.TableLayoutPlanner : object {
    [ExtensionAttribute]
public static void PlanCellPositions(Table table);
    private static void PlanCellPositions(int columnsCount, ICollection`1<TableCell> cells);
    [NullableContextAttribute("0")]
[IteratorStateMachineAttribute("QuestPDF.Elements.Table.TableLayoutPlanner/<GenerateCoordinates>d__2")]
private static IEnumerable`1<ValueTuple`2<int, int>> GenerateCoordinates(int columnsCount, ValueTuple`2<int, int> startPosition);
    [ExtensionAttribute]
private static bool CollidesWith(TableCell cell, TableCell neighbour);
    [ExtensionAttribute]
private static bool CollidesWithAnyOf(TableCell cell, ICollection`1<TableCell> neighbours);
    [ExtensionAttribute]
private static void SetPartialLocation(TableCell cell);
    [ExtensionAttribute]
private static bool HasLocation(TableCell cell);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class QuestPDF.Elements.Table.TableLayoutValidator : object {
    [ExtensionAttribute]
public static void ValidateCellPositions(Table table);
    private static void ValidateCellPositions(int columnsCount, ICollection`1<TableCell> cells);
    [CompilerGeneratedAttribute]
internal static string <ValidateCellPositions>g__GetCellDetails|1_0(TableCell cell);
}
internal interface QuestPDF.Elements.Text.Items.ITextBlockItem {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.Text.Items.TextBlockElement : object {
    [CompilerGeneratedAttribute]
private Element <Element>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <ElementSize>k__BackingField;
    [CompilerGeneratedAttribute]
private TextInjectedElementAlignment <Alignment>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ParagraphBlockIndex>k__BackingField;
    public Element Element { get; public set; }
    public Size ElementSize { get; public set; }
    public TextInjectedElementAlignment Alignment { get; public set; }
    public int ParagraphBlockIndex { get; public set; }
    [CompilerGeneratedAttribute]
public Element get_Element();
    [CompilerGeneratedAttribute]
public void set_Element(Element value);
    [CompilerGeneratedAttribute]
public Size get_ElementSize();
    [CompilerGeneratedAttribute]
public void set_ElementSize(Size value);
    [CompilerGeneratedAttribute]
public TextInjectedElementAlignment get_Alignment();
    [CompilerGeneratedAttribute]
public void set_Alignment(TextInjectedElementAlignment value);
    [CompilerGeneratedAttribute]
public int get_ParagraphBlockIndex();
    [CompilerGeneratedAttribute]
public void set_ParagraphBlockIndex(int value);
    public void ConfigureElement(IPageContext pageContext, ICanvas canvas);
    public void UpdateElementSize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.Text.Items.TextBlockHyperlink : TextBlockSpan {
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ParagraphBeginIndex>k__BackingField;
    public string Url { get; public set; }
    public int ParagraphBeginIndex { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public int get_ParagraphBeginIndex();
    [CompilerGeneratedAttribute]
public void set_ParagraphBeginIndex(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.Text.Items.TextBlockPageNumber : TextBlockSpan {
    public static string PageNumberPlaceholder;
    [CompilerGeneratedAttribute]
private Func`2<IPageContext, string> <Source>k__BackingField;
    public Func`2<IPageContext, string> Source { get; public set; }
    [CompilerGeneratedAttribute]
public Func`2<IPageContext, string> get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(Func`2<IPageContext, string> value);
    public void UpdatePageNumberText(IPageContext context);
}
internal class QuestPDF.Elements.Text.Items.TextBlockParagraphSpacing : object {
    [CompilerGeneratedAttribute]
private float <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Height>k__BackingField;
    public float Width { get; }
    public float Height { get; }
    public TextBlockParagraphSpacing(float width, float height);
    [CompilerGeneratedAttribute]
public float get_Width();
    [CompilerGeneratedAttribute]
public float get_Height();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.Text.Items.TextBlockSectionLink : TextBlockSpan {
    [CompilerGeneratedAttribute]
private string <SectionName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ParagraphBeginIndex>k__BackingField;
    public string SectionName { get; public set; }
    public int ParagraphBeginIndex { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SectionName();
    [CompilerGeneratedAttribute]
public void set_SectionName(string value);
    [CompilerGeneratedAttribute]
public int get_ParagraphBeginIndex();
    [CompilerGeneratedAttribute]
public void set_ParagraphBeginIndex(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.Text.Items.TextBlockSpan : object {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private TextStyle <Style>k__BackingField;
    public string Text { get; public set; }
    public TextStyle Style { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    [CompilerGeneratedAttribute]
public TextStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(TextStyle value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class QuestPDF.Elements.Text.SkParagraphBuilderPoolManager : object {
    [CompilerGeneratedAttribute]
private static ConcurrentDictionary`2<ParagraphStyleConfiguration, ConcurrentBag`1<SkParagraphBuilder>> <ObjectPool>k__BackingField;
    private static ConcurrentDictionary`2<ParagraphStyleConfiguration, ConcurrentBag`1<SkParagraphBuilder>> ObjectPool { get; }
    private static SkParagraphBuilderPoolManager();
    [CompilerGeneratedAttribute]
private static ConcurrentDictionary`2<ParagraphStyleConfiguration, ConcurrentBag`1<SkParagraphBuilder>> get_ObjectPool();
    public static SkParagraphBuilder Get(ParagraphStyleConfiguration configuration);
    public static void Return(SkParagraphBuilder builder);
    private static ConcurrentBag`1<SkParagraphBuilder> GetPool(ParagraphStyleConfiguration configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Elements.Text.TextBlock : Element {
    [CompilerGeneratedAttribute]
private List`1<ITextBlockItem> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TextHorizontalAlignment> <Alignment>k__BackingField;
    [CompilerGeneratedAttribute]
private ContentDirection <ContentDirection>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LineClamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LineClampEllipsis>k__BackingField;
    [CompilerGeneratedAttribute]
private float <ParagraphSpacing>k__BackingField;
    [CompilerGeneratedAttribute]
private float <ParagraphFirstLineIndentation>k__BackingField;
    [CompilerGeneratedAttribute]
private TextStyle <DefaultTextStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RebuildParagraphForEveryPage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AreParagraphMetricsValid>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AreParagraphItemsTransformedWithSpacingAndIndentation>k__BackingField;
    [CompilerGeneratedAttribute]
private SkSize[] <LineMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private float <WidthForLineMetricsCalculation>k__BackingField;
    [CompilerGeneratedAttribute]
private float <MaximumWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private SkRect[] <PlaceholderPositions>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ContainsOnlyWhiteSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private SkParagraph <Paragraph>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ClearInternalCacheAfterFullRender>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<int, float> <ParagraphContainingOnlyWhiteSpaceHeightCache>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRendered>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentLineIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private float <CurrentTopOffset>k__BackingField;
    public List`1<ITextBlockItem> Items { get; public set; }
    public Nullable`1<TextHorizontalAlignment> Alignment { get; public set; }
    public ContentDirection ContentDirection { get; public set; }
    public Nullable`1<int> LineClamp { get; public set; }
    public string LineClampEllipsis { get; public set; }
    public float ParagraphSpacing { get; public set; }
    public float ParagraphFirstLineIndentation { get; public set; }
    public TextStyle DefaultTextStyle { get; public set; }
    private bool RebuildParagraphForEveryPage { get; private set; }
    private bool AreParagraphMetricsValid { get; private set; }
    private bool AreParagraphItemsTransformedWithSpacingAndIndentation { get; private set; }
    private SkSize[] LineMetrics { get; private set; }
    private float WidthForLineMetricsCalculation { get; private set; }
    private float MaximumWidth { get; private set; }
    private SkRect[] PlaceholderPositions { get; private set; }
    private Nullable`1<bool> ContainsOnlyWhiteSpace { get; private set; }
    private SkParagraph Paragraph { get; private set; }
    internal bool ClearInternalCacheAfterFullRender { get; internal set; }
    public string Text { get; }
    private ConcurrentDictionary`2<int, float> ParagraphContainingOnlyWhiteSpaceHeightCache { get; }
    private bool IsRendered { get; private set; }
    private int CurrentLineIndex { get; private set; }
    private float CurrentTopOffset { get; private set; }
    [CompilerGeneratedAttribute]
public List`1<ITextBlockItem> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(List`1<ITextBlockItem> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TextHorizontalAlignment> get_Alignment();
    [CompilerGeneratedAttribute]
public void set_Alignment(Nullable`1<TextHorizontalAlignment> value);
    [CompilerGeneratedAttribute]
public sealed virtual ContentDirection get_ContentDirection();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ContentDirection(ContentDirection value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LineClamp();
    [CompilerGeneratedAttribute]
public void set_LineClamp(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_LineClampEllipsis();
    [CompilerGeneratedAttribute]
public void set_LineClampEllipsis(string value);
    [CompilerGeneratedAttribute]
public float get_ParagraphSpacing();
    [CompilerGeneratedAttribute]
public void set_ParagraphSpacing(float value);
    [CompilerGeneratedAttribute]
public float get_ParagraphFirstLineIndentation();
    [CompilerGeneratedAttribute]
public void set_ParagraphFirstLineIndentation(float value);
    [CompilerGeneratedAttribute]
public TextStyle get_DefaultTextStyle();
    [CompilerGeneratedAttribute]
public void set_DefaultTextStyle(TextStyle value);
    [CompilerGeneratedAttribute]
private bool get_RebuildParagraphForEveryPage();
    [CompilerGeneratedAttribute]
private void set_RebuildParagraphForEveryPage(bool value);
    [CompilerGeneratedAttribute]
private bool get_AreParagraphMetricsValid();
    [CompilerGeneratedAttribute]
private void set_AreParagraphMetricsValid(bool value);
    [CompilerGeneratedAttribute]
private bool get_AreParagraphItemsTransformedWithSpacingAndIndentation();
    [CompilerGeneratedAttribute]
private void set_AreParagraphItemsTransformedWithSpacingAndIndentation(bool value);
    [CompilerGeneratedAttribute]
private SkSize[] get_LineMetrics();
    [CompilerGeneratedAttribute]
private void set_LineMetrics(SkSize[] value);
    [CompilerGeneratedAttribute]
private float get_WidthForLineMetricsCalculation();
    [CompilerGeneratedAttribute]
private void set_WidthForLineMetricsCalculation(float value);
    [CompilerGeneratedAttribute]
private float get_MaximumWidth();
    [CompilerGeneratedAttribute]
private void set_MaximumWidth(float value);
    [CompilerGeneratedAttribute]
private SkRect[] get_PlaceholderPositions();
    [CompilerGeneratedAttribute]
private void set_PlaceholderPositions(SkRect[] value);
    [CompilerGeneratedAttribute]
private Nullable`1<bool> get_ContainsOnlyWhiteSpace();
    [CompilerGeneratedAttribute]
private void set_ContainsOnlyWhiteSpace(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
private SkParagraph get_Paragraph();
    [CompilerGeneratedAttribute]
private void set_Paragraph(SkParagraph value);
    [CompilerGeneratedAttribute]
internal bool get_ClearInternalCacheAfterFullRender();
    [CompilerGeneratedAttribute]
internal void set_ClearInternalCacheAfterFullRender(bool value);
    public string get_Text();
    protected virtual override void Finalize();
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
    private void Initialize();
    private void BuildParagraph();
    private IEnumerable`1<ITextBlockItem> ApplyParagraphSpacingToTextBlockItems();
    private void CalculateParagraphMetrics(Size availableSpace);
    private void CheckUnresolvedGlyphs();
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<int, float> get_ParagraphContainingOnlyWhiteSpaceHeightCache();
    private bool CheckIfContainsOnlyWhiteSpace();
    private float MeasureHeightOfParagraphContainingOnlyWhiteSpace();
    [CompilerGeneratedAttribute]
private bool get_IsRendered();
    [CompilerGeneratedAttribute]
private void set_IsRendered(bool value);
    [CompilerGeneratedAttribute]
private int get_CurrentLineIndex();
    [CompilerGeneratedAttribute]
private void set_CurrentLineIndex(int value);
    [CompilerGeneratedAttribute]
private float get_CurrentTopOffset();
    [CompilerGeneratedAttribute]
private void set_CurrentTopOffset(float value);
    public sealed virtual void ResetState(bool hardReset);
    public sealed virtual object GetState();
    public sealed virtual void SetState(object state);
    [NullableContextAttribute("2")]
internal virtual string GetCompanionHint();
    [NullableContextAttribute("2")]
internal virtual string GetCompanionSearchableContent();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ValueTuple`2<int, float> <Draw>g__DetermineLinesToDraw|76_0(<>c__DisplayClass76_0& );
    [CompilerGeneratedAttribute]
private void <Draw>g__DrawParagraph|76_1(<>c__DisplayClass76_0& );
    [CompilerGeneratedAttribute]
private void <Draw>g__DrawInjectedElements|76_2(<>c__DisplayClass76_0& );
    [CompilerGeneratedAttribute]
private void <Draw>g__DrawHyperlinks|76_3(<>c__DisplayClass76_0& );
    [CompilerGeneratedAttribute]
private void <Draw>g__DrawSectionLinks|76_4(<>c__DisplayClass76_0& );
    [CompilerGeneratedAttribute]
private bool <Draw>g__IsPositionVisible|76_5(Position position, <>c__DisplayClass76_0& );
    [CompilerGeneratedAttribute]
internal static TextAlign <BuildParagraph>g__MapAlignment|78_0(TextHorizontalAlignment alignment);
    [CompilerGeneratedAttribute]
internal static TextDirection <BuildParagraph>g__MapDirection|78_1(ContentDirection direction);
    [CompilerGeneratedAttribute]
internal static PlaceholderAlignment <BuildParagraph>g__MapInjectedTextAlignment|78_2(TextInjectedElementAlignment alignment);
    [CompilerGeneratedAttribute]
private SkParagraph <BuildParagraph>g__CreateParagraph|78_3(SkParagraphBuilder builder);
    [CompilerGeneratedAttribute]
private void <ApplyParagraphSpacingToTextBlockItems>g__AddClonedTextBlockSpanWithTextFragment|79_0(TextBlockSpan originalSpan, string textFragment, <>c__DisplayClass79_0& );
    [CompilerGeneratedAttribute]
private void <ApplyParagraphSpacingToTextBlockItems>g__AddParagraphSpacing|79_1(<>c__DisplayClass79_0& );
    [CompilerGeneratedAttribute]
private void <ApplyParagraphSpacingToTextBlockItems>g__AddParagraphFirstLineIndentation|79_2(<>c__DisplayClass79_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private float <MeasureHeightOfParagraphContainingOnlyWhiteSpace>b__86_0(TextBlockSpan x);
    [CompilerGeneratedAttribute]
internal static float <MeasureHeightOfParagraphContainingOnlyWhiteSpace>g__Measure|86_1(int textStyleId);
}
internal class QuestPDF.Elements.Translate : ContainerElement {
    [CompilerGeneratedAttribute]
private float <TranslateX>k__BackingField;
    [CompilerGeneratedAttribute]
private float <TranslateY>k__BackingField;
    public float TranslateX { get; public set; }
    public float TranslateY { get; public set; }
    [CompilerGeneratedAttribute]
public float get_TranslateX();
    [CompilerGeneratedAttribute]
public void set_TranslateX(float value);
    [CompilerGeneratedAttribute]
public float get_TranslateY();
    [CompilerGeneratedAttribute]
public void set_TranslateY(float value);
    internal virtual void Draw(Size availableSpace);
    [NullableContextAttribute("2")]
internal virtual string GetCompanionHint();
    [IteratorStateMachineAttribute("QuestPDF.Elements.Translate/<<GetCompanionHint>g__GetOptions|9_2>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<ValueTuple`2<string, float>> <GetCompanionHint>g__GetOptions|9_2();
}
internal class QuestPDF.Elements.Unconstrained : ContainerElement {
    [CompilerGeneratedAttribute]
private ContentDirection <ContentDirection>k__BackingField;
    public ContentDirection ContentDirection { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual ContentDirection get_ContentDirection();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ContentDirection(ContentDirection value);
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class QuestPDF.Fluent.AlignmentExtensions : object {
    [ExtensionAttribute]
private static IContainer AlignHorizontal(IContainer element, HorizontalAlignment horizontalAlignment);
    [ExtensionAttribute]
public static IContainer AlignLeft(IContainer element);
    [ExtensionAttribute]
public static IContainer AlignCenter(IContainer element);
    [ExtensionAttribute]
public static IContainer AlignRight(IContainer element);
    [ExtensionAttribute]
private static IContainer AlignVertical(IContainer element, VerticalAlignment verticalAlignment);
    [ExtensionAttribute]
public static IContainer AlignTop(IContainer element);
    [ExtensionAttribute]
public static IContainer AlignMiddle(IContainer element);
    [ExtensionAttribute]
public static IContainer AlignBottom(IContainer element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class QuestPDF.Fluent.BorderExtensions : object {
    [ExtensionAttribute]
private static IContainer Border(IContainer element, float top, float bottom, float left, float right);
    [ExtensionAttribute]
public static IContainer Border(IContainer element, float value, Unit unit);
    [ExtensionAttribute]
public static IContainer BorderVertical(IContainer element, float value, Unit unit);
    [ExtensionAttribute]
public static IContainer BorderHorizontal(IContainer element, float value, Unit unit);
    [ExtensionAttribute]
public static IContainer BorderLeft(IContainer element, float value, Unit unit);
    [ExtensionAttribute]
public static IContainer BorderRight(IContainer element, float value, Unit unit);
    [ExtensionAttribute]
public static IContainer BorderTop(IContainer element, float value, Unit unit);
    [ExtensionAttribute]
public static IContainer BorderBottom(IContainer element, float value, Unit unit);
    [ExtensionAttribute]
public static IContainer BorderColor(IContainer element, Color color);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Fluent.ColumnDescriptor : object {
    [CompilerGeneratedAttribute]
private Column <Column>k__BackingField;
    internal Column Column { get; }
    [CompilerGeneratedAttribute]
internal Column get_Column();
    public void Spacing(float value, Unit unit);
    public IContainer Item();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class QuestPDF.Fluent.ColumnExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("This element has been renamed since version 2022.2. Please use the 'Column' method.")]
public static void Stack(IContainer element, Action`1<ColumnDescriptor> handler);
    [ExtensionAttribute]
public static void Column(IContainer element, Action`1<ColumnDescriptor> handler);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Fluent.ComponentDescriptor`1 : object {
    [CompilerGeneratedAttribute]
private T <Component>k__BackingField;
    public T Component { get; }
    public ComponentDescriptor`1(T component);
    [CompilerGeneratedAttribute]
public T get_Component();
    public IContainer Slot(Expression`1<Func`2<T, ISlot>> selector);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class QuestPDF.Fluent.ComponentExtensions : object {
    [ExtensionAttribute]
public static void Component(IContainer element, T component);
    [ExtensionAttribute]
public static void Component(IContainer element);
    [ExtensionAttribute]
private static void Component(IContainer element, T component, Action`1<ComponentDescriptor`1<T>> handler);
    [ExtensionAttribute]
private static void Component(IContainer element, Action`1<ComponentDescriptor`1<T>> handler);
    [ExtensionAttribute]
private static void Slot(IContainer element, ISlot slot);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class QuestPDF.Fluent.ConstrainedExtensions : object {
    [ExtensionAttribute]
private static IContainer ConstrainedWidth(IContainer element, Nullable`1<float> min, Nullable`1<float> max);
    [ExtensionAttribute]
public static IContainer Width(IContainer element, float value, Unit unit);
    [ExtensionAttribute]
public static IContainer MinWidth(IContainer element, float value, Unit unit);
    [ExtensionAttribute]
public static IContainer MaxWidth(IContainer element, float value, Unit unit);
    [ExtensionAttribute]
private static IContainer ConstrainedHeight(IContainer element, Nullable`1<float> min, Nullable`1<float> max);
    [ExtensionAttribute]
public static IContainer Height(IContainer element, float value, Unit unit);
    [ExtensionAttribute]
public static IContainer MinHeight(IContainer element, float value, Unit unit);
    [ExtensionAttribute]
public static IContainer MaxHeight(IContainer element, float value, Unit unit);
    [ExtensionAttribute]
internal static IContainer EnforceSizeWhenEmpty(IContainer element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class QuestPDF.Fluent.ContentDirectionExtensions : object {
    [ExtensionAttribute]
internal static IContainer ContentDirection(IContainer element, ContentDirection direction);
    [ExtensionAttribute]
public static IContainer ContentFromLeftToRight(IContainer element);
    [ExtensionAttribute]
public static IContainer ContentFromRightToLeft(IContainer element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class QuestPDF.Fluent.DebugExtensions : object {
    [ExtensionAttribute]
public static IContainer DebugArea(IContainer parent, string text, Nullable`1<Color> color);
    [ExtensionAttribute]
public static IContainer DebugPointer(IContainer parent, string label);
    [ExtensionAttribute]
internal static IContainer DebugPointer(IContainer parent, DebugPointerType type, string label);
    [ExtensionAttribute]
internal static IContainer LayoutOverflowVisualization(IContainer parent);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Fluent.DecorationDescriptor : object {
    [CompilerGeneratedAttribute]
private Decoration <Decoration>k__BackingField;
    internal Decoration Decoration { get; }
    [CompilerGeneratedAttribute]
internal Decoration get_Decoration();
    public IContainer Before();
    public void Before(Action`1<IContainer> handler);
    public IContainer Content();
    public void Content(Action`1<IContainer> handler);
    public IContainer After();
    public void After(Action`1<IContainer> handler);
    [ObsoleteAttribute("This element has been renamed since version 2022.2. Please use the 'Before' method.")]
public IContainer Header();
    [ObsoleteAttribute("This element has been renamed since version 2022.2. Please use the 'Before' method.")]
public void Header(Action`1<IContainer> handler);
    [ObsoleteAttribute("This element has been renamed since version 2022.2. Please use the 'After' method.")]
public IContainer Footer();
    [ObsoleteAttribute("This element has been renamed since version 2022.2. Please use the 'After' method.")]
public void Footer(Action`1<IContainer> handler);
}
[ExtensionAttribute]
public static class QuestPDF.Fluent.DecorationExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Decoration(IContainer element, Action`1<DecorationDescriptor> handler);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Fluent.Document : object {
    [CompilerGeneratedAttribute]
private Action`1<IDocumentContainer> <ContentSource>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentMetadata <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentSettings <Settings>k__BackingField;
    private Action`1<IDocumentContainer> ContentSource { get; }
    private DocumentMetadata Metadata { get; private set; }
    private DocumentSettings Settings { get; private set; }
    private static Document();
    private Document(Action`1<IDocumentContainer> contentSource);
    [CompilerGeneratedAttribute]
private Action`1<IDocumentContainer> get_ContentSource();
    [CompilerGeneratedAttribute]
private DocumentMetadata get_Metadata();
    [CompilerGeneratedAttribute]
private void set_Metadata(DocumentMetadata value);
    [CompilerGeneratedAttribute]
private DocumentSettings get_Settings();
    [CompilerGeneratedAttribute]
private void set_Settings(DocumentSettings value);
    public static Document Create(Action`1<IDocumentContainer> handler);
    public Document WithMetadata(DocumentMetadata metadata);
    public Document WithSettings(DocumentSettings settings);
    public static MergedDocument Merge(IEnumerable`1<IDocument> documents);
    public static MergedDocument Merge(IDocument[] documents);
    public sealed virtual DocumentMetadata GetMetadata();
    public sealed virtual DocumentSettings GetSettings();
    public sealed virtual void Compose(IDocumentContainer container);
}
[ExtensionAttribute]
public static class QuestPDF.Fluent.DynamicComponentExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Dynamic(IContainer element, IDynamicComponent dynamicElement);
    [ExtensionAttribute]
public static void Dynamic(IContainer element, IDynamicComponent`1<TState> dynamicElement);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Element(IContainer element, IDynamicElement child);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Fluent.DynamicImageDescriptor : object {
    [CompilerGeneratedAttribute]
private DynamicImage <ImageElement>k__BackingField;
    private DynamicImage ImageElement { get; }
    internal DynamicImageDescriptor(DynamicImage imageElement);
    [CompilerGeneratedAttribute]
private DynamicImage get_ImageElement();
    public DynamicImageDescriptor UseOriginalImage(bool value);
    public DynamicImageDescriptor WithRasterDpi(int dpi);
    public DynamicImageDescriptor WithCompressionQuality(ImageCompressionQuality quality);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class QuestPDF.Fluent.ElementExtensions : object {
    private static string CanvasDeprecatedMessage;
    private static ElementExtensions();
    internal static Container Create(Action`1<IContainer> factory);
    [ExtensionAttribute]
internal static T Element(IContainer element, T child);
    [ExtensionAttribute]
public static void Element(IContainer parent, Action`1<IContainer> handler, string handlerName, string parentName, string sourceFilePath, int sourceLineNumber);
    [ExtensionAttribute]
public static IContainer Element(IContainer parent, Func`2<IContainer, IContainer> handler, string handlerName, string parentName, string sourceFilePath, int sourceLineNumber);
    [ExtensionAttribute]
internal static IContainer NonTrackingElement(IContainer parent, Func`2<IContainer, IContainer> handler);
    [ExtensionAttribute]
public static IContainer AspectRatio(IContainer element, float ratio, AspectRatioOption option);
    [ExtensionAttribute]
public static IContainer Background(IContainer element, Color color);
    [ExtensionAttribute]
public static void Placeholder(IContainer element, string text);
    [ExtensionAttribute]
public static IContainer ShowOnce(IContainer element);
    [ExtensionAttribute]
public static IContainer SkipOnce(IContainer element);
    [ExtensionAttribute]
public static IContainer ShowEntire(IContainer element);
    [ExtensionAttribute]
public static IContainer EnsureSpace(IContainer element, float minHeight);
    [ExtensionAttribute]
public static void PageBreak(IContainer element);
    [ExtensionAttribute]
public static IContainer Container(IContainer element);
    [ExtensionAttribute]
[ObsoleteAttribute("This element has been renamed since version 2022.3. Please use the Hyperlink method.")]
public static IContainer ExternalLink(IContainer element, string url);
    [ExtensionAttribute]
public static IContainer Hyperlink(IContainer element, string url);
    [ExtensionAttribute]
[ObsoleteAttribute("This element has been renamed since version 2022.3. Please use the Section method.")]
public static IContainer Location(IContainer element, string locationName);
    [ExtensionAttribute]
public static IContainer Section(IContainer element, string sectionName);
    [ExtensionAttribute]
[ObsoleteAttribute("This element has been renamed since version 2022.3. Please use the SectionLink method.")]
public static IContainer InternalLink(IContainer element, string locationName);
    [ExtensionAttribute]
public static IContainer SectionLink(IContainer element, string sectionName);
    [ExtensionAttribute]
public static IContainer ShowIf(IContainer element, bool condition);
    [ExtensionAttribute]
public static IContainer ShowIf(IContainer element, Predicate`1<ShowIfContext> predicate);
    [ExtensionAttribute]
public static IContainer Unconstrained(IContainer element);
    [ExtensionAttribute]
public static IContainer DefaultTextStyle(IContainer element, TextStyle textStyle);
    [ExtensionAttribute]
public static IContainer DefaultTextStyle(IContainer element, Func`2<TextStyle, TextStyle> handler);
    [ExtensionAttribute]
public static IContainer StopPaging(IContainer element);
    [ExtensionAttribute]
public static IContainer ScaleToFit(IContainer element);
    [ExtensionAttribute]
public static IContainer Repeat(IContainer element);
    [ExtensionAttribute]
[ObsoleteAttribute("The Canvas API has been deprecated since version 2024.3.0. Please use the .Svg(stringContent) API to provide custom content, and consult documentation webpage regarding integrating SkiaSharp with QuestPDF: https://www.questpdf.com/concepts/skia-sharp-integration.html")]
public static void Canvas(IContainer element, DrawOnCanvas handler);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class QuestPDF.Fluent.ExtendExtensions : object {
    [ExtensionAttribute]
private static IContainer Extend(IContainer element, bool vertical, bool horizontal);
    [ExtensionAttribute]
public static IContainer Extend(IContainer element);
    [ExtensionAttribute]
public static IContainer ExtendVertical(IContainer element);
    [ExtensionAttribute]
public static IContainer ExtendHorizontal(IContainer element);
}
public class QuestPDF.Fluent.GenerateDynamicSvgDelegate : MulticastDelegate {
    public GenerateDynamicSvgDelegate(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual string Invoke(Size size);
    public virtual IAsyncResult BeginInvoke(Size size, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class QuestPDF.Fluent.GenerateExtensions : object {
    private static int GenerateAndShowCounter;
    [ExtensionAttribute]
public static Byte[] GeneratePdf(IDocument document);
    [ExtensionAttribute]
public static void GeneratePdf(IDocument document, string filePath);
    [ExtensionAttribute]
public static void GeneratePdf(IDocument document, Stream stream);
    [ExtensionAttribute]
public static void GeneratePdfAndShow(IDocument document);
    [ExtensionAttribute]
public static Byte[] GenerateXps(IDocument document);
    [ExtensionAttribute]
public static void GenerateXps(IDocument document, string filePath);
    [ExtensionAttribute]
public static void GenerateXps(IDocument document, Stream stream);
    [ExtensionAttribute]
public static void GenerateXpsAndShow(IDocument document);
    [ExtensionAttribute]
public static IEnumerable`1<Byte[]> GenerateImages(IDocument document, ImageGenerationSettings settings);
    [ExtensionAttribute]
public static void GenerateImages(IDocument document, GenerateDocumentImagePath imagePathSource, ImageGenerationSettings settings);
    [ExtensionAttribute]
public static ICollection`1<string> GenerateSvg(IDocument document);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Fluent.GridDescriptor : object {
    [CompilerGeneratedAttribute]
private Grid <Grid>k__BackingField;
    internal Grid Grid { get; }
    [CompilerGeneratedAttribute]
internal Grid get_Grid();
    public void Spacing(float value, Unit unit);
    public void VerticalSpacing(float value, Unit unit);
    public void HorizontalSpacing(float value, Unit unit);
    public void Columns(int value);
    public void Alignment(HorizontalAlignment alignment);
    public void AlignLeft();
    public void AlignCenter();
    public void AlignRight();
    public IContainer Item(int columns);
}
[ExtensionAttribute]
public static class QuestPDF.Fluent.GridExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[ObsoleteAttribute("This element has been deprecated since version 2022.11. Please use the Table element, or the combination of the Row and Column elements.")]
public static void Grid(IContainer element, Action`1<GridDescriptor> handler);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Fluent.ImageDescriptor : object {
    [CompilerGeneratedAttribute]
private Image <ImageElement>k__BackingField;
    [CompilerGeneratedAttribute]
private AspectRatio <AspectRatioElement>k__BackingField;
    [CompilerGeneratedAttribute]
private float <ImageAspectRatio>k__BackingField;
    private Image ImageElement { get; }
    private AspectRatio AspectRatioElement { get; }
    private float ImageAspectRatio { get; }
    internal ImageDescriptor(Image imageElement, AspectRatio aspectRatioElement);
    [CompilerGeneratedAttribute]
private Image get_ImageElement();
    [CompilerGeneratedAttribute]
private AspectRatio get_AspectRatioElement();
    [CompilerGeneratedAttribute]
private float get_ImageAspectRatio();
    public ImageDescriptor UseOriginalImage(bool value);
    public ImageDescriptor WithRasterDpi(int dpi);
    public ImageDescriptor WithCompressionQuality(ImageCompressionQuality quality);
    public ImageDescriptor FitWidth();
    public ImageDescriptor FitHeight();
    public ImageDescriptor FitArea();
    public ImageDescriptor FitUnproportionally();
    internal ImageDescriptor SetAspectRatio(AspectRatioOption option);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class QuestPDF.Fluent.ImageExtensions : object {
    [ExtensionAttribute]
public static ImageDescriptor Image(IContainer parent, Byte[] imageData);
    [ExtensionAttribute]
public static ImageDescriptor Image(IContainer parent, string filePath);
    [ExtensionAttribute]
public static ImageDescriptor Image(IContainer parent, Stream fileStream);
    [ExtensionAttribute]
public static ImageDescriptor Image(IContainer parent, Image image);
    internal static AspectRatioOption GetBestAspectRatioOptionFromParent(IContainer container);
    [ExtensionAttribute]
public static DynamicImageDescriptor Image(IContainer element, GenerateDynamicImageDelegate dynamicImageSource);
    [ExtensionAttribute]
public static DynamicImageDescriptor Image(IContainer element, Func`2<ImageSize, Byte[]> dynamicImageSource);
    [ExtensionAttribute]
[ObsoleteAttribute("This element has been changed since version 2023.5. Please use the Image method overload that takes the GenerateDynamicImageDelegate as an argument.")]
public static void Image(IContainer element, Func`2<Size, Byte[]> imageSource);
    [ExtensionAttribute]
[ObsoleteAttribute("This element has been changed since version 2023.5. Please use the Image method overload that returns the ImageDescriptor object.")]
public static void Image(IContainer parent, Byte[] imageData, ImageScaling scaling);
    [ExtensionAttribute]
[ObsoleteAttribute("This element has been changed since version 2023.5. Please use the Image method overload that returns the ImageDescriptor object.")]
public static void Image(IContainer parent, string filePath, ImageScaling scaling);
    [ExtensionAttribute]
[ObsoleteAttribute("This element has been changed since version 2023.5. Please use the Image method overload that returns the ImageDescriptor object.")]
public static void Image(IContainer parent, Stream fileStream, ImageScaling scaling);
    [ExtensionAttribute]
internal static void ApplyScaling(ImageDescriptor descriptor, ImageScaling scaling);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Fluent.InlinedDescriptor : object {
    [CompilerGeneratedAttribute]
private Inlined <Inlined>k__BackingField;
    internal Inlined Inlined { get; }
    [CompilerGeneratedAttribute]
internal Inlined get_Inlined();
    public void Spacing(float value, Unit unit);
    public void VerticalSpacing(float value, Unit unit);
    public void HorizontalSpacing(float value, Unit unit);
    public void BaselineTop();
    public void BaselineMiddle();
    public void BaselineBottom();
    internal void Alignment(Nullable`1<InlinedAlignment> alignment);
    public void AlignLeft();
    public void AlignCenter();
    public void AlignRight();
    public void AlignJustify();
    public void AlignSpaceAround();
    public IContainer Item();
}
[ExtensionAttribute]
public static class QuestPDF.Fluent.InlinedExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Inlined(IContainer element, Action`1<InlinedDescriptor> handler);
}
[ExtensionAttribute]
public static class QuestPDF.Fluent.LayerExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Layers(IContainer element, Action`1<LayersDescriptor> handler);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Fluent.LayersDescriptor : object {
    [CompilerGeneratedAttribute]
private Layers <Layers>k__BackingField;
    internal Layers Layers { get; }
    [CompilerGeneratedAttribute]
internal Layers get_Layers();
    private IContainer Layer(bool isPrimary);
    public IContainer Layer();
    public IContainer PrimaryLayer();
    internal void Validate();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class QuestPDF.Fluent.LineExtensions : object {
    [ExtensionAttribute]
private static ILine Line(IContainer element, LineType type, float thickness);
    [ExtensionAttribute]
public static ILine LineVertical(IContainer element, float thickness, Unit unit);
    [ExtensionAttribute]
public static ILine LineHorizontal(IContainer element, float thickness, Unit unit);
    [ExtensionAttribute]
public static void LineColor(ILine descriptor, Color color);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Fluent.MultiColumnDescriptor : object {
    [CompilerGeneratedAttribute]
private MultiColumn <MultiColumn>k__BackingField;
    internal MultiColumn MultiColumn { get; }
    [CompilerGeneratedAttribute]
internal MultiColumn get_MultiColumn();
    public void Spacing(float value, Unit unit);
    public void Columns(int value);
    public void BalanceHeight(bool enable);
    public IContainer Content();
    public IContainer Spacer();
}
[ExtensionAttribute]
public static class QuestPDF.Fluent.MultiColumnExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void MultiColumn(IContainer element, Action`1<MultiColumnDescriptor> handler);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class QuestPDF.Fluent.PaddingExtensions : object {
    [ExtensionAttribute]
private static IContainer Padding(IContainer element, float top, float bottom, float left, float right);
    [ExtensionAttribute]
public static IContainer Padding(IContainer element, float value, Unit unit);
    [ExtensionAttribute]
public static IContainer PaddingHorizontal(IContainer element, float value, Unit unit);
    [ExtensionAttribute]
public static IContainer PaddingVertical(IContainer element, float value, Unit unit);
    [ExtensionAttribute]
public static IContainer PaddingTop(IContainer element, float value, Unit unit);
    [ExtensionAttribute]
public static IContainer PaddingBottom(IContainer element, float value, Unit unit);
    [ExtensionAttribute]
public static IContainer PaddingLeft(IContainer element, float value, Unit unit);
    [ExtensionAttribute]
public static IContainer PaddingRight(IContainer element, float value, Unit unit);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Fluent.PageDescriptor : object {
    [CompilerGeneratedAttribute]
private Page <Page>k__BackingField;
    internal Page Page { get; }
    [CompilerGeneratedAttribute]
internal Page get_Page();
    public void Size(float width, float height, Unit unit);
    public void Size(PageSize pageSize);
    public void ContinuousSize(float width, Unit unit);
    public void MinSize(PageSize pageSize);
    public void MaxSize(PageSize pageSize);
    public void MarginLeft(float value, Unit unit);
    public void MarginRight(float value, Unit unit);
    public void MarginTop(float value, Unit unit);
    public void MarginBottom(float value, Unit unit);
    public void MarginVertical(float value, Unit unit);
    public void MarginHorizontal(float value, Unit unit);
    public void Margin(float value, Unit unit);
    public void DefaultTextStyle(TextStyle textStyle);
    public void DefaultTextStyle(Func`2<TextStyle, TextStyle> handler);
    public void ContentFromLeftToRight();
    public void ContentFromRightToLeft();
    public void PageColor(Color color);
    [ObsoleteAttribute("This element has been renamed since version 2022.3. Please use the PageColor method.")]
public void Background(Color color);
    public IContainer Background();
    public IContainer Foreground();
    public IContainer Header();
    public IContainer Content();
    public IContainer Footer();
}
[ExtensionAttribute]
public static class QuestPDF.Fluent.PageExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IDocumentContainer Page(IDocumentContainer document, Action`1<PageDescriptor> handler);
}
public class QuestPDF.Fluent.PageNumberFormatter : MulticastDelegate {
    public PageNumberFormatter(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual string Invoke(Nullable`1<int> pageNumber);
    public virtual IAsyncResult BeginInvoke(Nullable`1<int> pageNumber, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class QuestPDF.Fluent.RotateExtensions : object {
    [ExtensionAttribute]
private static IContainer SimpleRotate(IContainer element, int turnDirection);
    [ExtensionAttribute]
public static IContainer RotateLeft(IContainer element);
    [ExtensionAttribute]
public static IContainer RotateRight(IContainer element);
    [ExtensionAttribute]
public static IContainer Rotate(IContainer element, float angle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Fluent.RowDescriptor : object {
    [CompilerGeneratedAttribute]
private Row <Row>k__BackingField;
    internal Row Row { get; }
    [CompilerGeneratedAttribute]
internal Row get_Row();
    public void Spacing(float value, Unit unit);
    private IContainer Item(RowItemType type, float size);
    [ObsoleteAttribute("This element has been renamed since version 2022.2. Please use the RelativeItem method.")]
public IContainer RelativeColumn(float size);
    [ObsoleteAttribute("This element has been renamed since version 2022.2. Please use the ConstantItem method.")]
public IContainer ConstantColumn(float size);
    public IContainer RelativeItem(float size);
    public IContainer ConstantItem(float size, Unit unit);
    public IContainer AutoItem();
}
[ExtensionAttribute]
public static class QuestPDF.Fluent.RowExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Row(IContainer element, Action`1<RowDescriptor> handler);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class QuestPDF.Fluent.ScaleExtensions : object {
    [ExtensionAttribute]
private static IContainer ScaleValue(IContainer element, float x, float y);
    [ExtensionAttribute]
public static IContainer Scale(IContainer element, float factor);
    [ExtensionAttribute]
public static IContainer ScaleHorizontal(IContainer element, float factor);
    [ExtensionAttribute]
public static IContainer ScaleVertical(IContainer element, float factor);
    [ExtensionAttribute]
public static IContainer FlipHorizontal(IContainer element);
    [ExtensionAttribute]
public static IContainer FlipVertical(IContainer element);
    [ExtensionAttribute]
public static IContainer FlipOver(IContainer element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class QuestPDF.Fluent.ShrinkExtensions : object {
    [ExtensionAttribute]
private static IContainer Shrink(IContainer element, Nullable`1<bool> vertical, Nullable`1<bool> horizontal);
    [ExtensionAttribute]
public static IContainer Shrink(IContainer element);
    [ExtensionAttribute]
public static IContainer ShrinkVertical(IContainer element);
    [ExtensionAttribute]
public static IContainer ShrinkHorizontal(IContainer element);
    [ExtensionAttribute]
[ObsoleteAttribute("This element has been renamed since version 2022.1. Please use the Shrink method.")]
public static IContainer Box(IContainer element);
    [ExtensionAttribute]
[ObsoleteAttribute("This element has been renamed since version 2023.11. Please use the Shrink method.")]
public static IContainer MinimalBox(IContainer element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class QuestPDF.Fluent.SvgExtensions : object {
    [ExtensionAttribute]
internal static void SvgPath(IContainer container, string svgPath, Color color);
    [ExtensionAttribute]
public static SvgImageDescriptor Svg(IContainer container, string svg);
    [ExtensionAttribute]
public static SvgImageDescriptor Svg(IContainer parent, SvgImage image);
    [ExtensionAttribute]
public static void Svg(IContainer element, GenerateDynamicSvgDelegate dynamicSvgSource);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Fluent.SvgImageDescriptor : object {
    [CompilerGeneratedAttribute]
private SvgImage <ImageElement>k__BackingField;
    [CompilerGeneratedAttribute]
private AspectRatio <AspectRatioElement>k__BackingField;
    [CompilerGeneratedAttribute]
private float <ImageAspectRatio>k__BackingField;
    private SvgImage ImageElement { get; }
    private AspectRatio AspectRatioElement { get; }
    private float ImageAspectRatio { get; }
    internal SvgImageDescriptor(SvgImage imageElement, AspectRatio aspectRatioElement);
    [CompilerGeneratedAttribute]
private SvgImage get_ImageElement();
    [CompilerGeneratedAttribute]
private AspectRatio get_AspectRatioElement();
    [CompilerGeneratedAttribute]
private float get_ImageAspectRatio();
    public SvgImageDescriptor FitWidth();
    public SvgImageDescriptor FitHeight();
    public SvgImageDescriptor FitArea();
    internal SvgImageDescriptor SetAspectRatio(AspectRatioOption option);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Fluent.TableCellDescriptor : object {
    [CompilerGeneratedAttribute]
private ICollection`1<TableCell> <Cells>k__BackingField;
    private ICollection`1<TableCell> Cells { get; }
    internal TableCellDescriptor(ICollection`1<TableCell> cells);
    [CompilerGeneratedAttribute]
private ICollection`1<TableCell> get_Cells();
    public ITableCellContainer Cell();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class QuestPDF.Fluent.TableCellExtensions : object {
    [ExtensionAttribute]
public static ITableCellContainer Column(ITableCellContainer tableCellContainer, UInt32 value);
    [ExtensionAttribute]
public static ITableCellContainer ColumnSpan(ITableCellContainer tableCellContainer, UInt32 value);
    [ExtensionAttribute]
public static ITableCellContainer Row(ITableCellContainer tableCellContainer, UInt32 value);
    [ExtensionAttribute]
public static ITableCellContainer RowSpan(ITableCellContainer tableCellContainer, UInt32 value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Fluent.TableColumnsDefinitionDescriptor : object {
    [CompilerGeneratedAttribute]
private List`1<TableColumnDefinition> <Columns>k__BackingField;
    internal List`1<TableColumnDefinition> Columns { get; }
    [CompilerGeneratedAttribute]
internal List`1<TableColumnDefinition> get_Columns();
    public void ConstantColumn(float width, Unit unit);
    public void RelativeColumn(float width);
    private void ComplexColumn(float constantWidth, float relativeWidth);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Fluent.TableDescriptor : object {
    [CompilerGeneratedAttribute]
private Table <HeaderTable>k__BackingField;
    [CompilerGeneratedAttribute]
private Table <ContentTable>k__BackingField;
    [CompilerGeneratedAttribute]
private Table <FooterTable>k__BackingField;
    private Table HeaderTable { get; }
    private Table ContentTable { get; }
    private Table FooterTable { get; }
    [CompilerGeneratedAttribute]
private Table get_HeaderTable();
    [CompilerGeneratedAttribute]
private Table get_ContentTable();
    [CompilerGeneratedAttribute]
private Table get_FooterTable();
    public void ColumnsDefinition(Action`1<TableColumnsDefinitionDescriptor> handler);
    public void ExtendLastCellsToTableBottom();
    public void Header(Action`1<TableCellDescriptor> handler);
    public void Footer(Action`1<TableCellDescriptor> handler);
    public ITableCellContainer Cell();
    internal IElement CreateElement();
    private static void ConfigureTable(Table table);
    [CompilerGeneratedAttribute]
private void <CreateElement>b__14_0(DecorationDescriptor decoration);
}
[ExtensionAttribute]
public static class QuestPDF.Fluent.TableExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Table(IContainer element, Action`1<TableDescriptor> handler);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Fluent.TextBlockDescriptor : TextSpanDescriptor {
    private TextBlock TextBlock;
    internal TextBlockDescriptor(TextBlock textBlock, TextBlockSpan textBlockSpan);
    public TextBlockDescriptor AlignLeft();
    public TextBlockDescriptor AlignCenter();
    public TextBlockDescriptor AlignRight();
    public TextBlockDescriptor Justify();
    public TextBlockDescriptor AlignStart();
    public TextBlockDescriptor AlignEnd();
    public TextBlockDescriptor ClampLines(int maxLines, string ellipsis);
    public TextBlockDescriptor ParagraphSpacing(float value, Unit unit);
    public TextBlockDescriptor ParagraphFirstLineIndentation(float value, Unit unit);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Fluent.TextDescriptor : object {
    [CompilerGeneratedAttribute]
private TextBlock <TextBlock>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TextStyle <DefaultStyle>k__BackingField;
    internal static string DefaultLineClampEllipsis;
    internal TextBlock TextBlock { get; }
    [NullableAttribute("2")]
private TextStyle DefaultStyle { get; private set; }
    [CompilerGeneratedAttribute]
internal TextBlock get_TextBlock();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private TextStyle get_DefaultStyle();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_DefaultStyle(TextStyle value);
    public void DefaultTextStyle(TextStyle style);
    public void DefaultTextStyle(Func`2<TextStyle, TextStyle> style);
    public void AlignLeft();
    public void AlignCenter();
    public void AlignRight();
    public void Justify();
    public void AlignStart();
    public void AlignEnd();
    public void ClampLines(int maxLines, string ellipsis);
    public void ParagraphSpacing(float value, Unit unit);
    public void ParagraphFirstLineIndentation(float value, Unit unit);
    [ObsoleteAttribute("This element has been renamed since version 2022.3. Please use the overload that returns a TextSpanDescriptor object which allows to specify text style.")]
public void Span(string text, TextStyle style);
    public TextSpanDescriptor Span(string text);
    public TextSpanDescriptor Line(string text);
    public TextSpanDescriptor EmptyLine();
    private TextPageNumberDescriptor PageNumber(Func`2<IPageContext, Nullable`1<int>> pageNumber);
    public TextPageNumberDescriptor CurrentPageNumber();
    public TextPageNumberDescriptor TotalPages();
    [ObsoleteAttribute("This element has been renamed since version 2022.3. Please use the BeginPageNumberOfSection method.")]
public void PageNumberOfLocation(string sectionName, TextStyle style);
    public TextPageNumberDescriptor BeginPageNumberOfSection(string sectionName);
    public TextPageNumberDescriptor EndPageNumberOfSection(string sectionName);
    public TextPageNumberDescriptor PageNumberWithinSection(string sectionName);
    public TextPageNumberDescriptor TotalPagesWithinSection(string sectionName);
    public TextSpanDescriptor SectionLink(string text, string sectionName);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("This element has been renamed since version 2022.3. Please use the SectionLink method.")]
public void InternalLocation(string text, string locationName, TextStyle style);
    public TextSpanDescriptor Hyperlink(string text, string url);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("This element has been renamed since version 2022.3. Please use the Hyperlink method.")]
public void ExternalLocation(string text, string url, TextStyle style);
    public IContainer Element(TextInjectedElementAlignment alignment);
    public void Element(Action`1<IContainer> handler, TextInjectedElementAlignment alignment);
    internal void Compose(IContainer container);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class QuestPDF.Fluent.TextExtensions : object {
    [ExtensionAttribute]
public static void Text(IContainer element, Action`1<TextDescriptor> content);
    [ExtensionAttribute]
[ObsoleteAttribute("This method has been deprecated since version 2022.3. Please use the overload that returns a TextSpanDescriptor object which allows to specify text style.")]
public static void Text(IContainer element, object text, TextStyle style);
    [ExtensionAttribute]
[ObsoleteAttribute("This method has been deprecated since version 2022.12. Please use an overload where the text parameter is passed explicitly as a string.")]
public static TextSpanDescriptor Text(IContainer element, object text);
    [ExtensionAttribute]
public static TextBlockDescriptor Text(IContainer container, string text);
    private static Nullable`1<TextHorizontalAlignment> MapAlignment(Nullable`1<HorizontalAlignment> alignment);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Fluent.TextPageNumberDescriptor : TextSpanDescriptor {
    [CompilerGeneratedAttribute]
private Action`1<PageNumberFormatter> <AssignFormatFunction>k__BackingField;
    internal Action`1<PageNumberFormatter> AssignFormatFunction { get; }
    internal TextPageNumberDescriptor(TextBlockSpan textBlockSpan, Action`1<PageNumberFormatter> assignFormatFunction);
    [CompilerGeneratedAttribute]
internal Action`1<PageNumberFormatter> get_AssignFormatFunction();
    public TextPageNumberDescriptor Format(PageNumberFormatter formatter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Fluent.TextSpanDescriptor : object {
    internal TextBlockSpan TextBlockSpan;
    internal TextSpanDescriptor(TextBlockSpan textBlockSpan);
    internal void MutateTextStyle(Func`3<TextStyle, T, TextStyle> handler, T argument);
    internal void MutateTextStyle(Func`2<TextStyle, TextStyle> handler);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class QuestPDF.Fluent.TextSpanDescriptorExtensions : object {
    [ExtensionAttribute]
public static T Style(T descriptor, TextStyle style);
    [ExtensionAttribute]
[ObsoleteAttribute("This setting is not supported since the 2024.3 version. Please use the FontFamilyFallback method or rely on the new automated fallback mechanism.")]
public static T Fallback(T descriptor, TextStyle value);
    [ExtensionAttribute]
[ObsoleteAttribute("This setting is not supported since the 2024.3 version. Please use the FontFamilyFallback method or rely on the new automated fallback mechanism.")]
public static T Fallback(T descriptor, Func`2<TextStyle, TextStyle> handler);
    [ExtensionAttribute]
public static T FontColor(T descriptor, Color color);
    [ExtensionAttribute]
public static T BackgroundColor(T descriptor, Color color);
    [ExtensionAttribute]
public static T FontFamily(T descriptor, String[] values);
    [ExtensionAttribute]
public static T FontSize(T descriptor, float value);
    [ExtensionAttribute]
public static T LineHeight(T descriptor, Nullable`1<float> factor);
    [ExtensionAttribute]
public static T LetterSpacing(T descriptor, float factor);
    [ExtensionAttribute]
public static T WordSpacing(T descriptor, float factor);
    [ExtensionAttribute]
public static T Italic(T descriptor, bool value);
    [ExtensionAttribute]
[ObsoleteAttribute("This setting is not supported since the 2024.3 version. This flag should be handled automatically by the layout engine.")]
public static T WrapAnywhere(T descriptor, bool value);
    [ExtensionAttribute]
public static T Strikethrough(T descriptor, bool value);
    [ExtensionAttribute]
public static T Underline(T descriptor, bool value);
    [ExtensionAttribute]
public static T Overline(T descriptor, bool value);
    [ExtensionAttribute]
public static T DecorationColor(T descriptor, Color color);
    [ExtensionAttribute]
public static T DecorationThickness(T descriptor, float factor);
    [ExtensionAttribute]
public static T DecorationSolid(T descriptor);
    [ExtensionAttribute]
public static T DecorationDouble(T descriptor);
    [ExtensionAttribute]
public static T DecorationWavy(T descriptor);
    [ExtensionAttribute]
public static T DecorationDotted(T descriptor);
    [ExtensionAttribute]
public static T DecorationDashed(T descriptor);
    [ExtensionAttribute]
public static T Thin(T descriptor);
    [ExtensionAttribute]
public static T ExtraLight(T descriptor);
    [ExtensionAttribute]
public static T Light(T descriptor);
    [ExtensionAttribute]
public static T NormalWeight(T descriptor);
    [ExtensionAttribute]
public static T Medium(T descriptor);
    [ExtensionAttribute]
public static T SemiBold(T descriptor);
    [ExtensionAttribute]
public static T Bold(T descriptor);
    [ExtensionAttribute]
public static T ExtraBold(T descriptor);
    [ExtensionAttribute]
public static T Black(T descriptor);
    [ExtensionAttribute]
public static T ExtraBlack(T descriptor);
    [ExtensionAttribute]
public static T NormalPosition(T descriptor);
    [ExtensionAttribute]
public static T Subscript(T descriptor);
    [ExtensionAttribute]
public static T Superscript(T descriptor);
    [ExtensionAttribute]
public static T DirectionAuto(T descriptor);
    [ExtensionAttribute]
public static T DirectionFromLeftToRight(T descriptor);
    [ExtensionAttribute]
public static T DirectionFromRightToLeft(T descriptor);
    [ExtensionAttribute]
public static T EnableFontFeature(T descriptor, string featureName);
    [ExtensionAttribute]
public static T DisableFontFeature(T descriptor, string featureName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class QuestPDF.Fluent.TextStyleExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("This element has been renamed since version 2022.3. Please use the FontColor method.")]
public static TextStyle Color(TextStyle style, string value);
    [ExtensionAttribute]
public static TextStyle FontColor(TextStyle style, Color color);
    [ExtensionAttribute]
public static TextStyle BackgroundColor(TextStyle style, Color color);
    [ExtensionAttribute]
[ObsoleteAttribute("This element has been renamed since version 2022.3. Please use the FontFamily method.")]
public static TextStyle FontType(TextStyle style, string value);
    [ExtensionAttribute]
public static TextStyle FontFamily(TextStyle style, String[] values);
    [ExtensionAttribute]
[ObsoleteAttribute("This element has been renamed since version 2022.3. Please use the FontSize method.")]
public static TextStyle Size(TextStyle style, float value);
    [ExtensionAttribute]
public static TextStyle FontSize(TextStyle style, float value);
    [ExtensionAttribute]
public static TextStyle LineHeight(TextStyle style, Nullable`1<float> factor);
    [ExtensionAttribute]
public static TextStyle LetterSpacing(TextStyle style, float factor);
    [ExtensionAttribute]
public static TextStyle WordSpacing(TextStyle style, float factor);
    [ExtensionAttribute]
public static TextStyle Italic(TextStyle style, bool value);
    [ExtensionAttribute]
[ObsoleteAttribute("This setting is not supported since the 2024.3 version. This flag should be handled automatically by the layout engine.")]
public static TextStyle WrapAnywhere(TextStyle style, bool value);
    [ExtensionAttribute]
public static TextStyle Strikethrough(TextStyle style, bool value);
    [ExtensionAttribute]
public static TextStyle Underline(TextStyle style, bool value);
    [ExtensionAttribute]
public static TextStyle Overline(TextStyle style, bool value);
    [ExtensionAttribute]
public static TextStyle DecorationColor(TextStyle style, Color color);
    [ExtensionAttribute]
public static TextStyle DecorationThickness(TextStyle style, float factor);
    [ExtensionAttribute]
public static TextStyle DecorationSolid(TextStyle style);
    [ExtensionAttribute]
public static TextStyle DecorationDouble(TextStyle style);
    [ExtensionAttribute]
public static TextStyle DecorationWavy(TextStyle style);
    [ExtensionAttribute]
public static TextStyle DecorationDotted(TextStyle style);
    [ExtensionAttribute]
public static TextStyle DecorationDashed(TextStyle style);
    [ExtensionAttribute]
public static TextStyle Weight(TextStyle style, FontWeight weight);
    [ExtensionAttribute]
public static TextStyle Thin(TextStyle style);
    [ExtensionAttribute]
public static TextStyle ExtraLight(TextStyle style);
    [ExtensionAttribute]
public static TextStyle Light(TextStyle style);
    [ExtensionAttribute]
public static TextStyle NormalWeight(TextStyle style);
    [ExtensionAttribute]
public static TextStyle Medium(TextStyle style);
    [ExtensionAttribute]
public static TextStyle SemiBold(TextStyle style);
    [ExtensionAttribute]
public static TextStyle Bold(TextStyle style);
    [ExtensionAttribute]
public static TextStyle ExtraBold(TextStyle style);
    [ExtensionAttribute]
public static TextStyle Black(TextStyle style);
    [ExtensionAttribute]
public static TextStyle ExtraBlack(TextStyle style);
    [ExtensionAttribute]
public static TextStyle NormalPosition(TextStyle style);
    [ExtensionAttribute]
public static TextStyle Subscript(TextStyle style);
    [ExtensionAttribute]
public static TextStyle Superscript(TextStyle style);
    [ExtensionAttribute]
private static TextStyle Position(TextStyle style, FontPosition fontPosition);
    [ExtensionAttribute]
[ObsoleteAttribute("This setting is not supported since the 2024.3 version. Please use the FontFamilyFallback method or rely on the new automated fallback mechanism.")]
public static TextStyle Fallback(TextStyle style, TextStyle value);
    [ExtensionAttribute]
[ObsoleteAttribute("This setting is not supported since the 2024.3 version. Please use the FontFamilyFallback method or rely on the new automated fallback mechanism.")]
public static TextStyle Fallback(TextStyle style, Func`2<TextStyle, TextStyle> handler);
    [ExtensionAttribute]
private static TextStyle TextDirection(TextStyle style, TextDirection textDirection);
    [ExtensionAttribute]
public static TextStyle DirectionAuto(TextStyle style);
    [ExtensionAttribute]
public static TextStyle DirectionFromLeftToRight(TextStyle style);
    [ExtensionAttribute]
public static TextStyle DirectionFromRightToLeft(TextStyle style);
    [ExtensionAttribute]
public static TextStyle EnableFontFeature(TextStyle style, string featureName);
    [ExtensionAttribute]
public static TextStyle DisableFontFeature(TextStyle style, string featureName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class QuestPDF.Fluent.TranslateExtensions : object {
    [ExtensionAttribute]
private static IContainer Translate(IContainer element, float x, float y);
    [ExtensionAttribute]
public static IContainer TranslateX(IContainer element, float value, Unit unit);
    [ExtensionAttribute]
public static IContainer TranslateY(IContainer element, float value, Unit unit);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class QuestPDF.Helpers.ColorParser : object {
    private static ConcurrentDictionary`2<string, Nullable`1<Color>> Cache;
    private static ColorParser();
    public static Color ParseColorHex(string hexString);
    public static bool TryParseColorHex(string hexString, Color& color);
    [CompilerGeneratedAttribute]
internal static Nullable`1<Color> <TryParseColorHex>g__ParseColor|2_0(string hexString);
}
public static class QuestPDF.Helpers.Colors : object {
    public static Color Black;
    public static Color White;
    public static Color Transparent;
    private static Colors();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class QuestPDF.Helpers.FontFeatures : object {
    public static string AccessAllAlternates;
    public static string AboveBaseForms;
    public static string AboveBaseMarkPositioning;
    public static string AboveBaseSubstitutions;
    public static string AlternativeFractions;
    public static string Akhand;
    public static string KerningForAlternateProportionalWidths;
    public static string BelowBaseForms;
    public static string BelowBaseMarkPositioning;
    public static string BelowBaseSubstitutions;
    public static string ContextualAlternates;
    public static string CaseSensitiveForms;
    public static string GlyphCompositionDecomposition;
    public static string ConjunctFormAfterRo;
    public static string ContextualHalfWidthSpacing;
    public static string ConjunctForms;
    public static string ContextualLigatures;
    public static string CenteredCjkPunctuation;
    public static string CapitalSpacing;
    public static string ContextualSwash;
    public static string CursivePositioning;
    public static string PetiteCapitalsFromCapitals;
    public static string SmallCapitalsFromCapitals;
    public static string Distances;
    public static string DiscretionaryLigatures;
    public static string Denominators;
    public static string DotlessForms;
    public static string ExpertForms;
    public static string FinalGlyphOnLineAlternates;
    public static string TerminalForms2;
    public static string TerminalForms3;
    public static string TerminalForms;
    public static string FlattenedAccentForms;
    public static string Fractions;
    public static string FullWidths;
    public static string HalfForms;
    public static string HalantForms;
    public static string AlternateHalfWidths;
    public static string HistoricalForms;
    public static string HorizontalKanaAlternates;
    public static string HistoricalLigatures;
    public static string Hangul;
    public static string HalfWidths;
    public static string InitialForms;
    public static string IsolatedForms;
    public static string Italics;
    public static string JustificationAlternates;
    public static string JIS78Forms;
    public static string JIS83Forms;
    public static string JIS90Forms;
    public static string JIS2004Forms;
    public static string Kerning;
    public static string LeftBounds;
    public static string StandardLigatures;
    public static string LeadingJamoForms;
    public static string LiningFigures;
    public static string LocalizedForms;
    public static string LeftToRightAlternates;
    public static string LeftToRightMirroredForms;
    public static string MarkPositioning;
    public static string MedialForms2;
    public static string MedialForms;
    public static string MathematicalGreek;
    public static string MarkToMarkPositioning;
    public static string MarkPositioningViaSubstitution;
    public static string AlternateAnnotationForms;
    public static string NlcKanjiForms;
    public static string NuktaForms;
    public static string Numerators;
    public static string OldstyleFigures;
    public static string OpticalBounds;
    public static string Ordinals;
    public static string Ornaments;
    public static string ProportionalAlternateWidths;
    public static string PetiteCapitals;
    public static string ProportionalKana;
    public static string ProportionalFigures;
    public static string PreBaseForms;
    public static string PreBaseSubstitutions;
    public static string PostBaseForms;
    public static string PostBaseSubstitutions;
    public static string ProportionalWidths;
    public static string QuarterWidths;
    public static string Randomize;
    public static string RequiredContextualAlternates;
    public static string RakarForms;
    public static string RequiredLigatures;
    public static string RephForm;
    public static string RightBounds;
    public static string RightToLeftAlternates;
    public static string RightToLeftMirroredForms;
    public static string RubyNotationForms;
    public static string RequiredVariationAlternates;
    public static string StylisticAlternates;
    public static string ScientificInferiors;
    public static string OpticalSize;
    public static string SmallCapitals;
    public static string SimplifiedForms;
    public static string MathScriptStyleAlternates;
    public static string StretchingGlyphDecomposition;
    public static string Subscript;
    public static string Superscript;
    public static string Swash;
    public static string Titling;
    public static string TrailingJamoForms;
    public static string TraditionalNameForms;
    public static string TabularFigures;
    public static string TraditionalForms;
    public static string ThirdWidths;
    public static string Unicase;
    public static string AlternateVerticalMetrics;
    public static string KerningForAlternateProportionalVerticalMetrics;
    public static string VattuVariants;
    public static string VerticalContextualHalfWidthSpacing;
    public static string VerticalAlternates;
    public static string AlternateVerticalHalfMetrics;
    public static string VowelJamoForms;
    public static string VerticalKanaAlternates;
    public static string VerticalKerning;
    public static string ProportionalAlternateVerticalMetrics;
    public static string VerticalAlternatesAndRotation;
    public static string VerticalAlternatesForRotation;
    public static string SlashedZero;
    public static string HojoKanjiForms;
    public static string CharacterVariant(int value);
    public static string StylisticSet(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Helpers.Fonts : object {
    public static string Arial;
    public static string Calibri;
    public static string Cambria;
    public static string Candara;
    public static string ComicSans;
    public static string Consolas;
    public static string Corbel;
    public static string Courier;
    public static string CourierNew;
    public static string Georgia;
    public static string Impact;
    public static string Lato;
    public static string LucidaConsole;
    public static string SegoeSD;
    public static string SegoeUI;
    public static string Tahoma;
    public static string TimesNewRoman;
    public static string TimesRoman;
    public static string Trebuchet;
    public static string Verdana;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class QuestPDF.Helpers.Helpers : object {
    internal static string ApplicationFilesPath { get; }
    private static Helpers();
    internal static Byte[] LoadEmbeddedResource(string resourceName);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
private static PropertyInfo ToPropertyInfo(Expression`1<Func`2<T, TValue>> selector);
    [ExtensionAttribute]
internal static string GetPropertyName(Expression`1<Func`2<T, TValue>> selector);
    [ExtensionAttribute]
internal static TValue GetPropertyValue(T target, Expression`1<Func`2<T, TValue>> selector);
    [ExtensionAttribute]
internal static void SetPropertyValue(T target, Expression`1<Func`2<T, TValue>> selector, TValue value);
    [ExtensionAttribute]
internal static string PrettifyName(string text);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static void VisitChildren(Element element, Action`1<Element> handler);
    [ExtensionAttribute]
internal static bool IsNegative(Size size);
    [ExtensionAttribute]
internal static bool IsEmpty(Element element);
    [ExtensionAttribute]
internal static int ToQualityValue(ImageCompressionQuality quality);
    [ExtensionAttribute]
internal static bool ToDownsamplingStrategy(ImageCompressionQuality quality);
    [ExtensionAttribute]
internal static SkImage CompressImage(SkImage image, ImageCompressionQuality compressionQuality);
    [ExtensionAttribute]
internal static SkImage ResizeAndCompressImage(SkImage image, ImageSize targetResolution, ImageCompressionQuality compressionQuality);
    internal static SkImage GetImageWithSmallerSize(SkImage one, SkImage second);
    internal static void OpenFileUsingDefaultProgram(string filePath);
    internal static string get_ApplicationFilesPath();
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static ValueTuple`2<float, float> CalculateSpaceScale(SkSvgImage image, Size availableSpace);
    [CompilerGeneratedAttribute]
internal static float <CalculateSpaceScale>g__CalculateDimensionScale|18_0(float availableSize, float imageSize, Unit unit);
    [CompilerGeneratedAttribute]
internal static float <CalculateSpaceScale>g__ConvertToPoints|18_1(float value, Unit unit);
}
internal static class QuestPDF.Helpers.NativeDependencyCompatibilityChecker : object {
    private static bool IsCompatibilityChecked;
    public static void Test();
}
public class QuestPDF.Helpers.PageSize : object {
    public float Width;
    public float Height;
    public PageSize(float width, float height, Unit unit);
    [NullableContextAttribute("1")]
public static Size op_Implicit(PageSize pageSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class QuestPDF.Helpers.PageSizeExtensions : object {
    [ExtensionAttribute]
public static PageSize Portrait(PageSize size);
    [ExtensionAttribute]
public static PageSize Landscape(PageSize size);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class QuestPDF.Helpers.PageSizes : object {
    public static int PointsPerInch;
    public static PageSize A0 { get; }
    public static PageSize A1 { get; }
    public static PageSize A2 { get; }
    public static PageSize A3 { get; }
    public static PageSize A4 { get; }
    public static PageSize A5 { get; }
    public static PageSize A6 { get; }
    public static PageSize A7 { get; }
    public static PageSize A8 { get; }
    public static PageSize A9 { get; }
    public static PageSize A10 { get; }
    public static PageSize B0 { get; }
    public static PageSize B1 { get; }
    public static PageSize B2 { get; }
    public static PageSize B3 { get; }
    public static PageSize B4 { get; }
    public static PageSize B5 { get; }
    public static PageSize B6 { get; }
    public static PageSize B7 { get; }
    public static PageSize B8 { get; }
    public static PageSize B9 { get; }
    public static PageSize B10 { get; }
    public static PageSize C0 { get; }
    public static PageSize C1 { get; }
    public static PageSize C2 { get; }
    public static PageSize C3 { get; }
    public static PageSize C4 { get; }
    public static PageSize C5 { get; }
    public static PageSize C6 { get; }
    public static PageSize C7 { get; }
    public static PageSize C8 { get; }
    public static PageSize C9 { get; }
    public static PageSize C10 { get; }
    public static PageSize Env10 { get; }
    public static PageSize EnvC4 { get; }
    public static PageSize EnvDL { get; }
    public static PageSize Postcard { get; }
    public static PageSize Executive { get; }
    public static PageSize Letter { get; }
    public static PageSize Legal { get; }
    public static PageSize Ledger { get; }
    public static PageSize Tabloid { get; }
    public static PageSize ARCH_A { get; }
    public static PageSize ARCH_B { get; }
    public static PageSize ARCH_C { get; }
    public static PageSize ARCH_D { get; }
    public static PageSize ARCH_E { get; }
    public static PageSize ARCH_E1 { get; }
    public static PageSize ARCH_E2 { get; }
    public static PageSize ARCH_E3 { get; }
    public static PageSize get_A0();
    public static PageSize get_A1();
    public static PageSize get_A2();
    public static PageSize get_A3();
    public static PageSize get_A4();
    public static PageSize get_A5();
    public static PageSize get_A6();
    public static PageSize get_A7();
    public static PageSize get_A8();
    public static PageSize get_A9();
    public static PageSize get_A10();
    public static PageSize get_B0();
    public static PageSize get_B1();
    public static PageSize get_B2();
    public static PageSize get_B3();
    public static PageSize get_B4();
    public static PageSize get_B5();
    public static PageSize get_B6();
    public static PageSize get_B7();
    public static PageSize get_B8();
    public static PageSize get_B9();
    public static PageSize get_B10();
    public static PageSize get_C0();
    public static PageSize get_C1();
    public static PageSize get_C2();
    public static PageSize get_C3();
    public static PageSize get_C4();
    public static PageSize get_C5();
    public static PageSize get_C6();
    public static PageSize get_C7();
    public static PageSize get_C8();
    public static PageSize get_C9();
    public static PageSize get_C10();
    public static PageSize get_Env10();
    public static PageSize get_EnvC4();
    public static PageSize get_EnvDL();
    public static PageSize get_Postcard();
    public static PageSize get_Executive();
    public static PageSize get_Letter();
    public static PageSize get_Legal();
    public static PageSize get_Ledger();
    public static PageSize get_Tabloid();
    public static PageSize get_ARCH_A();
    public static PageSize get_ARCH_B();
    public static PageSize get_ARCH_C();
    public static PageSize get_ARCH_D();
    public static PageSize get_ARCH_E();
    public static PageSize get_ARCH_E1();
    public static PageSize get_ARCH_E2();
    public static PageSize get_ARCH_E3();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class QuestPDF.Helpers.Placeholders : object {
    public static Random Random;
    private static string CommonParagraph;
    private static String[] LatinWords;
    private static String[] LongLatinWords;
    private static Color[] BackgroundColors;
    private static Placeholders();
    private static string RandomWord();
    private static string LongRandomWord();
    private static string RandomWords(int min, int max);
    public static string LoremIpsum();
    public static string Label();
    public static string Sentence();
    public static string Question();
    public static string Paragraph();
    public static string Paragraphs();
    public static string Email();
    public static string Name();
    public static string PhoneNumber();
    [ExtensionAttribute]
private static string FirstCharToUpper(string text);
    private static DateTime RandomDate();
    public static string Time();
    public static string ShortDate();
    public static string LongDate();
    public static string DateTime();
    public static string Integer();
    public static string Decimal();
    public static string Percent();
    public static Color BackgroundColor();
    public static Color Color();
    public static Byte[] Image(int width, int height);
    public static Byte[] Image(ImageSize size);
    [CompilerGeneratedAttribute]
internal static ImageSize <Image>g__LimitSize|30_1(ImageSize size, int maxSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Infrastructure.ArrayContainer`1 : ValueType {
    [CompilerGeneratedAttribute]
private T[] <Items>k__BackingField;
    public T[] Items { get; }
    public ArrayContainer`1(object array);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public T[] get_Items();
    public bool Equals(ArrayContainer`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum QuestPDF.Infrastructure.AspectRatioOption : Enum {
    public int value__;
    public static AspectRatioOption FitWidth;
    public static AspectRatioOption FitHeight;
    public static AspectRatioOption FitArea;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class QuestPDF.Infrastructure.Color : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <Hex>k__BackingField;
    public UInt32 Hex { get; }
    public byte Alpha { get; }
    public byte Red { get; }
    public byte Green { get; }
    public byte Blue { get; }
    public Color(UInt32 hex);
    [CompilerGeneratedAttribute]
public UInt32 get_Hex();
    public byte get_Alpha();
    public byte get_Red();
    public byte get_Green();
    public byte get_Blue();
    public Color WithAlpha(byte alpha);
    public static Color FromHex(string hex);
    public static Color FromRGB(byte red, byte green, byte blue);
    public static Color FromARGB(byte alpha, byte red, byte green, byte blue);
    public static string op_Implicit(Color color);
    public static Color op_Implicit(string hex);
    public static UInt32 op_Implicit(Color color);
    public static Color op_Implicit(UInt32 hex);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class QuestPDF.Infrastructure.ContainerElement : Element {
    [CompilerGeneratedAttribute]
private Element <Child>k__BackingField;
    internal Element Child { get; internal set; }
    private IElement QuestPDF.Infrastructure.IContainer.Child { get; private set; }
    [CompilerGeneratedAttribute]
internal Element get_Child();
    [CompilerGeneratedAttribute]
internal void set_Child(Element value);
    private sealed virtual override IElement QuestPDF.Infrastructure.IContainer.get_Child();
    private sealed virtual override void QuestPDF.Infrastructure.IContainer.set_Child(IElement value);
    [IteratorStateMachineAttribute("QuestPDF.Infrastructure.ContainerElement/<GetChildren>d__7")]
internal virtual IEnumerable`1<Element> GetChildren();
    internal virtual void CreateProxy(Func`2<Element, Element> create);
    internal virtual SpacePlan Measure(Size availableSpace);
    internal virtual void Draw(Size availableSpace);
}
public enum QuestPDF.Infrastructure.ContentDirection : Enum {
    public int value__;
    public static ContentDirection LeftToRight;
    public static ContentDirection RightToLeft;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Infrastructure.DocumentLocation : object {
    [CompilerGeneratedAttribute]
private int <DocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PageStart>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PageEnd>k__BackingField;
    public int DocumentId { get; public set; }
    public string Name { get; public set; }
    public int PageStart { get; public set; }
    public int PageEnd { get; public set; }
    public int Length { get; }
    [CompilerGeneratedAttribute]
public int get_DocumentId();
    [CompilerGeneratedAttribute]
public void set_DocumentId(int value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_PageStart();
    [CompilerGeneratedAttribute]
public void set_PageStart(int value);
    [CompilerGeneratedAttribute]
public int get_PageEnd();
    [CompilerGeneratedAttribute]
public void set_PageEnd(int value);
    public int get_Length();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class QuestPDF.Infrastructure.DocumentMetadata : object {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Author>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Keywords>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Creator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Producer>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <CreationDate>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ModifiedDate>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ImageQuality>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <RasterDpi>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <PdfA>k__BackingField;
    public string Title { get; public set; }
    public string Author { get; public set; }
    public string Subject { get; public set; }
    public string Keywords { get; public set; }
    public string Creator { get; public set; }
    public string Producer { get; public set; }
    public DateTimeOffset CreationDate { get; public set; }
    public DateTimeOffset ModifiedDate { get; public set; }
    [NullableAttribute("1")]
public static DocumentMetadata Default { get; }
    [ObsoleteAttribute("This API has been moved since version 2022.9. Please use the QuestPDF.Settings.DocumentLayoutExceptionThreshold static property.")]
public int DocumentLayoutExceptionThreshold { get; public set; }
    [ObsoleteAttribute("This API has been moved since version 2022.9. Please use the QuestPDF.Settings.EnableCaching static property.")]
public bool ApplyCaching { get; public set; }
    [ObsoleteAttribute("This API has been moved since version 2022.9. Please use the QuestPDF.Settings.EnableDebugging static property.")]
public bool ApplyDebugging { get; public set; }
    [ObsoleteAttribute("This API has been moved since version 2023.5. Please use the QuestPDF.Infrastructure.DocumentSettings API.")]
public Nullable`1<int> ImageQuality { get; public set; }
    [ObsoleteAttribute("This API has been moved since version 2023.5. Please use the QuestPDF.Infrastructure.DocumentSettings API.")]
public Nullable`1<int> RasterDpi { get; public set; }
    [ObsoleteAttribute("This API has been moved since version 2023.5. Please use the QuestPDF.Infrastructure.DocumentSettings API.")]
public Nullable`1<bool> PdfA { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Author();
    [CompilerGeneratedAttribute]
public void set_Author(string value);
    [CompilerGeneratedAttribute]
public string get_Subject();
    [CompilerGeneratedAttribute]
public void set_Subject(string value);
    [CompilerGeneratedAttribute]
public string get_Keywords();
    [CompilerGeneratedAttribute]
public void set_Keywords(string value);
    [CompilerGeneratedAttribute]
public string get_Creator();
    [CompilerGeneratedAttribute]
public void set_Creator(string value);
    [CompilerGeneratedAttribute]
public string get_Producer();
    [CompilerGeneratedAttribute]
public void set_Producer(string value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_CreationDate();
    [CompilerGeneratedAttribute]
public void set_CreationDate(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_ModifiedDate();
    [CompilerGeneratedAttribute]
public void set_ModifiedDate(DateTimeOffset value);
    [NullableContextAttribute("1")]
public static DocumentMetadata get_Default();
    public int get_DocumentLayoutExceptionThreshold();
    public void set_DocumentLayoutExceptionThreshold(int value);
    public bool get_ApplyCaching();
    public void set_ApplyCaching(bool value);
    public bool get_ApplyDebugging();
    public void set_ApplyDebugging(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ImageQuality();
    [CompilerGeneratedAttribute]
public void set_ImageQuality(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_RasterDpi();
    [CompilerGeneratedAttribute]
public void set_RasterDpi(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_PdfA();
    [CompilerGeneratedAttribute]
public void set_PdfA(Nullable`1<bool> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Infrastructure.DocumentSettings : object {
    public static int DefaultRasterDpi;
    [CompilerGeneratedAttribute]
private bool <PdfA>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CompressDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private ImageCompressionQuality <ImageCompressionQuality>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ImageRasterDpi>k__BackingField;
    [CompilerGeneratedAttribute]
private ContentDirection <ContentDirection>k__BackingField;
    public bool PdfA { get; public set; }
    public bool CompressDocument { get; public set; }
    public ImageCompressionQuality ImageCompressionQuality { get; public set; }
    public int ImageRasterDpi { get; public set; }
    public ContentDirection ContentDirection { get; public set; }
    public static DocumentSettings Default { get; }
    [CompilerGeneratedAttribute]
public bool get_PdfA();
    [CompilerGeneratedAttribute]
public void set_PdfA(bool value);
    [CompilerGeneratedAttribute]
public bool get_CompressDocument();
    [CompilerGeneratedAttribute]
public void set_CompressDocument(bool value);
    [CompilerGeneratedAttribute]
public ImageCompressionQuality get_ImageCompressionQuality();
    [CompilerGeneratedAttribute]
public void set_ImageCompressionQuality(ImageCompressionQuality value);
    [CompilerGeneratedAttribute]
public int get_ImageRasterDpi();
    [CompilerGeneratedAttribute]
public void set_ImageRasterDpi(int value);
    [CompilerGeneratedAttribute]
public ContentDirection get_ContentDirection();
    [CompilerGeneratedAttribute]
public void set_ContentDirection(ContentDirection value);
    public static DocumentSettings get_Default();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Infrastructure.DynamicComponentComposeResult : object {
    [CompilerGeneratedAttribute]
private IElement <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasMoreContent>k__BackingField;
    public IElement Content { get; public set; }
    public bool HasMoreContent { get; public set; }
    [CompilerGeneratedAttribute]
public IElement get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(IElement value);
    [CompilerGeneratedAttribute]
public bool get_HasMoreContent();
    [CompilerGeneratedAttribute]
public void set_HasMoreContent(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Infrastructure.DynamicComponentProxy : object {
    [CompilerGeneratedAttribute]
private Action`1<object> <SetState>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<object> <GetState>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<DynamicContext, DynamicComponentComposeResult> <Compose>k__BackingField;
    internal Action`1<object> SetState { get; private set; }
    internal Func`1<object> GetState { get; private set; }
    internal Func`2<DynamicContext, DynamicComponentComposeResult> Compose { get; private set; }
    [CompilerGeneratedAttribute]
internal Action`1<object> get_SetState();
    [CompilerGeneratedAttribute]
private void set_SetState(Action`1<object> value);
    [CompilerGeneratedAttribute]
internal Func`1<object> get_GetState();
    [CompilerGeneratedAttribute]
private void set_GetState(Func`1<object> value);
    [CompilerGeneratedAttribute]
internal Func`2<DynamicContext, DynamicComponentComposeResult> get_Compose();
    [CompilerGeneratedAttribute]
private void set_Compose(Func`2<DynamicContext, DynamicComponentComposeResult> value);
    [NullableContextAttribute("0")]
internal static DynamicComponentProxy CreateFrom(IDynamicComponent`1<TState> component);
    internal static DynamicComponentProxy CreateFrom(IDynamicComponent component);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class QuestPDF.Infrastructure.Element : object {
    [CompilerGeneratedAttribute]
private IPageContext <PageContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ICanvas <Canvas>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SourceCodePath> <CodeLocation>k__BackingField;
    internal IPageContext PageContext { get; internal set; }
    internal ICanvas Canvas { get; internal set; }
    internal Nullable`1<SourceCodePath> CodeLocation { get; internal set; }
    [CompilerGeneratedAttribute]
internal IPageContext get_PageContext();
    [CompilerGeneratedAttribute]
internal void set_PageContext(IPageContext value);
    [CompilerGeneratedAttribute]
internal ICanvas get_Canvas();
    [CompilerGeneratedAttribute]
internal void set_Canvas(ICanvas value);
    [CompilerGeneratedAttribute]
internal Nullable`1<SourceCodePath> get_CodeLocation();
    [CompilerGeneratedAttribute]
internal void set_CodeLocation(Nullable`1<SourceCodePath> value);
    [IteratorStateMachineAttribute("QuestPDF.Infrastructure.Element/<GetChildren>d__12")]
internal virtual IEnumerable`1<Element> GetChildren();
    internal virtual void CreateProxy(Func`2<Element, Element> create);
    internal abstract virtual SpacePlan Measure(Size availableSpace);
    internal abstract virtual void Draw(Size availableSpace);
    [NullableContextAttribute("2")]
internal virtual string GetCompanionHint();
    [NullableContextAttribute("2")]
internal virtual string GetCompanionSearchableContent();
    internal virtual IEnumerable`1<KeyValuePair`2<string, string>> GetCompanionProperties();
}
internal enum QuestPDF.Infrastructure.FontPosition : Enum {
    public int value__;
    public static FontPosition Normal;
    public static FontPosition Subscript;
    public static FontPosition Superscript;
}
public enum QuestPDF.Infrastructure.FontWeight : Enum {
    public int value__;
    public static FontWeight Thin;
    public static FontWeight ExtraLight;
    public static FontWeight Light;
    public static FontWeight Normal;
    public static FontWeight Medium;
    public static FontWeight SemiBold;
    public static FontWeight Bold;
    public static FontWeight ExtraBold;
    public static FontWeight Black;
    public static FontWeight ExtraBlack;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Infrastructure.GetImageVersionRequest : object {
    [CompilerGeneratedAttribute]
private ImageSize <Resolution>k__BackingField;
    [CompilerGeneratedAttribute]
private ImageCompressionQuality <CompressionQuality>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    internal ImageSize Resolution { get; internal set; }
    internal ImageCompressionQuality CompressionQuality { get; internal set; }
    [CompilerGeneratedAttribute]
protected GetImageVersionRequest(GetImageVersionRequest original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
internal ImageSize get_Resolution();
    [CompilerGeneratedAttribute]
internal void set_Resolution(ImageSize value);
    [CompilerGeneratedAttribute]
internal ImageCompressionQuality get_CompressionQuality();
    [CompilerGeneratedAttribute]
internal void set_CompressionQuality(ImageCompressionQuality value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(GetImageVersionRequest left, GetImageVersionRequest right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(GetImageVersionRequest left, GetImageVersionRequest right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(GetImageVersionRequest other);
    [CompilerGeneratedAttribute]
public virtual GetImageVersionRequest <Clone>$();
}
public enum QuestPDF.Infrastructure.HorizontalAlignment : Enum {
    public int value__;
    public static HorizontalAlignment Left;
    public static HorizontalAlignment Center;
    public static HorizontalAlignment Right;
}
[NullableContextAttribute("1")]
internal interface QuestPDF.Infrastructure.ICanvas {
    public abstract virtual void Save();
    public abstract virtual void Restore();
    public abstract virtual void Translate(Position vector);
    public abstract virtual void DrawFilledRectangle(Position vector, Size size, Color color);
    public abstract virtual void DrawStrokeRectangle(Position vector, Size size, float strokeWidth, Color color);
    public abstract virtual void DrawParagraph(SkParagraph paragraph);
    public abstract virtual void DrawImage(SkImage image, Size size);
    public abstract virtual void DrawPicture(SkPicture picture);
    public abstract virtual void DrawSvgPath(string path, Color color);
    public abstract virtual void DrawSvg(SkSvgImage svgImage, Size size);
    public abstract virtual void DrawOverflowArea(SkRect area);
    public abstract virtual void ClipOverflowArea(SkRect availableSpace, SkRect requiredSpace);
    public abstract virtual void ClipRectangle(SkRect clipArea);
    public abstract virtual void DrawHyperlink(string url, Size size);
    public abstract virtual void DrawSectionLink(string sectionName, Size size);
    public abstract virtual void DrawSection(string sectionName);
    public abstract virtual void Rotate(float angle);
    public abstract virtual void Scale(float scaleX, float scaleY);
}
[NullableContextAttribute("1")]
public interface QuestPDF.Infrastructure.IComponent {
    public abstract virtual void Compose(IContainer container);
}
[NullableContextAttribute("2")]
public interface QuestPDF.Infrastructure.IContainer {
    public IElement Child { get; public set; }
    public abstract virtual IElement get_Child();
    public abstract virtual void set_Child(IElement value);
}
internal interface QuestPDF.Infrastructure.IContentDirectionAware {
    public ContentDirection ContentDirection { get; public set; }
    public abstract virtual ContentDirection get_ContentDirection();
    public abstract virtual void set_ContentDirection(ContentDirection value);
}
[NullableContextAttribute("1")]
public interface QuestPDF.Infrastructure.IDocument {
    public virtual DocumentMetadata GetMetadata();
    public virtual DocumentSettings GetSettings();
    public abstract virtual void Compose(IDocumentContainer container);
}
public interface QuestPDF.Infrastructure.IDocumentContainer {
}
[NullableContextAttribute("1")]
public interface QuestPDF.Infrastructure.IDynamicComponent {
    public abstract virtual DynamicComponentComposeResult Compose(DynamicContext context);
}
public interface QuestPDF.Infrastructure.IDynamicComponent`1 {
    public TState State { get; public set; }
    public abstract virtual TState get_State();
    public abstract virtual void set_State(TState value);
}
public interface QuestPDF.Infrastructure.IElement {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Infrastructure.Image : object {
    [CompilerGeneratedAttribute]
private SkImage <SkImage>k__BackingField;
    [CompilerGeneratedAttribute]
private ImageSize <Size>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private LinkedList`1<ValueTuple`2<GetImageVersionRequest, SkImage>> <ScaledImageCache>k__BackingField;
    internal SkImage SkImage { get; }
    internal ImageSize Size { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal LinkedList`1<ValueTuple`2<GetImageVersionRequest, SkImage>> ScaledImageCache { get; }
    private static Image();
    internal Image(SkImage image);
    [CompilerGeneratedAttribute]
internal SkImage get_SkImage();
    [CompilerGeneratedAttribute]
internal ImageSize get_Size();
    [CompilerGeneratedAttribute]
internal LinkedList`1<ValueTuple`2<GetImageVersionRequest, SkImage>> get_ScaledImageCache();
    protected virtual override void Finalize();
    internal SkImage GetVersionOfSize(GetImageVersionRequest request);
    public static Image FromBinaryData(Byte[] imageBytes);
    public static Image FromFile(string filePath);
    public static Image FromStream(Stream stream);
    private static Image DecodeImage(SkData imageData);
}
public enum QuestPDF.Infrastructure.ImageCompressionQuality : Enum {
    public int value__;
    public static ImageCompressionQuality Best;
    public static ImageCompressionQuality VeryHigh;
    public static ImageCompressionQuality High;
    public static ImageCompressionQuality Medium;
    public static ImageCompressionQuality Low;
    public static ImageCompressionQuality VeryLow;
}
public enum QuestPDF.Infrastructure.ImageFormat : Enum {
    public int value__;
    public static ImageFormat Jpeg;
    public static ImageFormat Png;
    public static ImageFormat Webp;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Infrastructure.ImageGenerationSettings : object {
    [CompilerGeneratedAttribute]
private ImageFormat <ImageFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private ImageCompressionQuality <ImageCompressionQuality>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RasterDpi>k__BackingField;
    public ImageFormat ImageFormat { get; public set; }
    public ImageCompressionQuality ImageCompressionQuality { get; public set; }
    public int RasterDpi { get; public set; }
    public static ImageGenerationSettings Default { get; }
    [CompilerGeneratedAttribute]
public ImageFormat get_ImageFormat();
    [CompilerGeneratedAttribute]
public void set_ImageFormat(ImageFormat value);
    [CompilerGeneratedAttribute]
public ImageCompressionQuality get_ImageCompressionQuality();
    [CompilerGeneratedAttribute]
public void set_ImageCompressionQuality(ImageCompressionQuality value);
    [CompilerGeneratedAttribute]
public int get_RasterDpi();
    [CompilerGeneratedAttribute]
public void set_RasterDpi(int value);
    public static ImageGenerationSettings get_Default();
}
public enum QuestPDF.Infrastructure.ImageScaling : Enum {
    public int value__;
    public static ImageScaling FitWidth;
    public static ImageScaling FitHeight;
    public static ImageScaling FitArea;
    public static ImageScaling Resize;
}
[IsReadOnlyAttribute]
public class QuestPDF.Infrastructure.ImageSize : ValueType {
    public int Width;
    public int Height;
    public ImageSize(int width, int height);
}
[NullableContextAttribute("1")]
internal interface QuestPDF.Infrastructure.IPageContext {
    public bool IsInitialRenderingPhase { get; }
    public int DocumentLength { get; }
    public int CurrentPage { get; }
    public abstract virtual bool get_IsInitialRenderingPhase();
    public abstract virtual int get_DocumentLength();
    public abstract virtual int get_CurrentPage();
    public abstract virtual void SetSectionPage(string name);
    public abstract virtual DocumentLocation GetLocation(string name);
    public abstract virtual string GetDocumentLocationName(string locationName);
}
internal interface QuestPDF.Infrastructure.IRenderingCanvas {
    public bool DocumentContentHasLayoutOverflowIssues { get; public set; }
    public abstract virtual bool get_DocumentContentHasLayoutOverflowIssues();
    public abstract virtual void set_DocumentContentHasLayoutOverflowIssues(bool value);
    public abstract virtual void MarkCurrentPageAsHavingLayoutIssues();
    public abstract virtual void BeginDocument();
    public abstract virtual void EndDocument();
    public abstract virtual void BeginPage(Size size);
    public abstract virtual void EndPage();
}
internal interface QuestPDF.Infrastructure.ISlot {
}
[NullableContextAttribute("1")]
internal interface QuestPDF.Infrastructure.IStateful {
    public abstract virtual void ResetState(bool hardReset);
    public abstract virtual object GetState();
    public abstract virtual void SetState(object state);
}
public enum QuestPDF.Infrastructure.LicenseType : Enum {
    public int value__;
    public static LicenseType Community;
    public static LicenseType Professional;
    public static LicenseType Enterprise;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Infrastructure.MergedDocument : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IDocument> <Documents>k__BackingField;
    [CompilerGeneratedAttribute]
private MergedDocumentPageNumberStrategy <PageNumberStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentMetadata <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentSettings <Settings>k__BackingField;
    internal IReadOnlyList`1<IDocument> Documents { get; }
    internal MergedDocumentPageNumberStrategy PageNumberStrategy { get; private set; }
    internal DocumentMetadata Metadata { get; private set; }
    internal DocumentSettings Settings { get; private set; }
    internal MergedDocument(IEnumerable`1<IDocument> documents);
    [CompilerGeneratedAttribute]
internal IReadOnlyList`1<IDocument> get_Documents();
    [CompilerGeneratedAttribute]
internal MergedDocumentPageNumberStrategy get_PageNumberStrategy();
    [CompilerGeneratedAttribute]
private void set_PageNumberStrategy(MergedDocumentPageNumberStrategy value);
    [CompilerGeneratedAttribute]
internal DocumentMetadata get_Metadata();
    [CompilerGeneratedAttribute]
private void set_Metadata(DocumentMetadata value);
    [CompilerGeneratedAttribute]
internal DocumentSettings get_Settings();
    [CompilerGeneratedAttribute]
private void set_Settings(DocumentSettings value);
    public sealed virtual void Compose(IDocumentContainer container);
    public sealed virtual DocumentMetadata GetMetadata();
    public sealed virtual DocumentSettings GetSettings();
    public MergedDocument UseOriginalPageNumbers();
    public MergedDocument UseContinuousPageNumbers();
    public MergedDocument WithMetadata(DocumentMetadata metadata);
    public MergedDocument WithSettings(DocumentSettings settings);
}
internal enum QuestPDF.Infrastructure.MergedDocumentPageNumberStrategy : Enum {
    public int value__;
    public static MergedDocumentPageNumberStrategy Original;
    public static MergedDocumentPageNumberStrategy Continuous;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Infrastructure.PageContext : object {
    [CompilerGeneratedAttribute]
private bool <IsInitialRenderingPhase>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DocumentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<DocumentLocation> <Locations>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentDocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentPage>k__BackingField;
    public bool IsInitialRenderingPhase { get; private set; }
    public int DocumentLength { get; private set; }
    private List`1<DocumentLocation> Locations { get; }
    public int CurrentDocumentId { get; private set; }
    public int CurrentPage { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsInitialRenderingPhase();
    [CompilerGeneratedAttribute]
private void set_IsInitialRenderingPhase(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_DocumentLength();
    [CompilerGeneratedAttribute]
private void set_DocumentLength(int value);
    [CompilerGeneratedAttribute]
private List`1<DocumentLocation> get_Locations();
    [CompilerGeneratedAttribute]
public int get_CurrentDocumentId();
    [CompilerGeneratedAttribute]
private void set_CurrentDocumentId(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_CurrentPage();
    [CompilerGeneratedAttribute]
private void set_CurrentPage(int value);
    internal void SetDocumentId(int id);
    internal void ProceedToNextRenderingPhase();
    internal void DecrementPageNumber();
    internal void IncrementPageNumber();
    public sealed virtual void SetSectionPage(string name);
    public sealed virtual DocumentLocation GetLocation(string name);
    public sealed virtual string GetDocumentLocationName(string locationName);
}
[IsReadOnlyAttribute]
internal class QuestPDF.Infrastructure.Position : ValueType {
    public float X;
    public float Y;
    public static Position Zero { get; }
    public Position(float x, float y);
    public static Position get_Zero();
    public Position Reverse();
    public static bool Equal(Position first, Position second);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[IsReadOnlyAttribute]
public class QuestPDF.Infrastructure.Size : ValueType {
    public static float Epsilon;
    public static float Infinity;
    public float Width;
    public float Height;
    [CompilerGeneratedAttribute]
private static Size <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Size <Max>k__BackingField;
    public static Size Zero { get; }
    public static Size Max { get; }
    public Size(float width, float height);
    private static Size();
    [CompilerGeneratedAttribute]
public static Size get_Zero();
    [CompilerGeneratedAttribute]
public static Size get_Max();
    internal static bool Equal(Size first, Size second);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
internal class QuestPDF.Infrastructure.Slot : Container {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class QuestPDF.Infrastructure.SourceCodePath : ValueType {
    public string FilePath;
    public int LineNumber;
    public SourceCodePath(StackFrame frame);
    internal static Nullable`1<SourceCodePath> CreateFromCurrentStackTrace();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Infrastructure.SvgImage : object {
    [CompilerGeneratedAttribute]
private SkSvgImage <SkSvgImage>k__BackingField;
    internal SkSvgImage SkSvgImage { get; }
    private SvgImage(string content);
    [CompilerGeneratedAttribute]
internal SkSvgImage get_SkSvgImage();
    protected virtual override void Finalize();
    public static SvgImage FromFile(string filePath);
    public static SvgImage FromText(string svg);
}
internal enum QuestPDF.Infrastructure.TextDirection : Enum {
    public int value__;
    public static TextDirection Auto;
    public static TextDirection LeftToRight;
    public static TextDirection RightToLeft;
}
public enum QuestPDF.Infrastructure.TextHorizontalAlignment : Enum {
    public int value__;
    public static TextHorizontalAlignment Left;
    public static TextHorizontalAlignment Center;
    public static TextHorizontalAlignment Right;
    public static TextHorizontalAlignment Justify;
    public static TextHorizontalAlignment Start;
    public static TextHorizontalAlignment End;
}
public enum QuestPDF.Infrastructure.TextInjectedElementAlignment : Enum {
    public int value__;
    public static TextInjectedElementAlignment AboveBaseline;
    public static TextInjectedElementAlignment BelowBaseline;
    public static TextInjectedElementAlignment Top;
    public static TextInjectedElementAlignment Bottom;
    public static TextInjectedElementAlignment Middle;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class QuestPDF.Infrastructure.TextStyle : object {
    internal static float NormalLineHeightCalculatedFromFontMetrics;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Color> <Color>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Color> <BackgroundColor>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Color> <DecorationColor>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <FontFamilies>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueTuple`2[] <FontFeatures>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<float> <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<float> <LineHeight>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<float> <LetterSpacing>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<float> <WordSpacing>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<FontWeight> <FontWeight>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<FontPosition> <FontPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsItalic>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <HasStrikethrough>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <HasUnderline>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <HasOverline>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TextDecorationStyle> <DecorationStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<float> <DecorationThickness>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TextDirection> <Direction>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextStyle <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextStyle <LibraryDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextStyle <ParagraphSpacing>k__BackingField;
    [NullableAttribute("2")]
private SkTextStyle SkTextStyleCache;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    internal int Id { get; internal set; }
    internal Nullable`1<Color> Color { get; internal set; }
    internal Nullable`1<Color> BackgroundColor { get; internal set; }
    internal Nullable`1<Color> DecorationColor { get; internal set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal String[] FontFamilies { get; internal set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ValueTuple`2[] FontFeatures { get; internal set; }
    internal Nullable`1<float> Size { get; internal set; }
    internal Nullable`1<float> LineHeight { get; internal set; }
    internal Nullable`1<float> LetterSpacing { get; internal set; }
    internal Nullable`1<float> WordSpacing { get; internal set; }
    internal Nullable`1<FontWeight> FontWeight { get; internal set; }
    internal Nullable`1<FontPosition> FontPosition { get; internal set; }
    internal Nullable`1<bool> IsItalic { get; internal set; }
    internal Nullable`1<bool> HasStrikethrough { get; internal set; }
    internal Nullable`1<bool> HasUnderline { get; internal set; }
    internal Nullable`1<bool> HasOverline { get; internal set; }
    internal Nullable`1<TextDecorationStyle> DecorationStyle { get; internal set; }
    internal Nullable`1<float> DecorationThickness { get; internal set; }
    internal Nullable`1<TextDirection> Direction { get; internal set; }
    public static TextStyle Default { get; }
    internal static TextStyle LibraryDefault { get; }
    internal static TextStyle ParagraphSpacing { get; }
    [CompilerGeneratedAttribute]
protected TextStyle(TextStyle original);
    private static TextStyle();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
internal int get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(int value);
    [CompilerGeneratedAttribute]
internal Nullable`1<Color> get_Color();
    [CompilerGeneratedAttribute]
internal void set_Color(Nullable`1<Color> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<Color> get_BackgroundColor();
    [CompilerGeneratedAttribute]
internal void set_BackgroundColor(Nullable`1<Color> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<Color> get_DecorationColor();
    [CompilerGeneratedAttribute]
internal void set_DecorationColor(Nullable`1<Color> value);
    [CompilerGeneratedAttribute]
internal String[] get_FontFamilies();
    [CompilerGeneratedAttribute]
internal void set_FontFamilies(String[] value);
    [CompilerGeneratedAttribute]
internal ValueTuple`2[] get_FontFeatures();
    [CompilerGeneratedAttribute]
internal void set_FontFeatures(ValueTuple`2[] value);
    [CompilerGeneratedAttribute]
internal Nullable`1<float> get_Size();
    [CompilerGeneratedAttribute]
internal void set_Size(Nullable`1<float> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<float> get_LineHeight();
    [CompilerGeneratedAttribute]
internal void set_LineHeight(Nullable`1<float> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<float> get_LetterSpacing();
    [CompilerGeneratedAttribute]
internal void set_LetterSpacing(Nullable`1<float> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<float> get_WordSpacing();
    [CompilerGeneratedAttribute]
internal void set_WordSpacing(Nullable`1<float> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<FontWeight> get_FontWeight();
    [CompilerGeneratedAttribute]
internal void set_FontWeight(Nullable`1<FontWeight> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<FontPosition> get_FontPosition();
    [CompilerGeneratedAttribute]
internal void set_FontPosition(Nullable`1<FontPosition> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<bool> get_IsItalic();
    [CompilerGeneratedAttribute]
internal void set_IsItalic(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<bool> get_HasStrikethrough();
    [CompilerGeneratedAttribute]
internal void set_HasStrikethrough(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<bool> get_HasUnderline();
    [CompilerGeneratedAttribute]
internal void set_HasUnderline(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<bool> get_HasOverline();
    [CompilerGeneratedAttribute]
internal void set_HasOverline(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<TextDecorationStyle> get_DecorationStyle();
    [CompilerGeneratedAttribute]
internal void set_DecorationStyle(Nullable`1<TextDecorationStyle> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<float> get_DecorationThickness();
    [CompilerGeneratedAttribute]
internal void set_DecorationThickness(Nullable`1<float> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<TextDirection> get_Direction();
    [CompilerGeneratedAttribute]
internal void set_Direction(Nullable`1<TextDirection> value);
    [CompilerGeneratedAttribute]
public static TextStyle get_Default();
    [CompilerGeneratedAttribute]
internal static TextStyle get_LibraryDefault();
    [CompilerGeneratedAttribute]
internal static TextStyle get_ParagraphSpacing();
    internal SkTextStyle GetSkTextStyle();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(TextStyle left, TextStyle right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(TextStyle left, TextStyle right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(TextStyle other);
    [CompilerGeneratedAttribute]
public virtual TextStyle <Clone>$();
    [CompilerGeneratedAttribute]
internal static IntPtr[] <GetSkTextStyle>g__GetFontFamilyPointers|89_2(IList`1<SkText> texts);
    [CompilerGeneratedAttribute]
private FontFeature[] <GetSkTextStyle>g__GetFontFeatures|89_3(ValueTuple`2[] features);
    [CompilerGeneratedAttribute]
private TextDecoration <GetSkTextStyle>g__CreateDecoration|89_4();
    [CompilerGeneratedAttribute]
private float <GetSkTextStyle>g__CalculateTargetFontSize|89_5();
    [CompilerGeneratedAttribute]
private float <GetSkTextStyle>g__CalculateBaselineOffset|89_6();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class QuestPDF.Infrastructure.TextStyleManager : object {
    private static List`1<TextStyle> TextStyles;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<ValueTuple`3<int, TextStyleProperty, object>, TextStyle> TextStyleMutateCache;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<ValueTuple`2<int, int>, TextStyle> TextStyleApplyInheritedCache;
    private static ConcurrentDictionary`2<int, TextStyle> TextStyleApplyGlobalCache;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<ValueTuple`2<int, int>, TextStyle> TextStyleOverrideCache;
    private static object MutationLock;
    private static TextStyleManager();
    [ExtensionAttribute]
public static TextStyle Mutate(TextStyle origin, TextStyleProperty property, object value);
    [ExtensionAttribute]
private static TextStyle MutateStyle(TextStyle origin, TextStyleProperty targetProperty, object newValue, bool overrideValue);
    [ExtensionAttribute]
private static TextStyle MutateFontFamily(TextStyle origin, String[] newValue, bool overrideValue);
    [ExtensionAttribute]
private static TextStyle MutateFontFeatures(TextStyle origin, ValueTuple`2[] newValue, bool overrideValue);
    [ExtensionAttribute]
internal static TextStyle ApplyInheritedStyle(TextStyle style, TextStyle parent);
    [ExtensionAttribute]
internal static TextStyle ApplyGlobalStyle(TextStyle style);
    [ExtensionAttribute]
internal static TextStyle OverrideStyle(TextStyle style, TextStyle parent);
    private static TextStyle ApplyStyleProperties(int styleId, int parentId, bool overrideStyle);
    internal static TextStyle GetTextStyle(int id);
}
internal enum QuestPDF.Infrastructure.TextStyleProperty : Enum {
    public int value__;
    public static TextStyleProperty Color;
    public static TextStyleProperty BackgroundColor;
    public static TextStyleProperty DecorationColor;
    public static TextStyleProperty FontFamilies;
    public static TextStyleProperty FontFeatures;
    public static TextStyleProperty Size;
    public static TextStyleProperty LineHeight;
    public static TextStyleProperty LetterSpacing;
    public static TextStyleProperty WordSpacing;
    public static TextStyleProperty FontWeight;
    public static TextStyleProperty FontPosition;
    public static TextStyleProperty IsItalic;
    public static TextStyleProperty HasStrikethrough;
    public static TextStyleProperty HasUnderline;
    public static TextStyleProperty HasOverline;
    public static TextStyleProperty DecorationStyle;
    public static TextStyleProperty DecorationThickness;
    public static TextStyleProperty Direction;
}
public enum QuestPDF.Infrastructure.Unit : Enum {
    public int value__;
    public static Unit Point;
    public static Unit Meter;
    public static Unit Centimetre;
    public static Unit Millimetre;
    public static Unit Feet;
    public static Unit Inch;
    public static Unit Mil;
}
[ExtensionAttribute]
internal static class QuestPDF.Infrastructure.UnitExtensions : object {
    private static float InchToCentimetre;
    private static float InchToPoints;
    [ExtensionAttribute]
public static float ToPoints(float value, Unit unit);
    [CompilerGeneratedAttribute]
internal static float <ToPoints>g__GetConversionFactor|2_0(<>c__DisplayClass2_0& );
}
public enum QuestPDF.Infrastructure.VerticalAlignment : Enum {
    public int value__;
    public static VerticalAlignment Top;
    public static VerticalAlignment Middle;
    public static VerticalAlignment Bottom;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class QuestPDF.Previewer.PreviewerExtensions : object {
    private static string ObsoleteMessage;
    [ExtensionAttribute]
[ObsoleteAttribute("The Previewer application is no longer supprted. Please use a new QuestPDF Companion application by calling ShowInCompanion() or ShowInCompanionAsync() methods.")]
public static void ShowInPreviewer(IDocument document, int port);
    [ExtensionAttribute]
[ObsoleteAttribute("The Previewer application is no longer supprted. Please use a new QuestPDF Companion application by calling ShowInCompanion() or ShowInCompanionAsync() methods.")]
public static Task ShowInPreviewerAsync(IDocument document, int port, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class QuestPDF.Settings : object {
    [CompilerGeneratedAttribute]
private static Nullable`1<LicenseType> <License>k__BackingField;
    [CompilerGeneratedAttribute]
private static int <DocumentLayoutExceptionThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <EnableCaching>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <EnableDebugging>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <CheckIfAllTextGlyphsAreAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <UseEnvironmentFonts>k__BackingField;
    [CompilerGeneratedAttribute]
private static ICollection`1<string> <FontDiscoveryPaths>k__BackingField;
    public static Nullable`1<LicenseType> License { get; public set; }
    [ObsoleteAttribute("This setting is ignored since the 2023.10 version. The new infinite layout detection algorithm works automatically. You can safely remove this setting from your codebase.")]
public static int DocumentLayoutExceptionThreshold { get; public set; }
    public static bool EnableCaching { get; public set; }
    public static bool EnableDebugging { get; public set; }
    public static bool CheckIfAllTextGlyphsAreAvailable { get; public set; }
    public static bool UseEnvironmentFonts { get; public set; }
    public static ICollection`1<string> FontDiscoveryPaths { get; }
    private static Settings();
    [CompilerGeneratedAttribute]
public static Nullable`1<LicenseType> get_License();
    [CompilerGeneratedAttribute]
public static void set_License(Nullable`1<LicenseType> value);
    [CompilerGeneratedAttribute]
public static int get_DocumentLayoutExceptionThreshold();
    [CompilerGeneratedAttribute]
public static void set_DocumentLayoutExceptionThreshold(int value);
    [CompilerGeneratedAttribute]
public static bool get_EnableCaching();
    [CompilerGeneratedAttribute]
public static void set_EnableCaching(bool value);
    [CompilerGeneratedAttribute]
public static bool get_EnableDebugging();
    [CompilerGeneratedAttribute]
public static void set_EnableDebugging(bool value);
    [CompilerGeneratedAttribute]
public static bool get_CheckIfAllTextGlyphsAreAvailable();
    [CompilerGeneratedAttribute]
public static void set_CheckIfAllTextGlyphsAreAvailable(bool value);
    [CompilerGeneratedAttribute]
public static bool get_UseEnvironmentFonts();
    [CompilerGeneratedAttribute]
public static void set_UseEnvironmentFonts(bool value);
    [CompilerGeneratedAttribute]
public static ICollection`1<string> get_FontDiscoveryPaths();
}
internal class QuestPDF.Skia.SkBitmap : object {
    [CompilerGeneratedAttribute]
private IntPtr <Instance>k__BackingField;
    public IntPtr Instance { get; private set; }
    public SkBitmap(int width, int height);
    [CompilerGeneratedAttribute]
public IntPtr get_Instance();
    [CompilerGeneratedAttribute]
private void set_Instance(IntPtr value);
    [NullableContextAttribute("1")]
public SkData EncodeAsJpeg(int quality);
    [NullableContextAttribute("1")]
public SkData EncodeAsPng();
    [NullableContextAttribute("1")]
public SkData EncodeAsWebp(int quality);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Skia.SkCanvas : object {
    [CompilerGeneratedAttribute]
private IntPtr <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisposeNativeObject>k__BackingField;
    public IntPtr Instance { get; private set; }
    private bool DisposeNativeObject { get; }
    public SkCanvas(IntPtr instance, bool disposeNativeObject);
    [CompilerGeneratedAttribute]
public IntPtr get_Instance();
    [CompilerGeneratedAttribute]
private void set_Instance(IntPtr value);
    [CompilerGeneratedAttribute]
private bool get_DisposeNativeObject();
    public static SkCanvas CreateFromBitmap(SkBitmap bitmap);
    public void Save();
    public void Restore();
    public void Translate(float x, float y);
    public void Scale(float factorX, float factorY);
    public void Rotate(float degrees);
    public void DrawFilledRectangle(SkRect position, UInt32 color);
    public void DrawStrokeRectangle(SkRect position, float strokeWidth, UInt32 strokeColor);
    public void DrawImage(SkImage image, float width, float height);
    public void DrawPicture(SkPicture picture);
    public void DrawParagraph(SkParagraph paragraph);
    public void DrawSvgPath(string svg, UInt32 color);
    public void DrawSvg(SkSvgImage svgImage, float width, float height);
    public void DrawOverflowArea(SkRect position);
    public void ClipOverflowArea(SkRect availableSpace, SkRect requiredSpace);
    public void ClipRectangle(SkRect clipArea);
    public void AnnotateUrl(float width, float height, string url);
    public void AnnotateDestination(string destinationName);
    public void AnnotateDestinationLink(float width, float height, string destinationName);
    public CanvasMatrix GetCurrentTotalMatrix();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Skia.SkData : object {
    [CompilerGeneratedAttribute]
private IntPtr <Instance>k__BackingField;
    public IntPtr Instance { get; private set; }
    public SkData(IntPtr instance);
    [CompilerGeneratedAttribute]
public IntPtr get_Instance();
    [CompilerGeneratedAttribute]
private void set_Instance(IntPtr value);
    public static SkData FromFile(string filePath);
    public static SkData FromStream(Stream stream);
    public static SkData FromBinary(Byte[] data);
    public Byte[] ToBytes();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
internal class QuestPDF.Skia.SkDateTime : ValueType {
    public short TimeZoneMinutes;
    public ushort Year;
    public byte Month;
    public byte DayOfWeek;
    public byte Day;
    public byte Hour;
    public byte Minute;
    public byte Second;
    public SkDateTime(DateTimeOffset dateTime);
}
internal class QuestPDF.Skia.SkDocument : object {
    [CompilerGeneratedAttribute]
private IntPtr <Instance>k__BackingField;
    public IntPtr Instance { get; private set; }
    internal SkDocument(IntPtr instance);
    [CompilerGeneratedAttribute]
public IntPtr get_Instance();
    [CompilerGeneratedAttribute]
private void set_Instance(IntPtr value);
    [NullableContextAttribute("1")]
public SkCanvas BeginPage(float width, float height);
    public void EndPage();
    public void Close();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
internal static class QuestPDF.Skia.SkiaAPI : object {
    [NullableAttribute("1")]
public static string LibraryName;
    public static void EnsureNotNull(IntPtr instance);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Skia.SkImage : object {
    [CompilerGeneratedAttribute]
private IntPtr <Instance>k__BackingField;
    public int Width;
    public int Height;
    public int EncodedDataSize;
    public IntPtr Instance { get; private set; }
    public SkImage(IntPtr instance);
    [CompilerGeneratedAttribute]
public IntPtr get_Instance();
    [CompilerGeneratedAttribute]
private void set_Instance(IntPtr value);
    public static SkImage FromData(SkData data);
    public SkImage ResizeAndCompress(int targetWidth, int targetHeight, int compressionQuality, bool downsample);
    public static SkImage GeneratePlaceholder(int targetWidth, int targetHeight, UInt32 firstColor, UInt32 secondColor);
    public SkData GetEncodedData();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
internal static class QuestPDF.Skia.SkNativeDependencyCompatibilityChecker : object {
    private static bool IsCompatibilityChecked;
    public static void Test();
    [NullableContextAttribute("2")]
private static Exception CheckIfExceptionIsThrownWhenLoadingNativeDependencies();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static void <Test>g__ThrowCompatibilityException|1_0(Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class QuestPDF.Skia.SkNativeDependencyProvider : object {
    public static String[] SupportedPlatforms;
    private static SkNativeDependencyProvider();
    public static void EnsureNativeFileAvailability();
    public static bool IsCurrentPlatformSupported();
    [NullableContextAttribute("2")]
private static string GetNativeFileSourcePath();
    public static string GetRuntimePlatform();
    private static void CopyFileIfNewer(string sourcePath, string targetPath);
    [CompilerGeneratedAttribute]
internal static string <GetRuntimePlatform>g__GetSystemIdentifier|4_0();
    [CompilerGeneratedAttribute]
internal static string <GetRuntimePlatform>g__GetProcessArchitecture|4_1();
    [CompilerGeneratedAttribute]
internal static bool <GetRuntimePlatform>g__IsLinuxMusl|4_2();
}
internal static class QuestPDF.Skia.SkPdfDocument : object {
    [NullableContextAttribute("1")]
public static SkDocument Create(SkWriteStream stream, SkPdfDocumentMetadata metadata);
}
internal class QuestPDF.Skia.SkPdfDocumentMetadata : ValueType {
    public IntPtr Title;
    public IntPtr Author;
    public IntPtr Subject;
    public IntPtr Keywords;
    public IntPtr Creator;
    public IntPtr Producer;
    public SkDateTime CreationDate;
    public SkDateTime ModificationDate;
    public bool SupportPDFA;
    public bool CompressDocument;
    public float RasterDPI;
}
internal class QuestPDF.Skia.SkPicture : object {
    [CompilerGeneratedAttribute]
private IntPtr <Instance>k__BackingField;
    public IntPtr Instance { get; private set; }
    public SkPicture(IntPtr instance);
    [CompilerGeneratedAttribute]
public IntPtr get_Instance();
    [CompilerGeneratedAttribute]
private void set_Instance(IntPtr value);
    [NullableContextAttribute("1")]
public static SkPicture Deserialize(SkData data);
    [NullableContextAttribute("1")]
public SkData Serialize();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
internal class QuestPDF.Skia.SkPictureRecorder : object {
    [CompilerGeneratedAttribute]
private IntPtr <Instance>k__BackingField;
    public IntPtr Instance { get; private set; }
    [CompilerGeneratedAttribute]
public IntPtr get_Instance();
    [CompilerGeneratedAttribute]
private void set_Instance(IntPtr value);
    [NullableContextAttribute("1")]
public SkCanvas BeginRecording(float width, float height);
    [NullableContextAttribute("1")]
public SkPicture EndRecording();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
internal class QuestPDF.Skia.SkRect : ValueType {
    public float Left;
    public float Top;
    public float Right;
    public float Bottom;
    public float Width { get; }
    public float Height { get; }
    public SkRect(float left, float top, float right, float bottom);
    public float get_Width();
    public float get_Height();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Skia.SkResourceProvider : object {
    [CompilerGeneratedAttribute]
private IntPtr <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private static SkResourceProvider <Local>k__BackingField;
    [CompilerGeneratedAttribute]
private static SkResourceProvider <Global>k__BackingField;
    public IntPtr Instance { get; private set; }
    public static SkResourceProvider Local { get; }
    public static SkResourceProvider Global { get; }
    internal static SkResourceProvider CurrentResourceProvider { get; }
    private SkResourceProvider(SkFontManager fontManager);
    private static SkResourceProvider();
    [CompilerGeneratedAttribute]
public IntPtr get_Instance();
    [CompilerGeneratedAttribute]
private void set_Instance(IntPtr value);
    [CompilerGeneratedAttribute]
public static SkResourceProvider get_Local();
    [CompilerGeneratedAttribute]
public static SkResourceProvider get_Global();
    internal static SkResourceProvider get_CurrentResourceProvider();
}
internal class QuestPDF.Skia.SkSize : ValueType {
    public float Width;
    public float Height;
    public SkSize(float width, float height);
}
internal class QuestPDF.Skia.SkSvgCanvas : object {
    [NullableContextAttribute("1")]
public static SkCanvas CreateSvg(float width, float height, SkWriteStream writeStream);
}
internal class QuestPDF.Skia.SkSvgImage : object {
    [CompilerGeneratedAttribute]
private IntPtr <Instance>k__BackingField;
    public SkSvgImageSize Size;
    public SkRect ViewBox;
    public IntPtr Instance { get; private set; }
    internal float AspectRatio { get; }
    [NullableContextAttribute("1")]
public SkSvgImage(string svgString, SkResourceProvider resourceProvider, SkFontManager fontManager);
    [CompilerGeneratedAttribute]
public IntPtr get_Instance();
    [CompilerGeneratedAttribute]
private void set_Instance(IntPtr value);
    internal float get_AspectRatio();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
internal class QuestPDF.Skia.SkSvgImageSize : ValueType {
    public float Width;
    public float Height;
    public Unit WidthUnit;
    public Unit HeightUnit;
}
internal class QuestPDF.Skia.SkText : object {
    [CompilerGeneratedAttribute]
private IntPtr <Instance>k__BackingField;
    public IntPtr Instance { get; private set; }
    [NullableContextAttribute("2")]
public SkText(string text);
    [CompilerGeneratedAttribute]
public IntPtr get_Instance();
    [CompilerGeneratedAttribute]
private void set_Instance(IntPtr value);
    protected virtual override void Finalize();
    [NullableContextAttribute("2")]
public static IntPtr MarshalFromManagedToNative(string text);
    [NullableContextAttribute("1")]
public static IntPtr op_Implicit(SkText text);
    public sealed virtual void Dispose();
}
internal class QuestPDF.Skia.SkWriteStream : object {
    [CompilerGeneratedAttribute]
private IntPtr <Instance>k__BackingField;
    public IntPtr Instance { get; private set; }
    [CompilerGeneratedAttribute]
public IntPtr get_Instance();
    [CompilerGeneratedAttribute]
private void set_Instance(IntPtr value);
    [NullableContextAttribute("1")]
public SkData DetachData();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
internal static class QuestPDF.Skia.SkXpsDocument : object {
    [NullableContextAttribute("1")]
public static SkDocument Create(SkWriteStream stream, float dpi);
}
internal class QuestPDF.Skia.Text.ParagraphStyleConfiguration : ValueType {
    public TextAlign Alignment;
    public TextDirection Direction;
    public int MaxLinesVisible;
    public IntPtr LineClampEllipsis;
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ParagraphStyleConfiguration left, ParagraphStyleConfiguration right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ParagraphStyleConfiguration left, ParagraphStyleConfiguration right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ParagraphStyleConfiguration other);
}
internal class QuestPDF.Skia.Text.SkFontCollection : object {
    [CompilerGeneratedAttribute]
private IntPtr <Instance>k__BackingField;
    public IntPtr Instance { get; private set; }
    public SkFontCollection(IntPtr instance);
    [CompilerGeneratedAttribute]
public IntPtr get_Instance();
    [CompilerGeneratedAttribute]
private void set_Instance(IntPtr value);
    [NullableContextAttribute("1")]
public static SkFontCollection Create(SkTypefaceProvider typefaceProvider, SkFontManager fontManager);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Skia.Text.SkFontManager : object {
    [CompilerGeneratedAttribute]
private IntPtr <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private static SkFontManager <Local>k__BackingField;
    [CompilerGeneratedAttribute]
private static SkFontManager <Global>k__BackingField;
    public IntPtr Instance { get; }
    public static SkFontManager Local { get; }
    public static SkFontManager Global { get; }
    private SkFontManager(IntPtr instance);
    private static SkFontManager();
    [CompilerGeneratedAttribute]
public IntPtr get_Instance();
    [CompilerGeneratedAttribute]
public static SkFontManager get_Local();
    [CompilerGeneratedAttribute]
public static SkFontManager get_Global();
    public SkTypeface CreateTypeface(SkData data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Skia.Text.SkParagraph : object {
    [CompilerGeneratedAttribute]
private IntPtr <Instance>k__BackingField;
    public IntPtr Instance { get; private set; }
    public SkParagraph(IntPtr instance);
    [CompilerGeneratedAttribute]
public IntPtr get_Instance();
    [CompilerGeneratedAttribute]
private void set_Instance(IntPtr value);
    public void PlanLayout(float availableWidth);
    public SkSize[] GetLineMetrics();
    public Int32[] GetUnresolvedCodepoints();
    public SkRect[] GetPlaceholderPositions();
    public SkRect[] GetTextRangePositions(int rangeStart, int rangeEnd);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
internal class QuestPDF.Skia.Text.SkParagraphBuilder : object {
    [CompilerGeneratedAttribute]
private IntPtr <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private ParagraphStyleConfiguration <Configuration>k__BackingField;
    public IntPtr Instance { get; private set; }
    public ParagraphStyleConfiguration Configuration { get; private set; }
    [CompilerGeneratedAttribute]
public IntPtr get_Instance();
    [CompilerGeneratedAttribute]
private void set_Instance(IntPtr value);
    [CompilerGeneratedAttribute]
public ParagraphStyleConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
private void set_Configuration(ParagraphStyleConfiguration value);
    [NullableContextAttribute("1")]
public static SkParagraphBuilder Create(ParagraphStyleConfiguration paragraphStyleConfiguration, SkFontCollection fontCollection);
    [NullableContextAttribute("1")]
public void AddText(string text, SkTextStyle textStyle);
    public void AddPlaceholder(SkPlaceholderStyle placeholderStyle);
    [NullableContextAttribute("1")]
public SkParagraph CreateParagraph();
    public void Reset();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
internal class QuestPDF.Skia.Text.SkPlaceholderStyle : ValueType {
    public float Width;
    public float Height;
    public PlaceholderAlignment Alignment;
    public PlaceholderBaseline Baseline;
    public float BaselineOffset;
}
internal class QuestPDF.Skia.Text.SkTextStyle : object {
    [CompilerGeneratedAttribute]
private IntPtr <Instance>k__BackingField;
    public IntPtr Instance { get; private set; }
    public SkTextStyle(TextStyleConfiguration textStyleConfiguration);
    [CompilerGeneratedAttribute]
public IntPtr get_Instance();
    [CompilerGeneratedAttribute]
private void set_Instance(IntPtr value);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
internal class QuestPDF.Skia.Text.SkTypeface : object {
    [CompilerGeneratedAttribute]
private IntPtr <Instance>k__BackingField;
    public IntPtr Instance { get; private set; }
    public SkTypeface(IntPtr instance);
    [CompilerGeneratedAttribute]
public IntPtr get_Instance();
    [CompilerGeneratedAttribute]
private void set_Instance(IntPtr value);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
internal class QuestPDF.Skia.Text.SkTypefaceProvider : object {
    [CompilerGeneratedAttribute]
private IntPtr <Instance>k__BackingField;
    public IntPtr Instance { get; private set; }
    [CompilerGeneratedAttribute]
public IntPtr get_Instance();
    [CompilerGeneratedAttribute]
private void set_Instance(IntPtr value);
    [NullableContextAttribute("1")]
public void AddTypefaceFromData(SkData data, string alias);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
internal class QuestPDF.Skia.Text.TextStyleConfiguration : ValueType {
    public float FontSize;
    public FontWeights FontWeight;
    public bool IsItalic;
    public static int FONT_FAMILIES_LENGTH;
    [NullableAttribute("1")]
public IntPtr[] FontFamilies;
    public static int FONT_FEATURES_LENGTH;
    [NullableAttribute("1")]
public FontFeature[] FontFeatures;
    public UInt32 ForegroundColor;
    public UInt32 BackgroundColor;
    public UInt32 DecorationColor;
    public float DecorationThickness;
    public TextDecoration DecorationType;
    public TextDecorationMode DecorationMode;
    public TextDecorationStyle DecorationStyle;
    public float LineHeight;
    public float LetterSpacing;
    public float WordSpacing;
    public float BaselineOffset;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class QuestPDF.Skia.Utf8StringMarshaller : object {
    private static Utf8StringMarshaller Instance;
    private static Utf8StringMarshaller();
    public static ICustomMarshaler GetInstance(string cookie);
    public sealed virtual void CleanUpManagedData(object managedObj);
    public sealed virtual void CleanUpNativeData(IntPtr pNativeData);
    public sealed virtual int GetNativeDataSize();
    public sealed virtual IntPtr MarshalManagedToNative(object managedObject);
    public sealed virtual object MarshalNativeToManaged(IntPtr pNativeData);
}
[EditorBrowsableAttribute("1")]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
