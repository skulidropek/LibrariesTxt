[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal static class Sparrow.AdvInstructionSet : object {
    public static bool IsAcceleratedVector128;
    public static bool IsAcceleratedVector256;
    public static bool IsAcceleratedVector512;
    private static AdvInstructionSet();
}
public enum Sparrow.Backups.BackupCompressionAlgorithm : Enum {
    public int value__;
    public static BackupCompressionAlgorithm Zstd;
    public static BackupCompressionAlgorithm Gzip;
}
public enum Sparrow.Backups.SnapshotBackupCompressionAlgorithm : Enum {
    public int value__;
    public static SnapshotBackupCompressionAlgorithm Zstd;
    public static SnapshotBackupCompressionAlgorithm Deflate;
}
internal static class Sparrow.Binary.Bits : object {
    public static int InByte;
    public static int InShort;
    public static int InInt;
    public static int InLong;
    private static int GB;
    private static Byte[] MultiplyDeBruijnBitPosition;
    private static Byte[] DeBruijnBytePos64;
    private static Byte[] DeBruijnBytePos32;
    private static Bits();
    public static long NumberOfSetBits(long i);
    public static int MostSignificantBit(UInt32 n);
    public static int MostSignificantBit(int n);
    public static int MostSignificantBit(long nn);
    public static int MostSignificantBit(ulong n);
    public static int LeadingZeroes(int n);
    public static int LeadingZeroes(UInt32 n);
    public static int LeadingZeroes(long n);
    public static int LeadingZeroes(ulong n);
    public static int CeilLog2(int n);
    public static int CeilLog2(UInt32 n);
    public static int FloorLog2(UInt32 n);
    public static int FloorLog2(int n);
    public static int PowerOf2(int v);
    public static long PowerOf2(long v);
    public static int ToBytes(int bits);
    public static UInt32 RotateLeft32(UInt32 value, int count);
    public static UInt32 RotateRight32(UInt32 value, int count);
    public static ulong RotateLeft64(ulong value, int count);
    public static ulong RotateRight64(ulong value, int count);
    public static UInt32 SwapBytes(UInt32 value);
    public static int SwapBytes(int value);
    public static long SwapBytes(long value);
    public static ulong SwapBytes(ulong value);
    public static int TrailingZeroesInBytes(ulong value);
    public static int TrailingZeroesInBytes(long value);
    public static int TrailingZeroesInBytes(UInt32 value);
    public static int TrailingZeroesInBytes(int value);
    public static bool IsPowerOfTwo(int value);
    public static UInt32 ByteForBit(int idx);
    public static byte BitInByte(int idx);
    public static long DoubleToSortableLong(double val);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Sparrow.Binary.BitVector : ValueType {
    public static int BitsPerByte;
    public static int BitsPerWord;
    public static int BytesPerWord;
    public static UInt32 Log2BitsPerByte;
    private Span`1<byte> _storage;
    public int Count { get; }
    public bool Item { get; public set; }
    public BitVector(Span`1<byte> storage);
    public int get_Count();
    public bool get_Item(int idx);
    public void set_Item(int idx, bool value);
    public void Set(int idx);
    public void Set(int idx, bool value);
    public bool Get(int idx);
    internal static int IndexOfFirstSetBitAvx2(Byte& storage, int lengthInBytes);
    internal static int IndexOfFirstSetBitSse2(Byte& storage, int lengthInBytes);
    internal static int IndexOfFirstSetBitScalar(Byte& storage, int lengthInBytes);
    public int IndexOfFirstSetBit();
    public string ToDebugString();
}
internal static class Sparrow.Binary.Numbers : object {
    private static ReadOnlySpan`1<byte> HexStringTable { get; }
    private static ReadOnlySpan`1<byte> get_HexStringTable();
    private static ValueTuple`2<byte, byte> ToHexChars(byte value);
    public static int FillAsHex(Span`1<byte> dest, T number);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Sparrow.Binary.PtrBitVector : ValueType {
    public Byte* Bits;
    public int Count;
    public bool Item { get; public set; }
    public PtrBitVector(Void* bits, int numberOfBits);
    public static bool GetBitInPointer(Void* ptr, int idx);
    public static void SetBitInPointer(Void* ptr, int idx, bool value);
    public bool get_Item(int idx);
    public void set_Item(int idx, bool value);
    public void Set(int idx);
    public void Set(int idx, bool value);
    public bool Get(int idx);
    public int FindLeadingOne();
    public string ToDebugString();
}
[ExtensionAttribute]
internal static class Sparrow.Branchless : object {
    [ExtensionAttribute]
public static int ToInt32(bool value);
}
[DebuggerTypeProxyAttribute("Sparrow.Collections.ConcurrentSet`1/DebugProxy")]
public class Sparrow.Collections.ConcurrentSet`1 : object {
    private int _innerCountForEmpty;
    private ConcurrentDictionary`2<T, object> _inner;
    public int Count { get; }
    public bool IsEmpty { get; }
    public ConcurrentSet`1(IEqualityComparer`1<T> comparer);
    public int get_Count();
    public bool get_IsEmpty();
    public void Add(T item);
    public bool TryAdd(T item);
    public bool Contains(T item);
    public bool TryRemove(T item);
    [IteratorStateMachineAttribute("Sparrow.Collections.ConcurrentSet`1/<GetEnumerator>d__13")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Clear();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class Sparrow.Collections.FastList`1 : object {
    private UInt32 _version;
    private UInt32 _size;
    private static T[] EmptyArray;
    private T[] _items;
    private static int DefaultCapacity;
    private static int MaxArrayLength;
    public T Item { get; public set; }
    public T Item { get; public set; }
    public int Capacity { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public FastList`1(int capacity);
    private static FastList`1();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public T get_Item(UInt32 index);
    public void set_Item(UInt32 index, T value);
    public T& GetAsRef(UInt32 index);
    public T& GetAsRef(int index);
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(T item);
    public void AddByRef(T& item);
    public void CopyTo(FastList`1<T> dest);
    private void AddUnlikely(T item, int size);
    private void EnsureCapacity(int min);
    public sealed virtual void Clear();
    public void Trim(int size);
    public void WeakClear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual bool Remove(T item);
    public T RemoveLast();
    public sealed virtual void RemoveAt(int index);
    public void ThrowWhenIndexIsOutOfRange(int index);
    public void RemoveRange(int index, int count);
    public Span`1<T> AsUnsafeSpan();
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(Sorter`2& sorter);
    public T[] ToArray();
}
[DebuggerDisplayAttribute("Count = {Count}")]
public class Sparrow.Collections.FastStack`1 : object {
    private T[] _array;
    private int _size;
    private int _version;
    private static int DefaultCapacity;
    public int Count { get; }
    public FastStack`1(int capacity);
    public int get_Count();
    public void Clear();
    public void WeakClear();
    public bool Contains(T item);
    public void CopyTo(T[] array, int arrayIndex);
    public void CopyTo(FastStack`1<T> srcStack);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public T Peek();
    public bool TryPeek(T& result);
    public bool TryPeek(int depth, T& result);
    public T Pop();
    public bool TryPop(T& result);
    public void Push(T item);
    private void PushUnlikely(T item);
    public T[] ToArray();
    private T ThrowForEmptyStack();
}
internal class Sparrow.Collections.LimitedConcurrentSet`1 : object {
    private int _max;
    private int _count;
    private ConcurrentQueue`1<T> _q;
    public LimitedConcurrentSet`1(int max);
    public void Clear();
    public bool Enqueue(T item, int timeout);
    public bool TryDequeue(T& item);
    private bool ContendedCodePath(int timeout);
}
internal class Sparrow.Compression.LZ4 : object {
    public static int ACCELERATION_DEFAULT;
    private static int COPYLENGTH;
    private static int LASTLITERALS;
    private static int MINMATCH;
    private static int MFLIMIT;
    private static int LZ4_minLength;
    private static int MAXD_LOG;
    private static int MAX_DISTANCE;
    private static int LZ4_64Klimit;
    private static int LZ4_skipTrigger;
    private static byte ML_BITS;
    private static byte ML_MASK;
    private static byte RUN_BITS;
    private static byte RUN_MASK;
    private static UInt32 LZ4_MAX_INPUT_SIZE;
    private static int LZ4_MEMORY_USAGE;
    private static int LZ4_HASHLOG;
    private static int HASH_SIZE_U32;
    private static int MAX_INPUT_LENGTH_PER_SEGMENT;
    private static int ByU16HashLog;
    private static ulong ByU16HashMask;
    private static int ByU32HashLog;
    private static ulong ByU32HashMask;
    private static ulong prime5bytes;
    private static Int32[] dec32table;
    private static Int32[] dec64table;
    private static LZ4();
    public static long Encode64LongBuffer(Byte* input, Byte* output, long inputLength, long outputLength, int acceleration);
    public static int Encode64(Byte* input, Byte* output, int inputLength, int outputLength, int acceleration);
    public static long MaximumOutputLength(long size);
    public static int MaximumOutputLength(int size);
    private static int LZ4_compress_generic(LZ4_stream_t_internal* dictPtr, Byte* source, Byte* dest, int inputSize, int maxOutputSize, int acceleration);
    private static int LZ4_count(Byte* pInPtr, Byte* pMatchPtr, Byte* pInLimitPtr);
    private static void LZ4_putPosition(Byte* p, LZ4_stream_t_internal* ctx, Byte* srcBase);
    private static Byte* LZ4_getPosition(Byte* p, LZ4_stream_t_internal* ctx, Byte* srcBase);
    private static void LZ4_putPositionOnHash(Byte* p, int h, LZ4_stream_t_internal* ctx, Byte* srcBase);
    private static Byte* LZ4_getPositionOnHash(int h, LZ4_stream_t_internal* ctx, Byte* srcBase);
    private static int LZ4_hashPosition(Byte* sequence);
    private static void ThrowException(Exception e);
    private static TResult ThrowException(Exception e);
    public static long Decode64LongBuffers(Byte* input, long inputLength, Byte* output, long outputLength, bool knownOutputLength);
    public static int Decode64(Byte* input, int inputLength, Byte* output, int outputLength, bool knownOutputLength);
    private static int LZ4_decompress_generic(Byte* source, Byte* dest, int inputSize, int outputSize, int targetOutputSize, Byte* lowPrefix, Byte* dictStart, int dictSize);
    private static void WildCopy(Byte* dest, Byte* src, Byte* destEnd);
}
internal class Sparrow.Compression.SmallStringCompression : object {
    private static String[] DefaultTermsTable;
    private Byte*[] _termsTableBytes;
    private Byte*[][] _hashTable;
    private String[] _termsTable;
    private int _maxTermSize;
    private int _maxVerbatimLen;
    public static SmallStringCompression Instance;
    public SmallStringCompression(String[] termsTable);
    private static SmallStringCompression();
    private void AddToHash(Byte* ptr, int byteCount);
    private void AddToHash(int hash, Byte* buffer);
    public int Decompress(Byte* input, int inputLen, Byte* output, int outputLen);
    public int Compress(Byte* input, Byte* output, int inputLen, int outputLen);
    private void Flush(Byte* input, Byte* output, CompressionState* state);
}
internal static class Sparrow.Compression.VariableSizeEncoding : object {
    public static int ReadMany(ReadOnlySpan`1<byte> buffer, int count, Span`1<T> output);
    private static void ThrowNotEnoughOutputSpace();
    public static T Read(Byte* input, Int32& offset, Boolean& success);
    public static T Read(ReadOnlySpan`1<byte> input, int pos, Int32& offset, Boolean& success);
    public static T Read(Byte* input, Int32& offset);
    public static Byte* Skip(Byte* input);
    public static T ReadCompact(Byte* input, Int32& offset, Boolean& success);
    public static T ReadCompact(ReadOnlySpan`1<byte> input, int pos, Int32& offset, Boolean& success);
    public static T Read(ReadOnlySpan`1<byte> input, Int32& offset, int pos);
    private static void ThrowNotSupportedException();
    private static void ThrowInvalidShift();
    public static int WriteMany(Span`1<byte> dest, Span`1<T> values, int pos);
    public static int WriteMany(Span`1<byte> dest, ReadOnlySpan`1<T> values, int pos);
    public static int MaximumSizeOf();
    public static int Write(Byte* dest, T value);
    public static int Write(Span`1<byte> dest, T value, int pos);
}
internal static class Sparrow.Compression.ZigZagEncoding : object {
    public static int MaxEncodedSize;
    public static int Encode(Span`1<byte> buffer, T value, int pos);
    public static int Encode(Byte* buffer, T value, int pos);
    public static T Decode(ReadOnlySpan`1<byte> buffer, int pos);
    public static T Decode(Byte* buffer, Int32& len, int pos);
    public static T DecodeCompact(Byte* buffer, Int32& len, Boolean& success, int pos);
    public static T DecodeCompact(ReadOnlySpan`1<byte> buffer, Int32& len, Boolean& success, int pos);
    public static T Decode(ReadOnlySpan`1<byte> buffer, Int32& len, int pos);
    public static Int64[] DecodeDebug(ReadOnlySpan`1<byte> buffer);
    private static T UnZag(T value);
    public static int SizeOf2(ReadOnlySpan`1<byte> buffer, int pos);
    public static ValueTuple`2<T, T> Decode2(ReadOnlySpan`1<byte> buffer, Int32& len, int pos);
    public static ValueTuple`2<T, T> Decode2(Byte* buffer, Int32& len, int pos);
}
[ExtensionAttribute]
internal static class Sparrow.DateTimeExtenstion : object {
    [ExtensionAttribute]
public static DateTime Add(DateTime date, TimeValue time);
    [ExtensionAttribute]
public static int TotalMonths(DateTime date);
    [ExtensionAttribute]
public static DateTime EnsureMilliseconds(DateTime date);
    [ExtensionAttribute]
public static DateTime EnsureUtc(DateTime date);
}
internal static class Sparrow.Debugging.DebugStuff : object {
    public static IElectricFencedMemory ElectricFencedMemory;
}
internal static class Sparrow.DefaultFormat : object {
    public static string TimeOnlyFormatToWrite;
    public static string DateOnlyFormatToWrite;
    public static string DateTimeOffsetFormatsToWrite;
    public static string DateTimeFormatsToWrite;
    public static String[] OnlyDateTimeFormat;
    public static String[] DateTimeFormatsToRead;
    private static DefaultFormat();
}
internal class Sparrow.DictionaryResetBehavior`2 : ValueType {
    private sealed virtual override void Sparrow.IResetSupport<System.Collections.Generic.Dictionary<T1,T2>>.Reset(Dictionary`2<T1, T2> value);
}
internal static class Sparrow.Encodings : object {
    public static UTF8Encoding Utf8;
    private static Encodings();
}
public class Sparrow.Exceptions.InvalidStartOfObjectException : Exception {
    public InvalidStartOfObjectException(string message);
    public InvalidStartOfObjectException(string message, Exception innerException);
}
public class Sparrow.Exceptions.MemoryInfoException : Exception {
    public MemoryInfoException(string message);
    public MemoryInfoException(string message, Exception inner);
}
[ExtensionAttribute]
internal static class Sparrow.Extensions.NumberExtensions : object {
    [ExtensionAttribute]
public static bool AlmostEquals(double value, double other);
    [ExtensionAttribute]
public static bool AlmostEquals(float value, float other);
    private static bool HasMinimalDifference(double value1, double value2, long units);
    private static bool HasMinimalDifference(float value1, float value2, int units);
}
[ExtensionAttribute]
public static class Sparrow.Extensions.RavenDateTimeExtensions : object {
    private static long InitialJavaScriptDateTicks;
    private static long TicksPerMillisecond;
    private static long TicksPerSecond;
    private static long TicksPerMinute;
    private static long TicksPerHour;
    private static long TicksPerDay;
    private static int MillisPerSecond;
    private static int MillisPerMinute;
    private static int MillisPerHour;
    private static int MillisPerDay;
    private static int DaysPerYear;
    private static int DaysPer4Years;
    private static int DaysPer100Years;
    private static int DaysPer400Years;
    private static int DaysTo1601;
    private static int DaysTo1899;
    private static int DaysTo10000;
    internal static long MinTicks;
    internal static long MaxTicks;
    private static Int32[] DaysToMonth365;
    private static Int32[] DaysToMonth366;
    private static Char[][] _fourDigits;
    private static Byte[][] _fourDigitsByte;
    private static RavenDateTimeExtensions();
    private static Char[][] CreateFourDigitsCache();
    private static Byte[][] CreateFourDigitsByteCache();
    private static void ProcessDefaultRavenFormat(long ticks, Char* chars);
    internal static void ProcessDefaultRavenFormat(long ticks, Byte* chars);
    [ExtensionAttribute]
public static string GetDefaultRavenFormat(DateTime dt, bool isUtc);
    [ExtensionAttribute]
public static string GetDefaultRavenFormat(DateTime dt);
    [ExtensionAttribute]
internal static int GetDefaultRavenFormat(DateTime dt, JsonOperationContext context, AllocatedMemoryData& memory, bool isUtc);
    [ExtensionAttribute]
internal static int GetDefaultRavenFormat(DateTime dt, Byte* ptr, int ptrSize, bool isUtc);
    [ConditionalAttribute("DEBUG")]
internal static void ValidateDate(DateTime dt, bool isUtc);
    private static int ThrowMemoryIsNotBigEnough();
    internal static DateTime ParseDateMicrosoft(string text);
    private static DateTime ConvertJavaScriptTicksToDateTime(long javaScriptTicks);
}
[ExtensionAttribute]
internal static class Sparrow.Extensions.StringExtensions : object {
    [ExtensionAttribute]
public static int GetUtf8MaxSize(string value);
}
[ExtensionAttribute]
internal static class Sparrow.Extensions.TypeExtensions : object {
    internal static string RecordEqualityContractPropertyName;
    [ExtensionAttribute]
public static string GetTypeNameForSerialization(Type t);
    [ExtensionAttribute]
internal static bool IsRecord(Type type);
    private static string RemoveAssemblyDetails(string fullyQualifiedTypeName);
}
internal static class Sparrow.Global.Constants : object {
}
internal static class Sparrow.Hashing : object {
    private static ulong kMul;
    private static Hashing();
    public static ulong Combine(ulong x, ulong y);
    public static long Combine(long upper, long lower);
    public static UInt32 Mix(UInt32 key);
    public static int Mix(int key);
    public static UInt32 Mix(ulong key);
    public static int Mix(long key);
    public static UInt32 Combine(UInt32 upper, UInt32 lower);
    public static int Combine(int upper, int lower);
}
internal class Sparrow.HashSetResetBehavior`1 : ValueType {
    private sealed virtual override void Sparrow.IResetSupport<System.Collections.Generic.HashSet<T1>>.Reset(HashSet`1<T1> value);
}
public interface Sparrow.IReadOnlySpanEnumerator {
    public int Count { get; }
    public abstract virtual int get_Count();
    public abstract virtual void Reset();
    public abstract virtual bool MoveNext(ReadOnlySpan`1& result);
}
[DefaultMemberAttribute("Item")]
public interface Sparrow.IReadOnlySpanIndexer {
    public int Length { get; }
    public ReadOnlySpan`1<byte> Item { get; }
    public abstract virtual int get_Length();
    public abstract virtual bool IsNull(int i);
    public abstract virtual ReadOnlySpan`1<byte> get_Item(int i);
}
public interface Sparrow.IResetSupport`1 {
    public abstract virtual void Reset(T value);
}
public interface Sparrow.ISpanEnumerator {
    public abstract virtual void Reset();
    public abstract virtual bool MoveNext(Span`1& result);
}
[DefaultMemberAttribute("Item")]
public interface Sparrow.ISpanIndexer {
    public int Length { get; }
    public Span`1<byte> Item { get; }
    public abstract virtual int get_Length();
    public abstract virtual bool IsNull(int i);
    public abstract virtual Span`1<byte> get_Item(int i);
}
public abstract class Sparrow.Json.AbstractBlittableJsonDocumentBuilder : object {
    private bool _disposed;
    private GlobalPoolItem _cacheItem;
    protected ListCache`1<PropertyTag> _propertiesCache;
    protected ListCache`1<int> _positionsCache;
    protected ListCache`1<BlittableJsonToken> _tokensCache;
    private static ObjectPool`1<FastStack`1<BuildingState>> ContinuationPool;
    protected FastStack`1<BuildingState> _continuationState;
    private static PerCoreContainer`1<GlobalPoolItem> GlobalCache;
    private static AbstractBlittableJsonDocumentBuilder();
    public virtual void Dispose();
    protected void ClearState();
    [ConditionalAttribute("DEBUG")]
protected void AssertNotDisposed();
}
public abstract class Sparrow.Json.AbstractBlittableJsonTextWriter : object {
    protected JsonOperationContext _context;
    protected Stream _stream;
    private static byte StartObject;
    private static byte EndObject;
    private static byte StartArray;
    private static byte EndArray;
    private static byte Comma;
    private static byte Quote;
    private static byte Colon;
    public static Byte[] NullBuffer;
    public static Byte[] TrueBuffer;
    public static Byte[] FalseBuffer;
    private protected MemoryBuffer _pinnedBuffer;
    private Byte* _buffer;
    private protected int _pos;
    private ReturnBuffer _returnBuffer;
    public static ReadOnlySpan`1<byte> NewLineBuffer { get; }
    public static ReadOnlySpan`1<byte> NaNBuffer { get; }
    public static ReadOnlySpan`1<byte> PositiveInfinityBuffer { get; }
    public static ReadOnlySpan`1<byte> NegativeInfinityBuffer { get; }
    private static ReadOnlySpan`1<byte> _controlCodeEscapes { get; }
    internal static ReadOnlySpan`1<int> ControlCodeEscapes { get; }
    private static ReadOnlySpan`1<byte> EscapeCharacters { get; }
    public int Position { get; }
    protected AbstractBlittableJsonTextWriter(JsonOperationContext context, Stream stream);
    private static AbstractBlittableJsonTextWriter();
    public static ReadOnlySpan`1<byte> get_NewLineBuffer();
    public static ReadOnlySpan`1<byte> get_NaNBuffer();
    public static ReadOnlySpan`1<byte> get_PositiveInfinityBuffer();
    public static ReadOnlySpan`1<byte> get_NegativeInfinityBuffer();
    private static ReadOnlySpan`1<byte> get__controlCodeEscapes();
    internal static ReadOnlySpan`1<int> get_ControlCodeEscapes();
    private static ReadOnlySpan`1<byte> get_EscapeCharacters();
    public int get_Position();
    public virtual string ToString();
    public sealed virtual void WriteObject(BlittableJsonReaderObject obj);
    private void WriteArrayToStream(BlittableJsonReaderArray blittableArray);
    public sealed virtual void WriteValue(BlittableJsonToken token, object val);
    public sealed virtual int WriteDateTime(Nullable`1<DateTime> value, bool isUtc);
    [SkipLocalsInitAttribute]
public sealed virtual int WriteDateTime(DateTime value, bool isUtc);
    public sealed virtual void WriteString(string str, bool skipEscaping);
    public sealed virtual void WriteString(LazyStringValue str, bool skipEscaping);
    private void UnlikelyWriteEscapeSequences(Byte* strBuffer, int size, int numberOfEscapeSequences, int escapeSequencePos);
    private void UnlikelyWriteLargeString(Byte* strBuffer, int size, int numberOfEscapeSequences, int escapeSequencePos);
    private void WriteEscapeCharacter(Byte* buffer, byte b);
    [DoesNotReturnAttribute]
private void ThrowInvalidEscapeCharacter(byte b);
    public sealed virtual void WriteString(LazyCompressedStringValue str);
    private void UnlikelyWriteLargeString(int numberOfEscapeSequences, Byte* strSrcBuffer, int escapeSequencePos, Byte* strBuffer, int size);
    public void WriteRawStringWhichMustBeWithoutEscapeChars(Byte* buffer, int size);
    private void WriteRawString(ReadOnlySpan`1<byte> buffer);
    private void WriteRawString(Byte* buffer, int size);
    private void UnlikelyWriteLargeRawString(ReadOnlySpan`1<byte> buffer);
    private void UnlikelyWriteLargeRawString(Byte* buffer, int size);
    public sealed virtual void WriteStartObject();
    public sealed virtual void WriteEndArray();
    public sealed virtual void WriteStartArray();
    public sealed virtual void WriteEndObject();
    protected void EnsureBuffer(int len);
    protected virtual bool FlushInternal();
    [DoesNotReturnAttribute]
private static void ThrowValueTooBigForBuffer(int len);
    [DoesNotReturnAttribute]
private void ThrowStreamClosed();
    public sealed virtual void WriteNull();
    public sealed virtual void WriteBool(bool val);
    public sealed virtual void WriteComma();
    public sealed virtual void WritePropertyName(ReadOnlySpan`1<byte> prop);
    public void WritePropertyName(LazyStringValue prop);
    public sealed virtual void WritePropertyName(string prop);
    public sealed virtual void WritePropertyName(StringSegment prop);
    [SkipLocalsInitAttribute]
public sealed virtual void WriteInteger(long val);
    public sealed virtual void WriteDouble(LazyNumberValue val);
    public void WriteBufferFor(ReadOnlySpan`1<byte> buffer);
    public sealed virtual void WriteDouble(double val);
    protected void DisposeInternal();
    public sealed virtual void WriteNewLine();
    public void WriteMemoryChunk(IntPtr ptr, int size);
    public void WriteMemoryChunk(Byte* ptr, int size);
}
public class Sparrow.Json.AllocatedMemoryData : object {
    public int SizeInBytes;
    public int ContextGeneration;
    public JsonOperationContext Parent;
    public ThreadStats AllocatingThread;
    public Byte* Address;
    public AllocatedMemoryData(Byte* address, int sizeInBytes);
    public Span`1<byte> AsSpan();
}
public class Sparrow.Json.ArenaMemoryAllocator : object {
    internal static int MaxArenaSize;
    private static Nullable`1<int> SingleAllocationSizeLimit;
    private Byte* _ptrStart;
    private Byte* _ptrCurrent;
    private long _allocated;
    private long _used;
    private List`1<Tuple`3<IntPtr, long, ThreadStats>> _olderBuffers;
    private FreeSection*[] _freed;
    private SingleUseFlag _isDisposed;
    private ThreadStats _allocatingThread;
    private int _initialSize;
    public long TotalUsed;
    public bool AvoidOverAllocation;
    private SharedMultipleUseFlag _lowMemoryFlag;
    public long Allocated { get; }
    public ArenaMemoryAllocator(SharedMultipleUseFlag lowMemoryFlag, int initialSize);
    private static ArenaMemoryAllocator();
    public long get_Allocated();
    public bool GrowAllocation(AllocatedMemoryData allocation, int sizeIncrease);
    public AllocatedMemoryData Allocate(int size);
    private static void ThrowInvalidAllocateFromResetWithoutRenew();
    private void ThrowAlreadyDisposedException();
    private void GrowArena(int requestedSize);
    private long GetPreferredSize(int requestedSize);
    public void RenewArena();
    public void ResetArena();
    protected virtual override void Finalize();
    public virtual string ToString();
    public sealed virtual void Dispose();
    public void Dispose(bool disposing);
    public void Return(AllocatedMemoryData allocation);
    [CompilerGeneratedAttribute]
internal static long <GetPreferredSize>g__ApplyLimit|23_0(long size, <>c__DisplayClass23_0& );
}
public class Sparrow.Json.AsyncBlittableJsonTextWriter : AbstractBlittableJsonTextWriter {
    private Stream _outputStream;
    private CancellationToken _cancellationToken;
    public AsyncBlittableJsonTextWriter(JsonOperationContext context, Stream stream, CancellationToken cancellationToken);
    public static ConfiguredAsyncDisposable Create(JsonOperationContext context, Stream stream, AsyncBlittableJsonTextWriter& writer, CancellationToken cancellationToken);
    public ValueTask`1<int> MaybeOuterFlushAsync();
    [AsyncStateMachineAttribute("Sparrow.Json.AsyncBlittableJsonTextWriter/<OuterFlushAsync>d__5")]
public Task`1<int> OuterFlushAsync();
    [AsyncStateMachineAttribute("Sparrow.Json.AsyncBlittableJsonTextWriter/<WriteStreamAsync>d__6")]
public ValueTask WriteStreamAsync(Stream stream, CancellationToken token);
    public ValueTask`1<int> MaybeFlushAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Sparrow.Json.AsyncBlittableJsonTextWriter/<FlushAsync>d__8")]
public ValueTask`1<int> FlushAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Sparrow.Json.AsyncBlittableJsonTextWriter/<DisposeAsync>d__9")]
public sealed virtual ValueTask DisposeAsync();
    private void ThrowInvalidTypeException(Type typeOfStream);
}
public class Sparrow.Json.BlittableJsonDocumentBuilder : AbstractBlittableJsonDocumentBuilder {
    private static StringSegment UnderscoreSegment;
    private JsonOperationContext _context;
    private UsageMode _mode;
    private IJsonParser _reader;
    public IBlittableDocumentModifier _modifier;
    private BlittableWriter`1<UnmanagedWriteBuffer> _writer;
    private JsonParserState _state;
    private LazyStringValue _fakeFieldName;
    private SingleUseFlag _disposed;
    private WriteToken _writeToken;
    private string _debugTag;
    public int SizeInBytes { get; }
    public BlittableJsonDocumentBuilder(JsonOperationContext context, JsonParserState state, IJsonParser reader, BlittableWriter`1<UnmanagedWriteBuffer> writer, IBlittableDocumentModifier modifier);
    public BlittableJsonDocumentBuilder(JsonOperationContext context, UsageMode mode, string debugTag, IJsonParser reader, JsonParserState state, BlittableWriter`1<UnmanagedWriteBuffer> writer, IBlittableDocumentModifier modifier);
    public BlittableJsonDocumentBuilder(JsonOperationContext context, JsonParserState state, UsageMode mode, string debugTag, IJsonParser reader, BlittableWriter`1<UnmanagedWriteBuffer> writer);
    private static BlittableJsonDocumentBuilder();
    public void Reset();
    public void Renew(string debugTag, UsageMode mode);
    public void ReadArrayDocument();
    public void ReadObjectDocument();
    public void ReadNestedObject();
    public void ReadProperty();
    public int get_SizeInBytes();
    public virtual void Dispose();
    private bool ReadInternal();
    public bool Read();
    private bool ReadMaybeModifiedPropertyName();
    private void ThrowExpectedProperty();
    private void ThrowExpectedStartOfArray();
    private void ThrowExpectedStartOfObject();
    private void ReadJsonValue();
    private void ReadJsonValueUnlikely(JsonParserToken current);
    private void ThrowExpectedValue(JsonParserToken token);
    private LazyStringValue CreateLazyStringValueFromParserState();
    public void FinalizeDocument();
    public BlittableJsonReaderObject CreateReader();
    public BlittableJsonReaderArray CreateArrayReader(bool noCache);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class Sparrow.Json.BlittableJsonReaderArray : BlittableJsonReaderBase {
    private bool _disposeParent;
    private int _count;
    private Byte* _metadataPtr;
    private Byte* _dataStart;
    private long _currentOffsetSize;
    private Dictionary`2<int, ValueTuple`2<object, BlittableJsonToken>> _cache;
    public DynamicJsonArray Modifications;
    public BlittableJsonReaderObject Parent { get; }
    public Byte* DataStart { get; }
    public int Length { get; }
    public object Item { get; }
    public BlittableJsonArrayEnumerator Items { get; }
    public BlittableJsonReaderArray(int pos, BlittableJsonReaderObject parent, BlittableJsonToken type);
    public BlittableJsonReaderObject get_Parent();
    internal void ArrayIsRoot();
    public Byte* get_DataStart();
    public int get_Length();
    public virtual string ToString();
    public void BlittableValidation();
    public BlittableJsonReaderArray Clone(JsonOperationContext context, UsageMode usageMode);
    public sealed virtual void Dispose();
    public BlittableJsonToken GetArrayType();
    public object get_Item(int index);
    public int BinarySearch(string key, StringComparison comparison);
    public T GetByIndex(int index);
    public string GetStringByIndex(int index);
    public void AddItemsToStream(ManualBlittableJsonDocumentBuilder`1<T> writer);
    public ValueTuple`2<object, BlittableJsonToken> GetValueTokenTupleByIndex(int index);
    public BlittableJsonArrayEnumerator get_Items();
    private sealed virtual override IEnumerator`1<object> System.Collections.Generic.IEnumerable<System.Object>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private BlittableJsonArrayEnumerator GetEnumerator();
    public virtual bool Equals(object obj);
    public bool Equals(BlittableJsonReaderArray other);
    public virtual int GetHashCode();
    public void EnsureArrayModifiable();
}
public abstract class Sparrow.Json.BlittableJsonReaderBase : object {
    protected BlittableJsonReaderObject _parent;
    protected internal Byte* _mem;
    protected internal JsonOperationContext _context;
    [CompilerGeneratedAttribute]
private bool <NoCache>k__BackingField;
    public static BlittableJsonToken TypesMask;
    public bool HasParent { get; }
    public bool NoCache { get; public set; }
    protected BlittableJsonReaderBase(JsonOperationContext context);
    public bool BelongsToContext(JsonOperationContext context);
    public bool get_HasParent();
    [CompilerGeneratedAttribute]
public bool get_NoCache();
    [CompilerGeneratedAttribute]
public void set_NoCache(bool value);
    protected static int ProcessTokenPropertyFlags(BlittableJsonToken currentType);
    protected static int ProcessTokenOffsetFlags(BlittableJsonToken currentType);
    private static int ThrowInvalidOffsetSize(BlittableJsonToken currentType);
    public static BlittableJsonToken ProcessTokenTypeFlags(BlittableJsonToken currentType);
    private static void ThrowInvalidType(BlittableJsonToken currentType);
    protected int ReadNumber(Byte* value, long sizeOfValue);
    private static int ThrowInvalidSizeForNumber(long sizeOfValue);
    public BlittableJsonReaderObject ReadNestedObject(int pos);
    public LazyStringValue ReadStringLazily(int pos);
    public LazyCompressedStringValue ReadCompressStringLazily(int pos);
    public int ReadVariableSizeInt(int pos, Int32& offset);
    public static int ReadVariableSizeInt(Byte* buffer, Int32& pos);
    public static int ReadVariableSizeInt(Byte* buffer, int pos, Int32& offset, Boolean& success);
    public static int ReadVariableSizeInt(ReadOnlySpan`1<byte> buffer, int pos, Int32& offset, Boolean& success);
    private static void ThrowInvalidShift();
    public static int ReadVariableSizeIntInReverse(Byte* buffer, int pos, Byte& offset);
    protected long ReadVariableSizeLong(int pos);
    [ConditionalAttribute("DEBUG")]
protected void AssertContextNotDisposed();
    [ConditionalAttribute("DEBUG")]
protected void AssertContextNotDisposed(JsonOperationContext context);
}
[DefaultMemberAttribute("Item")]
public class Sparrow.Json.BlittableJsonReaderObject : BlittableJsonReaderBase {
    private static object BoxedTrue;
    private static object BoxedFalse;
    private AllocatedMemoryData _allocatedMemory;
    private UnmanagedWriteBuffer _buffer;
    private Byte* _metadataPtr;
    private int _size;
    private int _propCount;
    private long _currentOffsetSize;
    private long _currentPropertyIdSize;
    private bool _isRoot;
    private Byte* _objStart;
    private Byte* _propNames;
    private int _propNamesDataOffsetSize;
    public DynamicJsonValue Modifications;
    private Dictionary`2<StringSegment, object> _objectsPathCache;
    private Dictionary`2<int, object> _objectsPathCacheByIndex;
    private int _hashCode;
    public int Size { get; }
    public int Count { get; }
    public Byte* BasePointer { get; }
    public ulong DebugHash { get; }
    public long Location { get; }
    public object Item { get; }
    public BlittableJsonReaderObject(Byte* mem, int size, JsonOperationContext context, UnmanagedWriteBuffer buffer);
    private BlittableJsonReaderObject(Byte* mem, int size, JsonOperationContext context, AllocatedMemoryData allocatedMemory);
    private BlittableJsonReaderObject(Byte* mem, int size, JsonOperationContext context);
    public BlittableJsonReaderObject(int pos, BlittableJsonReaderObject parent, BlittableJsonToken type);
    private static BlittableJsonReaderObject();
    public virtual string ToString();
    public ValueTask WriteJsonToAsync(Stream stream, CancellationToken token);
    private static void ThrowOnZeroSize(int size);
    private static void ThrowOutOfRangeException(BlittableJsonToken token);
    private static void ThrowObjectDisposed();
    public int get_Size();
    public int get_Count();
    public Byte* get_BasePointer();
    public ulong get_DebugHash();
    public long get_Location();
    public String[] GetSortedPropertyNames();
    public String[] GetPropertyNames();
    private LazyStringValue GetPropertyName(int propertyId);
    public object get_Item(string name);
    public bool TryGet(string name, T& obj);
    public bool TryGetWithoutThrowingOnError(string name, T& obj);
    public bool TryGetWithoutThrowingOnError(StringSegment name, T& obj);
    public bool TryGet(StringSegment name, T& obj);
    private static void ThrowFormatException(object value, string fromType, string toType);
    private static void ThrowFormatException(object value, string fromType, string toType, Exception e);
    internal static bool TryConvertType(object result, T& obj);
    internal static void ConvertType(object result, T& obj);
    public bool TryGet(string name, Nullable`1& nullableDbl);
    public bool TryGet(StringSegment name, Nullable`1& nullableDbl);
    public bool TryGet(string name, Double& doubleNum);
    public bool TryGet(StringSegment name, Double& doubleNum);
    public bool TryGet(string name, String& str);
    public bool TryGet(StringSegment name, String& str);
    internal static bool ChangeTypeToString(object result, String& str);
    public bool TryGetMember(string name, Object& result);
    private bool TryGetObjectByIndex(int index, BlittableJsonToken expectedToken, Object& result);
    private bool CompareTokens(BlittableJsonToken firstToken, BlittableJsonToken secondToken);
    public bool TryGetMember(StringSegment name, Object& result);
    private void AddToCache(StringSegment name, object result, int index);
    private void GetPropertyTypeAndPosition(int index, long metadataSize, BlittableJsonToken& token, Int32& position, Int32& propertyId);
    public void GetPropertyByIndex(int index, PropertyDetails& prop, bool addObjectToCache);
    private static void ThrowOutOfRangeException(int indexValue);
    public int GetPropertyIndex(string name);
    public int GetPropertyIndex(LazyStringValue comparer);
    private int ComparePropertyName(int propertyId, LazyStringValue comparer);
    public InsertionOrderProperties GetPropertiesByInsertionOrder();
    public ulong GetHashOfPropertyNames();
    internal object GetObject(BlittableJsonToken type, int position, Boolean& isBlittableJsonReader);
    private RawBlob ReadRawBlob(int pos);
    public sealed virtual void Dispose();
    public void CopyTo(Byte* ptr);
    private static void InvalidAttemptToCopyNestedObject();
    public BlittableJsonReaderObject CloneOnTheSameContext();
    public BlittableJsonReaderObject Clone(JsonOperationContext context);
    public BlittableJsonReaderObject CloneForConcurrentRead(JsonOperationContext externalContext);
    public void BlittableValidation();
    private int PropertiesNamesValidation(int numberOfProps, int propsOffsetList, int propsNamesOffsetSize, int currentSize);
    private int StringValidation(int stringOffset);
    private BlittableJsonToken TokenValidation(byte tokenStart, Int32& propOffsetSize, Int32& propIdSize);
    private int PropertiesValidation(BlittableJsonToken rootTokenType, int mainPropOffsetSize, int mainPropIdSize, int objStartOffset, int numberOfPropsNames);
    public void AddItemsToStream(ManualBlittableJsonDocumentBuilder`1<T> writer);
    private static void ThrowInvalidTokenType();
    private static void ThrowInvalidNull();
    private static void ThrowInvalidBool();
    private static void ThrowInvalidCompressedString();
    private void ThrowInvalidNumber(int numberPosition);
    private static void ThrowInvalidPropertiesId();
    private static void ThrowInvalidPropertiesOffest();
    private static void ThrowInvalidNumberOfProperties();
    public virtual bool Equals(object obj);
    public bool Equals(BlittableJsonReaderObject other, bool ignoreRavenProperties);
    public virtual int GetHashCode();
    [ConditionalAttribute("DEBUG")]
public static void AssertNoModifications(BlittableJsonReaderObject data, string id, bool assertChildren, bool assertRemovals, bool assertProperties);
    public bool Contains(LazyStringValue propertyName);
    public ReadOnlySpan`1<byte> AsSpan();
}
[ExtensionAttribute]
internal static class Sparrow.Json.BlittableJsonTextWriterExtensions : object {
    [ExtensionAttribute]
public static void WriteArray(TWriter writer, JsonOperationContext context, string name, IEnumerable`1<T> items, Action`3<TWriter, JsonOperationContext, T> onWrite);
    [ExtensionAttribute]
public static void WriteArrayValue(TWriter writer, IEnumerable`1<string> items);
    [ExtensionAttribute]
public static void WriteArray(TWriter writer, string name, Memory`1<double> items);
    [AsyncStateMachineAttribute("Sparrow.Json.BlittableJsonTextWriterExtensions/<WriteArrayAsync>d__3")]
[ExtensionAttribute]
public static Task WriteArrayAsync(AsyncBlittableJsonTextWriter writer, string name, IEnumerable`1<Stream> items);
    [ExtensionAttribute]
public static void WriteArray(TWriter writer, string name, IEnumerable`1<LazyStringValue> items);
    [ExtensionAttribute]
public static void WriteArray(TWriter writer, string name, IEnumerable`1<string> items);
    [ExtensionAttribute]
public static void WriteArray(TWriter writer, string name, IEnumerable`1<DynamicJsonValue> items, JsonOperationContext context);
    [ExtensionAttribute]
public static void WriteArray(TWriter writer, string name, IEnumerable`1<BlittableJsonReaderObject> items);
    [AsyncStateMachineAttribute("Sparrow.Json.BlittableJsonTextWriterExtensions/<WriteArrayAsync>d__8")]
[ExtensionAttribute]
public static Task WriteArrayAsync(AsyncBlittableJsonTextWriter writer, string name, IEnumerable`1<BlittableJsonReaderObject> items);
    [AsyncStateMachineAttribute("Sparrow.Json.BlittableJsonTextWriterExtensions/<WriteArrayAsync>d__9")]
[ExtensionAttribute]
public static Task WriteArrayAsync(AsyncBlittableJsonTextWriter writer, string name, IAsyncEnumerable`1<BlittableJsonReaderObject> items);
    [ExtensionAttribute]
public static void WriteArray(TWriter writer, string name, IEnumerable`1<long> items);
}
[FlagsAttribute]
public enum Sparrow.Json.BlittableJsonToken : Enum {
    public byte value__;
    public static BlittableJsonToken StartObject;
    public static BlittableJsonToken StartArray;
    public static BlittableJsonToken Integer;
    public static BlittableJsonToken LazyNumber;
    public static BlittableJsonToken String;
    public static BlittableJsonToken CompressedString;
    public static BlittableJsonToken Boolean;
    public static BlittableJsonToken Null;
    public static BlittableJsonToken EmbeddedBlittable;
    public static BlittableJsonToken RawBlob;
    public static BlittableJsonToken Reserved2;
    public static BlittableJsonToken Reserved3;
    public static BlittableJsonToken Reserved4;
    public static BlittableJsonToken Reserved5;
    public static BlittableJsonToken Reserved6;
    public static BlittableJsonToken OffsetSizeByte;
    public static BlittableJsonToken OffsetSizeShort;
    public static BlittableJsonToken OffsetSizeInt;
    public static BlittableJsonToken PropertyIdSizeByte;
    public static BlittableJsonToken PropertyIdSizeShort;
    public static BlittableJsonToken PropertyIdSizeInt;
    public static BlittableJsonToken PositionMask;
    public static BlittableJsonToken PropertyIdMask;
}
public class Sparrow.Json.BlittableWriter`1 : object {
    private JsonOperationContext _context;
    private TWriter _unmanagedWriteBuffer;
    private AllocatedMemoryData _compressionBuffer;
    private AllocatedMemoryData _innerBuffer;
    private int _position;
    private int _lastSize;
    private int _documentNumber;
    [ThreadStaticAttribute]
private static FastList`1<int> _intBuffer;
    [ThreadStaticAttribute]
private static Int32[] _propertyArrayOffset;
    public int Position { get; }
    public int SizeInBytes { get; }
    internal CachedProperties CachedProperties { get; }
    public BlittableWriter`1(JsonOperationContext context, TWriter writer);
    public BlittableWriter`1(JsonOperationContext context);
    private static BlittableWriter`1();
    public int get_Position();
    public int get_SizeInBytes();
    public BlittableJsonReaderObject CreateReader();
    internal CachedProperties get_CachedProperties();
    public int WriteValue(long value);
    public int WriteValue(ulong value);
    public int WriteValue(bool value);
    public int WriteNull();
    public int WriteValue(double value);
    public int WriteValue(decimal value);
    public int WriteValue(float value);
    public int WriteValue(LazyNumberValue value);
    public int WriteValue(byte value);
    private static string EnsureDecimalPlace(double value, string text);
    private static string EnsureDecimalPlace(decimal value, string text);
    public void Reset();
    public void ResetAndRenew();
    public WriteToken WriteObjectMetadata(FastList`1<PropertyTag> properties, long firstWrite, int maxPropId);
    public int WriteArrayMetadata(FastList`1<int> positions, FastList`1<BlittableJsonToken> types, BlittableJsonToken& listToken);
    private static int SetPropertyIdSizeFlag(BlittableJsonToken& objectToken, int maxPropId);
    public static void CleanPropertyArrayOffset();
    private int WritePropertyNames(int rootOffset);
    public void WriteDocumentMetadata(int rootOffset, BlittableJsonToken documentToken);
    private static int SetOffsetSizeFlag(BlittableJsonToken& objectToken, long distanceFromFirstProperty);
    public void WriteNumber(int value, int sizeOfValue);
    public int WriteVariableSizeLong(long value);
    public int WriteVariableSizeInt(int value);
    public int WriteVariableSizeIntInReverse(int value);
    public int WriteValue(string str, BlittableJsonToken& token, UsageMode mode);
    public int WriteValue(LazyStringValue str);
    public int WriteValue(LazyStringValue str, BlittableJsonToken& token, UsageMode mode, Nullable`1<int> initialCompressedSize);
    private static int GetSizeIncludingEscapeSequences(Byte* buffer, int size);
    public int WriteValue(LazyCompressedStringValue str, BlittableJsonToken& token, UsageMode mode);
    public int WriteValue(Byte* buffer, int size, BlittableJsonToken& token, UsageMode mode, Nullable`1<int> initialCompressedSize);
    public int WriteValue(Byte* buffer, int size, FastList`1<int> escapePositions, BlittableJsonToken& token, UsageMode mode, Nullable`1<int> initialCompressedSize);
    public int WriteValue(Byte* buffer, int size);
    public int WriteValue(Byte* buffer, int size, Int32[] escapePositions);
    public int WriteValue(Byte* buffer, int size, FastList`1<int> escapePositions);
    public int WriteValue(Byte* buffer, int size, Int32[] escapePositions, BlittableJsonToken& token, UsageMode mode, Nullable`1<int> initialCompressedSize);
    private int TryCompressValue(Byte*& buffer, Int32& position, int size, BlittableJsonToken& token, UsageMode mode, Nullable`1<int> initialCompressedSize, int maxGoodCompressionSize);
    private Byte* CompressBuffer(Byte* buffer, int size, int maxGoodCompressionSize, Int32& compressedSize);
    private static int CalculateCompressionAcceleration(int size);
    private Byte* GetCompressionBuffer(int minSize);
    internal void ThrowIfCachedPropertiesWereReset();
    public sealed virtual void Dispose();
}
public class Sparrow.Json.CachedProperties : object {
    private JsonOperationContext _context;
    private Sorter`2<PropertyTag, PropertySorter> _sorter;
    private static PerCoreContainer`1<CachedSort[]> _perCorePropertiesCache;
    private static int CachedSortsSize;
    public static int CachedPropertiesSize;
    private CachedSort[] _cachedSorts;
    private FastList`1<PropertyName> _docPropNames;
    private SortedDictionary`2<PropertyName, object> _propertiesSortOrder;
    private Dictionary`2<LazyStringValue, PropertyName> _propertyNameToId;
    private bool _propertiesNeedSorting;
    public int PropertiesDiscovered;
    private bool _hasDuplicates;
    [CompilerGeneratedAttribute]
private int <DocumentNumber>k__BackingField;
    internal int DocumentNumber { get; private set; }
    public CachedProperties(JsonOperationContext context);
    private static CachedProperties();
    public void Renew();
    public void Reset();
    public void Clear();
    public void ClearRenew();
    public PropertyName GetProperty(LazyStringValue propName);
    private PropertyName UnlikelyGetProperty(LazyStringValue propName);
    private PropertyName SwapPropertyIds(PropertyName prop);
    public void Sort(FastList`1<PropertyTag> properties);
    private int GetPropertiesHashedIndex(FastList`1<PropertyTag> properties);
    private void UnlikelySortProperties(FastList`1<PropertyTag> properties);
    private void UpdatePropertiesSortOrder();
    [CompilerGeneratedAttribute]
internal int get_DocumentNumber();
    [CompilerGeneratedAttribute]
private void set_DocumentNumber(int value);
    public LazyStringValue GetProperty(int index);
    public void NewDocument();
    public bool NeedClearPropertiesCache();
}
[AttributeUsageAttribute("4")]
internal class Sparrow.Json.CreateFromBlittableJsonAttribute : Attribute {
}
[AttributeUsageAttribute("384")]
internal class Sparrow.Json.ForceJsonSerializationAttribute : Attribute {
}
public interface Sparrow.Json.IBlittableDocumentModifier {
    public abstract virtual void StartObject();
    public abstract virtual void EndObject();
    public abstract virtual bool AboutToReadPropertyName(IJsonParser reader, JsonParserState state);
    public abstract virtual void Reset(JsonOperationContext context);
}
public interface Sparrow.Json.IBlittableJsonContainer {
    public BlittableJsonReaderObject BlittableJson { get; }
    public abstract virtual BlittableJsonReaderObject get_BlittableJson();
}
public interface Sparrow.Json.IBlittableJsonTextWriter {
    public abstract virtual void WriteObject(BlittableJsonReaderObject obj);
    public abstract virtual void WriteValue(BlittableJsonToken token, object val);
    public abstract virtual int WriteDateTime(Nullable`1<DateTime> value, bool isUtc);
    public abstract virtual int WriteDateTime(DateTime value, bool isUtc);
    public abstract virtual void WriteString(string str, bool skipEscaping);
    public abstract virtual void WriteString(LazyStringValue str, bool skipEscaping);
    public abstract virtual void WriteString(LazyCompressedStringValue str);
    public abstract virtual void WriteStartObject();
    public abstract virtual void WriteEndObject();
    public abstract virtual void WriteStartArray();
    public abstract virtual void WriteEndArray();
    public abstract virtual void WriteNull();
    public abstract virtual void WriteBool(bool val);
    public abstract virtual void WritePropertyName(ReadOnlySpan`1<byte> prop);
    public abstract virtual void WritePropertyName(string prop);
    public abstract virtual void WritePropertyName(StringSegment prop);
    public abstract virtual void WriteInteger(long val);
    public abstract virtual void WriteDouble(LazyNumberValue val);
    public abstract virtual void WriteDouble(double val);
    public abstract virtual void WriteNewLine();
    public abstract virtual void WriteComma();
}
public interface Sparrow.Json.IDynamicJsonValueConvertible {
    public abstract virtual DynamicJsonValue ToJson();
}
public interface Sparrow.Json.IFillFromBlittableJson {
    public abstract virtual void FillFromBlittableJson(BlittableJsonReaderObject json);
}
internal interface Sparrow.Json.IPostJsonDeserialization {
    public abstract virtual void PostDeserialization();
}
public interface Sparrow.Json.IUnmanagedWriteBuffer {
    public int SizeInBytes { get; }
    public abstract virtual int get_SizeInBytes();
    public abstract virtual void Write(Byte[] buffer, int start, int count);
    public abstract virtual void Write(Byte* buffer, int length);
    public abstract virtual void WriteByte(byte data);
    public abstract virtual void EnsureSingleChunk(JsonParserState state);
    public abstract virtual void EnsureSingleChunk(Byte*& ptr, Int32& size);
}
public class Sparrow.Json.JsonContextPool : JsonContextPoolBase`1<JsonOperationContext> {
    private int _maxNumberOfAllocatedStringValuesPerContext;
    public JsonContextPool(Nullable`1<Size> maxContextSizeToKeep);
    internal JsonContextPool(Nullable`1<Size> maxContextSizeToKeep, Nullable`1<long> maxNumberOfContextsToKeepInGlobalStack, int maxNumberOfAllocatedStringValuesPerContext);
    protected virtual JsonOperationContext CreateContext();
}
public abstract class Sparrow.Json.JsonContextPoolBase`1 : object {
    private object _locker;
    private static Logger Logger;
    private bool _disposed;
    protected SharedMultipleUseFlag LowMemoryFlag;
    private MultipleUseFlag _isExtremelyLowMemory;
    private long _generation;
    private CancellationTokenSource _cts;
    private long _maxContextSizeToKeepInBytes;
    private long _maxNumberOfContextsToKeepInGlobalStack;
    private long _numberOfContextsDisposedInGlobalStack;
    private PerCoreContainer`1<T> _perCoreCache;
    private CountingConcurrentStack`1<T> _globalStack;
    private Timer _cleanupTimer;
    private DateTime _lastPerCoreCleanup;
    private TimeSpan _perCoreCleanupInterval;
    private DateTime _lastGlobalStackRebuild;
    private TimeSpan _globalStackRebuildInterval;
    protected JsonContextPoolBase`1(Nullable`1<Size> maxContextSizeToKeep);
    protected JsonContextPoolBase`1(Nullable`1<Size> maxContextSizeToKeep, Nullable`1<long> maxNumberOfContextsToKeepInGlobalStack);
    private static JsonContextPoolBase`1();
    public IDisposable AllocateOperationContext(JsonOperationContext& context);
    public void Clean();
    public IDisposable AllocateOperationContext(T& context);
    protected abstract virtual T CreateContext();
    private void Cleanup(object _);
    private void Push(T context);
    public virtual void Dispose();
    public sealed virtual void LowMemory(LowMemorySeverity lowMemorySeverity);
    public sealed virtual void LowMemoryOver();
    [CompilerGeneratedAttribute]
internal static bool <AllocateOperationContext>g__TryGetFromStack|18_0(CountingConcurrentStack`1<T> stack, T& context);
    [CompilerGeneratedAttribute]
internal static void <Dispose>g__ClearStack|27_0(CountingConcurrentStack`1<T> stack);
    [CompilerGeneratedAttribute]
internal static void <LowMemory>g__ClearStack|28_0(CountingConcurrentStack`1<T> stack);
}
internal class Sparrow.Json.JsonDeserializationBase : object {
    private static Type[] EmptyTypes;
    private static Dictionary`2<Type, object> DeserializedTypes;
    private static JsonDeserializationBase();
    protected internal static Func`2<BlittableJsonReaderObject, T> GenerateJsonDeserializationRoutine();
    private static Func`2<BlittableJsonReaderObject, T> FailureBuildingJsonParser(Exception e);
    private static void ThrowDeserializationError(Type type, FieldInfo fieldInfo);
    private static MethodCallExpression GetValue(string propertyName, Type propertyType, List`1<Attribute> customAttributes, ParameterExpression json, Dictionary`2<Type, ParameterExpression> vars);
    private static object GetConverterFromCache(Type propertyType);
    private static ParameterExpression GetParameter(Type type, Dictionary`2<Type, ParameterExpression> vars);
    private static Dictionary`2<string, T> ToDictionaryOfPrimitive(BlittableJsonReaderObject json, string name, JsonDeserializationStringDictionaryAttribute jsonDeserializationDictionaryAttribute);
    private static Dictionary`2<TK, TV> ToDictionary(BlittableJsonReaderObject json, string name, JsonDeserializationStringDictionaryAttribute jsonDeserializationDictionaryAttribute, Func`2<BlittableJsonReaderObject, TV> converter);
    private static void ThrowNotSupportedBlittableArray(string propertyName);
    private static T CreateFromBlittableJson(BlittableJsonReaderObject json, string name, MethodInfo methodToCall);
    private static Dictionary`2<string, TEnum> ToDictionaryOfEnum(BlittableJsonReaderObject json, string name, JsonDeserializationStringDictionaryAttribute jsonDeserializationDictionaryAttribute);
    private static Dictionary`2<TKey, string> ToDictionaryOfPrimitiveKeys(BlittableJsonReaderObject json, string name);
    private static Dictionary`2<TEnum, string> ToDictionaryOfEnumKeys(BlittableJsonReaderObject json, string name);
    private static Dictionary`2<string, string> ToDictionaryOfString(BlittableJsonReaderObject json, string name, JsonDeserializationStringDictionaryAttribute jsonDeserializationDictionaryAttribute);
    private static Dictionary`2<TK, List`1<TV>> ToDictionaryOfList(BlittableJsonReaderObject json, string name, JsonDeserializationStringDictionaryAttribute jsonDeserializationDictionaryAttribute, Func`2<BlittableJsonReaderObject, TV> converter);
    private static Dictionary`2<string, List`1<string>> ToDictionaryOfStringList(BlittableJsonReaderObject json, string name, JsonDeserializationStringDictionaryAttribute jsonDeserializationDictionaryAttribute);
    private static Dictionary`2<string, String[]> ToDictionaryOfStringArray(BlittableJsonReaderObject json, string name, JsonDeserializationStringDictionaryAttribute jsonDeserializationDictionaryAttribute);
    private static Dictionary`2<string, Double[]> ToDictionaryOfDoubleArray(BlittableJsonReaderObject json, string name, JsonDeserializationStringDictionaryAttribute jsonDeserializationDictionaryAttribute);
    private static Dictionary`2<string, Dictionary`2<string, String[]>> ToDictionaryOfDictionaryOfStringArray(BlittableJsonReaderObject json, string name, JsonDeserializationStringDictionaryAttribute jsonDeserializationDictionaryAttribute);
    private static Dictionary`2<string, Dictionary`2<string, Double[]>> ToDictionaryOfDictionaryOfDoubleArray(BlittableJsonReaderObject json, string name, JsonDeserializationStringDictionaryAttribute jsonDeserializationDictionaryAttribute);
    private static List`1<String[]> ToListOfStringArray(BlittableJsonReaderObject json, string name);
    private static TCollection ToCollectionOfString(BlittableJsonReaderObject json, string name);
    private static String[] ToArrayOfString(BlittableJsonReaderObject json, string name);
    private static Double[] ToArrayOfDouble(BlittableJsonReaderObject json, string name);
    private static T GetPrimitiveProperty(BlittableJsonReaderObject json, string prop);
    private static void ThrowInvalidPrimitiveCastException(string prop, string type, BlittableJsonReaderObject json);
    private static T ToObject(BlittableJsonReaderObject json, string name, Func`2<BlittableJsonReaderObject, T> converter);
    private static HashSet`1<T> ToHashSet(BlittableJsonReaderObject json, string name, Func`2<BlittableJsonReaderObject, T> converter);
    private static List`1<T> ToList(BlittableJsonReaderObject json, string name, Func`2<BlittableJsonReaderObject, T> converter);
    private static T[] ToArray(BlittableJsonReaderObject json, string name, Func`2<BlittableJsonReaderObject, T> converter);
    private static bool IsNumeric();
    private static bool TryGetTimeSpan(BlittableJsonReaderObject json, string propertyName, TimeSpan& timeSpan);
    private static bool TryGetNullableTimeSpan(BlittableJsonReaderObject json, string propertyName, Nullable`1& timeSpan);
    private static bool TryGetSize(BlittableJsonReaderObject json, string propertyName, Size& size);
    private static bool TryGetNullableSize(BlittableJsonReaderObject json, string propertyName, Nullable`1& size);
    private static StringComparer GetStringComparer(StringComparison stringComparison);
    [CompilerGeneratedAttribute]
internal static void <GenerateJsonDeserializationRoutine>g__SetValue|2_1(Type memberType, MemberExpression access, MethodCallExpression value, <>c__DisplayClass2_0`1& );
    [CompilerGeneratedAttribute]
internal static ConstantExpression <GetValue>g__GetJsonDeserializationDictionaryAttribute|5_0(List`1<Attribute> customAttributes);
}
[AttributeUsageAttribute("384")]
public class Sparrow.Json.JsonDeserializationIgnoreAttribute : Attribute {
}
[AttributeUsageAttribute("384")]
internal class Sparrow.Json.JsonDeserializationStringDictionaryAttribute : Attribute {
    public StringComparison StringComparison;
    public JsonDeserializationStringDictionaryAttribute(StringComparison stringComparison);
}
public class Sparrow.Json.JsonOperationContext : PooledItem {
    private int _generation;
    internal long PoolGeneration;
    public static int InitialStreamSize;
    private static int MaxInitialStreamSize;
    private int _initialSize;
    private int _longLivedSize;
    private int _maxNumberOfAllocatedStringValues;
    protected ArenaMemoryAllocator _arenaAllocator;
    private ArenaMemoryAllocator _arenaAllocatorForLongLivedValues;
    private AllocatedMemoryData _tempBuffer;
    private Dictionary`2<StringSegment, LazyStringValue> _fieldNames;
    private static PerCoreContainer`1<PathCache> _perCorePathCache;
    private PathCache _activeAllocatePathCaches;
    private Stack`1<MemoryStream> _cachedMemoryStreams;
    private static PerCoreContainer`1<FastList`1<LazyStringValue>> _perCoreLazyStringValuesList;
    private int _numberOfAllocatedStringsValues;
    private FastList`1<LazyStringValue> _allocateStringValues;
    public bool DoNotReuse;
    private LazyStringValue _empty;
    public CachedProperties CachedProperties;
    private JsonParserState _jsonParserState;
    private ObjectJsonParser _objectJsonParser;
    private BlittableJsonDocumentBuilder _documentBuilder;
    protected SharedMultipleUseFlag LowMemoryFlag;
    private DisposeOnce`1<SingleAttempt> _disposeOnceRunner;
    private static long MemoryStreamCacheThreshold;
    private static int MemoryStreamCacheMaxCapacityInBytes;
    private long _sizeOfMemoryStreamCache;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<Type, ValueTuple`2<Action`1<Array>, List`1<Array>>> _pooledArrays;
    private SyncJsonOperationContext _sync;
    public LazyStringValue Empty { get; }
    public int Generation { get; }
    public long AllocatedMemory { get; }
    public long UsedMemory { get; }
    public bool Disposed { get; }
    internal SyncJsonOperationContext Sync { get; }
    public JsonOperationContext(int initialSize, int longLivedSize, int maxNumberOfAllocatedStringValues, SharedMultipleUseFlag lowMemoryFlag);
    private static JsonOperationContext();
    public LazyStringValue get_Empty();
    public LazyStringValue AllocateStringValue(string str, Byte* ptr, int size);
    public int get_Generation();
    public virtual long get_AllocatedMemory();
    public virtual long get_UsedMemory();
    public static JsonOperationContext ShortTermSingleUse();
    public ReturnBuffer GetMemoryBuffer(MemoryBuffer& buffer);
    public ReturnBuffer GetMemoryBuffer(int size, MemoryBuffer& buffer);
    public AllocatedMemoryData GetMemory(int requestedSize);
    public AllocatedMemoryData GetLongLivedMemory(int requestedSize);
    private static void ThrowAlreadyDisposedForLongLivedAllocator();
    public UnmanagedWriteBuffer GetStream(int initialSize);
    public bool get_Disposed();
    public virtual void Dispose();
    public LazyStringValue GetLazyStringForFieldWithCaching(StringSegment key);
    public LazyStringValue GetLazyStringForFieldWithCaching(string field);
    private LazyStringValue GetLazyStringForFieldWithCachingUnlikely(StringSegment key);
    public LazyStringValue GetLazyString(string field);
    private LazyStringValue GetLazyString(StringSegment field, bool longLived);
    public LazyStringValue GetLazyString(Byte* ptr, int size, bool longLived);
    public LazyStringValue GetLazyStringValue(Byte* ptr, Boolean& success);
    public ValueTask`1<BlittableJsonReaderObject> ReadForDiskAsync(Stream stream, string documentId, Nullable`1<CancellationToken> token);
    public ValueTask`1<BlittableJsonReaderObject> ReadForMemoryAsync(Stream stream, string documentId, Nullable`1<CancellationToken> token);
    [AsyncStateMachineAttribute("Sparrow.Json.JsonOperationContext/<ParseToMemoryAsync>d__55")]
private ValueTask`1<BlittableJsonReaderObject> ParseToMemoryAsync(Stream stream, string debugTag, UsageMode mode, IBlittableDocumentModifier modifier, Nullable`1<CancellationToken> token);
    public BlittableJsonReaderObject ReadObject(DynamicJsonValue builder, string documentId, UsageMode mode, IBlittableDocumentModifier modifier);
    public BlittableJsonReaderObject ReadObject(BlittableJsonReaderObject obj, string documentId, UsageMode mode);
    private BlittableJsonReaderObject ReadObjectInternal(object builder, string documentId, UsageMode mode, IBlittableDocumentModifier modifier);
    [AsyncStateMachineAttribute("Sparrow.Json.JsonOperationContext/<ReadFromWebSocketAsync>d__59")]
public Task`1<BlittableJsonReaderObject> ReadFromWebSocketAsync(WebSocket webSocket, string debugTag, CancellationToken token);
    public BlittableJsonReaderObject ParseBuffer(Byte* buffer, int length, string debugTag, UsageMode mode, IBlittableDocumentModifier modifier);
    public BlittableJsonReaderArray ParseBufferToArray(string value, string debugTag, UsageMode mode, IBlittableDocumentModifier modifier);
    [AsyncStateMachineAttribute("Sparrow.Json.JsonOperationContext/<ParseToMemoryAsync>d__62")]
public ValueTask`1<BlittableJsonReaderObject> ParseToMemoryAsync(WebSocket webSocket, string debugTag, UsageMode mode, MemoryBuffer bytes, IBlittableDocumentModifier modifier, CancellationToken token);
    private void EnsureNotDisposed();
    [AsyncStateMachineAttribute("Sparrow.Json.JsonOperationContext/<ParseToMemoryAsync>d__64")]
public ValueTask`1<BlittableJsonReaderObject> ParseToMemoryAsync(Stream stream, string documentId, UsageMode mode, MemoryBuffer bytes, IBlittableDocumentModifier modifier, Nullable`1<CancellationToken> token, int maxSize);
    private void DisposeIfNeeded(int generation, UnmanagedJsonParser parser, BlittableJsonDocumentBuilder builder);
    private void ThrowObjectDisposed();
    protected internal virtual void Renew();
    protected internal virtual void Reset(bool forceReleaseLongLivedAllocator);
    public void AcquirePathCache(Dictionary`2& pathCache, Dictionary`2& pathCacheByIndex);
    public void ReleasePathCache(Dictionary`2<StringSegment, object> pathCache, Dictionary`2<int, object> pathCacheByIndex);
    [AsyncStateMachineAttribute("Sparrow.Json.JsonOperationContext/<WriteAsync>d__71")]
public ValueTask WriteAsync(Stream stream, BlittableJsonReaderObject json, CancellationToken token);
    public void Write(TWriter writer, BlittableJsonReaderObject json);
    private void WriteInternal(TWriter writer, object json);
    public void Write(TWriter writer, DynamicJsonValue json);
    public void Write(TWriter writer, DynamicJsonArray json);
    public void WriteObject(TWriter writer, JsonParserState state, ObjectJsonParser parser);
    private void WriteValue(TWriter writer, JsonParserState state, ObjectJsonParser parser);
    public void WriteArray(TWriter writer, JsonParserState state, ObjectJsonParser parser);
    public bool GrowAllocation(AllocatedMemoryData allocation, int sizeIncrease);
    public MemoryStream CheckoutMemoryStream();
    public void ReturnMemoryStream(MemoryStream stream);
    public void ReturnMemory(AllocatedMemoryData allocation);
    private static void ThrowUseAfterFree(AllocatedMemoryData allocation);
    public AvoidOverAllocationScope AvoidOverAllocation();
    public T[] AllocatePooledArray(int size);
    internal SyncJsonOperationContext get_Sync();
    [CompilerGeneratedAttribute]
private void <.ctor>b__34_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__34_1();
    [CompilerGeneratedAttribute]
internal static void <.ctor>g__TryDispose|34_2(IDisposable d, <>c__DisplayClass34_0& );
    [CompilerGeneratedAttribute]
internal static void <.ctor>g__TryExecute|34_3(Action a, <>c__DisplayClass34_0& );
    [CompilerGeneratedAttribute]
internal static void <AllocatePooledArray>g__Releaser|90_0(Array x);
}
public class Sparrow.Json.LazyCompressedStringValue : object {
    private JsonOperationContext _context;
    public Byte* Buffer;
    public int UncompressedSize;
    public int CompressedSize;
    public string String;
    public LazyCompressedStringValue(string str, Byte* buffer, int uncompressedSize, int compressedSize, JsonOperationContext context);
    public virtual bool Equals(object obj);
    public LazyStringValue ToLazyStringValue();
    public static string op_Implicit(LazyCompressedStringValue self);
    public Byte* DecompressToTempBuffer(AllocatedMemoryData& allocatedData, JsonOperationContext externalContext);
    public UnmanagedPointer DecompressToUnmanagedPointer(AllocatedMemoryData& allocatedData, JsonOperationContext externalContext);
    public AllocatedMemoryData DecompressToAllocatedMemoryData(JsonOperationContext externalContext);
    private AllocatedMemoryData DecompressToAllocatedMemoryDataInternal(JsonOperationContext externalContext, Int32& size);
    private void DecompressToBuffer(Byte* tempBuffer, int sizeOfEscapePositions, Int32& size);
    private int GetSizeOfEscapePositions();
    public virtual string ToString();
    public string Substring(int startIndex);
    public string Substring(int startIndex, int length);
    public virtual int GetHashCode();
    public bool Equals(LazyCompressedStringValue other);
}
public class Sparrow.Json.LazyNumberValue : object {
    public LazyStringValue Inner;
    private Nullable`1<double> _val;
    private Nullable`1<float> _floatVal;
    private Nullable`1<decimal> _decimalVal;
    private Nullable`1<long> _longVal;
    private Nullable`1<ulong> _ulongVal;
    public LazyNumberValue(LazyStringValue inner);
    public static long op_Implicit(LazyNumberValue self);
    public static ulong op_Implicit(LazyNumberValue self);
    public static double op_Implicit(LazyNumberValue self);
    public static string op_Implicit(LazyNumberValue self);
    public static float op_Implicit(LazyNumberValue self);
    public static decimal op_Implicit(LazyNumberValue self);
    private static void ThrowInvalidNumberFormat(LazyNumberValue self, string type);
    public static decimal op_Multiply(LazyNumberValue x, LazyNumberValue y);
    public static decimal op_Division(LazyNumberValue x, LazyNumberValue y);
    public static decimal op_Addition(LazyNumberValue x, LazyNumberValue y);
    public static decimal op_Subtraction(LazyNumberValue x, LazyNumberValue y);
    public static decimal op_Modulus(LazyNumberValue x, LazyNumberValue y);
    public static decimal op_Multiply(long x, LazyNumberValue y);
    public static decimal op_Division(long x, LazyNumberValue y);
    public static decimal op_Addition(long x, LazyNumberValue y);
    public static decimal op_Subtraction(long x, LazyNumberValue y);
    public static decimal op_Modulus(long x, LazyNumberValue y);
    public static decimal op_UnaryPlus(LazyNumberValue y);
    public static decimal op_UnaryNegation(LazyNumberValue y);
    public static bool op_Inequality(LazyNumberValue self, LazyNumberValue lnv);
    public static bool op_Equality(LazyNumberValue self, LazyNumberValue lnv);
    public virtual bool Equals(object obj);
    private bool Equals(LazyNumberValue other);
    internal bool TryParseLong(Int64& longValue);
    internal bool TryParseULong(UInt64& ulongValue);
    internal bool TryParseDouble(Double& doubleVal);
    internal bool TryParseFloat(Single& floatVal);
    internal bool TryParseDecimal(Decimal& decimalValue);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(object that);
    public Nullable`1<int> TryCompareTo(object that);
    private static int Compare(double this, double that);
    public virtual string ToString();
    public string ToString(string format);
    public bool IsNaN();
    public bool IsPositiveInfinity();
    public bool IsNegativeInfinity();
    public sealed virtual TypeCode GetTypeCode();
    private void ThrowInvalidCaseException(string typeName);
    public sealed virtual bool ToBoolean(IFormatProvider provider);
    public sealed virtual byte ToByte(IFormatProvider provider);
    public sealed virtual char ToChar(IFormatProvider provider);
    public sealed virtual DateTime ToDateTime(IFormatProvider provider);
    public sealed virtual decimal ToDecimal(IFormatProvider provider);
    public sealed virtual double ToDouble(IFormatProvider provider);
    public sealed virtual short ToInt16(IFormatProvider provider);
    public sealed virtual int ToInt32(IFormatProvider provider);
    public sealed virtual long ToInt64(IFormatProvider provider);
    public sealed virtual sbyte ToSByte(IFormatProvider provider);
    public sealed virtual float ToSingle(IFormatProvider provider);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual object ToType(Type conversionType, IFormatProvider provider);
    public sealed virtual ushort ToUInt16(IFormatProvider provider);
    public sealed virtual UInt32 ToUInt32(IFormatProvider provider);
    public sealed virtual ulong ToUInt64(IFormatProvider provider);
}
internal class Sparrow.Json.LazyStringParser : object {
    private static int OOR;
    private static Int32* shift1;
    private static Int32* shift10;
    private static Int32* shift100;
    private static Int32* shift1000;
    private static long TicksPerMillisecond;
    private static long TicksPerSecond;
    private static long TicksPerMinute;
    private static long TicksPerHour;
    private static long TicksPerDay;
    private static Int32[] _daysToMonth365;
    private static Int32[] _daysToMonth366;
    private static long MaxSeconds;
    private static long MinSeconds;
    private static LazyStringParser();
    private static bool TryDateToTicks(int year, int month, int day, int hour, int minute, int second, int fraction, Int64& ticks);
    public static bool TryParseTimeSpan(Byte* buffer, int len, TimeSpan& ts);
    public static bool TryParseTimeOnly(Byte* buffer, int len, TimeOnly& timeOnly);
    public static bool TryParseTimeOnly(Char* buffer, int len, TimeOnly& timeOnly);
    public static bool TryParseDateOnly(Byte* buffer, int len, DateOnly& dateOnly);
    public static bool TryParseDateOnly(Char* buffer, int len, DateOnly& dateOnly);
    public static Result TryParseTimeForQuery(Char* buffer, int len, DateTime& dt, DateTimeOffset& dto, DateOnly& do, TimeOnly& to, bool properlyParseThreeDigitsMilliseconds);
    public static Result TryParseTimeForQuery(Byte* buffer, int len, DateTime& dt, DateTimeOffset& dto, DateOnly& do, TimeOnly& to, bool properlyParseThreeDigitsMilliseconds);
    public static bool TryParseTimeSpan(Char* buffer, int len, TimeSpan& ts);
    public static Result TryParseDateTime(Char* buffer, int len, DateTime& dt, DateTimeOffset& dto, bool properlyParseThreeDigitsMilliseconds);
    public static Result TryParseDateTimeInternal(Char* buffer, int len, DateTime& dt, DateTimeOffset& dto, bool properlyParseThreeDigitsMilliseconds);
    public static Result TryParseDateTime(Byte* buffer, int len, DateTime& dt, DateTimeOffset& dto, bool properlyParseThreeDigitsMilliseconds);
    private static Result TryParseDateTimeInternal(Byte* buffer, int len, DateTime& dt, DateTimeOffset& dto, bool properlyParseThreeDigitsMilliseconds);
    private static bool TryParseNumber(Byte* ptr, int size, Int32& val);
    private static bool TryParseNumber(Char* ptr, int size, Int32& val);
    private static bool TryParseNumber2(Byte* ptr, int offset, Int32& val);
    private static bool TryParseNumber2(Char* ptr, int offset, Int32& val);
    private static bool TryParseNumber3(Byte* ptr, int offset, Int32& val);
    private static bool TryParseNumber3(Char* ptr, int offset, Int32& val);
    private static bool TryParseNumber4(Byte* ptr, int offset, Int32& val);
    private static bool TryParseNumber4(Char* ptr, int offset, Int32& val);
}
[DefaultMemberAttribute("Item")]
public class Sparrow.Json.LazyStringValue : object {
    internal JsonOperationContext _context;
    private string _string;
    private Byte* _buffer;
    private int _size;
    private int _length;
    [ThreadStaticAttribute]
private static Char[] _lazyStringTempBuffer;
    [ThreadStaticAttribute]
private static Byte[] _lazyStringTempComparisonBuffer;
    public Int32[] EscapePositions;
    public AllocatedMemoryData AllocatedMemoryData;
    private Nullable`1<int> _hashCode;
    public bool IsDisposed;
    private string MaterializeStringValue { get; }
    public byte Item { get; }
    public Byte* Buffer { get; }
    public int Size { get; }
    public int Length { get; }
    public bool HasStringValue { get; }
    public LazyStringValue(string str, Byte* buffer, int size, JsonOperationContext context);
    private static LazyStringValue();
    private string get_MaterializeStringValue();
    public byte get_Item(int index);
    public Byte* get_Buffer();
    public int get_Size();
    public int get_Length();
    public bool EqualsOrdinalIgnoreCase(LazyStringValue other);
    public static int CompareToOrdinalIgnoreCase(Byte* strA, int strALen, Byte* strB, int strBLen);
    public Span`1<byte> AsSpan();
    public ReadOnlySpan`1<byte> AsReadOnlySpan();
    public void CopyTo(Byte* dest);
    public LazyStringValue Clone(JsonOperationContext context);
    public LazyStringValue CloneOnSameContext();
    public bool get_HasStringValue();
    public static void CleanBuffers();
    public sealed virtual bool Equals(string other);
    public sealed virtual bool Equals(LazyStringValue other);
    public sealed virtual int CompareTo(string other);
    public sealed virtual int CompareTo(LazyStringValue other);
    public int Compare(Byte* other, int otherSize);
    public static bool op_Inequality(LazyStringValue self, LazyStringValue str);
    public static bool op_Inequality(LazyStringValue self, string str);
    public static bool op_Equality(LazyStringValue self, string str);
    public static bool op_Equality(LazyStringValue self, LazyStringValue str);
    public static string op_Implicit(LazyStringValue self);
    public static Byte[] op_Implicit(LazyStringValue self);
    public static short op_Explicit(LazyStringValue self);
    public static int op_Explicit(LazyStringValue self);
    public static long op_Explicit(LazyStringValue self);
    public static decimal op_Explicit(LazyStringValue self);
    public static double op_Explicit(LazyStringValue self);
    public static float op_Explicit(LazyStringValue self);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<char> GetEnumerator();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual int CompareTo(object obj);
    private void ThrowAlreadyDisposed();
    public sealed virtual void Dispose();
    private void ReturnAllocatedMemory();
    public bool Contains(char value);
    public bool Contains(char value, StringComparison comparisonType);
    public bool Contains(string value);
    public bool Contains(string value, StringComparison comparisonType);
    public bool EndsWith(string value);
    public bool EndsWith(LazyStringValue value);
    public bool EndsWith(string value, StringComparison comparisonType);
    public bool EndsWith(string value, bool ignoreCase, CultureInfo culture);
    public bool EndsWith(char value);
    public int IndexOf(char value);
    public int IndexOf(char value, StringComparison comparisonType);
    public int IndexOf(char value, int startIndex);
    private void ValidateIndexes(int startIndex, int count);
    public int IndexOf(char value, int startIndex, int count);
    public int IndexOf(string value);
    public int IndexOf(string value, int startIndex);
    public int IndexOf(string value, int startIndex, int count);
    public int IndexOf(string value, int startIndex, StringComparison comparisonType);
    public int IndexOf(string value, int startIndex, int count, StringComparison comparisonType);
    public int IndexOf(string value, StringComparison comparisonType);
    public int IndexOfAny(Char[] anyOf);
    public int IndexOfAny(Char[] anyOf, int startIndex);
    public int IndexOfAny(Char[] anyOf, int startIndex, int count);
    public string Insert(int startIndex, string value);
    public int LastIndexOf(char value);
    public int LastIndexOf(char value, int startIndex);
    public int LastIndexOf(char value, int startIndex, int count);
    public int LastIndexOf(string value);
    public int LastIndexOf(string value, StringComparison comparisonType);
    public int LastIndexOf(string value, int startIndex);
    public int LastIndexOf(string value, int startIndex, int count);
    public int LastIndexOf(string value, int startIndex, StringComparison comparisonType);
    public int LastIndexOf(string value, int startIndex, int count, StringComparison comparisonType);
    public int LastIndexOfAny(Char[] anyOf);
    public int LastIndexOfAny(Char[] anyOf, int startIndex);
    public int LastIndexOfAny(Char[] anyOf, int startIndex, int count);
    public string PadLeft(int totalWidth);
    public string PadLeft(int totalWidth, char paddingChar);
    public string PadRight(int totalWidth);
    public string PadRight(int totalWidth, char paddingChar);
    public string Remove(int startIndex);
    public string Remove(int startIndex, int count);
    public string Replace(char oldChar, char newChar);
    public string Replace(string oldValue, string newValue);
    public string Replace(string oldValue, string newValue, bool ignoreCase, CultureInfo culture);
    public string Replace(string oldValue, string newValue, StringComparison comparisonType);
    public string Substring(int startIndex);
    public string Substring(int startIndex, int length);
    public string Normalize();
    public string Normalize(NormalizationForm normalizationForm);
    public bool IsNormalized();
    public bool IsNormalized(NormalizationForm normalizationForm);
    public String[] Split(char separator, StringSplitOptions options);
    public String[] Split(char separator, int count, StringSplitOptions options);
    public String[] Split(string separator, StringSplitOptions options);
    public String[] Split(string separator, int count, StringSplitOptions options);
    public String[] Split(Char[] separator);
    public String[] Split(Char[] separator, int count);
    public String[] Split(Char[] separator, StringSplitOptions options);
    public String[] Split(Char[] separator, int count, StringSplitOptions options);
    public String[] Split(String[] separator, StringSplitOptions options);
    public String[] Split(String[] separator, int count, StringSplitOptions options);
    public bool StartsWith(string value);
    public bool StartsWith(LazyStringValue value);
    public bool StartsWith(ReadOnlySpan`1<byte> value);
    public bool StartsWith(string value, StringComparison comparisionType);
    public bool StartsWith(string value, bool ignoreCase, CultureInfo culture);
    public bool StartsWith(char value);
    public Char[] ToArray();
    public Char[] ToCharArray();
    public Char[] ToCharArray(int startIndex, int length);
    public string ToLower();
    public string ToLower(CultureInfo culture);
    public string ToLowerInvariant();
    public string ToUpper();
    public string ToUpper(CultureInfo culture);
    public string ToUpperInvariant();
    public string Trim();
    public string Trim(char trimChar);
    public string Trim(Char[] trimChars);
    public string TrimEnd();
    public string TrimEnd(char trimChar);
    public string TrimEnd(Char[] trimChars);
    public string TrimStart();
    public string TrimStart(char trimChar);
    public string TrimStart(Char[] trimChars);
    public string Reverse();
    private string GetReversedStringFromBuffer(Byte* buffer);
    public void Reset();
    public void Renew(string str, Byte* buffer, int size, JsonOperationContext context);
    public bool IsControlCodeCharacter(Byte& b);
    public sealed virtual TypeCode GetTypeCode();
    public sealed virtual bool ToBoolean(IFormatProvider provider);
    public sealed virtual byte ToByte(IFormatProvider provider);
    public sealed virtual char ToChar(IFormatProvider provider);
    public sealed virtual DateTime ToDateTime(IFormatProvider provider);
    public sealed virtual decimal ToDecimal(IFormatProvider provider);
    public sealed virtual double ToDouble(IFormatProvider provider);
    public sealed virtual short ToInt16(IFormatProvider provider);
    public sealed virtual int ToInt32(IFormatProvider provider);
    public sealed virtual long ToInt64(IFormatProvider provider);
    public sealed virtual sbyte ToSByte(IFormatProvider provider);
    public sealed virtual float ToSingle(IFormatProvider provider);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual object ToType(Type conversionType, IFormatProvider provider);
    public sealed virtual ushort ToUInt16(IFormatProvider provider);
    public sealed virtual UInt32 ToUInt32(IFormatProvider provider);
    public sealed virtual ulong ToUInt64(IFormatProvider provider);
    public bool StartsWithOrdinalIgnoreCase(LazyStringValue prefix);
    public void Truncate(int size);
}
internal class Sparrow.Json.LazyStringValueComparer : object {
    public static LazyStringValueComparer Instance;
    private static LazyStringValueComparer();
    public sealed virtual bool Equals(LazyStringValue x, LazyStringValue y);
    public sealed virtual int GetHashCode(LazyStringValue obj);
}
internal class Sparrow.Json.LazyStringValueStructComparer : ValueType {
    public sealed virtual bool Equals(LazyStringValue x, LazyStringValue y);
    public sealed virtual int GetHashCode(LazyStringValue obj);
}
public class Sparrow.Json.ManualBlittableJsonDocumentBuilder`1 : AbstractBlittableJsonDocumentBuilder {
    private JsonOperationContext _context;
    private BlittableWriter`1<TWriter> _writer;
    private UsageMode _mode;
    private WriteToken _writeToken;
    private static StringSegment UnderscoreSegment;
    public ManualBlittableJsonDocumentBuilder`1(JsonOperationContext context, Nullable`1<UsageMode> mode, BlittableWriter`1<TWriter> writer);
    private static ManualBlittableJsonDocumentBuilder`1();
    public void StartWriteObjectDocument();
    public void StartArrayDocument();
    public void WritePropertyName(string propertyName);
    public void WritePropertyName(LazyStringValue property);
    public void StartWriteObject();
    public void WriteObjectEnd();
    public void StartWriteArray();
    public void WriteArrayEnd();
    public void WriteValueNull();
    public void WriteValue(BlittableJsonToken token, object value);
    public void WriteValue(bool value);
    public void WriteValue(long value);
    public void WriteValue(float value);
    public void WriteValue(ulong value);
    public void WriteValue(double value);
    public void WriteValue(decimal value);
    public void WriteValue(LazyNumberValue value);
    public void WriteValue(string value);
    public void WriteValue(LazyStringValue value);
    public void WriteValue(LazyCompressedStringValue value);
    public void WriteEmbeddedBlittableDocument(BlittableJsonReaderObject document);
    public void WriteRawBlob(Byte* ptr, int size);
    public void WriteEmbeddedBlittableDocument(Byte* ptr, int size);
    private BuildingState FinishWritingScalarValue(BuildingState currentState);
    public void FinalizeDocument();
    private void ThrowIllegalStateException(ContinuationState state, string realOperation);
    public void Reset(UsageMode mode);
    public BlittableJsonReaderObject CreateReader();
    public BlittableJsonReaderArray CreateArrayReader();
    public virtual void Dispose();
}
public class Sparrow.Json.Parsing.DynamicJsonArray : object {
    public bool SkipOriginalArray;
    public int SourceIndex;
    public int ModificationsIndex;
    public List`1<object> Items;
    public List`1<int> Removals;
    public int Count { get; }
    public DynamicJsonArray(IEnumerable collection);
    public void RemoveAt(int index);
    public void Add(object obj);
    [ConditionalAttribute("DEBUG")]
private static void EnsureNotDocumentInArray(object value);
    public int get_Count();
    public sealed virtual IEnumerator`1<object> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Clear();
    public sealed virtual void Dispose();
}
[DefaultMemberAttribute("Item")]
public class Sparrow.Json.Parsing.DynamicJsonValue : object {
    public static string TypeFieldName;
    public int SourceIndex;
    public InsertionOrderProperties SourceProperties;
    public int ModificationsIndex;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<ValueTuple`2<string, object>> Properties;
    public HashSet`1<int> Removals;
    internal BlittableJsonReaderObject _source;
    public object Item { get; public set; }
    public DynamicJsonValue(Type explicitTypeInfo);
    public DynamicJsonValue(BlittableJsonReaderObject source);
    public void Remove(string property);
    internal void RemoveInMemoryPropertyByName(string property);
    public void set_Item(string name, object value);
    public object get_Item(string name);
    public static DynamicJsonValue Convert(IDictionary`2<string, T> dictionary);
    public static DynamicJsonValue Convert(IDictionary`2<TK, TV> dictionary);
}
public interface Sparrow.Json.Parsing.IDynamicJson {
    public abstract virtual DynamicJsonValue ToJson();
}
public interface Sparrow.Json.Parsing.IJsonParser {
    public abstract virtual bool Read();
    public abstract virtual void ValidateFloat();
    public abstract virtual string GenerateErrorState();
}
public class Sparrow.Json.Parsing.JsonParserState : object {
    public static int EscapePositionItemSize;
    public static int ControlCharacterItemSize;
    public Byte* StringBuffer;
    public int StringSize;
    public Nullable`1<int> CompressedSize;
    public long Long;
    public JsonParserToken CurrentTokenType;
    public JsonParserTokenContinuation Continuation;
    public FastList`1<int> EscapePositions;
    public static void WriteVariableSizeInt(Byte*& dest, int value);
    public static int VariableSizeIntSize(int value);
    public static int FindEscapePositionsMaxSize(string str, Int32& escapedCount);
    public static int FindEscapePositionsMaxSize(ReadOnlySpan`1<char> str, Int32& escapedCount);
    public static int FindEscapePositionsMaxSize(Byte* str, int size, Int32& escapedCount);
    public void FindEscapePositionsIn(Byte* str, Int32& len, int previousComputedMaxSize);
    public static void FindEscapePositionsIn(FastList`1<int> buffer, Byte* str, Int32& len, int previousComputedMaxSize);
    private static void ThrowInvalidSizeForEscapeControlChars(int previousComputedMaxSize);
    public int WriteEscapePositionsTo(Byte* buffer);
    public void Reset();
}
public enum Sparrow.Json.Parsing.JsonParserToken : Enum {
    public int value__;
    public static JsonParserToken None;
    public static JsonParserToken Null;
    public static JsonParserToken False;
    public static JsonParserToken True;
    public static JsonParserToken String;
    public static JsonParserToken Float;
    public static JsonParserToken Integer;
    public static JsonParserToken Separator;
    public static JsonParserToken StartObject;
    public static JsonParserToken StartArray;
    public static JsonParserToken EndArray;
    public static JsonParserToken EndObject;
    public static JsonParserToken Blob;
}
public enum Sparrow.Json.Parsing.JsonParserTokenContinuation : Enum {
    public int value__;
    public static JsonParserTokenContinuation None;
    public static JsonParserTokenContinuation PartialNaN;
    public static JsonParserTokenContinuation PartialPositiveInfinity;
    public static JsonParserTokenContinuation PartialNegativeInfinity;
    public static JsonParserTokenContinuation PartialNull;
    public static JsonParserTokenContinuation PartialTrue;
    public static JsonParserTokenContinuation PartialString;
    public static JsonParserTokenContinuation PartialNumber;
    public static JsonParserTokenContinuation PartialPreamble;
    public static JsonParserTokenContinuation PartialFalse;
    public static JsonParserTokenContinuation PleaseRefillBuffer;
}
public class Sparrow.Json.Parsing.ObjectJsonParser : object {
    private JsonParserState _state;
    private JsonOperationContext _ctx;
    private FastStack`1<object> _elements;
    private bool _disposed;
    private AllocatedMemoryData _currentStateBuffer;
    private HashSet`1<object> _seenValues;
    public ObjectJsonParser(JsonParserState state, JsonOperationContext ctx);
    public void Reset(object root);
    public sealed virtual void Dispose();
    public sealed virtual bool Read();
    private void ReadEscapePositions(Byte* buffer, int escapeSequencePos);
    private void ThrowOnDisposed();
    private void SetStringBuffer(string str);
    private static string EnsureDecimalPlace(double value, string text);
    public sealed virtual void ValidateFloat();
    public sealed virtual string GenerateErrorState();
}
public class Sparrow.Json.Parsing.UnmanagedJsonParser : object {
    private static Byte[] NaN;
    private static Byte[] PositiveInfinity;
    private static Byte[] NegativeInfinity;
    public static Byte[] Utf8Preamble;
    private string _debugTag;
    private UnmanagedWriteBuffer _unmanagedWriteBuffer;
    private int _currentStrStart;
    private JsonOperationContext _ctx;
    private JsonParserState _state;
    private UInt32 _pos;
    private UInt32 _bufSize;
    private int _line;
    private UInt32 _charPos;
    private Byte* _inputBuffer;
    private int _prevEscapePosition;
    private byte _currentQuote;
    private Byte[] _expectedTokenBuffer;
    private int _expectedTokenBufferPosition;
    private string _expectedTokenString;
    private bool _zeroPrefix;
    private bool _isNegative;
    private bool _isFractionedDouble;
    private bool _isOverflow;
    private bool _isExponent;
    private bool _escapeMode;
    private bool _maybeBeforePreamble;
    private static ParseNumberAction[] ParseNumberTable;
    private static byte Unlikely;
    private static Byte[] ParseStringTable;
    private bool _parsingUnicode;
    private int _unicodeValue;
    private int _unicodeIndex;
    public int BufferSize { get; }
    public int BufferOffset { get; }
    private static UnmanagedJsonParser();
    public UnmanagedJsonParser(JsonOperationContext ctx, JsonParserState state, string debugTag);
    public void SetBuffer(MemoryBuffer inputBuffer);
    public void SetBuffer(MemoryBuffer inputBuffer, int offset, int size);
    public void SetBuffer(Byte* inputBuffer, int size);
    public int get_BufferSize();
    public int get_BufferOffset();
    public void NewDocument();
    public void CopyParsedChunk(Stream dest, int from);
    public ValueTuple`2<bool, int> Copy(Byte* output, int count);
    public ValueTuple`2<bool, int> Copy(Stream dest, int count);
    public ValueTuple`2<bool, int> Skip(int count);
    public sealed virtual bool Read();
    private static bool IsPossibleNegativeNumber(byte b, UInt32 bufferSize, UInt32 pos, Byte* currentBuffer);
    private bool ReadUnlikely(byte b, UInt32& pos, Boolean& couldRead);
    private void ReadToken(UInt32& pos, Boolean& couldRead, Byte[] tokenBuffer, string tokenString, JsonParserTokenContinuation jsonParserTokenContinuation);
    private void ThrowCannotHaveCharInThisPosition(byte b);
    private bool ReadMaybeBeforePreamble();
    private bool ContinueParsingValue();
    private bool ParseNumber(Int64& value, UInt32& pos);
    private bool ParseNumberUnlikely(byte b, UInt32& pos, Int64& value, JsonParserState state);
    private void ThrowWhenMalformed(string message);
    private bool EnsureRestOfToken(UInt32& pos);
    private bool ParseString(UInt32& currentPos);
    private static void ThrowInvalidEscapeChar(byte b);
    private bool ParseUnicodeValue(UInt32& pos);
    private void WriteUnicodeCharacterToStringBuffer(int val);
    public sealed virtual void ValidateFloat();
    private void ThrowException(string message, Exception inner);
    public sealed virtual void Dispose();
    public sealed virtual string GenerateErrorState();
    [CompilerGeneratedAttribute]
internal static bool <ValidateFloat>g__IsInfinity|62_0(Byte* buffer, int offset);
}
public static class Sparrow.Json.Parsing.UnmanagedJsonParserHelper : object {
    public static string ReadString(JsonOperationContext context, PeepingTomStream peepingTomStream, UnmanagedJsonParser parser, JsonParserState state, MemoryBuffer buffer);
    public static bool Read(PeepingTomStream stream, UnmanagedJsonParser parser, JsonParserState state, MemoryBuffer buffer);
    [AsyncStateMachineAttribute("Sparrow.Json.Parsing.UnmanagedJsonParserHelper/<ReadAsync>d__2")]
public static Task`1<bool> ReadAsync(PeepingTomStream peepingTomStream, UnmanagedJsonParser parser, JsonParserState state, MemoryBuffer buffer, CancellationToken token);
    public static void ThrowInvalidJson(string msg, PeepingTomStream peepingTomStream, UnmanagedJsonParser parser);
    public static void ThrowInvalidJson(PeepingTomStream peepingTomStream);
    public static void ThrowInvalidJsonResponse(PeepingTomStream peepingTomStream);
    private static string GetPeepingTomBufferAsString(PeepingTomStream peepingTomStream);
    public static void ReadObject(BlittableJsonDocumentBuilder builder, PeepingTomStream peepingTomStream, UnmanagedJsonParser parser, MemoryBuffer buffer);
    public static void ReadProperty(BlittableJsonDocumentBuilder builder, PeepingTomStream peepingTomStream, UnmanagedJsonParser parser, MemoryBuffer buffer);
    [AsyncStateMachineAttribute("Sparrow.Json.Parsing.UnmanagedJsonParserHelper/<ReadPropertyAsync>d__9")]
public static Task ReadPropertyAsync(BlittableJsonDocumentBuilder builder, PeepingTomStream peepingTomStream, UnmanagedJsonParser parser, MemoryBuffer buffer, CancellationToken token);
    public static long ReadLong(JsonOperationContext context, PeepingTomStream peepingTomStream, UnmanagedJsonParser parser, JsonParserState state, MemoryBuffer buffer);
    [AsyncStateMachineAttribute("Sparrow.Json.Parsing.UnmanagedJsonParserHelper/<ReadJsonArrayAsync>d__11")]
public static ValueTask`1<BlittableJsonReaderArray> ReadJsonArrayAsync(BlittableJsonDocumentBuilder builder, PeepingTomStream peepingTomStream, UnmanagedJsonParser parser, MemoryBuffer buffer, CancellationToken token);
    [AsyncStateMachineAttribute("Sparrow.Json.Parsing.UnmanagedJsonParserHelper/<ReadObjectAsync>d__12")]
public static Task ReadObjectAsync(BlittableJsonDocumentBuilder builder, PeepingTomStream peepingTomStream, UnmanagedJsonParser parser, MemoryBuffer buffer, CancellationToken token);
    [IteratorStateMachineAttribute("Sparrow.Json.Parsing.UnmanagedJsonParserHelper/<ReadArrayToMemory>d__13")]
public static IEnumerable`1<BlittableJsonReaderObject> ReadArrayToMemory(JsonOperationContext context, PeepingTomStream peepingTomStream, UnmanagedJsonParser parser, JsonParserState state, MemoryBuffer buffer);
    [AsyncIteratorStateMachineAttribute("Sparrow.Json.Parsing.UnmanagedJsonParserHelper/<ReadArrayToMemoryAsync>d__14")]
public static IAsyncEnumerable`1<BlittableJsonReaderObject> ReadArrayToMemoryAsync(JsonOperationContext context, PeepingTomStream peepingTomStream, UnmanagedJsonParser parser, JsonParserState state, MemoryBuffer buffer);
}
internal class Sparrow.Json.PathCache : object {
    private int _used;
    private PathCacheHolder[] _items;
    public void AcquirePathCache(Dictionary`2& pathCache, Dictionary`2& pathCacheByIndex);
    public void ReleasePathCache(Dictionary`2<StringSegment, object> pathCache, Dictionary`2<int, object> pathCacheByIndex);
    public void ClearUnreturnedPathCache();
}
internal class Sparrow.Json.PerCoreContainer`1 : object {
    private T[][] _perCoreArrays;
    public PerCoreContainer`1(int numberOfSlotsPerCore);
    public bool TryPull(T& output);
    public bool TryPush(T cur);
    [IteratorStateMachineAttribute("Sparrow.Json.PerCoreContainer`1/<EnumerateAndClear>d__4")]
public IEnumerable`1<T> EnumerateAndClear();
    [IteratorStateMachineAttribute("Sparrow.Json.PerCoreContainer`1/<GetEnumerator>d__5")]
public sealed virtual IEnumerator`1<ValueTuple`2<T, ValueTuple`2<int, int>>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool Remove(T item, ValueTuple`2<int, int> pos);
}
internal class Sparrow.Json.Sync.BlittableJsonTextWriter : AbstractBlittableJsonTextWriter {
    public BlittableJsonTextWriter(JsonOperationContext context, Stream stream);
    public sealed virtual void Dispose();
    public void Flush();
}
public class Sparrow.Json.UnmanagedBuffersPool : object {
    protected string _debugTag;
    protected string _databaseName;
    private static Logger _log;
    private ConcurrentStack`1[] _freeSegments;
    private bool _isDisposed;
    public UnmanagedBuffersPool(string debugTag, string databaseName);
    private static UnmanagedBuffersPool();
    public void LowMemory(LowMemorySeverity lowMemorySeverity);
    private long FreeAllPooledMemory();
    public void LowMemoryOver();
    public long GetAllocatedMemorySize();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public AllocatedMemoryData Allocate(int size);
    private static int GetIndexSize(Int32& index, int powerBy2Size);
    public static int GetIndexFromSize(int size);
    public void Return(AllocatedMemoryData returned);
}
internal class Sparrow.Json.UnmanagedMemoryManager : MemoryManager`1<byte> {
    private Byte* _address;
    private int _length;
    public Memory`1<byte> Memory { get; }
    public UnmanagedMemoryManager(Byte* pointer, int length);
    public virtual Memory`1<byte> get_Memory();
    public virtual Span`1<byte> GetSpan();
    public virtual MemoryHandle Pin(int elementIndex);
    public virtual void Unpin();
    protected virtual void Dispose(bool disposing);
}
internal class Sparrow.Json.UnmanagedStreamBuffer : ValueType {
    private Stream _stream;
    private int _sizeInBytes;
    public int Used;
    private MemoryBuffer _buffer;
    private ReturnBuffer _returnBuffer;
    public int SizeInBytes { get; }
    public UnmanagedStreamBuffer(JsonOperationContext context, Stream stream);
    public sealed virtual int get_SizeInBytes();
    public sealed virtual void Write(Byte[] buffer, int start, int count);
    public sealed virtual void Write(Byte* buffer, int count);
    private void UnlikelyWrite(Byte* buffer, int count);
    public sealed virtual void WriteByte(byte data);
    public int CopyTo(IntPtr pointer);
    public int CopyTo(Byte* pointer);
    public sealed virtual void Dispose();
    public sealed virtual void EnsureSingleChunk(JsonParserState state);
    public sealed virtual void EnsureSingleChunk(Byte*& ptr, Int32& size);
}
public class Sparrow.Json.UnmanagedWriteBuffer : ValueType {
    private JsonOperationContext _context;
    private Segment _head;
    public int SizeInBytes { get; }
    public bool IsDisposed { get; }
    public UnmanagedWriteBuffer(JsonOperationContext context, AllocatedMemoryData allocatedMemoryData);
    public sealed virtual int get_SizeInBytes();
    public bool get_IsDisposed();
    public sealed virtual void Write(Byte[] buffer, int start, int count);
    private void ThrowOnDisposed();
    public sealed virtual void Write(Byte* buffer, int count);
    private void WriteUnlikely(Byte* buffer, int count);
    private void AllocateNextSegment(int required, bool allowGrowth);
    private static void ThrowOnAllocationSizeExceeded(int required, int maxSizeInBytes);
    private static void ThrowOnAllocationSizeMismatch(int allocationSizeInBytes, int required);
    public sealed virtual void WriteByte(byte data);
    private void WriteByteUnlikely(byte data);
    public int CopyTo(Byte* pointer);
    [ConditionalAttribute("DEBUG")]
private static void ThrowOnCopiedBytesMismatch(int copiedBytes, int accumulatedSizeInBytes);
    public void Clear();
    public sealed virtual void Dispose();
    public sealed virtual void EnsureSingleChunk(JsonParserState state);
    public sealed virtual void EnsureSingleChunk(Byte*& ptr, Int32& size);
    private void UnlikelyEnsureSingleChunk(Byte*& ptr, Int32& size);
}
internal class Sparrow.ListResetBehavior`1 : ValueType {
    private sealed virtual override void Sparrow.IResetSupport<System.Collections.Generic.List<T1>>.Reset(List`1<T1> value);
}
public class Sparrow.Logging.LogEntry : ValueType {
    public DateTime At;
    public LogMode Type;
    public string Source;
    public string Logger;
    public string Message;
    public Exception Exception;
}
public class Sparrow.Logging.Logger : object {
    private LoggingSource _parent;
    private string _source;
    private string _logger;
    [ThreadStaticAttribute]
private static LogEntry _logEntry;
    public bool IsInfoEnabled { get; }
    public bool IsOperationsEnabled { get; }
    public Logger(LoggingSource parent, string source, string logger);
    public void Info(FormattableString msg, Exception e);
    public void Operations(FormattableString msg, Exception e);
    public void Info(string msg, Exception ex);
    public Task InfoWithWait(string msg, Exception ex);
    public void Operations(string msg, Exception ex);
    public Task OperationsWithWait(string msg, Exception ex);
    public bool get_IsInfoEnabled();
    public bool get_IsOperationsEnabled();
    private static DateTime GetLogDate();
}
internal class Sparrow.Logging.LoggingFilter : object {
    private Dictionary`2<LogEntryFields, List`1<Filter>> _rules;
    public string Add(string rule, bool matchIsValid);
    public string Delete(string rule);
    public string List();
    public string GetHelp();
    public bool IsValid(string val, List`1<string> rules);
    private string GetField(LogEntryFields field, LogEntry& entry);
    public bool Forward(LogEntry& entry);
    public string ParseInput(string input);
}
public class Sparrow.Logging.LoggingSource : object {
    [ThreadStaticAttribute]
private static string _currentThreadId;
    public static bool UseUtcTime;
    public long MaxFileSizeInBytes;
    private static string DateTimeWithMinutesFormat;
    private static string DateOnlyFormat;
    internal static string LogExtension;
    internal static string AdditionalCompressExtension;
    internal static string FullCompressExtension;
    internal static long LocalToUtcOffsetInTicks;
    private ManualResetEventSlim _hasEntries;
    private ManualResetEventSlim _readyToCompress;
    private LightWeightThreadLocal`1<LocalThreadWriterState> _localState;
    private LimitedConcurrentSet`1[] _freePooledMessageEntries;
    private LimitedConcurrentSet`1[] _activePoolMessageEntries;
    private Thread _loggingThread;
    private Thread _compressLoggingThread;
    private int _generation;
    private bool _updateLocalTimeOffset;
    private string _path;
    private string _name;
    private string _dateString;
    private MultipleUseFlag _keepLogging;
    private int _logNumber;
    private DateTime _today;
    private bool _isInfoEnabled;
    private bool _isOperationsEnabled;
    private Stream _additionalOutput;
    private Stream _pipeSink;
    private static int TimeToWaitForLoggingToEndInMilliseconds;
    public static LoggingSource Instance;
    public static LoggingSource AuditLog;
    private static Byte[] _headerRow;
    private ConcurrentDictionary`2<WebSocket, WebSocketContext> _listeners;
    [CompilerGeneratedAttribute]
private LogMode <LogMode>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RetentionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RetentionSize>k__BackingField;
    private static IComparer`1<string> Comparer;
    private Task[] _tasks;
    public bool IsInfoEnabled { get; }
    public bool IsOperationsEnabled { get; }
    public LogMode LogMode { get; private set; }
    public TimeSpan RetentionTime { get; private set; }
    public long RetentionSize { get; private set; }
    public bool Compressing { get; }
    private static LoggingSource();
    public LoggingSource(LogMode logMode, string path, string name, TimeSpan retentionTime, long retentionSize, bool compress);
    public bool get_IsInfoEnabled();
    public bool get_IsOperationsEnabled();
    [CompilerGeneratedAttribute]
public LogMode get_LogMode();
    [CompilerGeneratedAttribute]
private void set_LogMode(LogMode value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RetentionTime();
    [CompilerGeneratedAttribute]
private void set_RetentionTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public long get_RetentionSize();
    [CompilerGeneratedAttribute]
private void set_RetentionSize(long value);
    public bool get_Compressing();
    private ValueTuple`2<bool, bool> CalculateIsLogEnabled(Nullable`1<LogMode> logMode);
    [AsyncStateMachineAttribute("Sparrow.Logging.LoggingSource/<Register>d__54")]
internal Task Register(WebSocket source, WebSocketContext context, CancellationToken token);
    private void AssertLogging();
    public void SetupLogMode(LogMode logMode, string path, Nullable`1<TimeSpan> retentionTime, Nullable`1<long> retentionSize, bool compress);
    public void SetupLogMode(LogMode logMode, string path, TimeSpan retentionTime, long retentionSize, bool compress);
    private void StartNewLoggingThreads(bool compress);
    public void EndLogging();
    private bool TryGetNewStreamAndApplyRetentionPolicies(long maxFileSize, FileStream& fileStream);
    private ValueTuple`2<string, long> GetFileInfoSafe(string fileName);
    internal static bool TryGetLastWriteTimeUtc(string filePath, DateTime& dateTimeUtc);
    internal static bool TryGetLastWriteTimeLocal(string filePath, DateTime& dateTimeLocal);
    internal static bool TryGetCreationTimeUtc(string filePath, DateTime& dateTimeUtc);
    internal static bool TryGetCreationTimeLocal(string filePath, DateTime& dateTimeLocal);
    private static bool TryGetFileTimeInternal(string filePath, Func`2<string, DateTime> fileTimeGetter, DateTime& dateTime);
    internal static DateTime GetLogFileCreationTime(string filePathOrName, DateTimeKind timeKind);
    internal static bool TryGetLogFileNumber(string filePathOrName, Int32& n);
    internal static string DateToLogFormat(DateTime dateTime);
    private void UpdateLocalDateTimeOffset();
    private static ValueTuple`2<int, string> GetLastLogNumberAndDateStringForToday(IEnumerable`1<string> allLogFiles);
    private void ApplyRetentionRulesToLogs(String[] logFiles);
    private String[] CleanupOldLogFiles(String[] logFiles);
    private void LimitTotalLogSize(String[] logFiles);
    private static void CleanupAlreadyCompressedLogFiles(String[] sortedLogFiles, String[] sortedLogGzFiles);
    private LocalThreadWriterState GenerateThreadWriterState();
    public void Log(LogEntry& entry, TaskCompletionSource`1<object> tcs);
    private void WriteEntryToWriter(StreamWriter writer, LogEntry& entry);
    public Logger GetLogger(string source);
    public Logger GetLogger(string source, string logger);
    private void BackgroundLogger();
    private void DisableLogsFor(TimeSpan timeout);
    private static bool IsOutOfDiskSpaceException(IOException ioe);
    private void BackgroundLoggerCompress();
    public void AttachPipeSink(Stream stream);
    public void DetachPipeSink();
    private int ActualWriteToLogTargets(LogMessageEntry item, Stream file);
    private void SendToWebSockets(LogMessageEntry item, ArraySegment`1<byte> bytes);
    private void RemoveWebSocket(WebSocket socket, string cause);
    public void EnableConsoleLogging();
    public void DisableConsoleLogging();
}
internal class Sparrow.Logging.LogMessageEntry : object {
    public LogMode Type;
    public MemoryStream Data;
    public TaskCompletionSource`1<object> Task;
    public List`1<WebSocket> WebSocketsList;
    public virtual string ToString();
}
[FlagsAttribute]
public enum Sparrow.Logging.LogMode : Enum {
    public int value__;
    public static LogMode None;
    public static LogMode Operations;
    public static LogMode Information;
}
internal abstract class Sparrow.LowMemory.AbstractLowMemoryMonitor : object {
    public abstract virtual MemoryInfoResult GetMemoryInfoOnce();
    public abstract virtual MemoryInfoResult GetMemoryInfo(bool extended);
    public abstract virtual bool IsEarlyOutOfMemory(MemoryInfoResult memInfo, Size& commitChargeThreshold);
    public abstract virtual DirtyMemoryState GetDirtyMemoryState();
    public abstract virtual void AssertNotAboutToRunOutOfMemory();
    internal static long GetManagedMemoryInBytes();
    internal static long GetUnmanagedAllocationsInBytes();
    public abstract virtual void Dispose();
}
internal class Sparrow.LowMemory.DirtyMemoryState : object {
    public bool IsHighDirty;
    public Size TotalDirty;
}
public class Sparrow.LowMemory.HighDirtyMemoryException : Exception {
    public HighDirtyMemoryException(string message);
    public HighDirtyMemoryException(string message, Exception inner);
}
public interface Sparrow.LowMemory.ILowMemoryHandler {
    public abstract virtual void LowMemory(LowMemorySeverity lowMemorySeverity);
    public abstract virtual void LowMemoryOver();
}
public class Sparrow.LowMemory.LowMemoryException : Exception {
    public LowMemoryException(string message);
    public LowMemoryException(string message, Exception inner);
}
internal class Sparrow.LowMemory.LowMemoryNotification : object {
    private static string NotificationThreadName;
    private Logger _logger;
    private ConcurrentSet`1<WeakReference`1<ILowMemoryHandler>> _lowMemoryHandlers;
    internal LowMemEventDetails[] LowMemEventDetailsStack;
    private int _lowMemEventDetailsIndex;
    private int _clearInactiveHandlersCounter;
    private bool _wasLowMemory;
    private DateTime _lastLoggedLowMemory;
    private TimeSpan _logLowMemoryInterval;
    private TimeSpan _lohCompactionInterval;
    private DateTime _lastLohCompactionRequest;
    [CompilerGeneratedAttribute]
private bool <SupportsCompactionOfLargeObjectHeap>k__BackingField;
    public static LowMemoryNotification Instance;
    [CompilerGeneratedAttribute]
private bool <LowMemoryState>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEarlyOutOfMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirtyMemoryState <DirtyMemoryState>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <LowMemoryThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <ExtremelyLowMemoryThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseTotalDirtyMemInsteadOfMemUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private float <TemporaryDirtyMemoryAllowedPercentage>k__BackingField;
    [CompilerGeneratedAttribute]
private float <LargeObjectHeapCompactionThresholdPercentage>k__BackingField;
    private ManualResetEvent _simulatedLowMemory;
    private ManualResetEvent _shutdownRequested;
    private List`1<WeakReference`1<ILowMemoryHandler>> _inactiveHandlers;
    private AbstractLowMemoryMonitor _lowMemoryMonitor;
    private bool _initialized;
    private bool _enableHighTemporaryDirtyMemoryUse;
    private CancellationTokenRegistration _cancellationTokenRegistration;
    internal bool SupportsCompactionOfLargeObjectHeap { get; internal set; }
    public bool LowMemoryState { get; private set; }
    public bool IsEarlyOutOfMemory { get; private set; }
    public DirtyMemoryState DirtyMemoryState { get; private set; }
    public Size LowMemoryThreshold { get; private set; }
    public Size ExtremelyLowMemoryThreshold { get; private set; }
    public bool UseTotalDirtyMemInsteadOfMemUsage { get; private set; }
    public float TemporaryDirtyMemoryAllowedPercentage { get; private set; }
    public float LargeObjectHeapCompactionThresholdPercentage { get; private set; }
    private static LowMemoryNotification();
    private void RunLowMemoryHandlers(bool isLowMemory, MemoryInfoResult memoryInfo, LowMemorySeverity lowMemorySeverity);
    [CompilerGeneratedAttribute]
internal bool get_SupportsCompactionOfLargeObjectHeap();
    [CompilerGeneratedAttribute]
internal void set_SupportsCompactionOfLargeObjectHeap(bool value);
    private void RequestLohCompactionIfNeeded(MemoryInfoResult memoryInfo, DateTime now);
    private void ClearInactiveHandlers();
    public void RegisterLowMemoryHandler(ILowMemoryHandler handler);
    [CompilerGeneratedAttribute]
public bool get_LowMemoryState();
    [CompilerGeneratedAttribute]
private void set_LowMemoryState(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsEarlyOutOfMemory();
    [CompilerGeneratedAttribute]
private void set_IsEarlyOutOfMemory(bool value);
    [CompilerGeneratedAttribute]
public DirtyMemoryState get_DirtyMemoryState();
    [CompilerGeneratedAttribute]
private void set_DirtyMemoryState(DirtyMemoryState value);
    [CompilerGeneratedAttribute]
public Size get_LowMemoryThreshold();
    [CompilerGeneratedAttribute]
private void set_LowMemoryThreshold(Size value);
    [CompilerGeneratedAttribute]
public Size get_ExtremelyLowMemoryThreshold();
    [CompilerGeneratedAttribute]
private void set_ExtremelyLowMemoryThreshold(Size value);
    [CompilerGeneratedAttribute]
public bool get_UseTotalDirtyMemInsteadOfMemUsage();
    [CompilerGeneratedAttribute]
private void set_UseTotalDirtyMemInsteadOfMemUsage(bool value);
    [CompilerGeneratedAttribute]
public float get_TemporaryDirtyMemoryAllowedPercentage();
    [CompilerGeneratedAttribute]
private void set_TemporaryDirtyMemoryAllowedPercentage(float value);
    [CompilerGeneratedAttribute]
public float get_LargeObjectHeapCompactionThresholdPercentage();
    [CompilerGeneratedAttribute]
private void set_LargeObjectHeapCompactionThresholdPercentage(float value);
    public void Initialize(Size lowMemoryThreshold, bool useTotalDirtyMemInsteadOfMemUsage, bool enableHighTemporaryDirtyMemoryUse, float temporaryDirtyMemoryAllowedPercentage, float largeObjectHeapCompactionThresholdPercentage, AbstractLowMemoryMonitor monitor, CancellationToken shutdownNotification);
    private void MonitorMemoryUsage();
    private void SimulateLowMemory();
    internal int CheckMemoryStatus(AbstractLowMemoryMonitor monitor);
    private LowMemorySeverity GetLowMemory(MemoryInfoResult& memoryInfo, AbstractLowMemoryMonitor monitor);
    internal LowMemorySeverity IsLowMemory(MemoryInfoResult memInfo, AbstractLowMemoryMonitor monitor, Size& commitChargeThreshold);
    private LowMemorySeverity IsAvailableMemoryBelowThreshold(MemoryInfoResult memInfo);
    private void AddLowMemEvent(LowMemReason reason, MemoryInfoResult memoryInfo, long totalUnmanaged);
    public void SimulateLowMemoryNotification();
    internal static void AssertNotAboutToRunOutOfMemory();
    [CompilerGeneratedAttribute]
private void <ClearInactiveHandlers>b__19_0(WeakReference`1<ILowMemoryHandler> x);
    [CompilerGeneratedAttribute]
private void <Initialize>b__54_0();
}
public enum Sparrow.LowMemory.LowMemorySeverity : Enum {
    public int value__;
    public static LowMemorySeverity None;
    public static LowMemorySeverity Low;
    public static LowMemorySeverity ExtremelyLow;
}
public class Sparrow.LowMemory.MemoryInfoResult : ValueType {
    public string Remarks;
    public Size TotalCommittableMemory;
    public Size CurrentCommitCharge;
    public Size TotalPhysicalMemory;
    public Size InstalledMemory;
    public Size WorkingSet;
    public Size AvailableMemory;
    public Size AvailableMemoryForProcessing;
    public Size SharedCleanMemory;
    public Size TotalSwapSize;
    public Size TotalSwapUsage;
    public Size WorkingSetSwapUsage;
    public bool IsExtended;
}
public static class Sparrow.Memory : object {
    private static int CompareInlineVsCallThreshold;
    private static ReadOnlySpan`1<byte> LoadMaskTable { get; }
    private static ReadOnlySpan`1<byte> get_LoadMaskTable();
    internal static int CompareAvx256(Void* p1, Void* p2, int size);
    internal static int CompareAvx256(Byte& p1, Byte& p2, int size);
    internal static int CompareSmallInlineNet7(Byte& p1, Byte& p2, int size);
    internal static bool IsEqualConstantAvx256(Byte& constantRef, Byte* ptr, int size);
    internal static bool IsEqualConstantVector128(Byte& constantRef, Byte* ptr, int size);
    [SecurityCriticalAttribute]
private static int Compare_posix(Byte* b1, Byte* b2, long count);
    [SecurityCriticalAttribute]
private static int Compare_windows(Byte* b1, Byte* b2, long count);
    internal static int CompareInlineNet6OorLesser(Void* p1, Void* p2, int size);
    public static int Compare(Void* p1, Void* p2, int size);
    public static int CompareInline(Void* p1, Void* p2, int size);
    public static int CompareInline(Byte& p1, Byte& p2, int size);
    public static int CompareInline(ReadOnlySpan`1<byte> p1, ReadOnlySpan`1<byte> p2, int size);
    public static void Copy(Void* dest, Void* src, UInt32 n);
    public static void Copy(Void* dest, Void* src, long n);
    private static void CopyLong(Void* dest, Void* src, long n);
    public static void Set(Byte* dest, byte value, UInt32 n);
    public static void Set(Byte* dest, byte value, long n);
    private static void SetLong(Byte* dest, byte value, long n);
    public static void Move(Byte* dest, Byte* src, int n);
    public static void CopyUnaligned(Byte* dest, Byte* src, UInt32 n);
    public static TTo As(TFrom& value);
    public static T Read(Byte* ptr);
    public static bool IsEqualConstant(ReadOnlySpan`1<byte> constant, Byte* ptr);
    public static bool IsEqualConstant(Byte* constant, int size, Byte* ptr);
    public static bool IsEqualConstant(ReadOnlySpan`1<byte> constant, Byte* ptr, int size);
}
internal class Sparrow.NoResetSupport`1 : ValueType {
    public sealed virtual void Reset(T value);
}
[IsReadOnlyAttribute]
internal class Sparrow.NumericDescendingComparer : ValueType {
    public sealed virtual int Compare(long x, long y);
    public sealed virtual int Compare(int x, int y);
    public sealed virtual int Compare(float x, float y);
    public sealed virtual int Compare(double x, double y);
    public sealed virtual int Compare(ulong x, ulong y);
    public sealed virtual int Compare(UInt32 x, UInt32 y);
}
internal class Sparrow.ObjectPool`1 : ObjectPool`2<T, NoResetSupport`1<T>> {
    public ObjectPool`1(Factory<T, NoResetSupport`1<T>> factory);
    public ObjectPool`1(Factory<T, NoResetSupport`1<T>> factory, int size);
}
internal class Sparrow.ObjectPool`2 : object {
    private static TResetBehavior Behavior;
    private T _firstItem;
    private Element[] _items;
    private Factory<T, TResetBehavior> _factory;
    public ObjectPool`2(Factory<T, TResetBehavior> factory);
    public ObjectPool`2(Factory<T, TResetBehavior> factory, int size);
    private static ObjectPool`2();
    private T CreateInstance();
    public ObjectPoolContext`2<T, TResetBehavior> AllocateInContext();
    public T Allocate();
    private T AllocateSlow();
    public void Free(T obj);
    private void FreeSlow(T obj);
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("DETECT_LEAKS")]
public void ForgetTrackedObject(T old, T replacement);
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("DETECT_LEAKS")]
private void Validate(object obj);
}
internal class Sparrow.ObjectPoolContext`2 : ValueType {
    private ObjectPool`2<T, TR> _owner;
    public T Value;
    internal ObjectPoolContext`2(ObjectPool`2<T, TR> owner, T value);
    public sealed virtual void Dispose();
}
public class Sparrow.PeepingTomStream : object {
    public static int BufferWindowSize;
    private MemoryBuffer _buffer;
    private int _pos;
    private Stream _stream;
    private bool _firstWindow;
    private IDisposable _returnBuffer;
    public PeepingTomStream(Stream stream, JsonOperationContext context);
    internal PeepingTomStream(Stream stream, MemoryBuffer buffer);
    public int Read(Span`1<byte> buffer);
    private int ReadInternal(Span`1<byte> buffer, int read);
    public Byte[] PeepInReadStream();
    [AsyncStateMachineAttribute("Sparrow.PeepingTomStream/<ReadAsync>d__11")]
public Task`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken token);
    public sealed virtual void Dispose();
}
internal static class Sparrow.Platform.PlatformDetails : object {
    public static bool IsWindows8OrNewer;
    private static bool IsWindows10OrNewer;
    public static bool Is32Bits;
    public static bool RunningOnPosix;
    public static bool RunningOnMacOsx;
    public static bool RunningOnLinux;
    public static bool RunningOnWindows;
    public static bool CanPrefetch;
    public static bool CanDiscardMemory;
    internal static bool CanUseHttp2;
    public static bool RunningOnDocker;
    private static PlatformDetails();
    private static bool TryGetWindowsVersion(Decimal& version);
}
public static class Sparrow.Platform.Sodium : object {
    private static string LIBSODIUM;
    private static long _lockedBytes;
    public static long LockedBytes { get; }
    private static Sodium();
    public static void ZeroBuffer(Byte[] buffer);
    public static Byte[] GenerateRandomBuffer(int bytes);
    public static UIntPtr crypto_kdf_keybytes();
    public static int sodium_init();
    public static UIntPtr crypto_generichash_bytes();
    public static UIntPtr crypto_sign_statebytes();
    public static UIntPtr crypto_generichash_keybytes();
    public static int crypto_sign_init(Void* state);
    public static int crypto_sign_update(Void* state, Byte* m, ulong mlen);
    public static int crypto_sign_final_create(Void* state, Byte* sig, UInt64* siglen_p, Byte* sk);
    public static int crypto_generichash_init(Void* state, Byte* key, UIntPtr keylen, UIntPtr outlen);
    public static int crypto_generichash_update(Void* state, Byte* in, ulong inlen);
    public static int crypto_generichash_final(Void* state, Byte* out, UIntPtr outlen);
    public static int crypto_kx_keypair(Byte* pk, Byte* sk);
    public static void randombytes_buf(Byte* buffer, UIntPtr size);
    public static void crypto_kdf_keygen(Byte* masterkey);
    public static int crypto_kdf_derive_from_key(Byte* subkey, UIntPtr subkeylen, ulong subkeyid, Byte* ctx, Byte* key);
    public static int crypto_stream_xchacha20_xor_ic(Byte* c, Byte* m, ulong mlen, Byte* n, ulong ic, Byte* k);
    public static int crypto_aead_xchacha20poly1305_ietf_encrypt(Byte* c, UInt64* clen, Byte* m, ulong mlen, Byte* ad, ulong adlen, Byte* nsec, Byte* npub, Byte* k);
    public static int crypto_aead_xchacha20poly1305_ietf_decrypt(Byte* m, UInt64* mlen, Byte* nsec, Byte* c, ulong clen, Byte* ad, ulong adlen, Byte* npub, Byte* k);
    public static int crypto_aead_xchacha20poly1305_ietf_encrypt_detached(Byte* c, Byte* mac, UInt64* maclen_p, Byte* m, ulong mlen, Byte* ad, ulong adlen, Byte* nsec, Byte* npub, Byte* k);
    public static int crypto_aead_xchacha20poly1305_ietf_decrypt_detached(Byte* m, Byte* nsec, Byte* c, ulong clen, Byte* mac, Byte* ad, ulong adlen, Byte* npub, Byte* k);
    public static int crypto_box_seal(Byte* c, Byte* m, ulong mlen, Byte* pk);
    public static int crypto_box_seal_open(Byte* m, Byte* c, ulong clen, Byte* pk, Byte* sk);
    public static UIntPtr crypto_stream_xchacha20_keybytes();
    public static UIntPtr crypto_stream_xchacha20_noncebytes();
    public static UIntPtr crypto_aead_xchacha20poly1305_ietf_keybytes();
    public static UIntPtr crypto_aead_xchacha20poly1305_ietf_npubbytes();
    public static UIntPtr crypto_aead_xchacha20poly1305_ietf_abytes();
    public static UIntPtr crypto_box_sealbytes();
    public static UIntPtr crypto_box_secretkeybytes();
    public static UIntPtr crypto_kx_secretkeybytes();
    public static UIntPtr crypto_kx_publickeybytes();
    public static UIntPtr crypto_generichash_bytes_max();
    public static UIntPtr crypto_box_publickeybytes();
    public static int crypto_box_keypair(Byte* pk, Byte* sk);
    public static int crypto_generichash(Byte* out, UIntPtr outlen, Byte* in, ulong inlen, Byte* key, UIntPtr keylen);
    public static int sodium_memcmp(Byte* b, Byte* vh, UIntPtr verifiedHashLength);
    public static UIntPtr crypto_box_macbytes();
    public static UIntPtr crypto_box_noncebytes();
    public static int crypto_kx_client_session_keys(Byte* rx, Byte* tx, Byte* client_pk, Byte* client_sk, Byte* server_pk);
    public static int crypto_kx_server_session_keys(Byte* rx, Byte* tx, Byte* server_pk, Byte* server_sk, Byte* client_pk);
    public static int crypto_box_easy(Byte* c, Byte* m, ulong mlen, Byte* n, Byte* pk, Byte* sk);
    public static int crypto_box_open_easy(Byte* m, Byte* c, ulong clen, Byte* n, Byte* pk, Byte* sk);
    public static int crypto_sign_detached(Byte* sig, UInt64* siglen, Byte* m, ulong mlen, Byte* sk);
    public static int crypto_sign_verify_detached(Byte* sig, Byte* m, ulong mlen, Byte* pk);
    public static UIntPtr crypto_sign_bytes();
    public static UIntPtr crypto_sign_publickeybytes();
    public static UIntPtr crypto_sign_secretkeybytes();
    public static int crypto_sign_keypair(Byte* pk, Byte* sk);
    public static void sodium_memzero(Byte* pnt, UIntPtr len);
    public static UIntPtr crypto_generichash_statebytes();
    public static void crypto_secretstream_xchacha20poly1305_keygen(Byte* k);
    public static UIntPtr crypto_secretstream_xchacha20poly1305_keybytes();
    public static UIntPtr crypto_secretstream_xchacha20poly1305_statebytes();
    public static UIntPtr crypto_secretstream_xchacha20poly1305_headerbytes();
    public static int crypto_secretstream_xchacha20poly1305_init_push(Byte* state, Byte* header, Byte* k);
    public static int crypto_secretstream_xchacha20poly1305_push(Byte* state, Byte* c, UInt64* clen_p, Byte* m, ulong mlen, Byte* ad, ulong adlen, byte tag);
    public static byte crypto_secretstream_xchacha20poly1305_tag_final();
    public static int crypto_secretstream_xchacha20poly1305_init_pull(Byte* state, Byte* header, Byte* k);
    public static int crypto_secretstream_xchacha20poly1305_pull(Byte* state, Byte* m, UInt64* mlen_p, Byte* tag_p, Byte* c, ulong clen, Byte* ad, ulong adlen);
    public static UIntPtr crypto_secretstream_xchacha20poly1305_abytes();
    public static int sodium_munlock(Byte* addr, UIntPtr len);
    public static int sodium_mlock(Byte* addr, UIntPtr len);
    public static long get_LockedBytes();
    public static int Lock(Byte* addr, UIntPtr len);
    public static int Unlock(Byte* addr, UIntPtr len);
}
public class Sparrow.Size : ValueType {
    public static Size Zero;
    private static long OneKb;
    private static long OneMb;
    private static long OneGb;
    private static long OneTb;
    private SizeUnit _unit;
    private long _valueInBytes;
    public Size(long value, SizeUnit unit);
    private static Size();
    private static long ConvertToBytes(long value, SizeUnit unit);
    public static double ConvertToBytes(double value, SizeUnit unit);
    public long GetValue(SizeUnit requestedUnit);
    public double GetDoubleValue(SizeUnit requestedUnit);
    private void ThrowUnsupportedSize();
    public void Add(int value, SizeUnit unit);
    public void Add(long value, SizeUnit unit);
    public void Set(long newValue, SizeUnit requestedUnit);
    public static bool op_LessThan(Size x, Size y);
    public static bool op_GreaterThan(Size x, Size y);
    public static bool op_LessThanOrEqual(Size x, Size y);
    public static bool op_GreaterThanOrEqual(Size x, Size y);
    public static Size op_Addition(Size x, Size y);
    public static Size op_Subtraction(Size x, Size y);
    public static bool op_Equality(Size x, Size y);
    public static bool op_Inequality(Size x, Size y);
    public static Size op_Multiply(Size x, long y);
    public static Size op_Multiply(Size x, double y);
    public static Size op_Multiply(double y, Size x);
    public static Size op_Division(Size x, int y);
    public static Size Min(Size x, Size y);
    public static Size Max(Size x, Size y);
    public static Size Sum(ICollection`1<Size> sizes);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum Sparrow.SizeUnit : Enum {
    public int value__;
    public static SizeUnit Bytes;
    public static SizeUnit Kilobytes;
    public static SizeUnit Megabytes;
    public static SizeUnit Gigabytes;
    public static SizeUnit Terabytes;
}
[IsReadOnlyAttribute]
public class Sparrow.Sorter`2 : ValueType {
    private TSorter _sorter;
    private static int SizeThreshold;
    public Sorter`2(TSorter& sorter);
    public void Sort(Span`1<T> keys);
    public void Sort(Span`1<T> keys, int index, int length);
    private void SwapIfGreaterWithItems3(Span`1<T> keys, int a, int b, int c);
    private void Swap(Span`1<T> keys, int x, int y);
    private void IntroSort(Span`1<T> keys, int lo, int hi, int depthLimit);
    private int PickPivotAndPartitionUnlikely(Span`1<T> keys, int lo, int hi, int middle);
    private void HeapSort(Span`1<T> keys, int lo, int hi);
    private void DownHeap(Span`1<T> keys, int i, int n, int lo);
    private void InsertionSort(Span`1<T> keys, int lo, int hi);
}
[IsReadOnlyAttribute]
internal class Sparrow.Sorter`3 : ValueType {
    private TSorter _sorter;
    private static int SizeThreshold;
    public Sorter`3(TSorter sorter);
    public void Sort(Span`1<T> keys, Span`1<V> values);
    public void Sort(Span`1<T> keys, Span`1<V> values, int index, int length);
    private void SwapIfGreaterWithItems3(Span`1<T> keys, Span`1<V> values, int a, int b, int c);
    private void Swap(Span`1<T> keys, Span`1<V> values, int x, int y);
    private void IntroSort(Span`1<T> keys, Span`1<V> values, int lo, int hi, int depthLimit);
    private int PickPivotAndPartitionUnlikely(Span`1<T> keys, Span`1<V> values, int lo, int hi, int middle);
    private void HeapSort(Span`1<T> keys, Span`1<V> values, int lo, int hi);
    private void DownHeap(Span`1<T> keys, Span`1<V> values, int i, int n, int lo);
    private void InsertionSort(Span`1<T> keys, Span`1<V> values, int lo, int hi);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class Sparrow.StringSegment : ValueType {
    public static StringSegment Empty;
    [CompilerGeneratedAttribute]
private string <Buffer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public string Buffer { get; }
    public int Offset { get; }
    public int Length { get; }
    public string Value { get; }
    public bool HasValue { get; }
    public char Item { get; }
    public StringSegment(string buffer);
    public StringSegment(string buffer, int offset, int length);
    private static StringSegment();
    [CompilerGeneratedAttribute]
public string get_Buffer();
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public int get_Length();
    public string get_Value();
    public bool get_HasValue();
    public char get_Item(int index);
    public ReadOnlySpan`1<char> AsSpan();
    public ReadOnlyMemory`1<char> AsMemory();
    public static int Compare(StringSegment a, StringSegment b, StringComparison comparisonType);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(StringSegment other);
    public bool Equals(StringSegment other, StringComparison comparisonType);
    public static bool Equals(StringSegment a, StringSegment b, StringComparison comparisonType);
    public sealed virtual bool Equals(string text);
    public bool Equals(string text, StringComparison comparisonType);
    public virtual int GetHashCode();
    public static bool op_Equality(StringSegment left, StringSegment right);
    public static bool op_Inequality(StringSegment left, StringSegment right);
    public static StringSegment op_Implicit(string value);
    public static ReadOnlySpan`1<char> op_Implicit(StringSegment segment);
    public static ReadOnlyMemory`1<char> op_Implicit(StringSegment segment);
    public bool StartsWith(string text, StringComparison comparisonType);
    public bool EndsWith(string text, StringComparison comparisonType);
    public string Substring(int offset);
    public string Substring(int offset, int length);
    public StringSegment Subsegment(int offset);
    public StringSegment Subsegment(int offset, int length);
    public int IndexOf(char c, int start, int count);
    public int IndexOf(char c, int start);
    public int IndexOf(char c);
    public int IndexOfAny(Char[] anyOf, int startIndex, int count);
    public int IndexOfAny(Char[] anyOf, int startIndex);
    public int IndexOfAny(Char[] anyOf);
    public int LastIndexOf(char value);
    public StringSegment Trim();
    public StringSegment TrimStart();
    public StringSegment TrimEnd();
    public static bool IsNullOrEmpty(StringSegment value);
    public virtual string ToString();
    [DoesNotReturnAttribute]
private static void ThrowInvalidArguments(string buffer, int offset, int length);
    [DoesNotReturnAttribute]
private void ThrowInvalidArguments(int offset, int length);
    [CompilerGeneratedAttribute]
internal static Exception <ThrowInvalidArguments>g__GetInvalidArgumentsException|51_0(<>c__DisplayClass51_0& );
    [CompilerGeneratedAttribute]
internal static Exception <ThrowInvalidArguments>g__GetInvalidArgumentsException|52_0(bool hasValue, <>c__DisplayClass52_0& );
}
internal class Sparrow.StringSegmentComparer : object {
    [CompilerGeneratedAttribute]
private static StringSegmentComparer <Ordinal>k__BackingField;
    [CompilerGeneratedAttribute]
private static StringSegmentComparer <OrdinalIgnoreCase>k__BackingField;
    [CompilerGeneratedAttribute]
private StringComparison <Comparison>k__BackingField;
    [CompilerGeneratedAttribute]
private StringComparer <Comparer>k__BackingField;
    public static StringSegmentComparer Ordinal { get; }
    public static StringSegmentComparer OrdinalIgnoreCase { get; }
    private StringComparison Comparison { get; }
    private StringComparer Comparer { get; }
    private StringSegmentComparer(StringComparison comparison, StringComparer comparer);
    private static StringSegmentComparer();
    [CompilerGeneratedAttribute]
public static StringSegmentComparer get_Ordinal();
    [CompilerGeneratedAttribute]
public static StringSegmentComparer get_OrdinalIgnoreCase();
    [CompilerGeneratedAttribute]
private StringComparison get_Comparison();
    [CompilerGeneratedAttribute]
private StringComparer get_Comparer();
    public sealed virtual int Compare(StringSegment x, StringSegment y);
    public sealed virtual bool Equals(StringSegment x, StringSegment y);
    public sealed virtual int GetHashCode(StringSegment obj);
}
internal class Sparrow.StringSegmentEqualityStructComparer : ValueType {
    public static IEqualityComparer`1<StringSegment> BoxedInstance;
    private static StringSegmentEqualityStructComparer();
    public sealed virtual bool Equals(StringSegment x, StringSegment y);
    public sealed virtual int GetHashCode(StringSegment x);
}
public class Sparrow.Threading.DisposeOnce`1 : object {
    private Action _action;
    private Tuple`2<MultipleUseFlag, TaskCompletionSource`1<object>> _state;
    private TOperationMode _operationModeData;
    public bool DisposedRequested { get; }
    public bool Disposed { get; }
    public DisposeOnce`1(Action action);
    public sealed virtual void Dispose();
    public bool get_DisposedRequested();
    public bool get_Disposed();
}
internal class Sparrow.Threading.DisposeOnceAsync`1 : object {
    private Func`1<Task> _action;
    private Tuple`2<MultipleUseFlag, TaskCompletionSource`1<object>> _state;
    private TOperationMode _operationModeData;
    public bool Disposed { get; }
    public DisposeOnceAsync`1(Func`1<Task> action);
    [AsyncStateMachineAttribute("Sparrow.Threading.DisposeOnceAsync`1/<DisposeAsync>d__4")]
public Task DisposeAsync();
    public bool get_Disposed();
}
internal class Sparrow.Threading.ExceptionRetry : ValueType {
    public bool DuringDispose { get; }
    public sealed virtual void Initialize();
    public sealed virtual bool get_DuringDispose();
    public sealed virtual void EnterDispose();
    public sealed virtual void LeaveDispose();
}
public interface Sparrow.Threading.IDisposeOnceOperationMode {
    public bool DuringDispose { get; }
    public abstract virtual void Initialize();
    public abstract virtual bool get_DuringDispose();
    public abstract virtual void EnterDispose();
    public abstract virtual void LeaveDispose();
}
internal class Sparrow.Threading.LightWeightThreadLocal`1 : object {
    [ThreadStaticAttribute]
private static CurrentThreadState<T> _state;
    private WeakReferenceCompareValue`1<T, LightWeightThreadLocal`1<T>> SelfReference;
    private ConcurrentDictionary`2<WeakReferenceCompareValue`1<T, CurrentThreadState<T>>, T> _values;
    private Func`1<T> _generator;
    private bool _disposed;
    private static int GlobalVersion;
    public ICollection`1<T> Values { get; }
    public bool IsValueCreated { get; }
    public T Value { get; public set; }
    public LightWeightThreadLocal`1(Func`1<T> generator);
    public ICollection`1<T> get_Values();
    public bool get_IsValueCreated();
    public T get_Value();
    public void set_Value(T value);
    public sealed virtual void Dispose();
}
public class Sparrow.Threading.MultipleUseFlag : object {
    private int _state;
    public MultipleUseFlag(MultipleUseFlag other);
    public MultipleUseFlag(bool raised);
    public void RaiseOrDie();
    private static void ThrowRaiseException();
    public void LowerOrDie();
    private static void ThrowLowerException();
    public bool Lower();
    public bool Raise();
    public bool IsRaised();
    public static bool op_Implicit(MultipleUseFlag flag);
}
public class Sparrow.Threading.SharedMultipleUseFlag : object {
    private MultipleUseFlag _flag;
    public static SharedMultipleUseFlag None;
    public SharedMultipleUseFlag(SharedMultipleUseFlag copy);
    public SharedMultipleUseFlag(bool raised);
    private static SharedMultipleUseFlag();
    public void RaiseOrDie();
    public void LowerOrDie();
    public bool Lower();
    public bool Raise();
    public bool IsRaised();
    public static bool op_Implicit(SharedMultipleUseFlag flag);
}
public class Sparrow.Threading.SingleAttempt : ValueType {
    private long disposeDepth;
    public bool DuringDispose { get; }
    public sealed virtual void Initialize();
    public sealed virtual bool get_DuringDispose();
    public sealed virtual void EnterDispose();
    public sealed virtual void LeaveDispose();
}
public class Sparrow.Threading.SingleUseFlag : object {
    private int _state;
    public SingleUseFlag(SingleUseFlag other);
    public SingleUseFlag(bool raised);
    public void RaiseOrDie();
    private static void ThrowException();
    public bool Raise();
    public bool IsRaised();
    public static bool op_Implicit(SingleUseFlag flag);
}
public class Sparrow.TimeValue : ValueType {
    public static TimeValue Zero;
    public static TimeValue MaxValue;
    public static TimeValue MinValue;
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeValueUnit <Unit>k__BackingField;
    private static int SecondsPerDay;
    private static int SecondsIn28Days;
    private static int SecondsIn31Days;
    private static int SecondsIn365Days;
    private static int SecondsIn366Days;
    public int Value { get; private set; }
    public TimeValueUnit Unit { get; private set; }
    private TimeValue(int value, TimeValueUnit unit);
    private static TimeValue();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TimeValueUnit get_Unit();
    [CompilerGeneratedAttribute]
private void set_Unit(TimeValueUnit value);
    public static TimeValue FromSeconds(int seconds);
    public static TimeValue FromMinutes(int minutes);
    public static TimeValue FromHours(int hours);
    public static TimeValue FromDays(int days);
    public static TimeValue FromMonths(int months);
    public static TimeValue FromYears(int years);
    public sealed virtual DynamicJsonValue ToJson();
    public double TimesInInterval(DateTime from, DateTime to);
    public bool IsMultiple(TimeValue multiple);
    private void Append(StringBuilder builder, int value, string singular);
    public virtual string ToString();
    private void AssertSeconds();
    private static void AssertValidUnit(TimeValueUnit unit);
    private static void AssertSameUnits(TimeValue a, TimeValue b);
    public int Compare(TimeValue other);
    private static ValueTuple`2<long, long> GetBoundsInSeconds(TimeValue time);
    private static bool IsSpecialCompare(TimeValue current, TimeValue other, Int32& result);
    private static bool IsMax(TimeValue time);
    private static bool IsMin(TimeValue time);
    private static int TrimCompareResult(long result);
    public static TimeValue op_Multiply(double c, TimeValue b);
    public static TimeValue op_Addition(TimeValue a, TimeValue b);
    public static TimeValue op_Subtraction(TimeValue a, TimeValue b);
    public static TimeValue op_UnaryNegation(TimeValue a);
    public static TimeValue op_Multiply(TimeValue a, double c);
    public static bool op_GreaterThan(TimeValue a, TimeValue b);
    public static bool op_LessThan(TimeValue a, TimeValue b);
    public static bool op_GreaterThanOrEqual(TimeValue a, TimeValue b);
    public static bool op_LessThanOrEqual(TimeValue a, TimeValue b);
    public static bool op_Equality(TimeValue a, TimeValue b);
    public static bool op_Inequality(TimeValue a, TimeValue b);
    public static TimeSpan op_Explicit(TimeValue a);
    public static DateTime op_Explicit(TimeValue a);
    public static TimeValue op_Implicit(TimeSpan a);
    public sealed virtual bool Equals(TimeValue other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum Sparrow.TimeValueUnit : Enum {
    public int value__;
    public static TimeValueUnit None;
    public static TimeValueUnit Second;
    public static TimeValueUnit Month;
}
internal static class Sparrow.TypesHelper : object {
    public static bool IsNumerical();
    public static bool IsInteger();
    public static bool IsFloatingPoint();
}
public class Sparrow.UnmanagedMemory : object {
    private Nullable`1<Memory`1<byte>> _memory;
    public Byte* Address;
    public int Size;
    public Memory`1<byte> Memory { get; }
    public UnmanagedMemory(Byte* address, int size);
    public Memory`1<byte> get_Memory();
}
[IsReadOnlyAttribute]
public class Sparrow.UnmanagedPointer : ValueType {
    public Byte* Address;
    public UnmanagedPointer(Byte* address);
    public static UnmanagedPointer op_Addition(UnmanagedPointer pointer, int offset);
}
[IsReadOnlyAttribute]
public class Sparrow.UnmanagedSpan : ValueType {
    public Byte* Address;
    public int Length;
    public long Long;
    public double Double;
    public static UnmanagedSpan Empty;
    public UnmanagedSpan(long l);
    public UnmanagedSpan(double d);
    public UnmanagedSpan(Byte* address, int length);
    public UnmanagedSpan(UnmanagedPointer pointer, int length);
    private static UnmanagedSpan();
    public UnmanagedMemoryStream ToStream();
    public virtual string ToString();
    public UnmanagedSpan Slice(int offset);
    public UnmanagedSpan Slice(int position, int length);
    public Span`1<byte> ToSpan();
    public ReadOnlySpan`1<byte> ToReadOnlySpan();
    public static UnmanagedSpan op_Addition(UnmanagedSpan pointer, int offset);
    public static Span`1<byte> op_Implicit(UnmanagedSpan pointer);
    public static ReadOnlySpan`1<byte> op_Implicit(UnmanagedSpan pointer);
    public string ToStringValue();
}
internal class Sparrow.UnmanagedSpanComparer : ValueType {
    public static UnmanagedSpanComparer Instance;
    private static UnmanagedSpanComparer();
    public sealed virtual bool Equals(UnmanagedSpan x, UnmanagedSpan y);
    public sealed virtual int GetHashCode(UnmanagedSpan item);
}
internal static class Sparrow.Utils.CommandLineArgumentEscaper : object {
    public static string EscapeAndConcatenate(IEnumerable`1<string> args);
    public static string EscapeSingleArg(string arg);
    private static bool IsSurroundedWithQuotes(string argument);
    private static bool ContainsWhitespace(string argument);
}
internal class Sparrow.Utils.ConcatStream : Stream {
    private RentedBuffer _prefix;
    private Stream _remaining;
    private bool _disposed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ConcatStream(RentedBuffer prefix, Stream remaining);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    private int ReadFromBuffer(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    private void ThrowDisposedException();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
}
internal class Sparrow.Utils.CountingConcurrentStack`1 : object {
    private ConcurrentStack`1<TItem> _stack;
    private long _count;
    public bool IsEmpty { get; }
    public long Count { get; }
    public bool get_IsEmpty();
    public long get_Count();
    public bool TryPop(TItem& item);
    public void Push(TItem item);
    public IEnumerator`1<TItem> GetEnumerator();
}
internal static class Sparrow.Utils.CurrentProcessorIdHelper : object {
    public static int GetCurrentProcessorId();
}
internal class Sparrow.Utils.DecimalHelper : object {
    private static string FlagsFieldName;
    public static DecimalHelper Instance;
    public IsDoubleDelegate IsDouble;
    private static DecimalHelper();
    private static Expression`1<IsDoubleDelegate> CreateIsDoubleMethod();
}
internal static class Sparrow.Utils.DevelopmentHelper : object {
    [ConditionalAttribute("DEBUG")]
internal static void ToDo(Feature feature, TeamMember member, Severity severity, string message);
    [ConditionalAttribute("DEBUG")]
internal static void ShardingToDo(TeamMember member, Severity severity, string message);
}
internal class Sparrow.Utils.DisposeLock : object {
    private string _name;
    private AsyncReaderWriterLock _lock;
    private CancellationTokenSource _cts;
    public DisposeLock(string name);
    public IDisposable EnsureNotDisposed();
    [AsyncStateMachineAttribute("Sparrow.Utils.DisposeLock/<EnsureNotDisposedAsync>d__5")]
public ValueTask`1<IDisposable> EnsureNotDisposedAsync();
    public IDisposable StartDisposing();
    private void ThrowDisposed();
}
internal static class Sparrow.Utils.DynamicNativeLibraryResolver : object {
    private static Dictionary`2<string, Func`2<string, string>> _registered;
    private static HashSet`1<Assembly> _registeredAssemblies;
    private static DynamicNativeLibraryResolver();
    public static void Register(Assembly asm, string lib, Func`2<string, string> mutator);
    private static IntPtr Resolver(string libraryName, Assembly assembly, Nullable`1<DllImportSearchPath> dllImportSearchPath);
}
internal class Sparrow.Utils.FifoSemaphore : object {
    internal Queue`1<OneTimeWaiter> _waitQueue;
    private object _lock;
    private int _tokens;
    private TestingStuff _forTestingPurposes;
    public FifoSemaphore(int tokens);
    public bool TryAcquire(TimeSpan timeout, CancellationToken token);
    public void Acquire(CancellationToken token);
    private static void ThrowCouldNotAcquireLock();
    public void Release();
    public void ReleaseMany(int tokens);
    internal TestingStuff ForTestingPurposesOnly();
}
internal class Sparrow.Utils.IncorrectDllException : Exception {
    public IncorrectDllException(string message);
    public IncorrectDllException(string message, Exception innerException);
}
internal class Sparrow.Utils.IsDoubleDelegate : MulticastDelegate {
    public IsDoubleDelegate(object object, IntPtr method);
    public virtual bool Invoke(Decimal& value);
    public virtual IAsyncResult BeginInvoke(Decimal& value, AsyncCallback callback, object object);
    public virtual bool EndInvoke(Decimal& value, IAsyncResult result);
}
public class Sparrow.Utils.LazyWithExceptionRetry`1 : object {
    private Lazy`1<T> _inner;
    private Func`1<T> _factory;
    private bool _faulted;
    public bool IsValueFaulted { get; }
    public bool IsValueCreated { get; }
    public T Value { get; }
    public LazyWithExceptionRetry`1(Func`1<T> factory);
    public bool get_IsValueFaulted();
    public bool get_IsValueCreated();
    public T get_Value();
}
public class Sparrow.Utils.LockAlreadyDisposedException : ObjectDisposedException {
    public LockAlreadyDisposedException(string message);
    public LockAlreadyDisposedException(string message, Exception innerException);
}
internal static class Sparrow.Utils.MemoryUtils : object {
    private static string GenericOutMemoryException;
    private static InvertedComparer InvertedComparerInstance;
    private static int MinAllocatedThresholdInBytes;
    private static MemoryUtils();
    public static string GetExtendedMemoryInfo(MemoryInfoResult memoryInfo, DirtyMemoryState dirtyState);
    [CompilerGeneratedAttribute]
internal static void <GetExtendedMemoryInfo>g__TryAppend|3_8(Action append);
}
public static class Sparrow.Utils.NativeMemory : object {
    public static Func`1<ulong> GetCurrentUnmanagedThreadId;
    internal static LightWeightThreadLocal`1<ThreadStats> ThreadAllocations;
    internal static long _totalAllocatedMemory;
    private static long _totalLuceneManagedAllocationsForTermCache;
    private static long _totalLuceneUnmanagedAllocationsForSorting;
    public static ConcurrentDictionary`2<string, Lazy`1<FileMappingInfo>> FileMapping;
    public static ThreadStats CurrentThreadStats { get; }
    public static IEnumerable`1<ThreadStats> AllThreadStats { get; }
    public static long TotalAllocatedMemory { get; }
    public static long TotalLuceneManagedAllocationsForTermCache { get; }
    public static long TotalLuceneUnmanagedAllocationsForSorting { get; }
    private static NativeMemory();
    public static void NotifyCurrentThreadAboutToClose();
    public static ThreadStats get_CurrentThreadStats();
    [IteratorStateMachineAttribute("Sparrow.Utils.NativeMemory/<get_AllThreadStats>d__6")]
public static IEnumerable`1<ThreadStats> get_AllThreadStats();
    public static long get_TotalAllocatedMemory();
    public static long get_TotalLuceneManagedAllocationsForTermCache();
    public static long get_TotalLuceneUnmanagedAllocationsForSorting();
    public static void Free(Byte* ptr, long size, ThreadStats stats);
    public static void Free(Byte* ptr, long size);
    public static Byte* AllocateMemory(long size);
    public static Byte* AllocateMemory(long size, ThreadStats& thread);
    public static void IncrementLuceneManagedAllocations(long size);
    public static void DecrementLuceneManagedAllocations(long size);
    public static Byte* AllocateMemoryByLucene(long size);
    public static void FreeMemoryByLucene(Byte* ptr, long size);
    private static Byte* ThrowFailedToAllocate(long size, ThreadStats thread, OutOfMemoryException e);
    internal static void UpdateMemoryStatsForThread(ThreadStats stats, long size);
    public static void RegisterFileMapping(string fullPath, IntPtr start, long size, Func`1<long> getAllocatedSize);
    private static FileType GetFileType(string fullPath);
    public static void UnregisterFileMapping(string name);
    public static void UnregisterFileMapping(string name, IntPtr start, long size);
    public static void EnsureRegistered();
}
public class Sparrow.Utils.NativeMemoryCleaner`2 : object {
    private static Logger Logger;
    private object _lock;
    private Func`2<object, ICollection`1<TStack>> _getContextsFromCleanupTarget;
    private SharedMultipleUseFlag _lowMemoryFlag;
    private TimeSpan _idleTime;
    private Timer _timer;
    private WeakReference _cleanupTargetWeakRef;
    public NativeMemoryCleaner`2(object cleanupTarget, Func`2<object, ICollection`1<TStack>> getContexts, SharedMultipleUseFlag lowMemoryFlag, TimeSpan period, TimeSpan idleTime);
    private static NativeMemoryCleaner`2();
    private ICollection`1<TStack> GetContexts();
    public void CleanNativeMemory(object state);
    public sealed virtual void Dispose();
}
public abstract class Sparrow.Utils.PooledItem : object {
    public MultipleUseFlag InUse;
    public DateTime InPoolSince;
    public abstract virtual void Dispose();
}
internal class Sparrow.Utils.ProcessorInfo : object {
    public static int ProcessorCount;
    private static ProcessorInfo();
    public static int GetProcessorCount();
}
internal class Sparrow.Utils.ReadWriteCompressedStream : Stream {
    private Stream _inner;
    private ZstdStream _input;
    private ZstdStream _output;
    private DisposeOnce`1<SingleAttempt> _dispose;
    private bool _disposing;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public ReadWriteCompressedStream(Stream inner);
    public ReadWriteCompressedStream(Stream inner, MemoryBuffer alreadyOnBuffer);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public TotalBytes GetTotalBytesSent();
    public TotalBytes GetTotalBytesReceived();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual int ReadByte();
    public virtual void WriteByte(byte value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    private void DisposeInternal();
    protected virtual void Dispose(bool disposing);
}
internal class Sparrow.Utils.ReferenceEqualityComparer : object {
    public static ReferenceEqualityComparer Default;
    private static ReferenceEqualityComparer();
    public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
}
internal class Sparrow.Utils.ReferenceEqualityComparer`1 : object {
    public static ReferenceEqualityComparer`1<T> Default;
    private static ReferenceEqualityComparer`1();
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
}
internal static class Sparrow.Utils.SafeFileStream : object {
    private static void AvoidKillingTheProcessWhenOutOfDiskSpace(FileStream file);
    public static FileStream Create(string path, FileMode mode);
    public static FileStream Create(string path, FileMode mode, FileAccess access);
    public static FileStream Create(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options);
    public static FileStream Create(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, bool useAsync);
    public static FileStream Create(string path, FileMode mode, FileAccess access, FileShare share);
    public static FileStream Create(SafeFileHandle handle, FileAccess access);
}
internal static class Sparrow.Utils.Sizes : object {
    public static string Humane(Nullable`1<long> size);
}
public class Sparrow.Utils.StackHeader`1 : object {
    public static StackNode`1<T> HeaderDisposed;
    public StackNode`1<T> Head;
    private static StackHeader`1();
}
public class Sparrow.Utils.StackNode`1 : object {
    public T Value;
    public StackNode`1<T> Next;
}
internal static class Sparrow.Utils.ThreadingHelper : object {
    public static bool InterlockedExchangeMax(Int64& location, long newValue);
}
internal static class Sparrow.Utils.ThreadLocalCleanup : object {
    [CompilerGeneratedAttribute]
private static Action ReleaseThreadLocalState;
    private static ThreadLocalCleanup();
    [CompilerGeneratedAttribute]
public static void add_ReleaseThreadLocalState(Action value);
    [CompilerGeneratedAttribute]
public static void remove_ReleaseThreadLocalState(Action value);
    public static void Run();
}
[ExtensionAttribute]
internal static class Sparrow.Utils.TimeoutManager : object {
    private static ConcurrentDictionary`2<UInt32, TimerTaskHolder> Values;
    private static Task InfiniteTask;
    private static TimeoutManager();
    [AsyncStateMachineAttribute("Sparrow.Utils.TimeoutManager/<WaitForInternal>d__3")]
private static Task WaitForInternal(TimeSpan time, CancellationToken token);
    private static void ThrowOutOfRange();
    private static TimerTaskHolder GetHolderForDuration(UInt32 duration);
    [AsyncStateMachineAttribute("Sparrow.Utils.TimeoutManager/<WaitFor>d__6")]
[ExtensionAttribute]
public static Task`1<Task> WaitFor(Task outer, TimeSpan duration, CancellationToken token);
    [AsyncStateMachineAttribute("Sparrow.Utils.TimeoutManager/<WaitFor>d__7")]
public static Task WaitFor(TimeSpan duration, CancellationToken token);
}
internal class Sparrow.Utils.TypeCache`1 : object {
    private FastList`1[] _buckets;
    private int _size;
    public TypeCache`1(int size);
    public bool TryGet(Type type, T& result);
    public bool TryGetUnlikely(FastList`1<Tuple`2<Type, T>> storage, Type type, T& result);
    public void Put(Type type, T value);
}
[ExtensionAttribute]
internal static class Sparrow.Utils.TypeUtils : object {
    private static ObjectPool`2<HashSet`1<object>, VisitedResetBehavior> VisitedHashsets;
    private static TypeUtils();
    [ExtensionAttribute]
public static bool ContainsBlittableObject(object obj);
    [ExtensionAttribute]
private static bool ContainsBlittableObject(object obj, HashSet`1<object> visited);
    [ExtensionAttribute]
public static bool IsUserDefinedStruct(Type type);
}
internal static class Sparrow.Utils.WhoIsLocking : object {
    private static int RmRebootReasonNone;
    private static int CCH_RM_MAX_APP_NAME;
    private static int CCH_RM_MAX_SVC_NAME;
    public static string ThisFile(string path);
    public static IList`1<Process> GetProcessesUsingFile(string filePath);
    private static int RmStartSession(UInt32& pSessionHandle, int dwSessionFlags, string strSessionKey);
    private static int RmEndSession(UInt32 pSessionHandle);
    private static int RmRegisterResources(UInt32 pSessionHandle, UInt32 nFiles, String[] rgsFilenames, UInt32 nApplications, RM_UNIQUE_PROCESS[] rgApplications, UInt32 nServices, String[] rgsServiceNames);
    private static int RmGetList(UInt32 dwSessionHandle, UInt32& pnProcInfoNeeded, UInt32& pnProcInfo, RM_PROCESS_INFO[] rgAffectedApps, UInt32& lpdwRebootReasons);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal static class Sparrow.Utils.ZstdLib : object {
    private static string LIBZSTD;
    internal static Func`2<string, Exception> CreateDictionaryException;
    private static ulong ZSTD_CONTENTSIZE_UNKNOWN;
    private static ulong ZSTD_CONTENTSIZE_ERROR;
    private static ulong ZSTD_Error_maxCode;
    [ThreadStaticAttribute]
private static CompressContext _threadCompressContext;
    private static ZstdLib();
    private static UIntPtr ZSTD_compressBound(UIntPtr srcSize);
    private static ulong ZSTD_getFrameContentSize(Void* src, UIntPtr srcSize);
    public static int GetDecompressedSize(ReadOnlySpan`1<byte> compressed);
    public static int GetDecompressedSize(Byte* srcPtr, int len);
    public static long GetMaxCompression(long size);
    public static int GetMaxCompression(int size);
    private static Void* ZSTD_createCCtx();
    private static UIntPtr ZSTD_CCtx_setParameter(Void* cctx, ZSTD_cParameter p, int value);
    private static UIntPtr ZSTD_freeCCtx(Void* cctx);
    private static Void* ZSTD_createDCtx();
    private static UIntPtr ZSTD_freeDCtx(Void* dctx);
    public static UInt32 ZSTD_isError(UIntPtr code);
    public static IntPtr ZSTD_getErrorName(UIntPtr code);
    public static UIntPtr ZSTD_compressCCtx(Void* ctx, Byte* dst, UIntPtr dstCapacity, Byte* src, UIntPtr srcSize, int compressionLevel);
    public static UIntPtr ZSTD_decompressDCtx(Void* ctx, Byte* dst, UIntPtr dstCapacity, Byte* src, UIntPtr srcSize);
    public static UIntPtr ZSTD_compress_usingCDict(Void* ctx, Byte* dst, UIntPtr dstCapacity, Byte* src, UIntPtr srcSize, Void* cdict);
    public static UIntPtr ZSTD_decompress_usingDDict(Void* ctx, Byte* dst, UIntPtr dstCapacity, Byte* src, UIntPtr srcSize, Void* ddict);
    public static Void* ZSTD_createCDict(Byte* dictBuffer, UIntPtr dictSize, int compressionLevel);
    public static UIntPtr ZSTD_freeCDict(Void* CDict);
    public static Void* ZSTD_createDDict(Void* dictBuffer, UIntPtr dictSize);
    public static UIntPtr ZSTD_freeDDict(Void* ddict);
    public static UIntPtr ZDICT_trainFromBuffer(Byte* dictBuffer, UIntPtr dictBufferCapacity, Byte* samplesBuffer, UIntPtr* samplesSizes, UInt32 nbSamples);
    public static UIntPtr ZSTD_compressStream2(Void* ctx, ZSTD_outBuffer* output, ZSTD_inBuffer* input, ZSTD_EndDirective directive);
    public static UIntPtr ZSTD_decompressStream(Void* ctx, ZSTD_outBuffer* output, ZSTD_inBuffer* input);
    public static void AssertZstdSuccess(UIntPtr v);
    private static void RaiseError(UIntPtr v);
    private static void AssertSuccess(UIntPtr v, CompressionDictionary dictionary);
    public static int Compress(Byte* src, int srcLen, Byte* dst, int dstLen, CompressionDictionary dictionary);
    public static int Decompress(ReadOnlySpan`1<byte> src, Span`1<byte> dst, CompressionDictionary dictionary);
    public static int Decompress(Byte* srcPtr, int srcSize, Byte* dstPtr, int dstSize, CompressionDictionary dictionary);
    public static void Train(ReadOnlySpan`1<byte> plainTextBuffer, ReadOnlySpan`1<UIntPtr> sizes, Span`1& output);
}
internal class Sparrow.Utils.ZstdStream : Stream {
    private Stream _inner;
    private bool _compression;
    private bool _leaveOpen;
    private CompressContext _compressContext;
    private Byte[] _tempBuffer;
    private Memory`1<byte> _decompressionInput;
    private long _compressedBytesCount;
    private long _uncompressedBytesCount;
    private DisposeLock _disposerLock;
    private bool _disposed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public long CompressedBytesCount { get; }
    public long UncompressedBytesCount { get; }
    private ZstdStream(Stream inner, bool compression, int level, bool leaveOpen);
    public static ZstdStream Compress(Stream stream, CompressionLevel compressionLevel, bool leaveOpen);
    public static ZstdStream Decompress(Stream stream, bool leaveOpen);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public long get_CompressedBytesCount();
    public long get_UncompressedBytesCount();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    private int DecompressStep(ReadOnlySpan`1<byte> buffer);
    private ValueTuple`3<int, int, bool> CompressStep(ReadOnlySpan`1<byte> buffer, ZSTD_EndDirective directive);
    private void ShiftBufferData();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Sparrow.Utils.ZstdStream/<ReadAsync>d__36")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Sparrow.Utils.ZstdStream/<WriteAsync>d__40")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void Flush();
    private void FlushInternal();
    [AsyncStateMachineAttribute("Sparrow.Utils.ZstdStream/<FlushAsync>d__43")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Sparrow.Utils.ZstdStream/<FlushInternalAsync>d__44")]
private Task FlushInternalAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Sparrow.Utils.ZstdStream/<DisposeAsync>d__45")]
public virtual ValueTask DisposeAsync();
    protected virtual void Dispose(bool disposing);
    private void ReleaseResources();
    private static int ToZstdLevel(CompressionLevel compressionLevel);
}
[ExtensionAttribute]
internal static class System.EnumerableExtensions : object {
    [ExtensionAttribute]
public static IEnumerator`1<T> GetEnumerator(IEnumerator`1<T> enumerator);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
