[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public static class Raven.Client.Constants : object {
}
public abstract class Raven.Client.Conventions : object {
}
internal static class Raven.Client.DocumentationUrls : object {
}
public enum Raven.Client.Documents.Attachments.AttachmentType : Enum {
    public byte value__;
    public static AttachmentType Document;
    public static AttachmentType Revision;
}
public class Raven.Client.Documents.BulkInsert.BulkInsertOperation : BulkInsertOperationBase`1<object> {
    private BulkInsertOptions _options;
    private string _database;
    private CancellationToken _token;
    private GenerateEntityIdOnTheClient _generateEntityIdOnTheClient;
    private RequestExecutor _requestExecutor;
    private JsonOperationContext _context;
    private IDisposable _resetContext;
    private CommandType _inProgressCommand;
    private CountersBulkInsertOperation _countersOperation;
    private AttachmentsBulkInsertOperation _attachmentsOperation;
    private string _nodeTag;
    private IJsonSerializer _defaultSerializer;
    private Func`4<object, IMetadataDictionary, StreamWriter, bool> _customEntitySerializer;
    private int _timeSeriesBatchSize;
    private long _concurrentCheck;
    private bool _first;
    public CompressionLevel CompressionLevel;
    private IDisposable _unsubscribeChanges;
    [CompilerGeneratedAttribute]
private EventHandler`1<BulkInsertOnProgressEventArgs> _onProgress;
    private bool _onProgressInitialized;
    private WeakReferencingTimer _timer;
    private SemaphoreSlim _streamLock;
    private TimeSpan _heartbeatCheckInterval;
    private BulkInsertWriter _writer;
    private DisposeOnceAsync`1<SingleAttempt> _disposeOnce;
    private DocumentConventions _conventions;
    private IDocumentStore _store;
    public BulkInsertOperation(string database, IDocumentStore store, BulkInsertOptions options, CancellationToken token);
    public BulkInsertOperation(string database, IDocumentStore store, CancellationToken token);
    [CompilerGeneratedAttribute]
private void add__onProgress(EventHandler`1<BulkInsertOnProgressEventArgs> value);
    [CompilerGeneratedAttribute]
private void remove__onProgress(EventHandler`1<BulkInsertOnProgressEventArgs> value);
    public void add_OnProgress(EventHandler`1<BulkInsertOnProgressEventArgs> value);
    public void remove_OnProgress(EventHandler`1<BulkInsertOnProgressEventArgs> value);
    private static void HandleHeartbeat(object state);
    [AsyncStateMachineAttribute("Raven.Client.Documents.BulkInsert.BulkInsertOperation/<SendHeartBeatAsync>d__32")]
private Task SendHeartBeatAsync();
    private static bool CheckServerVersion(string serverVersion);
    private static void ThrowNoDatabase();
    [AsyncStateMachineAttribute("Raven.Client.Documents.BulkInsert.BulkInsertOperation/<WaitForId>d__36")]
protected virtual Task WaitForId();
    internal void InvokeOnProgress(BulkInsertProgress progress);
    public void Store(object entity, string id, IMetadataDictionary metadata);
    public string Store(object entity, IMetadataDictionary metadata);
    [AsyncStateMachineAttribute("Raven.Client.Documents.BulkInsert.BulkInsertOperation/<StoreAsync>d__40")]
public Task`1<string> StoreAsync(object entity, IMetadataDictionary metadata);
    public virtual Task StoreAsync(object entity, string id);
    [AsyncStateMachineAttribute("Raven.Client.Documents.BulkInsert.BulkInsertOperation/<StoreAsync>d__42")]
public Task StoreAsync(object entity, string id, IMetadataDictionary metadata);
    [AsyncStateMachineAttribute("Raven.Client.Documents.BulkInsert.BulkInsertOperation/<WriteToStreamAsync>d__43")]
private ValueTask WriteToStreamAsync(object entity, string id, IMetadataDictionary metadata, CommandType type);
    [AsyncStateMachineAttribute("Raven.Client.Documents.BulkInsert.BulkInsertOperation/<HandleErrors>d__44")]
private Task HandleErrors(string documentId, Exception e);
    private ValueTask`1<ReleaseStream> ConcurrencyCheckAsync();
    private void EndPreviousCommandIfNeeded();
    private void WriteString(string input);
    private void WriteComma();
    private static void VerifyValidId(string id);
    [AsyncStateMachineAttribute("Raven.Client.Documents.BulkInsert.BulkInsertOperation/<GetExceptionFromOperation>d__50")]
protected virtual Task`1<BulkInsertAbortedException> GetExceptionFromOperation();
    [AsyncStateMachineAttribute("Raven.Client.Documents.BulkInsert.BulkInsertOperation/<EnsureStreamAsync>d__52")]
protected virtual Task EnsureStreamAsync();
    [AsyncStateMachineAttribute("Raven.Client.Documents.BulkInsert.BulkInsertOperation/<ExecuteAsync>d__53")]
private Task ExecuteAsync(BulkInsertCommand cmd);
    [AsyncStateMachineAttribute("Raven.Client.Documents.BulkInsert.BulkInsertOperation/<ExecuteAsync>d__54`1")]
private Task ExecuteAsync(RavenCommand`1<TResult> command, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.BulkInsert.BulkInsertOperation/<ThrowOnUnavailableStream>d__55")]
private Task ThrowOnUnavailableStream(string id, Exception innerEx);
    [AsyncStateMachineAttribute("Raven.Client.Documents.BulkInsert.BulkInsertOperation/<AbortAsync>d__56")]
public virtual Task AbortAsync();
    public void Abort();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Raven.Client.Documents.BulkInsert.BulkInsertOperation/<DisposeAsync>d__62")]
public sealed virtual ValueTask DisposeAsync();
    [AsyncStateMachineAttribute("Raven.Client.Documents.BulkInsert.BulkInsertOperation/<GetIdAsync>d__63")]
private ValueTask`1<string> GetIdAsync(object entity);
    public AttachmentsBulkInsert AttachmentsFor(string id);
    public CountersBulkInsert CountersFor(string id);
    public TimeSeriesBulkInsert TimeSeriesFor(string id, string name);
    public TypedTimeSeriesBulkInsert`1<TValues> TimeSeriesFor(string id, string name);
    private static void ValidateTimeSeriesName(string name);
    [AsyncStateMachineAttribute("Raven.Client.Documents.BulkInsert.BulkInsertOperation/<FlushIfNeeded>d__69")]
private Task FlushIfNeeded(bool force);
    private bool IsHeartbeatIntervalExceeded();
    [AsyncStateMachineAttribute("Raven.Client.Documents.BulkInsert.BulkInsertOperation/<<ConcurrencyCheckAsync>g__Async|45_0>d")]
[CompilerGeneratedAttribute]
private Task`1<ReleaseStream> <ConcurrencyCheckAsync>g__Async|45_0();
    [CompilerGeneratedAttribute]
private Task <Dispose>b__58_0();
}
public abstract class Raven.Client.Documents.BulkInsert.BulkInsertOperationBase`1 : object {
    private bool _streamEnsured;
    protected Task BulkInsertExecuteTask;
    protected long OperationId;
    public abstract virtual Task StoreAsync(T entity, string id);
    [AsyncStateMachineAttribute("Raven.Client.Documents.BulkInsert.BulkInsertOperationBase`1/<ExecuteBeforeStore>d__4")]
protected Task ExecuteBeforeStore();
    [AsyncStateMachineAttribute("Raven.Client.Documents.BulkInsert.BulkInsertOperationBase`1/<ThrowBulkInsertAborted>d__5")]
protected Task ThrowBulkInsertAborted(Exception e, Exception flushEx);
    protected abstract virtual Task WaitForId();
    protected abstract virtual Task EnsureStreamAsync();
    protected abstract virtual Task`1<BulkInsertAbortedException> GetExceptionFromOperation();
    public abstract virtual Task AbortAsync();
}
public class Raven.Client.Documents.BulkInsert.BulkInsertOptions : object {
    [CompilerGeneratedAttribute]
private CompressionLevel <CompressionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipOverwriteIfUnchanged>k__BackingField;
    internal TestingStuff ForTestingPurposes;
    public CompressionLevel CompressionLevel { get; public set; }
    public bool SkipOverwriteIfUnchanged { get; public set; }
    [CompilerGeneratedAttribute]
public CompressionLevel get_CompressionLevel();
    [CompilerGeneratedAttribute]
public void set_CompressionLevel(CompressionLevel value);
    [CompilerGeneratedAttribute]
public bool get_SkipOverwriteIfUnchanged();
    [CompilerGeneratedAttribute]
public void set_SkipOverwriteIfUnchanged(bool value);
    internal TestingStuff ForTestingPurposesOnly();
}
internal class Raven.Client.Documents.BulkInsert.BulkInsertWriter : BulkInsertWriterBase {
    private StreamWriter[] _writers;
    [CompilerGeneratedAttribute]
private StreamWriter <StreamWriter>k__BackingField;
    public StreamWriter StreamWriter { get; private set; }
    public BulkInsertWriter(JsonOperationContext ctx, CancellationToken token);
    [CompilerGeneratedAttribute]
public StreamWriter get_StreamWriter();
    [CompilerGeneratedAttribute]
private void set_StreamWriter(StreamWriter value);
    protected virtual void OnCurrentWriteStreamSet(MemoryStream currentWriteStream);
    [AsyncStateMachineAttribute("Raven.Client.Documents.BulkInsert.BulkInsertWriter/<FlushIfNeeded>d__7")]
public virtual Task`1<bool> FlushIfNeeded(bool force);
    public void Write(string value);
    public void Write(char value);
    public void Write(long value);
    [AsyncStateMachineAttribute("Raven.Client.Documents.BulkInsert.BulkInsertWriter/<DisposeAsync>d__11")]
public virtual ValueTask DisposeAsync();
    public Task FlushAsync();
    private static void ThrowUnexpectedWriteStream();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<bool> <>n__0(bool force);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__1();
}
internal abstract class Raven.Client.Documents.BulkInsert.BulkInsertWriterBase : object {
    protected int MaxSizeInBuffer;
    private CancellationToken _token;
    private DisposeOnceAsync`1<SingleAttempt> _disposeOnce;
    private Task _asyncWrite;
    private MemoryStream _currentWriteStream;
    private MemoryStream _backgroundWriteStream;
    private MemoryBuffer _memoryBuffer;
    private MemoryBuffer _backgroundMemoryBuffer;
    private bool _isInitialWrite;
    [CompilerGeneratedAttribute]
private DateTime <LastFlushToStream>k__BackingField;
    private Stream _requestBodyStream;
    internal BulkInsertStreamExposerContent StreamExposer;
    internal DateTime LastFlushToStream { get; private set; }
    protected BulkInsertWriterBase(JsonOperationContext ctx, CancellationToken token);
    [CompilerGeneratedAttribute]
internal DateTime get_LastFlushToStream();
    [CompilerGeneratedAttribute]
private void set_LastFlushToStream(DateTime value);
    public void Initialize();
    [AsyncStateMachineAttribute("Raven.Client.Documents.BulkInsert.BulkInsertWriterBase/<FlushIfNeeded>d__17")]
public virtual Task`1<bool> FlushIfNeeded(bool force);
    private void UpdateFlushTime();
    protected virtual void OnCurrentWriteStreamSet(MemoryStream currentWriteStream);
    protected Task WriteToStreamAsync(Stream src, Stream dst);
    protected Task WriteToRequestStreamAsync(Stream src);
    [AsyncStateMachineAttribute("Raven.Client.Documents.BulkInsert.BulkInsertWriterBase/<WriteToStreamAsync>d__22")]
private Task WriteToStreamAsync(Stream src, Stream dst, MemoryBuffer buffer, bool forceDstFlush);
    [AsyncStateMachineAttribute("Raven.Client.Documents.BulkInsert.BulkInsertWriterBase/<EnsureStreamAsync>d__23")]
public Task EnsureStreamAsync(HttpCompressionAlgorithm compressionAlgorithm, CompressionLevel compressionLevel);
    [AsyncStateMachineAttribute("Raven.Client.Documents.BulkInsert.BulkInsertWriterBase/<DisposeAsync>d__24")]
public virtual ValueTask DisposeAsync();
    public void DisposeRequestStream();
}
internal abstract class Raven.Client.Documents.Changes.AbstractDatabaseChanges`1 : object {
    private int _commandId;
    private SemaphoreSlim _semaphore;
    private MemoryStream _ms;
    protected RequestExecutor RequestExecutor;
    private string _database;
    private Action _onDispose;
    protected string _nodeTag;
    private bool _throttleConnection;
    private Lazy`1<ClientWebSocket> _lazyClient;
    private Lazy`1<Task> _task;
    private CancellationTokenSource _cts;
    private TaskCompletionSource`1<AbstractDatabaseChanges`1<TDatabaseConnectionState>> _tcs;
    private ConcurrentDictionary`2<int, TaskCompletionSource`1<object>> _confirmations;
    protected ConcurrentDictionary`2<DatabaseChangesOptions, TDatabaseConnectionState> States;
    private int _immediateConnection;
    private TaskCompletionSource`1<ChangesSupportedFeatures> _supportedFeaturesTcs;
    private ServerNode _serverNode;
    private int _nodeIndex;
    private Uri _url;
    [CompilerGeneratedAttribute]
private EventHandler ConnectionStatusChanged;
    [CompilerGeneratedAttribute]
private Action`1<Exception> OnError;
    private ClientWebSocket _client { get; }
    public bool Connected { get; }
    protected AbstractDatabaseChanges`1(RequestExecutor requestExecutor, string databaseName, Action onDispose, string nodeTag, bool throttleConnection);
    private ClientWebSocket get__client();
    internal Task`1<ChangesSupportedFeatures> GetSupportedFeaturesAsync();
    private void EnsureRunning();
    protected abstract virtual TDatabaseConnectionState CreateDatabaseConnectionState(Func`1<Task> onConnect, Func`1<Task> onDisconnect);
    protected virtual ClientWebSocket CreateClientWebSocket(RequestExecutor requestExecutor);
    private void OnConnectionStatusChanged(object sender, EventArgs e);
    public sealed virtual bool get_Connected();
    protected Task`1<AbstractDatabaseChanges`1<TDatabaseConnectionState>> EnsureConnectedNowAsync();
    [CompilerGeneratedAttribute]
public sealed virtual void add_ConnectionStatusChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ConnectionStatusChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnError(Action`1<Exception> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnError(Action`1<Exception> value);
    public sealed virtual void Dispose();
    protected TDatabaseConnectionState GetOrAddConnectionState(string name, string watchCommand, string unwatchCommand, string value, String[] values);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Changes.AbstractDatabaseChanges`1/<SendAsync>d__38")]
private Task SendAsync(string command, string value, String[] values);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Changes.AbstractDatabaseChanges`1/<DoWork>d__40")]
private Task DoWork(string nodeTag);
    private bool ReconnectClient();
    [AsyncStateMachineAttribute("Raven.Client.Documents.Changes.AbstractDatabaseChanges`1/<ProcessChanges>d__42")]
private Task ProcessChanges();
    protected abstract virtual void ProcessNotification(string type, BlittableJsonReaderObject change);
    private void ProcessConfirmationNotification(BlittableJsonReaderObject json);
    private void ProcessErrorNotification(BlittableJsonReaderObject json);
    internal virtual void NotifyAboutReconnection(Exception e);
    internal void NotifyAboutError(Exception e);
    [CompilerGeneratedAttribute]
private ClientWebSocket <.ctor>b__22_0();
    [AsyncStateMachineAttribute("Raven.Client.Documents.Changes.AbstractDatabaseChanges`1/<<-ctor>b__22_1>d")]
[CompilerGeneratedAttribute]
private Task <.ctor>b__22_1(Task`1<ChangesSupportedFeatures> t);
    [CompilerGeneratedAttribute]
private Task <.ctor>b__22_2();
    [CompilerGeneratedAttribute]
private void <.ctor>b__22_3(Task _);
    [CompilerGeneratedAttribute]
private ClientWebSocket <ReconnectClient>b__41_0();
}
internal abstract class Raven.Client.Documents.Changes.AbstractDatabaseConnectionState : object {
    [CompilerGeneratedAttribute]
private Action`1<Exception> OnError;
    private Func`1<Task> _onDisconnect;
    public Func`1<Task> OnConnect;
    private int _value;
    public Exception LastException;
    private TaskCompletionSource`1<object> _firstSet;
    private Task _connected;
    protected AbstractDatabaseConnectionState(Func`1<Task> onConnect, Func`1<Task> onDisconnect);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnError(Action`1<Exception> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnError(Action`1<Exception> value);
    public void Set(Task connection);
    public sealed virtual void Inc();
    public sealed virtual void Dec();
    public sealed virtual void Error(Exception e);
    public sealed virtual Task EnsureSubscribedNow();
    public virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <Set>b__10_0(Task t);
}
internal class Raven.Client.Documents.Changes.AggressiveCacheChange : DatabaseChange {
    internal static AggressiveCacheChange Instance;
    private static AggressiveCacheChange();
    internal static bool ShouldUpdateAggressiveCache(DocumentChange change);
    internal static bool ShouldUpdateAggressiveCache(IndexChange change);
}
internal class Raven.Client.Documents.Changes.AggressiveCacheDatabaseChanges : DatabaseChanges {
    internal AggressiveCacheDatabaseChanges(RequestExecutor requestExecutor, string databaseName, Action onDispose);
    internal virtual void NotifyAboutReconnection(Exception e);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Changes.AggressiveCacheDatabaseChanges/<EnsureConnectedNow>d__2")]
public Task`1<AggressiveCacheDatabaseChanges> EnsureConnectedNow();
}
internal class Raven.Client.Documents.Changes.ChangesObservable`2 : object {
    private TConnectionState _connectionState;
    private Func`2<T, bool> _filter;
    private ConcurrentSet`1<IObserver`1<T>> _subscribers;
    internal ChangesObservable`2(TConnectionState connectionState, Func`2<T, bool> filter);
    public sealed virtual IDisposable Subscribe(IObserver`1<T> observer);
    public void Send(T msg);
    public void Error(Exception e);
    public sealed virtual Task EnsureSubscribedNow();
}
internal class Raven.Client.Documents.Changes.ChangesSupportedFeatures : object {
    public bool TopologyChange;
    public bool AggressiveCachingChange;
}
public class Raven.Client.Documents.Changes.CounterChange : DatabaseChange {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectionName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private CounterChangeTypes <Type>k__BackingField;
    internal bool TriggeredByReplicationThread;
    public string Name { get; public set; }
    public long Value { get; public set; }
    public string DocumentId { get; public set; }
    public string CollectionName { get; public set; }
    public string ChangeVector { get; public set; }
    public CounterChangeTypes Type { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public long get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(long value);
    [CompilerGeneratedAttribute]
public string get_DocumentId();
    [CompilerGeneratedAttribute]
public void set_DocumentId(string value);
    [CompilerGeneratedAttribute]
public string get_CollectionName();
    [CompilerGeneratedAttribute]
public void set_CollectionName(string value);
    [CompilerGeneratedAttribute]
public string get_ChangeVector();
    [CompilerGeneratedAttribute]
public void set_ChangeVector(string value);
    [CompilerGeneratedAttribute]
public CounterChangeTypes get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(CounterChangeTypes value);
    public DynamicJsonValue ToJson();
    internal static CounterChange FromJson(BlittableJsonReaderObject value);
}
[FlagsAttribute]
public enum Raven.Client.Documents.Changes.CounterChangeTypes : Enum {
    public int value__;
    public static CounterChangeTypes None;
    public static CounterChangeTypes Put;
    public static CounterChangeTypes Delete;
    public static CounterChangeTypes Increment;
}
public abstract class Raven.Client.Documents.Changes.DatabaseChange : object {
}
internal class Raven.Client.Documents.Changes.DatabaseChanges : AbstractDatabaseChanges`1<DatabaseConnectionState> {
    public DatabaseChanges(RequestExecutor requestExecutor, string databaseName, Action onDispose, string nodeTag);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Changes.DatabaseChanges/<Raven-Client-Documents-Changes-IConnectableChanges<Raven-Client-Documents-Changes-IDatabaseChanges>-EnsureConnectedNow>d__1")]
private sealed virtual override Task`1<IDatabaseChanges> Raven.Client.Documents.Changes.IConnectableChanges<Raven.Client.Documents.Changes.IDatabaseChanges>.EnsureConnectedNow();
    [AsyncStateMachineAttribute("Raven.Client.Documents.Changes.DatabaseChanges/<Raven-Client-Documents-Changes-IConnectableChanges<Raven-Client-Documents-Changes-ISingleNodeDatabaseChanges>-EnsureConnectedNow>d__2")]
private sealed virtual override Task`1<ISingleNodeDatabaseChanges> Raven.Client.Documents.Changes.IConnectableChanges<Raven.Client.Documents.Changes.ISingleNodeDatabaseChanges>.EnsureConnectedNow();
    public sealed virtual IChangesObservable`1<DocumentChange> ForDocument(string docId);
    public sealed virtual IChangesObservable`1<DocumentChange> ForAllDocuments();
    internal IChangesObservable`1<AggressiveCacheChange> ForAggressiveCaching();
    public sealed virtual IChangesObservable`1<OperationStatusChange> ForOperationId(long operationId);
    public sealed virtual IChangesObservable`1<OperationStatusChange> ForAllOperations();
    public sealed virtual IChangesObservable`1<IndexChange> ForIndex(string indexName);
    public sealed virtual IChangesObservable`1<IndexChange> ForAllIndexes();
    public sealed virtual IChangesObservable`1<DocumentChange> ForDocumentsStartingWith(string docIdPrefix);
    public sealed virtual IChangesObservable`1<DocumentChange> ForDocumentsInCollection(string collectionName);
    public sealed virtual IChangesObservable`1<DocumentChange> ForDocumentsInCollection();
    public sealed virtual IChangesObservable`1<CounterChange> ForAllCounters();
    public sealed virtual IChangesObservable`1<CounterChange> ForCounter(string counterName);
    public sealed virtual IChangesObservable`1<CounterChange> ForCounterOfDocument(string documentId, string counterName);
    public sealed virtual IChangesObservable`1<CounterChange> ForCountersOfDocument(string documentId);
    public sealed virtual IChangesObservable`1<TimeSeriesChange> ForAllTimeSeries();
    public sealed virtual IChangesObservable`1<TimeSeriesChange> ForTimeSeries(string timeSeriesName);
    public sealed virtual IChangesObservable`1<TimeSeriesChange> ForTimeSeriesOfDocument(string documentId, string timeSeriesName);
    public sealed virtual IChangesObservable`1<TimeSeriesChange> ForTimeSeriesOfDocument(string documentId);
    protected virtual DatabaseConnectionState CreateDatabaseConnectionState(Func`1<Task> onConnect, Func`1<Task> onDisconnect);
    protected virtual void ProcessNotification(string type, BlittableJsonReaderObject change);
    private void NotifySubscribers(string type, BlittableJsonReaderObject value);
}
internal class Raven.Client.Documents.Changes.DatabaseChangesOptions : object {
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    public string DatabaseName { get; public set; }
    public string NodeTag { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DatabaseName();
    [CompilerGeneratedAttribute]
public void set_DatabaseName(string value);
    [CompilerGeneratedAttribute]
public string get_NodeTag();
    [CompilerGeneratedAttribute]
public void set_NodeTag(string value);
    private bool Equals(DatabaseChangesOptions other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Raven.Client.Documents.Changes.DatabaseConnectionState : AbstractDatabaseConnectionState {
    [CompilerGeneratedAttribute]
private Action`1<DocumentChange> OnDocumentChangeNotification;
    [CompilerGeneratedAttribute]
private Action`1<CounterChange> OnCounterChangeNotification;
    [CompilerGeneratedAttribute]
private Action`1<IndexChange> OnIndexChangeNotification;
    [CompilerGeneratedAttribute]
private Action`1<OperationStatusChange> OnOperationStatusChangeNotification;
    [CompilerGeneratedAttribute]
private Action`1<AggressiveCacheChange> OnAggressiveCacheChangeNotification;
    [CompilerGeneratedAttribute]
private Action`1<TimeSeriesChange> OnTimeSeriesChangeNotification;
    public DatabaseConnectionState(Func`1<Task> onConnect, Func`1<Task> onDisconnect);
    [CompilerGeneratedAttribute]
private void add_OnDocumentChangeNotification(Action`1<DocumentChange> value);
    [CompilerGeneratedAttribute]
private void remove_OnDocumentChangeNotification(Action`1<DocumentChange> value);
    [CompilerGeneratedAttribute]
private void add_OnCounterChangeNotification(Action`1<CounterChange> value);
    [CompilerGeneratedAttribute]
private void remove_OnCounterChangeNotification(Action`1<CounterChange> value);
    [CompilerGeneratedAttribute]
private void add_OnIndexChangeNotification(Action`1<IndexChange> value);
    [CompilerGeneratedAttribute]
private void remove_OnIndexChangeNotification(Action`1<IndexChange> value);
    [CompilerGeneratedAttribute]
private void add_OnOperationStatusChangeNotification(Action`1<OperationStatusChange> value);
    [CompilerGeneratedAttribute]
private void remove_OnOperationStatusChangeNotification(Action`1<OperationStatusChange> value);
    [CompilerGeneratedAttribute]
private void add_OnAggressiveCacheChangeNotification(Action`1<AggressiveCacheChange> value);
    [CompilerGeneratedAttribute]
private void remove_OnAggressiveCacheChangeNotification(Action`1<AggressiveCacheChange> value);
    [CompilerGeneratedAttribute]
private void add_OnTimeSeriesChangeNotification(Action`1<TimeSeriesChange> value);
    [CompilerGeneratedAttribute]
private void remove_OnTimeSeriesChangeNotification(Action`1<TimeSeriesChange> value);
    public void Send(DocumentChange documentChange);
    public void Send(CounterChange counterChange);
    public void Send(TimeSeriesChange timeSeriesChange);
    public void Send(IndexChange indexChange);
    public void Send(OperationStatusChange operationStatusChange);
    public void Send(AggressiveCacheChange aggressiveCacheChange);
    private sealed virtual override void Raven.Client.Documents.Changes.IChangesConnectionState<Raven.Client.Documents.Changes.TimeSeriesChange>.add_OnChangeNotification(Action`1<TimeSeriesChange> value);
    private sealed virtual override void Raven.Client.Documents.Changes.IChangesConnectionState<Raven.Client.Documents.Changes.TimeSeriesChange>.remove_OnChangeNotification(Action`1<TimeSeriesChange> value);
    private sealed virtual override void Raven.Client.Documents.Changes.IChangesConnectionState<Raven.Client.Documents.Changes.CounterChange>.add_OnChangeNotification(Action`1<CounterChange> value);
    private sealed virtual override void Raven.Client.Documents.Changes.IChangesConnectionState<Raven.Client.Documents.Changes.CounterChange>.remove_OnChangeNotification(Action`1<CounterChange> value);
    private sealed virtual override void Raven.Client.Documents.Changes.IChangesConnectionState<Raven.Client.Documents.Operations.OperationStatusChange>.add_OnChangeNotification(Action`1<OperationStatusChange> value);
    private sealed virtual override void Raven.Client.Documents.Changes.IChangesConnectionState<Raven.Client.Documents.Operations.OperationStatusChange>.remove_OnChangeNotification(Action`1<OperationStatusChange> value);
    private sealed virtual override void Raven.Client.Documents.Changes.IChangesConnectionState<Raven.Client.Documents.Changes.IndexChange>.add_OnChangeNotification(Action`1<IndexChange> value);
    private sealed virtual override void Raven.Client.Documents.Changes.IChangesConnectionState<Raven.Client.Documents.Changes.IndexChange>.remove_OnChangeNotification(Action`1<IndexChange> value);
    private sealed virtual override void Raven.Client.Documents.Changes.IChangesConnectionState<Raven.Client.Documents.Changes.DocumentChange>.add_OnChangeNotification(Action`1<DocumentChange> value);
    private sealed virtual override void Raven.Client.Documents.Changes.IChangesConnectionState<Raven.Client.Documents.Changes.DocumentChange>.remove_OnChangeNotification(Action`1<DocumentChange> value);
    private sealed virtual override void Raven.Client.Documents.Changes.IChangesConnectionState<Raven.Client.Documents.Changes.AggressiveCacheChange>.add_OnChangeNotification(Action`1<AggressiveCacheChange> value);
    private sealed virtual override void Raven.Client.Documents.Changes.IChangesConnectionState<Raven.Client.Documents.Changes.AggressiveCacheChange>.remove_OnChangeNotification(Action`1<AggressiveCacheChange> value);
    public virtual void Dispose();
}
public class Raven.Client.Documents.Changes.DocumentChange : DatabaseChange {
    [CompilerGeneratedAttribute]
private DocumentChangeTypes <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectionName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    internal bool TriggeredByReplicationThread;
    public DocumentChangeTypes Type { get; public set; }
    public string Id { get; public set; }
    public string CollectionName { get; public set; }
    public string ChangeVector { get; public set; }
    [CompilerGeneratedAttribute]
public DocumentChangeTypes get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(DocumentChangeTypes value);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_CollectionName();
    [CompilerGeneratedAttribute]
public void set_CollectionName(string value);
    [CompilerGeneratedAttribute]
public string get_ChangeVector();
    [CompilerGeneratedAttribute]
public void set_ChangeVector(string value);
    public virtual string ToString();
    public DynamicJsonValue ToJson();
    internal static DocumentChange FromJson(BlittableJsonReaderObject value);
}
[FlagsAttribute]
public enum Raven.Client.Documents.Changes.DocumentChangeTypes : Enum {
    public int value__;
    public static DocumentChangeTypes None;
    public static DocumentChangeTypes Put;
    public static DocumentChangeTypes Delete;
    public static DocumentChangeTypes BulkInsertStarted;
    public static DocumentChangeTypes BulkInsertEnded;
    public static DocumentChangeTypes BulkInsertError;
    public static DocumentChangeTypes DeleteOnTombstoneReplication;
    public static DocumentChangeTypes Conflict;
    public static DocumentChangeTypes Common;
}
internal class Raven.Client.Documents.Changes.EvictItemsFromCacheBasedOnChanges : object {
    private AggressiveCacheDatabaseChanges _changes;
    private IDisposable _documentsSubscription;
    private IDisposable _indexesSubscription;
    private RequestExecutor _requestExecutor;
    private Task _taskConnected;
    private IDisposable _aggressiveCachingSubscription;
    public EvictItemsFromCacheBasedOnChanges(DocumentStore store, string databaseName);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Changes.EvictItemsFromCacheBasedOnChanges/<EnsureConnectedInternalAsync>d__7")]
private Task EnsureConnectedInternalAsync();
    public void EnsureConnected();
    public Task EnsureConnectedAsync();
    public sealed virtual void OnNext(DocumentChange change);
    public sealed virtual void OnNext(IndexChange change);
    public sealed virtual void OnNext(AggressiveCacheChange value);
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnCompleted();
    public sealed virtual void Dispose();
}
internal interface Raven.Client.Documents.Changes.IChangesConnectionState`1 {
    public abstract virtual void Inc();
    public abstract virtual void Dec();
    public abstract virtual void Error(Exception e);
    public abstract virtual Task EnsureSubscribedNow();
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnChangeNotification(Action`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnChangeNotification(Action`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnError(Action`1<Exception> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnError(Action`1<Exception> value);
}
public interface Raven.Client.Documents.Changes.IChangesObservable`1 {
    public abstract virtual Task EnsureSubscribedNow();
}
public interface Raven.Client.Documents.Changes.IConnectableChanges`1 {
    public bool Connected { get; }
    public abstract virtual bool get_Connected();
    public abstract virtual Task`1<TChanges> EnsureConnectedNow();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ConnectionStatusChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ConnectionStatusChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnError(Action`1<Exception> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnError(Action`1<Exception> value);
}
public interface Raven.Client.Documents.Changes.ICounterChanges`1 {
    public abstract virtual IChangesObservable`1<TChange> ForAllCounters();
    public abstract virtual IChangesObservable`1<TChange> ForCounter(string counterName);
    public abstract virtual IChangesObservable`1<TChange> ForCounterOfDocument(string documentId, string counterName);
    public abstract virtual IChangesObservable`1<TChange> ForCountersOfDocument(string documentId);
}
public interface Raven.Client.Documents.Changes.IDatabaseChanges {
}
public interface Raven.Client.Documents.Changes.IDocumentChanges`1 {
    public abstract virtual IChangesObservable`1<TChange> ForDocument(string docId);
    public abstract virtual IChangesObservable`1<TChange> ForAllDocuments();
    public abstract virtual IChangesObservable`1<TChange> ForDocumentsStartingWith(string docIdPrefix);
    public abstract virtual IChangesObservable`1<TChange> ForDocumentsInCollection(string collectionName);
    public abstract virtual IChangesObservable`1<TChange> ForDocumentsInCollection();
}
public interface Raven.Client.Documents.Changes.IIndexChanges`1 {
    public abstract virtual IChangesObservable`1<TChange> ForIndex(string indexName);
    public abstract virtual IChangesObservable`1<TChange> ForAllIndexes();
}
public class Raven.Client.Documents.Changes.IndexChange : DatabaseChange {
    [CompilerGeneratedAttribute]
private IndexChangeTypes <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public IndexChangeTypes Type { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public IndexChangeTypes get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IndexChangeTypes value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public virtual string ToString();
    public DynamicJsonValue ToJson();
    internal static IndexChange FromJson(BlittableJsonReaderObject value);
}
[FlagsAttribute]
public enum Raven.Client.Documents.Changes.IndexChangeTypes : Enum {
    public int value__;
    public static IndexChangeTypes None;
    public static IndexChangeTypes BatchCompleted;
    public static IndexChangeTypes IndexAdded;
    public static IndexChangeTypes IndexRemoved;
    public static IndexChangeTypes IndexDemotedToIdle;
    public static IndexChangeTypes IndexPromotedFromIdle;
    public static IndexChangeTypes IndexDemotedToDisabled;
    public static IndexChangeTypes IndexMarkedAsErrored;
    public static IndexChangeTypes SideBySideReplace;
    public static IndexChangeTypes Renamed;
    public static IndexChangeTypes IndexPaused;
    public static IndexChangeTypes LockModeChanged;
    public static IndexChangeTypes PriorityChanged;
    public static IndexChangeTypes RollingIndexChanged;
}
public class Raven.Client.Documents.Changes.IndexRenameChange : IndexChange {
    [CompilerGeneratedAttribute]
private string <OldIndexName>k__BackingField;
    public string OldIndexName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_OldIndexName();
    [CompilerGeneratedAttribute]
public void set_OldIndexName(string value);
}
public interface Raven.Client.Documents.Changes.IOperationChanges`1 {
    public abstract virtual IChangesObservable`1<TChange> ForOperationId(long operationId);
    public abstract virtual IChangesObservable`1<TChange> ForAllOperations();
}
public interface Raven.Client.Documents.Changes.ISingleNodeDatabaseChanges {
}
public interface Raven.Client.Documents.Changes.ITimeSeriesChanges`1 {
    public abstract virtual IChangesObservable`1<TChange> ForAllTimeSeries();
    public abstract virtual IChangesObservable`1<TChange> ForTimeSeries(string timeSeriesName);
    public abstract virtual IChangesObservable`1<TChange> ForTimeSeriesOfDocument(string documentId, string timeSeriesName);
    public abstract virtual IChangesObservable`1<TChange> ForTimeSeriesOfDocument(string documentId);
}
public class Raven.Client.Documents.Changes.TimeSeriesChange : DatabaseChange {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <From>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <To>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSeriesChangeTypes <Type>k__BackingField;
    internal bool TriggeredByReplicationThread;
    [CompilerGeneratedAttribute]
private string <CollectionName>k__BackingField;
    public string Name { get; public set; }
    public DateTime From { get; public set; }
    public DateTime To { get; public set; }
    public string DocumentId { get; public set; }
    public string ChangeVector { get; public set; }
    public TimeSeriesChangeTypes Type { get; public set; }
    public string CollectionName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public DateTime get_From();
    [CompilerGeneratedAttribute]
public void set_From(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_To();
    [CompilerGeneratedAttribute]
public void set_To(DateTime value);
    [CompilerGeneratedAttribute]
public string get_DocumentId();
    [CompilerGeneratedAttribute]
public void set_DocumentId(string value);
    [CompilerGeneratedAttribute]
public string get_ChangeVector();
    [CompilerGeneratedAttribute]
public void set_ChangeVector(string value);
    [CompilerGeneratedAttribute]
public TimeSeriesChangeTypes get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(TimeSeriesChangeTypes value);
    [CompilerGeneratedAttribute]
public string get_CollectionName();
    [CompilerGeneratedAttribute]
public void set_CollectionName(string value);
    public DynamicJsonValue ToJson();
    internal static TimeSeriesChange FromJson(BlittableJsonReaderObject value);
}
[FlagsAttribute]
public enum Raven.Client.Documents.Changes.TimeSeriesChangeTypes : Enum {
    public int value__;
    public static TimeSeriesChangeTypes None;
    public static TimeSeriesChangeTypes Put;
    public static TimeSeriesChangeTypes Delete;
    public static TimeSeriesChangeTypes Mixed;
}
public class Raven.Client.Documents.Changes.TopologyChange : DatabaseChange {
    public string Url;
    public string Database;
    public DynamicJsonValue ToJson();
    internal static TopologyChange FromJson(BlittableJsonReaderObject value);
}
internal abstract class Raven.Client.Documents.Changes.TrafficWatchChangeBase : DatabaseChange {
    [CompilerGeneratedAttribute]
private DateTime <TimeStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CustomInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientIP>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificateThumbprint>k__BackingField;
    public TrafficWatchType TrafficWatchType { get; }
    public DateTime TimeStamp { get; public set; }
    public string DatabaseName { get; public set; }
    public string CustomInfo { get; public set; }
    public string ClientIP { get; public set; }
    public string CertificateThumbprint { get; public set; }
    public abstract virtual TrafficWatchType get_TrafficWatchType();
    [CompilerGeneratedAttribute]
public DateTime get_TimeStamp();
    [CompilerGeneratedAttribute]
public void set_TimeStamp(DateTime value);
    [CompilerGeneratedAttribute]
public string get_DatabaseName();
    [CompilerGeneratedAttribute]
public void set_DatabaseName(string value);
    [CompilerGeneratedAttribute]
public string get_CustomInfo();
    [CompilerGeneratedAttribute]
public void set_CustomInfo(string value);
    [CompilerGeneratedAttribute]
public string get_ClientIP();
    [CompilerGeneratedAttribute]
public void set_ClientIP(string value);
    [CompilerGeneratedAttribute]
public string get_CertificateThumbprint();
    [CompilerGeneratedAttribute]
public void set_CertificateThumbprint(string value);
    public virtual DynamicJsonValue ToJson();
}
public enum Raven.Client.Documents.Changes.TrafficWatchChangeType : Enum {
    public int value__;
    public static TrafficWatchChangeType None;
    public static TrafficWatchChangeType Queries;
    public static TrafficWatchChangeType Operations;
    public static TrafficWatchChangeType MultiGet;
    public static TrafficWatchChangeType BulkDocs;
    public static TrafficWatchChangeType Index;
    public static TrafficWatchChangeType Counters;
    public static TrafficWatchChangeType Hilo;
    public static TrafficWatchChangeType Subscriptions;
    public static TrafficWatchChangeType Streams;
    public static TrafficWatchChangeType Documents;
    public static TrafficWatchChangeType TimeSeries;
    public static TrafficWatchChangeType Notifications;
    public static TrafficWatchChangeType ClusterCommands;
}
internal class Raven.Client.Documents.Changes.TrafficWatchHttpChange : TrafficWatchChangeBase {
    [CompilerGeneratedAttribute]
private long <RequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HttpMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ElapsedMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ResponseStatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RequestUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AbsoluteUri>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RequestSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ResponseSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private TrafficWatchChangeType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryTimings <QueryTimings>k__BackingField;
    public TrafficWatchType TrafficWatchType { get; }
    public long RequestId { get; public set; }
    public string HttpMethod { get; public set; }
    public long ElapsedMilliseconds { get; public set; }
    public int ResponseStatusCode { get; public set; }
    public string RequestUri { get; public set; }
    public string AbsoluteUri { get; public set; }
    public long RequestSizeInBytes { get; public set; }
    public long ResponseSizeInBytes { get; public set; }
    public TrafficWatchChangeType Type { get; public set; }
    public QueryTimings QueryTimings { get; public set; }
    public virtual TrafficWatchType get_TrafficWatchType();
    [CompilerGeneratedAttribute]
public long get_RequestId();
    [CompilerGeneratedAttribute]
public void set_RequestId(long value);
    [CompilerGeneratedAttribute]
public string get_HttpMethod();
    [CompilerGeneratedAttribute]
public void set_HttpMethod(string value);
    [CompilerGeneratedAttribute]
public long get_ElapsedMilliseconds();
    [CompilerGeneratedAttribute]
public void set_ElapsedMilliseconds(long value);
    [CompilerGeneratedAttribute]
public int get_ResponseStatusCode();
    [CompilerGeneratedAttribute]
public void set_ResponseStatusCode(int value);
    [CompilerGeneratedAttribute]
public string get_RequestUri();
    [CompilerGeneratedAttribute]
public void set_RequestUri(string value);
    [CompilerGeneratedAttribute]
public string get_AbsoluteUri();
    [CompilerGeneratedAttribute]
public void set_AbsoluteUri(string value);
    [CompilerGeneratedAttribute]
public long get_RequestSizeInBytes();
    [CompilerGeneratedAttribute]
public void set_RequestSizeInBytes(long value);
    [CompilerGeneratedAttribute]
public long get_ResponseSizeInBytes();
    [CompilerGeneratedAttribute]
public void set_ResponseSizeInBytes(long value);
    [CompilerGeneratedAttribute]
public TrafficWatchChangeType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(TrafficWatchChangeType value);
    [CompilerGeneratedAttribute]
public QueryTimings get_QueryTimings();
    [CompilerGeneratedAttribute]
public void set_QueryTimings(QueryTimings value);
    public virtual DynamicJsonValue ToJson();
}
internal class Raven.Client.Documents.Changes.TrafficWatchTcpChange : TrafficWatchChangeBase {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private OperationTypes <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OperationVersion>k__BackingField;
    public TrafficWatchType TrafficWatchType { get; }
    public string Source { get; public set; }
    public OperationTypes Operation { get; public set; }
    public int OperationVersion { get; public set; }
    public virtual TrafficWatchType get_TrafficWatchType();
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public OperationTypes get_Operation();
    [CompilerGeneratedAttribute]
public void set_Operation(OperationTypes value);
    [CompilerGeneratedAttribute]
public int get_OperationVersion();
    [CompilerGeneratedAttribute]
public void set_OperationVersion(int value);
    public virtual DynamicJsonValue ToJson();
}
public enum Raven.Client.Documents.Changes.TrafficWatchType : Enum {
    public int value__;
    public static TrafficWatchType Http;
    public static TrafficWatchType Tcp;
}
public abstract class Raven.Client.Documents.Commands.AbstractQueryCommand`2 : RavenCommand`1<TResult> {
    private static TimeSpan AdditionalTimeToAddToTimeout;
    private bool _metadataOnly;
    private bool _indexEntriesOnly;
    private bool _ignoreLimit;
    public bool IsReadRequest { get; }
    protected AbstractQueryCommand`2(IndexQueryBase`1<TParameters> indexQuery, bool canCache, bool metadataOnly, bool indexEntriesOnly, bool ignoreLimit, TimeSpan globalHttpClientTimeout);
    private static AbstractQueryCommand`2();
    public virtual bool get_IsReadRequest();
    protected abstract virtual ulong GetQueryHash(JsonOperationContext ctx);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    protected abstract virtual HttpContent GetContent(JsonOperationContext ctx);
    protected static BlittableJsonReaderObject HandleCachedResponse(JsonOperationContext context, BlittableJsonReaderObject response);
}
public abstract class Raven.Client.Documents.Commands.AbstractStreamResult : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataDictionary <Metadata>k__BackingField;
    public string Id { get; public set; }
    public string ChangeVector { get; public set; }
    public IMetadataDictionary Metadata { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_ChangeVector();
    [CompilerGeneratedAttribute]
public void set_ChangeVector(string value);
    [CompilerGeneratedAttribute]
public IMetadataDictionary get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(IMetadataDictionary value);
}
public class Raven.Client.Documents.Commands.Batches.BatchOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private ReplicationBatchOptions <ReplicationOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexBatchOptions <IndexOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private ShardedBatchOptions <ShardedOptions>k__BackingField;
    public Nullable`1<TimeSpan> RequestTimeout { get; public set; }
    public ReplicationBatchOptions ReplicationOptions { get; public set; }
    public IndexBatchOptions IndexOptions { get; public set; }
    public ShardedBatchOptions ShardedOptions { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public ReplicationBatchOptions get_ReplicationOptions();
    [CompilerGeneratedAttribute]
public void set_ReplicationOptions(ReplicationBatchOptions value);
    [CompilerGeneratedAttribute]
public IndexBatchOptions get_IndexOptions();
    [CompilerGeneratedAttribute]
public void set_IndexOptions(IndexBatchOptions value);
    [CompilerGeneratedAttribute]
public ShardedBatchOptions get_ShardedOptions();
    [CompilerGeneratedAttribute]
public void set_ShardedOptions(ShardedBatchOptions value);
}
public class Raven.Client.Documents.Commands.Batches.BatchPatchCommandData : object {
    private HashSet`1<string> _seenIds;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<string, string>> _ids;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private PatchRequest <Patch>k__BackingField;
    [CompilerGeneratedAttribute]
private PatchRequest <PatchIfMissing>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<ValueTuple`2<string, string>> Ids { get; }
    public string Id { get; }
    public string Name { get; }
    public PatchRequest Patch { get; }
    public PatchRequest PatchIfMissing { get; }
    public string ChangeVector { get; }
    public CommandType Type { get; }
    private BatchPatchCommandData(PatchRequest patch, PatchRequest patchIfMissing);
    public BatchPatchCommandData(IList`1<string> ids, PatchRequest patch, PatchRequest patchIfMissing);
    public BatchPatchCommandData(IList`1<ValueTuple`2<string, string>> ids, PatchRequest patch, PatchRequest patchIfMissing);
    private void Add(string id, string changeVector);
    public IReadOnlyList`1<ValueTuple`2<string, string>> get_Ids();
    public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public PatchRequest get_Patch();
    [CompilerGeneratedAttribute]
public PatchRequest get_PatchIfMissing();
    public sealed virtual string get_ChangeVector();
    public sealed virtual CommandType get_Type();
    public sealed virtual DynamicJsonValue ToJson(DocumentConventions conventions, JsonOperationContext context);
    public sealed virtual void OnBeforeSaveChanges(InMemoryDocumentSessionOperations session);
}
internal class Raven.Client.Documents.Commands.Batches.ClusterWideBatchCommand : SingleNodeBatchCommand {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <DisableAtomicDocumentWrites>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RaftUniqueRequestId>k__BackingField;
    public Nullable`1<bool> DisableAtomicDocumentWrites { get; }
    public string RaftUniqueRequestId { get; }
    public ClusterWideBatchCommand(DocumentConventions conventions, IList`1<ICommandData> commands, BatchOptions options, Nullable`1<bool> disableAtomicDocumentsWrites);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_DisableAtomicDocumentWrites();
    [CompilerGeneratedAttribute]
public sealed virtual string get_RaftUniqueRequestId();
    protected virtual void AppendOptions(StringBuilder sb);
}
public enum Raven.Client.Documents.Commands.Batches.CommandType : Enum {
    public int value__;
    public static CommandType None;
    public static CommandType PUT;
    public static CommandType PATCH;
    public static CommandType DELETE;
    public static CommandType AttachmentPUT;
    public static CommandType AttachmentDELETE;
    public static CommandType AttachmentMOVE;
    public static CommandType AttachmentCOPY;
    public static CommandType CompareExchangePUT;
    public static CommandType CompareExchangeDELETE;
    public static CommandType ForceRevisionCreation;
    public static CommandType Counters;
    public static CommandType TimeSeries;
    public static CommandType TimeSeriesWithIncrements;
    public static CommandType TimeSeriesBulkInsert;
    public static CommandType TimeSeriesCopy;
    public static CommandType BatchPATCH;
    public static CommandType JsonPatch;
    public static CommandType ClientAnyCommand;
    public static CommandType ClientModifyDocumentCommand;
    public static CommandType HeartBeat;
}
public class Raven.Client.Documents.Commands.Batches.CopyAttachmentCommandData : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandType <Type>k__BackingField;
    public string Id { get; }
    public string Name { get; }
    public string DestinationId { get; }
    public string DestinationName { get; }
    public string ChangeVector { get; }
    public CommandType Type { get; }
    public CopyAttachmentCommandData(string sourceDocumentId, string sourceName, string destinationDocumentId, string destinationName, string changeVector);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public string get_DestinationId();
    [CompilerGeneratedAttribute]
public string get_DestinationName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ChangeVector();
    [CompilerGeneratedAttribute]
public sealed virtual CommandType get_Type();
    public sealed virtual DynamicJsonValue ToJson(DocumentConventions conventions, JsonOperationContext context);
    public sealed virtual void OnBeforeSaveChanges(InMemoryDocumentSessionOperations session);
}
internal class Raven.Client.Documents.Commands.Batches.CopyTimeSeriesCommandData : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <From>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <To>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandType <Type>k__BackingField;
    public string Id { get; }
    public string Name { get; }
    public string ChangeVector { get; }
    public string DestinationId { get; }
    public string DestinationName { get; }
    public Nullable`1<DateTime> From { get; }
    public Nullable`1<DateTime> To { get; }
    public CommandType Type { get; }
    public CopyTimeSeriesCommandData(string sourceDocumentId, string sourceName, string destinationDocumentId, string destinationName, Nullable`1<DateTime> from, Nullable`1<DateTime> to);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ChangeVector();
    [CompilerGeneratedAttribute]
public string get_DestinationId();
    [CompilerGeneratedAttribute]
public string get_DestinationName();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_From();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_To();
    [CompilerGeneratedAttribute]
public sealed virtual CommandType get_Type();
    public sealed virtual DynamicJsonValue ToJson(DocumentConventions conventions, JsonOperationContext context);
    public sealed virtual void OnBeforeSaveChanges(InMemoryDocumentSessionOperations session);
}
public class Raven.Client.Documents.Commands.Batches.CountersBatchCommandData : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <FromEtl>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentCountersOperation <Counters>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandType <Type>k__BackingField;
    public string Id { get; }
    public string Name { get; }
    public string ChangeVector { get; }
    internal Nullable`1<bool> FromEtl { get; internal set; }
    public DocumentCountersOperation Counters { get; }
    public CommandType Type { get; }
    public CountersBatchCommandData(string documentId, CounterOperation counterOperation);
    public CountersBatchCommandData(string documentId, List`1<CounterOperation> counterOperations);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ChangeVector();
    [CompilerGeneratedAttribute]
internal Nullable`1<bool> get_FromEtl();
    [CompilerGeneratedAttribute]
internal void set_FromEtl(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public DocumentCountersOperation get_Counters();
    [CompilerGeneratedAttribute]
public sealed virtual CommandType get_Type();
    public bool HasDelete(string counterName);
    public bool HasIncrement(string counterName);
    private bool HasOperationOfType(CounterOperationType type, string counterName);
    public sealed virtual DynamicJsonValue ToJson(DocumentConventions conventions, JsonOperationContext context);
    public sealed virtual void OnBeforeSaveChanges(InMemoryDocumentSessionOperations session);
}
public class Raven.Client.Documents.Commands.Batches.DeleteAttachmentCommandData : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandType <Type>k__BackingField;
    public string Id { get; }
    public string Name { get; }
    public string ChangeVector { get; }
    public CommandType Type { get; }
    public DeleteAttachmentCommandData(string documentId, string name, string changeVector);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ChangeVector();
    [CompilerGeneratedAttribute]
public sealed virtual CommandType get_Type();
    public sealed virtual DynamicJsonValue ToJson(DocumentConventions conventions, JsonOperationContext context);
    public sealed virtual void OnBeforeSaveChanges(InMemoryDocumentSessionOperations session);
}
public class Raven.Client.Documents.Commands.Batches.DeleteCommandData : object {
    [CompilerGeneratedAttribute]
private string <OriginalChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <Document>k__BackingField;
    public string OriginalChangeVector { get; }
    public string Id { get; }
    public string Name { get; }
    public string ChangeVector { get; }
    public CommandType Type { get; }
    public BlittableJsonReaderObject Document { get; public set; }
    public DeleteCommandData(string id, string changeVector);
    public DeleteCommandData(string id, string changeVector, string originalChangeVector);
    [CompilerGeneratedAttribute]
public string get_OriginalChangeVector();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ChangeVector();
    [CompilerGeneratedAttribute]
public sealed virtual CommandType get_Type();
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_Document();
    [CompilerGeneratedAttribute]
public void set_Document(BlittableJsonReaderObject value);
    public virtual DynamicJsonValue ToJson(DocumentConventions conventions, JsonOperationContext context);
    public sealed virtual void OnBeforeSaveChanges(InMemoryDocumentSessionOperations session);
}
public class Raven.Client.Documents.Commands.Batches.DeleteCompareExchangeCommandData : object {
    public long Index;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    public string Id { get; }
    public string Name { get; }
    public string ChangeVector { get; }
    public CommandType Type { get; }
    public DeleteCompareExchangeCommandData(string key, long index);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    public sealed virtual string get_Name();
    public sealed virtual string get_ChangeVector();
    public sealed virtual CommandType get_Type();
    public sealed virtual DynamicJsonValue ToJson(DocumentConventions conventions, JsonOperationContext context);
    public sealed virtual void OnBeforeSaveChanges(InMemoryDocumentSessionOperations session);
}
public class Raven.Client.Documents.Commands.Batches.DeletePrefixedCommandData : DeleteCommandData {
    private bool IdPrefixed { get; }
    public DeletePrefixedCommandData(string prefix);
    private bool get_IdPrefixed();
    public virtual DynamicJsonValue ToJson(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Commands.Batches.ForceRevisionCommandData : object {
    [CompilerGeneratedAttribute]
private CommandType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    public CommandType Type { get; }
    public string Id { get; }
    public string Name { get; }
    public string ChangeVector { get; }
    public ForceRevisionCommandData(string id);
    [CompilerGeneratedAttribute]
public sealed virtual CommandType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ChangeVector();
    public sealed virtual DynamicJsonValue ToJson(DocumentConventions conventions, JsonOperationContext context);
    public sealed virtual void OnBeforeSaveChanges(InMemoryDocumentSessionOperations session);
}
public interface Raven.Client.Documents.Commands.Batches.ICommandData {
    public string Id { get; }
    public string Name { get; }
    public string ChangeVector { get; }
    public CommandType Type { get; }
    public abstract virtual string get_Id();
    public abstract virtual string get_Name();
    public abstract virtual string get_ChangeVector();
    public abstract virtual CommandType get_Type();
    public abstract virtual DynamicJsonValue ToJson(DocumentConventions conventions, JsonOperationContext context);
    public abstract virtual void OnBeforeSaveChanges(InMemoryDocumentSessionOperations session);
}
public class Raven.Client.Documents.Commands.Batches.IncrementalTimeSeriesBatchCommandData : TimeSeriesCommandData {
    public CommandType Type { get; }
    public IncrementalTimeSeriesBatchCommandData(string documentId, string name, IList`1<IncrementOperation> increments);
    public virtual CommandType get_Type();
}
public class Raven.Client.Documents.Commands.Batches.IndexBatchOptions : object {
    [CompilerGeneratedAttribute]
private bool <WaitForIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <WaitForIndexesTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowOnTimeoutInWaitForIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <WaitForSpecificIndexes>k__BackingField;
    public bool WaitForIndexes { get; public set; }
    public TimeSpan WaitForIndexesTimeout { get; public set; }
    public bool ThrowOnTimeoutInWaitForIndexes { get; public set; }
    public String[] WaitForSpecificIndexes { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_WaitForIndexes();
    [CompilerGeneratedAttribute]
public void set_WaitForIndexes(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_WaitForIndexesTimeout();
    [CompilerGeneratedAttribute]
public void set_WaitForIndexesTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_ThrowOnTimeoutInWaitForIndexes();
    [CompilerGeneratedAttribute]
public void set_ThrowOnTimeoutInWaitForIndexes(bool value);
    [CompilerGeneratedAttribute]
public String[] get_WaitForSpecificIndexes();
    [CompilerGeneratedAttribute]
public void set_WaitForSpecificIndexes(String[] value);
}
public class Raven.Client.Documents.Commands.Batches.JsonPatchCommandData : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPatchDocument <JsonPatch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    private bool ReturnDocument;
    [CompilerGeneratedAttribute]
private CommandType <Type>k__BackingField;
    public string Id { get; }
    public JsonPatchDocument JsonPatch { get; }
    public string Name { get; }
    public string ChangeVector { get; }
    public CommandType Type { get; }
    public JsonPatchCommandData(string id, JsonPatchDocument patch);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public JsonPatchDocument get_JsonPatch();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ChangeVector();
    [CompilerGeneratedAttribute]
public sealed virtual CommandType get_Type();
    public sealed virtual DynamicJsonValue ToJson(DocumentConventions conventions, JsonOperationContext context);
    public sealed virtual void OnBeforeSaveChanges(InMemoryDocumentSessionOperations session);
}
public class Raven.Client.Documents.Commands.Batches.MoveAttachmentCommandData : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandType <Type>k__BackingField;
    public string Id { get; }
    public string Name { get; }
    public string DestinationId { get; }
    public string DestinationName { get; }
    public string ChangeVector { get; }
    public CommandType Type { get; }
    public MoveAttachmentCommandData(string documentId, string name, string destinationDocumentId, string destinationName, string changeVector);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public string get_DestinationId();
    [CompilerGeneratedAttribute]
public string get_DestinationName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ChangeVector();
    [CompilerGeneratedAttribute]
public sealed virtual CommandType get_Type();
    public sealed virtual DynamicJsonValue ToJson(DocumentConventions conventions, JsonOperationContext context);
    public sealed virtual void OnBeforeSaveChanges(InMemoryDocumentSessionOperations session);
}
public class Raven.Client.Documents.Commands.Batches.PatchCommandData : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <CreateIfMissing>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private PatchRequest <Patch>k__BackingField;
    [CompilerGeneratedAttribute]
private PatchRequest <PatchIfMissing>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReturnDocument>k__BackingField;
    public string Id { get; }
    public string Name { get; }
    public BlittableJsonReaderObject CreateIfMissing { get; public set; }
    public string ChangeVector { get; }
    public PatchRequest Patch { get; }
    public PatchRequest PatchIfMissing { get; }
    public CommandType Type { get; }
    public bool ReturnDocument { get; private set; }
    public PatchCommandData(string id, string changeVector, PatchRequest patch);
    public PatchCommandData(string id, string changeVector, PatchRequest patch, PatchRequest patchIfMissing);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_CreateIfMissing();
    [CompilerGeneratedAttribute]
public void set_CreateIfMissing(BlittableJsonReaderObject value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ChangeVector();
    [CompilerGeneratedAttribute]
public PatchRequest get_Patch();
    [CompilerGeneratedAttribute]
public PatchRequest get_PatchIfMissing();
    [CompilerGeneratedAttribute]
public sealed virtual CommandType get_Type();
    [CompilerGeneratedAttribute]
public bool get_ReturnDocument();
    [CompilerGeneratedAttribute]
private void set_ReturnDocument(bool value);
    public sealed virtual DynamicJsonValue ToJson(DocumentConventions conventions, JsonOperationContext context);
    public sealed virtual void OnBeforeSaveChanges(InMemoryDocumentSessionOperations session);
}
public class Raven.Client.Documents.Commands.Batches.PutAttachmentCommandData : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FromEtl>k__BackingField;
    public string Id { get; }
    public string Name { get; }
    public Stream Stream { get; }
    public string ChangeVector { get; }
    public string ContentType { get; }
    public CommandType Type { get; }
    public bool FromEtl { get; }
    public PutAttachmentCommandData(string documentId, string name, Stream stream, string contentType, string changeVector);
    internal PutAttachmentCommandData(string documentId, string name, Stream stream, string contentType, string changeVector, bool fromEtl);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public Stream get_Stream();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ChangeVector();
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
public sealed virtual CommandType get_Type();
    [CompilerGeneratedAttribute]
public bool get_FromEtl();
    public sealed virtual DynamicJsonValue ToJson(DocumentConventions conventions, JsonOperationContext context);
    public sealed virtual void OnBeforeSaveChanges(InMemoryDocumentSessionOperations session);
}
internal static class Raven.Client.Documents.Commands.Batches.PutAttachmentCommandHelper : object {
    public static void ThrowStreamWasAlreadyUsed();
    private static void ThrowPositionNotZero(long streamPosition);
    private static void ThrowNotSeekableStream();
    private static void ThrowNotReadableStream();
    public static void PrepareStream(Stream stream);
    public static void ValidateStream(Stream stream);
}
public class Raven.Client.Documents.Commands.Batches.PutCommandData : PutCommandDataBase`1<DynamicJsonValue> {
    public PutCommandData(string id, string changeVector, DynamicJsonValue document);
    public PutCommandData(string id, string changeVector, string originalChangeVector, DynamicJsonValue document);
    public PutCommandData(string id, string changeVector, DynamicJsonValue document, ForceRevisionStrategy strategy);
    public PutCommandData(string id, string changeVector, string originalChangeVector, DynamicJsonValue document, ForceRevisionStrategy strategy);
    public virtual void OnBeforeSaveChanges(InMemoryDocumentSessionOperations session);
}
public abstract class Raven.Client.Documents.Commands.Batches.PutCommandDataBase`1 : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OriginalChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ForceRevisionStrategy <ForceRevisionCreationStrategy>k__BackingField;
    public string Id { get; }
    public string Name { get; }
    public string ChangeVector { get; }
    public string OriginalChangeVector { get; }
    public T Document { get; }
    public CommandType Type { get; }
    public ForceRevisionStrategy ForceRevisionCreationStrategy { get; }
    protected PutCommandDataBase`1(string id, string changeVector, string originalChangeVector, T document, ForceRevisionStrategy strategy);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ChangeVector();
    [CompilerGeneratedAttribute]
public string get_OriginalChangeVector();
    [CompilerGeneratedAttribute]
public T get_Document();
    [CompilerGeneratedAttribute]
public sealed virtual CommandType get_Type();
    [CompilerGeneratedAttribute]
public ForceRevisionStrategy get_ForceRevisionCreationStrategy();
    public sealed virtual DynamicJsonValue ToJson(DocumentConventions conventions, JsonOperationContext context);
    public abstract virtual void OnBeforeSaveChanges(InMemoryDocumentSessionOperations session);
}
internal class Raven.Client.Documents.Commands.Batches.PutCommandDataWithBlittableJson : PutCommandDataBase`1<BlittableJsonReaderObject> {
    public PutCommandDataWithBlittableJson(string id, string changeVector, string originalChangeVector, BlittableJsonReaderObject document);
    public PutCommandDataWithBlittableJson(string id, string changeVector, string originalChangeVector, BlittableJsonReaderObject document, ForceRevisionStrategy strategy);
    public virtual void OnBeforeSaveChanges(InMemoryDocumentSessionOperations session);
}
public class Raven.Client.Documents.Commands.Batches.PutCompareExchangeCommandData : object {
    public long Index;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    public BlittableJsonReaderObject Document { get; }
    public string Id { get; }
    public string Name { get; }
    public string ChangeVector { get; }
    public CommandType Type { get; }
    public PutCompareExchangeCommandData(string key, BlittableJsonReaderObject value, long index);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_Document();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    public sealed virtual string get_Name();
    public sealed virtual string get_ChangeVector();
    public sealed virtual CommandType get_Type();
    public sealed virtual DynamicJsonValue ToJson(DocumentConventions conventions, JsonOperationContext context);
    public sealed virtual void OnBeforeSaveChanges(InMemoryDocumentSessionOperations session);
}
public class Raven.Client.Documents.Commands.Batches.PutResult : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    public string Id { get; public set; }
    public string ChangeVector { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_ChangeVector();
    [CompilerGeneratedAttribute]
public void set_ChangeVector(string value);
}
public class Raven.Client.Documents.Commands.Batches.ReplicationBatchOptions : object {
    [CompilerGeneratedAttribute]
private bool <WaitForReplicas>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfReplicasToWaitFor>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <WaitForReplicasTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Majority>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowOnTimeoutInWaitForReplicas>k__BackingField;
    public bool WaitForReplicas { get; public set; }
    public int NumberOfReplicasToWaitFor { get; public set; }
    public TimeSpan WaitForReplicasTimeout { get; public set; }
    public bool Majority { get; public set; }
    public bool ThrowOnTimeoutInWaitForReplicas { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_WaitForReplicas();
    [CompilerGeneratedAttribute]
public void set_WaitForReplicas(bool value);
    [CompilerGeneratedAttribute]
public int get_NumberOfReplicasToWaitFor();
    [CompilerGeneratedAttribute]
public void set_NumberOfReplicasToWaitFor(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_WaitForReplicasTimeout();
    [CompilerGeneratedAttribute]
public void set_WaitForReplicasTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_Majority();
    [CompilerGeneratedAttribute]
public void set_Majority(bool value);
    [CompilerGeneratedAttribute]
public bool get_ThrowOnTimeoutInWaitForReplicas();
    [CompilerGeneratedAttribute]
public void set_ThrowOnTimeoutInWaitForReplicas(bool value);
}
public class Raven.Client.Documents.Commands.Batches.ShardedBatchOptions : object {
    internal static ShardedBatchOptions NonTransactionalMultiBucket;
    internal static ShardedBatchOptions TransactionalSingleBucketOnly;
    [CompilerGeneratedAttribute]
private ShardedBatchBehavior <BatchBehavior>k__BackingField;
    public ShardedBatchBehavior BatchBehavior { get; public set; }
    private static ShardedBatchOptions();
    [CompilerGeneratedAttribute]
public ShardedBatchBehavior get_BatchBehavior();
    [CompilerGeneratedAttribute]
public void set_BatchBehavior(ShardedBatchBehavior value);
    internal static ShardedBatchOptions For(ShardedBatchBehavior behavior);
}
public class Raven.Client.Documents.Commands.Batches.SingleNodeBatchCommand : RavenCommand`1<BatchCommandResult> {
    private BlittableJsonReaderObject[] _commandsAsJson;
    private Nullable`1<bool> _supportsAtomicWrites;
    private List`1<Stream> _attachmentStreams;
    private HashSet`1<Stream> _uniqueAttachmentStreams;
    private DocumentConventions _conventions;
    private IList`1<ICommandData> _commands;
    private BatchOptions _options;
    private TransactionMode _mode;
    public bool IsReadRequest { get; }
    public SingleNodeBatchCommand(DocumentConventions conventions, JsonOperationContext context, IList`1<ICommandData> commands, BatchOptions options, TransactionMode mode);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    protected virtual void AppendOptions(StringBuilder sb);
    internal static void AppendOptions(StringBuilder sb, IndexBatchOptions indexOptions, ReplicationBatchOptions replicationOptions, ShardedBatchOptions shardedOptions);
    public virtual bool get_IsReadRequest();
    public sealed virtual void Dispose();
}
public class Raven.Client.Documents.Commands.Batches.TimeSeriesBatchCommandData : TimeSeriesCommandData {
    public CommandType Type { get; }
    public TimeSeriesBatchCommandData(string documentId, string name, IList`1<AppendOperation> appends, List`1<DeleteOperation> deletes);
    public virtual CommandType get_Type();
}
public abstract class Raven.Client.Documents.Commands.Batches.TimeSeriesCommandData : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSeriesOperation <TimeSeries>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <FromEtl>k__BackingField;
    public string Id { get; public set; }
    public string Name { get; public set; }
    public string ChangeVector { get; }
    public CommandType Type { get; }
    public TimeSeriesOperation TimeSeries { get; protected set; }
    public Nullable`1<bool> FromEtl { get; public set; }
    protected TimeSeriesCommandData(string documentId, string name);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public sealed virtual string get_ChangeVector();
    public abstract virtual CommandType get_Type();
    [CompilerGeneratedAttribute]
public TimeSeriesOperation get_TimeSeries();
    [CompilerGeneratedAttribute]
protected void set_TimeSeries(TimeSeriesOperation value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_FromEtl();
    [CompilerGeneratedAttribute]
public void set_FromEtl(Nullable`1<bool> value);
    public DynamicJsonValue ToJson();
    public sealed virtual DynamicJsonValue ToJson(DocumentConventions conventions, JsonOperationContext context);
    public sealed virtual void OnBeforeSaveChanges(InMemoryDocumentSessionOperations session);
}
internal class Raven.Client.Documents.Commands.ClaimDomainResult : object {
    [CompilerGeneratedAttribute]
private string <Email>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Emails>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, List`1<string>> <Domains>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <RootDomains>k__BackingField;
    public string Email { get; public set; }
    public String[] Emails { get; public set; }
    public Dictionary`2<string, List`1<string>> Domains { get; public set; }
    public String[] RootDomains { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Email();
    [CompilerGeneratedAttribute]
public void set_Email(string value);
    [CompilerGeneratedAttribute]
public String[] get_Emails();
    [CompilerGeneratedAttribute]
public void set_Emails(String[] value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, List`1<string>> get_Domains();
    [CompilerGeneratedAttribute]
public void set_Domains(Dictionary`2<string, List`1<string>> value);
    [CompilerGeneratedAttribute]
public String[] get_RootDomains();
    [CompilerGeneratedAttribute]
public void set_RootDomains(String[] value);
}
public class Raven.Client.Documents.Commands.ConditionalGetDocumentsCommand : RavenCommand`1<ConditionalGetResult> {
    private string _changeVector;
    private string _id;
    public bool IsReadRequest { get; }
    public ConditionalGetDocumentsCommand(string id, string changeVector);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Commands.ConditionalGetDocumentsCommand/<ProcessResponse>d__5")]
public virtual Task`1<ResponseDisposeHandling> ProcessResponse(JsonOperationContext context, HttpCache cache, HttpResponseMessage response, string url);
    public virtual bool get_IsReadRequest();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<ResponseDisposeHandling> <>n__0(JsonOperationContext context, HttpCache cache, HttpResponseMessage response, string url);
}
public class Raven.Client.Documents.Commands.ConditionalGetResult : object {
    [CompilerGeneratedAttribute]
private BlittableJsonReaderArray <Results>k__BackingField;
    public string ChangeVector;
    public BlittableJsonReaderArray Results { get; public set; }
    [CompilerGeneratedAttribute]
public BlittableJsonReaderArray get_Results();
    [CompilerGeneratedAttribute]
public void set_Results(BlittableJsonReaderArray value);
}
public class Raven.Client.Documents.Commands.CreateSubscriptionCommand : RavenCommand`1<CreateSubscriptionResult> {
    private DocumentConventions _conventions;
    private SubscriptionCreationOptions _options;
    private string _id;
    [CompilerGeneratedAttribute]
private string <RaftUniqueRequestId>k__BackingField;
    public bool IsReadRequest { get; }
    public string RaftUniqueRequestId { get; }
    public CreateSubscriptionCommand(DocumentConventions conventions, SubscriptionCreationOptions options, string id);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
    [CompilerGeneratedAttribute]
public sealed virtual string get_RaftUniqueRequestId();
}
public class Raven.Client.Documents.Commands.DeleteDocumentCommand : RavenCommand {
    private string _id;
    private string _changeVector;
    public DeleteDocumentCommand(string id, string changeVector);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
}
internal class Raven.Client.Documents.Commands.DeleteRevisionsCommand : RavenCommand`1<Result> {
    private DocumentConventions _conventions;
    private Parameters _parameters;
    public bool IsReadRequest { get; }
    public DeleteRevisionsCommand(DocumentConventions conventions, Parameters parameters);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
}
public class Raven.Client.Documents.Commands.DeleteSubscriptionCommand : RavenCommand {
    private string _name;
    [CompilerGeneratedAttribute]
private string <RaftUniqueRequestId>k__BackingField;
    public string RaftUniqueRequestId { get; }
    public DeleteSubscriptionCommand(string name);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RaftUniqueRequestId();
}
internal class Raven.Client.Documents.Commands.DocumentSizeDetails : object {
    [CompilerGeneratedAttribute]
private string <DocId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ActualSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HumaneActualSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AllocatedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HumaneAllocatedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCompressed>k__BackingField;
    public string DocId { get; public set; }
    public int ActualSize { get; public set; }
    public string HumaneActualSize { get; public set; }
    public int AllocatedSize { get; public set; }
    public string HumaneAllocatedSize { get; public set; }
    public bool IsCompressed { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DocId();
    [CompilerGeneratedAttribute]
public void set_DocId(string value);
    [CompilerGeneratedAttribute]
public int get_ActualSize();
    [CompilerGeneratedAttribute]
public void set_ActualSize(int value);
    [CompilerGeneratedAttribute]
public string get_HumaneActualSize();
    [CompilerGeneratedAttribute]
public void set_HumaneActualSize(string value);
    [CompilerGeneratedAttribute]
public int get_AllocatedSize();
    [CompilerGeneratedAttribute]
public void set_AllocatedSize(int value);
    [CompilerGeneratedAttribute]
public string get_HumaneAllocatedSize();
    [CompilerGeneratedAttribute]
public void set_HumaneAllocatedSize(string value);
    [CompilerGeneratedAttribute]
public bool get_IsCompressed();
    [CompilerGeneratedAttribute]
public void set_IsCompressed(bool value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Commands.DropSubscriptionConnectionCommand : RavenCommand {
    private string _name;
    private string _workerId;
    private Nullable`1<long> _subscriptionTaskId;
    public DropSubscriptionConnectionCommand(string name);
    internal DropSubscriptionConnectionCommand(string name, string workerId);
    internal DropSubscriptionConnectionCommand(string name, Nullable`1<long> subscriptionTaskId, string workerId);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
}
public class Raven.Client.Documents.Commands.ExplainQueryCommand : RavenCommand`1<ExplainQueryResult[]> {
    private DocumentConventions _conventions;
    private IndexQuery _indexQuery;
    private BlittableJsonReaderObject _indexQueryAsJson;
    public bool IsReadRequest { get; }
    public ExplainQueryCommand(DocumentConventions conventions, IndexQuery indexQuery);
    internal ExplainQueryCommand(DocumentConventions conventions, BlittableJsonReaderObject indexQuery);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
}
internal class Raven.Client.Documents.Commands.ForceRenewResult : object {
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    public bool Success { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
public void set_Success(bool value);
}
internal class Raven.Client.Documents.Commands.GetCollectionFieldsCommand : RavenCommand`1<BlittableJsonReaderObject> {
    private string _collection;
    private string _prefix;
    public string Collection { get; }
    public string Prefix { get; }
    public bool IsReadRequest { get; }
    public GetCollectionFieldsCommand(string collection, string prefix);
    public string get_Collection();
    public string get_Prefix();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
}
public class Raven.Client.Documents.Commands.GetConflictsCommand : RavenCommand`1<GetConflictsResult> {
    private string _id;
    public bool IsReadRequest { get; }
    public GetConflictsCommand(string id);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
}
internal class Raven.Client.Documents.Commands.GetConflictsPreviewResult : object {
    [CompilerGeneratedAttribute]
private List`1<ConflictPreview> <Results>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalResults>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SkippedResults>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContinuationToken>k__BackingField;
    public List`1<ConflictPreview> Results { get; internal set; }
    public long TotalResults { get; public set; }
    public long SkippedResults { get; public set; }
    public string ContinuationToken { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<ConflictPreview> get_Results();
    [CompilerGeneratedAttribute]
internal void set_Results(List`1<ConflictPreview> value);
    [CompilerGeneratedAttribute]
public long get_TotalResults();
    [CompilerGeneratedAttribute]
public void set_TotalResults(long value);
    [CompilerGeneratedAttribute]
public long get_SkippedResults();
    [CompilerGeneratedAttribute]
public void set_SkippedResults(long value);
    [CompilerGeneratedAttribute]
public string get_ContinuationToken();
    [CompilerGeneratedAttribute]
public void set_ContinuationToken(string value);
}
public class Raven.Client.Documents.Commands.GetConflictsResult : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Conflict[] <Results>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LargestEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalResults>k__BackingField;
    public string Id { get; public set; }
    public Conflict[] Results { get; internal set; }
    public long LargestEtag { get; public set; }
    public long TotalResults { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public Conflict[] get_Results();
    [CompilerGeneratedAttribute]
internal void set_Results(Conflict[] value);
    [CompilerGeneratedAttribute]
public long get_LargestEtag();
    [CompilerGeneratedAttribute]
public void set_LargestEtag(long value);
    [CompilerGeneratedAttribute]
public long get_TotalResults();
    [CompilerGeneratedAttribute]
public void set_TotalResults(long value);
}
public class Raven.Client.Documents.Commands.GetDocumentsCommand : RavenCommand`1<GetDocumentsResult> {
    private DocumentConventions _conventions;
    private string _id;
    private String[] _ids;
    private String[] _includes;
    private String[] _counters;
    private bool _includeAllCounters;
    private TransactionMode _txMode;
    private IEnumerable`1<AbstractTimeSeriesRange> _timeSeriesIncludes;
    private IEnumerable`1<string> _revisionsIncludeByChangeVector;
    private Nullable`1<DateTime> _revisionsIncludeByDateTime;
    private String[] _compareExchangeValueIncludes;
    private bool _metadataOnly;
    private string _startWith;
    private string _matches;
    private Nullable`1<int> _start;
    private Nullable`1<int> _pageSize;
    private string _exclude;
    private string _startAfter;
    public bool IsReadRequest { get; }
    public GetDocumentsCommand(int start, int pageSize);
    public GetDocumentsCommand(DocumentConventions conventions, string id, String[] includes, bool metadataOnly);
    public GetDocumentsCommand(DocumentConventions conventions, String[] ids, String[] includes, bool metadataOnly);
    public GetDocumentsCommand(DocumentConventions conventions, String[] ids, String[] includes, String[] counterIncludes, IEnumerable`1<AbstractTimeSeriesRange> timeSeriesIncludes, String[] compareExchangeValueIncludes, bool metadataOnly);
    public GetDocumentsCommand(DocumentConventions conventions, String[] ids, String[] includes, String[] counterIncludes, IEnumerable`1<string> revisionsIncludesByChangeVector, Nullable`1<DateTime> revisionIncludeByDateTimeBefore, IEnumerable`1<AbstractTimeSeriesRange> timeSeriesIncludes, String[] compareExchangeValueIncludes, bool metadataOnly);
    public GetDocumentsCommand(DocumentConventions conventions, String[] ids, String[] includes, bool includeAllCounters, IEnumerable`1<AbstractTimeSeriesRange> timeSeriesIncludes, String[] compareExchangeValueIncludes, bool metadataOnly);
    public GetDocumentsCommand(DocumentConventions conventions, string startWith, string startAfter, string matches, string exclude, int start, int pageSize, bool metadataOnly);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public static void PrepareRequestWithMultipleIds(DocumentConventions conventions, StringBuilder pathBuilder, HttpRequestMessage request, String[] ids, JsonOperationContext context);
    private static ulong CalculateHash(JsonOperationContext ctx, HashSet`1<string> uniqueIds);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
    internal void SetTransactionMode(TransactionMode mode);
}
internal class Raven.Client.Documents.Commands.GetDocumentSizeCommand : RavenCommand`1<DocumentSizeDetails> {
    private string _id;
    public bool IsReadRequest { get; }
    public GetDocumentSizeCommand(string id);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
}
public class Raven.Client.Documents.Commands.GetDocumentsResult : object {
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <Includes>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderArray <Results>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <CounterIncludes>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderArray <RevisionIncludes>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <TimeSeriesIncludes>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <CompareExchangeValueIncludes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NextPageStart>k__BackingField;
    public BlittableJsonReaderObject Includes { get; public set; }
    public BlittableJsonReaderArray Results { get; public set; }
    public BlittableJsonReaderObject CounterIncludes { get; public set; }
    public BlittableJsonReaderArray RevisionIncludes { get; public set; }
    public BlittableJsonReaderObject TimeSeriesIncludes { get; public set; }
    public BlittableJsonReaderObject CompareExchangeValueIncludes { get; public set; }
    [ObsoleteAttribute("Will be removed in next major version of the product.")]
public int NextPageStart { get; public set; }
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_Includes();
    [CompilerGeneratedAttribute]
public void set_Includes(BlittableJsonReaderObject value);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderArray get_Results();
    [CompilerGeneratedAttribute]
public void set_Results(BlittableJsonReaderArray value);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_CounterIncludes();
    [CompilerGeneratedAttribute]
public void set_CounterIncludes(BlittableJsonReaderObject value);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderArray get_RevisionIncludes();
    [CompilerGeneratedAttribute]
public void set_RevisionIncludes(BlittableJsonReaderArray value);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_TimeSeriesIncludes();
    [CompilerGeneratedAttribute]
public void set_TimeSeriesIncludes(BlittableJsonReaderObject value);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_CompareExchangeValueIncludes();
    [CompilerGeneratedAttribute]
public void set_CompareExchangeValueIncludes(BlittableJsonReaderObject value);
    [CompilerGeneratedAttribute]
public int get_NextPageStart();
    [CompilerGeneratedAttribute]
public void set_NextPageStart(int value);
}
public class Raven.Client.Documents.Commands.GetNextOperationIdCommand : RavenCommand`1<long> {
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    public string NodeTag { get; private set; }
    public bool IsReadRequest { get; }
    [CompilerGeneratedAttribute]
public string get_NodeTag();
    [CompilerGeneratedAttribute]
private void set_NodeTag(string value);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
}
internal class Raven.Client.Documents.Commands.GetNextServerOperationIdCommand : RavenCommand`1<long> {
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    public string NodeTag { get; private set; }
    public bool IsReadRequest { get; }
    [CompilerGeneratedAttribute]
public string get_NodeTag();
    [CompilerGeneratedAttribute]
private void set_NodeTag(string value);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
}
internal class Raven.Client.Documents.Commands.GetRemoteTaskTopologyCommand : RavenCommand`1<String[]> {
    private string _remoteDatabase;
    private string _databaseGroupId;
    private string _remoteTask;
    [CompilerGeneratedAttribute]
private ServerNode <RequestedNode>k__BackingField;
    public ServerNode RequestedNode { get; private set; }
    public bool IsReadRequest { get; }
    public GetRemoteTaskTopologyCommand(string remoteDatabase, string databaseGroupId, string remoteTask);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    [CompilerGeneratedAttribute]
public ServerNode get_RequestedNode();
    [CompilerGeneratedAttribute]
private void set_RequestedNode(ServerNode value);
    public virtual bool get_IsReadRequest();
}
public class Raven.Client.Documents.Commands.GetRevisionsBinEntryCommand : RavenCommand`1<BlittableArrayResult> {
    private int _start;
    private Nullable`1<int> _pageSize;
    private string _continuationToken;
    public bool IsReadRequest { get; }
    public GetRevisionsBinEntryCommand(int start, Nullable`1<int> pageSize);
    public GetRevisionsBinEntryCommand(string continuationToken);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
}
public class Raven.Client.Documents.Commands.GetRevisionsCommand : RavenCommand`1<BlittableArrayResult> {
    internal string ChangeVector;
    public String[] ChangeVectors;
    internal string Id;
    private Nullable`1<int> _start;
    private Nullable`1<int> _pageSize;
    private bool _metadataOnly;
    internal Nullable`1<DateTime> Before;
    public bool IsReadRequest { get; }
    public GetRevisionsCommand(string id, DateTime before);
    public GetRevisionsCommand(string id, Nullable`1<int> start, Nullable`1<int> pageSize, bool metadataOnly);
    public GetRevisionsCommand(string changeVector, bool metadataOnly);
    public GetRevisionsCommand(String[] changeVectors, bool metadataOnly);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    internal void GetRequestQueryString(StringBuilder pathBuilder);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
}
public class Raven.Client.Documents.Commands.GetSubscriptionsCommand : RavenCommand`1<SubscriptionState[]> {
    private int _start;
    private int _pageSize;
    public bool IsReadRequest { get; }
    public GetSubscriptionsCommand(int start, int pageSize);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
}
public class Raven.Client.Documents.Commands.GetSubscriptionStateCommand : RavenCommand`1<SubscriptionState> {
    private string _subscriptionName;
    public bool IsReadRequest { get; }
    public GetSubscriptionStateCommand(string subscriptionName);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
}
internal class Raven.Client.Documents.Commands.GetTcpInfoForRemoteTaskCommand : RavenCommand`1<TcpConnectionInfo> {
    private string _remoteDatabase;
    private string _remoteTask;
    private string _tag;
    private bool _verifyDatabase;
    [CompilerGeneratedAttribute]
private ServerNode <RequestedNode>k__BackingField;
    public ServerNode RequestedNode { get; private set; }
    public bool IsReadRequest { get; }
    public GetTcpInfoForRemoteTaskCommand(string tag, string remoteDatabase, string remoteTask, bool verifyDatabase);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    [CompilerGeneratedAttribute]
public ServerNode get_RequestedNode();
    [CompilerGeneratedAttribute]
private void set_RequestedNode(ServerNode value);
    public virtual bool get_IsReadRequest();
}
public class Raven.Client.Documents.Commands.HeadAttachmentCommand : RavenCommand`1<string> {
    private string _documentId;
    private string _name;
    private string _changeVector;
    public bool IsReadRequest { get; }
    public HeadAttachmentCommand(string documentId, string name, string changeVector);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual Task`1<ResponseDisposeHandling> ProcessResponse(JsonOperationContext context, HttpCache cache, HttpResponseMessage response, string url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
}
public class Raven.Client.Documents.Commands.HeadDocumentCommand : RavenCommand`1<string> {
    private string _id;
    private string _changeVector;
    public bool IsReadRequest { get; }
    public HeadDocumentCommand(string id, string changeVector);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual Task`1<ResponseDisposeHandling> ProcessResponse(JsonOperationContext context, HttpCache cache, HttpResponseMessage response, string url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
}
public class Raven.Client.Documents.Commands.HiLoReturnCommand : RavenCommand {
    private string _tag;
    private long _last;
    private long _end;
    public HiLoReturnCommand(string tag, long last, long end);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
}
public class Raven.Client.Documents.Commands.KillOperationCommand : RavenCommand {
    private long _id;
    public KillOperationCommand(long id);
    public KillOperationCommand(long id, string nodeTag);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
}
internal class Raven.Client.Documents.Commands.KillServerOperationCommand : RavenCommand {
    private long _id;
    public KillServerOperationCommand(long id);
    public KillServerOperationCommand(long id, string nodeTag);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
}
public class Raven.Client.Documents.Commands.MultiGet.GetRequest : object {
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Query>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanCacheAggressively>k__BackingField;
    [CompilerGeneratedAttribute]
private IContent <Content>k__BackingField;
    public string Url { get; public set; }
    public IDictionary`2<string, string> Headers { get; public set; }
    public string Query { get; public set; }
    public HttpMethod Method { get; public set; }
    public string UrlAndQuery { get; }
    public bool CanCacheAggressively { get; public set; }
    public IContent Content { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
public void set_Headers(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_Query();
    [CompilerGeneratedAttribute]
public void set_Query(string value);
    [CompilerGeneratedAttribute]
public HttpMethod get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(HttpMethod value);
    public string get_UrlAndQuery();
    [CompilerGeneratedAttribute]
public bool get_CanCacheAggressively();
    [CompilerGeneratedAttribute]
public void set_CanCacheAggressively(bool value);
    [CompilerGeneratedAttribute]
public IContent get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(IContent value);
}
public class Raven.Client.Documents.Commands.MultiGet.GetResponse : object {
    [CompilerGeneratedAttribute]
private TimeSpan <Elapsed>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderBase <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpStatusCode <StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceRetry>k__BackingField;
    internal TimeSpan Elapsed { get; internal set; }
    public BlittableJsonReaderBase Result { get; public set; }
    public Dictionary`2<string, string> Headers { get; public set; }
    public HttpStatusCode StatusCode { get; public set; }
    public bool ForceRetry { get; public set; }
    [CompilerGeneratedAttribute]
internal TimeSpan get_Elapsed();
    [CompilerGeneratedAttribute]
internal void set_Elapsed(TimeSpan value);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderBase get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(BlittableJsonReaderBase value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
public void set_Headers(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public HttpStatusCode get_StatusCode();
    [CompilerGeneratedAttribute]
public void set_StatusCode(HttpStatusCode value);
    [CompilerGeneratedAttribute]
public bool get_ForceRetry();
    [CompilerGeneratedAttribute]
public void set_ForceRetry(bool value);
    public bool RequestHasErrors();
}
public class Raven.Client.Documents.Commands.MultiGet.MultiGetCommand : RavenCommand`1<List`1<GetResponse>> {
    private RequestExecutor _requestExecutor;
    private HttpCache _httpCache;
    private List`1<GetRequest> _commands;
    private SessionInfo _sessionInfo;
    private string _baseUrl;
    private Cached _cached;
    internal bool AggressivelyCached;
    public bool IsReadRequest { get; }
    public MultiGetCommand(RequestExecutor requestExecutor, List`1<GetRequest> commands);
    internal MultiGetCommand(RequestExecutor requestExecutor, List`1<GetRequest> commands, SessionInfo sessionInfo);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    private bool MaybeReadAllFromCache(JsonOperationContext ctx, AggressiveCacheOptions options);
    private string GetCacheKey(GetRequest command, String& requestUrl);
    public virtual void SetResponseRaw(HttpResponseMessage response, Stream stream, JsonOperationContext context);
    [IteratorStateMachineAttribute("Raven.Client.Documents.Commands.MultiGet.MultiGetCommand/<ReadResponses>d__13")]
private static IEnumerable`1<GetResponse> ReadResponses(JsonOperationContext context, PeepingTomStream peepingTomStream, UnmanagedJsonParser parser, JsonParserState state, MemoryBuffer buffer);
    private static GetResponse ReadResponse(JsonOperationContext context, PeepingTomStream peepingTomStream, UnmanagedJsonParser parser, JsonParserState state, MemoryBuffer buffer);
    private void MaybeSetCache(GetResponse getResponse, GetRequest command, int cachedIndex);
    public virtual bool get_IsReadRequest();
    public sealed virtual void Dispose();
    private void DisposeCache();
}
public class Raven.Client.Documents.Commands.NextHiLoCommand : RavenCommand`1<HiLoResult> {
    private string _tag;
    private long _lastBatchSize;
    private Nullable`1<DateTime> _lastRangeAt;
    private char _identityPartsSeparator;
    private long _lastRangeMax;
    public bool IsReadRequest { get; }
    public NextHiLoCommand(string tag, long lastBatchSize, Nullable`1<DateTime> lastRangeAt, char identityPartsSeparator, long lastRangeMax);
    internal NextHiLoCommand(string tag, long lastBatchSize, Nullable`1<DateTime> lastRangeAt, char identityPartsSeparator, long lastRangeMax, string nodeTag);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
}
public class Raven.Client.Documents.Commands.NextIdentityForCommand : RavenCommand`1<long> {
    private string _id;
    [CompilerGeneratedAttribute]
private bool <IsReadRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RaftUniqueRequestId>k__BackingField;
    public bool IsReadRequest { get; }
    public string RaftUniqueRequestId { get; }
    public NextIdentityForCommand(string id);
    private NextIdentityForCommand(NextIdentityForCommand copy);
    [CompilerGeneratedAttribute]
public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RaftUniqueRequestId();
    public sealed virtual IBroadcast PrepareToBroadcast(JsonOperationContext context, DocumentConventions conventions);
}
internal class Raven.Client.Documents.Commands.PreviewCollectionCommand : RavenCommand`1<BlittableJsonReaderObject> {
    private string _collection;
    public string Collection { get; }
    public bool IsReadRequest { get; }
    public PreviewCollectionCommand(string collection);
    public string get_Collection();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
}
public class Raven.Client.Documents.Commands.PutDocumentCommand : RavenCommand`1<PutResult> {
    private DocumentConventions _conventions;
    private string _id;
    private string _changeVector;
    private BlittableJsonReaderObject _document;
    public bool IsReadRequest { get; }
    public PutDocumentCommand(DocumentConventions conventions, string id, string changeVector, BlittableJsonReaderObject document);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
}
public class Raven.Client.Documents.Commands.QueryCommand : AbstractQueryCommand`2<QueryResult, Parameters> {
    private DocumentConventions _conventions;
    private IndexQuery _indexQuery;
    private InMemoryDocumentSessionOperations _session;
    public QueryCommand(InMemoryDocumentSessionOperations session, IndexQuery indexQuery, bool metadataOnly, bool indexEntriesOnly);
    protected virtual ulong GetQueryHash(JsonOperationContext ctx);
    protected virtual HttpContent GetContent(JsonOperationContext ctx);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
}
public class Raven.Client.Documents.Commands.QueryStreamCommand : RavenCommand`1<StreamResult> {
    private DocumentConventions _conventions;
    private IndexQuery _indexQuery;
    public bool IsReadRequest { get; }
    public QueryStreamCommand(DocumentConventions conventions, IndexQuery query);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Commands.QueryStreamCommand/<ProcessResponse>d__4")]
public virtual Task`1<ResponseDisposeHandling> ProcessResponse(JsonOperationContext context, HttpCache cache, HttpResponseMessage response, string url);
    public virtual bool get_IsReadRequest();
}
internal class Raven.Client.Documents.Commands.RevertDocumentsToRevisionsRequest : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <IdToChangeVector>k__BackingField;
    public Dictionary`2<string, string> IdToChangeVector { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_IdToChangeVector();
    [CompilerGeneratedAttribute]
public void set_IdToChangeVector(Dictionary`2<string, string> value);
}
internal class Raven.Client.Documents.Commands.RevertRevisionsByIdCommand : RavenCommand {
    private Dictionary`2<string, string> _idToChangeVector;
    public RevertRevisionsByIdCommand(Dictionary`2<string, string> idToChangeVector);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
}
public class Raven.Client.Documents.Commands.SeedIdentityForCommand : RavenCommand`1<long> {
    private string _id;
    private long _value;
    private bool _forced;
    [CompilerGeneratedAttribute]
private bool <IsReadRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RaftUniqueRequestId>k__BackingField;
    public bool IsReadRequest { get; }
    public string RaftUniqueRequestId { get; }
    public SeedIdentityForCommand(string id, long value, bool forced);
    [CompilerGeneratedAttribute]
public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RaftUniqueRequestId();
}
internal class Raven.Client.Documents.Commands.StreamCommand : RavenCommand`1<StreamResult> {
    private string _url;
    public bool IsReadRequest { get; }
    public StreamCommand(string url);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Commands.StreamCommand/<ProcessResponse>d__3")]
public virtual Task`1<ResponseDisposeHandling> ProcessResponse(JsonOperationContext context, HttpCache cache, HttpResponseMessage response, string url);
    public virtual bool get_IsReadRequest();
}
public class Raven.Client.Documents.Commands.StreamResult : object {
    [CompilerGeneratedAttribute]
private HttpResponseMessage <Response>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    public HttpResponseMessage Response { get; public set; }
    public Stream Stream { get; public set; }
    [CompilerGeneratedAttribute]
public HttpResponseMessage get_Response();
    [CompilerGeneratedAttribute]
public void set_Response(HttpResponseMessage value);
    [CompilerGeneratedAttribute]
public Stream get_Stream();
    [CompilerGeneratedAttribute]
public void set_Stream(Stream value);
}
public class Raven.Client.Documents.Commands.StreamResult`1 : AbstractStreamResult {
    [CompilerGeneratedAttribute]
private TType <Document>k__BackingField;
    public TType Document { get; public set; }
    [CompilerGeneratedAttribute]
public TType get_Document();
    [CompilerGeneratedAttribute]
public void set_Document(TType value);
}
public class Raven.Client.Documents.Commands.TimeSeriesStreamResult`1 : AbstractStreamResult {
    [CompilerGeneratedAttribute]
private TType <Result>k__BackingField;
    public TType Result { get; public set; }
    [CompilerGeneratedAttribute]
public TType get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(TType value);
}
internal class Raven.Client.Documents.Commands.UpdateSubscriptionCommand : RavenCommand`1<UpdateSubscriptionResult> {
    private DocumentConventions _conventions;
    private SubscriptionUpdateOptions _options;
    [CompilerGeneratedAttribute]
private string <RaftUniqueRequestId>k__BackingField;
    public bool IsReadRequest { get; }
    public string RaftUniqueRequestId { get; }
    public UpdateSubscriptionCommand(DocumentConventions conventions, SubscriptionUpdateOptions options);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
    [CompilerGeneratedAttribute]
public sealed virtual string get_RaftUniqueRequestId();
}
public class Raven.Client.Documents.Conventions.DocumentConventions : Conventions {
    internal static HttpCompressionAlgorithm DefaultHttpCompressionAlgorithm;
    internal static DocumentConventions Default;
    internal static DocumentConventions DefaultForServer;
    private static bool DefaultDisableTcpCompression;
    private static TypeCache`1<string> CachedDefaultTypeCollectionNames;
    private Dictionary`2<MemberInfo, CustomQueryTranslator> _customQueryTranslators;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<Type, TryConvertValueToObjectForQueryDelegate`1<object>>> _listOfQueryValueToObjectConverters;
    private TypeCache`1<TryConvertValueToObjectForQueryDelegate`1<object>> _listOfQueryValueToObjectConvertersCache;
    private List`1<QueryMethodConverter> _listOfQueryMethodConverters;
    private Dictionary`2<Type, RangeType> _customRangeTypes;
    private List`1<Tuple`2<Type, Func`3<string, object, Task`1<string>>>> _listOfRegisteredIdConventionsAsync;
    public BulkInsertConventions BulkInsert;
    public AggressiveCacheConventions AggressiveCache;
    public ShardingConventions Sharding;
    private bool _frozen;
    private ClientConfiguration _originalConfiguration;
    private static TypeCache`1<MemberInfo> IdPropertyCache;
    private bool _saveEnumsAsIntegers;
    private bool _saveEnumsAsIntegersForPatching;
    private char _identityPartsSeparator;
    private bool _disableTopologyUpdates;
    private Func`4<InMemoryDocumentSessionOperations, object, string, bool> _shouldIgnoreEntityChanges;
    private Func`2<MemberInfo, bool> _findIdentityProperty;
    private Func`2<string, string> _transformTypeCollectionNameToDocumentIdPrefix;
    private Func`3<string, object, Task`1<string>> _asyncDocumentIdGenerator;
    private Func`2<string, string> _findIdentityPropertyNameFromCollectionName;
    private Func`5<Type, string, string, string, string> _findPropertyNameForDynamicIndex;
    private Func`5<Type, string, string, string, string> _findPropertyNameForIndex;
    private Func`5<Type, string, string, string, string> _findProjectedPropertyNameForIndex;
    private Func`2<string, string> _loadBalancerPerSessionContextSelector;
    [DynamicAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<object, string> _findCollectionNameForDynamic;
    [DynamicAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<object, string> _findClrTypeNameForDynamic;
    private Func`2<Type, string> _findCollectionName;
    private Func`2<Type, string> _findClrTypeName;
    private Func`3<string, BlittableJsonReaderObject, string> _findClrType;
    private Func`2<string, Type> _resolveTypeFromClrTypeName;
    private bool _useOptimisticConcurrency;
    private bool _addIdFieldToDynamicObjects;
    private int _maxNumberOfRequestsPerSession;
    private Nullable`1<TimeSpan> _requestTimeout;
    private TimeSpan _secondBroadcastAttemptTimeout;
    private TimeSpan _firstBroadcastAttemptTimeout;
    private TimeSpan _waitForIndexesAfterSaveChangesTimeout;
    private TimeSpan _waitForReplicationAfterSaveChangesTimeout;
    private TimeSpan _waitForNonStaleResultsTimeout;
    private TimeSpan _globalHttpClientTimeout;
    private int _loadBalancerContextSeed;
    private LoadBalanceBehavior _loadBalanceBehavior;
    private ReadBalanceBehavior _readBalanceBehavior;
    private bool _preserveDocumentPropertiesNotFoundOnModel;
    private Size _maxHttpCacheSize;
    private Nullable`1<bool> _useHttpDecompression;
    private Nullable`1<bool> _useHttpCompression;
    private HttpCompressionAlgorithm _httpCompressionAlgorithm;
    private Func`2<MemberInfo, string> _propertyNameConverter;
    private Func`2<Type, bool> _typeIsKnownServerSide;
    private Func`2<MemberInfo, bool> _shouldApplyPropertyNameConverter;
    private OperationStatusFetchMode _operationStatusFetchMode;
    private bool _disableTopologyCache;
    private string _topologyCacheLocation;
    private Version _httpVersion;
    private Type _httpClientType;
    private Func`2<HttpClientHandler, HttpClient> _createHttpClient;
    private bool _sendApplicationIdentifier;
    private Size _maxContextSizeToKeep;
    private ISerializationConventions _serialization;
    private Nullable`1<bool> _disableAtomicDocumentWritesInClusterWideTransaction;
    private bool _disableTcpCompression;
    private bool _disposeCertificate;
    internal TestingStuff ForTestingPurposes;
    public ISerializationConventions Serialization { get; public set; }
    public Func`4<InMemoryDocumentSessionOperations, object, string, bool> ShouldIgnoreEntityChanges { get; public set; }
    public Func`2<MemberInfo, bool> ShouldApplyPropertyNameConverter { get; public set; }
    public Size MaxContextSizeToKeep { get; public set; }
    public bool SendApplicationIdentifier { get; public set; }
    public Version HttpVersion { get; public set; }
    public Type HttpClientType { get; public set; }
    public Func`2<HttpClientHandler, HttpClient> CreateHttpClient { get; public set; }
    public Func`2<MemberInfo, string> PropertyNameConverter { get; public set; }
    public Nullable`1<TimeSpan> RequestTimeout { get; public set; }
    public TimeSpan GlobalHttpClientTimeout { get; public set; }
    public TimeSpan SecondBroadcastAttemptTimeout { get; public set; }
    public TimeSpan FirstBroadcastAttemptTimeout { get; public set; }
    public TimeSpan WaitForIndexesAfterSaveChangesTimeout { get; public set; }
    public TimeSpan WaitForNonStaleResultsTimeout { get; public set; }
    public TimeSpan WaitForReplicationAfterSaveChangesTimeout { get; public set; }
    public HttpCompressionAlgorithm HttpCompressionAlgorithm { get; public set; }
    public bool UseHttpCompression { get; public set; }
    internal bool HasExplicitlySetDecompressionUsage { get; }
    public bool UseHttpDecompression { get; public set; }
    public bool PreserveDocumentPropertiesNotFoundOnModel { get; public set; }
    public ReadBalanceBehavior ReadBalanceBehavior { get; public set; }
    public int LoadBalancerContextSeed { get; public set; }
    public LoadBalanceBehavior LoadBalanceBehavior { get; public set; }
    public Func`2<string, string> LoadBalancerPerSessionContextSelector { get; public set; }
    public bool AddIdFieldToDynamicObjects { get; public set; }
    public int MaxNumberOfRequestsPerSession { get; public set; }
    public Size MaxHttpCacheSize { get; public set; }
    public bool UseOptimisticConcurrency { get; public set; }
    public Func`3<string, BlittableJsonReaderObject, string> FindClrType { get; public set; }
    public Func`2<Type, string> FindClrTypeName { get; public set; }
    public Func`2<string, Type> ResolveTypeFromClrTypeName { get; public set; }
    public Func`2<Type, string> FindCollectionName { get; public set; }
    [DynamicAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<object, string> FindCollectionNameForDynamic { get; public set; }
    [DynamicAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<object, string> FindClrTypeNameForDynamic { get; public set; }
    public Func`5<Type, string, string, string, string> FindPropertyNameForIndex { get; public set; }
    public Func`5<Type, string, string, string, string> FindProjectedPropertyNameForIndex { get; public set; }
    public Func`5<Type, string, string, string, string> FindPropertyNameForDynamicIndex { get; public set; }
    public Func`2<string, string> FindIdentityPropertyNameFromCollectionName { get; public set; }
    public Func`3<string, object, Task`1<string>> AsyncDocumentIdGenerator { get; public set; }
    public Func`2<string, string> TransformTypeCollectionNameToDocumentIdPrefix { get; public set; }
    public Func`2<Type, bool> TypeIsKnownServerSide { get; public set; }
    public Func`2<MemberInfo, bool> FindIdentityProperty { get; public set; }
    public bool DisableTopologyUpdates { get; public set; }
    public char IdentityPartsSeparator { get; public set; }
    public bool SaveEnumsAsIntegers { get; public set; }
    public bool SaveEnumsAsIntegersForPatching { get; public set; }
    public OperationStatusFetchMode OperationStatusFetchMode { get; public set; }
    public bool DisableTopologyCache { get; public set; }
    public string TopologyCacheLocation { get; public set; }
    public bool DisposeCertificate { get; public set; }
    internal bool AnyQueryMethodConverters { get; }
    public Nullable`1<bool> DisableAtomicDocumentWritesInClusterWideTransaction { get; public set; }
    public bool DisableTcpCompression { get; public set; }
    private static DocumentConventions();
    public ISerializationConventions get_Serialization();
    public void set_Serialization(ISerializationConventions value);
    public Func`4<InMemoryDocumentSessionOperations, object, string, bool> get_ShouldIgnoreEntityChanges();
    public void set_ShouldIgnoreEntityChanges(Func`4<InMemoryDocumentSessionOperations, object, string, bool> value);
    public Func`2<MemberInfo, bool> get_ShouldApplyPropertyNameConverter();
    public void set_ShouldApplyPropertyNameConverter(Func`2<MemberInfo, bool> value);
    public Size get_MaxContextSizeToKeep();
    public void set_MaxContextSizeToKeep(Size value);
    public bool get_SendApplicationIdentifier();
    public void set_SendApplicationIdentifier(bool value);
    public Version get_HttpVersion();
    public void set_HttpVersion(Version value);
    public Type get_HttpClientType();
    public void set_HttpClientType(Type value);
    public Func`2<HttpClientHandler, HttpClient> get_CreateHttpClient();
    public void set_CreateHttpClient(Func`2<HttpClientHandler, HttpClient> value);
    internal string GetConvertedPropertyNameFor(MemberInfo member);
    public Func`2<MemberInfo, string> get_PropertyNameConverter();
    public void set_PropertyNameConverter(Func`2<MemberInfo, string> value);
    public Nullable`1<TimeSpan> get_RequestTimeout();
    public void set_RequestTimeout(Nullable`1<TimeSpan> value);
    public TimeSpan get_GlobalHttpClientTimeout();
    public void set_GlobalHttpClientTimeout(TimeSpan value);
    public TimeSpan get_SecondBroadcastAttemptTimeout();
    public void set_SecondBroadcastAttemptTimeout(TimeSpan value);
    public TimeSpan get_FirstBroadcastAttemptTimeout();
    public void set_FirstBroadcastAttemptTimeout(TimeSpan value);
    public TimeSpan get_WaitForIndexesAfterSaveChangesTimeout();
    public void set_WaitForIndexesAfterSaveChangesTimeout(TimeSpan value);
    public TimeSpan get_WaitForNonStaleResultsTimeout();
    public void set_WaitForNonStaleResultsTimeout(TimeSpan value);
    public TimeSpan get_WaitForReplicationAfterSaveChangesTimeout();
    public void set_WaitForReplicationAfterSaveChangesTimeout(TimeSpan value);
    public HttpCompressionAlgorithm get_HttpCompressionAlgorithm();
    public void set_HttpCompressionAlgorithm(HttpCompressionAlgorithm value);
    public bool get_UseHttpCompression();
    public void set_UseHttpCompression(bool value);
    internal bool get_HasExplicitlySetDecompressionUsage();
    public bool get_UseHttpDecompression();
    public void set_UseHttpDecompression(bool value);
    public bool get_PreserveDocumentPropertiesNotFoundOnModel();
    public void set_PreserveDocumentPropertiesNotFoundOnModel(bool value);
    public ReadBalanceBehavior get_ReadBalanceBehavior();
    public void set_ReadBalanceBehavior(ReadBalanceBehavior value);
    public int get_LoadBalancerContextSeed();
    public void set_LoadBalancerContextSeed(int value);
    public LoadBalanceBehavior get_LoadBalanceBehavior();
    public void set_LoadBalanceBehavior(LoadBalanceBehavior value);
    public Func`2<string, string> get_LoadBalancerPerSessionContextSelector();
    public void set_LoadBalancerPerSessionContextSelector(Func`2<string, string> value);
    public bool get_AddIdFieldToDynamicObjects();
    public void set_AddIdFieldToDynamicObjects(bool value);
    public int get_MaxNumberOfRequestsPerSession();
    public void set_MaxNumberOfRequestsPerSession(int value);
    public Size get_MaxHttpCacheSize();
    public void set_MaxHttpCacheSize(Size value);
    public bool get_UseOptimisticConcurrency();
    public void set_UseOptimisticConcurrency(bool value);
    public Func`3<string, BlittableJsonReaderObject, string> get_FindClrType();
    public void set_FindClrType(Func`3<string, BlittableJsonReaderObject, string> value);
    public Func`2<Type, string> get_FindClrTypeName();
    public void set_FindClrTypeName(Func`2<Type, string> value);
    public Func`2<string, Type> get_ResolveTypeFromClrTypeName();
    public void set_ResolveTypeFromClrTypeName(Func`2<string, Type> value);
    public Func`2<Type, string> get_FindCollectionName();
    public void set_FindCollectionName(Func`2<Type, string> value);
    public Func`2<object, string> get_FindCollectionNameForDynamic();
    public void set_FindCollectionNameForDynamic(Func`2<object, string> value);
    public Func`2<object, string> get_FindClrTypeNameForDynamic();
    public void set_FindClrTypeNameForDynamic(Func`2<object, string> value);
    public Func`5<Type, string, string, string, string> get_FindPropertyNameForIndex();
    public void set_FindPropertyNameForIndex(Func`5<Type, string, string, string, string> value);
    public Func`5<Type, string, string, string, string> get_FindProjectedPropertyNameForIndex();
    public void set_FindProjectedPropertyNameForIndex(Func`5<Type, string, string, string, string> value);
    public Func`5<Type, string, string, string, string> get_FindPropertyNameForDynamicIndex();
    public void set_FindPropertyNameForDynamicIndex(Func`5<Type, string, string, string, string> value);
    public Func`2<string, string> get_FindIdentityPropertyNameFromCollectionName();
    public void set_FindIdentityPropertyNameFromCollectionName(Func`2<string, string> value);
    public Func`3<string, object, Task`1<string>> get_AsyncDocumentIdGenerator();
    public void set_AsyncDocumentIdGenerator(Func`3<string, object, Task`1<string>> value);
    public Func`2<string, string> get_TransformTypeCollectionNameToDocumentIdPrefix();
    public void set_TransformTypeCollectionNameToDocumentIdPrefix(Func`2<string, string> value);
    public Func`2<Type, bool> get_TypeIsKnownServerSide();
    public void set_TypeIsKnownServerSide(Func`2<Type, bool> value);
    public Func`2<MemberInfo, bool> get_FindIdentityProperty();
    public void set_FindIdentityProperty(Func`2<MemberInfo, bool> value);
    public bool get_DisableTopologyUpdates();
    public void set_DisableTopologyUpdates(bool value);
    public char get_IdentityPartsSeparator();
    public void set_IdentityPartsSeparator(char value);
    public bool get_SaveEnumsAsIntegers();
    public void set_SaveEnumsAsIntegers(bool value);
    public bool get_SaveEnumsAsIntegersForPatching();
    public void set_SaveEnumsAsIntegersForPatching(bool value);
    public OperationStatusFetchMode get_OperationStatusFetchMode();
    public void set_OperationStatusFetchMode(OperationStatusFetchMode value);
    public bool get_DisableTopologyCache();
    public void set_DisableTopologyCache(bool value);
    public string get_TopologyCacheLocation();
    public void set_TopologyCacheLocation(string value);
    public bool get_DisposeCertificate();
    public void set_DisposeCertificate(bool value);
    public void RegisterCustomQueryTranslator(Expression`1<Func`2<T, object>> member, CustomQueryTranslator translator);
    public static string DefaultGetCollectionName(Type t);
    public string GetCollectionName(Type type);
    public string GetCollectionName(object entity);
    public string GenerateDocumentId(string databaseName, object entity);
    public Task`1<string> GenerateDocumentIdAsync(string databaseName, object entity);
    public DocumentConventions RegisterAsyncIdConvention(Func`3<string, TEntity, Task`1<string>> func);
    public string GetClrType(string id, BlittableJsonReaderObject document);
    public string GetClrTypeName(object entity);
    public string GetClrTypeName(Type entityType);
    public DocumentConventions Clone();
    public RangeType GetRangeType(Type type);
    public MemberInfo GetIdentityProperty(Type type);
    internal void UpdateFrom(ClientConfiguration configuration);
    public static bool DefaultShouldApplyPropertyNameConverter(MemberInfo member);
    public static string DefaultTransformCollectionNameToDocumentIdPrefix(string collectionName);
    public static string DefaultFindPropertyNameForIndex(Type indexedType, string indexedName, string path, string prop);
    public static string DefaultFindPropertyNameForDynamicIndex(Type indexedType, string indexedName, string path, string prop);
    [IteratorStateMachineAttribute("Raven.Client.Documents.Conventions.DocumentConventions/<GetPropertiesForType>d__248")]
private static IEnumerable`1<MemberInfo> GetPropertiesForType(Type type);
    public void RegisterQueryMethodConverter(QueryMethodConverter converter);
    internal bool get_AnyQueryMethodConverters();
    public Nullable`1<bool> get_DisableAtomicDocumentWritesInClusterWideTransaction();
    public void set_DisableAtomicDocumentWritesInClusterWideTransaction(Nullable`1<bool> value);
    public bool get_DisableTcpCompression();
    public void set_DisableTcpCompression(bool value);
    internal bool TryConvertQueryMethod(Parameters`1<T> parameters);
    public void RegisterQueryValueConverter(TryConvertValueForQueryDelegate`1<T> converter);
    private void RegisterQueryValueConverter(TryConvertValueToObjectForQueryDelegate`1<T> converter);
    public void RegisterQueryValueConverter(TryConvertValueToObjectForQueryDelegate`1<T> converter, RangeType rangeType);
    internal bool TryConvertValueToObjectForQuery(string fieldName, Type baseType, object value, bool forRange, Object& objValue);
    internal Result TranslateCustomQueryExpression(LinqPathProvider provider, Expression expression);
    private static MemberInfo GetMemberInfoFromExpression(Expression expression);
    internal void Freeze();
    internal void AssertNotFrozen();
    internal TestingStuff ForTestingPurposesOnly();
}
internal class Raven.Client.Documents.Conventions.Inflector : object {
    private static List`1<Rule> Plurals;
    private static List`1<Rule> Singulars;
    private static List`1<string> Uncountables;
    private static Inflector();
    public static string Pluralize(string word);
    public static string Singularize(string word);
    public static string Capitalize(string word);
    private static void AddIrregular(string singular, string plural);
    private static void AddUncountable(string word);
    private static void AddPlural(string rule, string replacement);
    private static void AddSingular(string rule, string replacement);
    private static string ApplyRules(IList rules, string word);
}
public enum Raven.Client.Documents.DataArchival.ArchivedDataProcessingBehavior : Enum {
    public int value__;
    public static ArchivedDataProcessingBehavior ExcludeArchived;
    public static ArchivedDataProcessingBehavior IncludeArchived;
    public static ArchivedDataProcessingBehavior ArchivedOnly;
}
public class Raven.Client.Documents.DocumentStore : DocumentStoreBase {
    private ConcurrentDictionary`2<DatabaseChangesOptions, DatabaseChanges> _databaseChanges;
    internal ConcurrentDictionary`2<string, Lazy`1<EvictItemsFromCacheBasedOnChanges>> _aggressiveCacheChanges;
    private ConcurrentDictionary`2<string, Lazy`1<RequestExecutor>> _requestExecutors;
    private AsyncMultiDatabaseHiLoIdGenerator _asyncMultiDbHiLo;
    private MaintenanceOperationExecutor _maintenanceOperationExecutor;
    private OperationExecutor _operationExecutor;
    private DatabaseSmuggler _smuggler;
    private string _identifier;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestExecutor> RequestExecutorCreated;
    [CompilerGeneratedAttribute]
private EventHandler AfterDispose;
    [CompilerGeneratedAttribute]
private EventHandler BeforeDispose;
    public IHiLoIdGenerator HiLoIdGenerator { get; }
    public string Identifier { get; public set; }
    public DatabaseSmuggler Smuggler { get; }
    public MaintenanceOperationExecutor Maintenance { get; }
    public OperationExecutor Operations { get; }
    public virtual IHiLoIdGenerator get_HiLoIdGenerator();
    protected virtual override void Finalize();
    public virtual string get_Identifier();
    public virtual void set_Identifier(string value);
    public virtual void Dispose();
    public virtual IDocumentSession OpenSession();
    public virtual IDocumentSession OpenSession(string database);
    public virtual IDocumentSession OpenSession(SessionOptions options);
    [CompilerGeneratedAttribute]
public void add_RequestExecutorCreated(EventHandler`1<RequestExecutor> value);
    [CompilerGeneratedAttribute]
public void remove_RequestExecutorCreated(EventHandler`1<RequestExecutor> value);
    public virtual RequestExecutor GetRequestExecutor(string database);
    public virtual IDisposable SetRequestTimeout(TimeSpan timeout, string database);
    public virtual IDocumentStore Initialize();
    private void AssertValidConfiguration();
    public virtual IDisposable DisableAggressiveCaching(string database);
    public virtual IDatabaseChanges Changes(string database);
    public virtual ISingleNodeDatabaseChanges Changes(string database, string nodeTag);
    private DatabaseChanges ChangesInternal(string database, string nodeTag);
    internal DatabaseChanges CreateDatabaseChanges(DatabaseChangesOptions node);
    public virtual IDisposable AggressivelyCacheFor(TimeSpan cacheDuration, string database);
    public virtual IDisposable AggressivelyCacheFor(TimeSpan cacheDuration, AggressiveCacheMode mode, string database);
    public virtual ValueTask`1<IDisposable> AggressivelyCacheForAsync(TimeSpan cacheDuration, string database);
    public virtual ValueTask`1<IDisposable> AggressivelyCacheForAsync(TimeSpan cacheDuration, AggressiveCacheMode mode, string database);
    private IDisposable SetAggressiveCache(TimeSpan cacheDuration, AggressiveCacheMode mode, String& database);
    [AsyncStateMachineAttribute("Raven.Client.Documents.DocumentStore/<FinalizeAggressiveCacheAsync>d__36")]
private ValueTask`1<IDisposable> FinalizeAggressiveCacheAsync(IDisposable release, AggressiveCacheMode mode, string database);
    [AsyncStateMachineAttribute("Raven.Client.Documents.DocumentStore/<ListenToChangesAndUpdateTheCacheAsync>d__37")]
private ValueTask ListenToChangesAndUpdateTheCacheAsync(string database);
    private AsyncDocumentSession OpenAsyncSessionInternal(SessionOptions options);
    public virtual IAsyncDocumentSession OpenAsyncSession(string database);
    public virtual IAsyncDocumentSession OpenAsyncSession(SessionOptions options);
    public virtual IAsyncDocumentSession OpenAsyncSession();
    [CompilerGeneratedAttribute]
public virtual void add_AfterDispose(EventHandler value);
    [CompilerGeneratedAttribute]
public virtual void remove_AfterDispose(EventHandler value);
    [CompilerGeneratedAttribute]
public virtual void add_BeforeDispose(EventHandler value);
    [CompilerGeneratedAttribute]
public virtual void remove_BeforeDispose(EventHandler value);
    public virtual DatabaseSmuggler get_Smuggler();
    public virtual MaintenanceOperationExecutor get_Maintenance();
    public virtual OperationExecutor get_Operations();
    public virtual BulkInsertOperation BulkInsert(string database, CancellationToken token);
    public virtual BulkInsertOperation BulkInsert(string database, BulkInsertOptions options, CancellationToken token);
    public virtual BulkInsertOperation BulkInsert(BulkInsertOptions options, CancellationToken token);
    private void DisposeCertificateIfNeeded();
    [CompilerGeneratedAttribute]
private Task <Dispose>b__14_0();
}
public abstract class Raven.Client.Documents.DocumentStoreBase : object {
    [CompilerGeneratedAttribute]
private bool <WasDisposed>k__BackingField;
    private TimeSeriesOperations _timeSeriesOperation;
    private DocumentConventions _conventions;
    private String[] _urls;
    protected bool Initialized;
    private X509Certificate2 _certificate;
    private string _database;
    [CompilerGeneratedAttribute]
private DocumentSubscriptions <Subscriptions>k__BackingField;
    private ConcurrentDictionary`2<string, Nullable`1<long>> _lastRaftIndexPerDatabase;
    [CompilerGeneratedAttribute]
private EventHandler`1<BeforeStoreEventArgs> OnBeforeStore;
    [CompilerGeneratedAttribute]
private EventHandler`1<AfterSaveChangesEventArgs> OnAfterSaveChanges;
    [CompilerGeneratedAttribute]
private EventHandler`1<BeforeDeleteEventArgs> OnBeforeDelete;
    [CompilerGeneratedAttribute]
private EventHandler`1<BeforeQueryEventArgs> OnBeforeQuery;
    [CompilerGeneratedAttribute]
private EventHandler`1<SessionCreatedEventArgs> OnSessionCreated;
    [CompilerGeneratedAttribute]
private EventHandler`1<SessionDisposingEventArgs> OnSessionDisposing;
    [CompilerGeneratedAttribute]
private EventHandler`1<BeforeConversionToDocumentEventArgs> OnBeforeConversionToDocument;
    [CompilerGeneratedAttribute]
private EventHandler`1<AfterConversionToDocumentEventArgs> OnAfterConversionToDocument;
    [CompilerGeneratedAttribute]
private EventHandler`1<BeforeConversionToEntityEventArgs> OnBeforeConversionToEntity;
    [CompilerGeneratedAttribute]
private EventHandler`1<AfterConversionToEntityEventArgs> OnAfterConversionToEntity;
    [CompilerGeneratedAttribute]
private EventHandler`1<FailedRequestEventArgs> _onFailedRequest;
    [CompilerGeneratedAttribute]
private EventHandler`1<BeforeRequestEventArgs> _onBeforeRequest;
    [CompilerGeneratedAttribute]
private EventHandler`1<SucceedRequestEventArgs> _onSucceedRequest;
    [CompilerGeneratedAttribute]
private EventHandler`1<TopologyUpdatedEventArgs> _onTopologyUpdated;
    public bool WasDisposed { get; protected set; }
    public IHiLoIdGenerator HiLoIdGenerator { get; }
    public string Identifier { get; public set; }
    public TimeSeriesOperations TimeSeries { get; }
    public DocumentConventions Conventions { get; public set; }
    public String[] Urls { get; public set; }
    public DocumentSubscriptions Subscriptions { get; }
    public string Database { get; public set; }
    public X509Certificate2 Certificate { get; public set; }
    public DatabaseSmuggler Smuggler { get; }
    public MaintenanceOperationExecutor Maintenance { get; }
    public OperationExecutor Operations { get; }
    public abstract virtual void Dispose();
    [CompilerGeneratedAttribute]
public abstract virtual void add_AfterDispose(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_AfterDispose(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_BeforeDispose(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BeforeDispose(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_WasDisposed();
    [CompilerGeneratedAttribute]
protected void set_WasDisposed(bool value);
    public abstract virtual IDatabaseChanges Changes(string database);
    public abstract virtual ISingleNodeDatabaseChanges Changes(string database, string nodeTag);
    public abstract virtual IDisposable AggressivelyCacheFor(TimeSpan cacheDuration, string database);
    public abstract virtual IDisposable AggressivelyCacheFor(TimeSpan cacheDuration, AggressiveCacheMode mode, string database);
    public abstract virtual ValueTask`1<IDisposable> AggressivelyCacheForAsync(TimeSpan cacheDuration, string database);
    public abstract virtual ValueTask`1<IDisposable> AggressivelyCacheForAsync(TimeSpan cacheDuration, AggressiveCacheMode mode, string database);
    public abstract virtual IDisposable DisableAggressiveCaching(string database);
    public abstract virtual IHiLoIdGenerator get_HiLoIdGenerator();
    public abstract virtual string get_Identifier();
    public abstract virtual void set_Identifier(string value);
    public abstract virtual IDocumentStore Initialize();
    public abstract virtual IAsyncDocumentSession OpenAsyncSession();
    public abstract virtual IAsyncDocumentSession OpenAsyncSession(string database);
    public abstract virtual IAsyncDocumentSession OpenAsyncSession(SessionOptions sessionOptions);
    public abstract virtual IDocumentSession OpenSession();
    public abstract virtual IDocumentSession OpenSession(string database);
    public abstract virtual IDocumentSession OpenSession(SessionOptions sessionOptions);
    public sealed virtual void ExecuteIndex(IAbstractIndexCreationTask task, string database);
    public sealed virtual Task ExecuteIndexAsync(IAbstractIndexCreationTask task, string database, CancellationToken token);
    public sealed virtual void ExecuteIndexes(IEnumerable`1<IAbstractIndexCreationTask> tasks, string database);
    public sealed virtual Task ExecuteIndexesAsync(IEnumerable`1<IAbstractIndexCreationTask> tasks, string database, CancellationToken token);
    public sealed virtual TimeSeriesOperations get_TimeSeries();
    public virtual DocumentConventions get_Conventions();
    public virtual void set_Conventions(DocumentConventions value);
    public sealed virtual String[] get_Urls();
    public void set_Urls(String[] value);
    public abstract virtual BulkInsertOperation BulkInsert(string database, CancellationToken token);
    public abstract virtual BulkInsertOperation BulkInsert(string database, BulkInsertOptions options, CancellationToken token);
    public abstract virtual BulkInsertOperation BulkInsert(BulkInsertOptions options, CancellationToken token);
    [CompilerGeneratedAttribute]
public sealed virtual DocumentSubscriptions get_Subscriptions();
    internal Nullable`1<long> GetLastTransactionIndex(string database);
    internal void SetLastTransactionIndex(string database, Nullable`1<long> index);
    protected void EnsureNotClosed();
    protected internal void AssertInitialized();
    private void AssertNotInitialized(string property);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnBeforeStore(EventHandler`1<BeforeStoreEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnBeforeStore(EventHandler`1<BeforeStoreEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnAfterSaveChanges(EventHandler`1<AfterSaveChangesEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnAfterSaveChanges(EventHandler`1<AfterSaveChangesEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnBeforeDelete(EventHandler`1<BeforeDeleteEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnBeforeDelete(EventHandler`1<BeforeDeleteEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnBeforeQuery(EventHandler`1<BeforeQueryEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnBeforeQuery(EventHandler`1<BeforeQueryEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnSessionCreated(EventHandler`1<SessionCreatedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnSessionCreated(EventHandler`1<SessionCreatedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnSessionDisposing(EventHandler`1<SessionDisposingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnSessionDisposing(EventHandler`1<SessionDisposingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnBeforeConversionToDocument(EventHandler`1<BeforeConversionToDocumentEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnBeforeConversionToDocument(EventHandler`1<BeforeConversionToDocumentEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnAfterConversionToDocument(EventHandler`1<AfterConversionToDocumentEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnAfterConversionToDocument(EventHandler`1<AfterConversionToDocumentEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnBeforeConversionToEntity(EventHandler`1<BeforeConversionToEntityEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnBeforeConversionToEntity(EventHandler`1<BeforeConversionToEntityEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnAfterConversionToEntity(EventHandler`1<AfterConversionToEntityEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnAfterConversionToEntity(EventHandler`1<AfterConversionToEntityEventArgs> value);
    [CompilerGeneratedAttribute]
private void add__onFailedRequest(EventHandler`1<FailedRequestEventArgs> value);
    [CompilerGeneratedAttribute]
private void remove__onFailedRequest(EventHandler`1<FailedRequestEventArgs> value);
    public sealed virtual void add_OnFailedRequest(EventHandler`1<FailedRequestEventArgs> value);
    public sealed virtual void remove_OnFailedRequest(EventHandler`1<FailedRequestEventArgs> value);
    [CompilerGeneratedAttribute]
private void add__onBeforeRequest(EventHandler`1<BeforeRequestEventArgs> value);
    [CompilerGeneratedAttribute]
private void remove__onBeforeRequest(EventHandler`1<BeforeRequestEventArgs> value);
    public sealed virtual void add_OnBeforeRequest(EventHandler`1<BeforeRequestEventArgs> value);
    public sealed virtual void remove_OnBeforeRequest(EventHandler`1<BeforeRequestEventArgs> value);
    [CompilerGeneratedAttribute]
private void add__onSucceedRequest(EventHandler`1<SucceedRequestEventArgs> value);
    [CompilerGeneratedAttribute]
private void remove__onSucceedRequest(EventHandler`1<SucceedRequestEventArgs> value);
    public sealed virtual void add_OnSucceedRequest(EventHandler`1<SucceedRequestEventArgs> value);
    public sealed virtual void remove_OnSucceedRequest(EventHandler`1<SucceedRequestEventArgs> value);
    [CompilerGeneratedAttribute]
private void add__onTopologyUpdated(EventHandler`1<TopologyUpdatedEventArgs> value);
    [CompilerGeneratedAttribute]
private void remove__onTopologyUpdated(EventHandler`1<TopologyUpdatedEventArgs> value);
    public sealed virtual void add_OnTopologyUpdated(EventHandler`1<TopologyUpdatedEventArgs> value);
    public sealed virtual void remove_OnTopologyUpdated(EventHandler`1<TopologyUpdatedEventArgs> value);
    public sealed virtual string get_Database();
    public sealed virtual void set_Database(string value);
    public sealed virtual X509Certificate2 get_Certificate();
    public void set_Certificate(X509Certificate2 value);
    public abstract virtual RequestExecutor GetRequestExecutor(string databaseName);
    public abstract virtual DatabaseSmuggler get_Smuggler();
    public abstract virtual IDisposable SetRequestTimeout(TimeSpan timeout, string database);
    public sealed virtual IDisposable AggressivelyCache(string database);
    public sealed virtual ValueTask`1<IDisposable> AggressivelyCacheAsync(string database);
    protected void RegisterEvents(InMemoryDocumentSessionOperations session);
    protected internal void RegisterEvents(RequestExecutor requestExecutor);
    protected void AfterSessionCreated(InMemoryDocumentSessionOperations session);
    public abstract virtual MaintenanceOperationExecutor get_Maintenance();
    public abstract virtual OperationExecutor get_Operations();
}
internal class Raven.Client.Documents.Identity.AsyncDocumentIdGeneration : object {
    private LinkedList`1<object> _entitiesStoredWithoutIDs;
    private InMemoryDocumentSessionOperations _session;
    private TryGetValue _tryGetValue;
    private ModifyObjectId _modifyObjectId;
    public AsyncDocumentIdGeneration(InMemoryDocumentSessionOperations session, TryGetValue tryGetValue, ModifyObjectId modifyObjectId);
    public Task GenerateDocumentIdsForSaveChanges();
    public void Add(object entity);
}
public class Raven.Client.Documents.Identity.AsyncHiLoIdGenerator : object {
    private DocumentStore _store;
    private string _tag;
    protected string Prefix;
    private long _lastBatchSize;
    private DateTime _lastRangeDate;
    private string _dbName;
    private char _identityPartsSeparator;
    private RangeValue modreq(System.Runtime.CompilerServices.IsVolatile) _range;
    private Lazy`1<Task> _nextRangeTask;
    internal TestingStuff _forTestingPurposes;
    protected RangeValue Range { get; protected set; }
    public AsyncHiLoIdGenerator(string tag, DocumentStore store, string dbName, char identityPartsSeparator);
    protected virtual string GetDocumentIdFromId(NextId result);
    protected RangeValue get_Range();
    protected void set_Range(RangeValue value);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Identity.AsyncHiLoIdGenerator/<GenerateDocumentIdAsync>d__15")]
public virtual Task`1<string> GenerateDocumentIdAsync(object entity);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Identity.AsyncHiLoIdGenerator/<GetNextIdAsync>d__16")]
public Task`1<NextId> GetNextIdAsync();
    [AsyncStateMachineAttribute("Raven.Client.Documents.Identity.AsyncHiLoIdGenerator/<GetNextRangeAsync>d__17")]
private Task GetNextRangeAsync();
    [AsyncStateMachineAttribute("Raven.Client.Documents.Identity.AsyncHiLoIdGenerator/<ReturnUnusedRangeAsync>d__18")]
public Task ReturnUnusedRangeAsync();
    internal TestingStuff ForTestingPurposesOnly();
}
public class Raven.Client.Documents.Identity.AsyncMultiDatabaseHiLoIdGenerator : object {
    protected DocumentStore Store;
    private ConcurrentDictionary`2<string, AsyncMultiTypeHiLoIdGenerator> _generators;
    public AsyncMultiDatabaseHiLoIdGenerator(DocumentStore store);
    public sealed virtual Task`1<string> GenerateDocumentIdAsync(string database, object entity);
    public sealed virtual Task`1<long> GenerateNextIdForAsync(string database, object entity);
    public sealed virtual Task`1<long> GenerateNextIdForAsync(string database, Type type);
    public sealed virtual Task`1<long> GenerateNextIdForAsync(string database, string collectionName);
    public virtual AsyncMultiTypeHiLoIdGenerator GenerateAsyncMultiTypeHiLoFunc(string database);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Identity.AsyncMultiDatabaseHiLoIdGenerator/<ReturnUnusedRange>d__8")]
public Task ReturnUnusedRange();
}
public class Raven.Client.Documents.Identity.AsyncMultiTypeHiLoIdGenerator : object {
    private SemaphoreSlim _generatorLock;
    private ConcurrentDictionary`2<string, AsyncHiLoIdGenerator> _idGeneratorsByTag;
    protected DocumentStore Store;
    protected string DbName;
    protected DocumentConventions Conventions;
    private char _identityPartsSeparator;
    public AsyncMultiTypeHiLoIdGenerator(DocumentStore store, string dbName);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Identity.AsyncMultiTypeHiLoIdGenerator/<GenerateDocumentIdAsync>d__7")]
public Task`1<string> GenerateDocumentIdAsync(object entity);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Identity.AsyncMultiTypeHiLoIdGenerator/<MaybeRefresh>d__8")]
private Task MaybeRefresh(char identityPartsSeparator);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Identity.AsyncMultiTypeHiLoIdGenerator/<GenerateNextIdForAsync>d__9")]
public Task`1<long> GenerateNextIdForAsync(string collectionName);
    protected virtual AsyncHiLoIdGenerator CreateGeneratorFor(string tag);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Identity.AsyncMultiTypeHiLoIdGenerator/<ReturnUnusedRange>d__11")]
public Task ReturnUnusedRange();
    [AsyncStateMachineAttribute("Raven.Client.Documents.Identity.AsyncMultiTypeHiLoIdGenerator/<ReturnUnusedRange>d__12")]
private static Task ReturnUnusedRange(IEnumerable`1<AsyncHiLoIdGenerator> generators);
}
public class Raven.Client.Documents.Identity.GenerateEntityIdOnTheClient : object {
    private DocumentConventions _conventions;
    private Func`2<object, string> _generateId;
    private Func`2<object, Task`1<string>> _generateIdAsync;
    [ObsoleteAttribute("This constructor is not supported anymore. Will be removed in next major version of the product. Use constructor with 'generateIdAsync' parameter instead.")]
public GenerateEntityIdOnTheClient(DocumentConventions conventions, Func`2<object, string> generateId);
    public GenerateEntityIdOnTheClient(DocumentConventions conventions, Func`2<object, Task`1<string>> generateIdAsync);
    private MemberInfo GetIdentityProperty(Type entityType);
    public bool TryGetIdFromInstance(object entity, String& id);
    public string GetOrGenerateDocumentId(object entity);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Identity.GenerateEntityIdOnTheClient/<GetOrGenerateDocumentIdAsync>d__8")]
public ValueTask`1<string> GetOrGenerateDocumentIdAsync(object entity);
    public string GenerateDocumentIdForStorage(object entity);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Identity.GenerateEntityIdOnTheClient/<GenerateDocumentIdForStorageAsync>d__10")]
public ValueTask`1<string> GenerateDocumentIdForStorageAsync(object entity);
    public bool TryGetIdFromDynamic(object entity, String& id);
    protected internal void TrySetIdentity(object entity, string id);
    internal void TrySetIdentity(object entity, string id, bool isProjection);
    private void TrySetIdentityInternal(object entity, string id, bool isProjection);
    public void TrySetIdOnDynamic(object entity, string id);
    private static void SetPropertyOrField(MemberInfo memberInfo, object entity, Action`1<object> setIdentifier, string id);
    [CompilerGeneratedAttribute]
private string <.ctor>b__4_0(object entity);
}
public class Raven.Client.Documents.Identity.HiloDocument : object {
    [CompilerGeneratedAttribute]
private long <Max>k__BackingField;
    public long Max { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Max();
    [CompilerGeneratedAttribute]
public void set_Max(long value);
}
public class Raven.Client.Documents.Identity.HiLoResult : object {
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Low>k__BackingField;
    [CompilerGeneratedAttribute]
private long <High>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerTag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastRangeAt>k__BackingField;
    public string Prefix { get; public set; }
    public long Low { get; public set; }
    public long High { get; public set; }
    public long LastSize { get; public set; }
    public string ServerTag { get; public set; }
    public DateTime LastRangeAt { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public void set_Prefix(string value);
    [CompilerGeneratedAttribute]
public long get_Low();
    [CompilerGeneratedAttribute]
public void set_Low(long value);
    [CompilerGeneratedAttribute]
public long get_High();
    [CompilerGeneratedAttribute]
public void set_High(long value);
    [CompilerGeneratedAttribute]
public long get_LastSize();
    [CompilerGeneratedAttribute]
public void set_LastSize(long value);
    [CompilerGeneratedAttribute]
public string get_ServerTag();
    [CompilerGeneratedAttribute]
public void set_ServerTag(string value);
    [CompilerGeneratedAttribute]
public DateTime get_LastRangeAt();
    [CompilerGeneratedAttribute]
public void set_LastRangeAt(DateTime value);
}
public interface Raven.Client.Documents.Identity.IHiLoIdGenerator {
    public abstract virtual Task`1<long> GenerateNextIdForAsync(string database, object entity);
    public abstract virtual Task`1<long> GenerateNextIdForAsync(string database, Type type);
    public abstract virtual Task`1<long> GenerateNextIdForAsync(string database, string collectionName);
    public abstract virtual Task`1<string> GenerateDocumentIdAsync(string database, object entity);
}
public interface Raven.Client.Documents.IDocumentStore {
    public X509Certificate2 Certificate { get; }
    public IHiLoIdGenerator HiLoIdGenerator { get; }
    public string Identifier { get; public set; }
    public TimeSeriesOperations TimeSeries { get; }
    public DocumentConventions Conventions { get; }
    public String[] Urls { get; }
    public DocumentSubscriptions Subscriptions { get; }
    public string Database { get; public set; }
    public MaintenanceOperationExecutor Maintenance { get; }
    public OperationExecutor Operations { get; }
    public DatabaseSmuggler Smuggler { get; }
    public abstract virtual X509Certificate2 get_Certificate();
    public abstract virtual IHiLoIdGenerator get_HiLoIdGenerator();
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnBeforeStore(EventHandler`1<BeforeStoreEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnBeforeStore(EventHandler`1<BeforeStoreEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnAfterSaveChanges(EventHandler`1<AfterSaveChangesEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnAfterSaveChanges(EventHandler`1<AfterSaveChangesEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnBeforeDelete(EventHandler`1<BeforeDeleteEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnBeforeDelete(EventHandler`1<BeforeDeleteEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnBeforeQuery(EventHandler`1<BeforeQueryEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnBeforeQuery(EventHandler`1<BeforeQueryEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnSessionCreated(EventHandler`1<SessionCreatedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnSessionCreated(EventHandler`1<SessionCreatedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnBeforeConversionToDocument(EventHandler`1<BeforeConversionToDocumentEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnBeforeConversionToDocument(EventHandler`1<BeforeConversionToDocumentEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnAfterConversionToDocument(EventHandler`1<AfterConversionToDocumentEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnAfterConversionToDocument(EventHandler`1<AfterConversionToDocumentEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnBeforeConversionToEntity(EventHandler`1<BeforeConversionToEntityEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnBeforeConversionToEntity(EventHandler`1<BeforeConversionToEntityEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnAfterConversionToEntity(EventHandler`1<AfterConversionToEntityEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnAfterConversionToEntity(EventHandler`1<AfterConversionToEntityEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnFailedRequest(EventHandler`1<FailedRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnFailedRequest(EventHandler`1<FailedRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnBeforeRequest(EventHandler`1<BeforeRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnBeforeRequest(EventHandler`1<BeforeRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnSucceedRequest(EventHandler`1<SucceedRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnSucceedRequest(EventHandler`1<SucceedRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnTopologyUpdated(EventHandler`1<TopologyUpdatedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnTopologyUpdated(EventHandler`1<TopologyUpdatedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnSessionDisposing(EventHandler`1<SessionDisposingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnSessionDisposing(EventHandler`1<SessionDisposingEventArgs> value);
    public abstract virtual IDatabaseChanges Changes(string database);
    public abstract virtual ISingleNodeDatabaseChanges Changes(string database, string nodeTag);
    public abstract virtual IDisposable AggressivelyCacheFor(TimeSpan cacheDuration, string database);
    public abstract virtual IDisposable AggressivelyCacheFor(TimeSpan cacheDuration, AggressiveCacheMode mode, string database);
    public abstract virtual ValueTask`1<IDisposable> AggressivelyCacheForAsync(TimeSpan cacheDuration, string database);
    public abstract virtual ValueTask`1<IDisposable> AggressivelyCacheForAsync(TimeSpan cacheDuration, AggressiveCacheMode mode, string database);
    public abstract virtual IDisposable AggressivelyCache(string database);
    public abstract virtual ValueTask`1<IDisposable> AggressivelyCacheAsync(string database);
    public abstract virtual IDisposable DisableAggressiveCaching(string database);
    public abstract virtual string get_Identifier();
    public abstract virtual void set_Identifier(string value);
    public abstract virtual IDocumentStore Initialize();
    public abstract virtual IAsyncDocumentSession OpenAsyncSession();
    public abstract virtual IAsyncDocumentSession OpenAsyncSession(string database);
    public abstract virtual IAsyncDocumentSession OpenAsyncSession(SessionOptions sessionOptions);
    public abstract virtual IDocumentSession OpenSession();
    public abstract virtual IDocumentSession OpenSession(string database);
    public abstract virtual IDocumentSession OpenSession(SessionOptions sessionOptions);
    public abstract virtual void ExecuteIndex(IAbstractIndexCreationTask task, string database);
    public abstract virtual void ExecuteIndexes(IEnumerable`1<IAbstractIndexCreationTask> tasks, string database);
    public abstract virtual Task ExecuteIndexAsync(IAbstractIndexCreationTask task, string database, CancellationToken token);
    public abstract virtual Task ExecuteIndexesAsync(IEnumerable`1<IAbstractIndexCreationTask> tasks, string database, CancellationToken token);
    public abstract virtual TimeSeriesOperations get_TimeSeries();
    public abstract virtual DocumentConventions get_Conventions();
    public abstract virtual String[] get_Urls();
    public abstract virtual BulkInsertOperation BulkInsert(string database, CancellationToken token);
    public abstract virtual BulkInsertOperation BulkInsert(string database, BulkInsertOptions options, CancellationToken token);
    public abstract virtual BulkInsertOperation BulkInsert(BulkInsertOptions options, CancellationToken token);
    public abstract virtual DocumentSubscriptions get_Subscriptions();
    public abstract virtual string get_Database();
    public abstract virtual void set_Database(string value);
    public abstract virtual RequestExecutor GetRequestExecutor(string database);
    public abstract virtual MaintenanceOperationExecutor get_Maintenance();
    public abstract virtual OperationExecutor get_Operations();
    public abstract virtual DatabaseSmuggler get_Smuggler();
    public abstract virtual IDisposable SetRequestTimeout(TimeSpan timeout, string database);
}
public abstract class Raven.Client.Documents.Indexes.AbstractCommonApiForIndexes : object {
    [CompilerGeneratedAttribute]
private NoTrackingCommonApiForIndexes <NoTracking>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <AdditionalSources>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<AdditionalAssembly> <AdditionalAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexConfiguration <Configuration>k__BackingField;
    public bool IsMapReduce { get; }
    public string IndexName { get; }
    public NoTrackingCommonApiForIndexes NoTracking { get; }
    public Dictionary`2<string, string> AdditionalSources { get; public set; }
    public HashSet`1<AdditionalAssembly> AdditionalAssemblies { get; public set; }
    public IndexConfiguration Configuration { get; public set; }
    public virtual bool get_IsMapReduce();
    public virtual string get_IndexName();
    protected IEnumerable`1<TResult> Recurse(TSource source, Func`2<TSource, TResult> func);
    protected IEnumerable`1<TResult> Recurse(TSource source, Func`2<TSource, IEnumerable`1<TResult>> func);
    protected IEnumerable`1<TResult> Recurse(TSource source, Func`2<TSource, ICollection`1<TResult>> func);
    protected IEnumerable`1<TResult> Recurse(TSource source, Func`2<TSource, ISet`1<TResult>> func);
    protected IEnumerable`1<TResult> Recurse(TSource source, Func`2<TSource, HashSet`1<TResult>> func);
    protected IEnumerable`1<TResult> Recurse(TSource source, Func`2<TSource, SortedSet`1<TResult>> func);
    [CompilerGeneratedAttribute]
public NoTrackingCommonApiForIndexes get_NoTracking();
    protected IEnumerable`1<TResult> Recurse(TSource source, Func`2<TSource, IList`1<TResult>> func);
    protected IEnumerable`1<TResult> Recurse(TSource source, Func`2<TSource, TResult[]> func);
    protected IEnumerable`1<TResult> Recurse(TSource source, Func`2<TSource, List`1<TResult>> func);
    protected Nullable`1<T> TryConvert(object value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_AdditionalSources();
    [CompilerGeneratedAttribute]
public void set_AdditionalSources(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public HashSet`1<AdditionalAssembly> get_AdditionalAssemblies();
    [CompilerGeneratedAttribute]
public void set_AdditionalAssemblies(HashSet`1<AdditionalAssembly> value);
    [CompilerGeneratedAttribute]
public IndexConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(IndexConfiguration value);
    public sealed virtual T LoadDocument(string id);
    public sealed virtual T LoadDocument(string id, string collectionName);
    public sealed virtual T[] LoadDocument(IEnumerable`1<string> ids);
    public sealed virtual T[] LoadDocument(IEnumerable`1<string> ids, string collectionName);
    public sealed virtual T LoadCompareExchangeValue(string key);
    public sealed virtual T[] LoadCompareExchangeValue(IEnumerable`1<string> keys);
}
public abstract class Raven.Client.Documents.Indexes.AbstractGenericIndexCreationTask`1 : AbstractIndexCreationTask {
    [CompilerGeneratedAttribute]
private List`1<Expression`1[]> <CompoundFields>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<IEnumerable`1<TReduceResult>, IEnumerable>> <Reduce>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldStorage> <Stores>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, FieldStorage> <StoresStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<Expression`1<Func`2<TReduceResult, object>>> <IndexSuggestions>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, string> <Analyzers>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <AnalyzersStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldTermVector> <TermVectors>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, FieldTermVector> <TermVectorsStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, SpatialOptions> <SpatialIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, SpatialOptions> <SpatialIndexesStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldIndexing> <Indexes>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, FieldIndexing> <IndexesStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputReduceToCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<TReduceResult, string>> <PatternForOutputReduceToCollectionReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PatternReferencesCollectionName>k__BackingField;
    public List`1<Expression`1[]> CompoundFields { get; public set; }
    public bool IsMapReduce { get; }
    protected Expression`1<Func`2<IEnumerable`1<TReduceResult>, IEnumerable>> Reduce { get; protected set; }
    protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldStorage> Stores { get; protected set; }
    protected IDictionary`2<string, FieldStorage> StoresStrings { get; protected set; }
    protected ISet`1<Expression`1<Func`2<TReduceResult, object>>> IndexSuggestions { get; protected set; }
    protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, string> Analyzers { get; protected set; }
    protected IDictionary`2<string, string> AnalyzersStrings { get; protected set; }
    protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldTermVector> TermVectors { get; protected set; }
    protected IDictionary`2<string, FieldTermVector> TermVectorsStrings { get; protected set; }
    protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, SpatialOptions> SpatialIndexes { get; protected set; }
    protected IDictionary`2<string, SpatialOptions> SpatialIndexesStrings { get; protected set; }
    protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldIndexing> Indexes { get; protected set; }
    protected IDictionary`2<string, FieldIndexing> IndexesStrings { get; protected set; }
    protected string OutputReduceToCollection { get; protected set; }
    protected Expression`1<Func`2<TReduceResult, string>> PatternForOutputReduceToCollectionReferences { get; protected set; }
    protected string PatternReferencesCollectionName { get; protected set; }
    [CompilerGeneratedAttribute]
public List`1<Expression`1[]> get_CompoundFields();
    [CompilerGeneratedAttribute]
public void set_CompoundFields(List`1<Expression`1[]> value);
    public virtual bool get_IsMapReduce();
    [CompilerGeneratedAttribute]
protected Expression`1<Func`2<IEnumerable`1<TReduceResult>, IEnumerable>> get_Reduce();
    [CompilerGeneratedAttribute]
protected void set_Reduce(Expression`1<Func`2<IEnumerable`1<TReduceResult>, IEnumerable>> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldStorage> get_Stores();
    [CompilerGeneratedAttribute]
protected void set_Stores(IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldStorage> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<string, FieldStorage> get_StoresStrings();
    [CompilerGeneratedAttribute]
protected void set_StoresStrings(IDictionary`2<string, FieldStorage> value);
    [CompilerGeneratedAttribute]
protected ISet`1<Expression`1<Func`2<TReduceResult, object>>> get_IndexSuggestions();
    [CompilerGeneratedAttribute]
protected void set_IndexSuggestions(ISet`1<Expression`1<Func`2<TReduceResult, object>>> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, string> get_Analyzers();
    [CompilerGeneratedAttribute]
protected void set_Analyzers(IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, string> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<string, string> get_AnalyzersStrings();
    [CompilerGeneratedAttribute]
protected void set_AnalyzersStrings(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldTermVector> get_TermVectors();
    [CompilerGeneratedAttribute]
protected void set_TermVectors(IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldTermVector> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<string, FieldTermVector> get_TermVectorsStrings();
    [CompilerGeneratedAttribute]
protected void set_TermVectorsStrings(IDictionary`2<string, FieldTermVector> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, SpatialOptions> get_SpatialIndexes();
    [CompilerGeneratedAttribute]
protected void set_SpatialIndexes(IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, SpatialOptions> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<string, SpatialOptions> get_SpatialIndexesStrings();
    [CompilerGeneratedAttribute]
protected void set_SpatialIndexesStrings(IDictionary`2<string, SpatialOptions> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldIndexing> get_Indexes();
    [CompilerGeneratedAttribute]
protected void set_Indexes(IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldIndexing> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<string, FieldIndexing> get_IndexesStrings();
    [CompilerGeneratedAttribute]
protected void set_IndexesStrings(IDictionary`2<string, FieldIndexing> value);
    [CompilerGeneratedAttribute]
protected string get_OutputReduceToCollection();
    [CompilerGeneratedAttribute]
protected void set_OutputReduceToCollection(string value);
    [CompilerGeneratedAttribute]
protected Expression`1<Func`2<TReduceResult, string>> get_PatternForOutputReduceToCollectionReferences();
    [CompilerGeneratedAttribute]
protected void set_PatternForOutputReduceToCollectionReferences(Expression`1<Func`2<TReduceResult, string>> value);
    [CompilerGeneratedAttribute]
protected string get_PatternReferencesCollectionName();
    [CompilerGeneratedAttribute]
protected void set_PatternReferencesCollectionName(string value);
    protected void Index(Expression`1<Func`2<TReduceResult, object>> field, FieldIndexing indexing);
    protected void Index(string field, FieldIndexing indexing);
    protected void Spatial(Expression`1<Func`2<TReduceResult, object>> field, Func`2<SpatialOptionsFactory, SpatialOptions> indexing);
    protected void Spatial(string field, Func`2<SpatialOptionsFactory, SpatialOptions> indexing);
    protected void Store(Expression`1<Func`2<TReduceResult, object>> field, FieldStorage storage);
    protected void StoreAllFields(FieldStorage storage);
    protected void Store(string field, FieldStorage storage);
    protected void Analyze(Expression`1<Func`2<TReduceResult, object>> field, string analyzer);
    protected void Analyze(string field, string analyzer);
    protected void TermVector(Expression`1<Func`2<TReduceResult, object>> field, FieldTermVector termVector);
    protected void TermVector(string field, FieldTermVector termVector);
    protected void Suggestion(Expression`1<Func`2<TReduceResult, object>> field);
    protected void AddAssembly(AdditionalAssembly assembly);
    protected void CompoundField(Expression`1<Func`2<TReduceResult, object>> first, Expression`1<Func`2<TReduceResult, object>> second);
}
public abstract class Raven.Client.Documents.Indexes.AbstractIndexCreationTask : AbstractIndexCreationTaskBase`1<IndexDefinition> {
    protected IMetadata MetadataFor(object doc);
    protected IEnumerable`1<AttachmentName> AttachmentsFor(object doc);
    protected IEnumerable`1<string> CounterNamesFor(object doc);
    protected IEnumerable`1<string> TimeSeriesNamesFor(object doc);
    public IAttachmentObject LoadAttachment(object doc, string name);
    public IEnumerable`1<IAttachmentObject> LoadAttachments(object doc);
    protected IJsonObject AsJson(object doc);
}
public abstract class Raven.Client.Documents.Indexes.AbstractIndexCreationTask`1 : AbstractIndexCreationTask`2<TDocument, TDocument> {
}
public abstract class Raven.Client.Documents.Indexes.AbstractIndexCreationTask`2 : AbstractGenericIndexCreationTask`1<TReduceResult> {
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<IEnumerable`1<TDocument>, IEnumerable>> <Map>k__BackingField;
    protected Expression`1<Func`2<IEnumerable`1<TDocument>, IEnumerable>> Map { get; protected set; }
    public virtual IndexDefinition CreateIndexDefinition();
    [CompilerGeneratedAttribute]
protected Expression`1<Func`2<IEnumerable`1<TDocument>, IEnumerable>> get_Map();
    [CompilerGeneratedAttribute]
protected void set_Map(Expression`1<Func`2<IEnumerable`1<TDocument>, IEnumerable>> value);
}
public abstract class Raven.Client.Documents.Indexes.AbstractIndexCreationTaskBase`1 : AbstractCommonApiForIndexes {
    [CompilerGeneratedAttribute]
private DocumentConventions <Conventions>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<IndexPriority> <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<IndexLockMode> <LockMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<IndexDeploymentMode> <DeploymentMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SearchEngineType> <SearchEngineType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ArchivedDataProcessingBehavior> <ArchivedDataProcessingBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<IndexState> <State>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<String[]> <CompoundFieldsStrings>k__BackingField;
    private Nullable`1<IndexPriority> Raven.Client.Documents.Indexes.IAbstractIndexCreationTask.Priority { get; }
    private string Raven.Client.Documents.Indexes.IAbstractIndexCreationTask.IndexName { get; }
    private Nullable`1<IndexDeploymentMode> Raven.Client.Documents.Indexes.IAbstractIndexCreationTask.DeploymentMode { get; }
    private DocumentConventions Raven.Client.Documents.Indexes.IAbstractIndexCreationTask.Conventions { get; private set; }
    public DocumentConventions Conventions { get; public set; }
    public Nullable`1<IndexPriority> Priority { get; public set; }
    public Nullable`1<IndexLockMode> LockMode { get; public set; }
    public Nullable`1<IndexDeploymentMode> DeploymentMode { get; public set; }
    public Nullable`1<SearchEngineType> SearchEngineType { get; public set; }
    public Nullable`1<ArchivedDataProcessingBehavior> ArchivedDataProcessingBehavior { get; public set; }
    public Nullable`1<IndexState> State { get; public set; }
    public List`1<String[]> CompoundFieldsStrings { get; public set; }
    private sealed virtual override Nullable`1<IndexPriority> Raven.Client.Documents.Indexes.IAbstractIndexCreationTask.get_Priority();
    private sealed virtual override string Raven.Client.Documents.Indexes.IAbstractIndexCreationTask.get_IndexName();
    private sealed virtual override Nullable`1<IndexDeploymentMode> Raven.Client.Documents.Indexes.IAbstractIndexCreationTask.get_DeploymentMode();
    private sealed virtual override DocumentConventions Raven.Client.Documents.Indexes.IAbstractIndexCreationTask.get_Conventions();
    private sealed virtual override void Raven.Client.Documents.Indexes.IAbstractIndexCreationTask.set_Conventions(DocumentConventions value);
    private sealed virtual override IndexDefinition Raven.Client.Documents.Indexes.IAbstractIndexCreationTask.CreateIndexDefinition();
    private sealed virtual override void Raven.Client.Documents.Indexes.IAbstractIndexCreationTask.Execute(IDocumentStore store, DocumentConventions conventions, string database);
    private sealed virtual override Task Raven.Client.Documents.Indexes.IAbstractIndexCreationTask.ExecuteAsync(IDocumentStore store, DocumentConventions conventions, string database, CancellationToken token);
    public abstract virtual TIndexDefinition CreateIndexDefinition();
    [CompilerGeneratedAttribute]
public DocumentConventions get_Conventions();
    [CompilerGeneratedAttribute]
public void set_Conventions(DocumentConventions value);
    [CompilerGeneratedAttribute]
public Nullable`1<IndexPriority> get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(Nullable`1<IndexPriority> value);
    [CompilerGeneratedAttribute]
public Nullable`1<IndexLockMode> get_LockMode();
    [CompilerGeneratedAttribute]
public void set_LockMode(Nullable`1<IndexLockMode> value);
    [CompilerGeneratedAttribute]
public Nullable`1<IndexDeploymentMode> get_DeploymentMode();
    [CompilerGeneratedAttribute]
public void set_DeploymentMode(Nullable`1<IndexDeploymentMode> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<SearchEngineType> get_SearchEngineType();
    [CompilerGeneratedAttribute]
public void set_SearchEngineType(Nullable`1<SearchEngineType> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ArchivedDataProcessingBehavior> get_ArchivedDataProcessingBehavior();
    [CompilerGeneratedAttribute]
public void set_ArchivedDataProcessingBehavior(Nullable`1<ArchivedDataProcessingBehavior> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<IndexState> get_State();
    [CompilerGeneratedAttribute]
public void set_State(Nullable`1<IndexState> value);
    protected object CreateField(string name, object value, CreateFieldOptions options);
    protected object CreateField(string name, object value, bool stored, bool analyzed);
    protected object CreateField(string name, object value);
    public object CreateSpatialField(Nullable`1<double> lat, Nullable`1<double> lng);
    public object CreateSpatialField(string shapeWkt);
    public virtual void Execute(IDocumentStore store, DocumentConventions conventions, string database);
    [CompilerGeneratedAttribute]
public List`1<String[]> get_CompoundFieldsStrings();
    [CompilerGeneratedAttribute]
public void set_CompoundFieldsStrings(List`1<String[]> value);
    protected void CompoundField(string firstField, string secondField);
    public virtual Task ExecuteAsync(IDocumentStore store, DocumentConventions conventions, string database, CancellationToken token);
}
public abstract class Raven.Client.Documents.Indexes.AbstractIndexDefinitionBuilder`3 : object {
    protected string _indexName;
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<IEnumerable`1<TReduceResult>, IEnumerable>> <Reduce>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldStorage> <Stores>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, FieldStorage> <StoresStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldIndexing> <Indexes>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, FieldIndexing> <IndexesStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, string> <Analyzers>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <AnalyzersStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<Expression`1<Func`2<TReduceResult, object>>> <SuggestionsOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldTermVector> <TermVectors>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, FieldTermVector> <TermVectorsStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, SpatialOptions> <SpatialIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, SpatialOptions> <SpatialIndexesStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<IndexLockMode> <LockMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<IndexPriority> <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<IndexState> <State>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<String[]> <CompoundFieldsStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Expression`1[]> <CompoundFields>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<IndexDeploymentMode> <DeploymentMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputReduceToCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<TReduceResult, string>> <PatternForOutputReduceToCollectionReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PatternReferencesCollectionName>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <AdditionalSources>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<AdditionalAssembly> <AdditionalAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexConfiguration <Configuration>k__BackingField;
    public Expression`1<Func`2<IEnumerable`1<TReduceResult>, IEnumerable>> Reduce { get; public set; }
    public IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldStorage> Stores { get; public set; }
    public IDictionary`2<string, FieldStorage> StoresStrings { get; public set; }
    public IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldIndexing> Indexes { get; public set; }
    public IDictionary`2<string, FieldIndexing> IndexesStrings { get; public set; }
    public IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, string> Analyzers { get; public set; }
    public IDictionary`2<string, string> AnalyzersStrings { get; public set; }
    public ISet`1<Expression`1<Func`2<TReduceResult, object>>> SuggestionsOptions { get; public set; }
    public IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldTermVector> TermVectors { get; public set; }
    public IDictionary`2<string, FieldTermVector> TermVectorsStrings { get; public set; }
    public IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, SpatialOptions> SpatialIndexes { get; public set; }
    public IDictionary`2<string, SpatialOptions> SpatialIndexesStrings { get; public set; }
    public Nullable`1<IndexLockMode> LockMode { get; public set; }
    public Nullable`1<IndexPriority> Priority { get; public set; }
    public Nullable`1<IndexState> State { get; public set; }
    public List`1<String[]> CompoundFieldsStrings { get; public set; }
    public List`1<Expression`1[]> CompoundFields { get; public set; }
    public Nullable`1<IndexDeploymentMode> DeploymentMode { get; public set; }
    public string OutputReduceToCollection { get; public set; }
    public Expression`1<Func`2<TReduceResult, string>> PatternForOutputReduceToCollectionReferences { get; public set; }
    public string PatternReferencesCollectionName { get; public set; }
    public Dictionary`2<string, string> AdditionalSources { get; public set; }
    public HashSet`1<AdditionalAssembly> AdditionalAssemblies { get; public set; }
    public IndexConfiguration Configuration { get; public set; }
    protected AbstractIndexDefinitionBuilder`3(string indexName);
    [CompilerGeneratedAttribute]
public Expression`1<Func`2<IEnumerable`1<TReduceResult>, IEnumerable>> get_Reduce();
    [CompilerGeneratedAttribute]
public void set_Reduce(Expression`1<Func`2<IEnumerable`1<TReduceResult>, IEnumerable>> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldStorage> get_Stores();
    [CompilerGeneratedAttribute]
public void set_Stores(IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldStorage> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, FieldStorage> get_StoresStrings();
    [CompilerGeneratedAttribute]
public void set_StoresStrings(IDictionary`2<string, FieldStorage> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldIndexing> get_Indexes();
    [CompilerGeneratedAttribute]
public void set_Indexes(IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldIndexing> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, FieldIndexing> get_IndexesStrings();
    [CompilerGeneratedAttribute]
public void set_IndexesStrings(IDictionary`2<string, FieldIndexing> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, string> get_Analyzers();
    [CompilerGeneratedAttribute]
public void set_Analyzers(IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_AnalyzersStrings();
    [CompilerGeneratedAttribute]
public void set_AnalyzersStrings(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public ISet`1<Expression`1<Func`2<TReduceResult, object>>> get_SuggestionsOptions();
    [CompilerGeneratedAttribute]
public void set_SuggestionsOptions(ISet`1<Expression`1<Func`2<TReduceResult, object>>> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldTermVector> get_TermVectors();
    [CompilerGeneratedAttribute]
public void set_TermVectors(IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldTermVector> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, FieldTermVector> get_TermVectorsStrings();
    [CompilerGeneratedAttribute]
public void set_TermVectorsStrings(IDictionary`2<string, FieldTermVector> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, SpatialOptions> get_SpatialIndexes();
    [CompilerGeneratedAttribute]
public void set_SpatialIndexes(IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, SpatialOptions> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, SpatialOptions> get_SpatialIndexesStrings();
    [CompilerGeneratedAttribute]
public void set_SpatialIndexesStrings(IDictionary`2<string, SpatialOptions> value);
    [CompilerGeneratedAttribute]
public Nullable`1<IndexLockMode> get_LockMode();
    [CompilerGeneratedAttribute]
public void set_LockMode(Nullable`1<IndexLockMode> value);
    [CompilerGeneratedAttribute]
public Nullable`1<IndexPriority> get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(Nullable`1<IndexPriority> value);
    [CompilerGeneratedAttribute]
public Nullable`1<IndexState> get_State();
    [CompilerGeneratedAttribute]
public void set_State(Nullable`1<IndexState> value);
    [CompilerGeneratedAttribute]
public List`1<String[]> get_CompoundFieldsStrings();
    [CompilerGeneratedAttribute]
public void set_CompoundFieldsStrings(List`1<String[]> value);
    [CompilerGeneratedAttribute]
public List`1<Expression`1[]> get_CompoundFields();
    [CompilerGeneratedAttribute]
public void set_CompoundFields(List`1<Expression`1[]> value);
    [CompilerGeneratedAttribute]
public Nullable`1<IndexDeploymentMode> get_DeploymentMode();
    [CompilerGeneratedAttribute]
public void set_DeploymentMode(Nullable`1<IndexDeploymentMode> value);
    [CompilerGeneratedAttribute]
public string get_OutputReduceToCollection();
    [CompilerGeneratedAttribute]
public void set_OutputReduceToCollection(string value);
    [CompilerGeneratedAttribute]
public Expression`1<Func`2<TReduceResult, string>> get_PatternForOutputReduceToCollectionReferences();
    [CompilerGeneratedAttribute]
public void set_PatternForOutputReduceToCollectionReferences(Expression`1<Func`2<TReduceResult, string>> value);
    [CompilerGeneratedAttribute]
public string get_PatternReferencesCollectionName();
    [CompilerGeneratedAttribute]
public void set_PatternReferencesCollectionName(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_AdditionalSources();
    [CompilerGeneratedAttribute]
public void set_AdditionalSources(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public HashSet`1<AdditionalAssembly> get_AdditionalAssemblies();
    [CompilerGeneratedAttribute]
public void set_AdditionalAssemblies(HashSet`1<AdditionalAssembly> value);
    [CompilerGeneratedAttribute]
public IndexConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(IndexConfiguration value);
    public virtual TIndexDefinition ToIndexDefinition(DocumentConventions conventions, bool validateMap);
    protected abstract virtual void ToIndexDefinition(TIndexDefinition indexDefinition, DocumentConventions conventions);
    private string ConvertPatternForOutputReduceToCollectionReferencesToString(Expression`1<Func`2<TReduceResult, string>> reduceOutputReferencesPattern);
    private void ApplyValues(IndexDefinition indexDefinition, IDictionary`2<string, TValue> values, Action`2<IndexFieldOptions, TValue> action);
    private static IDictionary`2<string, TValue> ConvertToStringDictionary(DocumentConventions conventions, IEnumerable`1<KeyValuePair`2<Expression`1<Func`2<TReduceResult, object>>, TValue>> input);
    private static ISet`1<string> ConvertToStringSet(DocumentConventions conventions, IEnumerable`1<Expression`1<Func`2<TReduceResult, object>>> input);
    [CompilerGeneratedAttribute]
internal static void <ConvertPatternForOutputReduceToCollectionReferencesToString>g__RewritePatternParameters|100_0(Expression expression, int position, <>c__DisplayClass100_0& );
    [CompilerGeneratedAttribute]
internal static string <ConvertPatternForOutputReduceToCollectionReferencesToString>g__PatternFromBinary|100_1(Expression left, Expression right);
    [CompilerGeneratedAttribute]
internal static string <ConvertPatternForOutputReduceToCollectionReferencesToString>g__PatternFromExpression|100_2(Expression expr);
}
public abstract class Raven.Client.Documents.Indexes.AbstractJavaScriptIndexCreationTask : AbstractIndexCreationTask {
    private IndexDefinition _definition;
    public HashSet`1<string> Maps { get; public set; }
    public Dictionary`2<string, IndexFieldOptions> Fields { get; public set; }
    protected string Reduce { get; protected set; }
    public bool IsMapReduce { get; }
    protected string OutputReduceToCollection { get; protected set; }
    protected string PatternReferencesCollectionName { get; protected set; }
    protected string PatternForOutputReduceToCollectionReferences { get; protected set; }
    public HashSet`1<string> get_Maps();
    public void set_Maps(HashSet`1<string> value);
    public Dictionary`2<string, IndexFieldOptions> get_Fields();
    public void set_Fields(Dictionary`2<string, IndexFieldOptions> value);
    protected string get_Reduce();
    protected void set_Reduce(string value);
    public virtual bool get_IsMapReduce();
    protected string get_OutputReduceToCollection();
    protected void set_OutputReduceToCollection(string value);
    protected string get_PatternReferencesCollectionName();
    protected void set_PatternReferencesCollectionName(string value);
    protected string get_PatternForOutputReduceToCollectionReferences();
    protected void set_PatternForOutputReduceToCollectionReferences(string value);
    public virtual IndexDefinition CreateIndexDefinition();
}
public abstract class Raven.Client.Documents.Indexes.AbstractMultiMapIndexCreationTask : AbstractMultiMapIndexCreationTask`1<object> {
}
public abstract class Raven.Client.Documents.Indexes.AbstractMultiMapIndexCreationTask`1 : AbstractGenericIndexCreationTask`1<TReduceResult> {
    private List`1<Func`1<string>> _maps;
    protected void AddMap(Expression`1<Func`2<IEnumerable`1<TSource>, IEnumerable>> map);
    protected void AddMapForAll(Expression`1<Func`2<IEnumerable`1<TBase>, IEnumerable>> map);
    public virtual IndexDefinition CreateIndexDefinition();
}
public class Raven.Client.Documents.Indexes.AdditionalAssembly : object {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageSourceUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <Usings>k__BackingField;
    public string AssemblyName { get; private set; }
    public string AssemblyPath { get; private set; }
    public string PackageName { get; private set; }
    public string PackageVersion { get; private set; }
    public string PackageSourceUrl { get; private set; }
    public HashSet`1<string> Usings { get; private set; }
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
private void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public string get_AssemblyPath();
    [CompilerGeneratedAttribute]
private void set_AssemblyPath(string value);
    [CompilerGeneratedAttribute]
public string get_PackageName();
    [CompilerGeneratedAttribute]
private void set_PackageName(string value);
    [CompilerGeneratedAttribute]
public string get_PackageVersion();
    [CompilerGeneratedAttribute]
private void set_PackageVersion(string value);
    [CompilerGeneratedAttribute]
public string get_PackageSourceUrl();
    [CompilerGeneratedAttribute]
private void set_PackageSourceUrl(string value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_Usings();
    [CompilerGeneratedAttribute]
private void set_Usings(HashSet`1<string> value);
    private bool Equals(AdditionalAssembly other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal AdditionalAssembly Clone();
    public static AdditionalAssembly OnlyUsings(HashSet`1<string> usings);
    public static AdditionalAssembly FromRuntime(string assemblyName, HashSet`1<string> usings);
    public static AdditionalAssembly FromPath(string assemblyPath, HashSet`1<string> usings);
    public static AdditionalAssembly FromNuGet(string packageName, string packageVersion, string packageSourceUrl, HashSet`1<string> usings);
    public sealed virtual DynamicJsonValue ToJson();
    internal void WriteTo(AbstractBlittableJsonTextWriter writer);
}
public enum Raven.Client.Documents.Indexes.AggregationOperation : Enum {
    public int value__;
    public static AggregationOperation None;
    public static AggregationOperation Count;
    public static AggregationOperation Sum;
}
public class Raven.Client.Documents.Indexes.Analysis.AnalyzerDefinition : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    public string Name { get; public set; }
    public string Code { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(string value);
    public DynamicJsonValue ToJson();
    internal void Validate();
}
[FlagsAttribute]
public enum Raven.Client.Documents.Indexes.AutoFieldIndexing : Enum {
    public int value__;
    public static AutoFieldIndexing No;
    public static AutoFieldIndexing Search;
    public static AutoFieldIndexing Exact;
    public static AutoFieldIndexing Highlighting;
    public static AutoFieldIndexing Default;
}
public class Raven.Client.Documents.Indexes.AutoIndexDefinition : IndexDefinitionBase {
    [CompilerGeneratedAttribute]
private IndexType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Collection>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, AutoIndexFieldOptions> <MapFields>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, AutoIndexFieldOptions> <GroupByFields>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <GroupByFieldNames>k__BackingField;
    public IndexType Type { get; public set; }
    public string Collection { get; public set; }
    public Dictionary`2<string, AutoIndexFieldOptions> MapFields { get; public set; }
    public Dictionary`2<string, AutoIndexFieldOptions> GroupByFields { get; public set; }
    public List`1<string> GroupByFieldNames { get; public set; }
    [CompilerGeneratedAttribute]
public IndexType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IndexType value);
    [CompilerGeneratedAttribute]
public string get_Collection();
    [CompilerGeneratedAttribute]
public void set_Collection(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, AutoIndexFieldOptions> get_MapFields();
    [CompilerGeneratedAttribute]
public void set_MapFields(Dictionary`2<string, AutoIndexFieldOptions> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, AutoIndexFieldOptions> get_GroupByFields();
    [CompilerGeneratedAttribute]
public void set_GroupByFields(Dictionary`2<string, AutoIndexFieldOptions> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_GroupByFieldNames();
    [CompilerGeneratedAttribute]
public void set_GroupByFieldNames(List`1<string> value);
    public IndexDefinitionCompareDifferences Compare(AutoIndexDefinition other);
}
public class Raven.Client.Documents.Indexes.BoostedValue : object {
    [CompilerGeneratedAttribute]
private float <Boost>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public float Boost { get; public set; }
    public object Value { get; public set; }
    [CompilerGeneratedAttribute]
public float get_Boost();
    [CompilerGeneratedAttribute]
public void set_Boost(float value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
}
public class Raven.Client.Documents.Indexes.CleanupRunDetails : object {
    [CompilerGeneratedAttribute]
private int <DeleteSuccesses>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BatchCompleteReason>k__BackingField;
    public int DeleteSuccesses { get; public set; }
    public string BatchCompleteReason { get; public set; }
    [CompilerGeneratedAttribute]
public int get_DeleteSuccesses();
    [CompilerGeneratedAttribute]
public void set_DeleteSuccesses(int value);
    [CompilerGeneratedAttribute]
public string get_BatchCompleteReason();
    [CompilerGeneratedAttribute]
public void set_BatchCompleteReason(string value);
}
public abstract class Raven.Client.Documents.Indexes.Counters.AbstractCountersIndexCreationTask : AbstractIndexCreationTaskBase`1<CountersIndexDefinition> {
}
public abstract class Raven.Client.Documents.Indexes.Counters.AbstractCountersIndexCreationTask`1 : AbstractCountersIndexCreationTask`2<TDocument, TDocument> {
}
public abstract class Raven.Client.Documents.Indexes.Counters.AbstractCountersIndexCreationTask`2 : AbstractGenericCountersIndexCreationTask`1<TReduceResult> {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2<string, Expression`1<Func`2<IEnumerable`1<CounterEntry>, IEnumerable>>> _map;
    protected void AddMapForAll(Expression`1<Func`2<IEnumerable`1<CounterEntry>, IEnumerable>> map);
    protected void AddMap(string counter, Expression`1<Func`2<IEnumerable`1<CounterEntry>, IEnumerable>> map);
    private void AddMapInternal(string counter, Expression`1<Func`2<IEnumerable`1<CounterEntry>, IEnumerable>> map);
    public virtual CountersIndexDefinition CreateIndexDefinition();
}
public abstract class Raven.Client.Documents.Indexes.Counters.AbstractGenericCountersIndexCreationTask`1 : AbstractCountersIndexCreationTask {
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<IEnumerable`1<TReduceResult>, IEnumerable>> <Reduce>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldStorage> <Stores>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, FieldStorage> <StoresStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<Expression`1<Func`2<TReduceResult, object>>> <IndexSuggestions>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, string> <Analyzers>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <AnalyzersStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldTermVector> <TermVectors>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, FieldTermVector> <TermVectorsStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, SpatialOptions> <SpatialIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, SpatialOptions> <SpatialIndexesStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldIndexing> <Indexes>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, FieldIndexing> <IndexesStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputReduceToCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<TReduceResult, string>> <PatternForOutputReduceToCollectionReferences>k__BackingField;
    public bool IsMapReduce { get; }
    protected Expression`1<Func`2<IEnumerable`1<TReduceResult>, IEnumerable>> Reduce { get; protected set; }
    protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldStorage> Stores { get; protected set; }
    protected IDictionary`2<string, FieldStorage> StoresStrings { get; protected set; }
    protected ISet`1<Expression`1<Func`2<TReduceResult, object>>> IndexSuggestions { get; protected set; }
    protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, string> Analyzers { get; protected set; }
    protected IDictionary`2<string, string> AnalyzersStrings { get; protected set; }
    protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldTermVector> TermVectors { get; protected set; }
    protected IDictionary`2<string, FieldTermVector> TermVectorsStrings { get; protected set; }
    protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, SpatialOptions> SpatialIndexes { get; protected set; }
    protected IDictionary`2<string, SpatialOptions> SpatialIndexesStrings { get; protected set; }
    protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldIndexing> Indexes { get; protected set; }
    protected IDictionary`2<string, FieldIndexing> IndexesStrings { get; protected set; }
    protected string OutputReduceToCollection { get; protected set; }
    protected Expression`1<Func`2<TReduceResult, string>> PatternForOutputReduceToCollectionReferences { get; protected set; }
    public virtual bool get_IsMapReduce();
    [CompilerGeneratedAttribute]
protected Expression`1<Func`2<IEnumerable`1<TReduceResult>, IEnumerable>> get_Reduce();
    [CompilerGeneratedAttribute]
protected void set_Reduce(Expression`1<Func`2<IEnumerable`1<TReduceResult>, IEnumerable>> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldStorage> get_Stores();
    [CompilerGeneratedAttribute]
protected void set_Stores(IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldStorage> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<string, FieldStorage> get_StoresStrings();
    [CompilerGeneratedAttribute]
protected void set_StoresStrings(IDictionary`2<string, FieldStorage> value);
    [CompilerGeneratedAttribute]
protected ISet`1<Expression`1<Func`2<TReduceResult, object>>> get_IndexSuggestions();
    [CompilerGeneratedAttribute]
protected void set_IndexSuggestions(ISet`1<Expression`1<Func`2<TReduceResult, object>>> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, string> get_Analyzers();
    [CompilerGeneratedAttribute]
protected void set_Analyzers(IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, string> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<string, string> get_AnalyzersStrings();
    [CompilerGeneratedAttribute]
protected void set_AnalyzersStrings(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldTermVector> get_TermVectors();
    [CompilerGeneratedAttribute]
protected void set_TermVectors(IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldTermVector> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<string, FieldTermVector> get_TermVectorsStrings();
    [CompilerGeneratedAttribute]
protected void set_TermVectorsStrings(IDictionary`2<string, FieldTermVector> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, SpatialOptions> get_SpatialIndexes();
    [CompilerGeneratedAttribute]
protected void set_SpatialIndexes(IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, SpatialOptions> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<string, SpatialOptions> get_SpatialIndexesStrings();
    [CompilerGeneratedAttribute]
protected void set_SpatialIndexesStrings(IDictionary`2<string, SpatialOptions> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldIndexing> get_Indexes();
    [CompilerGeneratedAttribute]
protected void set_Indexes(IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldIndexing> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<string, FieldIndexing> get_IndexesStrings();
    [CompilerGeneratedAttribute]
protected void set_IndexesStrings(IDictionary`2<string, FieldIndexing> value);
    [CompilerGeneratedAttribute]
protected string get_OutputReduceToCollection();
    [CompilerGeneratedAttribute]
protected void set_OutputReduceToCollection(string value);
    [CompilerGeneratedAttribute]
protected Expression`1<Func`2<TReduceResult, string>> get_PatternForOutputReduceToCollectionReferences();
    [CompilerGeneratedAttribute]
protected void set_PatternForOutputReduceToCollectionReferences(Expression`1<Func`2<TReduceResult, string>> value);
    protected void Index(Expression`1<Func`2<TReduceResult, object>> field, FieldIndexing indexing);
    protected void Index(string field, FieldIndexing indexing);
    protected void Spatial(Expression`1<Func`2<TReduceResult, object>> field, Func`2<SpatialOptionsFactory, SpatialOptions> indexing);
    protected void Spatial(string field, Func`2<SpatialOptionsFactory, SpatialOptions> indexing);
    protected void Store(Expression`1<Func`2<TReduceResult, object>> field, FieldStorage storage);
    protected void StoreAllFields(FieldStorage storage);
    protected void Store(string field, FieldStorage storage);
    protected void Analyze(Expression`1<Func`2<TReduceResult, object>> field, string analyzer);
    protected void Analyze(string field, string analyzer);
    protected void TermVector(Expression`1<Func`2<TReduceResult, object>> field, FieldTermVector termVector);
    protected void TermVector(string field, FieldTermVector termVector);
    protected void Suggestion(Expression`1<Func`2<TReduceResult, object>> field);
}
public abstract class Raven.Client.Documents.Indexes.Counters.AbstractJavaScriptCountersIndexCreationTask : AbstractCountersIndexCreationTask {
    private CountersIndexDefinition _definition;
    public HashSet`1<string> Maps { get; public set; }
    public Dictionary`2<string, IndexFieldOptions> Fields { get; public set; }
    protected string Reduce { get; protected set; }
    public bool IsMapReduce { get; }
    protected string OutputReduceToCollection { get; protected set; }
    protected string PatternReferencesCollectionName { get; protected set; }
    protected string PatternForOutputReduceToCollectionReferences { get; protected set; }
    public HashSet`1<string> get_Maps();
    public void set_Maps(HashSet`1<string> value);
    public Dictionary`2<string, IndexFieldOptions> get_Fields();
    public void set_Fields(Dictionary`2<string, IndexFieldOptions> value);
    protected string get_Reduce();
    protected void set_Reduce(string value);
    public virtual bool get_IsMapReduce();
    protected string get_OutputReduceToCollection();
    protected void set_OutputReduceToCollection(string value);
    protected string get_PatternReferencesCollectionName();
    protected void set_PatternReferencesCollectionName(string value);
    protected string get_PatternForOutputReduceToCollectionReferences();
    protected void set_PatternForOutputReduceToCollectionReferences(string value);
    public virtual CountersIndexDefinition CreateIndexDefinition();
}
public abstract class Raven.Client.Documents.Indexes.Counters.AbstractMultiMapCountersIndexCreationTask : AbstractMultiMapCountersIndexCreationTask`1<object> {
}
public abstract class Raven.Client.Documents.Indexes.Counters.AbstractMultiMapCountersIndexCreationTask`1 : AbstractGenericCountersIndexCreationTask`1<TReduceResult> {
    private List`1<Func`1<string>> _maps;
    protected void AddMap(string counter, Expression`1<Func`2<IEnumerable`1<CounterEntry>, IEnumerable>> map);
    protected void AddMapForAll(string counter, Expression`1<Func`2<IEnumerable`1<CounterEntry>, IEnumerable>> map);
    public virtual CountersIndexDefinition CreateIndexDefinition();
}
public class Raven.Client.Documents.Indexes.Counters.CounterEntry : object {
    [CompilerGeneratedAttribute]
private string <DocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Value>k__BackingField;
    public string DocumentId { get; public set; }
    public string Name { get; public set; }
    public long Value { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DocumentId();
    [CompilerGeneratedAttribute]
public void set_DocumentId(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public long get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(long value);
}
public class Raven.Client.Documents.Indexes.Counters.CountersIndexDefinition : IndexDefinition {
    public IndexSourceType SourceType { get; }
    public virtual IndexSourceType get_SourceType();
}
public class Raven.Client.Documents.Indexes.Counters.CountersIndexDefinitionBuilder`1 : CountersIndexDefinitionBuilder`2<TDocument, TDocument> {
    public CountersIndexDefinitionBuilder`1(string indexName);
}
public class Raven.Client.Documents.Indexes.Counters.CountersIndexDefinitionBuilder`2 : AbstractIndexDefinitionBuilder`3<TDocument, TReduceResult, CountersIndexDefinition> {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2<string, Expression`1<Func`2<IEnumerable`1<CounterEntry>, IEnumerable>>> _map;
    public CountersIndexDefinitionBuilder`2(string indexName);
    public void AddMapForAll(Expression`1<Func`2<IEnumerable`1<CounterEntry>, IEnumerable>> map);
    public void AddMap(string counter, Expression`1<Func`2<IEnumerable`1<CounterEntry>, IEnumerable>> map);
    private void AddMapInternal(string counter, Expression`1<Func`2<IEnumerable`1<CounterEntry>, IEnumerable>> map);
    public virtual CountersIndexDefinition ToIndexDefinition(DocumentConventions conventions, bool validateMap);
    protected virtual void ToIndexDefinition(CountersIndexDefinition indexDefinition, DocumentConventions conventions);
    private string GetQuerySource(DocumentConventions conventions);
}
public class Raven.Client.Documents.Indexes.CreateFieldOptions : object {
    internal static CreateFieldOptions Default;
    [CompilerGeneratedAttribute]
private Nullable`1<FieldStorage> <Storage>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<FieldIndexing> <Indexing>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<FieldTermVector> <TermVector>k__BackingField;
    public Nullable`1<FieldStorage> Storage { get; public set; }
    public Nullable`1<FieldIndexing> Indexing { get; public set; }
    public Nullable`1<FieldTermVector> TermVector { get; public set; }
    private static CreateFieldOptions();
    [CompilerGeneratedAttribute]
public Nullable`1<FieldStorage> get_Storage();
    [CompilerGeneratedAttribute]
public void set_Storage(Nullable`1<FieldStorage> value);
    [CompilerGeneratedAttribute]
public Nullable`1<FieldIndexing> get_Indexing();
    [CompilerGeneratedAttribute]
public void set_Indexing(Nullable`1<FieldIndexing> value);
    [CompilerGeneratedAttribute]
public Nullable`1<FieldTermVector> get_TermVector();
    [CompilerGeneratedAttribute]
public void set_TermVector(Nullable`1<FieldTermVector> value);
}
internal enum Raven.Client.Documents.Indexes.ExpressionOperatorPrecedence : Enum {
    public int value__;
    public static ExpressionOperatorPrecedence Primary;
    public static ExpressionOperatorPrecedence Unary;
    public static ExpressionOperatorPrecedence Multiplicative;
    public static ExpressionOperatorPrecedence Additive;
    public static ExpressionOperatorPrecedence Shift;
    public static ExpressionOperatorPrecedence RelationalAndTypeTesting;
    public static ExpressionOperatorPrecedence Equality;
    public static ExpressionOperatorPrecedence LogicalAND;
    public static ExpressionOperatorPrecedence LogicalXOR;
    public static ExpressionOperatorPrecedence LogicalOR;
    public static ExpressionOperatorPrecedence ConditionalAND;
    public static ExpressionOperatorPrecedence ConditionalOR;
    public static ExpressionOperatorPrecedence NullCoalescing;
    public static ExpressionOperatorPrecedence Conditional;
    public static ExpressionOperatorPrecedence Assignment;
    public static ExpressionOperatorPrecedence ParenthesisNotNeeded;
}
[ExtensionAttribute]
internal static class Raven.Client.Documents.Indexes.ExpressionOperatorPrecedenceExtension : object {
    [ExtensionAttribute]
public static bool NeedsParenthesisFor(ExpressionOperatorPrecedence outer, ExpressionOperatorPrecedence inner);
}
internal class Raven.Client.Documents.Indexes.ExpressionStringBuilder : ExpressionVisitor {
    private StringBuilder _out;
    private DocumentConventions _conventions;
    private Type _queryRoot;
    private string _queryRootName;
    private bool _translateIdentityProperty;
    private ExpressionOperatorPrecedence _currentPrecedence;
    private Dictionary`2<object, int> _ids;
    private Dictionary`2<string, object> _duplicatedParams;
    private bool _castLambdas;
    private bool _isDictionary;
    private bool _isReduce;
    public static HashSet`1<string> KeywordsInCSharp;
    private bool _insideWellKnownType;
    private bool _avoidDuplicatedParameters;
    private bool _isSelectMany;
    private bool _isProjectionPart;
    private HashSet`1<Type> _loadDocumentTypes;
    private ExpressionStringBuilder(DocumentConventions conventions, bool translateIdentityProperty, Type queryRoot, string queryRootName, bool isReduce);
    private static ExpressionStringBuilder();
    private int GetLabelId(LabelTarget label);
    private void AddParam(ParameterExpression p);
    private void DumpLabel(LabelTarget target);
    public static string ExpressionToString(DocumentConventions conventions, bool translateIdentityProperty, Type queryRoot, string queryRootName, Expression node, bool isReduce);
    private int GetParamId(ParameterExpression p);
    private void Out(char c);
    private void Out(string s);
    private void OutMember(Expression instance, MemberInfo member, Type exprType);
    private void OutMemberCall(string name);
    private static bool ValidCSharpName(string name);
    private static bool ShouldParenthesisMemberExpression(Expression instance);
    private bool TranslateToDocumentId(Expression instance, MemberInfo member, Type exprType);
    private string GetPropertyName(MemberInfo memberInfo);
    private static Type GetMemberType(MemberInfo member);
    public virtual string ToString();
    private void SometimesParenthesis(ExpressionOperatorPrecedence outer, ExpressionOperatorPrecedence inner, Action visitor);
    private void Visit(Expression node, ExpressionOperatorPrecedence outerPrecedence);
    protected virtual Expression VisitBinary(BinaryExpression node);
    private Expression VisitBinary(BinaryExpression node, ExpressionOperatorPrecedence outerPrecedence);
    private void FixupEnumBinaryExpression(Expression& left, Expression& right);
    private Expression SkipConvertExpressions(Expression expression);
    protected virtual Expression VisitBlock(BlockExpression node);
    protected virtual CatchBlock VisitCatchBlock(CatchBlock node);
    protected virtual Expression VisitConditional(ConditionalExpression node);
    private Expression VisitConditional(ConditionalExpression node, ExpressionOperatorPrecedence outerPrecedence);
    protected virtual Expression VisitConstant(ConstantExpression node);
    private void OutLiteral(string value);
    private void OutLiteral(char c);
    private void ConvertTypeToCSharpKeywordIncludeNullable(Type type);
    private string ConvertTypeToCSharpKeyword(Type type, Boolean& isValueTypeOnTheServerSide);
    private bool TypeExistsOnServer(Type type);
    private bool TypeExistsOnServer(Type type, bool isGenericArgument);
    protected virtual Expression VisitDebugInfo(DebugInfoExpression node);
    protected virtual Expression VisitDefault(DefaultExpression node);
    protected virtual ElementInit VisitElementInit(ElementInit initializer);
    private void VisitExpressions(char open, IEnumerable`1<T> expressions, char close);
    protected virtual Expression VisitExtension(Expression node);
    protected virtual Expression VisitGoto(GotoExpression node);
    protected virtual Expression VisitIndex(IndexExpression node);
    protected virtual Expression VisitInvocation(InvocationExpression node);
    protected virtual Expression VisitLabel(LabelExpression node);
    protected virtual Expression VisitLambda(Expression`1<T> node);
    protected virtual Expression VisitListInit(ListInitExpression node);
    protected virtual Expression VisitLoop(LoopExpression node);
    protected virtual Expression VisitMember(MemberExpression node);
    protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment assignment);
    protected virtual Expression VisitMemberInit(MemberInitExpression node);
    protected virtual MemberListBinding VisitMemberListBinding(MemberListBinding binding);
    protected virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding binding);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    private void OutputGenericMethodArgumentsIfNeeded(MethodInfo method);
    private static bool IsIndexerCall(MethodCallExpression node);
    private bool ShouldConvertToDynamicEnumerable(MethodCallExpression node);
    private static bool IsExtensionMethod(MethodCallExpression node);
    protected virtual Expression VisitNew(NewExpression node);
    private void VisitType(Type type);
    protected virtual Expression VisitNewArray(NewArrayExpression node);
    private void OutputAppropriateArrayType(NewArrayExpression node);
    private static bool CheckIfAnonymousType(Type type);
    protected virtual Expression VisitParameter(ParameterExpression node);
    protected virtual Expression VisitRuntimeVariables(RuntimeVariablesExpression node);
    protected virtual Expression VisitSwitch(SwitchExpression node);
    protected virtual SwitchCase VisitSwitchCase(SwitchCase node);
    protected virtual Expression VisitTry(TryExpression node);
    protected virtual Expression VisitTypeBinary(TypeBinaryExpression node);
    protected virtual Expression VisitUnary(UnaryExpression node);
    private Expression VisitUnary(UnaryExpression node, ExpressionOperatorPrecedence outerPrecedence);
    private bool ShouldConvert(Type nonNullableType);
    [CompilerGeneratedAttribute]
internal static bool <VisitNew>g__IsEnum|66_0(Type type);
}
public enum Raven.Client.Documents.Indexes.FieldIndexing : Enum {
    public int value__;
    public static FieldIndexing No;
    public static FieldIndexing Search;
    public static FieldIndexing Exact;
    public static FieldIndexing Default;
}
public enum Raven.Client.Documents.Indexes.FieldStorage : Enum {
    public int value__;
    public static FieldStorage Yes;
    public static FieldStorage No;
}
public enum Raven.Client.Documents.Indexes.FieldTermVector : Enum {
    public int value__;
    public static FieldTermVector No;
    public static FieldTermVector Yes;
    public static FieldTermVector WithPositions;
    public static FieldTermVector WithOffsets;
    public static FieldTermVector WithPositionsAndOffsets;
}
internal static class Raven.Client.Documents.Indexes.FieldUtil : object {
    public static RangeType GetRangeTypeFromFieldName(string fieldName);
    public static string ApplyRangeSuffixIfNecessary(string fieldName, RangeType rangeType);
}
public enum Raven.Client.Documents.Indexes.GroupByArrayBehavior : Enum {
    public int value__;
    public static GroupByArrayBehavior NotApplicable;
    public static GroupByArrayBehavior ByContent;
    public static GroupByArrayBehavior ByIndividualValues;
}
public interface Raven.Client.Documents.Indexes.IAbstractIndexCreationTask {
    public string IndexName { get; }
    public Nullable`1<IndexPriority> Priority { get; }
    public Nullable`1<IndexState> State { get; }
    public Nullable`1<IndexDeploymentMode> DeploymentMode { get; }
    public DocumentConventions Conventions { get; public set; }
    public Nullable`1<SearchEngineType> SearchEngineType { get; }
    public abstract virtual string get_IndexName();
    public abstract virtual Nullable`1<IndexPriority> get_Priority();
    public abstract virtual Nullable`1<IndexState> get_State();
    public abstract virtual Nullable`1<IndexDeploymentMode> get_DeploymentMode();
    public abstract virtual DocumentConventions get_Conventions();
    public abstract virtual void set_Conventions(DocumentConventions value);
    public abstract virtual Nullable`1<SearchEngineType> get_SearchEngineType();
    public abstract virtual IndexDefinition CreateIndexDefinition();
    public abstract virtual void Execute(IDocumentStore store, DocumentConventions conventions, string database);
    public abstract virtual Task ExecuteAsync(IDocumentStore store, DocumentConventions conventions, string database, CancellationToken token);
}
public interface Raven.Client.Documents.Indexes.IAttachmentObject {
    public string Name { get; }
    public string Hash { get; }
    public string ContentType { get; }
    public long Size { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Hash();
    public abstract virtual string get_ContentType();
    public abstract virtual long get_Size();
    public abstract virtual string GetContentAsString();
    public abstract virtual string GetContentAsString(Encoding encoding);
    public abstract virtual Stream GetContentAsStream();
}
[DefaultMemberAttribute("Item")]
public interface Raven.Client.Documents.Indexes.IJsonObject {
    public object Item { get; }
    public abstract virtual object get_Item(string propertyName);
    public abstract virtual T Value(string propertyName);
    public abstract virtual IEnumerable`1<T> Values();
}
public interface Raven.Client.Documents.Indexes.ILoadCommonApiForIndexes {
    public abstract virtual T LoadDocument(string id);
    public abstract virtual T LoadDocument(string id, string collectionName);
    public abstract virtual T[] LoadDocument(IEnumerable`1<string> ids);
    public abstract virtual T[] LoadDocument(IEnumerable`1<string> ids, string collectionName);
}
public interface Raven.Client.Documents.Indexes.ILoadCompareExchangeApiForIndexes {
    public abstract virtual T LoadCompareExchangeValue(string key);
    public abstract virtual T[] LoadCompareExchangeValue(IEnumerable`1<string> keys);
}
[DefaultMemberAttribute("Item")]
public class Raven.Client.Documents.Indexes.IndexConfiguration : Dictionary`2<string, string> {
    public string Item { get; public set; }
    public void Add(string key, string value);
    public string get_Item(string key);
    public void set_Item(string key, string value);
    public string GetValue(string key);
    private bool Equals(IndexConfiguration other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void FillFromBlittableJson(BlittableJsonReaderObject json);
}
public static class Raven.Client.Documents.Indexes.IndexCreation : object {
    private static Logger Logger;
    private static IndexCreation();
    public static void CreateIndexes(Assembly assemblyToScan, IDocumentStore store, DocumentConventions conventions, string database);
    public static Task CreateIndexesAsync(Assembly assemblyToScan, IDocumentStore store, DocumentConventions conventions, string database, CancellationToken token);
    public static void CreateIndexes(IEnumerable`1<IAbstractIndexCreationTask> indexes, IDocumentStore store, DocumentConventions conventions, string database);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Indexes.IndexCreation/<CreateIndexesAsync>d__4")]
public static Task CreateIndexesAsync(IEnumerable`1<IAbstractIndexCreationTask> indexes, IDocumentStore store, DocumentConventions conventions, string database, CancellationToken token);
    internal static IndexDefinition[] CreateIndexesToAdd(IEnumerable`1<IAbstractIndexCreationTask> indexCreationTasks, DocumentConventions conventions);
    [IteratorStateMachineAttribute("Raven.Client.Documents.Indexes.IndexCreation/<GetAllInstancesOfType>d__6`1")]
private static IEnumerable`1<TType> GetAllInstancesOfType(Assembly assembly);
}
public class Raven.Client.Documents.Indexes.IndexDefinition : IndexDefinitionBase {
    private static Regex _newLineCharacters;
    [CompilerGeneratedAttribute]
private Nullable`1<IndexLockMode> <LockMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reduce>k__BackingField;
    private Nullable`1<IndexSourceType> _indexSourceType;
    [CompilerGeneratedAttribute]
private Nullable`1<ArchivedDataProcessingBehavior> <ArchivedDataProcessingBehavior>k__BackingField;
    [JsonIgnoreAttribute]
private Byte[] _cachedHashCodeAsBytes;
    [JsonIgnoreAttribute]
private HashSet`1<string> _maps;
    [JsonIgnoreAttribute]
private Dictionary`2<string, IndexFieldOptions> _fields;
    [JsonIgnoreAttribute]
private Dictionary`2<string, string> _additionalSources;
    [JsonIgnoreAttribute]
private HashSet`1<AdditionalAssembly> _additionalAssemblies;
    [JsonIgnoreAttribute]
private IndexConfiguration _configuration;
    [JsonIgnoreAttribute]
private List`1<String[]> _compoundFields;
    private Nullable`1<IndexType> _indexType;
    [CompilerGeneratedAttribute]
private string <OutputReduceToCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ReduceOutputIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PatternForOutputReduceToCollectionReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PatternReferencesCollectionName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<IndexDeploymentMode> <DeploymentMode>k__BackingField;
    internal static IndexDefinitionCompareDifferences ReIndexRequiredMask;
    public Nullable`1<IndexLockMode> LockMode { get; public set; }
    public Dictionary`2<string, string> AdditionalSources { get; public set; }
    public List`1<String[]> CompoundFields { get; public set; }
    public HashSet`1<AdditionalAssembly> AdditionalAssemblies { get; public set; }
    public HashSet`1<string> Maps { get; public set; }
    public string Reduce { get; public set; }
    public Dictionary`2<string, IndexFieldOptions> Fields { get; public set; }
    public IndexConfiguration Configuration { get; public set; }
    public IndexSourceType SourceType { get; internal set; }
    public Nullable`1<ArchivedDataProcessingBehavior> ArchivedDataProcessingBehavior { get; public set; }
    public IndexType Type { get; internal set; }
    public string OutputReduceToCollection { get; public set; }
    public Nullable`1<long> ReduceOutputIndex { get; public set; }
    public string PatternForOutputReduceToCollectionReferences { get; public set; }
    public string PatternReferencesCollectionName { get; public set; }
    public Nullable`1<IndexDeploymentMode> DeploymentMode { get; public set; }
    private static IndexDefinition();
    [CompilerGeneratedAttribute]
public Nullable`1<IndexLockMode> get_LockMode();
    [CompilerGeneratedAttribute]
public void set_LockMode(Nullable`1<IndexLockMode> value);
    public Dictionary`2<string, string> get_AdditionalSources();
    public void set_AdditionalSources(Dictionary`2<string, string> value);
    public List`1<String[]> get_CompoundFields();
    public void set_CompoundFields(List`1<String[]> value);
    public HashSet`1<AdditionalAssembly> get_AdditionalAssemblies();
    public void set_AdditionalAssemblies(HashSet`1<AdditionalAssembly> value);
    public HashSet`1<string> get_Maps();
    public void set_Maps(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public string get_Reduce();
    [CompilerGeneratedAttribute]
public void set_Reduce(string value);
    public Dictionary`2<string, IndexFieldOptions> get_Fields();
    public void set_Fields(Dictionary`2<string, IndexFieldOptions> value);
    public IndexConfiguration get_Configuration();
    public void set_Configuration(IndexConfiguration value);
    public virtual IndexSourceType get_SourceType();
    internal virtual void set_SourceType(IndexSourceType value);
    [CompilerGeneratedAttribute]
public virtual Nullable`1<ArchivedDataProcessingBehavior> get_ArchivedDataProcessingBehavior();
    [CompilerGeneratedAttribute]
public virtual void set_ArchivedDataProcessingBehavior(Nullable`1<ArchivedDataProcessingBehavior> value);
    public IndexDefinitionCompareDifferences Compare(IndexDefinition other);
    public bool Equals(IndexDefinition other);
    private static int DictionaryHashCode(IEnumerable`1<KeyValuePair`2<TKey, TValue>> x);
    public virtual bool Equals(object obj);
    public Byte[] GetIndexHash();
    public virtual int GetHashCode();
    public IndexType get_Type();
    internal void set_Type(IndexType value);
    public void RemoveDefaultValues();
    public IndexSourceType DetectStaticIndexSourceType();
    public IndexType DetectStaticIndexType();
    [CompilerGeneratedAttribute]
public string get_OutputReduceToCollection();
    [CompilerGeneratedAttribute]
public void set_OutputReduceToCollection(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ReduceOutputIndex();
    [CompilerGeneratedAttribute]
public void set_ReduceOutputIndex(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public string get_PatternForOutputReduceToCollectionReferences();
    [CompilerGeneratedAttribute]
public void set_PatternForOutputReduceToCollectionReferences(string value);
    [CompilerGeneratedAttribute]
public string get_PatternReferencesCollectionName();
    [CompilerGeneratedAttribute]
public void set_PatternReferencesCollectionName(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<IndexDeploymentMode> get_DeploymentMode();
    [CompilerGeneratedAttribute]
public void set_DeploymentMode(Nullable`1<IndexDeploymentMode> value);
    public virtual string ToString();
    internal void CopyTo(IndexDefinition definition);
    [CompilerGeneratedAttribute]
internal static string <Compare>g__Normalize|36_0(string toNormalize);
}
public abstract class Raven.Client.Documents.Indexes.IndexDefinitionBase : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<IndexPriority> <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<IndexState> <State>k__BackingField;
    [ForceJsonSerializationAttribute]
internal IndexDefinitionClusterState ClusterState;
    public string Name { get; public set; }
    public Nullable`1<IndexPriority> Priority { get; public set; }
    public Nullable`1<IndexState> State { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<IndexPriority> get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(Nullable`1<IndexPriority> value);
    [CompilerGeneratedAttribute]
public Nullable`1<IndexState> get_State();
    [CompilerGeneratedAttribute]
public void set_State(Nullable`1<IndexState> value);
}
public class Raven.Client.Documents.Indexes.IndexDefinitionBuilder`1 : IndexDefinitionBuilder`2<TDocument, TDocument> {
    public IndexDefinitionBuilder`1(string indexName);
}
public class Raven.Client.Documents.Indexes.IndexDefinitionBuilder`2 : AbstractIndexDefinitionBuilder`3<TDocument, TReduceResult, IndexDefinition> {
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<IEnumerable`1<TDocument>, IEnumerable>> <Map>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ArchivedDataProcessingBehavior> <ArchivedDataProcessingBehavior>k__BackingField;
    public Expression`1<Func`2<IEnumerable`1<TDocument>, IEnumerable>> Map { get; public set; }
    public Nullable`1<ArchivedDataProcessingBehavior> ArchivedDataProcessingBehavior { get; public set; }
    public IndexDefinitionBuilder`2(string indexName);
    [CompilerGeneratedAttribute]
public Expression`1<Func`2<IEnumerable`1<TDocument>, IEnumerable>> get_Map();
    [CompilerGeneratedAttribute]
public void set_Map(Expression`1<Func`2<IEnumerable`1<TDocument>, IEnumerable>> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ArchivedDataProcessingBehavior> get_ArchivedDataProcessingBehavior();
    [CompilerGeneratedAttribute]
public void set_ArchivedDataProcessingBehavior(Nullable`1<ArchivedDataProcessingBehavior> value);
    public virtual IndexDefinition ToIndexDefinition(DocumentConventions conventions, bool validateMap);
    protected virtual void ToIndexDefinition(IndexDefinition indexDefinition, DocumentConventions conventions);
    private string GetQuerySource(DocumentConventions conventions);
    private bool ContainsWhereEntityIs();
}
internal class Raven.Client.Documents.Indexes.IndexDefinitionClusterState : object {
    public long LastIndex;
    public long LastStateIndex;
    public long LastRollingDeploymentIndex;
    public IndexDefinitionClusterState(IndexDefinitionClusterState clusterState);
}
[FlagsAttribute]
public enum Raven.Client.Documents.Indexes.IndexDefinitionCompareDifferences : Enum {
    public int value__;
    public static IndexDefinitionCompareDifferences None;
    public static IndexDefinitionCompareDifferences Maps;
    public static IndexDefinitionCompareDifferences Reduce;
    public static IndexDefinitionCompareDifferences Fields;
    public static IndexDefinitionCompareDifferences Configuration;
    public static IndexDefinitionCompareDifferences LockMode;
    public static IndexDefinitionCompareDifferences Priority;
    public static IndexDefinitionCompareDifferences State;
    public static IndexDefinitionCompareDifferences AdditionalSources;
    public static IndexDefinitionCompareDifferences AdditionalAssemblies;
    public static IndexDefinitionCompareDifferences DeploymentMode;
    public static IndexDefinitionCompareDifferences CompoundFields;
    public static IndexDefinitionCompareDifferences ArchivedDataProcessingBehavior;
    public static IndexDefinitionCompareDifferences All;
}
internal static class Raven.Client.Documents.Indexes.IndexDefinitionHelper : object {
    private static Regex CommentsStripper;
    private static IndexDefinitionHelper();
    public static string PruneToFailureLinqQueryAsStringToWorkableCode(LambdaExpression expr, DocumentConventions conventions, string querySource, bool translateIdentityProperty);
    private static string FormatLinqQuery(LambdaExpression expr, string querySource, string linqQuery);
    private static MethodCallExpression GetFirstMethodCallExpression(Expression expression);
    private static string TryCaptureQueryRoot(Expression expression);
    private static string ReplaceAnonymousTypeBraces(string linqQuery);
    public static void ValidateReduce(LambdaExpression reduceExpression);
    private static bool ContainsMethodInGrouping(Expression expression, string grouping, string method);
    internal static string GetQuerySource(DocumentConventions conventions, Type type, IndexSourceType sourceType);
    internal static IndexSourceType DetectStaticIndexSourceType(string map);
    internal static IndexType DetectStaticIndexType(string map, string reduce);
    private static string StripComments(string input);
    private static string UnifyWhiteSpace(string input);
}
public enum Raven.Client.Documents.Indexes.IndexDeploymentMode : Enum {
    public int value__;
    public static IndexDeploymentMode Parallel;
    public static IndexDeploymentMode Rolling;
}
public class Raven.Client.Documents.Indexes.IndexErrors : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexingError[] <Errors>k__BackingField;
    public string Name { get; public set; }
    public IndexingError[] Errors { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public IndexingError[] get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(IndexingError[] value);
}
internal class Raven.Client.Documents.Indexes.IndexesProgress : object {
    [CompilerGeneratedAttribute]
private IndexProgress[] <Results>k__BackingField;
    public IndexProgress[] Results { get; public set; }
    [CompilerGeneratedAttribute]
public IndexProgress[] get_Results();
    [CompilerGeneratedAttribute]
public void set_Results(IndexProgress[] value);
}
public class Raven.Client.Documents.Indexes.IndexFailureInformation : object {
    private static float FailureThreshold;
    internal static int SufficientNumberOfAttemptsToCheckFailureRate;
    internal static int MinimalNumberOfAttemptsToCheckFailureRate;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MapAttempts>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MapSuccesses>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MapErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MapReferenceAttempts>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MapReferenceSuccesses>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MapReferenceErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ReduceAttempts>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ReduceSuccesses>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ReduceErrors>k__BackingField;
    public string Name { get; public set; }
    public long MapAttempts { get; public set; }
    public long MapSuccesses { get; public set; }
    public long MapErrors { get; public set; }
    public Nullable`1<long> MapReferenceAttempts { get; public set; }
    public Nullable`1<long> MapReferenceSuccesses { get; public set; }
    public Nullable`1<long> MapReferenceErrors { get; public set; }
    public Nullable`1<long> ReduceAttempts { get; public set; }
    public Nullable`1<long> ReduceSuccesses { get; public set; }
    public Nullable`1<long> ReduceErrors { get; public set; }
    public float FailureRate { get; }
    public bool IsInvalidIndex(bool isStale);
    public static bool CheckIndexInvalid(long mapAttempts, long mapErrors, Nullable`1<long> mapReferenceAttempts, Nullable`1<long> mapReferenceErrors, Nullable`1<long> reduceAttempts, Nullable`1<long> reduceErrors, bool isStale);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public long get_MapAttempts();
    [CompilerGeneratedAttribute]
public void set_MapAttempts(long value);
    [CompilerGeneratedAttribute]
public long get_MapSuccesses();
    [CompilerGeneratedAttribute]
public void set_MapSuccesses(long value);
    [CompilerGeneratedAttribute]
public long get_MapErrors();
    [CompilerGeneratedAttribute]
public void set_MapErrors(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MapReferenceAttempts();
    [CompilerGeneratedAttribute]
public void set_MapReferenceAttempts(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MapReferenceSuccesses();
    [CompilerGeneratedAttribute]
public void set_MapReferenceSuccesses(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MapReferenceErrors();
    [CompilerGeneratedAttribute]
public void set_MapReferenceErrors(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ReduceAttempts();
    [CompilerGeneratedAttribute]
public void set_ReduceAttempts(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ReduceSuccesses();
    [CompilerGeneratedAttribute]
public void set_ReduceSuccesses(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ReduceErrors();
    [CompilerGeneratedAttribute]
public void set_ReduceErrors(Nullable`1<long> value);
    public float get_FailureRate();
    public string GetErrorMessage();
}
public class Raven.Client.Documents.Indexes.IndexFieldOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<FieldStorage> <Storage>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<FieldIndexing> <Indexing>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<FieldTermVector> <TermVector>k__BackingField;
    [CompilerGeneratedAttribute]
private SpatialOptions <Spatial>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Analyzer>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Suggestions>k__BackingField;
    public Nullable`1<FieldStorage> Storage { get; public set; }
    public Nullable`1<FieldIndexing> Indexing { get; public set; }
    public Nullable`1<FieldTermVector> TermVector { get; public set; }
    public SpatialOptions Spatial { get; public set; }
    public string Analyzer { get; public set; }
    public Nullable`1<bool> Suggestions { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<FieldStorage> get_Storage();
    [CompilerGeneratedAttribute]
public void set_Storage(Nullable`1<FieldStorage> value);
    [CompilerGeneratedAttribute]
public Nullable`1<FieldIndexing> get_Indexing();
    [CompilerGeneratedAttribute]
public void set_Indexing(Nullable`1<FieldIndexing> value);
    [CompilerGeneratedAttribute]
public Nullable`1<FieldTermVector> get_TermVector();
    [CompilerGeneratedAttribute]
public void set_TermVector(Nullable`1<FieldTermVector> value);
    [CompilerGeneratedAttribute]
public SpatialOptions get_Spatial();
    [CompilerGeneratedAttribute]
public void set_Spatial(SpatialOptions value);
    [CompilerGeneratedAttribute]
public string get_Analyzer();
    [CompilerGeneratedAttribute]
public void set_Analyzer(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Suggestions();
    [CompilerGeneratedAttribute]
public void set_Suggestions(Nullable`1<bool> value);
    private bool Equals(IndexFieldOptions other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Raven.Client.Documents.Indexes.IndexingError : object {
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Action>k__BackingField;
    public string Error { get; public set; }
    public DateTime Timestamp { get; public set; }
    public string Document { get; public set; }
    public string Action { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(string value);
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTime value);
    [CompilerGeneratedAttribute]
public string get_Document();
    [CompilerGeneratedAttribute]
public void set_Document(string value);
    [CompilerGeneratedAttribute]
public string get_Action();
    [CompilerGeneratedAttribute]
public void set_Action(string value);
    public virtual string ToString();
}
internal static class Raven.Client.Documents.Indexes.IndexingOperation : object {
    public static string LoadDocument;
    public static string LoadAttachment;
    public static string LoadCompareExchangeValue;
}
public class Raven.Client.Documents.Indexes.IndexingPerformanceBasicStats : object {
    [CompilerGeneratedAttribute]
private long <InputCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FailedCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OutputCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SuccessCount>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Started>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DurationInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <AllocatedManagedBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <AllocatedUnmanagedBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <DocumentsSize>k__BackingField;
    public long InputCount { get; public set; }
    public long FailedCount { get; public set; }
    public long OutputCount { get; public set; }
    public long SuccessCount { get; public set; }
    public DateTime Started { get; public set; }
    public double DurationInMs { get; }
    public Size AllocatedManagedBytes { get; public set; }
    public Size AllocatedUnmanagedBytes { get; public set; }
    public Size DocumentsSize { get; public set; }
    public IndexingPerformanceBasicStats(TimeSpan duration);
    [CompilerGeneratedAttribute]
public long get_InputCount();
    [CompilerGeneratedAttribute]
public void set_InputCount(long value);
    [CompilerGeneratedAttribute]
public long get_FailedCount();
    [CompilerGeneratedAttribute]
public void set_FailedCount(long value);
    [CompilerGeneratedAttribute]
public long get_OutputCount();
    [CompilerGeneratedAttribute]
public void set_OutputCount(long value);
    [CompilerGeneratedAttribute]
public long get_SuccessCount();
    [CompilerGeneratedAttribute]
public void set_SuccessCount(long value);
    [CompilerGeneratedAttribute]
public DateTime get_Started();
    [CompilerGeneratedAttribute]
public void set_Started(DateTime value);
    [CompilerGeneratedAttribute]
public double get_DurationInMs();
    [CompilerGeneratedAttribute]
public Size get_AllocatedManagedBytes();
    [CompilerGeneratedAttribute]
public void set_AllocatedManagedBytes(Size value);
    [CompilerGeneratedAttribute]
public Size get_AllocatedUnmanagedBytes();
    [CompilerGeneratedAttribute]
public void set_AllocatedUnmanagedBytes(Size value);
    [CompilerGeneratedAttribute]
public Size get_DocumentsSize();
    [CompilerGeneratedAttribute]
public void set_DocumentsSize(Size value);
}
public class Raven.Client.Documents.Indexes.IndexingPerformanceOperation : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DurationInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private ReduceRunDetails <ReduceDetails>k__BackingField;
    [CompilerGeneratedAttribute]
private MapRunDetails <MapDetails>k__BackingField;
    [CompilerGeneratedAttribute]
private CleanupRunDetails <CleanupDetails>k__BackingField;
    [CompilerGeneratedAttribute]
private LuceneMergeDetails <LuceneMergeDetails>k__BackingField;
    [CompilerGeneratedAttribute]
private StorageCommitDetails <CommitDetails>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexingPerformanceOperation[] <Operations>k__BackingField;
    [CompilerGeneratedAttribute]
private ReferenceRunDetails <ReferenceDetails>k__BackingField;
    public string Name { get; public set; }
    public double DurationInMs { get; }
    public ReduceRunDetails ReduceDetails { get; public set; }
    public MapRunDetails MapDetails { get; public set; }
    public CleanupRunDetails CleanupDetails { get; public set; }
    public LuceneMergeDetails LuceneMergeDetails { get; public set; }
    public StorageCommitDetails CommitDetails { get; public set; }
    public IndexingPerformanceOperation[] Operations { get; public set; }
    public ReferenceRunDetails ReferenceDetails { get; public set; }
    public IndexingPerformanceOperation(TimeSpan duration);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public double get_DurationInMs();
    [CompilerGeneratedAttribute]
public ReduceRunDetails get_ReduceDetails();
    [CompilerGeneratedAttribute]
public void set_ReduceDetails(ReduceRunDetails value);
    [CompilerGeneratedAttribute]
public MapRunDetails get_MapDetails();
    [CompilerGeneratedAttribute]
public void set_MapDetails(MapRunDetails value);
    [CompilerGeneratedAttribute]
public CleanupRunDetails get_CleanupDetails();
    [CompilerGeneratedAttribute]
public void set_CleanupDetails(CleanupRunDetails value);
    [CompilerGeneratedAttribute]
public LuceneMergeDetails get_LuceneMergeDetails();
    [CompilerGeneratedAttribute]
public void set_LuceneMergeDetails(LuceneMergeDetails value);
    [CompilerGeneratedAttribute]
public StorageCommitDetails get_CommitDetails();
    [CompilerGeneratedAttribute]
public void set_CommitDetails(StorageCommitDetails value);
    [CompilerGeneratedAttribute]
public IndexingPerformanceOperation[] get_Operations();
    [CompilerGeneratedAttribute]
public void set_Operations(IndexingPerformanceOperation[] value);
    [CompilerGeneratedAttribute]
public ReferenceRunDetails get_ReferenceDetails();
    [CompilerGeneratedAttribute]
public void set_ReferenceDetails(ReferenceRunDetails value);
}
public class Raven.Client.Documents.Indexes.IndexingPerformanceStats : IndexingPerformanceBasicStats {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Completed>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexingPerformanceOperation <Details>k__BackingField;
    public int Id { get; public set; }
    public Nullable`1<DateTime> Completed { get; public set; }
    public IndexingPerformanceOperation Details { get; public set; }
    public IndexingPerformanceStats(TimeSpan duration);
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Completed();
    [CompilerGeneratedAttribute]
public void set_Completed(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public IndexingPerformanceOperation get_Details();
    [CompilerGeneratedAttribute]
public void set_Details(IndexingPerformanceOperation value);
}
public class Raven.Client.Documents.Indexes.IndexingStatus : object {
    [CompilerGeneratedAttribute]
private IndexRunningStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexStatus[] <Indexes>k__BackingField;
    public IndexRunningStatus Status { get; public set; }
    public IndexStatus[] Indexes { get; public set; }
    [CompilerGeneratedAttribute]
public IndexRunningStatus get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(IndexRunningStatus value);
    [CompilerGeneratedAttribute]
public IndexStatus[] get_Indexes();
    [CompilerGeneratedAttribute]
public void set_Indexes(IndexStatus[] value);
}
public enum Raven.Client.Documents.Indexes.IndexLockMode : Enum {
    public int value__;
    public static IndexLockMode Unlock;
    public static IndexLockMode LockedIgnore;
    public static IndexLockMode LockedError;
}
public class Raven.Client.Documents.Indexes.IndexPerformanceStats : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexingPerformanceStats[] <Performance>k__BackingField;
    public string Name { get; public set; }
    public IndexingPerformanceStats[] Performance { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public IndexingPerformanceStats[] get_Performance();
    [CompilerGeneratedAttribute]
public void set_Performance(IndexingPerformanceStats[] value);
}
public enum Raven.Client.Documents.Indexes.IndexPriority : Enum {
    public int value__;
    public static IndexPriority Low;
    public static IndexPriority Normal;
    public static IndexPriority High;
}
internal class Raven.Client.Documents.Indexes.IndexProgress : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexSourceType <SourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, CollectionStats> <Collections>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStale>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexRunningStatus <IndexRunningStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ProcessedPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private RollingIndex <IndexRollingStatus>k__BackingField;
    public string Name { get; public set; }
    public IndexType Type { get; public set; }
    public IndexSourceType SourceType { get; public set; }
    public Dictionary`2<string, CollectionStats> Collections { get; public set; }
    public bool IsStale { get; public set; }
    public IndexRunningStatus IndexRunningStatus { get; public set; }
    public double ProcessedPerSecond { get; public set; }
    public RollingIndex IndexRollingStatus { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public IndexType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IndexType value);
    [CompilerGeneratedAttribute]
public IndexSourceType get_SourceType();
    [CompilerGeneratedAttribute]
public void set_SourceType(IndexSourceType value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, CollectionStats> get_Collections();
    [CompilerGeneratedAttribute]
public void set_Collections(Dictionary`2<string, CollectionStats> value);
    [CompilerGeneratedAttribute]
public bool get_IsStale();
    [CompilerGeneratedAttribute]
public void set_IsStale(bool value);
    [CompilerGeneratedAttribute]
public IndexRunningStatus get_IndexRunningStatus();
    [CompilerGeneratedAttribute]
public void set_IndexRunningStatus(IndexRunningStatus value);
    [CompilerGeneratedAttribute]
public double get_ProcessedPerSecond();
    [CompilerGeneratedAttribute]
public void set_ProcessedPerSecond(double value);
    [CompilerGeneratedAttribute]
public RollingIndex get_IndexRollingStatus();
    [CompilerGeneratedAttribute]
public void set_IndexRollingStatus(RollingIndex value);
}
public enum Raven.Client.Documents.Indexes.IndexResetMode : Enum {
    public int value__;
    public static IndexResetMode InPlace;
    public static IndexResetMode SideBySide;
}
public enum Raven.Client.Documents.Indexes.IndexRunningStatus : Enum {
    public int value__;
    public static IndexRunningStatus Running;
    public static IndexRunningStatus Paused;
    public static IndexRunningStatus Disabled;
    public static IndexRunningStatus Pending;
}
public enum Raven.Client.Documents.Indexes.IndexSourceType : Enum {
    public int value__;
    public static IndexSourceType None;
    public static IndexSourceType Documents;
    public static IndexSourceType TimeSeries;
    public static IndexSourceType Counters;
}
public enum Raven.Client.Documents.Indexes.IndexState : Enum {
    public int value__;
    public static IndexState Normal;
    public static IndexState Disabled;
    public static IndexState Idle;
    public static IndexState Error;
}
public class Raven.Client.Documents.Indexes.IndexStats : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MapAttempts>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MapSuccesses>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MapErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MapReferenceAttempts>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MapReferenceSuccesses>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MapReferenceErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ReduceAttempts>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ReduceSuccesses>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ReduceErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReduceOutputCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReduceOutputReferencePattern>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PatternReferencesCollectionName>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MappedPerSecondRate>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ReducedPerSecondRate>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxNumberOfOutputsPerDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, CollectionStats> <Collections>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastQueryingTime>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexPriority <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CreatedTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastIndexingTime>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStale>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexLockMode <LockMode>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private SearchEngineType <SearchEngineType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ArchivedDataProcessingBehavior> <ArchivedDataProcessingBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexRunningStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EntriesCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ErrorsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexSourceType <SourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <ReferencedCollections>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryStats <Memory>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexingPerformanceBasicStats <LastBatchStats>k__BackingField;
    public string Name { get; public set; }
    public int MapAttempts { get; public set; }
    public int MapSuccesses { get; public set; }
    public int MapErrors { get; public set; }
    public Nullable`1<int> MapReferenceAttempts { get; public set; }
    public Nullable`1<int> MapReferenceSuccesses { get; public set; }
    public Nullable`1<int> MapReferenceErrors { get; public set; }
    public Nullable`1<long> ReduceAttempts { get; public set; }
    public Nullable`1<long> ReduceSuccesses { get; public set; }
    public Nullable`1<long> ReduceErrors { get; public set; }
    public string ReduceOutputCollection { get; public set; }
    public string ReduceOutputReferencePattern { get; public set; }
    public string PatternReferencesCollectionName { get; public set; }
    public double MappedPerSecondRate { get; public set; }
    public double ReducedPerSecondRate { get; public set; }
    public int MaxNumberOfOutputsPerDocument { get; public set; }
    public Dictionary`2<string, CollectionStats> Collections { get; public set; }
    public Nullable`1<DateTime> LastQueryingTime { get; public set; }
    public IndexState State { get; public set; }
    public IndexPriority Priority { get; public set; }
    public DateTime CreatedTimestamp { get; public set; }
    public Nullable`1<DateTime> LastIndexingTime { get; public set; }
    public bool IsStale { get; public set; }
    public IndexLockMode LockMode { get; public set; }
    public IndexType Type { get; public set; }
    public SearchEngineType SearchEngineType { get; public set; }
    public Nullable`1<ArchivedDataProcessingBehavior> ArchivedDataProcessingBehavior { get; public set; }
    public IndexRunningStatus Status { get; public set; }
    public long EntriesCount { get; public set; }
    public int ErrorsCount { get; public set; }
    public IndexSourceType SourceType { get; public set; }
    public HashSet`1<string> ReferencedCollections { get; public set; }
    public bool IsInvalidIndex { get; }
    public MemoryStats Memory { get; public set; }
    public IndexingPerformanceBasicStats LastBatchStats { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_MapAttempts();
    [CompilerGeneratedAttribute]
public void set_MapAttempts(int value);
    [CompilerGeneratedAttribute]
public int get_MapSuccesses();
    [CompilerGeneratedAttribute]
public void set_MapSuccesses(int value);
    [CompilerGeneratedAttribute]
public int get_MapErrors();
    [CompilerGeneratedAttribute]
public void set_MapErrors(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MapReferenceAttempts();
    [CompilerGeneratedAttribute]
public void set_MapReferenceAttempts(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MapReferenceSuccesses();
    [CompilerGeneratedAttribute]
public void set_MapReferenceSuccesses(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MapReferenceErrors();
    [CompilerGeneratedAttribute]
public void set_MapReferenceErrors(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ReduceAttempts();
    [CompilerGeneratedAttribute]
public void set_ReduceAttempts(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ReduceSuccesses();
    [CompilerGeneratedAttribute]
public void set_ReduceSuccesses(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ReduceErrors();
    [CompilerGeneratedAttribute]
public void set_ReduceErrors(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public string get_ReduceOutputCollection();
    [CompilerGeneratedAttribute]
public void set_ReduceOutputCollection(string value);
    [CompilerGeneratedAttribute]
public string get_ReduceOutputReferencePattern();
    [CompilerGeneratedAttribute]
public void set_ReduceOutputReferencePattern(string value);
    [CompilerGeneratedAttribute]
public string get_PatternReferencesCollectionName();
    [CompilerGeneratedAttribute]
public void set_PatternReferencesCollectionName(string value);
    [CompilerGeneratedAttribute]
public double get_MappedPerSecondRate();
    [CompilerGeneratedAttribute]
public void set_MappedPerSecondRate(double value);
    [CompilerGeneratedAttribute]
public double get_ReducedPerSecondRate();
    [CompilerGeneratedAttribute]
public void set_ReducedPerSecondRate(double value);
    [CompilerGeneratedAttribute]
public int get_MaxNumberOfOutputsPerDocument();
    [CompilerGeneratedAttribute]
public void set_MaxNumberOfOutputsPerDocument(int value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, CollectionStats> get_Collections();
    [CompilerGeneratedAttribute]
public void set_Collections(Dictionary`2<string, CollectionStats> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastQueryingTime();
    [CompilerGeneratedAttribute]
public void set_LastQueryingTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public IndexState get_State();
    [CompilerGeneratedAttribute]
public void set_State(IndexState value);
    [CompilerGeneratedAttribute]
public IndexPriority get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(IndexPriority value);
    [CompilerGeneratedAttribute]
public DateTime get_CreatedTimestamp();
    [CompilerGeneratedAttribute]
public void set_CreatedTimestamp(DateTime value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastIndexingTime();
    [CompilerGeneratedAttribute]
public void set_LastIndexingTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public bool get_IsStale();
    [CompilerGeneratedAttribute]
public void set_IsStale(bool value);
    [CompilerGeneratedAttribute]
public IndexLockMode get_LockMode();
    [CompilerGeneratedAttribute]
public void set_LockMode(IndexLockMode value);
    [CompilerGeneratedAttribute]
public IndexType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IndexType value);
    [CompilerGeneratedAttribute]
public SearchEngineType get_SearchEngineType();
    [CompilerGeneratedAttribute]
public void set_SearchEngineType(SearchEngineType value);
    [CompilerGeneratedAttribute]
public Nullable`1<ArchivedDataProcessingBehavior> get_ArchivedDataProcessingBehavior();
    [CompilerGeneratedAttribute]
public void set_ArchivedDataProcessingBehavior(Nullable`1<ArchivedDataProcessingBehavior> value);
    [CompilerGeneratedAttribute]
public IndexRunningStatus get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(IndexRunningStatus value);
    [CompilerGeneratedAttribute]
public long get_EntriesCount();
    [CompilerGeneratedAttribute]
public void set_EntriesCount(long value);
    [CompilerGeneratedAttribute]
public int get_ErrorsCount();
    [CompilerGeneratedAttribute]
public void set_ErrorsCount(int value);
    [CompilerGeneratedAttribute]
public IndexSourceType get_SourceType();
    [CompilerGeneratedAttribute]
public void set_SourceType(IndexSourceType value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_ReferencedCollections();
    [CompilerGeneratedAttribute]
public void set_ReferencedCollections(HashSet`1<string> value);
    public bool get_IsInvalidIndex();
    [CompilerGeneratedAttribute]
public MemoryStats get_Memory();
    [CompilerGeneratedAttribute]
public void set_Memory(MemoryStats value);
    [CompilerGeneratedAttribute]
public IndexingPerformanceBasicStats get_LastBatchStats();
    [CompilerGeneratedAttribute]
public void set_LastBatchStats(IndexingPerformanceBasicStats value);
}
public enum Raven.Client.Documents.Indexes.IndexType : Enum {
    public int value__;
    public static IndexType None;
    public static IndexType AutoMap;
    public static IndexType AutoMapReduce;
    public static IndexType Map;
    public static IndexType MapReduce;
    public static IndexType Faulty;
    public static IndexType JavaScriptMap;
    public static IndexType JavaScriptMapReduce;
}
[ExtensionAttribute]
internal static class Raven.Client.Documents.Indexes.IndexTypeExtensions : object {
    [ExtensionAttribute]
public static bool IsMap(IndexType self);
    [ExtensionAttribute]
public static bool IsMapReduce(IndexType self);
    [ExtensionAttribute]
public static bool IsStaticMapReduce(IndexType self);
    [ExtensionAttribute]
public static bool IsAutoMapReduce(IndexType self);
    [ExtensionAttribute]
public static bool IsAuto(IndexType self);
    [ExtensionAttribute]
public static bool IsStatic(IndexType self);
    [ExtensionAttribute]
public static bool IsJavaScript(IndexType self);
}
internal class Raven.Client.Documents.Indexes.JSBeautify : object {
    private StringBuilder output;
    private string indent_string;
    private int indent_level;
    private string token_text;
    private Stack`1<string> modes;
    private string current_mode;
    private int opt_indent_size;
    private char opt_indent_char;
    private int opt_indent_level;
    private bool opt_preserve_newlines;
    private bool if_line_flag;
    private bool do_block_just_closed;
    private string input;
    private string whitespace;
    private string wordchar;
    private int parser_pos;
    private string last_type;
    private string last_text;
    private string digits;
    private String[] punct;
    private string prefix;
    private string last_word;
    private bool var_line;
    private bool var_line_tainted;
    private String[] line_starters;
    private bool in_case;
    private string token_type;
    private bool add_script_tags;
    public JSBeautify(string js_source_text, JSBeautifyOptions options);
    public static string Apply(string origin);
    private void trim_output();
    private void print_newline(Nullable`1<bool> ignore_repeated);
    private void print_space();
    private void print_token();
    private void indent();
    private void unindent();
    private void remove_indent();
    private void set_mode(string mode);
    private void restore_mode();
    private bool is_ternary_op();
    private String[] get_next_token(Int32& parser_pos);
    public string GetResult();
}
public enum Raven.Client.Documents.Indexes.LuceneIndexInputType : Enum {
    public int value__;
    public static LuceneIndexInputType Standard;
    public static LuceneIndexInputType Buffered;
}
public class Raven.Client.Documents.Indexes.LuceneMergeDetails : object {
    [CompilerGeneratedAttribute]
private int <TotalMergesCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExecutedMergesCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MergedFilesCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MergedDocumentsCount>k__BackingField;
    public int TotalMergesCount { get; public set; }
    public int ExecutedMergesCount { get; public set; }
    public long MergedFilesCount { get; public set; }
    public long MergedDocumentsCount { get; public set; }
    [CompilerGeneratedAttribute]
public int get_TotalMergesCount();
    [CompilerGeneratedAttribute]
public void set_TotalMergesCount(int value);
    [CompilerGeneratedAttribute]
public int get_ExecutedMergesCount();
    [CompilerGeneratedAttribute]
public void set_ExecutedMergesCount(int value);
    [CompilerGeneratedAttribute]
public long get_MergedFilesCount();
    [CompilerGeneratedAttribute]
public void set_MergedFilesCount(long value);
    [CompilerGeneratedAttribute]
public long get_MergedDocumentsCount();
    [CompilerGeneratedAttribute]
public void set_MergedDocumentsCount(long value);
}
public class Raven.Client.Documents.Indexes.MapReduce.OutputReduceToCollectionReference : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <ReduceOutputs>k__BackingField;
    public string Id { get; public set; }
    public List`1<string> ReduceOutputs { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_ReduceOutputs();
    [CompilerGeneratedAttribute]
public void set_ReduceOutputs(List`1<string> value);
}
public class Raven.Client.Documents.Indexes.MapRunDetails : object {
    [CompilerGeneratedAttribute]
private string <BatchCompleteReason>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ProcessPrivateMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ProcessWorkingSet>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CurrentlyAllocated>k__BackingField;
    [CompilerGeneratedAttribute]
private long <AllocationBudget>k__BackingField;
    public string BatchCompleteReason { get; public set; }
    public long ProcessPrivateMemory { get; public set; }
    public long ProcessWorkingSet { get; public set; }
    public long CurrentlyAllocated { get; public set; }
    public long AllocationBudget { get; public set; }
    [CompilerGeneratedAttribute]
public string get_BatchCompleteReason();
    [CompilerGeneratedAttribute]
public void set_BatchCompleteReason(string value);
    [CompilerGeneratedAttribute]
public long get_ProcessPrivateMemory();
    [CompilerGeneratedAttribute]
public void set_ProcessPrivateMemory(long value);
    [CompilerGeneratedAttribute]
public long get_ProcessWorkingSet();
    [CompilerGeneratedAttribute]
public void set_ProcessWorkingSet(long value);
    [CompilerGeneratedAttribute]
public long get_CurrentlyAllocated();
    [CompilerGeneratedAttribute]
public void set_CurrentlyAllocated(long value);
    [CompilerGeneratedAttribute]
public long get_AllocationBudget();
    [CompilerGeneratedAttribute]
public void set_AllocationBudget(long value);
}
public class Raven.Client.Documents.Indexes.NoTrackingCommonApiForIndexes : object {
    public sealed virtual T LoadDocument(string id);
    public sealed virtual T LoadDocument(string id, string collectionName);
    public sealed virtual T[] LoadDocument(IEnumerable`1<string> ids);
    public sealed virtual T[] LoadDocument(IEnumerable`1<string> ids, string collectionName);
}
internal static class Raven.Client.Documents.Indexes.NumberUtil : object {
    public static string NumberToString(long number);
    public static string NumberToString(double number);
    public static string NumberToString(float number);
}
public class Raven.Client.Documents.Indexes.PutIndexResult : object {
    [CompilerGeneratedAttribute]
private string <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RaftCommandIndex>k__BackingField;
    public string Index { get; public set; }
    public long RaftCommandIndex { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(string value);
    [CompilerGeneratedAttribute]
public long get_RaftCommandIndex();
    [CompilerGeneratedAttribute]
public void set_RaftCommandIndex(long value);
}
public enum Raven.Client.Documents.Indexes.RangeType : Enum {
    public int value__;
    public static RangeType None;
    public static RangeType Long;
    public static RangeType Double;
}
[AttributeUsageAttribute("64")]
public class Raven.Client.Documents.Indexes.RavenMethodAttribute : Attribute {
}
public class Raven.Client.Documents.Indexes.ReduceRunDetails : object {
    [CompilerGeneratedAttribute]
private long <ProcessPrivateMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ProcessWorkingSet>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CurrentlyAllocated>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ReduceAttempts>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ReduceSuccesses>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ReduceErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private TreesReduceDetails <TreesReduceDetails>k__BackingField;
    public long ProcessPrivateMemory { get; public set; }
    public long ProcessWorkingSet { get; public set; }
    public long CurrentlyAllocated { get; public set; }
    public long ReduceAttempts { get; public set; }
    public long ReduceSuccesses { get; public set; }
    public long ReduceErrors { get; public set; }
    public TreesReduceDetails TreesReduceDetails { get; public set; }
    [CompilerGeneratedAttribute]
public long get_ProcessPrivateMemory();
    [CompilerGeneratedAttribute]
public void set_ProcessPrivateMemory(long value);
    [CompilerGeneratedAttribute]
public long get_ProcessWorkingSet();
    [CompilerGeneratedAttribute]
public void set_ProcessWorkingSet(long value);
    [CompilerGeneratedAttribute]
public long get_CurrentlyAllocated();
    [CompilerGeneratedAttribute]
public void set_CurrentlyAllocated(long value);
    [CompilerGeneratedAttribute]
public long get_ReduceAttempts();
    [CompilerGeneratedAttribute]
public void set_ReduceAttempts(long value);
    [CompilerGeneratedAttribute]
public long get_ReduceSuccesses();
    [CompilerGeneratedAttribute]
public void set_ReduceSuccesses(long value);
    [CompilerGeneratedAttribute]
public long get_ReduceErrors();
    [CompilerGeneratedAttribute]
public void set_ReduceErrors(long value);
    [CompilerGeneratedAttribute]
public TreesReduceDetails get_TreesReduceDetails();
    [CompilerGeneratedAttribute]
public void set_TreesReduceDetails(TreesReduceDetails value);
}
public class Raven.Client.Documents.Indexes.ReferenceRunDetails : object {
    [CompilerGeneratedAttribute]
private int <ReferenceAttempts>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReferenceSuccesses>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReferenceErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ProcessPrivateMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ProcessWorkingSet>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CurrentlyAllocated>k__BackingField;
    [CompilerGeneratedAttribute]
private long <AllocationBudget>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BatchCompleteReason>k__BackingField;
    public int ReferenceAttempts { get; public set; }
    public int ReferenceSuccesses { get; public set; }
    public int ReferenceErrors { get; public set; }
    public long ProcessPrivateMemory { get; public set; }
    public long ProcessWorkingSet { get; public set; }
    public long CurrentlyAllocated { get; public set; }
    public long AllocationBudget { get; public set; }
    public string BatchCompleteReason { get; public set; }
    [CompilerGeneratedAttribute]
public int get_ReferenceAttempts();
    [CompilerGeneratedAttribute]
public void set_ReferenceAttempts(int value);
    [CompilerGeneratedAttribute]
public int get_ReferenceSuccesses();
    [CompilerGeneratedAttribute]
public void set_ReferenceSuccesses(int value);
    [CompilerGeneratedAttribute]
public int get_ReferenceErrors();
    [CompilerGeneratedAttribute]
public void set_ReferenceErrors(int value);
    [CompilerGeneratedAttribute]
public long get_ProcessPrivateMemory();
    [CompilerGeneratedAttribute]
public void set_ProcessPrivateMemory(long value);
    [CompilerGeneratedAttribute]
public long get_ProcessWorkingSet();
    [CompilerGeneratedAttribute]
public void set_ProcessWorkingSet(long value);
    [CompilerGeneratedAttribute]
public long get_CurrentlyAllocated();
    [CompilerGeneratedAttribute]
public void set_CurrentlyAllocated(long value);
    [CompilerGeneratedAttribute]
public long get_AllocationBudget();
    [CompilerGeneratedAttribute]
public void set_AllocationBudget(long value);
    [CompilerGeneratedAttribute]
public string get_BatchCompleteReason();
    [CompilerGeneratedAttribute]
public void set_BatchCompleteReason(string value);
}
public class Raven.Client.Documents.Indexes.RollingIndex : object {
    public Dictionary`2<string, RollingIndexDeployment> ActiveDeployments;
    public long RaftCommandIndex;
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Indexes.RollingIndexDeployment : object {
    [CompilerGeneratedAttribute]
private RollingIndexState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CreatedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <StartedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <FinishedAt>k__BackingField;
    public RollingIndexState State { get; public set; }
    public DateTime CreatedAt { get; public set; }
    public Nullable`1<DateTime> StartedAt { get; public set; }
    public Nullable`1<DateTime> FinishedAt { get; public set; }
    [CompilerGeneratedAttribute]
public RollingIndexState get_State();
    [CompilerGeneratedAttribute]
public void set_State(RollingIndexState value);
    [CompilerGeneratedAttribute]
public DateTime get_CreatedAt();
    [CompilerGeneratedAttribute]
public void set_CreatedAt(DateTime value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_StartedAt();
    [CompilerGeneratedAttribute]
public void set_StartedAt(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_FinishedAt();
    [CompilerGeneratedAttribute]
public void set_FinishedAt(Nullable`1<DateTime> value);
    public sealed virtual DynamicJsonValue ToJson();
}
public enum Raven.Client.Documents.Indexes.RollingIndexState : Enum {
    public int value__;
    public static RollingIndexState Pending;
    public static RollingIndexState Running;
    public static RollingIndexState Done;
}
public enum Raven.Client.Documents.Indexes.SearchEngineType : Enum {
    public int value__;
    public static SearchEngineType None;
    public static SearchEngineType Corax;
    public static SearchEngineType Lucene;
}
public class Raven.Client.Documents.Indexes.Spatial.AutoSpatialOptions : SpatialOptions {
    [CompilerGeneratedAttribute]
private AutoSpatialMethodType <MethodType>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <MethodArguments>k__BackingField;
    public AutoSpatialMethodType MethodType { get; public set; }
    public List`1<string> MethodArguments { get; public set; }
    public AutoSpatialOptions(AutoSpatialMethodType methodType, List`1<string> methodArguments);
    public AutoSpatialOptions(AutoSpatialOptions options);
    [CompilerGeneratedAttribute]
public AutoSpatialMethodType get_MethodType();
    [CompilerGeneratedAttribute]
public void set_MethodType(AutoSpatialMethodType value);
    [CompilerGeneratedAttribute]
public List`1<string> get_MethodArguments();
    [CompilerGeneratedAttribute]
public void set_MethodArguments(List`1<string> value);
    private bool Equals(AutoSpatialOptions other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Raven.Client.Documents.Indexes.Spatial.CartesianSpatialOptionsFactory : object {
    public SpatialOptions BoundingBoxIndex();
    public SpatialOptions QuadPrefixTreeIndex(int maxTreeLevel, SpatialBounds bounds);
}
public class Raven.Client.Documents.Indexes.Spatial.GeographySpatialOptionsFactory : object {
    public SpatialOptions Default(SpatialUnits circleRadiusUnits);
    public SpatialOptions BoundingBoxIndex(SpatialUnits circleRadiusUnits);
    public SpatialOptions GeohashPrefixTreeIndex(int maxTreeLevel, SpatialUnits circleRadiusUnits);
    public SpatialOptions QuadPrefixTreeIndex(int maxTreeLevel, SpatialUnits circleRadiusUnits);
}
public class Raven.Client.Documents.Indexes.Spatial.SpatialBounds : object {
    [CompilerGeneratedAttribute]
private double <MinX>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MaxX>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MinY>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MaxY>k__BackingField;
    public double MinX { get; }
    public double MaxX { get; }
    public double MinY { get; }
    public double MaxY { get; }
    public SpatialBounds(double minX, double minY, double maxX, double maxY);
    [CompilerGeneratedAttribute]
public double get_MinX();
    [CompilerGeneratedAttribute]
public double get_MaxX();
    [CompilerGeneratedAttribute]
public double get_MinY();
    [CompilerGeneratedAttribute]
public double get_MaxY();
    private bool Equals(SpatialBounds other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum Raven.Client.Documents.Indexes.Spatial.SpatialFieldType : Enum {
    public int value__;
    public static SpatialFieldType Geography;
    public static SpatialFieldType Cartesian;
}
public class Raven.Client.Documents.Indexes.Spatial.SpatialOptions : object {
    public static int DefaultGeohashLevel;
    public static int DefaultQuadTreeLevel;
    internal static SpatialOptions Default;
    [CompilerGeneratedAttribute]
private SpatialFieldType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private SpatialSearchStrategy <Strategy>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTreeLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MinX>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MaxX>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MinY>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MaxY>k__BackingField;
    [CompilerGeneratedAttribute]
private SpatialUnits <Units>k__BackingField;
    public SpatialFieldType Type { get; public set; }
    public SpatialSearchStrategy Strategy { get; public set; }
    public int MaxTreeLevel { get; public set; }
    public double MinX { get; public set; }
    public double MaxX { get; public set; }
    public double MinY { get; public set; }
    public double MaxY { get; public set; }
    public SpatialUnits Units { get; public set; }
    internal SpatialOptions(SpatialOptions options);
    private static SpatialOptions();
    [CompilerGeneratedAttribute]
public SpatialFieldType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(SpatialFieldType value);
    [CompilerGeneratedAttribute]
public SpatialSearchStrategy get_Strategy();
    [CompilerGeneratedAttribute]
public void set_Strategy(SpatialSearchStrategy value);
    [CompilerGeneratedAttribute]
public int get_MaxTreeLevel();
    [CompilerGeneratedAttribute]
public void set_MaxTreeLevel(int value);
    [CompilerGeneratedAttribute]
public double get_MinX();
    [CompilerGeneratedAttribute]
public void set_MinX(double value);
    [CompilerGeneratedAttribute]
public double get_MaxX();
    [CompilerGeneratedAttribute]
public void set_MaxX(double value);
    [CompilerGeneratedAttribute]
public double get_MinY();
    [CompilerGeneratedAttribute]
public void set_MinY(double value);
    [CompilerGeneratedAttribute]
public double get_MaxY();
    [CompilerGeneratedAttribute]
public void set_MaxY(double value);
    [CompilerGeneratedAttribute]
public SpatialUnits get_Units();
    [CompilerGeneratedAttribute]
public void set_Units(SpatialUnits value);
    protected bool Equals(SpatialOptions other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Raven.Client.Documents.Indexes.Spatial.SpatialOptionsFactory : object {
    public GeographySpatialOptionsFactory Geography { get; }
    public CartesianSpatialOptionsFactory Cartesian { get; }
    public GeographySpatialOptionsFactory get_Geography();
    public CartesianSpatialOptionsFactory get_Cartesian();
}
public enum Raven.Client.Documents.Indexes.Spatial.SpatialRelation : Enum {
    public int value__;
    public static SpatialRelation Within;
    public static SpatialRelation Contains;
    public static SpatialRelation Disjoint;
    public static SpatialRelation Intersects;
}
public enum Raven.Client.Documents.Indexes.Spatial.SpatialSearchStrategy : Enum {
    public int value__;
    public static SpatialSearchStrategy GeohashPrefixTree;
    public static SpatialSearchStrategy QuadPrefixTree;
    public static SpatialSearchStrategy BoundingBox;
}
public enum Raven.Client.Documents.Indexes.Spatial.SpatialUnits : Enum {
    public int value__;
    public static SpatialUnits Kilometers;
    public static SpatialUnits Miles;
}
public class Raven.Client.Documents.Indexes.StorageCommitDetails : object {
    [CompilerGeneratedAttribute]
private int <NumberOfModifiedPages>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOf4KbsWrittenToDisk>k__BackingField;
    public int NumberOfModifiedPages { get; public set; }
    public int NumberOf4KbsWrittenToDisk { get; public set; }
    [CompilerGeneratedAttribute]
public int get_NumberOfModifiedPages();
    [CompilerGeneratedAttribute]
public void set_NumberOfModifiedPages(int value);
    [CompilerGeneratedAttribute]
public int get_NumberOf4KbsWrittenToDisk();
    [CompilerGeneratedAttribute]
public void set_NumberOf4KbsWrittenToDisk(int value);
}
public class Raven.Client.Documents.Indexes.Suggestions.SuggestionOptions : object {
    [CompilerGeneratedAttribute]
private StringDistanceTypes <Distance>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Accuracy>k__BackingField;
    public StringDistanceTypes Distance { get; public set; }
    public double Accuracy { get; public set; }
    [CompilerGeneratedAttribute]
public StringDistanceTypes get_Distance();
    [CompilerGeneratedAttribute]
public void set_Distance(StringDistanceTypes value);
    [CompilerGeneratedAttribute]
public double get_Accuracy();
    [CompilerGeneratedAttribute]
public void set_Accuracy(double value);
    private bool Equals(SuggestionOptions other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class Raven.Client.Documents.Indexes.TimeSeries.AbstractGenericTimeSeriesIndexCreationTask`1 : AbstractTimeSeriesIndexCreationTask {
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<IEnumerable`1<TReduceResult>, IEnumerable>> <Reduce>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldStorage> <Stores>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, FieldStorage> <StoresStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<Expression`1<Func`2<TReduceResult, object>>> <IndexSuggestions>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, string> <Analyzers>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <AnalyzersStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldTermVector> <TermVectors>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, FieldTermVector> <TermVectorsStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, SpatialOptions> <SpatialIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, SpatialOptions> <SpatialIndexesStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldIndexing> <Indexes>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, FieldIndexing> <IndexesStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputReduceToCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<TReduceResult, string>> <PatternForOutputReduceToCollectionReferences>k__BackingField;
    public bool IsMapReduce { get; }
    protected Expression`1<Func`2<IEnumerable`1<TReduceResult>, IEnumerable>> Reduce { get; protected set; }
    protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldStorage> Stores { get; protected set; }
    protected IDictionary`2<string, FieldStorage> StoresStrings { get; protected set; }
    protected ISet`1<Expression`1<Func`2<TReduceResult, object>>> IndexSuggestions { get; protected set; }
    protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, string> Analyzers { get; protected set; }
    protected IDictionary`2<string, string> AnalyzersStrings { get; protected set; }
    protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldTermVector> TermVectors { get; protected set; }
    protected IDictionary`2<string, FieldTermVector> TermVectorsStrings { get; protected set; }
    protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, SpatialOptions> SpatialIndexes { get; protected set; }
    protected IDictionary`2<string, SpatialOptions> SpatialIndexesStrings { get; protected set; }
    protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldIndexing> Indexes { get; protected set; }
    protected IDictionary`2<string, FieldIndexing> IndexesStrings { get; protected set; }
    protected string OutputReduceToCollection { get; protected set; }
    protected Expression`1<Func`2<TReduceResult, string>> PatternForOutputReduceToCollectionReferences { get; protected set; }
    public virtual bool get_IsMapReduce();
    [CompilerGeneratedAttribute]
protected Expression`1<Func`2<IEnumerable`1<TReduceResult>, IEnumerable>> get_Reduce();
    [CompilerGeneratedAttribute]
protected void set_Reduce(Expression`1<Func`2<IEnumerable`1<TReduceResult>, IEnumerable>> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldStorage> get_Stores();
    [CompilerGeneratedAttribute]
protected void set_Stores(IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldStorage> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<string, FieldStorage> get_StoresStrings();
    [CompilerGeneratedAttribute]
protected void set_StoresStrings(IDictionary`2<string, FieldStorage> value);
    [CompilerGeneratedAttribute]
protected ISet`1<Expression`1<Func`2<TReduceResult, object>>> get_IndexSuggestions();
    [CompilerGeneratedAttribute]
protected void set_IndexSuggestions(ISet`1<Expression`1<Func`2<TReduceResult, object>>> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, string> get_Analyzers();
    [CompilerGeneratedAttribute]
protected void set_Analyzers(IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, string> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<string, string> get_AnalyzersStrings();
    [CompilerGeneratedAttribute]
protected void set_AnalyzersStrings(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldTermVector> get_TermVectors();
    [CompilerGeneratedAttribute]
protected void set_TermVectors(IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldTermVector> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<string, FieldTermVector> get_TermVectorsStrings();
    [CompilerGeneratedAttribute]
protected void set_TermVectorsStrings(IDictionary`2<string, FieldTermVector> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, SpatialOptions> get_SpatialIndexes();
    [CompilerGeneratedAttribute]
protected void set_SpatialIndexes(IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, SpatialOptions> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<string, SpatialOptions> get_SpatialIndexesStrings();
    [CompilerGeneratedAttribute]
protected void set_SpatialIndexesStrings(IDictionary`2<string, SpatialOptions> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldIndexing> get_Indexes();
    [CompilerGeneratedAttribute]
protected void set_Indexes(IDictionary`2<Expression`1<Func`2<TReduceResult, object>>, FieldIndexing> value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<string, FieldIndexing> get_IndexesStrings();
    [CompilerGeneratedAttribute]
protected void set_IndexesStrings(IDictionary`2<string, FieldIndexing> value);
    [CompilerGeneratedAttribute]
protected string get_OutputReduceToCollection();
    [CompilerGeneratedAttribute]
protected void set_OutputReduceToCollection(string value);
    [CompilerGeneratedAttribute]
protected Expression`1<Func`2<TReduceResult, string>> get_PatternForOutputReduceToCollectionReferences();
    [CompilerGeneratedAttribute]
protected void set_PatternForOutputReduceToCollectionReferences(Expression`1<Func`2<TReduceResult, string>> value);
    protected void Index(Expression`1<Func`2<TReduceResult, object>> field, FieldIndexing indexing);
    protected void Index(string field, FieldIndexing indexing);
    protected void Spatial(Expression`1<Func`2<TReduceResult, object>> field, Func`2<SpatialOptionsFactory, SpatialOptions> indexing);
    protected void Spatial(string field, Func`2<SpatialOptionsFactory, SpatialOptions> indexing);
    protected void Store(Expression`1<Func`2<TReduceResult, object>> field, FieldStorage storage);
    protected void StoreAllFields(FieldStorage storage);
    protected void Store(string field, FieldStorage storage);
    protected void Analyze(Expression`1<Func`2<TReduceResult, object>> field, string analyzer);
    protected void Analyze(string field, string analyzer);
    protected void TermVector(Expression`1<Func`2<TReduceResult, object>> field, FieldTermVector termVector);
    protected void TermVector(string field, FieldTermVector termVector);
    protected void Suggestion(Expression`1<Func`2<TReduceResult, object>> field);
}
public abstract class Raven.Client.Documents.Indexes.TimeSeries.AbstractJavaScriptTimeSeriesIndexCreationTask : AbstractTimeSeriesIndexCreationTask {
    private TimeSeriesIndexDefinition _definition;
    public HashSet`1<string> Maps { get; public set; }
    public Dictionary`2<string, IndexFieldOptions> Fields { get; public set; }
    protected string Reduce { get; protected set; }
    public bool IsMapReduce { get; }
    protected string OutputReduceToCollection { get; protected set; }
    protected string PatternReferencesCollectionName { get; protected set; }
    protected string PatternForOutputReduceToCollectionReferences { get; protected set; }
    public HashSet`1<string> get_Maps();
    public void set_Maps(HashSet`1<string> value);
    public Dictionary`2<string, IndexFieldOptions> get_Fields();
    public void set_Fields(Dictionary`2<string, IndexFieldOptions> value);
    protected string get_Reduce();
    protected void set_Reduce(string value);
    public virtual bool get_IsMapReduce();
    protected string get_OutputReduceToCollection();
    protected void set_OutputReduceToCollection(string value);
    protected string get_PatternReferencesCollectionName();
    protected void set_PatternReferencesCollectionName(string value);
    protected string get_PatternForOutputReduceToCollectionReferences();
    protected void set_PatternForOutputReduceToCollectionReferences(string value);
    public virtual TimeSeriesIndexDefinition CreateIndexDefinition();
}
public abstract class Raven.Client.Documents.Indexes.TimeSeries.AbstractMultiMapTimeSeriesIndexCreationTask : AbstractMultiMapTimeSeriesIndexCreationTask`1<object> {
}
public abstract class Raven.Client.Documents.Indexes.TimeSeries.AbstractMultiMapTimeSeriesIndexCreationTask`1 : AbstractGenericTimeSeriesIndexCreationTask`1<TReduceResult> {
    private List`1<Func`1<string>> _maps;
    protected void AddMap(string timeSeries, Expression`1<Func`2<IEnumerable`1<TimeSeriesSegment>, IEnumerable>> map);
    protected void AddMapForAll(string timeSeries, Expression`1<Func`2<IEnumerable`1<TimeSeriesSegment>, IEnumerable>> map);
    public virtual TimeSeriesIndexDefinition CreateIndexDefinition();
}
public abstract class Raven.Client.Documents.Indexes.TimeSeries.AbstractTimeSeriesIndexCreationTask : AbstractIndexCreationTaskBase`1<TimeSeriesIndexDefinition> {
}
public abstract class Raven.Client.Documents.Indexes.TimeSeries.AbstractTimeSeriesIndexCreationTask`1 : AbstractTimeSeriesIndexCreationTask`2<TDocument, TDocument> {
}
public abstract class Raven.Client.Documents.Indexes.TimeSeries.AbstractTimeSeriesIndexCreationTask`2 : AbstractGenericTimeSeriesIndexCreationTask`1<TReduceResult> {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2<string, Expression`1<Func`2<IEnumerable`1<TimeSeriesSegment>, IEnumerable>>> _map;
    protected void AddMapForAll(Expression`1<Func`2<IEnumerable`1<TimeSeriesSegment>, IEnumerable>> map);
    protected void AddMap(string timeSeries, Expression`1<Func`2<IEnumerable`1<TimeSeriesSegment>, IEnumerable>> map);
    private void AddMapInternal(string timeSeries, Expression`1<Func`2<IEnumerable`1<TimeSeriesSegment>, IEnumerable>> map);
    public virtual TimeSeriesIndexDefinition CreateIndexDefinition();
}
public class Raven.Client.Documents.Indexes.TimeSeries.TimeSeriesIndexDefinition : IndexDefinition {
    public IndexSourceType SourceType { get; }
    public virtual IndexSourceType get_SourceType();
}
public class Raven.Client.Documents.Indexes.TimeSeries.TimeSeriesIndexDefinitionBuilder`1 : TimeSeriesIndexDefinitionBuilder`2<TDocument, TDocument> {
    public TimeSeriesIndexDefinitionBuilder`1(string indexName);
}
public class Raven.Client.Documents.Indexes.TimeSeries.TimeSeriesIndexDefinitionBuilder`2 : AbstractIndexDefinitionBuilder`3<TDocument, TReduceResult, TimeSeriesIndexDefinition> {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2<string, Expression`1<Func`2<IEnumerable`1<TimeSeriesSegment>, IEnumerable>>> _map;
    public TimeSeriesIndexDefinitionBuilder`2(string indexName);
    public void AddMapForAll(Expression`1<Func`2<IEnumerable`1<TimeSeriesSegment>, IEnumerable>> map);
    public void AddMap(string timeSeries, Expression`1<Func`2<IEnumerable`1<TimeSeriesSegment>, IEnumerable>> map);
    private void AddMapInternal(string timeSeries, Expression`1<Func`2<IEnumerable`1<TimeSeriesSegment>, IEnumerable>> map);
    public virtual TimeSeriesIndexDefinition ToIndexDefinition(DocumentConventions conventions, bool validateMap);
    protected virtual void ToIndexDefinition(TimeSeriesIndexDefinition indexDefinition, DocumentConventions conventions);
    private string GetQuerySource(DocumentConventions conventions);
}
public class Raven.Client.Documents.Indexes.TimeSeries.TimeSeriesSegment : object {
    [CompilerGeneratedAttribute]
private string <DocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Max>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Sum>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <End>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSeriesEntry[] <Entries>k__BackingField;
    public string DocumentId { get; public set; }
    public string Name { get; public set; }
    public Double[] Min { get; public set; }
    public Double[] Max { get; public set; }
    public Double[] Sum { get; public set; }
    public int Count { get; public set; }
    public DateTime Start { get; public set; }
    public DateTime End { get; public set; }
    public TimeSeriesEntry[] Entries { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DocumentId();
    [CompilerGeneratedAttribute]
public void set_DocumentId(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Double[] get_Min();
    [CompilerGeneratedAttribute]
public void set_Min(Double[] value);
    [CompilerGeneratedAttribute]
public Double[] get_Max();
    [CompilerGeneratedAttribute]
public void set_Max(Double[] value);
    [CompilerGeneratedAttribute]
public Double[] get_Sum();
    [CompilerGeneratedAttribute]
public void set_Sum(Double[] value);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(int value);
    [CompilerGeneratedAttribute]
public DateTime get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_End();
    [CompilerGeneratedAttribute]
public void set_End(DateTime value);
    [CompilerGeneratedAttribute]
public TimeSeriesEntry[] get_Entries();
    [CompilerGeneratedAttribute]
public void set_Entries(TimeSeriesEntry[] value);
}
public class Raven.Client.Documents.Indexes.TreesReduceDetails : object {
    [CompilerGeneratedAttribute]
private int <NumberOfModifiedLeafs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfModifiedBranches>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfCompressedLeafs>k__BackingField;
    public int NumberOfModifiedLeafs { get; public set; }
    public int NumberOfModifiedBranches { get; public set; }
    public int NumberOfCompressedLeafs { get; public set; }
    [CompilerGeneratedAttribute]
public int get_NumberOfModifiedLeafs();
    [CompilerGeneratedAttribute]
public void set_NumberOfModifiedLeafs(int value);
    [CompilerGeneratedAttribute]
public int get_NumberOfModifiedBranches();
    [CompilerGeneratedAttribute]
public void set_NumberOfModifiedBranches(int value);
    [CompilerGeneratedAttribute]
public int get_NumberOfCompressedLeafs();
    [CompilerGeneratedAttribute]
public void set_NumberOfCompressedLeafs(int value);
}
internal class Raven.Client.Documents.Linq.ExpressionInfo : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNestedPath>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyInfo <MaybeProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Args>k__BackingField;
    public string Path { get; }
    public Type Type { get; }
    public bool IsNestedPath { get; }
    public PropertyInfo MaybeProperty { get; public set; }
    public String[] Args { get; }
    public ExpressionInfo(string path, Type type, bool isNestedPath, String[] args);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public bool get_IsNestedPath();
    [CompilerGeneratedAttribute]
public PropertyInfo get_MaybeProperty();
    [CompilerGeneratedAttribute]
public void set_MaybeProperty(PropertyInfo value);
    [CompilerGeneratedAttribute]
public String[] get_Args();
}
public class Raven.Client.Documents.Linq.FieldToFetch : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    public string Name { get; internal set; }
    public string Alias { get; internal set; }
    public FieldToFetch(string name, string alias);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Alias();
    [CompilerGeneratedAttribute]
internal void set_Alias(string value);
    private bool Equals(FieldToFetch other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public interface Raven.Client.Documents.Linq.IDocumentQueryGenerator {
    public DocumentConventions Conventions { get; }
    public InMemoryDocumentSessionOperations Session { get; }
    public abstract virtual DocumentConventions get_Conventions();
    public abstract virtual InMemoryDocumentSessionOperations get_Session();
    public abstract virtual IDocumentQuery`1<T> Query(string indexName, string collectionName, bool isMapReduce);
    public abstract virtual IAsyncDocumentQuery`1<T> AsyncQuery(string indexName, string collectionName, bool isMapReduce);
    public abstract virtual RavenQueryInspector`1<TS> CreateRavenQueryInspector();
}
[ExtensionAttribute]
public static class Raven.Client.Documents.Linq.Indexing.IndexingLinqExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<TResult> WhereEntityIs(IEnumerable`1<object> queryable, String[] names);
    [ExtensionAttribute]
public static BoostedValue Boost(object item, float value);
    [ExtensionAttribute]
public static TResult IfEntityIs(object queryable, string name);
    [ExtensionAttribute]
public static string ParseInt(object item);
    [ExtensionAttribute]
public static string ParseInt(object item, int defaultValue);
    [ExtensionAttribute]
public static string ParseDouble(object item);
    [ExtensionAttribute]
public static string ParseDouble(object item, double defaultValue);
    [ExtensionAttribute]
public static string ParseDecimal(object item);
    [ExtensionAttribute]
public static string ParseDecimal(object item, decimal defaultValue);
    [ExtensionAttribute]
public static string ParseLong(object item);
    [ExtensionAttribute]
public static string ParseLong(object item, long defaultValue);
}
public interface Raven.Client.Documents.Linq.IRavenQueryable`1 {
    public abstract virtual IRavenQueryable`1<T> Statistics(QueryStatistics& stats);
    public abstract virtual IRavenQueryable`1<T> Customize(Action`1<IDocumentQueryCustomization> action);
    public abstract virtual IRavenQueryable`1<T> Highlight(string fieldName, int fragmentLength, int fragmentCount, Highlightings& highlightings);
    public abstract virtual IRavenQueryable`1<T> Highlight(string fieldName, int fragmentLength, int fragmentCount, HighlightingOptions options, Highlightings& highlightings);
    public abstract virtual IRavenQueryable`1<T> Highlight(Expression`1<Func`2<T, object>> path, int fragmentLength, int fragmentCount, Highlightings& highlightings);
    public abstract virtual IRavenQueryable`1<T> Highlight(Expression`1<Func`2<T, object>> path, int fragmentLength, int fragmentCount, HighlightingOptions options, Highlightings& highlightings);
}
public interface Raven.Client.Documents.Linq.IRavenQueryProvider {
    public string IndexName { get; }
    public IDocumentQueryGenerator QueryGenerator { get; }
    public Action`1<IDocumentQueryCustomization> CustomizeQuery { get; }
    public HashSet`1<FieldToFetch> FieldsToFetch { get; }
    public bool IsProjectInto { get; public set; }
    public Type OriginalQueryType { get; }
    public abstract virtual void AfterQueryExecuted(Action`1<QueryResult> afterQueryExecuted);
    public abstract virtual void Customize(Action`1<IDocumentQueryCustomization> action);
    public abstract virtual string get_IndexName();
    public abstract virtual IDocumentQueryGenerator get_QueryGenerator();
    public abstract virtual Action`1<IDocumentQueryCustomization> get_CustomizeQuery();
    public abstract virtual IRavenQueryProvider For();
    public abstract virtual IAsyncDocumentQuery`1<T> ToAsyncDocumentQuery(Expression expression);
    public abstract virtual IDocumentQuery`1<TResult> ToDocumentQuery(Expression expression);
    public abstract virtual Lazy`1<IEnumerable`1<T>> Lazily(Expression expression, Action`1<IEnumerable`1<T>> onEval);
    public abstract virtual Lazy`1<Task`1<IEnumerable`1<T>>> LazilyAsync(Expression expression, Action`1<IEnumerable`1<T>> onEval);
    public abstract virtual Lazy`1<int> CountLazily(Expression expression);
    public abstract virtual Lazy`1<long> LongCountLazily(Expression expression);
    public abstract virtual Lazy`1<Task`1<int>> CountLazilyAsync(Expression expression, CancellationToken token);
    public abstract virtual Lazy`1<Task`1<long>> LongCountLazilyAsync(Expression expression, CancellationToken token);
    public abstract virtual HashSet`1<FieldToFetch> get_FieldsToFetch();
    public abstract virtual bool get_IsProjectInto();
    public abstract virtual void set_IsProjectInto(bool value);
    public abstract virtual Type get_OriginalQueryType();
}
public class Raven.Client.Documents.Linq.LinqPathProvider : object {
    private DocumentConventions _conventions;
    internal static string CounterMethodName;
    public LinqPathProvider(DocumentConventions conventions);
    public Result GetPath(Expression expression, bool isFilterActive);
    internal static Result CreateCounterResult(MethodCallExpression callExpression);
    private static string HandleMemberExpressionPropertyRenames(MemberExpression memberExpression, string name);
    public static string HandlePropertyRenames(MemberInfo member, string name);
    private static Expression SimplifyExpression(Expression expression);
    public object GetValueFromExpression(Expression expression, Type type);
    public static MemberExpression GetMemberExpression(Expression expression);
    public static bool GetValueFromExpressionWithoutConversion(Expression expression, Object& value);
    private static bool TryGetMethodArguments(MethodCallExpression mce, Object[]& args);
    private static object GetNewExpressionValue(Expression expression);
    private static object GetMemberValue(MemberExpression memberExpression);
    private static void AssertNoComputation(MemberExpression memberExpression);
    internal static string RemoveTransparentIdentifiersIfNeeded(string path);
    public static bool IsCounterCall(MethodCallExpression mce);
    public static bool IsCompareExchangeCall(MethodCallExpression mce);
    public static bool IsTimeSeriesCall(MethodCallExpression mce);
    private static void ThrowInvalidTimeSeriesReturnType(Type type);
    public static bool IsMetadataCall(MethodCallExpression mce);
    [CompilerGeneratedAttribute]
private object <GetValueFromExpression>g__ConvertEnum|9_0(object val, Type enumType);
    [CompilerGeneratedAttribute]
internal static void <AssertNoComputation>g__ThrowArgumentException|15_0(<>c__DisplayClass15_0& );
}
public abstract class Raven.Client.Documents.Linq.QueryMethodConverter : object {
    public abstract virtual bool Convert(Parameters`1<T> parameters);
}
[ExtensionAttribute]
public static class Raven.Client.Documents.Linq.RavenQueryableExtensions : object {
    [ExtensionAttribute]
public static IRavenQueryable`1<T> Where(IRavenQueryable`1<T> source, Expression`1<Func`2<T, bool>> predicate);
    [ExtensionAttribute]
public static IRavenQueryable`1<T> Where(IRavenQueryable`1<T> source, Expression`1<Func`3<T, int, bool>> predicate);
    [ExtensionAttribute]
public static IRavenQueryable`1<T> OrderBy(IRavenQueryable`1<T> source, Expression`1<Func`2<T, TK>> keySelector);
    [ExtensionAttribute]
public static IRavenQueryable`1<T> OrderBy(IRavenQueryable`1<T> source, Expression`1<Func`2<T, TK>> keySelector, IComparer`1<TK> comparer);
    [ExtensionAttribute]
public static IRavenQueryable`1<T> OrderByDescending(IRavenQueryable`1<T> source, Expression`1<Func`2<T, TK>> keySelector);
    [ExtensionAttribute]
public static IRavenQueryable`1<T> OrderByDescending(IRavenQueryable`1<T> source, Expression`1<Func`2<T, TK>> keySelector, IComparer`1<TK> comparer);
    [ExtensionAttribute]
public static IRavenQueryable`1<T> ThenBy(IRavenQueryable`1<T> source, Expression`1<Func`2<T, TK>> keySelector);
    [ExtensionAttribute]
public static IRavenQueryable`1<T> ThenByDescending(IRavenQueryable`1<T> source, Expression`1<Func`2<T, TK>> keySelector);
    [ExtensionAttribute]
public static IRavenQueryable`1<TResult> Select(IRavenQueryable`1<TSource> source, Expression`1<Func`2<TSource, TResult>> selector);
    [ExtensionAttribute]
public static IRavenQueryable`1<TResult> Select(IRavenQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, TResult>> selector);
    [ExtensionAttribute]
public static bool In(T field, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static bool In(T field, T[] values);
    [ExtensionAttribute]
public static IRavenQueryable`1<TSource> Skip(IRavenQueryable`1<TSource> source, int count);
    [ExtensionAttribute]
public static IRavenQueryable`1<TSource> Take(IRavenQueryable`1<TSource> source, int count);
    [ExtensionAttribute]
public static bool ContainsAny(IEnumerable`1<T> list, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static bool ContainsAll(IEnumerable`1<T> list, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static IAsyncEnumerable`1<TSource> AsAsyncEnumerable(IQueryable`1<TSource> source);
}
public class Raven.Client.Documents.Linq.RavenQueryInspector`1 : object {
    private Expression _expression;
    private IRavenQueryProvider _provider;
    private QueryStatistics _queryStats;
    private LinqQueryHighlightings _highlightings;
    private string _indexName;
    private string _collectionName;
    private InMemoryDocumentSessionOperations _session;
    private bool _isMapReduce;
    private DocumentConventions _conventions;
    private bool _isAsync;
    private Expression System.Linq.IQueryable.Expression { get; }
    private Type System.Linq.IQueryable.ElementType { get; }
    private IQueryProvider System.Linq.IQueryable.Provider { get; }
    public string IndexName { get; }
    public InMemoryDocumentSessionOperations Session { get; }
    public void Init(IRavenQueryProvider provider, QueryStatistics queryStats, LinqQueryHighlightings highlightings, string indexName, string collectionName, Expression expression, InMemoryDocumentSessionOperations session, bool isMapReduce);
    private void AfterQueryExecuted(QueryResult queryResult);
    private sealed virtual override Expression System.Linq.IQueryable.get_Expression();
    private sealed virtual override Type System.Linq.IQueryable.get_ElementType();
    private sealed virtual override IQueryProvider System.Linq.IQueryable.get_Provider();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [AsyncIteratorStateMachineAttribute("Raven.Client.Documents.Linq.RavenQueryInspector`1/<GetAsyncEnumerator>d__20")]
public sealed virtual IAsyncEnumerator`1<T> GetAsyncEnumerator(CancellationToken cancellationToken);
    public sealed virtual IRavenQueryable`1<T> Statistics(QueryStatistics& stats);
    public sealed virtual IRavenQueryable`1<T> Customize(Action`1<IDocumentQueryCustomization> action);
    public sealed virtual IRavenQueryable`1<T> Highlight(string fieldName, int fragmentLength, int fragmentCount, Highlightings& highlightings);
    public sealed virtual IRavenQueryable`1<T> Highlight(string fieldName, int fragmentLength, int fragmentCount, HighlightingOptions options, Highlightings& highlightings);
    public sealed virtual IRavenQueryable`1<T> Highlight(Expression`1<Func`2<T, object>> path, int fragmentLength, int fragmentCount, Highlightings& highlightings);
    public sealed virtual IRavenQueryable`1<T> Highlight(Expression`1<Func`2<T, object>> path, int fragmentLength, int fragmentCount, HighlightingOptions options, Highlightings& highlightings);
    public virtual string ToString();
    public sealed virtual IndexQuery GetIndexQuery(bool isAsync);
    internal IDocumentQuery`1<T> GetDocumentQuery(Action`1<IAbstractDocumentQuery`1<T>> customization);
    internal IAsyncDocumentQuery`1<T> GetAsyncDocumentQuery(Action`1<IAbstractDocumentQuery`1<T>> customization);
    private RavenQueryProviderProcessor`1<T> GetRavenQueryProvider();
    public sealed virtual string get_IndexName();
    public sealed virtual InMemoryDocumentSessionOperations get_Session();
    public void FieldsToFetch(IEnumerable`1<string> fields);
    internal void FieldsToFetch(IEnumerable`1<MemberInfo> fields);
}
internal class Raven.Client.Documents.Linq.RavenQueryProvider`1 : object {
    private Action`1<QueryResult> _afterQueryExecuted;
    private Action`1<IDocumentQueryCustomization> _customizeQuery;
    private string _indexName;
    private string _collectionName;
    private IDocumentQueryGenerator _queryGenerator;
    private QueryStatistics _queryStatistics;
    private LinqQueryHighlightings _highlightings;
    private bool _isMapReduce;
    private DocumentConventions _conventions;
    [CompilerGeneratedAttribute]
private HashSet`1<FieldToFetch> <FieldsToFetch>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsProjectInto>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <OriginalQueryType>k__BackingField;
    public string IndexName { get; }
    public string CollectionName { get; }
    public IDocumentQueryGenerator QueryGenerator { get; }
    public Action`1<IDocumentQueryCustomization> CustomizeQuery { get; }
    public HashSet`1<FieldToFetch> FieldsToFetch { get; }
    public bool IsProjectInto { get; public set; }
    public Type OriginalQueryType { get; }
    internal Action`1<QueryResult> AfterQueryExecutedCallback { get; }
    public RavenQueryProvider`1(IDocumentQueryGenerator queryGenerator, string indexName, string collectionName, Type originalQueryType, QueryStatistics queryStatistics, LinqQueryHighlightings highlightings, bool isMapReduce, DocumentConventions conventions, HashSet`1<FieldToFetch> fieldsToFetch, bool isProjectInto);
    public sealed virtual string get_IndexName();
    public string get_CollectionName();
    public sealed virtual IDocumentQueryGenerator get_QueryGenerator();
    public sealed virtual Action`1<IDocumentQueryCustomization> get_CustomizeQuery();
    [CompilerGeneratedAttribute]
public sealed virtual HashSet`1<FieldToFetch> get_FieldsToFetch();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsProjectInto();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsProjectInto(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_OriginalQueryType();
    public sealed virtual IRavenQueryProvider For();
    public object Execute(Expression expression);
    private sealed virtual override IQueryable`1<TS> System.Linq.IQueryProvider.CreateQuery(Expression expression);
    private sealed virtual override IQueryable System.Linq.IQueryProvider.CreateQuery(Expression expression);
    private sealed virtual override TS System.Linq.IQueryProvider.Execute(Expression expression);
    private sealed virtual override object System.Linq.IQueryProvider.Execute(Expression expression);
    public sealed virtual void AfterQueryExecuted(Action`1<QueryResult> afterQueryExecutedCallback);
    internal Action`1<QueryResult> get_AfterQueryExecutedCallback();
    public void InvokeAfterQueryExecuted(QueryResult result);
    public sealed virtual void Customize(Action`1<IDocumentQueryCustomization> action);
    public sealed virtual IAsyncDocumentQuery`1<TResult> ToAsyncDocumentQuery(Expression expression);
    public sealed virtual Lazy`1<IEnumerable`1<TS>> Lazily(Expression expression, Action`1<IEnumerable`1<TS>> onEval);
    public sealed virtual Lazy`1<Task`1<IEnumerable`1<TS>>> LazilyAsync(Expression expression, Action`1<IEnumerable`1<TS>> onEval);
    public sealed virtual Lazy`1<int> CountLazily(Expression expression);
    public sealed virtual Lazy`1<long> LongCountLazily(Expression expression);
    public sealed virtual Lazy`1<Task`1<int>> CountLazilyAsync(Expression expression, CancellationToken token);
    public sealed virtual Lazy`1<Task`1<long>> LongCountLazilyAsync(Expression expression, CancellationToken token);
    private RavenQueryProviderProcessor`1<TS> GetQueryProviderProcessor();
    public sealed virtual IDocumentQuery`1<TResult> ToDocumentQuery(Expression expression);
}
internal class Raven.Client.Documents.Linq.RavenQueryProviderProcessor`1 : object {
    private Action`1<IDocumentQueryCustomization> _customizeQuery;
    private IDocumentQueryGenerator QueryGenerator;
    internal static string WholeDocumentComparisonExceptionMessage;
    internal IAbstractDocumentQuery`1<T> DocumentQuery;
    internal string FromAlias;
    internal LinqPathProvider LinqPathProvider;
    private Action`1<QueryResult> _afterQueryExecuted;
    private LinqQueryHighlightings _highlightings;
    private QueryStatistics _queryStatistics;
    private bool _chainedWhere;
    private int _insideWhereOrSearchCounter;
    private int _insideFilterCounter;
    private bool _insideNegate;
    private bool _insideExact;
    private SpecialQueryType<T> _queryType;
    private Type _newExpressionType;
    private string _currentPath;
    private int _subClauseDepth;
    private Expression _groupByElementSelector;
    private string _jsSelectBody;
    private List`1<string> _jsProjectionNames;
    private StringBuilder _declareBuilder;
    private List`1<DeclareToken> _declareTokens;
    private List`1<LoadToken> _loadTokens;
    private HashSet`1<string> _loadAliases;
    private HashSet`1<Type> _loadTypes;
    private HashSet`1<string> _loadAliasesMovedToOutputFunction;
    private int _insideLet;
    private string _loadAlias;
    private bool _selectLoad;
    private static string DefaultLoadAlias;
    private static string DefaultAliasPrefix;
    private bool _addedDefaultAlias;
    private Type _ofType;
    private bool _isSelectArg;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2<bool, string> _manualLet;
    private TypedParameterSupport _typedParameterSupport;
    private HashSet`1<string> _aliasKeywords;
    private List`1<string> _projectionParameters;
    private int _aliasesCount;
    private string IndexName;
    private string _collectionName;
    [CompilerGeneratedAttribute]
private HashSet`1<FieldToFetch> <FieldsToFetch>k__BackingField;
    private static Regex CastingRemover;
    private static Regex ConvertRemover;
    private static MethodInfo StringCompareStaticMethodInfo;
    private int _insideSelect;
    private bool _isMapReduce;
    private Type _originalQueryType;
    private DocumentConventions _conventions;
    private bool _isProjectInto;
    public string CurrentPath { get; }
    public HashSet`1<FieldToFetch> FieldsToFetch { get; public set; }
    public RavenQueryProviderProcessor`1(IDocumentQueryGenerator queryGenerator, Action`1<IDocumentQueryCustomization> customizeQuery, Action`1<QueryResult> afterQueryExecuted, LinqQueryHighlightings highlightings, string indexName, string collectionName, HashSet`1<FieldToFetch> fieldsToFetch, bool isMapReduce, Type originalType, DocumentConventions conventions, bool isProjectInto, QueryStatistics queryStatistics);
    private static RavenQueryProviderProcessor`1();
    public string get_CurrentPath();
    [CompilerGeneratedAttribute]
public HashSet`1<FieldToFetch> get_FieldsToFetch();
    [CompilerGeneratedAttribute]
public void set_FieldsToFetch(HashSet`1<FieldToFetch> value);
    private void VisitExpression(Expression expression);
    private void VisitBinaryExpression(BinaryExpression expression);
    private void VerifyLegalBinaryExpression(BinaryExpression expression);
    private void VisitAndAlso(BinaryExpression andAlso);
    private bool TryHandleBetween(BinaryExpression andAlso);
    private Tuple`2<ExpressionInfo, object> GetMemberForBetween(BinaryExpression binaryExpression);
    private object GetValueFromExpression(Expression expression, Type type);
    private void VisitOrElse(BinaryExpression orElse);
    private void VisitEquals(BinaryExpression expression);
    private bool IsMemberAccessForQuerySource(Expression node);
    private void VisitNotEquals(BinaryExpression expression);
    private static void EnsureStringComparisonMethodComparedWithZero(BinaryExpression expression, MethodCallExpression mce);
    private static Type GetMemberType(ExpressionInfo info);
    private ExpressionInfo GetMember(Expression expression);
    private ExpressionInfo GetMemberDirect(Expression expression);
    private string GetPropertyName(string selectPath, ExpressionType type);
    private string AddAliasToPathIfNeeded(string alias, string prop);
    private static ParameterExpression GetParameterExpressionIncludingConversions(Expression expression);
    private void VisitEquals(MethodCallExpression expression);
    private static bool ConvertStringComparisonToExact(Expression comparisonArg);
    private static void GetStringComparisonArgumentsFromExpression(MethodCallExpression expression, Expression& firstArg, Expression& secondArg, Expression& comparisonArg);
    private void VisitStringContains(MethodCallExpression _);
    private void VisitStartsWith(MethodCallExpression expression);
    private void VisitEndsWith(MethodCallExpression expression);
    private void VisitIsNullOrEmpty(MethodCallExpression expression, bool notEquals);
    private void VisitGreaterThan(BinaryExpression expression);
    private void VisitGreaterThanOrEqual(BinaryExpression expression);
    private static bool ShouldExcludeNullTypes(Type memberType);
    private void VisitLessThan(BinaryExpression expression);
    private void VisitLessThanOrEqual(BinaryExpression expression);
    private bool IsStringCompareTo(BinaryExpression expression, bool throwOnInvalidExpression);
    private BinaryExpression NormalizeStringCompareExpression(BinaryExpression expression);
    private void VisitAny(MethodCallExpression expression);
    private void VisitContains(MethodCallExpression expression);
    private void VisitMemberAccess(MemberExpression memberExpression, bool boolValue);
    private void VisitMethodCall(MethodCallExpression expression);
    private void VisitRegexMethodCall(MethodCallExpression expression);
    private void VisitLinqExtensionsMethodCall(MethodCallExpression expression);
    private void VisitOrderByDistance(ReadOnlyCollection`1<Expression> arguments, bool descending);
    private void EnsureValidDynamicGroupByMethod(string methodName);
    private void VisitSearch(MethodCallExpression searchExpression);
    private void VisitListMethodCall(MethodCallExpression expression);
    private void VisitEnumerableMethodCall(MethodCallExpression expression);
    private void VisitStringMethodCall(MethodCallExpression expression);
    private void VisitQueryableMethodCall(MethodCallExpression expression);
    private bool IsFilterModeActive();
    private IDisposable FilterModeScope(bool on);
    private IDisposable AnyModeScope();
    private void AddFilterLimit(int filterLimit);
    private void CheckForLetOrLoadFromSelect(MethodCallExpression expression, LambdaExpression lambdaExpression);
    private bool CheckForLoad(MethodCallExpression mce);
    private bool CheckForNestedLoad(LambdaExpression lambdaExpression, MethodCallExpression& mce, String& selectPath);
    private bool HandleLoadFromSelectIfNeeded(LambdaExpression lambdaExpression);
    private static bool ExpressionHasNestedLambda(MethodCallExpression expression, LambdaExpression& lambdaExpression);
    private void VisitGroupBy(Expression expression, GroupByArrayBehavior arrayBehavior);
    private void AddCompositeGroupByKey(NewExpression newExpression, List`1<string> prefix);
    private void AddGroupByAliasIfNeeded(MemberInfo aliasMember, string originalField);
    private void VisitOrderBy(LambdaExpression expression, bool descending);
    private void VisitSelect(Expression operand);
    private void SelectCall(Expression body, LambdaExpression lambdaExpression);
    private void SelectMemberInit(MemberInitExpression memberInitExpression, LambdaExpression lambdaExpression);
    private void SelectNewExpression(NewExpression newExpression, LambdaExpression lambdaExpression);
    private void SelectMemberAccess(Expression body);
    private void AddFromAliasOrRenameArgument(String& arg);
    private void HandleSelectCounter(MethodCallExpression methodCallExpression, LambdaExpression lambdaExpression, MemberInfo member);
    private void AddCallArgumentsToPath(String[] mceArgs, string parameter, String& path, String& alias);
    private void HandleSelectTimeSeries(MethodCallExpression callExpression, string alias);
    private void HandleSelectRaw(MethodCallExpression callExpression, LambdaExpression lambdaExpression);
    private string GetSelectPathOrConstantValue(MemberExpression member);
    private static string GetConstantValueAsString(object value);
    private void AddReturnStatementToOutputFunction(Expression expression);
    private void VisitLet(NewExpression expression);
    private void TranslateLetBody(NewExpression expression);
    private void HandleLoad(Expression expression, LoadSupport loadSupport, string name, string js, StringBuilder wrapper);
    private bool IsDictionaryOnDictionaryExpression(Expression expression);
    private void AddLoadToken(string arg, string alias);
    private void AppendLineToOutputFunction(string name, string js, StringBuilder wrapper);
    private static void AddPropertyToWrapperObject(string name, string js, StringBuilder wrapper);
    internal void AddFromAlias(string alias);
    private void AddAliasToIncludeTokensIfNeeded();
    private string RenameAliasIfNeeded(string alias);
    private static string RenameAliasIfReservedInJs(string alias);
    private string TranslateSelectBodyToJs(Expression expression);
    private void AddJsProjection(string name, Expression expression, StringBuilder sb, bool addComma);
    private static bool IsRawCall(MethodCallExpression mce);
    private string ToJs(Expression expression, bool loadArg, LoadSupport loadSupport);
    private bool IsRawOrTimeSeriesCall(Expression expression, String& script);
    internal string GenerateTimeSeriesScript(MethodCallExpression mce);
    private static bool HasComputation(MemberExpression memberExpression);
    private static bool TryGetMemberExpression(Expression expression, MemberExpression& member);
    private void VisitSelectAfterGroupBy(Expression operand, Expression elementSelectorPath);
    private void HandleOutputFieldOfDynamicMapReduce(LambdaExpression entireExpression, Expression fieldExpression, MemberInfo fieldMember, Expression elementSelectorPath);
    private static string ExtractProjectedName(MemberInfo fieldMember);
    private void AddMapReduceField(MethodCallExpression mapReduceOperationCall, MemberInfo memberInfo, Expression elementSelectorPath);
    private static string GetSelectPath(MemberInfo member);
    private string GetSelectPath(MemberExpression expression);
    private void AddToFieldsToFetch(string field, string alias);
    private void HandleKeywordsIfNeeded(String& field, String& alias);
    private bool NeedToAddFromAliasToField(string field);
    private bool FieldTypeAllowToAddAlias(string field);
    private void AddFromAliasToFieldToFetch(String& field, String& alias, bool quote);
    private void AddDefaultAliasToQuery();
    private void VisitSkip(ConstantExpression constantExpression);
    private void VisitTake(ConstantExpression constantExpression);
    private void VisitAll(Expression`1<Func`2<T, bool>> predicateExpression);
    private void VisitAny();
    private void VisitCount();
    private void VisitLongCount();
    private void VisitSingle();
    private void VisitSingleOrDefault();
    private void VisitFirst();
    private void VisitFirstOrDefault();
    private string GetFieldNameForRangeQuery(ExpressionInfo expression, object value);
    public IDocumentQuery`1<T> GetDocumentQueryFor(Expression expression, Action`1<IAbstractDocumentQuery`1<T>> customization);
    public IAsyncDocumentQuery`1<T> GetAsyncDocumentQueryFor(Expression expression, Action`1<IAbstractDocumentQuery`1<T>> customization);
    public object Execute(Expression expression);
    internal ValueTuple`2<String[], String[]> GetProjections();
    private object ExecuteQuery();
    private object GetQueryResult(IDocumentQuery`1<TProjection> finalQuery);
    private static bool IsCollection(Type type);
    [CompilerGeneratedAttribute]
private bool <IsStringCompareTo>g__CheckValidComparison|81_0(MethodCallExpression methodCall, Expression compareExpression, <>c__DisplayClass81_0& );
    [CompilerGeneratedAttribute]
private void <VisitSearch>g__WhereExistsAndNegatedSearch|92_0(ExpressionInfo expressionInfo, string searchTerms, SearchOperator operator);
    [CompilerGeneratedAttribute]
private bool <VisitSearch>g__IsPreviousSearchOnSameField|92_1(Expression searchTargetExpression, Expression currentSearchExpression);
    [CompilerGeneratedAttribute]
private void <VisitGroupBy>g__AddPart|106_0(<>c__DisplayClass106_0& , <>c__DisplayClass106_1& );
}
[ExtensionAttribute]
public static class Raven.Client.Documents.LinqExtensions : object {
    [ExtensionAttribute]
public static IRavenQueryable`1<TResult> Include(IQueryable`1<TResult> source, Expression`1<Func`2<TResult, object>> path);
    [ExtensionAttribute]
public static IRavenQueryable`1<TResult> Include(IQueryable`1<TResult> source, Expression`1<Func`2<TResult, object>> path);
    [ExtensionAttribute]
public static IRavenQueryable`1<TResult> Include(IQueryable`1<TResult> source, string path);
    [ExtensionAttribute]
public static IRavenQueryable`1<T> Filter(IRavenQueryable`1<T> source, Expression`1<Func`2<T, bool>> predicate, int limit);
    [ExtensionAttribute]
public static IRavenQueryable`1<T> Filter(IQueryable`1<T> source, Expression`1<Func`2<T, bool>> predicate, int limit);
    [ExtensionAttribute]
public static IRavenQueryable`1<TResult> Include(IQueryable`1<TResult> source, Action`1<IQueryIncludeBuilder`1<TResult>> includes);
    [ExtensionAttribute]
private static IRavenQueryable`1<TResult> Include(IQueryable`1<TResult> source, IncludeBuilder includes);
    [ExtensionAttribute]
public static IAggregationQuery`1<T> AggregateBy(IQueryable`1<T> source, FacetBase facet);
    [ExtensionAttribute]
public static IAggregationQuery`1<T> AggregateBy(IQueryable`1<T> source, IEnumerable`1<FacetBase> facets);
    [ExtensionAttribute]
public static IAggregationQuery`1<T> AggregateBy(IQueryable`1<T> source, Action`1<IFacetBuilder`1<T>> builder);
    [ExtensionAttribute]
public static IAggregationQuery`1<T> AggregateUsing(IQueryable`1<T> source, string facetSetupDocumentId);
    [ExtensionAttribute]
public static IQueryable`1<TResult> As(IQueryable queryable);
    [ExtensionAttribute]
public static IRavenQueryable`1<T> Intersect(IQueryable`1<T> self);
    [ExtensionAttribute]
public static IRavenQueryable`1<TResult> ProjectInto(IQueryable queryable);
    [ExtensionAttribute]
public static ISuggestionQuery`1<T> SuggestUsing(IQueryable`1<T> source, SuggestionBase suggestion);
    [ExtensionAttribute]
public static ISuggestionQuery`1<T> SuggestUsing(IQueryable`1<T> source, Action`1<ISuggestionBuilder`1<T>> builder);
    [ExtensionAttribute]
public static Lazy`1<Task`1<IEnumerable`1<T>>> LazilyAsync(IQueryable`1<T> source);
    [ExtensionAttribute]
public static Lazy`1<Task`1<IEnumerable`1<T>>> LazilyAsync(IQueryable`1<T> source, Action`1<IEnumerable`1<T>> onEval);
    [ExtensionAttribute]
public static Lazy`1<IEnumerable`1<T>> Lazily(IQueryable`1<T> source);
    [ExtensionAttribute]
public static Lazy`1<IEnumerable`1<T>> Lazily(IQueryable`1<T> source, Action`1<IEnumerable`1<T>> onEval);
    [ExtensionAttribute]
public static Lazy`1<int> CountLazily(IQueryable`1<T> source);
    [ExtensionAttribute]
public static Lazy`1<long> LongCountLazily(IQueryable`1<T> source);
    [ExtensionAttribute]
public static Lazy`1<Task`1<int>> CountLazilyAsync(IQueryable`1<T> source, CancellationToken token);
    [ExtensionAttribute]
public static Lazy`1<Task`1<long>> LongCountLazilyAsync(IQueryable`1<T> source, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<List`1<T>> ToListAsync(IQueryable`1<T> source, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<T[]> ToArrayAsync(IQueryable`1<T> source, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<bool> AnyAsync(IQueryable`1<TSource> source, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<bool> AnyAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<int> CountAsync(IQueryable`1<TSource> source, CancellationToken token);
    [ExtensionAttribute]
public static long LongCount(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static Task`1<long> LongCountAsync(IQueryable`1<TSource> source, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<int> CountAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<TSource> FirstAsync(IQueryable`1<TSource> source, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<TSource> FirstAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<TSource> FirstOrDefaultAsync(IQueryable`1<TSource> source, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<TSource> FirstOrDefaultAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<TSource> SingleAsync(IQueryable`1<TSource> source, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<TSource> SingleAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<TSource> SingleOrDefaultAsync(IQueryable`1<TSource> source, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<TSource> SingleOrDefaultAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate, CancellationToken token);
    [ExtensionAttribute]
public static IRavenQueryable`1<T> Search(IQueryable`1<T> self, Expression`1<Func`2<T, object>> fieldSelector, string searchTerms, decimal boost, SearchOptions options, SearchOperator operator);
    [ExtensionAttribute]
public static IRavenQueryable`1<T> Search(IQueryable`1<T> self, Expression`1<Func`2<T, object>> fieldSelector, IEnumerable`1<string> searchTerms, decimal boost, SearchOptions options, SearchOperator operator);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByScore(IQueryable`1<T> self);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> ThenByScore(IOrderedQueryable`1<T> self);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByScoreDescending(IQueryable`1<T> self);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> ThenByScoreDescending(IOrderedQueryable`1<T> self);
    [ExtensionAttribute]
public static void ToStream(IQueryable`1<T> self, Stream stream);
    [ExtensionAttribute]
public static void ToStream(IDocumentQuery`1<T> self, Stream stream);
    [AsyncStateMachineAttribute("Raven.Client.Documents.LinqExtensions/<ToStreamAsync>d__48`1")]
[ExtensionAttribute]
public static Task ToStreamAsync(IQueryable`1<T> self, Stream stream, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.LinqExtensions/<ToStreamAsync>d__49`1")]
[ExtensionAttribute]
public static Task ToStreamAsync(IAsyncDocumentQuery`1<T> self, Stream stream, CancellationToken token);
    [ExtensionAttribute]
public static IRavenQueryable`1<IGrouping`2<TKey, TSource>> GroupByArrayValues(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, IEnumerable`1<TKey>>> fieldSelector);
    [ExtensionAttribute]
public static IRavenQueryable`1<IGrouping`2<IEnumerable`1<TKey>, TSource>> GroupByArrayContent(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, IEnumerable`1<TKey>>> fieldSelector);
    [ExtensionAttribute]
public static IRavenQueryable`1<T> Where(IQueryable`1<T> source, Expression`1<Func`3<T, int, bool>> predicate, bool exact);
    [ExtensionAttribute]
public static IRavenQueryable`1<T> Where(IQueryable`1<T> source, Expression`1<Func`2<T, bool>> predicate, bool exact);
    [ExtensionAttribute]
public static IRavenQueryable`1<T> Spatial(IQueryable`1<T> source, Expression`1<Func`2<T, object>> path, Func`2<SpatialCriteriaFactory, SpatialCriteria> clause);
    [ExtensionAttribute]
public static IRavenQueryable`1<T> Spatial(IQueryable`1<T> source, string fieldName, Func`2<SpatialCriteriaFactory, SpatialCriteria> clause);
    [ExtensionAttribute]
public static IRavenQueryable`1<T> Spatial(IQueryable`1<T> source, Func`2<DynamicSpatialFieldFactory`1<T>, DynamicSpatialField> field, Func`2<SpatialCriteriaFactory, SpatialCriteria> clause);
    [ExtensionAttribute]
public static IRavenQueryable`1<T> Spatial(IQueryable`1<T> source, DynamicSpatialField field, Func`2<SpatialCriteriaFactory, SpatialCriteria> clause);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByDistance(IQueryable`1<T> source, Func`2<DynamicSpatialFieldFactory`1<T>, DynamicSpatialField> field, double latitude, double longitude);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByDistance(IQueryable`1<T> source, DynamicSpatialField field, double latitude, double longitude);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByDistance(IQueryable`1<T> source, Expression`1<Func`2<T, object>> path, double latitude, double longitude);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByDistance(IQueryable`1<T> source, Expression`1<Func`2<T, object>> path, double latitude, double longitude, double roundFactor);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByDistance(IQueryable`1<T> source, string fieldName, double latitude, double longitude);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByDistance(IQueryable`1<T> source, string fieldName, double latitude, double longitude, double roundFactor);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByDistance(IQueryable`1<T> source, Func`2<DynamicSpatialFieldFactory`1<T>, DynamicSpatialField> field, string shapeWkt);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByDistance(IQueryable`1<T> source, DynamicSpatialField field, string shapeWkt);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByDistance(IQueryable`1<T> source, Expression`1<Func`2<T, object>> path, string shapeWkt);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByDistance(IQueryable`1<T> source, string fieldName, string shapeWkt);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByDistanceDescending(IQueryable`1<T> source, Func`2<DynamicSpatialFieldFactory`1<T>, DynamicSpatialField> field, double latitude, double longitude);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByDistanceDescending(IQueryable`1<T> source, DynamicSpatialField field, double latitude, double longitude);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByDistanceDescending(IQueryable`1<T> source, Expression`1<Func`2<T, object>> path, double latitude, double longitude);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByDistanceDescending(IQueryable`1<T> source, Expression`1<Func`2<T, object>> path, double latitude, double longitude, double roundFactor);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByDistanceDescending(IQueryable`1<T> source, string fieldName, double latitude, double longitude);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByDistanceDescending(IQueryable`1<T> source, string fieldName, double latitude, double longitude, double roundFactor);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByDistanceDescending(IQueryable`1<T> source, Func`2<DynamicSpatialFieldFactory`1<T>, DynamicSpatialField> field, string shapeWkt);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByDistanceDescending(IQueryable`1<T> source, DynamicSpatialField field, string shapeWkt);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByDistanceDescending(IQueryable`1<T> source, Expression`1<Func`2<T, object>> path, string shapeWkt);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByDistanceDescending(IQueryable`1<T> source, Expression`1<Func`2<T, object>> path, string shapeWkt, double roundFactor);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByDistanceDescending(IQueryable`1<T> source, string fieldName, string shapeWkt);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByDistanceDescending(IQueryable`1<T> source, string fieldName, string shapeWkt, double roundFactor);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderBy(IQueryable`1<T> source, Expression`1<Func`2<T, object>> path, string sorterName);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderBy(IQueryable`1<T> source, string path, string sorterName);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderBy(IQueryable`1<T> source, Expression`1<Func`2<T, object>> path, OrderingType ordering);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderBy(IQueryable`1<T> source, string path, OrderingType ordering);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByDescending(IQueryable`1<T> source, Expression`1<Func`2<T, object>> path, string sorterName);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByDescending(IQueryable`1<T> source, string path, string sorterName);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByDescending(IQueryable`1<T> source, Expression`1<Func`2<T, object>> path, OrderingType ordering);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByDescending(IQueryable`1<T> source, string path, OrderingType ordering);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> ThenBy(IOrderedQueryable`1<T> source, Expression`1<Func`2<T, object>> path, string sorterName);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> ThenBy(IOrderedQueryable`1<T> source, string path, string sorterName);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> ThenBy(IOrderedQueryable`1<T> source, Expression`1<Func`2<T, object>> path, OrderingType ordering);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> ThenBy(IOrderedQueryable`1<T> source, string path, OrderingType ordering);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> ThenByDescending(IOrderedQueryable`1<T> source, Expression`1<Func`2<T, object>> path, string sorterName);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> ThenByDescending(IOrderedQueryable`1<T> source, string path, string sorterName);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> ThenByDescending(IOrderedQueryable`1<T> source, Expression`1<Func`2<T, object>> path, OrderingType ordering);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> ThenByDescending(IOrderedQueryable`1<T> source, string path, OrderingType ordering);
    [ExtensionAttribute]
public static IRavenQueryable`1<T> MoreLikeThis(IQueryable`1<T> source, MoreLikeThisBase moreLikeThis);
    [ExtensionAttribute]
public static IRavenQueryable`1<T> MoreLikeThis(IQueryable`1<T> source, Action`1<IMoreLikeThisBuilder`1<T>> builder);
    [ExtensionAttribute]
public static IDocumentQuery`1<T> ToDocumentQuery(IQueryable`1<T> source);
    [ExtensionAttribute]
public static IAsyncDocumentQuery`1<T> ToAsyncDocumentQuery(IQueryable`1<T> source);
    [ExtensionAttribute]
public static IRavenQueryable`1<T> Skip(IQueryable`1<T> source, long count);
    private static Expression ConvertExpressionIfNecessary(IQueryable`1<T> source);
    private static MethodInfo ConvertMethodIfNecessary(MethodInfo method, Type typeArgument);
    private static MethodInfo ConvertMethodIfNecessary(MethodInfo method, Type[] typeArguments);
}
public abstract class Raven.Client.Documents.Operations.AbstractDatabaseStatistics`1 : object {
    [CompilerGeneratedAttribute]
private int <CountOfIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountOfDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountOfRevisionDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountOfDocumentsConflicts>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountOfTombstones>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountOfConflicts>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountOfAttachments>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountOfCounterEntries>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountOfTimeSeriesSegments>k__BackingField;
    [CompilerGeneratedAttribute]
private TIndexInformation[] <Indexes>k__BackingField;
    public int CountOfIndexes { get; public set; }
    public long CountOfDocuments { get; public set; }
    public long CountOfRevisionDocuments { get; public set; }
    public long CountOfDocumentsConflicts { get; public set; }
    public long CountOfTombstones { get; public set; }
    public long CountOfConflicts { get; public set; }
    public long CountOfAttachments { get; public set; }
    public long CountOfCounterEntries { get; public set; }
    public long CountOfTimeSeriesSegments { get; public set; }
    public TIndexInformation[] Indexes { get; public set; }
    [CompilerGeneratedAttribute]
public int get_CountOfIndexes();
    [CompilerGeneratedAttribute]
public void set_CountOfIndexes(int value);
    [CompilerGeneratedAttribute]
public long get_CountOfDocuments();
    [CompilerGeneratedAttribute]
public void set_CountOfDocuments(long value);
    [CompilerGeneratedAttribute]
public long get_CountOfRevisionDocuments();
    [CompilerGeneratedAttribute]
public void set_CountOfRevisionDocuments(long value);
    [CompilerGeneratedAttribute]
public long get_CountOfDocumentsConflicts();
    [CompilerGeneratedAttribute]
public void set_CountOfDocumentsConflicts(long value);
    [CompilerGeneratedAttribute]
public long get_CountOfTombstones();
    [CompilerGeneratedAttribute]
public void set_CountOfTombstones(long value);
    [CompilerGeneratedAttribute]
public long get_CountOfConflicts();
    [CompilerGeneratedAttribute]
public void set_CountOfConflicts(long value);
    [CompilerGeneratedAttribute]
public long get_CountOfAttachments();
    [CompilerGeneratedAttribute]
public void set_CountOfAttachments(long value);
    [CompilerGeneratedAttribute]
public long get_CountOfCounterEntries();
    [CompilerGeneratedAttribute]
public void set_CountOfCounterEntries(long value);
    [CompilerGeneratedAttribute]
public long get_CountOfTimeSeriesSegments();
    [CompilerGeneratedAttribute]
public void set_CountOfTimeSeriesSegments(long value);
    [CompilerGeneratedAttribute]
public TIndexInformation[] get_Indexes();
    [CompilerGeneratedAttribute]
public void set_Indexes(TIndexInformation[] value);
}
public class Raven.Client.Documents.Operations.Analyzers.DeleteAnalyzerOperation : object {
    private string _analyzerName;
    public DeleteAnalyzerOperation(string analyzerName);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Analyzers.PutAnalyzersOperation : object {
    private AnalyzerDefinition[] _analyzersToAdd;
    public PutAnalyzersOperation(AnalyzerDefinition[] analyzersToAdd);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Attachments.AttachmentDetails : AttachmentName {
    public string ChangeVector;
    public string DocumentId;
}
public class Raven.Client.Documents.Operations.Attachments.AttachmentEnumeratorResult : object {
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private AttachmentDetails <Details>k__BackingField;
    public Stream Stream { get; }
    public AttachmentDetails Details { get; }
    public AttachmentEnumeratorResult(AttachmentDetails details, Stream stream);
    [CompilerGeneratedAttribute]
public Stream get_Stream();
    [CompilerGeneratedAttribute]
public AttachmentDetails get_Details();
}
public class Raven.Client.Documents.Operations.Attachments.AttachmentName : object {
    public string Name;
    public string Hash;
    public string ContentType;
    public long Size;
    internal virtual DynamicJsonValue ToJson();
}
internal class Raven.Client.Documents.Operations.Attachments.AttachmentNameWithCount : AttachmentName {
    [CompilerGeneratedAttribute]
private long <Count>k__BackingField;
    public long Count { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(long value);
    internal virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.Attachments.AttachmentRequest : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DocumentId>k__BackingField;
    public string Name { get; }
    public string DocumentId { get; }
    public AttachmentRequest(string documentId, string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_DocumentId();
}
public class Raven.Client.Documents.Operations.Attachments.AttachmentResult : object {
    public Stream Stream;
    public AttachmentDetails Details;
    public sealed virtual void Dispose();
}
public class Raven.Client.Documents.Operations.Attachments.AttachmentStream : Stream {
    private HttpResponseMessage _response;
    private Stream _stream;
    [CompilerGeneratedAttribute]
private bool <CanRead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanWrite>k__BackingField;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public AttachmentStream(HttpResponseMessage response, Stream stream);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    private void ThrowNotWritableStream();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
public class Raven.Client.Documents.Operations.Attachments.DeleteAttachmentOperation : object {
    private string _documentId;
    private string _name;
    private string _changeVector;
    public DeleteAttachmentOperation(string documentId, string name, string changeVector);
    public sealed virtual RavenCommand GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
}
public class Raven.Client.Documents.Operations.Attachments.GetAttachmentOperation : object {
    private string _documentId;
    private string _name;
    private AttachmentType _type;
    private string _changeVector;
    public GetAttachmentOperation(string documentId, string name, AttachmentType type, string changeVector);
    public sealed virtual RavenCommand`1<AttachmentResult> GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
}
public class Raven.Client.Documents.Operations.Attachments.GetAttachmentsOperation : object {
    private AttachmentType _type;
    private IEnumerable`1<AttachmentRequest> _attachments;
    public GetAttachmentsOperation(IEnumerable`1<AttachmentRequest> attachments, AttachmentType type);
    public sealed virtual RavenCommand`1<IEnumerator`1<AttachmentEnumeratorResult>> GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
}
internal class Raven.Client.Documents.Operations.Attachments.LimitedStream : Stream {
    [CompilerGeneratedAttribute]
private long <OverallRead>k__BackingField;
    private long _length;
    private long _currentPos;
    private Stream _inner;
    private long _read;
    private bool _disposed;
    internal IDisposable _disposable;
    public long OverallRead { get; private set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public LimitedStream(Stream inner, long length, long currentPos, long overallRead);
    [CompilerGeneratedAttribute]
public long get_OverallRead();
    [CompilerGeneratedAttribute]
private void set_OverallRead(long value);
    public virtual void Flush();
    public virtual long Seek(long position, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Operations.Attachments.LimitedStream/<ReadAsync>d__15")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
    private void ReadToEnd();
    [AsyncStateMachineAttribute("Raven.Client.Documents.Operations.Attachments.LimitedStream/<ReadToEndAsync>d__19")]
private Task ReadToEndAsync(CancellationToken ct);
    private static void ThrowDisposedException();
    private void ThrowEndOfStreamException(Nullable`1<int> count, Nullable`1<CancellationToken> cancellationToken);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
public class Raven.Client.Documents.Operations.Attachments.PutAttachmentOperation : object {
    private string _documentId;
    private string _name;
    private Stream _stream;
    private string _contentType;
    private string _changeVector;
    public PutAttachmentOperation(string documentId, string name, Stream stream, string contentType, string changeVector);
    public sealed virtual RavenCommand`1<AttachmentDetails> GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
}
public abstract class Raven.Client.Documents.Operations.Backups.AbstractGetPeriodicBackupStatusOperationResult : object {
    [ForceJsonSerializationAttribute]
internal bool IsSharded;
}
public abstract class Raven.Client.Documents.Operations.Backups.AmazonSettings : BackupSettings {
    [CompilerGeneratedAttribute]
private string <AwsAccessKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AwsSecretKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AwsSessionToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AwsRegionName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RemoteFolderName>k__BackingField;
    public string AwsAccessKey { get; public set; }
    public string AwsSecretKey { get; public set; }
    public string AwsSessionToken { get; public set; }
    public string AwsRegionName { get; public set; }
    public string RemoteFolderName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_AwsAccessKey();
    [CompilerGeneratedAttribute]
public void set_AwsAccessKey(string value);
    [CompilerGeneratedAttribute]
public string get_AwsSecretKey();
    [CompilerGeneratedAttribute]
public void set_AwsSecretKey(string value);
    [CompilerGeneratedAttribute]
public string get_AwsSessionToken();
    [CompilerGeneratedAttribute]
public void set_AwsSessionToken(string value);
    [CompilerGeneratedAttribute]
public string get_AwsRegionName();
    [CompilerGeneratedAttribute]
public void set_AwsRegionName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RemoteFolderName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RemoteFolderName(string value);
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToAuditJson();
}
public class Raven.Client.Documents.Operations.Backups.AzureSettings : BackupSettings {
    [CompilerGeneratedAttribute]
private string <StorageContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RemoteFolderName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccountName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccountKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SasToken>k__BackingField;
    public string StorageContainer { get; public set; }
    public string RemoteFolderName { get; public set; }
    public string AccountName { get; public set; }
    public string AccountKey { get; public set; }
    public string SasToken { get; public set; }
    internal AzureSettings(AzureSettings settings);
    [CompilerGeneratedAttribute]
public string get_StorageContainer();
    [CompilerGeneratedAttribute]
public void set_StorageContainer(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RemoteFolderName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RemoteFolderName(string value);
    [CompilerGeneratedAttribute]
public string get_AccountName();
    [CompilerGeneratedAttribute]
public void set_AccountName(string value);
    [CompilerGeneratedAttribute]
public string get_AccountKey();
    [CompilerGeneratedAttribute]
public void set_AccountKey(string value);
    [CompilerGeneratedAttribute]
public string get_SasToken();
    [CompilerGeneratedAttribute]
public void set_SasToken(string value);
    public virtual bool HasSettings();
    public bool Equals(AzureSettings other);
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToAuditJson();
}
public class Raven.Client.Documents.Operations.Backups.BackupConfiguration : object {
    [CompilerGeneratedAttribute]
private BackupType <BackupType>k__BackingField;
    [CompilerGeneratedAttribute]
private BackupUploadMode <BackupUploadMode>k__BackingField;
    [CompilerGeneratedAttribute]
private SnapshotSettings <SnapshotSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private BackupEncryptionSettings <BackupEncryptionSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalSettings <LocalSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private S3Settings <S3Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private GlacierSettings <GlacierSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private AzureSettings <AzureSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private FtpSettings <FtpSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private GoogleCloudSettings <GoogleCloudSettings>k__BackingField;
    public BackupType BackupType { get; public set; }
    public BackupUploadMode BackupUploadMode { get; public set; }
    public SnapshotSettings SnapshotSettings { get; public set; }
    public BackupEncryptionSettings BackupEncryptionSettings { get; public set; }
    public LocalSettings LocalSettings { get; public set; }
    public S3Settings S3Settings { get; public set; }
    public GlacierSettings GlacierSettings { get; public set; }
    public AzureSettings AzureSettings { get; public set; }
    public FtpSettings FtpSettings { get; public set; }
    public GoogleCloudSettings GoogleCloudSettings { get; public set; }
    [CompilerGeneratedAttribute]
public BackupType get_BackupType();
    [CompilerGeneratedAttribute]
public void set_BackupType(BackupType value);
    [CompilerGeneratedAttribute]
public BackupUploadMode get_BackupUploadMode();
    [CompilerGeneratedAttribute]
public void set_BackupUploadMode(BackupUploadMode value);
    [CompilerGeneratedAttribute]
public SnapshotSettings get_SnapshotSettings();
    [CompilerGeneratedAttribute]
public void set_SnapshotSettings(SnapshotSettings value);
    [CompilerGeneratedAttribute]
public BackupEncryptionSettings get_BackupEncryptionSettings();
    [CompilerGeneratedAttribute]
public void set_BackupEncryptionSettings(BackupEncryptionSettings value);
    [CompilerGeneratedAttribute]
public LocalSettings get_LocalSettings();
    [CompilerGeneratedAttribute]
public void set_LocalSettings(LocalSettings value);
    [CompilerGeneratedAttribute]
public S3Settings get_S3Settings();
    [CompilerGeneratedAttribute]
public void set_S3Settings(S3Settings value);
    [CompilerGeneratedAttribute]
public GlacierSettings get_GlacierSettings();
    [CompilerGeneratedAttribute]
public void set_GlacierSettings(GlacierSettings value);
    [CompilerGeneratedAttribute]
public AzureSettings get_AzureSettings();
    [CompilerGeneratedAttribute]
public void set_AzureSettings(AzureSettings value);
    [CompilerGeneratedAttribute]
public FtpSettings get_FtpSettings();
    [CompilerGeneratedAttribute]
public void set_FtpSettings(FtpSettings value);
    [CompilerGeneratedAttribute]
public GoogleCloudSettings get_GoogleCloudSettings();
    [CompilerGeneratedAttribute]
public void set_GoogleCloudSettings(GoogleCloudSettings value);
    internal bool HasBackup();
    internal bool HasCloudBackup();
    internal static bool CanBackupUsing(BackupSettings settings);
    internal List`1<string> GetFullBackupDestinations();
    internal List`1<string> GetDestinations();
    private List`1<BackupDestination> GetBackupDestinations();
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToAuditJson();
    public virtual bool ValidateDestinations(String& message);
    [CompilerGeneratedAttribute]
internal static void <GetBackupDestinations>g__AddBackupDestination|45_0(BackupSettings backupSettings, BackupDestination backupDestination, <>c__DisplayClass45_0& );
}
public class Raven.Client.Documents.Operations.Backups.BackupEncryptionSettings : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private EncryptionMode <EncryptionMode>k__BackingField;
    public string Key { get; public set; }
    public EncryptionMode EncryptionMode { get; public set; }
    internal BackupEncryptionSettings(BackupEncryptionSettings other);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public EncryptionMode get_EncryptionMode();
    [CompilerGeneratedAttribute]
public void set_EncryptionMode(EncryptionMode value);
    public DynamicJsonValue ToJson();
    public DynamicJsonValue ToAuditJson();
}
public class Raven.Client.Documents.Operations.Backups.BackupOperation : object {
    private BackupConfiguration _backupConfiguration;
    public BackupOperation(BackupConfiguration backupConfiguration);
    public sealed virtual RavenCommand`1<OperationIdResult`1<StartBackupOperationResult>> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.Documents.Operations.Backups.BackupProgress : SmugglerProgress {
    public Counts SnapshotBackup { get; }
    public UploadToS3 S3Backup { get; }
    public UploadToAzure AzureBackup { get; }
    public UploadToGoogleCloud GoogleCloudBackup { get; }
    public UploadToGlacier GlacierBackup { get; }
    public UploadToFtp FtpBackup { get; }
    public BackupProgress(BackupResult result);
    public Counts get_SnapshotBackup();
    public UploadToS3 get_S3Backup();
    public UploadToAzure get_AzureBackup();
    public UploadToGoogleCloud get_GoogleCloudBackup();
    public UploadToGlacier get_GlacierBackup();
    public UploadToFtp get_FtpBackup();
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.Backups.BackupResult : SmugglerResult {
    [CompilerGeneratedAttribute]
private Counts <SnapshotBackup>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadToS3 <S3Backup>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadToAzure <AzureBackup>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadToGoogleCloud <GoogleCloudBackup>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadToGlacier <GlacierBackup>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadToFtp <FtpBackup>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalBackup <LocalBackup>k__BackingField;
    public Counts SnapshotBackup { get; public set; }
    public UploadToS3 S3Backup { get; public set; }
    public UploadToAzure AzureBackup { get; public set; }
    public UploadToGoogleCloud GoogleCloudBackup { get; public set; }
    public UploadToGlacier GlacierBackup { get; public set; }
    public UploadToFtp FtpBackup { get; public set; }
    public LocalBackup LocalBackup { get; public set; }
    [CompilerGeneratedAttribute]
public Counts get_SnapshotBackup();
    [CompilerGeneratedAttribute]
public void set_SnapshotBackup(Counts value);
    [CompilerGeneratedAttribute]
public UploadToS3 get_S3Backup();
    [CompilerGeneratedAttribute]
public void set_S3Backup(UploadToS3 value);
    [CompilerGeneratedAttribute]
public UploadToAzure get_AzureBackup();
    [CompilerGeneratedAttribute]
public void set_AzureBackup(UploadToAzure value);
    [CompilerGeneratedAttribute]
public UploadToGoogleCloud get_GoogleCloudBackup();
    [CompilerGeneratedAttribute]
public void set_GoogleCloudBackup(UploadToGoogleCloud value);
    [CompilerGeneratedAttribute]
public UploadToGlacier get_GlacierBackup();
    [CompilerGeneratedAttribute]
public void set_GlacierBackup(UploadToGlacier value);
    [CompilerGeneratedAttribute]
public UploadToFtp get_FtpBackup();
    [CompilerGeneratedAttribute]
public void set_FtpBackup(UploadToFtp value);
    [CompilerGeneratedAttribute]
public LocalBackup get_LocalBackup();
    [CompilerGeneratedAttribute]
public void set_LocalBackup(LocalBackup value);
    public virtual DynamicJsonValue ToJson();
}
public abstract class Raven.Client.Documents.Operations.Backups.BackupSettings : object {
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private GetBackupConfigurationScript <GetBackupConfigurationScript>k__BackingField;
    public bool Disabled { get; public set; }
    public GetBackupConfigurationScript GetBackupConfigurationScript { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    [CompilerGeneratedAttribute]
public GetBackupConfigurationScript get_GetBackupConfigurationScript();
    [CompilerGeneratedAttribute]
public void set_GetBackupConfigurationScript(GetBackupConfigurationScript value);
    public virtual bool HasSettings();
    public virtual bool WasEnabled(BackupSettings other);
    public virtual DynamicJsonValue ToAuditJson();
    public virtual DynamicJsonValue ToJson();
}
public abstract class Raven.Client.Documents.Operations.Backups.BackupStatus : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastFullBackup>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastIncrementalBackup>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <FullBackupDurationInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <IncrementalBackupDurationInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exception>k__BackingField;
    public Nullable`1<DateTime> LastFullBackup { get; public set; }
    public Nullable`1<DateTime> LastIncrementalBackup { get; public set; }
    public Nullable`1<long> FullBackupDurationInMs { get; public set; }
    public Nullable`1<long> IncrementalBackupDurationInMs { get; public set; }
    public string Exception { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastFullBackup();
    [CompilerGeneratedAttribute]
public void set_LastFullBackup(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastIncrementalBackup();
    [CompilerGeneratedAttribute]
public void set_LastIncrementalBackup(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_FullBackupDurationInMs();
    [CompilerGeneratedAttribute]
public void set_FullBackupDurationInMs(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_IncrementalBackupDurationInMs();
    [CompilerGeneratedAttribute]
public void set_IncrementalBackupDurationInMs(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public string get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(string value);
    public IDisposable UpdateStats(bool isFullBackup);
    public virtual DynamicJsonValue ToJson();
}
public enum Raven.Client.Documents.Operations.Backups.BackupTaskType : Enum {
    public int value__;
    public static BackupTaskType Periodic;
    public static BackupTaskType OneTime;
}
public enum Raven.Client.Documents.Operations.Backups.BackupType : Enum {
    public int value__;
    public static BackupType Backup;
    public static BackupType Snapshot;
}
public enum Raven.Client.Documents.Operations.Backups.BackupUploadMode : Enum {
    public int value__;
    public static BackupUploadMode Default;
    public static BackupUploadMode DirectUpload;
}
public abstract class Raven.Client.Documents.Operations.Backups.CloudUploadStatus : BackupStatus {
    [CompilerGeneratedAttribute]
private bool <Skipped>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadProgress <UploadProgress>k__BackingField;
    public bool Skipped { get; public set; }
    public UploadProgress UploadProgress { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Skipped();
    [CompilerGeneratedAttribute]
public void set_Skipped(bool value);
    [CompilerGeneratedAttribute]
public UploadProgress get_UploadProgress();
    [CompilerGeneratedAttribute]
public void set_UploadProgress(UploadProgress value);
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.Backups.DelayBackupOperation : object {
    private long _runningBackupTaskId;
    private TimeSpan _duration;
    public DelayBackupOperation(long runningBackupTaskId, TimeSpan duration);
    public sealed virtual RavenCommand`1<OperationState> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public enum Raven.Client.Documents.Operations.Backups.EncryptionMode : Enum {
    public int value__;
    public static EncryptionMode None;
    public static EncryptionMode UseDatabaseKey;
    public static EncryptionMode UseProvidedKey;
}
public class Raven.Client.Documents.Operations.Backups.Error : object {
    [CompilerGeneratedAttribute]
private string <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <At>k__BackingField;
    public string Exception { get; public set; }
    public DateTime At { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(string value);
    [CompilerGeneratedAttribute]
public DateTime get_At();
    [CompilerGeneratedAttribute]
public void set_At(DateTime value);
    public DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.Backups.FtpSettings : BackupSettings {
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificateAsBase64>k__BackingField;
    public string Url { get; public set; }
    public string UserName { get; public set; }
    public string Password { get; public set; }
    public string CertificateAsBase64 { get; public set; }
    internal FtpSettings(FtpSettings settings);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public string get_UserName();
    [CompilerGeneratedAttribute]
public void set_UserName(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public string get_CertificateAsBase64();
    [CompilerGeneratedAttribute]
public void set_CertificateAsBase64(string value);
    public virtual bool HasSettings();
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToAuditJson();
}
public class Raven.Client.Documents.Operations.Backups.GetBackupConfigurationScript : object {
    [CompilerGeneratedAttribute]
private string <Exec>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TimeoutInMs>k__BackingField;
    [SecurityClearanceAttribute("3")]
public string Exec { get; public set; }
    [SecurityClearanceAttribute("3")]
public string Arguments { get; public set; }
    public int TimeoutInMs { get; public set; }
    internal GetBackupConfigurationScript(GetBackupConfigurationScript script);
    [CompilerGeneratedAttribute]
public string get_Exec();
    [CompilerGeneratedAttribute]
public void set_Exec(string value);
    [CompilerGeneratedAttribute]
public string get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(string value);
    [CompilerGeneratedAttribute]
public int get_TimeoutInMs();
    [CompilerGeneratedAttribute]
public void set_TimeoutInMs(int value);
    public DynamicJsonValue ToAuditJson();
    public DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.Backups.GetPeriodicBackupStatusOperation : object {
    private long _taskId;
    public GetPeriodicBackupStatusOperation(long taskId);
    public sealed virtual RavenCommand`1<GetPeriodicBackupStatusOperationResult> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.Documents.Operations.Backups.GetPeriodicBackupStatusOperationResult : AbstractGetPeriodicBackupStatusOperationResult {
    public PeriodicBackupStatus Status;
}
public class Raven.Client.Documents.Operations.Backups.GlacierSettings : AmazonSettings {
    [CompilerGeneratedAttribute]
private string <VaultName>k__BackingField;
    public string VaultName { get; public set; }
    internal GlacierSettings(GlacierSettings settings);
    [CompilerGeneratedAttribute]
public string get_VaultName();
    [CompilerGeneratedAttribute]
public void set_VaultName(string value);
    public virtual bool HasSettings();
    public bool Equals(GlacierSettings other);
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToAuditJson();
}
public class Raven.Client.Documents.Operations.Backups.GoogleCloudSettings : BackupSettings {
    [CompilerGeneratedAttribute]
private string <BucketName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RemoteFolderName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GoogleCredentialsJson>k__BackingField;
    public string BucketName { get; public set; }
    public string RemoteFolderName { get; public set; }
    public string GoogleCredentialsJson { get; public set; }
    internal GoogleCloudSettings(GoogleCloudSettings settings);
    [CompilerGeneratedAttribute]
public string get_BucketName();
    [CompilerGeneratedAttribute]
public void set_BucketName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RemoteFolderName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RemoteFolderName(string value);
    [CompilerGeneratedAttribute]
public string get_GoogleCredentialsJson();
    [CompilerGeneratedAttribute]
public void set_GoogleCredentialsJson(string value);
    public virtual bool HasSettings();
    public bool Equals(GoogleCloudSettings other);
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToAuditJson();
}
public interface Raven.Client.Documents.Operations.Backups.ICloudBackupSettings {
    public string RemoteFolderName { get; public set; }
    public abstract virtual string get_RemoteFolderName();
    public abstract virtual void set_RemoteFolderName(string value);
}
public class Raven.Client.Documents.Operations.Backups.LastRaftIndex : object {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <LastEtag>k__BackingField;
    public Nullable`1<long> LastEtag { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_LastEtag();
    [CompilerGeneratedAttribute]
public void set_LastEtag(Nullable`1<long> value);
    public DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.Backups.LocalBackup : BackupStatus {
    [CompilerGeneratedAttribute]
private string <BackupDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TempFolderUsed>k__BackingField;
    public string BackupDirectory { get; public set; }
    public string FileName { get; public set; }
    public bool TempFolderUsed { get; public set; }
    [CompilerGeneratedAttribute]
public string get_BackupDirectory();
    [CompilerGeneratedAttribute]
public void set_BackupDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
    [CompilerGeneratedAttribute]
public bool get_TempFolderUsed();
    [CompilerGeneratedAttribute]
public void set_TempFolderUsed(bool value);
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.Backups.LocalSettings : BackupSettings {
    [CompilerGeneratedAttribute]
private string <FolderPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ShardNumber>k__BackingField;
    public string FolderPath { get; public set; }
    public Nullable`1<int> ShardNumber { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FolderPath();
    [CompilerGeneratedAttribute]
public void set_FolderPath(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ShardNumber();
    [CompilerGeneratedAttribute]
public void set_ShardNumber(Nullable`1<int> value);
    public virtual bool HasSettings();
    public bool Equals(LocalSettings other);
    public virtual DynamicJsonValue ToAuditJson();
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.Backups.PeriodicBackupConfiguration : BackupConfiguration {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TaskId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MentorNode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PinToMentorNode>k__BackingField;
    [CompilerGeneratedAttribute]
private RetentionPolicy <RetentionPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <CreatedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullBackupFrequency>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IncrementalBackupFrequency>k__BackingField;
    public string Name { get; public set; }
    public long TaskId { get; public set; }
    public bool Disabled { get; public set; }
    public string MentorNode { get; public set; }
    public bool PinToMentorNode { get; public set; }
    public RetentionPolicy RetentionPolicy { get; public set; }
    public Nullable`1<DateTime> CreatedAt { get; public set; }
    public string FullBackupFrequency { get; public set; }
    public string IncrementalBackupFrequency { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public long get_TaskId();
    [CompilerGeneratedAttribute]
public void set_TaskId(long value);
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    [CompilerGeneratedAttribute]
public string get_MentorNode();
    [CompilerGeneratedAttribute]
public void set_MentorNode(string value);
    [CompilerGeneratedAttribute]
public bool get_PinToMentorNode();
    [CompilerGeneratedAttribute]
public void set_PinToMentorNode(bool value);
    [CompilerGeneratedAttribute]
public RetentionPolicy get_RetentionPolicy();
    [CompilerGeneratedAttribute]
public void set_RetentionPolicy(RetentionPolicy value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_CreatedAt();
    [CompilerGeneratedAttribute]
public void set_CreatedAt(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public string get_FullBackupFrequency();
    [CompilerGeneratedAttribute]
public void set_FullBackupFrequency(string value);
    [CompilerGeneratedAttribute]
public string get_IncrementalBackupFrequency();
    [CompilerGeneratedAttribute]
public void set_IncrementalBackupFrequency(string value);
    public sealed virtual ulong GetTaskKey();
    public sealed virtual string GetMentorNode();
    public sealed virtual string GetDefaultTaskName();
    public sealed virtual string GetTaskName();
    public sealed virtual bool IsResourceIntensive();
    public sealed virtual bool IsPinnedToMentorNode();
    public bool HasBackupFrequencyChanged(PeriodicBackupConfiguration other);
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToAuditJson();
    public virtual bool ValidateDestinations(String& message);
}
public class Raven.Client.Documents.Operations.Backups.PeriodicBackupStatus : object {
    [CompilerGeneratedAttribute]
private long <TaskId>k__BackingField;
    [CompilerGeneratedAttribute]
private BackupType <BackupType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFull>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <DelayUntil>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <OriginalBackupTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastFullBackup>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastIncrementalBackup>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastFullBackupInternal>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastIncrementalBackupInternal>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalBackup <LocalBackup>k__BackingField;
    public UploadToS3 UploadToS3;
    public UploadToGlacier UploadToGlacier;
    public UploadToAzure UploadToAzure;
    public UploadToGoogleCloud UploadToGoogleCloud;
    public UploadToFtp UploadToFtp;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <LastEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastDatabaseChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private LastRaftIndex <LastRaftIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FolderName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <DurationInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <LocalRetentionDurationInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <LastOperationId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEncrypted>k__BackingField;
    public long TaskId { get; public set; }
    public BackupType BackupType { get; public set; }
    public bool IsFull { get; public set; }
    public string NodeTag { get; public set; }
    public Nullable`1<DateTime> DelayUntil { get; public set; }
    public Nullable`1<DateTime> OriginalBackupTime { get; public set; }
    public Nullable`1<DateTime> LastFullBackup { get; public set; }
    public Nullable`1<DateTime> LastIncrementalBackup { get; public set; }
    public Nullable`1<DateTime> LastFullBackupInternal { get; public set; }
    public Nullable`1<DateTime> LastIncrementalBackupInternal { get; public set; }
    public LocalBackup LocalBackup { get; public set; }
    public Nullable`1<long> LastEtag { get; public set; }
    public string LastDatabaseChangeVector { get; public set; }
    public LastRaftIndex LastRaftIndex { get; public set; }
    public string FolderName { get; public set; }
    public Nullable`1<long> DurationInMs { get; public set; }
    public Nullable`1<long> LocalRetentionDurationInMs { get; public set; }
    public long Version { get; public set; }
    public Error Error { get; public set; }
    public Nullable`1<long> LastOperationId { get; public set; }
    public bool IsEncrypted { get; public set; }
    public static string Prefix { get; }
    [CompilerGeneratedAttribute]
public long get_TaskId();
    [CompilerGeneratedAttribute]
public void set_TaskId(long value);
    [CompilerGeneratedAttribute]
public BackupType get_BackupType();
    [CompilerGeneratedAttribute]
public void set_BackupType(BackupType value);
    [CompilerGeneratedAttribute]
public bool get_IsFull();
    [CompilerGeneratedAttribute]
public void set_IsFull(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_NodeTag();
    [CompilerGeneratedAttribute]
public void set_NodeTag(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_DelayUntil();
    [CompilerGeneratedAttribute]
public void set_DelayUntil(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_OriginalBackupTime();
    [CompilerGeneratedAttribute]
public void set_OriginalBackupTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastFullBackup();
    [CompilerGeneratedAttribute]
public void set_LastFullBackup(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastIncrementalBackup();
    [CompilerGeneratedAttribute]
public void set_LastIncrementalBackup(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastFullBackupInternal();
    [CompilerGeneratedAttribute]
public void set_LastFullBackupInternal(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastIncrementalBackupInternal();
    [CompilerGeneratedAttribute]
public void set_LastIncrementalBackupInternal(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public LocalBackup get_LocalBackup();
    [CompilerGeneratedAttribute]
public void set_LocalBackup(LocalBackup value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_LastEtag();
    [CompilerGeneratedAttribute]
public void set_LastEtag(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public string get_LastDatabaseChangeVector();
    [CompilerGeneratedAttribute]
public void set_LastDatabaseChangeVector(string value);
    [CompilerGeneratedAttribute]
public LastRaftIndex get_LastRaftIndex();
    [CompilerGeneratedAttribute]
public void set_LastRaftIndex(LastRaftIndex value);
    [CompilerGeneratedAttribute]
public string get_FolderName();
    [CompilerGeneratedAttribute]
public void set_FolderName(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_DurationInMs();
    [CompilerGeneratedAttribute]
public void set_DurationInMs(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_LocalRetentionDurationInMs();
    [CompilerGeneratedAttribute]
public void set_LocalRetentionDurationInMs(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public long get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(long value);
    [CompilerGeneratedAttribute]
public Error get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(Error value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_LastOperationId();
    [CompilerGeneratedAttribute]
public void set_LastOperationId(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public bool get_IsEncrypted();
    [CompilerGeneratedAttribute]
public void set_IsEncrypted(bool value);
    public DynamicJsonValue ToJson();
    public void UpdateJson(DynamicJsonValue json);
    public static string get_Prefix();
    public static string GenerateItemName(string databaseName, long taskId);
}
public class Raven.Client.Documents.Operations.Backups.RestoreBackupConfiguration : RestoreBackupConfigurationBase {
    [CompilerGeneratedAttribute]
private string <BackupLocation>k__BackingField;
    public string BackupLocation { get; public set; }
    protected RestoreType Type { get; }
    private RestoreBackupConfiguration(RestoreBackupConfiguration other);
    [CompilerGeneratedAttribute]
public string get_BackupLocation();
    [CompilerGeneratedAttribute]
public void set_BackupLocation(string value);
    protected virtual RestoreType get_Type();
    public virtual DynamicJsonValue ToJson();
    public virtual RestoreBackupConfigurationBase Clone();
}
public abstract class Raven.Client.Documents.Operations.Backups.RestoreBackupConfigurationBase : object {
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastFileNameToRestore>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DataDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableOngoingTasks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private ShardedRestoreSettings <ShardRestoreSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private BackupEncryptionSettings <BackupEncryptionSettings>k__BackingField;
    public string DatabaseName { get; public set; }
    public string LastFileNameToRestore { get; public set; }
    public string DataDirectory { get; public set; }
    public string EncryptionKey { get; public set; }
    public bool DisableOngoingTasks { get; public set; }
    public bool SkipIndexes { get; public set; }
    protected RestoreType Type { get; }
    public ShardedRestoreSettings ShardRestoreSettings { get; public set; }
    public BackupEncryptionSettings BackupEncryptionSettings { get; public set; }
    protected RestoreBackupConfigurationBase(RestoreBackupConfigurationBase other);
    [CompilerGeneratedAttribute]
public string get_DatabaseName();
    [CompilerGeneratedAttribute]
public void set_DatabaseName(string value);
    [CompilerGeneratedAttribute]
public string get_LastFileNameToRestore();
    [CompilerGeneratedAttribute]
public void set_LastFileNameToRestore(string value);
    [CompilerGeneratedAttribute]
public string get_DataDirectory();
    [CompilerGeneratedAttribute]
public void set_DataDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_EncryptionKey();
    [CompilerGeneratedAttribute]
public void set_EncryptionKey(string value);
    [CompilerGeneratedAttribute]
public bool get_DisableOngoingTasks();
    [CompilerGeneratedAttribute]
public void set_DisableOngoingTasks(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipIndexes();
    [CompilerGeneratedAttribute]
public void set_SkipIndexes(bool value);
    protected abstract virtual RestoreType get_Type();
    [CompilerGeneratedAttribute]
public ShardedRestoreSettings get_ShardRestoreSettings();
    [CompilerGeneratedAttribute]
public void set_ShardRestoreSettings(ShardedRestoreSettings value);
    [CompilerGeneratedAttribute]
public BackupEncryptionSettings get_BackupEncryptionSettings();
    [CompilerGeneratedAttribute]
public void set_BackupEncryptionSettings(BackupEncryptionSettings value);
    public abstract virtual RestoreBackupConfigurationBase Clone();
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.Backups.RestoreFromAzureConfiguration : RestoreBackupConfigurationBase {
    [CompilerGeneratedAttribute]
private AzureSettings <Settings>k__BackingField;
    public AzureSettings Settings { get; public set; }
    protected RestoreType Type { get; }
    private RestoreFromAzureConfiguration(RestoreFromAzureConfiguration other);
    [CompilerGeneratedAttribute]
public AzureSettings get_Settings();
    [CompilerGeneratedAttribute]
public void set_Settings(AzureSettings value);
    protected virtual RestoreType get_Type();
    public virtual DynamicJsonValue ToJson();
    public virtual RestoreBackupConfigurationBase Clone();
}
public class Raven.Client.Documents.Operations.Backups.RestoreFromGoogleCloudConfiguration : RestoreBackupConfigurationBase {
    [CompilerGeneratedAttribute]
private GoogleCloudSettings <Settings>k__BackingField;
    public GoogleCloudSettings Settings { get; public set; }
    protected RestoreType Type { get; }
    private RestoreFromGoogleCloudConfiguration(RestoreFromGoogleCloudConfiguration other);
    [CompilerGeneratedAttribute]
public GoogleCloudSettings get_Settings();
    [CompilerGeneratedAttribute]
public void set_Settings(GoogleCloudSettings value);
    protected virtual RestoreType get_Type();
    public virtual DynamicJsonValue ToJson();
    public virtual RestoreBackupConfigurationBase Clone();
}
public class Raven.Client.Documents.Operations.Backups.RestoreFromS3Configuration : RestoreBackupConfigurationBase {
    [CompilerGeneratedAttribute]
private S3Settings <Settings>k__BackingField;
    public S3Settings Settings { get; public set; }
    protected RestoreType Type { get; }
    private RestoreFromS3Configuration(RestoreFromS3Configuration other);
    [CompilerGeneratedAttribute]
public S3Settings get_Settings();
    [CompilerGeneratedAttribute]
public void set_Settings(S3Settings value);
    protected virtual RestoreType get_Type();
    public virtual DynamicJsonValue ToJson();
    public virtual RestoreBackupConfigurationBase Clone();
}
public enum Raven.Client.Documents.Operations.Backups.RestoreType : Enum {
    public int value__;
    public static RestoreType Local;
    public static RestoreType S3;
    public static RestoreType Azure;
    public static RestoreType GoogleCloud;
}
public class Raven.Client.Documents.Operations.Backups.RetentionPolicy : object {
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <MinimumBackupAgeToKeep>k__BackingField;
    public bool Disabled { get; public set; }
    public Nullable`1<TimeSpan> MinimumBackupAgeToKeep { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_MinimumBackupAgeToKeep();
    [CompilerGeneratedAttribute]
public void set_MinimumBackupAgeToKeep(Nullable`1<TimeSpan> value);
    public sealed virtual DynamicJsonValue ToJson();
    public DynamicJsonValue ToAuditJson();
}
public class Raven.Client.Documents.Operations.Backups.S3Settings : AmazonSettings {
    [CompilerGeneratedAttribute]
private string <BucketName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CustomServerUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForcePathStyle>k__BackingField;
    public string BucketName { get; public set; }
    public string CustomServerUrl { get; public set; }
    public bool ForcePathStyle { get; public set; }
    internal S3Settings(S3Settings settings);
    [CompilerGeneratedAttribute]
public string get_BucketName();
    [CompilerGeneratedAttribute]
public void set_BucketName(string value);
    [CompilerGeneratedAttribute]
public string get_CustomServerUrl();
    [CompilerGeneratedAttribute]
public void set_CustomServerUrl(string value);
    [CompilerGeneratedAttribute]
public bool get_ForcePathStyle();
    [CompilerGeneratedAttribute]
public void set_ForcePathStyle(bool value);
    public virtual bool HasSettings();
    public bool Equals(S3Settings other);
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToAuditJson();
}
public class Raven.Client.Documents.Operations.Backups.ShardedBackupProgress : BackupProgress {
    [CompilerGeneratedAttribute]
private int <ShardNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    public int ShardNumber { get; public set; }
    public string NodeTag { get; public set; }
    public ShardedBackupProgress(BackupResult result);
    [CompilerGeneratedAttribute]
public sealed virtual int get_ShardNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ShardNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_NodeTag();
    [CompilerGeneratedAttribute]
public sealed virtual void set_NodeTag(string value);
    public sealed virtual void Fill(IOperationProgress progress, int shardNumber, string nodeTag);
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.Backups.ShardedBackupResult : object {
    [CompilerGeneratedAttribute]
private List`1<ShardNodeBackupResult> <Results>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public List`1<ShardNodeBackupResult> Results { get; public set; }
    public string Message { get; private set; }
    public bool ShouldPersist { get; }
    public bool CanMerge { get; }
    [CompilerGeneratedAttribute]
public sealed virtual List`1<ShardNodeBackupResult> get_Results();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Results(List`1<ShardNodeBackupResult> value);
    public sealed virtual void CombineWith(IOperationResult result, int shardNumber, string nodeTag);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(string value);
    public sealed virtual DynamicJsonValue ToJson();
    public sealed virtual bool get_ShouldPersist();
    public sealed virtual bool get_CanMerge();
    public sealed virtual void MergeWith(IOperationResult result);
}
public class Raven.Client.Documents.Operations.Backups.Sharding.GetShardedPeriodicBackupStatusOperation : object {
    private long _taskId;
    public GetShardedPeriodicBackupStatusOperation(long taskId);
    public sealed virtual RavenCommand`1<GetShardedPeriodicBackupStatusOperationResult> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.Documents.Operations.Backups.Sharding.GetShardedPeriodicBackupStatusOperationResult : AbstractGetPeriodicBackupStatusOperationResult {
    public Dictionary`2<int, PeriodicBackupStatus> Statuses;
}
public class Raven.Client.Documents.Operations.Backups.Sharding.ShardedRestoreSettings : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<int, SingleShardRestoreSetting> <Shards>k__BackingField;
    public Dictionary`2<int, SingleShardRestoreSetting> Shards { get; public set; }
    internal ShardedRestoreSettings(ShardedRestoreSettings other);
    [CompilerGeneratedAttribute]
public Dictionary`2<int, SingleShardRestoreSetting> get_Shards();
    [CompilerGeneratedAttribute]
public void set_Shards(Dictionary`2<int, SingleShardRestoreSetting> value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.Backups.Sharding.SingleShardRestoreSetting : object {
    [CompilerGeneratedAttribute]
private int <ShardNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FolderName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastFileNameToRestore>k__BackingField;
    public int ShardNumber { get; public set; }
    public string NodeTag { get; public set; }
    public string FolderName { get; public set; }
    public string LastFileNameToRestore { get; public set; }
    internal SingleShardRestoreSetting(SingleShardRestoreSetting other);
    [CompilerGeneratedAttribute]
public int get_ShardNumber();
    [CompilerGeneratedAttribute]
public void set_ShardNumber(int value);
    [CompilerGeneratedAttribute]
public string get_NodeTag();
    [CompilerGeneratedAttribute]
public void set_NodeTag(string value);
    [CompilerGeneratedAttribute]
public string get_FolderName();
    [CompilerGeneratedAttribute]
public void set_FolderName(string value);
    [CompilerGeneratedAttribute]
public string get_LastFileNameToRestore();
    [CompilerGeneratedAttribute]
public void set_LastFileNameToRestore(string value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.Backups.ShardNodeBackupResult : ShardNodeOperationResult`1<BackupResult> {
    public bool ShouldPersist { get; }
    public virtual bool get_ShouldPersist();
}
public class Raven.Client.Documents.Operations.Backups.SnapshotSettings : object {
    [CompilerGeneratedAttribute]
private Nullable`1<SnapshotBackupCompressionAlgorithm> <CompressionAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionLevel <CompressionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeIndexes>k__BackingField;
    public Nullable`1<SnapshotBackupCompressionAlgorithm> CompressionAlgorithm { get; public set; }
    public CompressionLevel CompressionLevel { get; public set; }
    public bool ExcludeIndexes { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<SnapshotBackupCompressionAlgorithm> get_CompressionAlgorithm();
    [CompilerGeneratedAttribute]
public void set_CompressionAlgorithm(Nullable`1<SnapshotBackupCompressionAlgorithm> value);
    [CompilerGeneratedAttribute]
public CompressionLevel get_CompressionLevel();
    [CompilerGeneratedAttribute]
public void set_CompressionLevel(CompressionLevel value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeIndexes();
    [CompilerGeneratedAttribute]
public void set_ExcludeIndexes(bool value);
    public sealed virtual DynamicJsonValue ToJson();
    public DynamicJsonValue ToAuditJson();
}
public class Raven.Client.Documents.Operations.Backups.StartBackupOperation : object {
    private bool _isFullBackup;
    private long _taskId;
    public StartBackupOperation(bool isFullBackup, long taskId);
    public sealed virtual RavenCommand`1<OperationIdResult`1<StartBackupOperationResult>> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Backups.StartBackupOperationResult : object {
    [CompilerGeneratedAttribute]
private string <ResponsibleNode>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OperationId>k__BackingField;
    public string ResponsibleNode { get; public set; }
    public long OperationId { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ResponsibleNode();
    [CompilerGeneratedAttribute]
public void set_ResponsibleNode(string value);
    [CompilerGeneratedAttribute]
public long get_OperationId();
    [CompilerGeneratedAttribute]
public void set_OperationId(long value);
}
public class Raven.Client.Documents.Operations.Backups.UpdatePeriodicBackupOperation : object {
    private PeriodicBackupConfiguration _configuration;
    public UpdatePeriodicBackupOperation(PeriodicBackupConfiguration configuration);
    public sealed virtual RavenCommand`1<UpdatePeriodicBackupOperationResult> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.Documents.Operations.Backups.UpdatePeriodicBackupOperationResult : object {
    [CompilerGeneratedAttribute]
private long <RaftCommandIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TaskId>k__BackingField;
    public long RaftCommandIndex { get; public set; }
    public long TaskId { get; public set; }
    [CompilerGeneratedAttribute]
public long get_RaftCommandIndex();
    [CompilerGeneratedAttribute]
public void set_RaftCommandIndex(long value);
    [CompilerGeneratedAttribute]
public long get_TaskId();
    [CompilerGeneratedAttribute]
public void set_TaskId(long value);
}
public class Raven.Client.Documents.Operations.Backups.UploadProgress : object {
    private Stopwatch _sw;
    [CompilerGeneratedAttribute]
private UploadType <UploadType>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadState <UploadState>k__BackingField;
    [CompilerGeneratedAttribute]
private long <UploadedInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private double <BytesPutsPerSec>k__BackingField;
    public UploadType UploadType { get; public set; }
    public UploadState UploadState { get; private set; }
    public long UploadedInBytes { get; public set; }
    public long TotalInBytes { get; public set; }
    public double BytesPutsPerSec { get; public set; }
    public long UploadTimeInMs { get; }
    [CompilerGeneratedAttribute]
public UploadType get_UploadType();
    [CompilerGeneratedAttribute]
public void set_UploadType(UploadType value);
    [CompilerGeneratedAttribute]
public UploadState get_UploadState();
    [CompilerGeneratedAttribute]
private void set_UploadState(UploadState value);
    [CompilerGeneratedAttribute]
public long get_UploadedInBytes();
    [CompilerGeneratedAttribute]
public void set_UploadedInBytes(long value);
    [CompilerGeneratedAttribute]
public long get_TotalInBytes();
    [CompilerGeneratedAttribute]
public void set_TotalInBytes(long value);
    [CompilerGeneratedAttribute]
public double get_BytesPutsPerSec();
    [CompilerGeneratedAttribute]
public void set_BytesPutsPerSec(double value);
    public long get_UploadTimeInMs();
    public void ChangeState(UploadState newState);
    public void SetTotal(long totalLength);
    public void UpdateUploaded(long length);
    public void SetUploaded(long length);
    public void ChangeType(UploadType newType);
    public DynamicJsonValue ToJson();
}
public enum Raven.Client.Documents.Operations.Backups.UploadState : Enum {
    public int value__;
    public static UploadState PendingUpload;
    public static UploadState Uploading;
    public static UploadState PendingResponse;
    public static UploadState Done;
}
public class Raven.Client.Documents.Operations.Backups.UploadToAzure : CloudUploadStatus {
}
public class Raven.Client.Documents.Operations.Backups.UploadToFtp : CloudUploadStatus {
}
public class Raven.Client.Documents.Operations.Backups.UploadToGlacier : CloudUploadStatus {
}
public class Raven.Client.Documents.Operations.Backups.UploadToGoogleCloud : CloudUploadStatus {
}
public class Raven.Client.Documents.Operations.Backups.UploadToS3 : CloudUploadStatus {
}
public enum Raven.Client.Documents.Operations.Backups.UploadType : Enum {
    public int value__;
    public static UploadType Regular;
    public static UploadType Chunked;
}
internal class Raven.Client.Documents.Operations.BulkInsertObserver : object {
    private BulkInsertOperation _operation;
    internal BulkInsertObserver(BulkInsertOperation operation);
    public sealed virtual void OnCompleted();
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnNext(OperationStatusChange value);
}
public class Raven.Client.Documents.Operations.BulkInsertProgress : object {
    [CompilerGeneratedAttribute]
private long <Total>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BatchCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastProcessedId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DocumentsProcessed>k__BackingField;
    [CompilerGeneratedAttribute]
private long <AttachmentsProcessed>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountersProcessed>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TimeSeriesProcessed>k__BackingField;
    public long Total { get; public set; }
    public long BatchCount { get; public set; }
    public string LastProcessedId { get; public set; }
    public long DocumentsProcessed { get; public set; }
    public long AttachmentsProcessed { get; public set; }
    public long CountersProcessed { get; public set; }
    public long TimeSeriesProcessed { get; public set; }
    private bool Raven.Client.Documents.Operations.IOperationProgress.CanMerge { get; }
    [CompilerGeneratedAttribute]
public long get_Total();
    [CompilerGeneratedAttribute]
public void set_Total(long value);
    [CompilerGeneratedAttribute]
public long get_BatchCount();
    [CompilerGeneratedAttribute]
public void set_BatchCount(long value);
    [CompilerGeneratedAttribute]
public string get_LastProcessedId();
    [CompilerGeneratedAttribute]
public void set_LastProcessedId(string value);
    [CompilerGeneratedAttribute]
public long get_DocumentsProcessed();
    [CompilerGeneratedAttribute]
public void set_DocumentsProcessed(long value);
    [CompilerGeneratedAttribute]
public long get_AttachmentsProcessed();
    [CompilerGeneratedAttribute]
public void set_AttachmentsProcessed(long value);
    [CompilerGeneratedAttribute]
public long get_CountersProcessed();
    [CompilerGeneratedAttribute]
public void set_CountersProcessed(long value);
    [CompilerGeneratedAttribute]
public long get_TimeSeriesProcessed();
    [CompilerGeneratedAttribute]
public void set_TimeSeriesProcessed(long value);
    public virtual string ToString();
    public sealed virtual DynamicJsonValue ToJson();
    private sealed virtual override IOperationProgress Raven.Client.Documents.Operations.IOperationProgress.Clone();
    private sealed virtual override bool Raven.Client.Documents.Operations.IOperationProgress.get_CanMerge();
    private sealed virtual override void Raven.Client.Documents.Operations.IOperationProgress.MergeWith(IOperationProgress progress);
}
public class Raven.Client.Documents.Operations.BulkOperationResult : object {
    [CompilerGeneratedAttribute]
private long <Total>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DocumentsProcessed>k__BackingField;
    [CompilerGeneratedAttribute]
private long <AttachmentsProcessed>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountersProcessed>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TimeSeriesProcessed>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Query>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IBulkOperationDetails> <Details>k__BackingField;
    public long Total { get; public set; }
    public long DocumentsProcessed { get; public set; }
    public long AttachmentsProcessed { get; public set; }
    public long CountersProcessed { get; public set; }
    public long TimeSeriesProcessed { get; public set; }
    public string Query { get; public set; }
    public string Message { get; }
    public List`1<IBulkOperationDetails> Details { get; }
    public bool ShouldPersist { get; }
    private bool Raven.Client.Documents.Operations.IOperationResult.CanMerge { get; }
    [CompilerGeneratedAttribute]
public long get_Total();
    [CompilerGeneratedAttribute]
public void set_Total(long value);
    [CompilerGeneratedAttribute]
public long get_DocumentsProcessed();
    [CompilerGeneratedAttribute]
public void set_DocumentsProcessed(long value);
    [CompilerGeneratedAttribute]
public long get_AttachmentsProcessed();
    [CompilerGeneratedAttribute]
public void set_AttachmentsProcessed(long value);
    [CompilerGeneratedAttribute]
public long get_CountersProcessed();
    [CompilerGeneratedAttribute]
public void set_CountersProcessed(long value);
    [CompilerGeneratedAttribute]
public long get_TimeSeriesProcessed();
    [CompilerGeneratedAttribute]
public void set_TimeSeriesProcessed(long value);
    [CompilerGeneratedAttribute]
public string get_Query();
    [CompilerGeneratedAttribute]
public void set_Query(string value);
    public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public List`1<IBulkOperationDetails> get_Details();
    public sealed virtual DynamicJsonValue ToJson();
    public sealed virtual bool get_ShouldPersist();
    private sealed virtual override bool Raven.Client.Documents.Operations.IOperationResult.get_CanMerge();
    private sealed virtual override void Raven.Client.Documents.Operations.IOperationResult.MergeWith(IOperationResult result);
}
public class Raven.Client.Documents.Operations.CollectionDetails : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountOfDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <DocumentsSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <TombstonesSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <RevisionsSize>k__BackingField;
    public string Name { get; public set; }
    public long CountOfDocuments { get; public set; }
    public Size Size { get; public set; }
    public Size DocumentsSize { get; public set; }
    public Size TombstonesSize { get; public set; }
    public Size RevisionsSize { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public long get_CountOfDocuments();
    [CompilerGeneratedAttribute]
public void set_CountOfDocuments(long value);
    [CompilerGeneratedAttribute]
public Size get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(Size value);
    [CompilerGeneratedAttribute]
public Size get_DocumentsSize();
    [CompilerGeneratedAttribute]
public void set_DocumentsSize(Size value);
    [CompilerGeneratedAttribute]
public Size get_TombstonesSize();
    [CompilerGeneratedAttribute]
public void set_TombstonesSize(Size value);
    [CompilerGeneratedAttribute]
public Size get_RevisionsSize();
    [CompilerGeneratedAttribute]
public void set_RevisionsSize(Size value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.CollectionOperationOptions : object {
    private Nullable`1<int> _maxOpsPerSecond;
    [CompilerGeneratedAttribute]
private bool <IgnoreMaxStepsForScript>k__BackingField;
    internal bool IgnoreMaxStepsForScript { get; internal set; }
    public Nullable`1<int> MaxOpsPerSecond { get; public set; }
    [CompilerGeneratedAttribute]
internal bool get_IgnoreMaxStepsForScript();
    [CompilerGeneratedAttribute]
internal void set_IgnoreMaxStepsForScript(bool value);
    public Nullable`1<int> get_MaxOpsPerSecond();
    public void set_MaxOpsPerSecond(Nullable`1<int> value);
}
public class Raven.Client.Documents.Operations.CollectionStatistics : object {
    [CompilerGeneratedAttribute]
private long <CountOfDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountOfConflicts>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, long> <Collections>k__BackingField;
    public long CountOfDocuments { get; public set; }
    public long CountOfConflicts { get; public set; }
    public Dictionary`2<string, long> Collections { get; public set; }
    [CompilerGeneratedAttribute]
public long get_CountOfDocuments();
    [CompilerGeneratedAttribute]
public void set_CountOfDocuments(long value);
    [CompilerGeneratedAttribute]
public long get_CountOfConflicts();
    [CompilerGeneratedAttribute]
public void set_CountOfConflicts(long value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, long> get_Collections();
    [CompilerGeneratedAttribute]
public void set_Collections(Dictionary`2<string, long> value);
    public DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.CompareExchange.CompareExchangeResult`1 : object {
    public T Value;
    public long Index;
    public bool Successful;
    public static CompareExchangeResult`1<T> ParseFromBlittable(BlittableJsonReaderObject response, DocumentConventions conventions);
}
public class Raven.Client.Documents.Operations.CompareExchange.CompareExchangeValue`1 : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    private IMetadataDictionary _metadataAsDictionary;
    public string Key { get; }
    public long Index { get; internal set; }
    public T Value { get; public set; }
    public string ChangeVector { get; internal set; }
    public IMetadataDictionary Metadata { get; }
    private bool HasMetadata { get; }
    private string Raven.Client.Documents.Operations.CompareExchange.ICompareExchangeValue.Key { get; }
    private long Raven.Client.Documents.Operations.CompareExchange.ICompareExchangeValue.Index { get; private set; }
    private object Raven.Client.Documents.Operations.CompareExchange.ICompareExchangeValue.Value { get; }
    private IMetadataDictionary Raven.Client.Documents.Operations.CompareExchange.ICompareExchangeValue.Metadata { get; }
    private bool Raven.Client.Documents.Operations.CompareExchange.ICompareExchangeValue.HasMetadata { get; }
    public CompareExchangeValue`1(string key, long index, T value, IMetadataDictionary metadata);
    internal CompareExchangeValue`1(string key, long index, T value, string changeVector, IMetadataDictionary metadata);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public long get_Index();
    [CompilerGeneratedAttribute]
internal void set_Index(long value);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(T value);
    [CompilerGeneratedAttribute]
public string get_ChangeVector();
    [CompilerGeneratedAttribute]
internal void set_ChangeVector(string value);
    public IMetadataDictionary get_Metadata();
    private bool get_HasMetadata();
    private sealed virtual override string Raven.Client.Documents.Operations.CompareExchange.ICompareExchangeValue.get_Key();
    private sealed virtual override long Raven.Client.Documents.Operations.CompareExchange.ICompareExchangeValue.get_Index();
    private sealed virtual override void Raven.Client.Documents.Operations.CompareExchange.ICompareExchangeValue.set_Index(long value);
    private sealed virtual override object Raven.Client.Documents.Operations.CompareExchange.ICompareExchangeValue.get_Value();
    private sealed virtual override IMetadataDictionary Raven.Client.Documents.Operations.CompareExchange.ICompareExchangeValue.get_Metadata();
    private sealed virtual override bool Raven.Client.Documents.Operations.CompareExchange.ICompareExchangeValue.get_HasMetadata();
    internal static CompareExchangeValue`1<BlittableJsonReaderObject> CreateFrom(BlittableJsonReaderObject json);
}
internal static class Raven.Client.Documents.Operations.CompareExchange.CompareExchangeValueBlittableJsonConverter : object {
    public static object ConvertToBlittable(object value, DocumentConventions conventions, JsonOperationContext context);
    public static object ConvertToBlittable(object value, DocumentConventions conventions, JsonOperationContext context, IJsonSerializer jsonSerializer);
}
internal static class Raven.Client.Documents.Operations.CompareExchange.CompareExchangeValueResultParser`1 : object {
    public static Dictionary`2<string, CompareExchangeValue`1<T>> GetValues(BlittableJsonReaderObject response, bool materializeMetadata, DocumentConventions conventions);
    public static CompareExchangeValue`1<T> GetValue(BlittableJsonReaderObject response, bool materializeMetadata, DocumentConventions conventions);
    public static CompareExchangeValue`1<T> GetSingleValue(BlittableJsonReaderObject item, bool materializeMetadata, DocumentConventions conventions);
    internal static T DeserializeObject(BlittableJsonReaderObject raw, DocumentConventions conventions);
}
public class Raven.Client.Documents.Operations.CompareExchange.DeleteCompareExchangeValueOperation`1 : object {
    private string _key;
    private long _index;
    public DeleteCompareExchangeValueOperation`1(string key, long index);
    public sealed virtual RavenCommand`1<CompareExchangeResult`1<T>> GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
}
public class Raven.Client.Documents.Operations.CompareExchange.GetCompareExchangeValueOperation`1 : object {
    private string _key;
    private bool _materializeMetadata;
    private string _nodeTag;
    public GetCompareExchangeValueOperation`1(string key);
    internal GetCompareExchangeValueOperation`1(string key, string nodeTag);
    internal GetCompareExchangeValueOperation`1(string key, bool materializeMetadata);
    public sealed virtual RavenCommand`1<CompareExchangeValue`1<T>> GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
}
public class Raven.Client.Documents.Operations.CompareExchange.GetCompareExchangeValuesOperation`1 : object {
    private String[] _keys;
    private string _startWith;
    private Nullable`1<int> _start;
    private Nullable`1<int> _pageSize;
    private bool _materializeMetadata;
    public GetCompareExchangeValuesOperation`1(String[] keys);
    internal GetCompareExchangeValuesOperation`1(String[] keys, bool materializeMetadata);
    public GetCompareExchangeValuesOperation`1(string startWith, Nullable`1<int> start, Nullable`1<int> pageSize);
    public sealed virtual RavenCommand`1<Dictionary`2<string, CompareExchangeValue`1<T>>> GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
}
internal interface Raven.Client.Documents.Operations.CompareExchange.ICompareExchangeValue {
    public string Key { get; }
    public long Index { get; internal set; }
    public object Value { get; }
    public IMetadataDictionary Metadata { get; }
    public bool HasMetadata { get; }
    public abstract virtual string get_Key();
    public abstract virtual long get_Index();
    internal abstract virtual void set_Index(long value);
    public abstract virtual object get_Value();
    public abstract virtual IMetadataDictionary get_Metadata();
    public abstract virtual bool get_HasMetadata();
}
public class Raven.Client.Documents.Operations.CompareExchange.PutCompareExchangeValueOperation`1 : object {
    private string _key;
    private T _value;
    private long _index;
    private IMetadataDictionary _metadata;
    public PutCompareExchangeValueOperation`1(string key, T value, long index, IMetadataDictionary metadata);
    public sealed virtual RavenCommand`1<CompareExchangeResult`1<T>> GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
}
public class Raven.Client.Documents.Operations.Configuration.ClientConfiguration : object {
    private Nullable`1<char> _identityPartsSeparator;
    [CompilerGeneratedAttribute]
private long <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxNumberOfRequestsPerSession>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReadBalanceBehavior> <ReadBalanceBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<LoadBalanceBehavior> <LoadBalanceBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LoadBalancerContextSeed>k__BackingField;
    public long Etag { get; public set; }
    public bool Disabled { get; public set; }
    public Nullable`1<int> MaxNumberOfRequestsPerSession { get; public set; }
    public Nullable`1<ReadBalanceBehavior> ReadBalanceBehavior { get; public set; }
    public Nullable`1<LoadBalanceBehavior> LoadBalanceBehavior { get; public set; }
    public Nullable`1<int> LoadBalancerContextSeed { get; public set; }
    public Nullable`1<char> IdentityPartsSeparator { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Etag();
    [CompilerGeneratedAttribute]
public void set_Etag(long value);
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxNumberOfRequestsPerSession();
    [CompilerGeneratedAttribute]
public void set_MaxNumberOfRequestsPerSession(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReadBalanceBehavior> get_ReadBalanceBehavior();
    [CompilerGeneratedAttribute]
public void set_ReadBalanceBehavior(Nullable`1<ReadBalanceBehavior> value);
    [CompilerGeneratedAttribute]
public Nullable`1<LoadBalanceBehavior> get_LoadBalanceBehavior();
    [CompilerGeneratedAttribute]
public void set_LoadBalanceBehavior(Nullable`1<LoadBalanceBehavior> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LoadBalancerContextSeed();
    [CompilerGeneratedAttribute]
public void set_LoadBalancerContextSeed(Nullable`1<int> value);
    public Nullable`1<char> get_IdentityPartsSeparator();
    public void set_IdentityPartsSeparator(Nullable`1<char> value);
    public DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.Configuration.GetClientConfigurationOperation : object {
    public sealed virtual RavenCommand`1<Result> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
internal class Raven.Client.Documents.Operations.Configuration.GetStudioConfigurationOperation : object {
    public sealed virtual RavenCommand`1<StudioConfiguration> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Configuration.PutClientConfigurationOperation : object {
    private ClientConfiguration _configuration;
    public PutClientConfigurationOperation(ClientConfiguration configuration);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Configuration.StudioConfiguration : object {
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableAutoIndexCreation>k__BackingField;
    [CompilerGeneratedAttribute]
private StudioEnvironment <Environment>k__BackingField;
    public bool Disabled { get; public set; }
    public bool DisableAutoIndexCreation { get; public set; }
    public StudioEnvironment Environment { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableAutoIndexCreation();
    [CompilerGeneratedAttribute]
public void set_DisableAutoIndexCreation(bool value);
    [CompilerGeneratedAttribute]
public StudioEnvironment get_Environment();
    [CompilerGeneratedAttribute]
public void set_Environment(StudioEnvironment value);
    public virtual DynamicJsonValue ToJson();
}
public abstract class Raven.Client.Documents.Operations.ConnectionStrings.ConnectionString : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; public set; }
    public ConnectionStringType Type { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public bool Validate(List`1& errors);
    public abstract virtual ConnectionStringType get_Type();
    protected abstract virtual void ValidateImpl(List`1& errors);
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToAuditJson();
    public virtual bool IsEqual(ConnectionString connectionString);
    internal static ConnectionStringType GetConnectionStringType(BlittableJsonReaderObject connectionStringConfiguration);
}
public enum Raven.Client.Documents.Operations.ConnectionStrings.ConnectionStringType : Enum {
    public int value__;
    public static ConnectionStringType None;
    public static ConnectionStringType Raven;
    public static ConnectionStringType Sql;
    public static ConnectionStringType Olap;
    public static ConnectionStringType ElasticSearch;
    public static ConnectionStringType Queue;
}
public class Raven.Client.Documents.Operations.ConnectionStrings.GetConnectionStringsOperation : object {
    private string _connectionStringName;
    private ConnectionStringType _type;
    public GetConnectionStringsOperation(string connectionStringName, ConnectionStringType type);
    public sealed virtual RavenCommand`1<GetConnectionStringsResult> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.Documents.Operations.ConnectionStrings.GetConnectionStringsResult : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, RavenConnectionString> <RavenConnectionStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, SqlConnectionString> <SqlConnectionStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, OlapConnectionString> <OlapConnectionStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ElasticSearchConnectionString> <ElasticSearchConnectionStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, QueueConnectionString> <QueueConnectionStrings>k__BackingField;
    public Dictionary`2<string, RavenConnectionString> RavenConnectionStrings { get; public set; }
    public Dictionary`2<string, SqlConnectionString> SqlConnectionStrings { get; public set; }
    public Dictionary`2<string, OlapConnectionString> OlapConnectionStrings { get; public set; }
    public Dictionary`2<string, ElasticSearchConnectionString> ElasticSearchConnectionStrings { get; public set; }
    public Dictionary`2<string, QueueConnectionString> QueueConnectionStrings { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, RavenConnectionString> get_RavenConnectionStrings();
    [CompilerGeneratedAttribute]
public void set_RavenConnectionStrings(Dictionary`2<string, RavenConnectionString> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, SqlConnectionString> get_SqlConnectionStrings();
    [CompilerGeneratedAttribute]
public void set_SqlConnectionStrings(Dictionary`2<string, SqlConnectionString> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, OlapConnectionString> get_OlapConnectionStrings();
    [CompilerGeneratedAttribute]
public void set_OlapConnectionStrings(Dictionary`2<string, OlapConnectionString> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, ElasticSearchConnectionString> get_ElasticSearchConnectionStrings();
    [CompilerGeneratedAttribute]
public void set_ElasticSearchConnectionStrings(Dictionary`2<string, ElasticSearchConnectionString> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, QueueConnectionString> get_QueueConnectionStrings();
    [CompilerGeneratedAttribute]
public void set_QueueConnectionStrings(Dictionary`2<string, QueueConnectionString> value);
    public DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.ConnectionStrings.PutConnectionStringOperation`1 : object {
    private T _connectionString;
    public PutConnectionStringOperation`1(T connectionString);
    public sealed virtual RavenCommand`1<PutConnectionStringResult> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.Documents.Operations.ConnectionStrings.PutConnectionStringResult : object {
    [CompilerGeneratedAttribute]
private long <RaftCommandIndex>k__BackingField;
    public long RaftCommandIndex { get; public set; }
    [CompilerGeneratedAttribute]
public long get_RaftCommandIndex();
    [CompilerGeneratedAttribute]
public void set_RaftCommandIndex(long value);
}
public class Raven.Client.Documents.Operations.ConnectionStrings.RemoveConnectionStringOperation`1 : object {
    private T _connectionString;
    public RemoveConnectionStringOperation`1(T connectionString);
    public sealed virtual RavenCommand`1<RemoveConnectionStringResult> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.ConnectionStrings.RemoveConnectionStringResult : object {
    [CompilerGeneratedAttribute]
private long <RaftCommandIndex>k__BackingField;
    public long RaftCommandIndex { get; public set; }
    [CompilerGeneratedAttribute]
public long get_RaftCommandIndex();
    [CompilerGeneratedAttribute]
public void set_RaftCommandIndex(long value);
}
public class Raven.Client.Documents.Operations.Counters.CounterBatch : object {
    public bool ReplyWithAllNodesValues;
    public List`1<DocumentCountersOperation> Documents;
    public bool FromEtl;
}
public class Raven.Client.Documents.Operations.Counters.CounterBatchOperation : object {
    private CounterBatch _counterBatch;
    public CounterBatchOperation(CounterBatch counterBatch);
    public sealed virtual RavenCommand`1<CountersDetail> GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
}
public class Raven.Client.Documents.Operations.Counters.CounterDetail : object {
    [CompilerGeneratedAttribute]
private string <DocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CounterName>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalValue>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, long> <CounterValues>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private LazyStringValue <CounterKey>k__BackingField;
    public string DocumentId { get; public set; }
    public string CounterName { get; public set; }
    public long TotalValue { get; public set; }
    public long Etag { get; public set; }
    public Dictionary`2<string, long> CounterValues { get; public set; }
    public string ChangeVector { get; public set; }
    internal LazyStringValue CounterKey { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_DocumentId();
    [CompilerGeneratedAttribute]
public void set_DocumentId(string value);
    [CompilerGeneratedAttribute]
public string get_CounterName();
    [CompilerGeneratedAttribute]
public void set_CounterName(string value);
    [CompilerGeneratedAttribute]
public long get_TotalValue();
    [CompilerGeneratedAttribute]
public void set_TotalValue(long value);
    [CompilerGeneratedAttribute]
public long get_Etag();
    [CompilerGeneratedAttribute]
public void set_Etag(long value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, long> get_CounterValues();
    [CompilerGeneratedAttribute]
public void set_CounterValues(Dictionary`2<string, long> value);
    [CompilerGeneratedAttribute]
public string get_ChangeVector();
    [CompilerGeneratedAttribute]
public void set_ChangeVector(string value);
    [CompilerGeneratedAttribute]
internal LazyStringValue get_CounterKey();
    [CompilerGeneratedAttribute]
internal void set_CounterKey(LazyStringValue value);
    public DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.Counters.CounterGroupDetail : object {
    [CompilerGeneratedAttribute]
private LazyStringValue <DocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private LazyStringValue <ChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <Values>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Etag>k__BackingField;
    public LazyStringValue DocumentId { get; public set; }
    public LazyStringValue ChangeVector { get; public set; }
    public BlittableJsonReaderObject Values { get; public set; }
    public long Etag { get; public set; }
    [CompilerGeneratedAttribute]
public LazyStringValue get_DocumentId();
    [CompilerGeneratedAttribute]
public void set_DocumentId(LazyStringValue value);
    [CompilerGeneratedAttribute]
public LazyStringValue get_ChangeVector();
    [CompilerGeneratedAttribute]
public void set_ChangeVector(LazyStringValue value);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_Values();
    [CompilerGeneratedAttribute]
public void set_Values(BlittableJsonReaderObject value);
    [CompilerGeneratedAttribute]
public long get_Etag();
    [CompilerGeneratedAttribute]
public void set_Etag(long value);
    public DynamicJsonValue ToJson();
    public sealed virtual void Dispose();
}
public class Raven.Client.Documents.Operations.Counters.CounterOperation : object {
    public CounterOperationType Type;
    public string CounterName;
    public long Delta;
    internal string ChangeVector;
    internal string DocumentId;
    public static CounterOperation Parse(BlittableJsonReaderObject input);
    private static void ThrowMissingDeltaProperty(string name, CounterOperationType type);
    private static void ThrowMissingCounterOperationType(string name);
    private static void ThrowMissingCounterName();
    public DynamicJsonValue ToJson();
}
public enum Raven.Client.Documents.Operations.Counters.CounterOperationType : Enum {
    public int value__;
    public static CounterOperationType None;
    public static CounterOperationType Increment;
    public static CounterOperationType Delete;
    public static CounterOperationType Get;
    public static CounterOperationType Put;
    public static CounterOperationType GetAll;
}
public class Raven.Client.Documents.Operations.Counters.CountersDetail : object {
    [CompilerGeneratedAttribute]
private List`1<CounterDetail> <Counters>k__BackingField;
    public List`1<CounterDetail> Counters { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<CounterDetail> get_Counters();
    [CompilerGeneratedAttribute]
public void set_Counters(List`1<CounterDetail> value);
    public DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.Counters.DocumentCountersOperation : object {
    public List`1<CounterOperation> Operations;
    public string DocumentId;
    public static DocumentCountersOperation Parse(BlittableJsonReaderObject input);
    private static void ThrowNotBlittableJsonReaderObjectOperation(object op);
    private static void ThrowMissingCounterOperations();
    private static void ThrowMissingDocumentId();
    public DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.Counters.GetCountersOperation : object {
    private string _docId;
    private String[] _counters;
    private bool _returnFullResults;
    public GetCountersOperation(string docId, String[] counters, bool returnFullResults);
    public GetCountersOperation(string docId, string counter, bool returnFullResults);
    public GetCountersOperation(string docId, bool returnFullResults);
    public sealed virtual RavenCommand`1<CountersDetail> GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
}
public class Raven.Client.Documents.Operations.DataArchival.ConfigureDataArchivalOperation : object {
    private DataArchivalConfiguration _configuration;
    public ConfigureDataArchivalOperation(DataArchivalConfiguration configuration);
    public sealed virtual RavenCommand`1<ConfigureDataArchivalOperationResult> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.Documents.Operations.DataArchival.ConfigureDataArchivalOperationResult : object {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <RaftCommandIndex>k__BackingField;
    public Nullable`1<long> RaftCommandIndex { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_RaftCommandIndex();
    [CompilerGeneratedAttribute]
public void set_RaftCommandIndex(Nullable`1<long> value);
}
public class Raven.Client.Documents.Operations.DataArchival.DataArchivalConfiguration : object {
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ArchiveFrequencyInSec>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MaxItemsToProcess>k__BackingField;
    public bool Disabled { get; public set; }
    public Nullable`1<long> ArchiveFrequencyInSec { get; public set; }
    public Nullable`1<long> MaxItemsToProcess { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ArchiveFrequencyInSec();
    [CompilerGeneratedAttribute]
public void set_ArchiveFrequencyInSec(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MaxItemsToProcess();
    [CompilerGeneratedAttribute]
public void set_MaxItemsToProcess(Nullable`1<long> value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    protected bool Equals(DataArchivalConfiguration other);
    public sealed virtual DynamicJsonValue ToJson();
}
internal class Raven.Client.Documents.Operations.DatabaseHealthCheckOperation : object {
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.DatabaseStatistics : AbstractDatabaseStatistics`1<IndexInformation> {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <LastDocEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <LastDatabaseEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountOfUniqueAttachments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatabaseChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatabaseId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Is64Bit>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Pager>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastIndexingTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <SizeOnDisk>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <TempBuffersSizeOnDisk>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfTransactionMergerQueueOperations>k__BackingField;
    public Nullable`1<long> LastDocEtag { get; public set; }
    public Nullable`1<long> LastDatabaseEtag { get; public set; }
    public long CountOfUniqueAttachments { get; public set; }
    public String[] StaleIndexes { get; }
    public string DatabaseChangeVector { get; public set; }
    public string DatabaseId { get; public set; }
    public bool Is64Bit { get; public set; }
    public string Pager { get; public set; }
    public Nullable`1<DateTime> LastIndexingTime { get; public set; }
    public Size SizeOnDisk { get; public set; }
    public Size TempBuffersSizeOnDisk { get; public set; }
    public int NumberOfTransactionMergerQueueOperations { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_LastDocEtag();
    [CompilerGeneratedAttribute]
public void set_LastDocEtag(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_LastDatabaseEtag();
    [CompilerGeneratedAttribute]
public void set_LastDatabaseEtag(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public long get_CountOfUniqueAttachments();
    [CompilerGeneratedAttribute]
public void set_CountOfUniqueAttachments(long value);
    public String[] get_StaleIndexes();
    [CompilerGeneratedAttribute]
public string get_DatabaseChangeVector();
    [CompilerGeneratedAttribute]
public void set_DatabaseChangeVector(string value);
    [CompilerGeneratedAttribute]
public string get_DatabaseId();
    [CompilerGeneratedAttribute]
public void set_DatabaseId(string value);
    [CompilerGeneratedAttribute]
public bool get_Is64Bit();
    [CompilerGeneratedAttribute]
public void set_Is64Bit(bool value);
    [CompilerGeneratedAttribute]
public string get_Pager();
    [CompilerGeneratedAttribute]
public void set_Pager(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastIndexingTime();
    [CompilerGeneratedAttribute]
public void set_LastIndexingTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Size get_SizeOnDisk();
    [CompilerGeneratedAttribute]
public void set_SizeOnDisk(Size value);
    [CompilerGeneratedAttribute]
public Size get_TempBuffersSizeOnDisk();
    [CompilerGeneratedAttribute]
public void set_TempBuffersSizeOnDisk(Size value);
    [CompilerGeneratedAttribute]
public int get_NumberOfTransactionMergerQueueOperations();
    [CompilerGeneratedAttribute]
public void set_NumberOfTransactionMergerQueueOperations(int value);
}
public class Raven.Client.Documents.Operations.DeleteByQueryOperation : object {
    protected static IndexQuery DummyQuery;
    protected IndexQuery _queryToDelete;
    private QueryOperationOptions _options;
    public DeleteByQueryOperation(string queryToDelete);
    public DeleteByQueryOperation(IndexQuery queryToDelete, QueryOperationOptions options);
    private static DeleteByQueryOperation();
    public virtual RavenCommand`1<OperationIdResult> GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
}
public class Raven.Client.Documents.Operations.DeleteByQueryOperation`1 : DeleteByQueryOperation {
    private string _indexName;
    private Expression`1<Func`2<TEntity, bool>> _expression;
    public DeleteByQueryOperation`1(string indexName, Expression`1<Func`2<TEntity, bool>> expression, QueryOperationOptions options);
    public virtual RavenCommand`1<OperationIdResult> GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
}
public class Raven.Client.Documents.Operations.DeleteByQueryOperation`2 : DeleteByQueryOperation`1<TEntity> {
    public DeleteByQueryOperation`2(Expression`1<Func`2<TEntity, bool>> expression, QueryOperationOptions options);
}
public class Raven.Client.Documents.Operations.DetailedCollectionStatistics : object {
    [CompilerGeneratedAttribute]
private long <CountOfDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountOfConflicts>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, CollectionDetails> <Collections>k__BackingField;
    public long CountOfDocuments { get; public set; }
    public long CountOfConflicts { get; public set; }
    public Dictionary`2<string, CollectionDetails> Collections { get; public set; }
    [CompilerGeneratedAttribute]
public long get_CountOfDocuments();
    [CompilerGeneratedAttribute]
public void set_CountOfDocuments(long value);
    [CompilerGeneratedAttribute]
public long get_CountOfConflicts();
    [CompilerGeneratedAttribute]
public void set_CountOfConflicts(long value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, CollectionDetails> get_Collections();
    [CompilerGeneratedAttribute]
public void set_Collections(Dictionary`2<string, CollectionDetails> value);
    public DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.DetailedDatabaseStatistics : DatabaseStatistics {
    [CompilerGeneratedAttribute]
private long <CountOfIdentities>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountOfCompareExchange>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountOfCompareExchangeTombstones>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountOfTimeSeriesDeletedRanges>k__BackingField;
    public long CountOfIdentities { get; public set; }
    public long CountOfCompareExchange { get; public set; }
    public long CountOfCompareExchangeTombstones { get; public set; }
    public long CountOfTimeSeriesDeletedRanges { get; public set; }
    [CompilerGeneratedAttribute]
public long get_CountOfIdentities();
    [CompilerGeneratedAttribute]
public void set_CountOfIdentities(long value);
    [CompilerGeneratedAttribute]
public long get_CountOfCompareExchange();
    [CompilerGeneratedAttribute]
public void set_CountOfCompareExchange(long value);
    [CompilerGeneratedAttribute]
public long get_CountOfCompareExchangeTombstones();
    [CompilerGeneratedAttribute]
public void set_CountOfCompareExchangeTombstones(long value);
    [CompilerGeneratedAttribute]
public long get_CountOfTimeSeriesDeletedRanges();
    [CompilerGeneratedAttribute]
public void set_CountOfTimeSeriesDeletedRanges(long value);
}
public class Raven.Client.Documents.Operations.DeterminateProgress : object {
    [CompilerGeneratedAttribute]
private long <Processed>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Total>k__BackingField;
    public long Processed { get; public set; }
    public long Total { get; public set; }
    private bool Raven.Client.Documents.Operations.IOperationProgress.CanMerge { get; }
    [CompilerGeneratedAttribute]
public long get_Processed();
    [CompilerGeneratedAttribute]
public void set_Processed(long value);
    [CompilerGeneratedAttribute]
public long get_Total();
    [CompilerGeneratedAttribute]
public void set_Total(long value);
    public sealed virtual DynamicJsonValue ToJson();
    private sealed virtual override IOperationProgress Raven.Client.Documents.Operations.IOperationProgress.Clone();
    private sealed virtual override bool Raven.Client.Documents.Operations.IOperationProgress.get_CanMerge();
    private sealed virtual override void Raven.Client.Documents.Operations.IOperationProgress.MergeWith(IOperationProgress progress);
}
public class Raven.Client.Documents.Operations.EssentialDatabaseStatistics : AbstractDatabaseStatistics`1<EssentialIndexInformation> {
}
public class Raven.Client.Documents.Operations.EssentialIndexInformation : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexLockMode <LockMode>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexPriority <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexSourceType <SourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ArchivedDataProcessingBehavior> <ArchivedDataProcessingBehavior>k__BackingField;
    public string Name { get; public set; }
    public IndexLockMode LockMode { get; public set; }
    public IndexPriority Priority { get; public set; }
    public IndexType Type { get; public set; }
    public IndexSourceType SourceType { get; public set; }
    public Nullable`1<ArchivedDataProcessingBehavior> ArchivedDataProcessingBehavior { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public IndexLockMode get_LockMode();
    [CompilerGeneratedAttribute]
public void set_LockMode(IndexLockMode value);
    [CompilerGeneratedAttribute]
public IndexPriority get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(IndexPriority value);
    [CompilerGeneratedAttribute]
public IndexType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IndexType value);
    [CompilerGeneratedAttribute]
public IndexSourceType get_SourceType();
    [CompilerGeneratedAttribute]
public void set_SourceType(IndexSourceType value);
    [CompilerGeneratedAttribute]
public Nullable`1<ArchivedDataProcessingBehavior> get_ArchivedDataProcessingBehavior();
    [CompilerGeneratedAttribute]
public void set_ArchivedDataProcessingBehavior(Nullable`1<ArchivedDataProcessingBehavior> value);
}
public class Raven.Client.Documents.Operations.ETL.AddEtlOperation`1 : object {
    private EtlConfiguration`1<T> _configuration;
    public AddEtlOperation`1(EtlConfiguration`1<T> configuration);
    public sealed virtual RavenCommand`1<AddEtlOperationResult> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.Documents.Operations.ETL.AddEtlOperationResult : object {
    [CompilerGeneratedAttribute]
private long <RaftCommandIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TaskId>k__BackingField;
    public long RaftCommandIndex { get; public set; }
    public long TaskId { get; public set; }
    [CompilerGeneratedAttribute]
public long get_RaftCommandIndex();
    [CompilerGeneratedAttribute]
public void set_RaftCommandIndex(long value);
    [CompilerGeneratedAttribute]
public long get_TaskId();
    [CompilerGeneratedAttribute]
public void set_TaskId(long value);
}
public class Raven.Client.Documents.Operations.ETL.ElasticSearch.ApiKeyAuthentication : object {
    [CompilerGeneratedAttribute]
private string <ApiKeyId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApiKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncodedApiKey>k__BackingField;
    public string ApiKeyId { get; public set; }
    public string ApiKey { get; public set; }
    public string EncodedApiKey { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ApiKeyId();
    [CompilerGeneratedAttribute]
public void set_ApiKeyId(string value);
    [CompilerGeneratedAttribute]
public string get_ApiKey();
    [CompilerGeneratedAttribute]
public void set_ApiKey(string value);
    [CompilerGeneratedAttribute]
public string get_EncodedApiKey();
    [CompilerGeneratedAttribute]
public void set_EncodedApiKey(string value);
}
public class Raven.Client.Documents.Operations.ETL.ElasticSearch.Authentication : object {
    [CompilerGeneratedAttribute]
private ApiKeyAuthentication <ApiKey>k__BackingField;
    [CompilerGeneratedAttribute]
private BasicAuthentication <Basic>k__BackingField;
    [CompilerGeneratedAttribute]
private CertificateAuthentication <Certificate>k__BackingField;
    public ApiKeyAuthentication ApiKey { get; public set; }
    public BasicAuthentication Basic { get; public set; }
    public CertificateAuthentication Certificate { get; public set; }
    [CompilerGeneratedAttribute]
public ApiKeyAuthentication get_ApiKey();
    [CompilerGeneratedAttribute]
public void set_ApiKey(ApiKeyAuthentication value);
    [CompilerGeneratedAttribute]
public BasicAuthentication get_Basic();
    [CompilerGeneratedAttribute]
public void set_Basic(BasicAuthentication value);
    [CompilerGeneratedAttribute]
public CertificateAuthentication get_Certificate();
    [CompilerGeneratedAttribute]
public void set_Certificate(CertificateAuthentication value);
}
public class Raven.Client.Documents.Operations.ETL.ElasticSearch.BasicAuthentication : object {
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    public string Username { get; public set; }
    public string Password { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public void set_Username(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
}
public class Raven.Client.Documents.Operations.ETL.ElasticSearch.CertificateAuthentication : object {
    [CompilerGeneratedAttribute]
private String[] <CertificatesBase64>k__BackingField;
    public String[] CertificatesBase64 { get; public set; }
    [CompilerGeneratedAttribute]
public String[] get_CertificatesBase64();
    [CompilerGeneratedAttribute]
public void set_CertificatesBase64(String[] value);
}
public class Raven.Client.Documents.Operations.ETL.ElasticSearch.ElasticSearchConnectionString : ConnectionString {
    public String[] Nodes;
    public Authentication Authentication;
    [CompilerGeneratedAttribute]
private bool <EnableCompatibilityMode>k__BackingField;
    public ConnectionStringType Type { get; }
    [ObsoleteAttribute("Elasticsearch compatibility isn't required anymore to connect with Elasticsearch server v8.x.")]
public bool EnableCompatibilityMode { get; public set; }
    public virtual ConnectionStringType get_Type();
    [CompilerGeneratedAttribute]
public bool get_EnableCompatibilityMode();
    [CompilerGeneratedAttribute]
public void set_EnableCompatibilityMode(bool value);
    protected virtual void ValidateImpl(List`1& errors);
    public virtual bool IsEqual(ConnectionString connectionString);
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToAuditJson();
}
public class Raven.Client.Documents.Operations.ETL.ElasticSearch.ElasticSearchEtlConfiguration : EtlConfiguration`1<ElasticSearchConnectionString> {
    private string _destination;
    [CompilerGeneratedAttribute]
private List`1<ElasticSearchIndex> <ElasticIndexes>k__BackingField;
    public List`1<ElasticSearchIndex> ElasticIndexes { get; public set; }
    public EtlType EtlType { get; }
    [CompilerGeneratedAttribute]
public List`1<ElasticSearchIndex> get_ElasticIndexes();
    [CompilerGeneratedAttribute]
public void set_ElasticIndexes(List`1<ElasticSearchIndex> value);
    public virtual string GetDestination();
    public virtual EtlType get_EtlType();
    public virtual bool UsingEncryptedCommunicationChannel();
    public virtual string GetDefaultTaskName();
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToAuditJson();
}
public class Raven.Client.Documents.Operations.ETL.ElasticSearch.ElasticSearchIndex : object {
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DocumentIdProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InsertOnlyMode>k__BackingField;
    public string IndexName { get; public set; }
    public string DocumentIdProperty { get; public set; }
    public bool InsertOnlyMode { get; public set; }
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    [CompilerGeneratedAttribute]
public string get_DocumentIdProperty();
    [CompilerGeneratedAttribute]
public void set_DocumentIdProperty(string value);
    [CompilerGeneratedAttribute]
public bool get_InsertOnlyMode();
    [CompilerGeneratedAttribute]
public void set_InsertOnlyMode(bool value);
    public DynamicJsonValue ToJson();
}
public abstract class Raven.Client.Documents.Operations.ETL.EtlConfiguration`1 : object {
    private bool _initialized;
    [CompilerGeneratedAttribute]
private long <TaskId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MentorNode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PinToMentorNode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionStringName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TestMode>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Connection>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Transformation> <Transforms>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowEtlOnNonEncryptedChannel>k__BackingField;
    public long TaskId { get; public set; }
    public string Name { get; public set; }
    public string MentorNode { get; public set; }
    public bool PinToMentorNode { get; public set; }
    public string ConnectionStringName { get; public set; }
    internal bool TestMode { get; internal set; }
    [JsonDeserializationIgnoreAttribute]
[JsonIgnoreAttribute]
internal T Connection { get; internal set; }
    public List`1<Transformation> Transforms { get; public set; }
    public bool Disabled { get; public set; }
    public EtlType EtlType { get; }
    public bool AllowEtlOnNonEncryptedChannel { get; public set; }
    [CompilerGeneratedAttribute]
public long get_TaskId();
    [CompilerGeneratedAttribute]
public void set_TaskId(long value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_MentorNode();
    [CompilerGeneratedAttribute]
public void set_MentorNode(string value);
    [CompilerGeneratedAttribute]
public bool get_PinToMentorNode();
    [CompilerGeneratedAttribute]
public void set_PinToMentorNode(bool value);
    public abstract virtual string GetDestination();
    [CompilerGeneratedAttribute]
public string get_ConnectionStringName();
    [CompilerGeneratedAttribute]
public void set_ConnectionStringName(string value);
    [CompilerGeneratedAttribute]
internal bool get_TestMode();
    [CompilerGeneratedAttribute]
internal void set_TestMode(bool value);
    [CompilerGeneratedAttribute]
internal T get_Connection();
    [CompilerGeneratedAttribute]
internal void set_Connection(T value);
    public void Initialize(T connectionString);
    [CompilerGeneratedAttribute]
public List`1<Transformation> get_Transforms();
    [CompilerGeneratedAttribute]
public void set_Transforms(List`1<Transformation> value);
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    public virtual bool Validate(List`1& errors, bool validateName, bool validateConnection);
    public abstract virtual EtlType get_EtlType();
    public abstract virtual bool UsingEncryptedCommunicationChannel();
    [CompilerGeneratedAttribute]
public bool get_AllowEtlOnNonEncryptedChannel();
    [CompilerGeneratedAttribute]
public void set_AllowEtlOnNonEncryptedChannel(bool value);
    public sealed virtual ulong GetTaskKey();
    public sealed virtual string GetMentorNode();
    public abstract virtual string GetDefaultTaskName();
    public sealed virtual string GetTaskName();
    public sealed virtual bool IsResourceIntensive();
    public sealed virtual bool IsPinnedToMentorNode();
    public virtual string ToString();
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToAuditJson();
    internal EtlConfigurationCompareDifferences Compare(EtlConfiguration`1<T> config, List`1<ValueTuple`2<string, EtlConfigurationCompareDifferences>> transformationDiffs);
    public static EtlType GetEtlType(BlittableJsonReaderObject etlConfiguration);
}
[FlagsAttribute]
internal enum Raven.Client.Documents.Operations.ETL.EtlConfigurationCompareDifferences : Enum {
    public int value__;
    public static EtlConfigurationCompareDifferences None;
    public static EtlConfigurationCompareDifferences TransformationsCount;
    public static EtlConfigurationCompareDifferences TransformationCollectionsCount;
    public static EtlConfigurationCompareDifferences TransformationName;
    public static EtlConfigurationCompareDifferences TransformationScript;
    public static EtlConfigurationCompareDifferences TransformationApplyToAllDocuments;
    public static EtlConfigurationCompareDifferences TransformationDisabled;
    public static EtlConfigurationCompareDifferences ConnectionStringName;
    public static EtlConfigurationCompareDifferences ConfigurationName;
    public static EtlConfigurationCompareDifferences MentorNode;
    public static EtlConfigurationCompareDifferences ConfigurationDisabled;
    public static EtlConfigurationCompareDifferences TransformationDocumentIdPostfix;
}
public class Raven.Client.Documents.Operations.ETL.EtlProcessState : object {
    [CompilerGeneratedAttribute]
private string <ConfigurationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TransformationName>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, long> <LastProcessedEtagPerDbId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <SkippedTimeSeriesDocs>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastBatchTime>k__BackingField;
    public string ConfigurationName { get; public set; }
    public string TransformationName { get; public set; }
    public Dictionary`2<string, long> LastProcessedEtagPerDbId { get; public set; }
    public string ChangeVector { get; public set; }
    public string NodeTag { get; public set; }
    public HashSet`1<string> SkippedTimeSeriesDocs { get; public set; }
    public Nullable`1<DateTime> LastBatchTime { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ConfigurationName();
    [CompilerGeneratedAttribute]
public void set_ConfigurationName(string value);
    [CompilerGeneratedAttribute]
public string get_TransformationName();
    [CompilerGeneratedAttribute]
public void set_TransformationName(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, long> get_LastProcessedEtagPerDbId();
    [CompilerGeneratedAttribute]
public void set_LastProcessedEtagPerDbId(Dictionary`2<string, long> value);
    [CompilerGeneratedAttribute]
public string get_ChangeVector();
    [CompilerGeneratedAttribute]
public void set_ChangeVector(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_NodeTag();
    [CompilerGeneratedAttribute]
public void set_NodeTag(string value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_SkippedTimeSeriesDocs();
    [CompilerGeneratedAttribute]
public void set_SkippedTimeSeriesDocs(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastBatchTime();
    [CompilerGeneratedAttribute]
public void set_LastBatchTime(Nullable`1<DateTime> value);
    public long GetLastProcessedEtag(string dbId, string nodeTag);
    public DynamicJsonValue ToJson();
    public static string GenerateItemName(string databaseName, string configurationName, string transformationName);
}
public enum Raven.Client.Documents.Operations.ETL.EtlType : Enum {
    public int value__;
    public static EtlType Raven;
    public static EtlType Sql;
    public static EtlType Olap;
    public static EtlType ElasticSearch;
    public static EtlType Queue;
}
public class Raven.Client.Documents.Operations.ETL.OLAP.OlapConnectionString : ConnectionString {
    [CompilerGeneratedAttribute]
private LocalSettings <LocalSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private S3Settings <S3Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private AzureSettings <AzureSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private GlacierSettings <GlacierSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private GoogleCloudSettings <GoogleCloudSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private FtpSettings <FtpSettings>k__BackingField;
    private static string DestinationFormat;
    public ConnectionStringType Type { get; }
    public LocalSettings LocalSettings { get; public set; }
    public S3Settings S3Settings { get; public set; }
    public AzureSettings AzureSettings { get; public set; }
    public GlacierSettings GlacierSettings { get; public set; }
    public GoogleCloudSettings GoogleCloudSettings { get; public set; }
    public FtpSettings FtpSettings { get; public set; }
    public virtual ConnectionStringType get_Type();
    [CompilerGeneratedAttribute]
public LocalSettings get_LocalSettings();
    [CompilerGeneratedAttribute]
public void set_LocalSettings(LocalSettings value);
    [CompilerGeneratedAttribute]
public S3Settings get_S3Settings();
    [CompilerGeneratedAttribute]
public void set_S3Settings(S3Settings value);
    [CompilerGeneratedAttribute]
public AzureSettings get_AzureSettings();
    [CompilerGeneratedAttribute]
public void set_AzureSettings(AzureSettings value);
    [CompilerGeneratedAttribute]
public GlacierSettings get_GlacierSettings();
    [CompilerGeneratedAttribute]
public void set_GlacierSettings(GlacierSettings value);
    [CompilerGeneratedAttribute]
public GoogleCloudSettings get_GoogleCloudSettings();
    [CompilerGeneratedAttribute]
public void set_GoogleCloudSettings(GoogleCloudSettings value);
    [CompilerGeneratedAttribute]
public FtpSettings get_FtpSettings();
    [CompilerGeneratedAttribute]
public void set_FtpSettings(FtpSettings value);
    protected virtual void ValidateImpl(List`1& errors);
    internal string GetDestination();
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToAuditJson();
}
public class Raven.Client.Documents.Operations.ETL.OLAP.OlapEtlConfiguration : EtlConfiguration`1<OlapConnectionString> {
    [CompilerGeneratedAttribute]
private string <RunFrequency>k__BackingField;
    [CompilerGeneratedAttribute]
private OlapEtlFileFormat <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CustomPartitionValue>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<OlapEtlTable> <OlapTables>k__BackingField;
    private string _name;
    private static string Sftp;
    private static string Ftps;
    public string RunFrequency { get; public set; }
    public OlapEtlFileFormat Format { get; public set; }
    public string CustomPartitionValue { get; public set; }
    public List`1<OlapEtlTable> OlapTables { get; public set; }
    public EtlType EtlType { get; }
    [CompilerGeneratedAttribute]
public string get_RunFrequency();
    [CompilerGeneratedAttribute]
public void set_RunFrequency(string value);
    [CompilerGeneratedAttribute]
public OlapEtlFileFormat get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(OlapEtlFileFormat value);
    [CompilerGeneratedAttribute]
public string get_CustomPartitionValue();
    [CompilerGeneratedAttribute]
public void set_CustomPartitionValue(string value);
    [CompilerGeneratedAttribute]
public List`1<OlapEtlTable> get_OlapTables();
    [CompilerGeneratedAttribute]
public void set_OlapTables(List`1<OlapEtlTable> value);
    public virtual string GetDestination();
    public virtual EtlType get_EtlType();
    public virtual bool UsingEncryptedCommunicationChannel();
    public virtual string GetDefaultTaskName();
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToAuditJson();
    internal bool Equals(OlapEtlConfiguration other);
}
public enum Raven.Client.Documents.Operations.ETL.OLAP.OlapEtlFileFormat : Enum {
    public int value__;
    public static OlapEtlFileFormat Parquet;
}
public class Raven.Client.Documents.Operations.ETL.OLAP.OlapEtlTable : object {
    [CompilerGeneratedAttribute]
private string <TableName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DocumentIdColumn>k__BackingField;
    public string TableName { get; public set; }
    public string DocumentIdColumn { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TableName();
    [CompilerGeneratedAttribute]
public void set_TableName(string value);
    [CompilerGeneratedAttribute]
public string get_DocumentIdColumn();
    [CompilerGeneratedAttribute]
public void set_DocumentIdColumn(string value);
    private bool Equals(OlapEtlTable other);
    public DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.ETL.Queue.AzureQueueStorageConnectionSettings : object {
    [CompilerGeneratedAttribute]
private EntraId <EntraId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionString>k__BackingField;
    [CompilerGeneratedAttribute]
private Passwordless <Passwordless>k__BackingField;
    public EntraId EntraId { get; public set; }
    public string ConnectionString { get; public set; }
    public Passwordless Passwordless { get; public set; }
    [CompilerGeneratedAttribute]
public EntraId get_EntraId();
    [CompilerGeneratedAttribute]
public void set_EntraId(EntraId value);
    [CompilerGeneratedAttribute]
public string get_ConnectionString();
    [CompilerGeneratedAttribute]
public void set_ConnectionString(string value);
    [CompilerGeneratedAttribute]
public Passwordless get_Passwordless();
    [CompilerGeneratedAttribute]
public void set_Passwordless(Passwordless value);
    public bool IsValidConnection();
    private bool IsOnlyOneConnectionProvided();
    public string GetStorageUrl();
    private string GetUrlFromConnectionString(string connectionString);
    private string GetStorageAccountName();
    private void ThrowConnectionStringError(string message);
    public DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.ETL.Queue.EntraId : object {
    [CompilerGeneratedAttribute]
private string <StorageAccountName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientSecret>k__BackingField;
    public string StorageAccountName { get; public set; }
    public string TenantId { get; public set; }
    public string ClientId { get; public set; }
    public string ClientSecret { get; public set; }
    [CompilerGeneratedAttribute]
public string get_StorageAccountName();
    [CompilerGeneratedAttribute]
public void set_StorageAccountName(string value);
    [CompilerGeneratedAttribute]
public string get_TenantId();
    [CompilerGeneratedAttribute]
public void set_TenantId(string value);
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public void set_ClientId(string value);
    [CompilerGeneratedAttribute]
public string get_ClientSecret();
    [CompilerGeneratedAttribute]
public void set_ClientSecret(string value);
    public bool IsValid();
}
public class Raven.Client.Documents.Operations.ETL.Queue.EtlQueue : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DeleteProcessedDocuments>k__BackingField;
    public string Name { get; public set; }
    public bool DeleteProcessedDocuments { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_DeleteProcessedDocuments();
    [CompilerGeneratedAttribute]
public void set_DeleteProcessedDocuments(bool value);
    public DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.ETL.Queue.KafkaConnectionSettings : object {
    [CompilerGeneratedAttribute]
private string <BootstrapServers>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <ConnectionOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseRavenCertificate>k__BackingField;
    public string BootstrapServers { get; public set; }
    public Dictionary`2<string, string> ConnectionOptions { get; public set; }
    public bool UseRavenCertificate { get; public set; }
    [CompilerGeneratedAttribute]
public string get_BootstrapServers();
    [CompilerGeneratedAttribute]
public void set_BootstrapServers(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_ConnectionOptions();
    [CompilerGeneratedAttribute]
public void set_ConnectionOptions(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public bool get_UseRavenCertificate();
    [CompilerGeneratedAttribute]
public void set_UseRavenCertificate(bool value);
    public DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.ETL.Queue.Passwordless : object {
    [CompilerGeneratedAttribute]
private string <StorageAccountName>k__BackingField;
    public string StorageAccountName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_StorageAccountName();
    [CompilerGeneratedAttribute]
public void set_StorageAccountName(string value);
    public bool IsValid();
}
public enum Raven.Client.Documents.Operations.ETL.Queue.QueueBrokerType : Enum {
    public int value__;
    public static QueueBrokerType None;
    public static QueueBrokerType Kafka;
    public static QueueBrokerType RabbitMq;
    public static QueueBrokerType AzureQueueStorage;
}
public class Raven.Client.Documents.Operations.ETL.Queue.QueueConnectionString : ConnectionString {
    [CompilerGeneratedAttribute]
private QueueBrokerType <BrokerType>k__BackingField;
    [CompilerGeneratedAttribute]
private KafkaConnectionSettings <KafkaConnectionSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private RabbitMqConnectionSettings <RabbitMqConnectionSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private AzureQueueStorageConnectionSettings <AzureQueueStorageConnectionSettings>k__BackingField;
    public QueueBrokerType BrokerType { get; public set; }
    public KafkaConnectionSettings KafkaConnectionSettings { get; public set; }
    public RabbitMqConnectionSettings RabbitMqConnectionSettings { get; public set; }
    public AzureQueueStorageConnectionSettings AzureQueueStorageConnectionSettings { get; public set; }
    public ConnectionStringType Type { get; }
    [CompilerGeneratedAttribute]
public QueueBrokerType get_BrokerType();
    [CompilerGeneratedAttribute]
public void set_BrokerType(QueueBrokerType value);
    [CompilerGeneratedAttribute]
public KafkaConnectionSettings get_KafkaConnectionSettings();
    [CompilerGeneratedAttribute]
public void set_KafkaConnectionSettings(KafkaConnectionSettings value);
    [CompilerGeneratedAttribute]
public RabbitMqConnectionSettings get_RabbitMqConnectionSettings();
    [CompilerGeneratedAttribute]
public void set_RabbitMqConnectionSettings(RabbitMqConnectionSettings value);
    [CompilerGeneratedAttribute]
public AzureQueueStorageConnectionSettings get_AzureQueueStorageConnectionSettings();
    [CompilerGeneratedAttribute]
public void set_AzureQueueStorageConnectionSettings(AzureQueueStorageConnectionSettings value);
    public virtual ConnectionStringType get_Type();
    protected virtual void ValidateImpl(List`1& errors);
    internal string GetUrl();
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToAuditJson();
}
public class Raven.Client.Documents.Operations.ETL.Queue.QueueEtlConfiguration : EtlConfiguration`1<QueueConnectionString> {
    [CompilerGeneratedAttribute]
private List`1<EtlQueue> <Queues>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueBrokerType <BrokerType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipAutomaticQueueDeclaration>k__BackingField;
    public List`1<EtlQueue> Queues { get; public set; }
    public QueueBrokerType BrokerType { get; public set; }
    public bool SkipAutomaticQueueDeclaration { get; public set; }
    public EtlType EtlType { get; }
    [CompilerGeneratedAttribute]
public List`1<EtlQueue> get_Queues();
    [CompilerGeneratedAttribute]
public void set_Queues(List`1<EtlQueue> value);
    [CompilerGeneratedAttribute]
public QueueBrokerType get_BrokerType();
    [CompilerGeneratedAttribute]
public void set_BrokerType(QueueBrokerType value);
    [CompilerGeneratedAttribute]
public bool get_SkipAutomaticQueueDeclaration();
    [CompilerGeneratedAttribute]
public void set_SkipAutomaticQueueDeclaration(bool value);
    public virtual bool Validate(List`1& errors, bool validateName, bool validateConnection);
    public virtual string GetDestination();
    public virtual EtlType get_EtlType();
    public virtual bool UsingEncryptedCommunicationChannel();
    public virtual string GetDefaultTaskName();
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToAuditJson();
}
public class Raven.Client.Documents.Operations.ETL.Queue.RabbitMqConnectionSettings : object {
    [CompilerGeneratedAttribute]
private string <ConnectionString>k__BackingField;
    public string ConnectionString { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ConnectionString();
    [CompilerGeneratedAttribute]
public void set_ConnectionString(string value);
    public DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.ETL.RavenConnectionString : ConnectionString {
    [CompilerGeneratedAttribute]
private string <Database>k__BackingField;
    public String[] TopologyDiscoveryUrls;
    public string Database { get; public set; }
    public ConnectionStringType Type { get; }
    [CompilerGeneratedAttribute]
public string get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(string value);
    public virtual ConnectionStringType get_Type();
    protected virtual void ValidateImpl(List`1& errors);
    public virtual bool IsEqual(ConnectionString connectionString);
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToAuditJson();
}
public class Raven.Client.Documents.Operations.ETL.RavenEtlConfiguration : EtlConfiguration`1<RavenConnectionString> {
    private string _destination;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LoadRequestTimeoutInSec>k__BackingField;
    public Nullable`1<int> LoadRequestTimeoutInSec { get; public set; }
    public EtlType EtlType { get; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LoadRequestTimeoutInSec();
    [CompilerGeneratedAttribute]
public void set_LoadRequestTimeoutInSec(Nullable`1<int> value);
    public virtual EtlType get_EtlType();
    public virtual string GetDestination();
    public virtual bool UsingEncryptedCommunicationChannel();
    public virtual string GetDefaultTaskName();
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToAuditJson();
}
public class Raven.Client.Documents.Operations.ETL.ResetEtlOperation : object {
    private string _configurationName;
    private string _transformationName;
    public ResetEtlOperation(string configurationName, string transformationName);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.ETL.SQL.SqlConnectionString : ConnectionString {
    [CompilerGeneratedAttribute]
private string <ConnectionString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FactoryName>k__BackingField;
    public string ConnectionString { get; public set; }
    public string FactoryName { get; public set; }
    public ConnectionStringType Type { get; }
    [CompilerGeneratedAttribute]
public string get_ConnectionString();
    [CompilerGeneratedAttribute]
public void set_ConnectionString(string value);
    [CompilerGeneratedAttribute]
public string get_FactoryName();
    [CompilerGeneratedAttribute]
public void set_FactoryName(string value);
    public virtual ConnectionStringType get_Type();
    protected virtual void ValidateImpl(List`1& errors);
    public virtual bool IsEqual(ConnectionString connectionString);
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToAuditJson();
}
internal static class Raven.Client.Documents.Operations.ETL.SQL.SqlConnectionStringParser : object {
    internal static ValueTuple`2<string, string> GetDatabaseAndServerFromConnectionString(string factoryName, string connectionString);
    public static string GetConnectionStringValue(string connectionString, String[] keyNames);
    internal static string GetOracleDataSourceSubValue(string dataSourceValue, string key);
}
public class Raven.Client.Documents.Operations.ETL.SQL.SqlEtlConfiguration : EtlConfiguration`1<SqlConnectionString> {
    private string _name;
    [CompilerGeneratedAttribute]
private bool <ParameterizeDeletes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceQueryRecompile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <QuoteTables>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <CommandTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SqlEtlTable> <SqlTables>k__BackingField;
    public bool ParameterizeDeletes { get; public set; }
    public bool ForceQueryRecompile { get; public set; }
    public bool QuoteTables { get; public set; }
    public Nullable`1<int> CommandTimeout { get; public set; }
    public List`1<SqlEtlTable> SqlTables { get; public set; }
    public EtlType EtlType { get; }
    [CompilerGeneratedAttribute]
public bool get_ParameterizeDeletes();
    [CompilerGeneratedAttribute]
public void set_ParameterizeDeletes(bool value);
    [CompilerGeneratedAttribute]
public bool get_ForceQueryRecompile();
    [CompilerGeneratedAttribute]
public void set_ForceQueryRecompile(bool value);
    [CompilerGeneratedAttribute]
public bool get_QuoteTables();
    [CompilerGeneratedAttribute]
public void set_QuoteTables(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_CommandTimeout();
    [CompilerGeneratedAttribute]
public void set_CommandTimeout(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public List`1<SqlEtlTable> get_SqlTables();
    [CompilerGeneratedAttribute]
public void set_SqlTables(List`1<SqlEtlTable> value);
    public virtual EtlType get_EtlType();
    public virtual bool Validate(List`1& errors, bool validateName, bool validateConnection);
    public virtual string GetDestination();
    public virtual bool UsingEncryptedCommunicationChannel();
    public virtual string GetDefaultTaskName();
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToAuditJson();
}
public class Raven.Client.Documents.Operations.ETL.SQL.SqlEtlTable : object {
    [CompilerGeneratedAttribute]
private string <TableName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DocumentIdColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InsertOnlyMode>k__BackingField;
    public string TableName { get; public set; }
    public string DocumentIdColumn { get; public set; }
    public bool InsertOnlyMode { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TableName();
    [CompilerGeneratedAttribute]
public void set_TableName(string value);
    [CompilerGeneratedAttribute]
public string get_DocumentIdColumn();
    [CompilerGeneratedAttribute]
public void set_DocumentIdColumn(string value);
    [CompilerGeneratedAttribute]
public bool get_InsertOnlyMode();
    [CompilerGeneratedAttribute]
public void set_InsertOnlyMode(bool value);
    protected bool Equals(SqlEtlTable other);
    public DynamicJsonValue ToJson();
}
public enum Raven.Client.Documents.Operations.ETL.SQL.SqlProvider : Enum {
    public int value__;
    public static SqlProvider SqlClient;
    public static SqlProvider Npgsql;
    public static SqlProvider OleDb;
    public static SqlProvider OracleClient;
    public static SqlProvider MySqlClient;
    public static SqlProvider MySqlConnectorFactory;
}
internal class Raven.Client.Documents.Operations.ETL.SQL.SqlProviderParser : object {
    public static SqlProvider GetSupportedProvider(string factoryName);
}
public class Raven.Client.Documents.Operations.ETL.Transformation : object {
    internal static string LoadTo;
    internal static string LoadAttachment;
    internal static string AddAttachment;
    internal static string AttachmentMarker;
    internal static string GenericDeleteDocumentsBehaviorFunctionKey;
    internal static string GenericDeleteDocumentsBehaviorFunctionName;
    private static Regex LoadToMethodRegex;
    private static Regex LoadToMethodRegexAlt;
    private static Regex LoadAttachmentMethodRegex;
    private static Regex AddAttachmentMethodRegex;
    internal CountersTransformation Counters;
    internal TimeSeriesTransformation TimeSeries;
    private static string ParametersAndFunctionBodyRegex;
    internal static Regex DeleteDocumentsBehaviorMethodRegex;
    internal static Regex DeleteDocumentsBehaviorMethodNameRegex;
    internal static Regex GenericDeleteDocumentsBehaviorMethodRegex;
    private static Regex Legacy_ReplicateToMethodRegex;
    private String[] _collections;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Collections>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ApplyToAllDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Script>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEmptyScript>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <CollectionToDeleteDocumentsBehaviorFunction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAddingAttachments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLoadingAttachments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DocumentIdPostfix>k__BackingField;
    public string Name { get; public set; }
    public bool Disabled { get; public set; }
    public List`1<string> Collections { get; public set; }
    public bool ApplyToAllDocuments { get; public set; }
    public string Script { get; public set; }
    internal bool IsEmptyScript { get; internal set; }
    internal Dictionary`2<string, string> CollectionToDeleteDocumentsBehaviorFunction { get; private set; }
    internal bool IsAddingAttachments { get; private set; }
    internal bool IsLoadingAttachments { get; private set; }
    public string DocumentIdPostfix { get; public set; }
    private static Transformation();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Collections();
    [CompilerGeneratedAttribute]
public void set_Collections(List`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_ApplyToAllDocuments();
    [CompilerGeneratedAttribute]
public void set_ApplyToAllDocuments(bool value);
    [CompilerGeneratedAttribute]
public string get_Script();
    [CompilerGeneratedAttribute]
public void set_Script(string value);
    [CompilerGeneratedAttribute]
internal bool get_IsEmptyScript();
    [CompilerGeneratedAttribute]
internal void set_IsEmptyScript(bool value);
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, string> get_CollectionToDeleteDocumentsBehaviorFunction();
    [CompilerGeneratedAttribute]
private void set_CollectionToDeleteDocumentsBehaviorFunction(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
internal bool get_IsAddingAttachments();
    [CompilerGeneratedAttribute]
private void set_IsAddingAttachments(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsLoadingAttachments();
    [CompilerGeneratedAttribute]
private void set_IsLoadingAttachments(bool value);
    [CompilerGeneratedAttribute]
public string get_DocumentIdPostfix();
    [CompilerGeneratedAttribute]
public void set_DocumentIdPostfix(string value);
    public bool Validate(List`1& errors, EtlType type);
    public DynamicJsonValue ToJson();
    internal EtlConfigurationCompareDifferences Compare(Transformation transformation);
    public String[] GetCollectionsFromScript();
}
public class Raven.Client.Documents.Operations.ETL.UpdateEtlOperation`1 : object {
    private long _taskId;
    private EtlConfiguration`1<T> _configuration;
    public UpdateEtlOperation`1(long taskId, EtlConfiguration`1<T> configuration);
    public sealed virtual RavenCommand`1<UpdateEtlOperationResult> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.Documents.Operations.ETL.UpdateEtlOperationResult : object {
    [CompilerGeneratedAttribute]
private long <RaftCommandIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TaskId>k__BackingField;
    public long RaftCommandIndex { get; public set; }
    public long TaskId { get; public set; }
    [CompilerGeneratedAttribute]
public long get_RaftCommandIndex();
    [CompilerGeneratedAttribute]
public void set_RaftCommandIndex(long value);
    [CompilerGeneratedAttribute]
public long get_TaskId();
    [CompilerGeneratedAttribute]
public void set_TaskId(long value);
}
public class Raven.Client.Documents.Operations.Expiration.ConfigureExpirationOperation : object {
    private ExpirationConfiguration _configuration;
    public ConfigureExpirationOperation(ExpirationConfiguration configuration);
    public sealed virtual RavenCommand`1<ConfigureExpirationOperationResult> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.Documents.Operations.Expiration.ConfigureExpirationOperationResult : object {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <RaftCommandIndex>k__BackingField;
    public Nullable`1<long> RaftCommandIndex { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_RaftCommandIndex();
    [CompilerGeneratedAttribute]
public void set_RaftCommandIndex(Nullable`1<long> value);
}
public class Raven.Client.Documents.Operations.Expiration.ExpirationConfiguration : object {
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <DeleteFrequencyInSec>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MaxItemsToProcess>k__BackingField;
    public bool Disabled { get; public set; }
    public Nullable`1<long> DeleteFrequencyInSec { get; public set; }
    public Nullable`1<long> MaxItemsToProcess { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_DeleteFrequencyInSec();
    [CompilerGeneratedAttribute]
public void set_DeleteFrequencyInSec(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MaxItemsToProcess();
    [CompilerGeneratedAttribute]
public void set_MaxItemsToProcess(Nullable`1<long> value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private bool Equals(ExpirationConfiguration other);
    public sealed virtual DynamicJsonValue ToJson();
}
internal class Raven.Client.Documents.Operations.GetCertificatesMetadataResponse : ResultsResponse`1<CertificateMetadata> {
}
internal class Raven.Client.Documents.Operations.GetCertificatesResponse : ResultsResponse`1<CertificateDefinition> {
}
public class Raven.Client.Documents.Operations.GetCollectionStatisticsOperation : object {
    public sealed virtual RavenCommand`1<CollectionStatistics> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.GetDetailedCollectionStatisticsOperation : object {
    public sealed virtual RavenCommand`1<DetailedCollectionStatistics> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.GetDetailedStatisticsOperation : object {
    private string _debugTag;
    internal GetDetailedStatisticsOperation(string debugTag);
    public sealed virtual RavenCommand`1<DetailedDatabaseStatistics> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.GetEssentialStatisticsOperation : object {
    private string _debugTag;
    internal GetEssentialStatisticsOperation(string debugTag);
    public sealed virtual RavenCommand`1<EssentialDatabaseStatistics> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
internal class Raven.Client.Documents.Operations.GetIndexesResponse : ResultsResponse`1<IndexDefinition> {
}
internal class Raven.Client.Documents.Operations.GetIndexNamesResponse : ResultsResponse`1<string> {
}
internal class Raven.Client.Documents.Operations.GetIndexStatisticsResponse : ResultsResponse`1<IndexStats> {
}
public class Raven.Client.Documents.Operations.GetOperationStateOperation : object {
    private long _id;
    private string _nodeTag;
    public GetOperationStateOperation(long id);
    public GetOperationStateOperation(long id, string nodeTag);
    public sealed virtual RavenCommand`1<OperationState> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
internal class Raven.Client.Documents.Operations.GetServerWideBackupConfigurationsResponse : ResultsResponse`1<ServerWideBackupConfiguration> {
}
internal class Raven.Client.Documents.Operations.GetServerWideExternalReplicationsResponse : ResultsResponse`1<ServerWideExternalReplication> {
}
public class Raven.Client.Documents.Operations.GetStatisticsOperation : object {
    private string _debugTag;
    private string _nodeTag;
    internal GetStatisticsOperation(string debugTag, string nodeTag);
    public sealed virtual RavenCommand`1<DatabaseStatistics> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public interface Raven.Client.Documents.Operations.IBulkOperationDetails {
    public abstract virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.Identities.GetIdentitiesOperation : object {
    public sealed virtual RavenCommand`1<Dictionary`2<string, long>> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Identities.NextIdentityForOperation : object {
    private string _identityName;
    public NextIdentityForOperation(string name);
    public sealed virtual RavenCommand`1<long> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Identities.SeedIdentityForOperation : object {
    private string _identityName;
    private long _identityValue;
    private bool _forceUpdate;
    public SeedIdentityForOperation(string name, long value, bool forceUpdate);
    public sealed virtual RavenCommand`1<long> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public interface Raven.Client.Documents.Operations.IMaintenanceOperation {
    public abstract virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public interface Raven.Client.Documents.Operations.IMaintenanceOperation`1 {
    public abstract virtual RavenCommand`1<T> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.IndeterminateProgress : object {
    [CompilerGeneratedAttribute]
private string <Progress>k__BackingField;
    public string Progress { get; public set; }
    private bool Raven.Client.Documents.Operations.IOperationProgress.CanMerge { get; }
    [CompilerGeneratedAttribute]
public string get_Progress();
    [CompilerGeneratedAttribute]
public void set_Progress(string value);
    public sealed virtual DynamicJsonValue ToJson();
    private sealed virtual override IOperationProgress Raven.Client.Documents.Operations.IOperationProgress.Clone();
    private sealed virtual override bool Raven.Client.Documents.Operations.IOperationProgress.get_CanMerge();
    private sealed virtual override void Raven.Client.Documents.Operations.IOperationProgress.MergeWith(IOperationProgress progress);
}
public class Raven.Client.Documents.Operations.IndeterminateProgressCount : object {
    [CompilerGeneratedAttribute]
private long <Processed>k__BackingField;
    public long Processed { get; public set; }
    private bool Raven.Client.Documents.Operations.IOperationProgress.CanMerge { get; }
    [CompilerGeneratedAttribute]
public long get_Processed();
    [CompilerGeneratedAttribute]
public void set_Processed(long value);
    public sealed virtual DynamicJsonValue ToJson();
    private sealed virtual override IOperationProgress Raven.Client.Documents.Operations.IOperationProgress.Clone();
    private sealed virtual override bool Raven.Client.Documents.Operations.IOperationProgress.get_CanMerge();
    private sealed virtual override void Raven.Client.Documents.Operations.IOperationProgress.MergeWith(IOperationProgress progress);
}
public class Raven.Client.Documents.Operations.Indexes.DeleteIndexErrorsOperation : object {
    private String[] _indexNames;
    public DeleteIndexErrorsOperation(String[] indexNames);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Indexes.DeleteIndexOperation : object {
    private string _indexName;
    public DeleteIndexOperation(string indexName);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Indexes.DisableIndexOperation : object {
    private string _indexName;
    private bool _clusterWide;
    public DisableIndexOperation(string indexName);
    public DisableIndexOperation(string indexName, bool clusterWide);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Indexes.EnableIndexOperation : object {
    private string _indexName;
    private bool _clusterWide;
    public EnableIndexOperation(string indexName);
    public EnableIndexOperation(string indexName, bool clusterWide);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Indexes.GetIndexErrorsOperation : object {
    private String[] _indexNames;
    private string _nodeTag;
    public GetIndexErrorsOperation(String[] indexNames);
    internal GetIndexErrorsOperation(String[] indexNames, string nodeTag);
    public sealed virtual RavenCommand`1<IndexErrors[]> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Indexes.GetIndexesOperation : object {
    private int _start;
    private int _pageSize;
    public GetIndexesOperation(int start, int pageSize);
    public sealed virtual RavenCommand`1<IndexDefinition[]> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Indexes.GetIndexesStatisticsOperation : object {
    public sealed virtual RavenCommand`1<IndexStats[]> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Indexes.GetIndexingStatusOperation : object {
    public sealed virtual RavenCommand`1<IndexingStatus> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Indexes.GetIndexNamesOperation : object {
    private int _start;
    private int _pageSize;
    public GetIndexNamesOperation(int start, int pageSize);
    public sealed virtual RavenCommand`1<String[]> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Indexes.GetIndexOperation : object {
    private string _indexName;
    public GetIndexOperation(string indexName);
    public sealed virtual RavenCommand`1<IndexDefinition> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Indexes.GetIndexPerformanceStatisticsOperation : object {
    private String[] _indexNames;
    public GetIndexPerformanceStatisticsOperation(String[] indexNames);
    public sealed virtual RavenCommand`1<IndexPerformanceStats[]> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Indexes.GetIndexStatisticsOperation : object {
    private string _indexName;
    public GetIndexStatisticsOperation(string indexName);
    public sealed virtual RavenCommand`1<IndexStats> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Indexes.GetTermsOperation : object {
    private string _indexName;
    private string _field;
    private string _fromValue;
    private Nullable`1<int> _pageSize;
    public GetTermsOperation(string indexName, string field, string fromValue, Nullable`1<int> pageSize);
    public sealed virtual RavenCommand`1<String[]> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Indexes.IndexHasChangedOperation : object {
    private IndexDefinition _definition;
    public IndexHasChangedOperation(IndexDefinition definition);
    public sealed virtual RavenCommand`1<bool> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Indexes.PutIndexesOperation : object {
    private IndexDefinition[] _indexToAdd;
    public PutIndexesOperation(IndexDefinition[] indexToAdd);
    public sealed virtual RavenCommand`1<PutIndexResult[]> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Indexes.ResetIndexOperation : object {
    private string _indexName;
    private Nullable`1<IndexResetMode> _indexResetMode;
    public ResetIndexOperation(string indexName);
    public ResetIndexOperation(string indexName, IndexResetMode indexResetMode);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Indexes.SetIndexesLockOperation : object {
    private Parameters _parameters;
    public SetIndexesLockOperation(string indexName, IndexLockMode mode);
    public SetIndexesLockOperation(Parameters parameters);
    private void FilterAutoIndexes();
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Indexes.SetIndexesPriorityOperation : object {
    private Parameters _parameters;
    public SetIndexesPriorityOperation(string indexName, IndexPriority priority);
    public SetIndexesPriorityOperation(Parameters parameters);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Indexes.StartIndexingOperation : object {
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Indexes.StartIndexOperation : object {
    private string _indexName;
    public StartIndexOperation(string indexName);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Indexes.StopIndexingOperation : object {
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Indexes.StopIndexOperation : object {
    private string _indexName;
    public StopIndexOperation(string indexName);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.IndexInformation : EssentialIndexInformation {
    [CompilerGeneratedAttribute]
private bool <IsStale>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastIndexingTime>k__BackingField;
    public bool IsStale { get; public set; }
    public IndexState State { get; public set; }
    public Nullable`1<DateTime> LastIndexingTime { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsStale();
    [CompilerGeneratedAttribute]
public void set_IsStale(bool value);
    [CompilerGeneratedAttribute]
public IndexState get_State();
    [CompilerGeneratedAttribute]
public void set_State(IndexState value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastIndexingTime();
    [CompilerGeneratedAttribute]
public void set_LastIndexingTime(Nullable`1<DateTime> value);
}
public class Raven.Client.Documents.Operations.Integrations.PostgreSQL.ConfigurePostgreSqlOperation : object {
    private PostgreSqlConfiguration _configuration;
    public ConfigurePostgreSqlOperation(PostgreSqlConfiguration configuration);
    public sealed virtual RavenCommand`1<ConfigurePostgreSqlOperationResult> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.Documents.Operations.Integrations.PostgreSQL.ConfigurePostgreSqlOperationResult : object {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <RaftCommandIndex>k__BackingField;
    public Nullable`1<long> RaftCommandIndex { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_RaftCommandIndex();
    [CompilerGeneratedAttribute]
public void set_RaftCommandIndex(Nullable`1<long> value);
}
public interface Raven.Client.Documents.Operations.IOperation {
    public abstract virtual RavenCommand GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
}
public interface Raven.Client.Documents.Operations.IOperation`1 {
    public abstract virtual RavenCommand`1<T> GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
}
public interface Raven.Client.Documents.Operations.IOperationDetailedDescription {
    public abstract virtual DynamicJsonValue ToJson();
}
public interface Raven.Client.Documents.Operations.IOperationProgress {
    public bool CanMerge { get; }
    public abstract virtual DynamicJsonValue ToJson();
    public abstract virtual IOperationProgress Clone();
    public abstract virtual bool get_CanMerge();
    public abstract virtual void MergeWith(IOperationProgress progress);
}
public interface Raven.Client.Documents.Operations.IOperationResult {
    public string Message { get; }
    public bool ShouldPersist { get; }
    public bool CanMerge { get; }
    public abstract virtual string get_Message();
    public abstract virtual DynamicJsonValue ToJson();
    public abstract virtual bool get_ShouldPersist();
    public abstract virtual bool get_CanMerge();
    public abstract virtual void MergeWith(IOperationResult result);
}
public interface Raven.Client.Documents.Operations.IShardedOperationProgress {
    public int ShardNumber { get; public set; }
    public string NodeTag { get; public set; }
    public abstract virtual int get_ShardNumber();
    public abstract virtual void set_ShardNumber(int value);
    public abstract virtual string get_NodeTag();
    public abstract virtual void set_NodeTag(string value);
    public abstract virtual void Fill(IOperationProgress progress, int shardNumber, string nodeTag);
}
public interface Raven.Client.Documents.Operations.IShardedOperationResult {
    public abstract virtual void CombineWith(IOperationResult result, int shardNumber, string nodeTag);
}
public interface Raven.Client.Documents.Operations.IShardedOperationResult`1 {
    public List`1<TResult> Results { get; public set; }
    public abstract virtual List`1<TResult> get_Results();
    public abstract virtual void set_Results(List`1<TResult> value);
}
public interface Raven.Client.Documents.Operations.IShardNodeOperationResult`1 {
    public int ShardNumber { get; public set; }
    public string NodeTag { get; public set; }
    public TResult Result { get; public set; }
    public abstract virtual int get_ShardNumber();
    public abstract virtual void set_ShardNumber(int value);
    public abstract virtual string get_NodeTag();
    public abstract virtual void set_NodeTag(string value);
    public abstract virtual TResult get_Result();
    public abstract virtual void set_Result(TResult value);
}
internal class Raven.Client.Documents.Operations.JsonOperation : object {
    [CompilerGeneratedAttribute]
private List`1<Operation> <Operations>k__BackingField;
    public List`1<Operation> Operations { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<Operation> get_Operations();
    [CompilerGeneratedAttribute]
public void set_Operations(List`1<Operation> value);
}
public class Raven.Client.Documents.Operations.JsonPatchOperation : object {
    public string Id;
    public JsonPatchDocument JsonPatchDocument;
    public JsonPatchOperation(string id, JsonPatchDocument jsonPatchDocument);
    public sealed virtual RavenCommand`1<JsonPatchResult> GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
}
public class Raven.Client.Documents.Operations.JsonPatchResult : PatchResultBase {
}
public class Raven.Client.Documents.Operations.MaintenanceOperationExecutor : object {
    private DocumentStoreBase _store;
    private string _nodeTag;
    private Nullable`1<int> _shardNumber;
    internal string _databaseName;
    private RequestExecutor _requestExecutor;
    private ServerOperationExecutor _serverOperationExecutor;
    private RequestExecutor RequestExecutor { get; }
    public ServerOperationExecutor Server { get; }
    internal MaintenanceOperationExecutor(DocumentStoreBase store, string databaseName, string nodeTag, Nullable`1<int> shardNumber);
    private RequestExecutor get_RequestExecutor();
    public ServerOperationExecutor get_Server();
    public MaintenanceOperationExecutor ForDatabase(string databaseName);
    public MaintenanceOperationExecutor ForNode(string nodeTag);
    public MaintenanceOperationExecutor ForShard(int shardNumber);
    internal MaintenanceOperationExecutor ForShardWithProxy(int shardNumber);
    public void Send(IMaintenanceOperation operation);
    public TResult Send(IMaintenanceOperation`1<TResult> operation);
    internal TResult Send(JsonOperationContext context, IMaintenanceOperation`1<TResult> operation);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Operations.MaintenanceOperationExecutor/<SendAsync>d__18")]
public Task SendAsync(IMaintenanceOperation operation, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Operations.MaintenanceOperationExecutor/<SendAsync>d__19`1")]
public Task`1<TResult> SendAsync(IMaintenanceOperation`1<TResult> operation, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Operations.MaintenanceOperationExecutor/<SendAsync>d__20`1")]
internal Task`1<TResult> SendAsync(JsonOperationContext context, IMaintenanceOperation`1<TResult> operation, CancellationToken token);
    public Operation Send(IMaintenanceOperation`1<OperationIdResult> operation);
    public Operation`1<TResult> Send(IMaintenanceOperation`1<OperationIdResult`1<TResult>> operation);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Operations.MaintenanceOperationExecutor/<SendAsync>d__23")]
public Task`1<Operation> SendAsync(IMaintenanceOperation`1<OperationIdResult> operation, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Operations.MaintenanceOperationExecutor/<SendAsync>d__24`1")]
public Task`1<Operation`1<TResult>> SendAsync(IMaintenanceOperation`1<OperationIdResult`1<TResult>> operation, CancellationToken token);
    private IDisposable GetContext(JsonOperationContext& context);
    private void ApplyNodeTagAndShardNumberToCommandIfSet(RavenCommand`1<T> command);
}
public class Raven.Client.Documents.Operations.OngoingTasks.DeleteOngoingTaskOperation : object {
    private long _taskId;
    private OngoingTaskType _taskType;
    public DeleteOngoingTaskOperation(long taskId, OngoingTaskType taskType);
    public sealed virtual RavenCommand`1<ModifyOngoingTaskResult> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.Documents.Operations.OngoingTasks.GetOngoingTaskInfoOperation : object {
    private string _taskName;
    private long _taskId;
    private OngoingTaskType _type;
    public GetOngoingTaskInfoOperation(long taskId, OngoingTaskType type);
    public GetOngoingTaskInfoOperation(string taskName, OngoingTaskType type);
    public sealed virtual RavenCommand`1<OngoingTask> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.Documents.Operations.OngoingTasks.GetPullReplicationTasksInfoOperation : object {
    private long _taskId;
    public GetPullReplicationTasksInfoOperation(long taskId);
    public sealed virtual RavenCommand`1<PullReplicationDefinitionAndCurrentConnections> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.Documents.Operations.OngoingTasks.ModifyOngoingTaskResult : object {
    [CompilerGeneratedAttribute]
private long <TaskId>k__BackingField;
    public long RaftCommandIndex;
    public string ResponsibleNode;
    public long TaskId { get; public set; }
    [CompilerGeneratedAttribute]
public long get_TaskId();
    [CompilerGeneratedAttribute]
public void set_TaskId(long value);
}
public class Raven.Client.Documents.Operations.OngoingTasks.NextBackup : object {
    [CompilerGeneratedAttribute]
private TimeSpan <TimeSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <DateTime>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFull>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <OriginalBackupTime>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TaskId>k__BackingField;
    public TimeSpan TimeSpan { get; public set; }
    public DateTime DateTime { get; public set; }
    public bool IsFull { get; public set; }
    public Nullable`1<DateTime> OriginalBackupTime { get; public set; }
    internal long TaskId { get; internal set; }
    [CompilerGeneratedAttribute]
public TimeSpan get_TimeSpan();
    [CompilerGeneratedAttribute]
public void set_TimeSpan(TimeSpan value);
    [CompilerGeneratedAttribute]
public DateTime get_DateTime();
    [CompilerGeneratedAttribute]
public void set_DateTime(DateTime value);
    [CompilerGeneratedAttribute]
public bool get_IsFull();
    [CompilerGeneratedAttribute]
public void set_IsFull(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_OriginalBackupTime();
    [CompilerGeneratedAttribute]
public void set_OriginalBackupTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
internal long get_TaskId();
    [CompilerGeneratedAttribute]
internal void set_TaskId(long value);
    public sealed virtual DynamicJsonValue ToJson();
}
public abstract class Raven.Client.Documents.Operations.OngoingTasks.OngoingTask : object {
    [CompilerGeneratedAttribute]
private long <TaskId>k__BackingField;
    [CompilerGeneratedAttribute]
private OngoingTaskType <TaskType>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeId <ResponsibleNode>k__BackingField;
    [CompilerGeneratedAttribute]
private OngoingTaskState <TaskState>k__BackingField;
    [CompilerGeneratedAttribute]
private OngoingTaskConnectionStatus <TaskConnectionStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TaskName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MentorNode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PinToMentorNode>k__BackingField;
    public long TaskId { get; public set; }
    public OngoingTaskType TaskType { get; protected set; }
    public NodeId ResponsibleNode { get; public set; }
    public OngoingTaskState TaskState { get; public set; }
    public OngoingTaskConnectionStatus TaskConnectionStatus { get; public set; }
    public string TaskName { get; public set; }
    public string Error { get; public set; }
    public string MentorNode { get; public set; }
    public bool PinToMentorNode { get; public set; }
    [CompilerGeneratedAttribute]
public long get_TaskId();
    [CompilerGeneratedAttribute]
public void set_TaskId(long value);
    [CompilerGeneratedAttribute]
public OngoingTaskType get_TaskType();
    [CompilerGeneratedAttribute]
protected void set_TaskType(OngoingTaskType value);
    [CompilerGeneratedAttribute]
public NodeId get_ResponsibleNode();
    [CompilerGeneratedAttribute]
public void set_ResponsibleNode(NodeId value);
    [CompilerGeneratedAttribute]
public OngoingTaskState get_TaskState();
    [CompilerGeneratedAttribute]
public void set_TaskState(OngoingTaskState value);
    [CompilerGeneratedAttribute]
public OngoingTaskConnectionStatus get_TaskConnectionStatus();
    [CompilerGeneratedAttribute]
public void set_TaskConnectionStatus(OngoingTaskConnectionStatus value);
    [CompilerGeneratedAttribute]
public string get_TaskName();
    [CompilerGeneratedAttribute]
public void set_TaskName(string value);
    [CompilerGeneratedAttribute]
public string get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(string value);
    [CompilerGeneratedAttribute]
public string get_MentorNode();
    [CompilerGeneratedAttribute]
public void set_MentorNode(string value);
    [CompilerGeneratedAttribute]
public bool get_PinToMentorNode();
    [CompilerGeneratedAttribute]
public void set_PinToMentorNode(bool value);
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.OngoingTasks.OngoingTaskBackup : OngoingTask {
    [CompilerGeneratedAttribute]
private BackupType <BackupType>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <BackupDestinations>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastFullBackup>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastIncrementalBackup>k__BackingField;
    [CompilerGeneratedAttribute]
private RunningBackup <OnGoingBackup>k__BackingField;
    [CompilerGeneratedAttribute]
private NextBackup <NextBackup>k__BackingField;
    [CompilerGeneratedAttribute]
private RetentionPolicy <RetentionPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEncrypted>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastExecutingNodeTag>k__BackingField;
    public BackupType BackupType { get; public set; }
    public List`1<string> BackupDestinations { get; public set; }
    public Nullable`1<DateTime> LastFullBackup { get; public set; }
    public Nullable`1<DateTime> LastIncrementalBackup { get; public set; }
    public RunningBackup OnGoingBackup { get; public set; }
    public NextBackup NextBackup { get; public set; }
    public RetentionPolicy RetentionPolicy { get; public set; }
    public bool IsEncrypted { get; public set; }
    public string LastExecutingNodeTag { get; public set; }
    [CompilerGeneratedAttribute]
public BackupType get_BackupType();
    [CompilerGeneratedAttribute]
public void set_BackupType(BackupType value);
    [CompilerGeneratedAttribute]
public List`1<string> get_BackupDestinations();
    [CompilerGeneratedAttribute]
public void set_BackupDestinations(List`1<string> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastFullBackup();
    [CompilerGeneratedAttribute]
public void set_LastFullBackup(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastIncrementalBackup();
    [CompilerGeneratedAttribute]
public void set_LastIncrementalBackup(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public RunningBackup get_OnGoingBackup();
    [CompilerGeneratedAttribute]
public void set_OnGoingBackup(RunningBackup value);
    [CompilerGeneratedAttribute]
public NextBackup get_NextBackup();
    [CompilerGeneratedAttribute]
public void set_NextBackup(NextBackup value);
    [CompilerGeneratedAttribute]
public RetentionPolicy get_RetentionPolicy();
    [CompilerGeneratedAttribute]
public void set_RetentionPolicy(RetentionPolicy value);
    [CompilerGeneratedAttribute]
public bool get_IsEncrypted();
    [CompilerGeneratedAttribute]
public void set_IsEncrypted(bool value);
    [CompilerGeneratedAttribute]
public string get_LastExecutingNodeTag();
    [CompilerGeneratedAttribute]
public void set_LastExecutingNodeTag(string value);
    public virtual DynamicJsonValue ToJson();
}
public enum Raven.Client.Documents.Operations.OngoingTasks.OngoingTaskConnectionStatus : Enum {
    public int value__;
    public static OngoingTaskConnectionStatus None;
    public static OngoingTaskConnectionStatus Active;
    public static OngoingTaskConnectionStatus NotActive;
    public static OngoingTaskConnectionStatus Reconnect;
    public static OngoingTaskConnectionStatus NotOnThisNode;
}
public class Raven.Client.Documents.Operations.OngoingTasks.OngoingTaskElasticSearchEtl : OngoingTask {
    [CompilerGeneratedAttribute]
private string <ConnectionStringName>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <NodesUrls>k__BackingField;
    [CompilerGeneratedAttribute]
private ElasticSearchEtlConfiguration <Configuration>k__BackingField;
    public string ConnectionStringName { get; public set; }
    public String[] NodesUrls { get; public set; }
    public ElasticSearchEtlConfiguration Configuration { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ConnectionStringName();
    [CompilerGeneratedAttribute]
public void set_ConnectionStringName(string value);
    [CompilerGeneratedAttribute]
public String[] get_NodesUrls();
    [CompilerGeneratedAttribute]
public void set_NodesUrls(String[] value);
    [CompilerGeneratedAttribute]
public ElasticSearchEtlConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(ElasticSearchEtlConfiguration value);
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.OngoingTasks.OngoingTaskOlapEtl : OngoingTask {
    [CompilerGeneratedAttribute]
private string <ConnectionStringName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private OlapEtlConfiguration <Configuration>k__BackingField;
    public string ConnectionStringName { get; public set; }
    public string Destination { get; public set; }
    public OlapEtlConfiguration Configuration { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ConnectionStringName();
    [CompilerGeneratedAttribute]
public void set_ConnectionStringName(string value);
    [CompilerGeneratedAttribute]
public string get_Destination();
    [CompilerGeneratedAttribute]
public void set_Destination(string value);
    [CompilerGeneratedAttribute]
public OlapEtlConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(OlapEtlConfiguration value);
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.OngoingTasks.OngoingTaskPullReplicationAsHub : OngoingTask {
    [CompilerGeneratedAttribute]
private string <DestinationUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationDatabase>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <DelayReplicationFor>k__BackingField;
    public string DestinationUrl { get; public set; }
    public string DestinationDatabase { get; public set; }
    public TimeSpan DelayReplicationFor { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DestinationUrl();
    [CompilerGeneratedAttribute]
public void set_DestinationUrl(string value);
    [CompilerGeneratedAttribute]
public string get_DestinationDatabase();
    [CompilerGeneratedAttribute]
public void set_DestinationDatabase(string value);
    [CompilerGeneratedAttribute]
public TimeSpan get_DelayReplicationFor();
    [CompilerGeneratedAttribute]
public void set_DelayReplicationFor(TimeSpan value);
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.OngoingTasks.OngoingTaskPullReplicationAsSink : OngoingTask {
    [CompilerGeneratedAttribute]
private string <HubName>k__BackingField;
    [CompilerGeneratedAttribute]
private PullReplicationMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <TopologyDiscoveryUrls>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationDatabase>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionStringName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificatePublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccessName>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <AllowedHubToSinkPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <AllowedSinkToHubPaths>k__BackingField;
    public string HubName { get; public set; }
    public PullReplicationMode Mode { get; public set; }
    public string DestinationUrl { get; public set; }
    public String[] TopologyDiscoveryUrls { get; public set; }
    public string DestinationDatabase { get; public set; }
    public string ConnectionStringName { get; public set; }
    public string CertificatePublicKey { get; public set; }
    public string AccessName { get; public set; }
    public String[] AllowedHubToSinkPaths { get; public set; }
    public String[] AllowedSinkToHubPaths { get; public set; }
    [CompilerGeneratedAttribute]
public string get_HubName();
    [CompilerGeneratedAttribute]
public void set_HubName(string value);
    [CompilerGeneratedAttribute]
public PullReplicationMode get_Mode();
    [CompilerGeneratedAttribute]
public void set_Mode(PullReplicationMode value);
    [CompilerGeneratedAttribute]
public string get_DestinationUrl();
    [CompilerGeneratedAttribute]
public void set_DestinationUrl(string value);
    [CompilerGeneratedAttribute]
public String[] get_TopologyDiscoveryUrls();
    [CompilerGeneratedAttribute]
public void set_TopologyDiscoveryUrls(String[] value);
    [CompilerGeneratedAttribute]
public string get_DestinationDatabase();
    [CompilerGeneratedAttribute]
public void set_DestinationDatabase(string value);
    [CompilerGeneratedAttribute]
public string get_ConnectionStringName();
    [CompilerGeneratedAttribute]
public void set_ConnectionStringName(string value);
    [CompilerGeneratedAttribute]
public string get_CertificatePublicKey();
    [CompilerGeneratedAttribute]
public void set_CertificatePublicKey(string value);
    [CompilerGeneratedAttribute]
public string get_AccessName();
    [CompilerGeneratedAttribute]
public void set_AccessName(string value);
    [CompilerGeneratedAttribute]
public String[] get_AllowedHubToSinkPaths();
    [CompilerGeneratedAttribute]
public void set_AllowedHubToSinkPaths(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_AllowedSinkToHubPaths();
    [CompilerGeneratedAttribute]
public void set_AllowedSinkToHubPaths(String[] value);
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.OngoingTasks.OngoingTaskQueueEtl : OngoingTask {
    [CompilerGeneratedAttribute]
private QueueBrokerType <BrokerType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionStringName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueEtlConfiguration <Configuration>k__BackingField;
    public QueueBrokerType BrokerType { get; public set; }
    public string ConnectionStringName { get; public set; }
    public string Url { get; public set; }
    public QueueEtlConfiguration Configuration { get; public set; }
    [CompilerGeneratedAttribute]
public QueueBrokerType get_BrokerType();
    [CompilerGeneratedAttribute]
public void set_BrokerType(QueueBrokerType value);
    [CompilerGeneratedAttribute]
public string get_ConnectionStringName();
    [CompilerGeneratedAttribute]
public void set_ConnectionStringName(string value);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public QueueEtlConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(QueueEtlConfiguration value);
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.OngoingTasks.OngoingTaskQueueSink : OngoingTask {
    [CompilerGeneratedAttribute]
private QueueSinkConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueBrokerType <BrokerType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionStringName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public QueueSinkConfiguration Configuration { get; public set; }
    public QueueBrokerType BrokerType { get; public set; }
    public string ConnectionStringName { get; public set; }
    public string Url { get; public set; }
    [CompilerGeneratedAttribute]
public QueueSinkConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(QueueSinkConfiguration value);
    [CompilerGeneratedAttribute]
public QueueBrokerType get_BrokerType();
    [CompilerGeneratedAttribute]
public void set_BrokerType(QueueBrokerType value);
    [CompilerGeneratedAttribute]
public string get_ConnectionStringName();
    [CompilerGeneratedAttribute]
public void set_ConnectionStringName(string value);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.OngoingTasks.OngoingTaskRavenEtl : OngoingTask {
    [CompilerGeneratedAttribute]
private string <DestinationUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationDatabase>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionStringName>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <TopologyDiscoveryUrls>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenEtlConfiguration <Configuration>k__BackingField;
    public string DestinationUrl { get; public set; }
    public string DestinationDatabase { get; public set; }
    public string ConnectionStringName { get; public set; }
    public String[] TopologyDiscoveryUrls { get; public set; }
    public RavenEtlConfiguration Configuration { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DestinationUrl();
    [CompilerGeneratedAttribute]
public void set_DestinationUrl(string value);
    [CompilerGeneratedAttribute]
public string get_DestinationDatabase();
    [CompilerGeneratedAttribute]
public void set_DestinationDatabase(string value);
    [CompilerGeneratedAttribute]
public string get_ConnectionStringName();
    [CompilerGeneratedAttribute]
public void set_ConnectionStringName(string value);
    [CompilerGeneratedAttribute]
public String[] get_TopologyDiscoveryUrls();
    [CompilerGeneratedAttribute]
public void set_TopologyDiscoveryUrls(String[] value);
    [CompilerGeneratedAttribute]
public RavenEtlConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(RavenEtlConfiguration value);
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.OngoingTasks.OngoingTaskReplication : OngoingTask {
    [CompilerGeneratedAttribute]
private string <DestinationUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <TopologyDiscoveryUrls>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationDatabase>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionStringName>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <DelayReplicationFor>k__BackingField;
    public string DestinationUrl { get; public set; }
    public String[] TopologyDiscoveryUrls { get; public set; }
    public string DestinationDatabase { get; public set; }
    public string ConnectionStringName { get; public set; }
    public TimeSpan DelayReplicationFor { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DestinationUrl();
    [CompilerGeneratedAttribute]
public void set_DestinationUrl(string value);
    [CompilerGeneratedAttribute]
public String[] get_TopologyDiscoveryUrls();
    [CompilerGeneratedAttribute]
public void set_TopologyDiscoveryUrls(String[] value);
    [CompilerGeneratedAttribute]
public string get_DestinationDatabase();
    [CompilerGeneratedAttribute]
public void set_DestinationDatabase(string value);
    [CompilerGeneratedAttribute]
public string get_ConnectionStringName();
    [CompilerGeneratedAttribute]
public void set_ConnectionStringName(string value);
    [CompilerGeneratedAttribute]
public TimeSpan get_DelayReplicationFor();
    [CompilerGeneratedAttribute]
public void set_DelayReplicationFor(TimeSpan value);
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.OngoingTasks.OngoingTaskSqlEtl : OngoingTask {
    [CompilerGeneratedAttribute]
private string <DestinationServer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationDatabase>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionStringName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConnectionStringDefined>k__BackingField;
    [CompilerGeneratedAttribute]
private SqlEtlConfiguration <Configuration>k__BackingField;
    public string DestinationServer { get; public set; }
    public string DestinationDatabase { get; public set; }
    public string ConnectionStringName { get; public set; }
    public bool ConnectionStringDefined { get; public set; }
    public SqlEtlConfiguration Configuration { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DestinationServer();
    [CompilerGeneratedAttribute]
public void set_DestinationServer(string value);
    [CompilerGeneratedAttribute]
public string get_DestinationDatabase();
    [CompilerGeneratedAttribute]
public void set_DestinationDatabase(string value);
    [CompilerGeneratedAttribute]
public string get_ConnectionStringName();
    [CompilerGeneratedAttribute]
public void set_ConnectionStringName(string value);
    [CompilerGeneratedAttribute]
public bool get_ConnectionStringDefined();
    [CompilerGeneratedAttribute]
public void set_ConnectionStringDefined(bool value);
    [CompilerGeneratedAttribute]
public SqlEtlConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(SqlEtlConfiguration value);
    public virtual DynamicJsonValue ToJson();
}
public enum Raven.Client.Documents.Operations.OngoingTasks.OngoingTaskState : Enum {
    public int value__;
    public static OngoingTaskState None;
    public static OngoingTaskState Enabled;
    public static OngoingTaskState Disabled;
    public static OngoingTaskState PartiallyEnabled;
}
public class Raven.Client.Documents.Operations.OngoingTasks.OngoingTaskSubscription : OngoingTask {
    [CompilerGeneratedAttribute]
private string <Query>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SubscriptionName>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SubscriptionId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ArchivedDataProcessingBehavior> <ArchivedDataProcessingBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVectorForNextBatchStartingPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <ChangeVectorForNextBatchStartingPointPerShard>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastBatchAckTime>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastClientConnectionTime>k__BackingField;
    public string Query { get; public set; }
    public string SubscriptionName { get; public set; }
    public long SubscriptionId { get; public set; }
    public Nullable`1<ArchivedDataProcessingBehavior> ArchivedDataProcessingBehavior { get; public set; }
    public string ChangeVectorForNextBatchStartingPoint { get; public set; }
    public Dictionary`2<string, string> ChangeVectorForNextBatchStartingPointPerShard { get; public set; }
    public Nullable`1<DateTime> LastBatchAckTime { get; public set; }
    public bool Disabled { get; public set; }
    public Nullable`1<DateTime> LastClientConnectionTime { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Query();
    [CompilerGeneratedAttribute]
public void set_Query(string value);
    [CompilerGeneratedAttribute]
public string get_SubscriptionName();
    [CompilerGeneratedAttribute]
public void set_SubscriptionName(string value);
    [CompilerGeneratedAttribute]
public long get_SubscriptionId();
    [CompilerGeneratedAttribute]
public void set_SubscriptionId(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<ArchivedDataProcessingBehavior> get_ArchivedDataProcessingBehavior();
    [CompilerGeneratedAttribute]
public void set_ArchivedDataProcessingBehavior(Nullable`1<ArchivedDataProcessingBehavior> value);
    [CompilerGeneratedAttribute]
public string get_ChangeVectorForNextBatchStartingPoint();
    [CompilerGeneratedAttribute]
public void set_ChangeVectorForNextBatchStartingPoint(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_ChangeVectorForNextBatchStartingPointPerShard();
    [CompilerGeneratedAttribute]
public void set_ChangeVectorForNextBatchStartingPointPerShard(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastBatchAckTime();
    [CompilerGeneratedAttribute]
public void set_LastBatchAckTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastClientConnectionTime();
    [CompilerGeneratedAttribute]
public void set_LastClientConnectionTime(Nullable`1<DateTime> value);
    public virtual DynamicJsonValue ToJson();
    internal static OngoingTaskSubscription From(SubscriptionState state, OngoingTaskConnectionStatus connectionStatus, ClusterTopology clusterTopology, string responsibleNodeTag);
}
public enum Raven.Client.Documents.Operations.OngoingTasks.OngoingTaskType : Enum {
    public int value__;
    public static OngoingTaskType Replication;
    public static OngoingTaskType RavenEtl;
    public static OngoingTaskType SqlEtl;
    public static OngoingTaskType OlapEtl;
    public static OngoingTaskType ElasticSearchEtl;
    public static OngoingTaskType QueueEtl;
    public static OngoingTaskType Backup;
    public static OngoingTaskType Subscription;
    public static OngoingTaskType PullReplicationAsHub;
    public static OngoingTaskType PullReplicationAsSink;
    public static OngoingTaskType QueueSink;
}
public class Raven.Client.Documents.Operations.OngoingTasks.RunningBackup : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFull>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RunningBackupTaskId>k__BackingField;
    public Nullable`1<DateTime> StartTime { get; public set; }
    public bool IsFull { get; public set; }
    public long RunningBackupTaskId { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_StartTime();
    [CompilerGeneratedAttribute]
public void set_StartTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public bool get_IsFull();
    [CompilerGeneratedAttribute]
public void set_IsFull(bool value);
    [CompilerGeneratedAttribute]
public long get_RunningBackupTaskId();
    [CompilerGeneratedAttribute]
public void set_RunningBackupTaskId(long value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.OngoingTasks.ToggleOngoingTaskStateOperation : object {
    private long _taskId;
    private string _taskName;
    private OngoingTaskType _type;
    private bool _disable;
    public ToggleOngoingTaskStateOperation(long taskId, OngoingTaskType type, bool disable);
    internal ToggleOngoingTaskStateOperation(string taskName, OngoingTaskType type, bool disable);
    public sealed virtual RavenCommand`1<ModifyOngoingTaskResult> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.Documents.Operations.Operation : object {
    private RequestExecutor _requestExecutor;
    private Func`1<ISingleNodeDatabaseChanges> _changes;
    private DocumentConventions _conventions;
    private Task _afterOperationCompleted;
    private long _id;
    private TaskCompletionSource`1<IOperationResult> _result;
    private SemaphoreSlim _lock;
    public EventHandler`1<IOperationProgress> OnProgressChanged;
    private JsonOperationContext _context;
    private IDisposable _subscription;
    internal string NodeTag;
    [CompilerGeneratedAttribute]
private OperationStatusFetchMode <StatusFetchMode>k__BackingField;
    private bool _isProcessing;
    internal long Id { get; }
    public OperationStatusFetchMode StatusFetchMode { get; protected set; }
    public Operation(RequestExecutor requestExecutor, Func`1<ISingleNodeDatabaseChanges> changes, DocumentConventions conventions, long id, string nodeTag);
    internal Operation(RequestExecutor requestExecutor, Func`1<ISingleNodeDatabaseChanges> changes, DocumentConventions conventions, long id, string nodeTag, Task afterOperationCompleted);
    internal long get_Id();
    [CompilerGeneratedAttribute]
public OperationStatusFetchMode get_StatusFetchMode();
    [CompilerGeneratedAttribute]
protected void set_StatusFetchMode(OperationStatusFetchMode value);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Operations.Operation/<Initialize>d__20")]
private Task Initialize();
    [AsyncStateMachineAttribute("Raven.Client.Documents.Operations.Operation/<InitializeResult>d__21")]
private Task`1<Task`1<IOperationResult>> InitializeResult();
    [AsyncStateMachineAttribute("Raven.Client.Documents.Operations.Operation/<Process>d__22")]
protected virtual Task Process();
    private void OnConnectionStatusChanged(object sender, EventArgs e);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Operations.Operation/<OnConnectionStatusChangedAsync>d__24")]
private Task OnConnectionStatusChangedAsync();
    [AsyncStateMachineAttribute("Raven.Client.Documents.Operations.Operation/<StopProcessingUnderLock>d__25")]
private Task StopProcessingUnderLock(Exception e);
    protected virtual void StopProcessing();
    [AsyncStateMachineAttribute("Raven.Client.Documents.Operations.Operation/<FetchOperationStatus>d__27")]
protected Task FetchOperationStatus(bool shouldThrowOnNoStatus);
    protected virtual RavenCommand`1<OperationState> GetOperationStateCommand(DocumentConventions conventions, long id, string nodeTag);
    protected virtual RavenCommand GetKillOperationCommand(long id, string nodeTag);
    public sealed virtual void OnNext(OperationStatusChange change);
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnCompleted();
    public Task`1<IOperationResult> WaitForCompletionAsync(Nullable`1<TimeSpan> timeout);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Operations.Operation/<WaitForCompletionAsync>d__34`1")]
public Task`1<TResult> WaitForCompletionAsync(Nullable`1<TimeSpan> timeout);
    public Task`1<IOperationResult> WaitForCompletionAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Operations.Operation/<WaitForCompletionAsync>d__36`1")]
public Task`1<TResult> WaitForCompletionAsync(CancellationToken token);
    public IOperationResult WaitForCompletion(Nullable`1<TimeSpan> timeout);
    public TResult WaitForCompletion(Nullable`1<TimeSpan> timeout);
    public IOperationResult WaitForCompletion(CancellationToken token);
    public TResult WaitForCompletion(CancellationToken token);
    public void Kill();
    [AsyncStateMachineAttribute("Raven.Client.Documents.Operations.Operation/<KillAsync>d__42")]
public Task KillAsync(CancellationToken token);
    [CompilerGeneratedAttribute]
private Task <Kill>b__41_0();
}
public class Raven.Client.Documents.Operations.Operation`1 : Operation {
    [CompilerGeneratedAttribute]
private TResult <Result>k__BackingField;
    public TResult Result { get; }
    internal Operation`1(RequestExecutor requestExecutor, Func`1<ISingleNodeDatabaseChanges> changes, DocumentConventions conventions, TResult result, long id, string nodeTag);
    internal Operation`1(RequestExecutor requestExecutor, Func`1<ISingleNodeDatabaseChanges> changes, DocumentConventions conventions, TResult result, long id, string nodeTag, Task afterOperationCompleted);
    [CompilerGeneratedAttribute]
public TResult get_Result();
}
public class Raven.Client.Documents.Operations.OperationExceptionResult : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpStatusCode <StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldPersist>k__BackingField;
    public string Type { get; public set; }
    public string Message { get; public set; }
    public string Error { get; public set; }
    public HttpStatusCode StatusCode { get; public set; }
    public bool ShouldPersist { get; }
    private bool Raven.Client.Documents.Operations.IOperationResult.CanMerge { get; }
    public OperationExceptionResult(Exception exception, HttpStatusCode statusCode, bool shouldBePersistent);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(string value);
    [CompilerGeneratedAttribute]
public HttpStatusCode get_StatusCode();
    [CompilerGeneratedAttribute]
public void set_StatusCode(HttpStatusCode value);
    public sealed virtual DynamicJsonValue ToJson();
    private static string ExceptionToString(Exception exception);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ShouldPersist();
    private sealed virtual override bool Raven.Client.Documents.Operations.IOperationResult.get_CanMerge();
    private sealed virtual override void Raven.Client.Documents.Operations.IOperationResult.MergeWith(IOperationResult result);
}
public class Raven.Client.Documents.Operations.OperationExecutor : object {
    private IDocumentStore _store;
    private string _databaseName;
    private RequestExecutor _requestExecutor;
    private RequestExecutor RequestExecutor { get; }
    public OperationExecutor(DocumentStoreBase store, string databaseName);
    protected OperationExecutor(IDocumentStore store, string databaseName);
    private RequestExecutor get_RequestExecutor();
    public virtual OperationExecutor ForDatabase(string databaseName);
    public void Send(IOperation operation, SessionInfo sessionInfo);
    public TResult Send(IOperation`1<TResult> operation, SessionInfo sessionInfo);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Operations.OperationExecutor/<SendAsync>d__10")]
public Task SendAsync(IOperation operation, SessionInfo sessionInfo, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Operations.OperationExecutor/<SendAsync>d__11`1")]
public Task`1<TResult> SendAsync(IOperation`1<TResult> operation, SessionInfo sessionInfo, CancellationToken token);
    protected virtual IDisposable GetContext(JsonOperationContext& context);
    public Operation Send(IOperation`1<OperationIdResult> operation, SessionInfo sessionInfo);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Operations.OperationExecutor/<SendAsync>d__14")]
public Task`1<Operation> SendAsync(IOperation`1<OperationIdResult> operation, SessionInfo sessionInfo, CancellationToken token);
    public PatchStatus Send(PatchOperation operation);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Operations.OperationExecutor/<SendAsync>d__16")]
public Task`1<PatchStatus> SendAsync(PatchOperation operation, SessionInfo sessionInfo, CancellationToken token);
    public Result`1<TEntity> Send(PatchOperation`1<TEntity> operation, SessionInfo sessionInfo);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Operations.OperationExecutor/<SendAsync>d__18`1")]
public Task`1<Result`1<TEntity>> SendAsync(PatchOperation`1<TEntity> operation, SessionInfo sessionInfo, CancellationToken token);
}
public class Raven.Client.Documents.Operations.OperationIdResult : object {
    [CompilerGeneratedAttribute]
private long <OperationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationNodeTag>k__BackingField;
    public long OperationId { get; public set; }
    public string OperationNodeTag { get; public set; }
    [CompilerGeneratedAttribute]
public long get_OperationId();
    [CompilerGeneratedAttribute]
public void set_OperationId(long value);
    [CompilerGeneratedAttribute]
public string get_OperationNodeTag();
    [CompilerGeneratedAttribute]
public void set_OperationNodeTag(string value);
    internal OperationIdResult`1<TResult> ForResult(TResult result);
}
public class Raven.Client.Documents.Operations.OperationIdResult`1 : OperationIdResult {
    [CompilerGeneratedAttribute]
private TResult <Result>k__BackingField;
    public TResult Result { get; public set; }
    [CompilerGeneratedAttribute]
public TResult get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(TResult value);
}
public class Raven.Client.Documents.Operations.OperationMultipleExceptionsResult : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<OperationExceptionResult> <Exceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldPersist>k__BackingField;
    public string Message { get; }
    public List`1<OperationExceptionResult> Exceptions { get; }
    public bool ShouldPersist { get; }
    private bool Raven.Client.Documents.Operations.IOperationResult.CanMerge { get; }
    public OperationMultipleExceptionsResult(string message);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public List`1<OperationExceptionResult> get_Exceptions();
    public sealed virtual DynamicJsonValue ToJson();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ShouldPersist();
    private sealed virtual override bool Raven.Client.Documents.Operations.IOperationResult.get_CanMerge();
    private sealed virtual override void Raven.Client.Documents.Operations.IOperationResult.MergeWith(IOperationResult result);
}
public class Raven.Client.Documents.Operations.OperationState : object {
    [CompilerGeneratedAttribute]
private IOperationResult <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperationProgress <Progress>k__BackingField;
    [CompilerGeneratedAttribute]
private OperationStatus <Status>k__BackingField;
    public IOperationResult Result { get; public set; }
    public IOperationProgress Progress { get; public set; }
    public OperationStatus Status { get; public set; }
    [CompilerGeneratedAttribute]
public IOperationResult get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(IOperationResult value);
    [CompilerGeneratedAttribute]
public IOperationProgress get_Progress();
    [CompilerGeneratedAttribute]
public void set_Progress(IOperationProgress value);
    [CompilerGeneratedAttribute]
public OperationStatus get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(OperationStatus value);
    public DynamicJsonValue ToJson();
}
public enum Raven.Client.Documents.Operations.OperationStatus : Enum {
    public int value__;
    public static OperationStatus InProgress;
    public static OperationStatus Completed;
    public static OperationStatus Faulted;
    public static OperationStatus Canceled;
}
public class Raven.Client.Documents.Operations.OperationStatusChange : DatabaseChange {
    [CompilerGeneratedAttribute]
private long <OperationId>k__BackingField;
    [CompilerGeneratedAttribute]
private OperationState <State>k__BackingField;
    public long OperationId { get; public set; }
    public OperationState State { get; public set; }
    [CompilerGeneratedAttribute]
public long get_OperationId();
    [CompilerGeneratedAttribute]
public void set_OperationId(long value);
    [CompilerGeneratedAttribute]
public OperationState get_State();
    [CompilerGeneratedAttribute]
public void set_State(OperationState value);
    public DynamicJsonValue ToJson();
    internal static OperationStatusChange FromJson(BlittableJsonReaderObject value);
}
public enum Raven.Client.Documents.Operations.OperationStatusFetchMode : Enum {
    public int value__;
    public static OperationStatusFetchMode ChangesApi;
    public static OperationStatusFetchMode Polling;
}
public class Raven.Client.Documents.Operations.PatchByQueryOperation : object {
    private IndexQuery _queryToUpdate;
    private QueryOperationOptions _options;
    public PatchByQueryOperation(string queryToUpdate);
    public PatchByQueryOperation(IndexQuery queryToUpdate, QueryOperationOptions options);
    public sealed virtual RavenCommand`1<OperationIdResult> GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
}
public class Raven.Client.Documents.Operations.PatchOperation : object {
    private string _id;
    private string _changeVector;
    private PatchRequest _patch;
    private PatchRequest _patchIfMissing;
    private bool _skipPatchIfChangeVectorMismatch;
    public PatchOperation(string id, string changeVector, PatchRequest patch, PatchRequest patchIfMissing, bool skipPatchIfChangeVectorMismatch);
    public sealed virtual RavenCommand`1<PatchResult> GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
    public RavenCommand`1<PatchResult> GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache, bool returnDebugInformation, bool test);
}
public class Raven.Client.Documents.Operations.PatchOperation`1 : PatchOperation {
    public PatchOperation`1(string id, string changeVector, PatchRequest patch, PatchRequest patchIfMissing, bool skipPatchIfChangeVectorMismatch);
}
public class Raven.Client.Documents.Operations.PatchRequest : object {
    [CompilerGeneratedAttribute]
private string <Script>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <Values>k__BackingField;
    public string Script { get; public set; }
    public Dictionary`2<string, object> Values { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Script();
    [CompilerGeneratedAttribute]
public void set_Script(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_Values();
    [CompilerGeneratedAttribute]
public void set_Values(Dictionary`2<string, object> value);
    private bool Equals(PatchRequest other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public DynamicJsonValue ToJson(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.PatchResult : PatchResultBase {
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <OriginalDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <Debug>k__BackingField;
    public BlittableJsonReaderObject OriginalDocument { get; public set; }
    public BlittableJsonReaderObject Debug { get; public set; }
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_OriginalDocument();
    [CompilerGeneratedAttribute]
public void set_OriginalDocument(BlittableJsonReaderObject value);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_Debug();
    [CompilerGeneratedAttribute]
public void set_Debug(BlittableJsonReaderObject value);
    public virtual void Dispose();
}
public abstract class Raven.Client.Documents.Operations.PatchResultBase : object {
    [CompilerGeneratedAttribute]
private PatchStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <ModifiedDocument>k__BackingField;
    public DateTime LastModified;
    public string ChangeVector;
    public string Collection;
    public PatchStatus Status { get; public set; }
    public BlittableJsonReaderObject ModifiedDocument { get; public set; }
    [CompilerGeneratedAttribute]
public PatchStatus get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(PatchStatus value);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_ModifiedDocument();
    [CompilerGeneratedAttribute]
public void set_ModifiedDocument(BlittableJsonReaderObject value);
    public virtual void Dispose();
}
public enum Raven.Client.Documents.Operations.PatchStatus : Enum {
    public int value__;
    public static PatchStatus DocumentDoesNotExist;
    public static PatchStatus Created;
    public static PatchStatus Patched;
    public static PatchStatus Skipped;
    public static PatchStatus NotModified;
}
internal class Raven.Client.Documents.Operations.PutIndexesResponse : ResultsResponse`1<PutIndexResult> {
}
public class Raven.Client.Documents.Operations.QueueSink.AddQueueSinkOperation`1 : object {
    private QueueSinkConfiguration _configuration;
    public AddQueueSinkOperation`1(QueueSinkConfiguration configuration);
    public sealed virtual RavenCommand`1<AddQueueSinkOperationResult> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.Documents.Operations.QueueSink.AddQueueSinkOperationResult : object {
    [CompilerGeneratedAttribute]
private long <RaftCommandIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TaskId>k__BackingField;
    public long RaftCommandIndex { get; public set; }
    public long TaskId { get; public set; }
    [CompilerGeneratedAttribute]
public long get_RaftCommandIndex();
    [CompilerGeneratedAttribute]
public void set_RaftCommandIndex(long value);
    [CompilerGeneratedAttribute]
public long get_TaskId();
    [CompilerGeneratedAttribute]
public void set_TaskId(long value);
}
public class Raven.Client.Documents.Operations.QueueSink.QueueSinkConfiguration : object {
    private bool _initialized;
    [CompilerGeneratedAttribute]
private QueueBrokerType <BrokerType>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TaskId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MentorNode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PinToMentorNode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionStringName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TestMode>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<QueueSinkScript> <Scripts>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueConnectionString <Connection>k__BackingField;
    public QueueBrokerType BrokerType { get; public set; }
    public long TaskId { get; public set; }
    public bool Disabled { get; public set; }
    public string Name { get; public set; }
    public string MentorNode { get; public set; }
    public bool PinToMentorNode { get; public set; }
    public string ConnectionStringName { get; public set; }
    internal bool TestMode { get; internal set; }
    public List`1<QueueSinkScript> Scripts { get; public set; }
    [JsonDeserializationIgnoreAttribute]
[JsonIgnoreAttribute]
internal QueueConnectionString Connection { get; internal set; }
    [CompilerGeneratedAttribute]
public QueueBrokerType get_BrokerType();
    [CompilerGeneratedAttribute]
public void set_BrokerType(QueueBrokerType value);
    [CompilerGeneratedAttribute]
public long get_TaskId();
    [CompilerGeneratedAttribute]
public void set_TaskId(long value);
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_MentorNode();
    [CompilerGeneratedAttribute]
public void set_MentorNode(string value);
    [CompilerGeneratedAttribute]
public bool get_PinToMentorNode();
    [CompilerGeneratedAttribute]
public void set_PinToMentorNode(bool value);
    [CompilerGeneratedAttribute]
public string get_ConnectionStringName();
    [CompilerGeneratedAttribute]
public void set_ConnectionStringName(string value);
    [CompilerGeneratedAttribute]
internal bool get_TestMode();
    [CompilerGeneratedAttribute]
internal void set_TestMode(bool value);
    [CompilerGeneratedAttribute]
public List`1<QueueSinkScript> get_Scripts();
    [CompilerGeneratedAttribute]
public void set_Scripts(List`1<QueueSinkScript> value);
    [CompilerGeneratedAttribute]
internal QueueConnectionString get_Connection();
    [CompilerGeneratedAttribute]
internal void set_Connection(QueueConnectionString value);
    public void Initialize(QueueConnectionString connectionString);
    public virtual bool Validate(List`1& errors, bool validateName, bool validateConnection);
    public sealed virtual DynamicJsonValue ToJson();
    public string GetDestination();
    public sealed virtual ulong GetTaskKey();
    public sealed virtual string GetMentorNode();
    public sealed virtual string GetDefaultTaskName();
    public sealed virtual string GetTaskName();
    public sealed virtual bool IsResourceIntensive();
    public sealed virtual bool IsPinnedToMentorNode();
    internal QueueSinkConfigurationCompareDifferences Compare(QueueSinkConfiguration config, List`1<ValueTuple`2<string, QueueSinkConfigurationCompareDifferences>> transformationDiffs);
}
[FlagsAttribute]
internal enum Raven.Client.Documents.Operations.QueueSink.QueueSinkConfigurationCompareDifferences : Enum {
    public int value__;
    public static QueueSinkConfigurationCompareDifferences None;
    public static QueueSinkConfigurationCompareDifferences ScriptsCount;
    public static QueueSinkConfigurationCompareDifferences QueueCount;
    public static QueueSinkConfigurationCompareDifferences ScriptName;
    public static QueueSinkConfigurationCompareDifferences Script;
    public static QueueSinkConfigurationCompareDifferences ScriptDisabled;
    public static QueueSinkConfigurationCompareDifferences ConnectionStringName;
    public static QueueSinkConfigurationCompareDifferences ConfigurationName;
    public static QueueSinkConfigurationCompareDifferences MentorNode;
    public static QueueSinkConfigurationCompareDifferences ConfigurationDisabled;
}
public class Raven.Client.Documents.Operations.QueueSink.QueueSinkProcessState : object {
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigurationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScriptName>k__BackingField;
    public string NodeTag { get; public set; }
    public string ConfigurationName { get; public set; }
    public string ScriptName { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_NodeTag();
    [CompilerGeneratedAttribute]
public void set_NodeTag(string value);
    [CompilerGeneratedAttribute]
public string get_ConfigurationName();
    [CompilerGeneratedAttribute]
public void set_ConfigurationName(string value);
    [CompilerGeneratedAttribute]
public string get_ScriptName();
    [CompilerGeneratedAttribute]
public void set_ScriptName(string value);
    public DynamicJsonValue ToJson();
    public static string GenerateItemName(string databaseName, string configurationName, string transformationName);
}
public class Raven.Client.Documents.Operations.QueueSink.QueueSinkScript : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Queues>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Script>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    public string Name { get; public set; }
    public List`1<string> Queues { get; public set; }
    public string Script { get; public set; }
    public bool Disabled { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Queues();
    [CompilerGeneratedAttribute]
public void set_Queues(List`1<string> value);
    [CompilerGeneratedAttribute]
public string get_Script();
    [CompilerGeneratedAttribute]
public void set_Script(string value);
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    internal QueueSinkConfigurationCompareDifferences Compare(QueueSinkScript script);
    public DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.QueueSink.UpdateQueueSinkOperation`1 : object {
    private long _taskId;
    private QueueSinkConfiguration _configuration;
    public UpdateQueueSinkOperation`1(long taskId, QueueSinkConfiguration configuration);
    public sealed virtual RavenCommand`1<UpdateQueueSinkOperationResult> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.Documents.Operations.QueueSink.UpdateQueueSinkOperationResult : object {
    [CompilerGeneratedAttribute]
private long <RaftCommandIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TaskId>k__BackingField;
    public long RaftCommandIndex { get; public set; }
    public long TaskId { get; public set; }
    [CompilerGeneratedAttribute]
public long get_RaftCommandIndex();
    [CompilerGeneratedAttribute]
public void set_RaftCommandIndex(long value);
    [CompilerGeneratedAttribute]
public long get_TaskId();
    [CompilerGeneratedAttribute]
public void set_TaskId(long value);
}
public class Raven.Client.Documents.Operations.Refresh.ConfigureRefreshOperation : object {
    private RefreshConfiguration _configuration;
    public ConfigureRefreshOperation(RefreshConfiguration configuration);
    public sealed virtual RavenCommand`1<ConfigureRefreshOperationResult> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.Documents.Operations.Refresh.ConfigureRefreshOperationResult : object {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <RaftCommandIndex>k__BackingField;
    public Nullable`1<long> RaftCommandIndex { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_RaftCommandIndex();
    [CompilerGeneratedAttribute]
public void set_RaftCommandIndex(Nullable`1<long> value);
}
public class Raven.Client.Documents.Operations.Refresh.RefreshConfiguration : object {
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <RefreshFrequencyInSec>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MaxItemsToProcess>k__BackingField;
    public bool Disabled { get; public set; }
    public Nullable`1<long> RefreshFrequencyInSec { get; public set; }
    public Nullable`1<long> MaxItemsToProcess { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_RefreshFrequencyInSec();
    [CompilerGeneratedAttribute]
public void set_RefreshFrequencyInSec(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MaxItemsToProcess();
    [CompilerGeneratedAttribute]
public void set_MaxItemsToProcess(Nullable`1<long> value);
    private bool Equals(RefreshConfiguration other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.Replication.DetailedReplicationHubAccess : object {
    public string Name;
    public string Thumbprint;
    public string Certificate;
    public DateTime NotBefore;
    public DateTime NotAfter;
    public string Subject;
    public string Issuer;
    public String[] AllowedHubToSinkPaths;
    public String[] AllowedSinkToHubPaths;
    internal static String[] Preferred(String[] a, String[] b);
}
public class Raven.Client.Documents.Operations.Replication.ExternalReplication : ExternalReplicationBase {
    [CompilerGeneratedAttribute]
private TimeSpan <DelayReplicationFor>k__BackingField;
    public TimeSpan DelayReplicationFor { get; public set; }
    public ExternalReplication(string database, string connectionStringName);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_DelayReplicationFor();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DelayReplicationFor(TimeSpan value);
    public virtual ReplicationType GetReplicationType();
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToAuditJson();
    public virtual bool IsEqualTo(ReplicationNode other);
}
public abstract class Raven.Client.Documents.Operations.Replication.ExternalReplicationBase : ReplicationNode {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionStringName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MentorNode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PinToMentorNode>k__BackingField;
    [JsonDeserializationIgnoreAttribute]
internal RavenConnectionString ConnectionString;
    private long _taskId;
    public long TaskId { get; public set; }
    public string Name { get; public set; }
    public string ConnectionStringName { get; public set; }
    public string MentorNode { get; public set; }
    public bool PinToMentorNode { get; public set; }
    protected ExternalReplicationBase(string database, string connectionStringName);
    public sealed virtual long get_TaskId();
    public sealed virtual void set_TaskId(long value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_ConnectionStringName();
    [CompilerGeneratedAttribute]
public void set_ConnectionStringName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MentorNode();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MentorNode(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PinToMentorNode();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PinToMentorNode(bool value);
    public void AssertValidReplication();
    public static void RemoveExternalReplication(List`1<T> replicationTasks, long taskId);
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToAuditJson();
    public virtual ulong GetTaskKey();
    public virtual int GetHashCode();
    public virtual bool IsEqualTo(ReplicationNode other);
    public bool Equals(ExternalReplicationBase other);
    public virtual bool Equals(object obj);
    public sealed virtual string GetMentorNode();
    public virtual string GetDefaultTaskName();
    public sealed virtual string GetTaskName();
    public sealed virtual bool IsResourceIntensive();
    public sealed virtual bool IsPinnedToMentorNode();
}
public class Raven.Client.Documents.Operations.Replication.GetReplicationHubAccessOperation : object {
    private string _hubName;
    private int _start;
    private int _pageSize;
    public GetReplicationHubAccessOperation(string hubName, int start, int pageSize);
    public sealed virtual RavenCommand`1<DetailedReplicationHubAccess[]> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Replication.GetReplicationPerformanceStatisticsOperation : object {
    public sealed virtual RavenCommand`1<ReplicationPerformance> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
internal interface Raven.Client.Documents.Operations.Replication.IExternalReplication {
    public bool Disabled { get; public set; }
    public long TaskId { get; public set; }
    public string Name { get; public set; }
    public string MentorNode { get; public set; }
    public bool PinToMentorNode { get; public set; }
    public TimeSpan DelayReplicationFor { get; public set; }
    public abstract virtual bool get_Disabled();
    public abstract virtual void set_Disabled(bool value);
    public abstract virtual long get_TaskId();
    public abstract virtual void set_TaskId(long value);
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual string get_MentorNode();
    public abstract virtual void set_MentorNode(string value);
    public abstract virtual bool get_PinToMentorNode();
    public abstract virtual void set_PinToMentorNode(bool value);
    public abstract virtual TimeSpan get_DelayReplicationFor();
    public abstract virtual void set_DelayReplicationFor(TimeSpan value);
    public abstract virtual string GetDefaultTaskName();
}
public class Raven.Client.Documents.Operations.Replication.InternalReplication : ReplicationNode {
    private string _nodeTag;
    public string NodeTag { get; public set; }
    public string get_NodeTag();
    public void set_NodeTag(string value);
    public virtual ReplicationType GetReplicationType();
    public virtual string FromString();
    public virtual bool IsEqualTo(ReplicationNode other);
    public virtual int GetHashCode();
    public virtual DynamicJsonValue ToJson();
}
[FlagsAttribute]
public enum Raven.Client.Documents.Operations.Replication.PreventDeletionsMode : Enum {
    public int value__;
    public static PreventDeletionsMode None;
    public static PreventDeletionsMode PreventSinkToHubDeletions;
}
internal class Raven.Client.Documents.Operations.Replication.PullReplicationAsHub : ExternalReplication {
    public PullReplicationMode Mode;
    public PullReplicationAsHub(string database, string connectionStringName);
    public virtual ReplicationType GetReplicationType();
    public virtual bool IsEqualTo(ReplicationNode other);
    public virtual ulong GetTaskKey();
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToAuditJson();
    public virtual string ToString();
    public virtual string GetDefaultTaskName();
}
public class Raven.Client.Documents.Operations.Replication.PullReplicationAsSink : ExternalReplicationBase {
    public PullReplicationMode Mode;
    public String[] AllowedHubToSinkPaths;
    public String[] AllowedSinkToHubPaths;
    public string CertificateWithPrivateKey;
    public string CertificatePassword;
    public string AccessName;
    public string HubName;
    public PullReplicationAsSink(string database, string connectionStringName, string hubName);
    public virtual ReplicationType GetReplicationType();
    public virtual bool IsEqualTo(ReplicationNode other);
    public virtual ulong GetTaskKey();
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToAuditJson();
    public virtual string ToString();
    public virtual string GetDefaultTaskName();
}
public class Raven.Client.Documents.Operations.Replication.PullReplicationDefinition : object {
    public TimeSpan DelayReplicationFor;
    public bool Disabled;
    public string MentorNode;
    public bool PinToMentorNode;
    public PullReplicationMode Mode;
    public string Name;
    public long TaskId;
    public bool WithFiltering;
    [CompilerGeneratedAttribute]
private PreventDeletionsMode <PreventDeletionsMode>k__BackingField;
    public PreventDeletionsMode PreventDeletionsMode { get; public set; }
    public PullReplicationDefinition(string name, TimeSpan delay, string mentor);
    [CompilerGeneratedAttribute]
public PreventDeletionsMode get_PreventDeletionsMode();
    [CompilerGeneratedAttribute]
public void set_PreventDeletionsMode(PreventDeletionsMode value);
    public sealed virtual DynamicJsonValue ToJson();
    public DynamicJsonValue ToAuditJson();
    internal void Validate(bool useSsl);
    internal PullReplicationAsHub ToPullReplicationAsHub(ReplicationInitialRequest request, long taskId);
}
public class Raven.Client.Documents.Operations.Replication.PullReplicationDefinitionAndCurrentConnections : object {
    [CompilerGeneratedAttribute]
private PullReplicationDefinition <Definition>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<OngoingTaskPullReplicationAsHub> <OngoingTasks>k__BackingField;
    public PullReplicationDefinition Definition { get; public set; }
    public List`1<OngoingTaskPullReplicationAsHub> OngoingTasks { get; public set; }
    [CompilerGeneratedAttribute]
public PullReplicationDefinition get_Definition();
    [CompilerGeneratedAttribute]
public void set_Definition(PullReplicationDefinition value);
    [CompilerGeneratedAttribute]
public List`1<OngoingTaskPullReplicationAsHub> get_OngoingTasks();
    [CompilerGeneratedAttribute]
public void set_OngoingTasks(List`1<OngoingTaskPullReplicationAsHub> value);
    public sealed virtual DynamicJsonValue ToJson();
}
[FlagsAttribute]
public enum Raven.Client.Documents.Operations.Replication.PullReplicationMode : Enum {
    public int value__;
    public static PullReplicationMode None;
    public static PullReplicationMode HubToSink;
    public static PullReplicationMode SinkToHub;
}
public class Raven.Client.Documents.Operations.Replication.PutPullReplicationAsHubOperation : object {
    private PullReplicationDefinition _pullReplicationDefinition;
    public PutPullReplicationAsHubOperation(string name);
    public PutPullReplicationAsHubOperation(PullReplicationDefinition pullReplicationDefinition);
    public sealed virtual RavenCommand`1<ModifyOngoingTaskResult> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Replication.RegisterReplicationHubAccessOperation : object {
    private string _hubName;
    private ReplicationHubAccess _access;
    public RegisterReplicationHubAccessOperation(string hubName, ReplicationHubAccess access);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Replication.ReplicationHubAccess : object {
    public string Name;
    public string CertificateBase64;
    public String[] AllowedHubToSinkPaths;
    public String[] AllowedSinkToHubPaths;
    public sealed virtual DynamicJsonValue ToJson();
    internal void Validate(bool filteringIsRequired);
    private void ValidateAllowedPaths(String[] allowedPaths);
}
internal class Raven.Client.Documents.Operations.Replication.ReplicationHubAccessResponse : object {
    [CompilerGeneratedAttribute]
private long <RaftCommandIndex>k__BackingField;
    public long RaftCommandIndex { get; public set; }
    [CompilerGeneratedAttribute]
public long get_RaftCommandIndex();
    [CompilerGeneratedAttribute]
public void set_RaftCommandIndex(long value);
}
public class Raven.Client.Documents.Operations.Replication.ReplicationHubAccessResult : object {
    public DetailedReplicationHubAccess[] Results;
}
public class Raven.Client.Documents.Operations.Replication.UnregisterReplicationHubAccessOperation : object {
    private string _hubName;
    private string _thumbprint;
    public UnregisterReplicationHubAccessOperation(string hubName, string thumbprint);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Replication.UpdateExternalReplicationOperation : object {
    private ExternalReplication _newWatcher;
    public UpdateExternalReplicationOperation(ExternalReplication newWatcher);
    public sealed virtual RavenCommand`1<ModifyOngoingTaskResult> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.Documents.Operations.Replication.UpdatePullReplicationAsSinkOperation : object {
    private PullReplicationAsSink _pullReplication;
    public UpdatePullReplicationAsSinkOperation(PullReplicationAsSink pullReplication);
    public sealed virtual RavenCommand`1<ModifyOngoingTaskResult> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
internal abstract class Raven.Client.Documents.Operations.ResultsResponse`1 : object {
    [CompilerGeneratedAttribute]
private T[] <Results>k__BackingField;
    public T[] Results { get; public set; }
    [CompilerGeneratedAttribute]
public T[] get_Results();
    [CompilerGeneratedAttribute]
public void set_Results(T[] value);
}
public class Raven.Client.Documents.Operations.Revisions.AdoptOrphanedRevisionsOperation : object {
    private Parameters _parameters;
    public AdoptOrphanedRevisionsOperation(Parameters parameters);
    public sealed virtual RavenCommand`1<OperationIdResult> GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
}
public class Raven.Client.Documents.Operations.Revisions.AdoptOrphanedRevisionsResult : OperationResult {
    [CompilerGeneratedAttribute]
private int <AdoptedCount>k__BackingField;
    public int AdoptedCount { get; public set; }
    public bool CanMerge { get; }
    [CompilerGeneratedAttribute]
public int get_AdoptedCount();
    [CompilerGeneratedAttribute]
public void set_AdoptedCount(int value);
    public virtual bool get_CanMerge();
    public virtual void MergeWith(IOperationResult result);
    public virtual void MergeWith(IOperationProgress progress);
    public virtual IOperationProgress Clone();
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.Revisions.ConfigureRevisionsOperation : object {
    private RevisionsConfiguration _configuration;
    public ConfigureRevisionsOperation(RevisionsConfiguration configuration);
    public sealed virtual RavenCommand`1<ConfigureRevisionsOperationResult> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.Documents.Operations.Revisions.ConfigureRevisionsOperationResult : object {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <RaftCommandIndex>k__BackingField;
    public Nullable`1<long> RaftCommandIndex { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_RaftCommandIndex();
    [CompilerGeneratedAttribute]
public void set_RaftCommandIndex(Nullable`1<long> value);
}
public class Raven.Client.Documents.Operations.Revisions.DeleteRevisionsOperation : object {
    private Parameters _parameters;
    public DeleteRevisionsOperation(List`1<string> documentIds, bool removeForceCreatedRevisions);
    public DeleteRevisionsOperation(string documentId, bool removeForceCreatedRevisions);
    public DeleteRevisionsOperation(List`1<string> documentIds, Nullable`1<DateTime> from, Nullable`1<DateTime> to, bool removeForceCreatedRevisions);
    public DeleteRevisionsOperation(string documentId, Nullable`1<DateTime> from, Nullable`1<DateTime> to, bool removeForceCreatedRevisions);
    public DeleteRevisionsOperation(string documentId, List`1<string> revisionsChangeVectors, bool removeForceCreatedRevisions);
    public sealed virtual RavenCommand`1<Result> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Revisions.EnforceConfigurationResult : OperationResult {
    [CompilerGeneratedAttribute]
private int <RemovedRevisions>k__BackingField;
    public int RemovedRevisions { get; public set; }
    public bool CanMerge { get; }
    [CompilerGeneratedAttribute]
public int get_RemovedRevisions();
    [CompilerGeneratedAttribute]
public void set_RemovedRevisions(int value);
    public virtual bool get_CanMerge();
    public virtual void MergeWith(IOperationResult result);
    public virtual void MergeWith(IOperationProgress progress);
    public virtual IOperationProgress Clone();
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.Revisions.EnforceRevisionsConfigurationOperation : object {
    private Parameters _parameters;
    public EnforceRevisionsConfigurationOperation(Parameters parameters);
    public sealed virtual RavenCommand`1<OperationIdResult> GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
}
public class Raven.Client.Documents.Operations.Revisions.GetRevisionsOperation`1 : object {
    private Parameters<T> _parameters;
    public GetRevisionsOperation`1(string id);
    public GetRevisionsOperation`1(string id, int start, int pageSize);
    public GetRevisionsOperation`1(Parameters<T> parameters);
    public sealed virtual RavenCommand`1<RevisionsResult`1<T>> GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
}
internal interface Raven.Client.Documents.Operations.Revisions.IRevisionsOperationParameters {
}
public abstract class Raven.Client.Documents.Operations.Revisions.OperationResult : object {
    [CompilerGeneratedAttribute]
private int <ScannedRevisions>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ScannedDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Warnings>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public int ScannedRevisions { get; public set; }
    public int ScannedDocuments { get; public set; }
    public Dictionary`2<string, string> Warnings { get; public set; }
    public string Message { get; }
    public bool CanMerge { get; }
    public bool ShouldPersist { get; }
    [CompilerGeneratedAttribute]
public int get_ScannedRevisions();
    [CompilerGeneratedAttribute]
public void set_ScannedRevisions(int value);
    [CompilerGeneratedAttribute]
public int get_ScannedDocuments();
    [CompilerGeneratedAttribute]
public void set_ScannedDocuments(int value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Warnings();
    [CompilerGeneratedAttribute]
public void set_Warnings(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    public void Warn(string id, string message);
    public virtual DynamicJsonValue ToJson();
    public virtual IOperationProgress Clone();
    public virtual void MergeWith(IOperationProgress progress);
    public virtual bool get_CanMerge();
    public virtual void MergeWith(IOperationResult result);
    public sealed virtual bool get_ShouldPersist();
}
public class Raven.Client.Documents.Operations.Revisions.RevertResult : OperationResult {
    [CompilerGeneratedAttribute]
private int <RevertedDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private int <_failedCollections>k__BackingField;
    public int RevertedDocuments { get; public set; }
    private int _failedCollections { get; private set; }
    public bool CanMerge { get; }
    [CompilerGeneratedAttribute]
public int get_RevertedDocuments();
    [CompilerGeneratedAttribute]
public void set_RevertedDocuments(int value);
    [CompilerGeneratedAttribute]
private int get__failedCollections();
    [CompilerGeneratedAttribute]
private void set__failedCollections(int value);
    public virtual bool get_CanMerge();
    public virtual void MergeWith(IOperationResult result);
    public virtual void MergeWith(IOperationProgress progress);
    public virtual IOperationProgress Clone();
    public virtual DynamicJsonValue ToJson();
    public void WarnAboutFailedCollection(string message);
}
public class Raven.Client.Documents.Operations.Revisions.RevertRevisionsByIdOperation : object {
    private Dictionary`2<string, string> _idToChangeVector;
    public RevertRevisionsByIdOperation(Dictionary`2<string, string> idToChangeVector);
    public RevertRevisionsByIdOperation(string id, string cv);
    public sealed virtual RavenCommand GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
}
internal class Raven.Client.Documents.Operations.Revisions.RevisionIncludeResult : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Before>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <Revision>k__BackingField;
    public string Id { get; public set; }
    public string ChangeVector { get; public set; }
    public DateTime Before { get; public set; }
    public BlittableJsonReaderObject Revision { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_ChangeVector();
    [CompilerGeneratedAttribute]
public void set_ChangeVector(string value);
    [CompilerGeneratedAttribute]
public DateTime get_Before();
    [CompilerGeneratedAttribute]
public void set_Before(DateTime value);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_Revision();
    [CompilerGeneratedAttribute]
public void set_Revision(BlittableJsonReaderObject value);
}
public class Raven.Client.Documents.Operations.Revisions.RevisionsCollectionConfiguration : object {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MinimumRevisionsToKeep>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <MinimumRevisionAgeToKeep>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PurgeOnDelete>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MaximumRevisionsToDeleteUponDocumentUpdate>k__BackingField;
    public Nullable`1<long> MinimumRevisionsToKeep { get; public set; }
    public Nullable`1<TimeSpan> MinimumRevisionAgeToKeep { get; public set; }
    public bool Disabled { get; public set; }
    public bool PurgeOnDelete { get; public set; }
    public Nullable`1<long> MaximumRevisionsToDeleteUponDocumentUpdate { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MinimumRevisionsToKeep();
    [CompilerGeneratedAttribute]
public void set_MinimumRevisionsToKeep(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_MinimumRevisionAgeToKeep();
    [CompilerGeneratedAttribute]
public void set_MinimumRevisionAgeToKeep(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_PurgeOnDelete();
    [CompilerGeneratedAttribute]
public void set_PurgeOnDelete(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MaximumRevisionsToDeleteUponDocumentUpdate();
    [CompilerGeneratedAttribute]
public void set_MaximumRevisionsToDeleteUponDocumentUpdate(Nullable`1<long> value);
    private bool Equals(RevisionsCollectionConfiguration other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public DynamicJsonValue ToJson();
    public DynamicJsonValue ToAuditJson();
}
public class Raven.Client.Documents.Operations.Revisions.RevisionsConfiguration : object {
    [CompilerGeneratedAttribute]
private RevisionsCollectionConfiguration <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, RevisionsCollectionConfiguration> <Collections>k__BackingField;
    public RevisionsCollectionConfiguration Default { get; public set; }
    public Dictionary`2<string, RevisionsCollectionConfiguration> Collections { get; public set; }
    [CompilerGeneratedAttribute]
public RevisionsCollectionConfiguration get_Default();
    [CompilerGeneratedAttribute]
public void set_Default(RevisionsCollectionConfiguration value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, RevisionsCollectionConfiguration> get_Collections();
    [CompilerGeneratedAttribute]
public void set_Collections(Dictionary`2<string, RevisionsCollectionConfiguration> value);
    public bool Equals(RevisionsConfiguration other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void FillFromBlittableJson(BlittableJsonReaderObject json);
    public DynamicJsonValue ToJson();
    public DynamicJsonValue ToAuditJson();
}
public class Raven.Client.Documents.Operations.Revisions.RevisionsResult`1 : object {
    [CompilerGeneratedAttribute]
private List`1<T> <Results>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalResults>k__BackingField;
    public List`1<T> Results { get; public set; }
    public int TotalResults { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<T> get_Results();
    [CompilerGeneratedAttribute]
public void set_Results(List`1<T> value);
    [CompilerGeneratedAttribute]
public int get_TotalResults();
    [CompilerGeneratedAttribute]
public void set_TotalResults(int value);
}
public abstract class Raven.Client.Documents.Operations.ShardNodeOperationResult`1 : object {
    [CompilerGeneratedAttribute]
private int <ShardNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private TResult <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public int ShardNumber { get; public set; }
    public string NodeTag { get; public set; }
    public TResult Result { get; public set; }
    public string Message { get; private set; }
    public bool ShouldPersist { get; }
    public bool CanMerge { get; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_ShardNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ShardNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_NodeTag();
    [CompilerGeneratedAttribute]
public sealed virtual void set_NodeTag(string value);
    [CompilerGeneratedAttribute]
public sealed virtual TResult get_Result();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Result(TResult value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(string value);
    public sealed virtual DynamicJsonValue ToJson();
    public abstract virtual bool get_ShouldPersist();
    public sealed virtual bool get_CanMerge();
    public sealed virtual void MergeWith(IOperationResult result);
}
public class Raven.Client.Documents.Operations.Sorters.DeleteSorterOperation : object {
    private string _sorterName;
    public DeleteSorterOperation(string sorterName);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.Sorters.PutSortersOperation : object {
    private SorterDefinition[] _sortersToAdd;
    public PutSortersOperation(SorterDefinition[] sortersToAdd);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public abstract class Raven.Client.Documents.Operations.TimeSeries.AbstractTimeSeriesRange : object {
    public string Name;
}
public class Raven.Client.Documents.Operations.TimeSeries.ConfigureRawTimeSeriesPolicyOperation : ConfigureTimeSeriesPolicyOperation {
    public ConfigureRawTimeSeriesPolicyOperation(string collection, RawTimeSeriesPolicy config);
}
public class Raven.Client.Documents.Operations.TimeSeries.ConfigureTimeSeriesOperation : object {
    private TimeSeriesConfiguration _configuration;
    public ConfigureTimeSeriesOperation(TimeSeriesConfiguration configuration);
    public sealed virtual RavenCommand`1<ConfigureTimeSeriesOperationResult> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.Documents.Operations.TimeSeries.ConfigureTimeSeriesOperationResult : object {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <RaftCommandIndex>k__BackingField;
    public Nullable`1<long> RaftCommandIndex { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_RaftCommandIndex();
    [CompilerGeneratedAttribute]
public void set_RaftCommandIndex(Nullable`1<long> value);
}
public class Raven.Client.Documents.Operations.TimeSeries.ConfigureTimeSeriesPolicyOperation : object {
    private string _collection;
    private TimeSeriesPolicy _config;
    public ConfigureTimeSeriesPolicyOperation(string collection, TimeSeriesPolicy config);
    public sealed virtual RavenCommand`1<ConfigureTimeSeriesOperationResult> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.TimeSeries.ConfigureTimeSeriesValueNamesOperation : object {
    private Parameters _parameters;
    public ConfigureTimeSeriesValueNamesOperation(Parameters parameters);
    public sealed virtual RavenCommand`1<ConfigureTimeSeriesOperationResult> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.Documents.Operations.TimeSeries.GetMultipleTimeSeriesOperation : object {
    private string _docId;
    private IEnumerable`1<TimeSeriesRange> _ranges;
    private int _start;
    private int _pageSize;
    private Action`1<ITimeSeriesIncludeBuilder> _includes;
    private bool _returnFullResults;
    public GetMultipleTimeSeriesOperation(string docId, IEnumerable`1<TimeSeriesRange> ranges, int start, int pageSize, bool returnFullResults);
    internal GetMultipleTimeSeriesOperation(string docId, IEnumerable`1<TimeSeriesRange> ranges, int start, int pageSize, Action`1<ITimeSeriesIncludeBuilder> includes, bool returnFullResults);
    public sealed virtual RavenCommand`1<TimeSeriesDetails> GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
}
internal class Raven.Client.Documents.Operations.TimeSeries.GetMultipleTimeSeriesRangesCommand : RavenCommand`1<Response> {
    private DocumentConventions _conventions;
    private int _start;
    private int _pageSize;
    private bool _returnFullResults;
    private RequestBody _ranges;
    public bool IsReadRequest { get; }
    public GetMultipleTimeSeriesRangesCommand(DocumentConventions conventions, Dictionary`2<string, List`1<TimeSeriesRange>> ranges, int start, int pageSize, bool returnFullResults);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
}
public class Raven.Client.Documents.Operations.TimeSeries.GetTimeSeriesOperation : GetTimeSeriesOperation`1<TimeSeriesEntry> {
    public GetTimeSeriesOperation(string docId, string timeseries, Nullable`1<DateTime> from, Nullable`1<DateTime> to, int start, int pageSize, bool returnFullResults);
}
public class Raven.Client.Documents.Operations.TimeSeries.GetTimeSeriesOperation`1 : object {
    private string _docId;
    private string _name;
    private int _start;
    private int _pageSize;
    private Nullable`1<DateTime> _from;
    private Nullable`1<DateTime> _to;
    private Action`1<ITimeSeriesIncludeBuilder> _includes;
    private bool _returnFullResults;
    public GetTimeSeriesOperation`1(string docId, string timeseries, Nullable`1<DateTime> from, Nullable`1<DateTime> to, int start, int pageSize, bool returnFullResults);
    internal GetTimeSeriesOperation`1(string docId, string timeseries, Nullable`1<DateTime> from, Nullable`1<DateTime> to, int start, int pageSize, Action`1<ITimeSeriesIncludeBuilder> includes, bool returnFullResults);
    public sealed virtual RavenCommand`1<TimeSeriesRangeResult`1<TValues>> GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
}
public class Raven.Client.Documents.Operations.TimeSeries.GetTimeSeriesStatisticsOperation : object {
    private string _documentId;
    public GetTimeSeriesStatisticsOperation(string documentId);
    public sealed virtual RavenCommand`1<TimeSeriesStatistics> GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
}
public class Raven.Client.Documents.Operations.TimeSeries.RawTimeSeriesPolicy : TimeSeriesPolicy {
    internal static string PolicyString;
    public static RawTimeSeriesPolicy Default { get; }
    public RawTimeSeriesPolicy(TimeValue retentionTime);
    public static RawTimeSeriesPolicy get_Default();
    public static bool IsRaw(TimeSeriesPolicy policy);
}
public class Raven.Client.Documents.Operations.TimeSeries.RemoveTimeSeriesPolicyOperation : object {
    private string _collection;
    private string _name;
    public RemoveTimeSeriesPolicyOperation(string collection, string name);
    public sealed virtual RavenCommand`1<ConfigureTimeSeriesOperationResult> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.TimeSeries.TimeSeriesBatchOperation : object {
    private string _documentId;
    private TimeSeriesOperation _operation;
    public TimeSeriesBatchOperation(string documentId, TimeSeriesOperation operation);
    public sealed virtual RavenCommand GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
}
public class Raven.Client.Documents.Operations.TimeSeries.TimeSeriesCollectionConfiguration : object {
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TimeSeriesPolicy> <Policies>k__BackingField;
    [CompilerGeneratedAttribute]
private RawTimeSeriesPolicy <RawPolicy>k__BackingField;
    private ConcurrentDictionary`2<string, int> _policyIndexCache;
    private Nullable`1<TimeValue> _maxRetention;
    public bool Disabled { get; public set; }
    public List`1<TimeSeriesPolicy> Policies { get; public set; }
    public RawTimeSeriesPolicy RawPolicy { get; public set; }
    internal TimeValue MaxRetention { get; }
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    [CompilerGeneratedAttribute]
public List`1<TimeSeriesPolicy> get_Policies();
    [CompilerGeneratedAttribute]
public void set_Policies(List`1<TimeSeriesPolicy> value);
    [CompilerGeneratedAttribute]
public RawTimeSeriesPolicy get_RawPolicy();
    [CompilerGeneratedAttribute]
public void set_RawPolicy(RawTimeSeriesPolicy value);
    private bool Equals(TimeSeriesCollectionConfiguration other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal void ValidateAndInitialize();
    internal TimeSeriesPolicy GetPolicyByName(string policy, Int32& policyIndex);
    internal TimeSeriesPolicy GetNextPolicy(TimeSeriesPolicy policy);
    internal TimeValue get_MaxRetention();
    internal int GetPolicyIndexByTimeSeries(string name);
    internal TimeSeriesPolicy GetPolicy(int policyIndex);
    internal TimeSeriesPolicy GetNextPolicy(int policyIndex);
    internal TimeSeriesPolicy GetPreviousPolicy(int policyIndex);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.TimeSeries.TimeSeriesConfiguration : object {
    internal static char TimeSeriesRollupSeparator;
    internal static TimeSpan DefaultPolicyCheckFrequency;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, TimeSeriesCollectionConfiguration> <Collections>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <PolicyCheckFrequency>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Dictionary`2<string, String[]>> <NamedValues>k__BackingField;
    public Dictionary`2<string, TimeSeriesCollectionConfiguration> Collections { get; public set; }
    public Nullable`1<TimeSpan> PolicyCheckFrequency { get; public set; }
    public Dictionary`2<string, Dictionary`2<string, String[]>> NamedValues { get; public set; }
    private static TimeSeriesConfiguration();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, TimeSeriesCollectionConfiguration> get_Collections();
    [CompilerGeneratedAttribute]
public void set_Collections(Dictionary`2<string, TimeSeriesCollectionConfiguration> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_PolicyCheckFrequency();
    [CompilerGeneratedAttribute]
public void set_PolicyCheckFrequency(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Dictionary`2<string, String[]>> get_NamedValues();
    [CompilerGeneratedAttribute]
public void set_NamedValues(Dictionary`2<string, Dictionary`2<string, String[]>> value);
    internal void InitializeRollupAndRetention();
    private bool IsNullOrEmpty();
    internal bool PolicyConfigurationChanged(TimeSeriesConfiguration other);
    public sealed virtual DynamicJsonValue ToJson();
    public void AddValueName(string collection, string timeSeries, String[] names);
    public bool TryAddValueName(string collection, string timeSeries, String[] names);
    public String[] GetNames(string collection, string timeSeries);
    [OnDeserializedAttribute]
internal void OnNewtonSoftJsonDeserialized(StreamingContext context);
    private sealed virtual override void Sparrow.Json.IPostJsonDeserialization.PostDeserialization();
    private void InternalPostJsonDeserialization();
    private void PopulatePolicies();
    private void PopulateNamedValues();
}
internal class Raven.Client.Documents.Operations.TimeSeries.TimeSeriesCountRange : AbstractTimeSeriesRange {
    public int Count;
    public TimeSeriesRangeType Type;
}
public class Raven.Client.Documents.Operations.TimeSeries.TimeSeriesDetails : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, List`1<TimeSeriesRangeResult>> <Values>k__BackingField;
    public string Id { get; public set; }
    public Dictionary`2<string, List`1<TimeSeriesRangeResult>> Values { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, List`1<TimeSeriesRangeResult>> get_Values();
    [CompilerGeneratedAttribute]
public void set_Values(Dictionary`2<string, List`1<TimeSeriesRangeResult>> value);
}
internal class Raven.Client.Documents.Operations.TimeSeries.TimeSeriesDownSamplePolicyComparer : object {
    public static TimeSeriesDownSamplePolicyComparer Instance;
    private static TimeSeriesDownSamplePolicyComparer();
    public sealed virtual int Compare(TimeSeriesPolicy x, TimeSeriesPolicy y);
}
public class Raven.Client.Documents.Operations.TimeSeries.TimeSeriesItemDetail : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfEntries>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartDate>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <EndDate>k__BackingField;
    public string Name { get; public set; }
    public long NumberOfEntries { get; public set; }
    public DateTime StartDate { get; public set; }
    public DateTime EndDate { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public long get_NumberOfEntries();
    [CompilerGeneratedAttribute]
public void set_NumberOfEntries(long value);
    [CompilerGeneratedAttribute]
public DateTime get_StartDate();
    [CompilerGeneratedAttribute]
public void set_StartDate(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_EndDate();
    [CompilerGeneratedAttribute]
public void set_EndDate(DateTime value);
    public DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Operations.TimeSeries.TimeSeriesOperation : object {
    private SortedList`2<long, AppendOperation> _appends;
    private SortedList`2<long, IncrementOperation> _increments;
    internal List`1<DeleteOperation> Deletes;
    public string Name;
    private static string TimeSeriesFormat;
    private static long EpochTicks;
    internal IList`1<AppendOperation> Appends { get; private set; }
    internal IList`1<IncrementOperation> Increments { get; private set; }
    private static TimeSeriesOperation();
    internal IList`1<AppendOperation> get_Appends();
    private void set_Appends(IList`1<AppendOperation> value);
    internal IList`1<IncrementOperation> get_Increments();
    private void set_Increments(IList`1<IncrementOperation> value);
    public void Increment(IncrementOperation incrementOperation);
    public void Append(AppendOperation appendOperation);
    public void Delete(DeleteOperation deleteOperation);
    internal static TimeSeriesOperation Parse(BlittableJsonReaderObject input);
    private static long FromUnixMs(long unixMs);
    private static long FromUnixNs(long unixNs);
    internal static TimeSeriesOperation ParseForBulkInsert(BlittableJsonReaderObject input);
    private static void ThrowNotBlittableJsonReaderObjectOperation(object op);
    private static void ThrowNotBlittableJsonReaderArrayOperation(object op);
    private static void ThrowNotString(object obj);
    private static void ThrowMissingProperty(string prop);
    public DynamicJsonValue ToJson();
    [CompilerGeneratedAttribute]
internal static long <ParseForBulkInsert>g__GetLong|19_0(object value);
}
public class Raven.Client.Documents.Operations.TimeSeries.TimeSeriesPolicy : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeValue <RetentionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeValue <AggregationTime>k__BackingField;
    internal static TimeSeriesPolicy AfterAllPolices;
    internal static TimeSeriesPolicy BeforeAllPolices;
    public string Name { get; protected set; }
    public TimeValue RetentionTime { get; protected set; }
    public TimeValue AggregationTime { get; private set; }
    public TimeSeriesPolicy(string name, TimeValue aggregationTime);
    public TimeSeriesPolicy(string name, TimeValue aggregationTime, TimeValue retentionTime);
    private static TimeSeriesPolicy();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
protected void set_Name(string value);
    [CompilerGeneratedAttribute]
public TimeValue get_RetentionTime();
    [CompilerGeneratedAttribute]
protected void set_RetentionTime(TimeValue value);
    [CompilerGeneratedAttribute]
public TimeValue get_AggregationTime();
    [CompilerGeneratedAttribute]
private void set_AggregationTime(TimeValue value);
    public string GetTimeSeriesName(string rawName);
    public sealed virtual DynamicJsonValue ToJson();
    protected bool Equals(TimeSeriesPolicy other);
    public sealed virtual int CompareTo(TimeSeriesPolicy other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Raven.Client.Documents.Operations.TimeSeries.TimeSeriesRange : AbstractTimeSeriesRange {
    public Nullable`1<DateTime> From;
    public Nullable`1<DateTime> To;
}
public class Raven.Client.Documents.Operations.TimeSeries.TimeSeriesRangeResult : object {
    public DateTime From;
    public DateTime To;
    public TimeSeriesEntry[] Entries;
    public Nullable`1<long> TotalResults;
    internal string Hash;
    public BlittableJsonReaderObject Includes;
    internal List`1<string> MissingIncludes;
    [OnDeserializedAttribute]
internal void OnNewtonSoftJsonDeserialized(StreamingContext context);
    private sealed virtual override void Sparrow.Json.IPostJsonDeserialization.PostDeserialization();
    private void SetMinMaxDateTime();
}
public class Raven.Client.Documents.Operations.TimeSeries.TimeSeriesRangeResult`1 : TimeSeriesRangeResult {
    public TValues[] Entries;
}
public enum Raven.Client.Documents.Operations.TimeSeries.TimeSeriesRangeType : Enum {
    public int value__;
    public static TimeSeriesRangeType None;
    public static TimeSeriesRangeType Last;
}
public class Raven.Client.Documents.Operations.TimeSeries.TimeSeriesStatistics : object {
    [CompilerGeneratedAttribute]
private string <DocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TimeSeriesItemDetail> <TimeSeries>k__BackingField;
    public string DocumentId { get; public set; }
    public List`1<TimeSeriesItemDetail> TimeSeries { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DocumentId();
    [CompilerGeneratedAttribute]
public void set_DocumentId(string value);
    [CompilerGeneratedAttribute]
public List`1<TimeSeriesItemDetail> get_TimeSeries();
    [CompilerGeneratedAttribute]
public void set_TimeSeries(List`1<TimeSeriesItemDetail> value);
    public DynamicJsonValue ToJson();
}
internal class Raven.Client.Documents.Operations.TimeSeries.TimeSeriesTimeRange : AbstractTimeSeriesRange {
    public TimeValue Time;
    public TimeSeriesRangeType Type;
}
public class Raven.Client.Documents.Operations.TransactionsRecording.ReplayTransactionsRecordingOperation : object {
    private Stream _replayStream;
    private long _operationId;
    public ReplayTransactionsRecordingOperation(Stream replayStream, long operationId);
    public sealed virtual RavenCommand`1<ReplayTxOperationResult> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.TransactionsRecording.ReplayTxOperationResult : object {
    [CompilerGeneratedAttribute]
private long <ExecutedCommandsAmount>k__BackingField;
    public long ExecutedCommandsAmount { get; public set; }
    public string Message { get; }
    public bool ShouldPersist { get; }
    private bool Raven.Client.Documents.Operations.IOperationResult.CanMerge { get; }
    [CompilerGeneratedAttribute]
public long get_ExecutedCommandsAmount();
    [CompilerGeneratedAttribute]
public void set_ExecutedCommandsAmount(long value);
    public sealed virtual string get_Message();
    public sealed virtual DynamicJsonValue ToJson();
    public sealed virtual bool get_ShouldPersist();
    private sealed virtual override bool Raven.Client.Documents.Operations.IOperationResult.get_CanMerge();
    private sealed virtual override void Raven.Client.Documents.Operations.IOperationResult.MergeWith(IOperationResult result);
}
public class Raven.Client.Documents.Operations.TransactionsRecording.StartTransactionsRecordingOperation : object {
    private string _filePath;
    public StartTransactionsRecordingOperation(string filePath);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Operations.TransactionsRecording.StopTransactionsRecordingOperation : object {
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.Documents.Queries.Explanation.ExplanationOptions : object {
    [CompilerGeneratedAttribute]
private string <GroupKey>k__BackingField;
    public string GroupKey { get; public set; }
    [CompilerGeneratedAttribute]
public string get_GroupKey();
    [CompilerGeneratedAttribute]
public void set_GroupKey(string value);
}
public class Raven.Client.Documents.Queries.Explanation.Explanations : object {
    private Dictionary`2<string, String[]> _explanations;
    [CompilerGeneratedAttribute]
private bool <ShouldBeIncluded>k__BackingField;
    internal bool ShouldBeIncluded { get; internal set; }
    [CompilerGeneratedAttribute]
internal bool get_ShouldBeIncluded();
    [CompilerGeneratedAttribute]
internal void set_ShouldBeIncluded(bool value);
    public String[] GetExplanations(string key);
    internal void Update(QueryResult queryResult);
}
internal class Raven.Client.Documents.Queries.Facets.AggregationDocumentQuery`1 : AggregationQueryBase {
    private AbstractDocumentQuery`2<T, DocumentQuery`1<T>> _source;
    public AggregationDocumentQuery`1(DocumentQuery`1<T> source);
    public sealed virtual IAggregationDocumentQuery`1<T> AndAggregateBy(Action`1<IFacetBuilder`1<T>> builder);
    public sealed virtual IAggregationDocumentQuery`1<T> AndAggregateBy(FacetBase facet);
    protected virtual IndexQuery GetIndexQuery(bool isAsync, bool updateAfterQueryExecuted);
    protected virtual void InvokeAfterQueryExecuted(QueryResult result);
}
internal class Raven.Client.Documents.Queries.Facets.AggregationQuery`1 : AggregationQueryBase {
    private IQueryable`1<T> _source;
    private Func`2<IQueryable`1<T>, Expression> _convertExpressionIfNecessary;
    private Func`3<MethodInfo, Type, MethodInfo> _convertMethodIfNecessary;
    private MethodInfo _aggregateByMethod;
    public AggregationQuery`1(IQueryable`1<T> source, Func`2<IQueryable`1<T>, Expression> convertExpressionIfNecessary, Func`3<MethodInfo, Type, MethodInfo> convertMethodIfNecessary, MethodInfo aggregateByMethod);
    public sealed virtual IAggregationQuery`1<T> AndAggregateBy(Action`1<IFacetBuilder`1<T>> builder);
    public sealed virtual IAggregationQuery`1<T> AndAggregateBy(FacetBase facet);
    protected virtual IndexQuery GetIndexQuery(bool isAsync, bool updateAfterQueryExecuted);
    protected virtual void InvokeAfterQueryExecuted(QueryResult result);
}
internal abstract class Raven.Client.Documents.Queries.Facets.AggregationQueryBase : object {
    private InMemoryDocumentSessionOperations _session;
    private IndexQuery _query;
    private Stopwatch _duration;
    protected AggregationQueryBase(InMemoryDocumentSessionOperations session);
    public sealed virtual Dictionary`2<string, FacetResult> Execute();
    [AsyncStateMachineAttribute("Raven.Client.Documents.Queries.Facets.AggregationQueryBase/<ExecuteAsync>d__5")]
public sealed virtual Task`1<Dictionary`2<string, FacetResult>> ExecuteAsync(CancellationToken token);
    public sealed virtual Lazy`1<Dictionary`2<string, FacetResult>> ExecuteLazy(Action`1<Dictionary`2<string, FacetResult>> onEval);
    public sealed virtual Lazy`1<Task`1<Dictionary`2<string, FacetResult>>> ExecuteLazyAsync(Action`1<Dictionary`2<string, FacetResult>> onEval, CancellationToken token);
    protected abstract virtual IndexQuery GetIndexQuery(bool isAsync, bool updateAfterQueryExecuted);
    protected abstract virtual void InvokeAfterQueryExecuted(QueryResult result);
    private Dictionary`2<string, FacetResult> ProcessResults(QueryResult queryResult);
    private QueryCommand GetCommand(bool isAsync);
    public virtual string ToString();
}
internal class Raven.Client.Documents.Queries.Facets.AggregationRawDocumentQuery`1 : AggregationQueryBase {
    private IRawDocumentQuery`1<T> _source;
    public AggregationRawDocumentQuery`1(IRawDocumentQuery`1<T> source, IDocumentSession session);
    protected virtual IndexQuery GetIndexQuery(bool isAsync, bool updateAfterQueryExecuted);
    protected virtual void InvokeAfterQueryExecuted(QueryResult result);
}
internal class Raven.Client.Documents.Queries.Facets.AsyncAggregationDocumentQuery`1 : AggregationQueryBase {
    private AbstractDocumentQuery`2<T, AsyncDocumentQuery`1<T>> _source;
    public AsyncAggregationDocumentQuery`1(AsyncDocumentQuery`1<T> source);
    public sealed virtual IAsyncAggregationDocumentQuery`1<T> AndAggregateBy(Action`1<IFacetBuilder`1<T>> builder);
    public sealed virtual IAsyncAggregationDocumentQuery`1<T> AndAggregateBy(FacetBase facet);
    protected virtual IndexQuery GetIndexQuery(bool isAsync, bool updateAfterQueryExecuted);
    protected virtual void InvokeAfterQueryExecuted(QueryResult result);
}
internal class Raven.Client.Documents.Queries.Facets.AsyncAggregationRawDocumentQuery`1 : AggregationQueryBase {
    private IAsyncRawDocumentQuery`1<T> _source;
    public AsyncAggregationRawDocumentQuery`1(IAsyncRawDocumentQuery`1<T> source, IAsyncDocumentSession session);
    protected virtual IndexQuery GetIndexQuery(bool isAsync, bool updateAfterQueryExecuted);
    protected virtual void InvokeAfterQueryExecuted(QueryResult result);
}
public class Raven.Client.Documents.Queries.Facets.Facet : FacetBase {
    internal Func`2<DocumentConventions, string> _originalFieldNamePathEvaluator;
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private FacetOptions <Options>k__BackingField;
    public string FieldName { get; public set; }
    public FacetOptions Options { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FieldName();
    [CompilerGeneratedAttribute]
public void set_FieldName(string value);
    [CompilerGeneratedAttribute]
public FacetOptions get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(FacetOptions value);
    internal virtual FacetToken ToFacetToken(DocumentConventions conventions, Func`2<object, string> addQueryParameter);
    internal static Facet Create(BlittableJsonReaderObject json);
}
public class Raven.Client.Documents.Queries.Facets.Facet`1 : FacetBase {
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<T, object>> <FieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private FacetOptions <Options>k__BackingField;
    public Expression`1<Func`2<T, object>> FieldName { get; public set; }
    public FacetOptions Options { get; public set; }
    [CompilerGeneratedAttribute]
public Expression`1<Func`2<T, object>> get_FieldName();
    [CompilerGeneratedAttribute]
public void set_FieldName(Expression`1<Func`2<T, object>> value);
    [CompilerGeneratedAttribute]
public FacetOptions get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(FacetOptions value);
    public static Facet op_Implicit(Facet`1<T> other);
    internal virtual FacetToken ToFacetToken(DocumentConventions conventions, Func`2<object, string> addQueryParameter);
}
public enum Raven.Client.Documents.Queries.Facets.FacetAggregation : Enum {
    public int value__;
    public static FacetAggregation None;
    public static FacetAggregation Max;
    public static FacetAggregation Min;
    public static FacetAggregation Average;
    public static FacetAggregation Sum;
}
public class Raven.Client.Documents.Queries.Facets.FacetAggregationField : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    public string Name { get; public set; }
    public string DisplayName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    private bool Equals(FacetAggregationField other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class Raven.Client.Documents.Queries.Facets.FacetBase : object {
    [JsonIgnoreAttribute]
private string _displayFieldName;
    [CompilerGeneratedAttribute]
private Dictionary`2<FacetAggregation, HashSet`1<FacetAggregationField>> <Aggregations>k__BackingField;
    public Dictionary`2<FacetAggregation, HashSet`1<FacetAggregationField>> Aggregations { get; public set; }
    public string DisplayFieldName { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<FacetAggregation, HashSet`1<FacetAggregationField>> get_Aggregations();
    [CompilerGeneratedAttribute]
public void set_Aggregations(Dictionary`2<FacetAggregation, HashSet`1<FacetAggregationField>> value);
    public string get_DisplayFieldName();
    public void set_DisplayFieldName(string value);
    internal abstract virtual FacetToken ToFacetToken(DocumentConventions conventions, Func`2<object, string> addQueryParameter);
    internal static void Fill(FacetBase facet, BlittableJsonReaderObject json);
}
internal class Raven.Client.Documents.Queries.Facets.FacetBuilder`1 : object {
    private DocumentConventions _conventions;
    private RangeFacet`1<T> _range;
    private Facet _default;
    private HashSet`1<string> _rqlKeywords;
    internal FacetBase Facet { get; }
    public FacetBuilder`1(DocumentConventions conventions);
    public sealed virtual IRangeFacetOperations`1<T> ByRanges(Expression`1<Func`2<T, bool>> path, Expression`1[] paths);
    public sealed virtual IFacetOperations`1<T> ByField(Expression`1<Func`2<T, object>> path);
    public sealed virtual IFacetOperations`1<T> ByField(string fieldName);
    public sealed virtual IFacetOperations`1<T> AllResults();
    public sealed virtual IFacetOperations`1<T> WithOptions(FacetOptions options);
    public sealed virtual IFacetOperations`1<T> WithDisplayName(string displayName);
    private sealed virtual override IRangeFacetOperations`1<T> Raven.Client.Documents.Queries.Facets.IFacetOperationsBase<T,Raven.Client.Documents.Queries.Facets.IRangeFacetOperations<T>>.SumOn(Expression`1<Func`2<T, object>> path, string displayName);
    private sealed virtual override IRangeFacetOperations`1<T> Raven.Client.Documents.Queries.Facets.IFacetOperationsBase<T,Raven.Client.Documents.Queries.Facets.IRangeFacetOperations<T>>.MinOn(Expression`1<Func`2<T, object>> path, string displayName);
    private sealed virtual override IRangeFacetOperations`1<T> Raven.Client.Documents.Queries.Facets.IFacetOperationsBase<T,Raven.Client.Documents.Queries.Facets.IRangeFacetOperations<T>>.MaxOn(Expression`1<Func`2<T, object>> path, string displayName);
    private sealed virtual override IRangeFacetOperations`1<T> Raven.Client.Documents.Queries.Facets.IFacetOperationsBase<T,Raven.Client.Documents.Queries.Facets.IRangeFacetOperations<T>>.AverageOn(Expression`1<Func`2<T, object>> path, string displayName);
    private sealed virtual override IRangeFacetOperations`1<T> Raven.Client.Documents.Queries.Facets.IFacetOperationsBase<T,Raven.Client.Documents.Queries.Facets.IRangeFacetOperations<T>>.WithDisplayName(string displayName);
    public sealed virtual IFacetOperations`1<T> SumOn(Expression`1<Func`2<T, object>> path, string displayName);
    public sealed virtual IFacetOperations`1<T> MinOn(Expression`1<Func`2<T, object>> path, string displayName);
    public sealed virtual IFacetOperations`1<T> MaxOn(Expression`1<Func`2<T, object>> path, string displayName);
    public sealed virtual IFacetOperations`1<T> AverageOn(Expression`1<Func`2<T, object>> path, string displayName);
    internal FacetBase get_Facet();
}
public class Raven.Client.Documents.Queries.Facets.FacetOptions : object {
    internal static FacetOptions Default;
    [CompilerGeneratedAttribute]
private FacetTermSortMode <TermSortMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeRemainingTerms>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PageSize>k__BackingField;
    public FacetTermSortMode TermSortMode { get; public set; }
    public bool IncludeRemainingTerms { get; public set; }
    public int Start { get; public set; }
    public int PageSize { get; public set; }
    private static FacetOptions();
    [CompilerGeneratedAttribute]
public FacetTermSortMode get_TermSortMode();
    [CompilerGeneratedAttribute]
public void set_TermSortMode(FacetTermSortMode value);
    [CompilerGeneratedAttribute]
public bool get_IncludeRemainingTerms();
    [CompilerGeneratedAttribute]
public void set_IncludeRemainingTerms(bool value);
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(int value);
    [CompilerGeneratedAttribute]
public int get_PageSize();
    [CompilerGeneratedAttribute]
public void set_PageSize(int value);
    internal static FacetOptions Create(BlittableJsonReaderObject json);
}
public class Raven.Client.Documents.Queries.Facets.FacetResult : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<FacetValue> <Values>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <RemainingTerms>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RemainingTermsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RemainingHits>k__BackingField;
    public string Name { get; public set; }
    public List`1<FacetValue> Values { get; public set; }
    public List`1<string> RemainingTerms { get; public set; }
    public int RemainingTermsCount { get; public set; }
    public int RemainingHits { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public List`1<FacetValue> get_Values();
    [CompilerGeneratedAttribute]
public void set_Values(List`1<FacetValue> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_RemainingTerms();
    [CompilerGeneratedAttribute]
public void set_RemainingTerms(List`1<string> value);
    [CompilerGeneratedAttribute]
public int get_RemainingTermsCount();
    [CompilerGeneratedAttribute]
public void set_RemainingTermsCount(int value);
    [CompilerGeneratedAttribute]
public int get_RemainingHits();
    [CompilerGeneratedAttribute]
public void set_RemainingHits(int value);
}
public class Raven.Client.Documents.Queries.Facets.FacetSetup : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Facet> <Facets>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<RangeFacet> <RangeFacets>k__BackingField;
    public string Id { get; public set; }
    public List`1<Facet> Facets { get; public set; }
    public List`1<RangeFacet> RangeFacets { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public List`1<Facet> get_Facets();
    [CompilerGeneratedAttribute]
public void set_Facets(List`1<Facet> value);
    [CompilerGeneratedAttribute]
public List`1<RangeFacet> get_RangeFacets();
    [CompilerGeneratedAttribute]
public void set_RangeFacets(List`1<RangeFacet> value);
    internal static FacetSetup Create(string id, BlittableJsonReaderObject json);
    private static List`1<RangeFacet> CreateRangeFacets(BlittableJsonReaderArray array);
    private static List`1<Facet> CreateFacets(BlittableJsonReaderArray array);
}
public enum Raven.Client.Documents.Queries.Facets.FacetTermSortMode : Enum {
    public int value__;
    public static FacetTermSortMode ValueAsc;
    public static FacetTermSortMode ValueDesc;
    public static FacetTermSortMode CountAsc;
    public static FacetTermSortMode CountDesc;
}
public class Raven.Client.Documents.Queries.Facets.FacetValue : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Sum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Max>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Average>k__BackingField;
    public string Name { get; public set; }
    public string Range { get; public set; }
    public int Count { get; public set; }
    public Nullable`1<double> Sum { get; public set; }
    public Nullable`1<double> Max { get; public set; }
    public Nullable`1<double> Min { get; public set; }
    public Nullable`1<double> Average { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Range();
    [CompilerGeneratedAttribute]
public void set_Range(string value);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Sum();
    [CompilerGeneratedAttribute]
public void set_Sum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Max();
    [CompilerGeneratedAttribute]
public void set_Max(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Min();
    [CompilerGeneratedAttribute]
public void set_Min(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Average();
    [CompilerGeneratedAttribute]
public void set_Average(Nullable`1<double> value);
    public virtual string ToString();
}
public interface Raven.Client.Documents.Queries.Facets.IAggregationDocumentQuery`1 {
    public abstract virtual IAggregationDocumentQuery`1<T> AndAggregateBy(Action`1<IFacetBuilder`1<T>> builder);
    public abstract virtual IAggregationDocumentQuery`1<T> AndAggregateBy(FacetBase facet);
    public abstract virtual Dictionary`2<string, FacetResult> Execute();
    public abstract virtual Lazy`1<Dictionary`2<string, FacetResult>> ExecuteLazy(Action`1<Dictionary`2<string, FacetResult>> onEval);
}
public interface Raven.Client.Documents.Queries.Facets.IAggregationQuery`1 {
    public abstract virtual IAggregationQuery`1<T> AndAggregateBy(Action`1<IFacetBuilder`1<T>> builder);
    public abstract virtual IAggregationQuery`1<T> AndAggregateBy(FacetBase facet);
    public abstract virtual Dictionary`2<string, FacetResult> Execute();
    public abstract virtual Task`1<Dictionary`2<string, FacetResult>> ExecuteAsync(CancellationToken token);
    public abstract virtual Lazy`1<Dictionary`2<string, FacetResult>> ExecuteLazy(Action`1<Dictionary`2<string, FacetResult>> onEval);
    public abstract virtual Lazy`1<Task`1<Dictionary`2<string, FacetResult>>> ExecuteLazyAsync(Action`1<Dictionary`2<string, FacetResult>> onEval, CancellationToken token);
}
public interface Raven.Client.Documents.Queries.Facets.IAsyncAggregationDocumentQuery`1 {
    public abstract virtual IAsyncAggregationDocumentQuery`1<T> AndAggregateBy(Action`1<IFacetBuilder`1<T>> builder);
    public abstract virtual IAsyncAggregationDocumentQuery`1<T> AndAggregateBy(FacetBase facet);
    public abstract virtual Task`1<Dictionary`2<string, FacetResult>> ExecuteAsync(CancellationToken token);
    public abstract virtual Lazy`1<Task`1<Dictionary`2<string, FacetResult>>> ExecuteLazyAsync(Action`1<Dictionary`2<string, FacetResult>> onEval, CancellationToken token);
}
public interface Raven.Client.Documents.Queries.Facets.IFacetBuilder`1 {
    public abstract virtual IRangeFacetOperations`1<T> ByRanges(Expression`1<Func`2<T, bool>> path, Expression`1[] paths);
    public abstract virtual IFacetOperations`1<T> ByField(Expression`1<Func`2<T, object>> path);
    public abstract virtual IFacetOperations`1<T> ByField(string fieldName);
    public abstract virtual IFacetOperations`1<T> AllResults();
}
public interface Raven.Client.Documents.Queries.Facets.IFacetOperations`1 {
    public abstract virtual IFacetOperations`1<T> WithOptions(FacetOptions options);
}
public interface Raven.Client.Documents.Queries.Facets.IFacetOperationsBase`2 {
    public abstract virtual TSelf WithDisplayName(string displayName);
    public abstract virtual TSelf SumOn(Expression`1<Func`2<T, object>> path, string displayName);
    public abstract virtual TSelf MinOn(Expression`1<Func`2<T, object>> path, string displayName);
    public abstract virtual TSelf MaxOn(Expression`1<Func`2<T, object>> path, string displayName);
    public abstract virtual TSelf AverageOn(Expression`1<Func`2<T, object>> path, string displayName);
}
public interface Raven.Client.Documents.Queries.Facets.IRangeFacetOperations`1 {
}
public class Raven.Client.Documents.Queries.Facets.RangeFacet : FacetBase {
    private FacetBase _parent;
    [CompilerGeneratedAttribute]
private List`1<string> <Ranges>k__BackingField;
    public List`1<string> Ranges { get; public set; }
    internal RangeFacet(FacetBase parent);
    [CompilerGeneratedAttribute]
public List`1<string> get_Ranges();
    [CompilerGeneratedAttribute]
public void set_Ranges(List`1<string> value);
    internal virtual FacetToken ToFacetToken(DocumentConventions conventions, Func`2<object, string> addQueryParameter);
    internal static RangeFacet Create(BlittableJsonReaderObject json);
}
public class Raven.Client.Documents.Queries.Facets.RangeFacet`1 : FacetBase {
    [CompilerGeneratedAttribute]
private List`1<Expression`1<Func`2<T, bool>>> <Ranges>k__BackingField;
    public List`1<Expression`1<Func`2<T, bool>>> Ranges { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<Expression`1<Func`2<T, bool>>> get_Ranges();
    [CompilerGeneratedAttribute]
public void set_Ranges(List`1<Expression`1<Func`2<T, bool>>> value);
    internal virtual FacetToken ToFacetToken(DocumentConventions conventions, Func`2<object, string> addQueryParameter);
    public static RangeFacet op_Implicit(RangeFacet`1<T> other);
    public static string Parse(Expression`1<Func`2<T, bool>> expr);
    public static string Parse(Expression`1<Func`2<T, bool>> expr, DocumentConventions documentConventions);
    public static string Parse(string prefix, LambdaExpression expr);
    public static string Parse(string prefix, LambdaExpression expr, DocumentConventions documentConventions);
    public static string Parse(string prefix, LambdaExpression expr, Func`2<object, string> addQueryParameter);
    public static string Parse(string prefix, LambdaExpression expr, Func`2<object, string> addQueryParameter, DocumentConventions documentConventions);
    private static string GetFieldName(string prefix, MemberExpression left, DocumentConventions conventions);
    private static object ParseSubExpression(BinaryExpression operation);
    private static object ParseMemberExpression(MemberExpression me);
    private static Expression SkipConvertExpressions(Expression expression);
    private static object ParseUnaryExpression(UnaryExpression expression);
    private static object TryInvokeLambda(Expression expression);
    private static string GetStringRepresentation(string fieldName, ExpressionType leftOp, ExpressionType rightOp, object lValue, object rValue, Func`2<object, string> addQueryParameter);
    private static string GetStringValue(object value, Func`2<object, string> addQueryParameter);
    private static string DefaultGetStringValue(object o);
    private static object EscapeString(string s);
    private static string GetStringRepresentation(string fieldName, ExpressionType op, object value, Func`2<object, string> addQueryParameter);
}
internal class Raven.Client.Documents.Queries.FilterFactory`1 : object {
    private IAbstractDocumentQuery`1<T> _documentQuery;
    public FilterFactory`1(IAbstractDocumentQuery`1<T> documentQuery, int filterLimit);
    public sealed virtual IFilterFactory`1<T> Equals(string fieldName, MethodCall value);
    public sealed virtual IFilterFactory`1<T> Equals(Expression`1<Func`2<T, object>> propertySelector, TValue value);
    public sealed virtual IFilterFactory`1<T> Equals(Expression`1<Func`2<T, object>> propertySelector, MethodCall value);
    public sealed virtual IFilterFactory`1<T> Equals(string fieldName, object value);
    public sealed virtual IFilterFactory`1<T> Equals(WhereParams WhereParams);
    public sealed virtual IFilterFactory`1<T> NotEquals(string fieldName, object value);
    public sealed virtual IFilterFactory`1<T> NotEquals(string fieldName, MethodCall value);
    public sealed virtual IFilterFactory`1<T> NotEquals(Expression`1<Func`2<T, object>> propertySelector, TValue value);
    public sealed virtual IFilterFactory`1<T> NotEquals(Expression`1<Func`2<T, object>> propertySelector, MethodCall value);
    public sealed virtual IFilterFactory`1<T> NotEquals(WhereParams WhereParams);
    public sealed virtual IFilterFactory`1<T> GreaterThan(string fieldName, object value);
    public sealed virtual IFilterFactory`1<T> GreaterThan(Expression`1<Func`2<T, object>> propertySelector, TValue value);
    public sealed virtual IFilterFactory`1<T> GreaterThanOrEqual(string fieldName, object value);
    public sealed virtual IFilterFactory`1<T> GreaterThanOrEqual(Expression`1<Func`2<T, object>> propertySelector, TValue value);
    public sealed virtual IFilterFactory`1<T> LessThan(string fieldName, object value);
    public sealed virtual IFilterFactory`1<T> LessThan(Expression`1<Func`2<T, object>> propertySelector, TValue value);
    public sealed virtual IFilterFactory`1<T> LessThanOrEqual(string fieldName, object value);
    public sealed virtual IFilterFactory`1<T> LessThanOrEqual(Expression`1<Func`2<T, object>> propertySelector, TValue value);
    public sealed virtual IFilterFactory`1<T> AndAlso();
    public sealed virtual IFilterFactory`1<T> OrElse();
    public sealed virtual IFilterFactory`1<T> Not();
    public sealed virtual IFilterFactory`1<T> OpenSubclause();
    public sealed virtual IFilterFactory`1<T> CloseSubclause();
    private string GetFieldName(Expression`1<Func`2<T, object>> propertySelector);
    private void SetFilterLimit(int limit);
}
public enum Raven.Client.Documents.Queries.GroupByMethod : Enum {
    public int value__;
    public static GroupByMethod None;
    public static GroupByMethod Array;
}
internal class Raven.Client.Documents.Queries.HashCalculator : ValueType {
    private JsonOperationContext _context;
    private IJsonSerializer _serializer;
    private UnmanagedWriteBuffer _buffer;
    public HashCalculator(JsonOperationContext ctx);
    public ulong GetHash();
    public void Write(float f);
    public void Write(long l);
    public void Write(ulong ul);
    public void Write(Nullable`1<long> l);
    public void Write(Nullable`1<float> f);
    public void Write(Nullable`1<int> i);
    public void Write(int i);
    public void Write(UInt32 ui);
    public void Write(short sh);
    public void Write(ushort ush);
    public void Write(bool b);
    public void Write(Nullable`1<bool> b);
    public void Write(sbyte sby);
    public void Write(char ch);
    public void Write(string s);
    public void Write(String[] s);
    public void Write(List`1<string> s);
    public sealed virtual void Dispose();
    public void Write(Parameters qp, DocumentConventions conventions, IJsonSerializer serializer);
    private void WriteParameterValue(object value, DocumentConventions conventions, IJsonSerializer serializer);
    internal void Write(BlittableJsonReaderObject json);
}
public class Raven.Client.Documents.Queries.Highlighting.HighlightingOptions : object {
    [CompilerGeneratedAttribute]
private string <GroupKey>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <PreTags>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <PostTags>k__BackingField;
    public string GroupKey { get; public set; }
    public String[] PreTags { get; public set; }
    public String[] PostTags { get; public set; }
    [CompilerGeneratedAttribute]
public string get_GroupKey();
    [CompilerGeneratedAttribute]
public void set_GroupKey(string value);
    [CompilerGeneratedAttribute]
public String[] get_PreTags();
    [CompilerGeneratedAttribute]
public void set_PreTags(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_PostTags();
    [CompilerGeneratedAttribute]
public void set_PostTags(String[] value);
}
public class Raven.Client.Documents.Queries.Highlighting.Highlightings : object {
    private Dictionary`2<string, String[]> _highlightings;
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    public string FieldName { get; }
    public IEnumerable`1<string> ResultIndents { get; }
    public Highlightings(string fieldName);
    [CompilerGeneratedAttribute]
public string get_FieldName();
    public IEnumerable`1<string> get_ResultIndents();
    public String[] GetFragments(string key);
    internal void Update(Dictionary`2<string, Dictionary`2<string, String[]>> highlightings);
}
public class Raven.Client.Documents.Queries.Highlighting.LinqQueryHighlightings : object {
    private List`1<Highlightings> _highlightings;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal List`1<ValueTuple`4<string, int, int, HighlightingOptions>> Highlightings;
    internal Highlightings Add(string fieldName, int fragmentLength, int fragmentCount, HighlightingOptions options);
    internal void Update(QueryResult queryResult);
}
public class Raven.Client.Documents.Queries.Highlighting.QueryHighlightings : object {
    private List`1<Highlightings> _highlightings;
    internal Highlightings Add(string fieldName);
    internal void Update(QueryResult queryResult);
}
public interface Raven.Client.Documents.Queries.IFilterFactory`1 {
    public abstract virtual IFilterFactory`1<T> Equals(string fieldName, MethodCall value);
    public abstract virtual IFilterFactory`1<T> Equals(Expression`1<Func`2<T, object>> propertySelector, TValue value);
    public abstract virtual IFilterFactory`1<T> Equals(Expression`1<Func`2<T, object>> propertySelector, MethodCall value);
    public abstract virtual IFilterFactory`1<T> Equals(string fieldName, object value);
    public abstract virtual IFilterFactory`1<T> Equals(WhereParams WhereParams);
    public abstract virtual IFilterFactory`1<T> NotEquals(string fieldName, object value);
    public abstract virtual IFilterFactory`1<T> NotEquals(string fieldName, MethodCall value);
    public abstract virtual IFilterFactory`1<T> NotEquals(Expression`1<Func`2<T, object>> propertySelector, TValue value);
    public abstract virtual IFilterFactory`1<T> NotEquals(Expression`1<Func`2<T, object>> propertySelector, MethodCall value);
    public abstract virtual IFilterFactory`1<T> NotEquals(WhereParams WhereParams);
    public abstract virtual IFilterFactory`1<T> GreaterThan(string fieldName, object value);
    public abstract virtual IFilterFactory`1<T> GreaterThan(Expression`1<Func`2<T, object>> propertySelector, TValue value);
    public abstract virtual IFilterFactory`1<T> GreaterThanOrEqual(string fieldName, object value);
    public abstract virtual IFilterFactory`1<T> GreaterThanOrEqual(Expression`1<Func`2<T, object>> propertySelector, TValue value);
    public abstract virtual IFilterFactory`1<T> LessThan(string fieldName, object value);
    public abstract virtual IFilterFactory`1<T> LessThan(Expression`1<Func`2<T, object>> propertySelector, TValue value);
    public abstract virtual IFilterFactory`1<T> LessThanOrEqual(string fieldName, object value);
    public abstract virtual IFilterFactory`1<T> LessThanOrEqual(Expression`1<Func`2<T, object>> propertySelector, TValue value);
    public abstract virtual IFilterFactory`1<T> AndAlso();
    public abstract virtual IFilterFactory`1<T> OrElse();
    public abstract virtual IFilterFactory`1<T> Not();
    public abstract virtual IFilterFactory`1<T> OpenSubclause();
    public abstract virtual IFilterFactory`1<T> CloseSubclause();
}
public interface Raven.Client.Documents.Queries.IIndexQuery {
    public Nullable`1<TimeSpan> WaitForNonStaleResultsTimeout { get; }
    public abstract virtual Nullable`1<TimeSpan> get_WaitForNonStaleResultsTimeout();
}
public class Raven.Client.Documents.Queries.IndexQuery : IndexQuery`1<Parameters> {
    [CompilerGeneratedAttribute]
private bool <DisableCaching>k__BackingField;
    public bool DisableCaching { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_DisableCaching();
    [CompilerGeneratedAttribute]
public void set_DisableCaching(bool value);
    public ulong GetQueryHash(JsonOperationContext ctx, DocumentConventions conventions, IJsonSerializer serializer);
    public virtual bool Equals(IndexQuery`1<Parameters> other);
    public virtual int GetHashCode();
}
public abstract class Raven.Client.Documents.Queries.IndexQuery`1 : IndexQueryBase`1<T> {
    [CompilerGeneratedAttribute]
private bool <SkipDuplicateChecking>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipStatistics>k__BackingField;
    public bool SkipDuplicateChecking { get; public set; }
    public bool SkipStatistics { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_SkipDuplicateChecking();
    [CompilerGeneratedAttribute]
public void set_SkipDuplicateChecking(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipStatistics();
    [CompilerGeneratedAttribute]
public void set_SkipStatistics(bool value);
    public virtual bool Equals(IndexQuery`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(IndexQuery`1<T> left, IndexQuery`1<T> right);
    public static bool op_Inequality(IndexQuery`1<T> left, IndexQuery`1<T> right);
}
public abstract class Raven.Client.Documents.Queries.IndexQueryBase`1 : object {
    [CompilerGeneratedAttribute]
private string <Query>k__BackingField;
    [CompilerGeneratedAttribute]
private T <QueryParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ProjectionBehavior> <ProjectionBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WaitForNonStaleResults>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <WaitForNonStaleResultsTimeout>k__BackingField;
    public string Query { get; public set; }
    public T QueryParameters { get; public set; }
    public Nullable`1<ProjectionBehavior> ProjectionBehavior { get; public set; }
    public bool WaitForNonStaleResults { get; public set; }
    public Nullable`1<TimeSpan> WaitForNonStaleResultsTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Query();
    [CompilerGeneratedAttribute]
public void set_Query(string value);
    [CompilerGeneratedAttribute]
public T get_QueryParameters();
    [CompilerGeneratedAttribute]
public void set_QueryParameters(T value);
    [CompilerGeneratedAttribute]
public Nullable`1<ProjectionBehavior> get_ProjectionBehavior();
    [CompilerGeneratedAttribute]
public void set_ProjectionBehavior(Nullable`1<ProjectionBehavior> value);
    [CompilerGeneratedAttribute]
public bool get_WaitForNonStaleResults();
    [CompilerGeneratedAttribute]
public void set_WaitForNonStaleResults(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<TimeSpan> get_WaitForNonStaleResultsTimeout();
    [CompilerGeneratedAttribute]
public void set_WaitForNonStaleResultsTimeout(Nullable`1<TimeSpan> value);
    public virtual string ToString();
    public virtual bool Equals(IndexQueryBase`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(IndexQueryBase`1<T> left, IndexQueryBase`1<T> right);
    public static bool op_Inequality(IndexQueryBase`1<T> left, IndexQueryBase`1<T> right);
}
public interface Raven.Client.Documents.Queries.MoreLikeThis.IMoreLikeThisBuilder`1 {
    public abstract virtual IMoreLikeThisOperations`1<T> UsingDocument(Expression`1<Func`2<T, bool>> predicate);
}
public interface Raven.Client.Documents.Queries.MoreLikeThis.IMoreLikeThisBuilderBase`1 {
    public abstract virtual IMoreLikeThisOperations`1<T> UsingAnyDocument();
    public abstract virtual IMoreLikeThisOperations`1<T> UsingDocument(string documentJson);
}
public interface Raven.Client.Documents.Queries.MoreLikeThis.IMoreLikeThisBuilderForAsyncDocumentQuery`1 {
    public abstract virtual IMoreLikeThisOperations`1<T> UsingDocument(Action`1<IFilterDocumentQueryBase`2<T, IAsyncDocumentQuery`1<T>>> predicate);
}
public interface Raven.Client.Documents.Queries.MoreLikeThis.IMoreLikeThisBuilderForDocumentQuery`1 {
    public abstract virtual IMoreLikeThisOperations`1<T> UsingDocument(Action`1<IFilterDocumentQueryBase`2<T, IDocumentQuery`1<T>>> predicate);
}
public interface Raven.Client.Documents.Queries.MoreLikeThis.IMoreLikeThisOperations`1 {
    public abstract virtual IMoreLikeThisOperations`1<T> WithOptions(MoreLikeThisOptions options);
}
public abstract class Raven.Client.Documents.Queries.MoreLikeThis.MoreLikeThisBase : object {
    [CompilerGeneratedAttribute]
private MoreLikeThisOptions <Options>k__BackingField;
    public MoreLikeThisOptions Options { get; public set; }
    [CompilerGeneratedAttribute]
public MoreLikeThisOptions get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(MoreLikeThisOptions value);
}
internal class Raven.Client.Documents.Queries.MoreLikeThis.MoreLikeThisBuilder`1 : object {
    [CompilerGeneratedAttribute]
private MoreLikeThisBase <MoreLikeThis>k__BackingField;
    internal MoreLikeThisBase MoreLikeThis { get; private set; }
    public sealed virtual IMoreLikeThisOperations`1<T> UsingAnyDocument();
    public sealed virtual IMoreLikeThisOperations`1<T> UsingDocument(string documentJson);
    public sealed virtual IMoreLikeThisOperations`1<T> UsingDocument(Action`1<IFilterDocumentQueryBase`2<T, IDocumentQuery`1<T>>> predicate);
    public sealed virtual IMoreLikeThisOperations`1<T> UsingDocument(Action`1<IFilterDocumentQueryBase`2<T, IAsyncDocumentQuery`1<T>>> predicate);
    public sealed virtual IMoreLikeThisOperations`1<T> UsingDocument(Expression`1<Func`2<T, bool>> predicate);
    public sealed virtual IMoreLikeThisOperations`1<T> WithOptions(MoreLikeThisOptions options);
    [CompilerGeneratedAttribute]
internal MoreLikeThisBase get_MoreLikeThis();
    [CompilerGeneratedAttribute]
private void set_MoreLikeThis(MoreLikeThisBase value);
}
public class Raven.Client.Documents.Queries.MoreLikeThis.MoreLikeThisOptions : object {
    public static int DefaultMaximumNumberOfTokensParsed;
    public static int DefaultMinimumTermFrequency;
    public static int DefaultMinimumDocumentFrequency;
    public static int DefaultMaximumDocumentFrequency;
    public static bool DefaultBoost;
    public static float DefaultBoostFactor;
    public static int DefaultMinimumWordLength;
    public static int DefaultMaximumWordLength;
    public static int DefaultMaximumQueryTerms;
    internal static MoreLikeThisOptions Default;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumTermFrequency>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumQueryTerms>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumNumberOfTokensParsed>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumWordLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumWordLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumDocumentFrequency>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumDocumentFrequency>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumDocumentFrequencyPercentage>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Boost>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<float> <BoostFactor>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StopWordsDocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Fields>k__BackingField;
    public Nullable`1<int> MinimumTermFrequency { get; public set; }
    public Nullable`1<int> MaximumQueryTerms { get; public set; }
    public Nullable`1<int> MaximumNumberOfTokensParsed { get; public set; }
    public Nullable`1<int> MinimumWordLength { get; public set; }
    public Nullable`1<int> MaximumWordLength { get; public set; }
    public Nullable`1<int> MinimumDocumentFrequency { get; public set; }
    public Nullable`1<int> MaximumDocumentFrequency { get; public set; }
    public Nullable`1<int> MaximumDocumentFrequencyPercentage { get; public set; }
    public Nullable`1<bool> Boost { get; public set; }
    public Nullable`1<float> BoostFactor { get; public set; }
    public string StopWordsDocumentId { get; public set; }
    public String[] Fields { get; public set; }
    private static MoreLikeThisOptions();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumTermFrequency();
    [CompilerGeneratedAttribute]
public void set_MinimumTermFrequency(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumQueryTerms();
    [CompilerGeneratedAttribute]
public void set_MaximumQueryTerms(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumNumberOfTokensParsed();
    [CompilerGeneratedAttribute]
public void set_MaximumNumberOfTokensParsed(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumWordLength();
    [CompilerGeneratedAttribute]
public void set_MinimumWordLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumWordLength();
    [CompilerGeneratedAttribute]
public void set_MaximumWordLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumDocumentFrequency();
    [CompilerGeneratedAttribute]
public void set_MinimumDocumentFrequency(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumDocumentFrequency();
    [CompilerGeneratedAttribute]
public void set_MaximumDocumentFrequency(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumDocumentFrequencyPercentage();
    [CompilerGeneratedAttribute]
public void set_MaximumDocumentFrequencyPercentage(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Boost();
    [CompilerGeneratedAttribute]
public void set_Boost(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<float> get_BoostFactor();
    [CompilerGeneratedAttribute]
public void set_BoostFactor(Nullable`1<float> value);
    [CompilerGeneratedAttribute]
public string get_StopWordsDocumentId();
    [CompilerGeneratedAttribute]
public void set_StopWordsDocumentId(string value);
    [CompilerGeneratedAttribute]
public String[] get_Fields();
    [CompilerGeneratedAttribute]
public void set_Fields(String[] value);
}
public class Raven.Client.Documents.Queries.MoreLikeThis.MoreLikeThisScope : object {
    private MoreLikeThisToken _token;
    private Func`2<object, string> _addQueryParameter;
    private Action _onDispose;
    public MoreLikeThisScope(MoreLikeThisToken token, Func`2<object, string> addQueryParameter, Action onDispose);
    public sealed virtual void Dispose();
    public void WithOptions(MoreLikeThisOptions options);
    public void WithDocument(string document);
}
public class Raven.Client.Documents.Queries.MoreLikeThis.MoreLikeThisStopWords : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <StopWords>k__BackingField;
    public string Id { get; public set; }
    public List`1<string> StopWords { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_StopWords();
    [CompilerGeneratedAttribute]
public void set_StopWords(List`1<string> value);
}
public class Raven.Client.Documents.Queries.MoreLikeThis.MoreLikeThisUsingAnyDocument : MoreLikeThisBase {
}
public class Raven.Client.Documents.Queries.MoreLikeThis.MoreLikeThisUsingDocument : MoreLikeThisBase {
    [CompilerGeneratedAttribute]
private string <DocumentJson>k__BackingField;
    public string DocumentJson { get; public set; }
    public MoreLikeThisUsingDocument(string documentJson);
    [CompilerGeneratedAttribute]
public string get_DocumentJson();
    [CompilerGeneratedAttribute]
public void set_DocumentJson(string value);
}
internal class Raven.Client.Documents.Queries.MoreLikeThis.MoreLikeThisUsingDocumentForDocumentQuery`1 : MoreLikeThisBase {
    [CompilerGeneratedAttribute]
private Action`1<IFilterDocumentQueryBase`2<T, IDocumentQuery`1<T>>> <ForDocumentQuery>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<IFilterDocumentQueryBase`2<T, IAsyncDocumentQuery`1<T>>> <ForAsyncDocumentQuery>k__BackingField;
    public Action`1<IFilterDocumentQueryBase`2<T, IDocumentQuery`1<T>>> ForDocumentQuery { get; public set; }
    public Action`1<IFilterDocumentQueryBase`2<T, IAsyncDocumentQuery`1<T>>> ForAsyncDocumentQuery { get; public set; }
    [CompilerGeneratedAttribute]
public Action`1<IFilterDocumentQueryBase`2<T, IDocumentQuery`1<T>>> get_ForDocumentQuery();
    [CompilerGeneratedAttribute]
public void set_ForDocumentQuery(Action`1<IFilterDocumentQueryBase`2<T, IDocumentQuery`1<T>>> value);
    [CompilerGeneratedAttribute]
public Action`1<IFilterDocumentQueryBase`2<T, IAsyncDocumentQuery`1<T>>> get_ForAsyncDocumentQuery();
    [CompilerGeneratedAttribute]
public void set_ForAsyncDocumentQuery(Action`1<IFilterDocumentQueryBase`2<T, IAsyncDocumentQuery`1<T>>> value);
}
internal class Raven.Client.Documents.Queries.MoreLikeThis.MoreLikeThisUsingDocumentForQuery`1 : MoreLikeThisBase {
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<T, bool>> <ForQuery>k__BackingField;
    public Expression`1<Func`2<T, bool>> ForQuery { get; public set; }
    [CompilerGeneratedAttribute]
public Expression`1<Func`2<T, bool>> get_ForQuery();
    [CompilerGeneratedAttribute]
public void set_ForQuery(Expression`1<Func`2<T, bool>> value);
}
public enum Raven.Client.Documents.Queries.ProjectionBehavior : Enum {
    public int value__;
    public static ProjectionBehavior Default;
    public static ProjectionBehavior FromIndex;
    public static ProjectionBehavior FromIndexOrThrow;
    public static ProjectionBehavior FromDocument;
    public static ProjectionBehavior FromDocumentOrThrow;
}
[ExtensionAttribute]
internal static class Raven.Client.Documents.Queries.ProjectionBehaviorExtensions : object {
    [ExtensionAttribute]
public static bool FromIndexOrDefault(Nullable`1<ProjectionBehavior> projectionBehavior);
    [ExtensionAttribute]
public static bool FromIndexOnly(Nullable`1<ProjectionBehavior> projectionBehavior);
    [ExtensionAttribute]
public static bool FromDocumentOrDefault(Nullable`1<ProjectionBehavior> projectionBehavior);
    [ExtensionAttribute]
public static bool FromDocumentOnly(Nullable`1<ProjectionBehavior> projectionBehavior);
    [ExtensionAttribute]
public static bool MustThrow(Nullable`1<ProjectionBehavior> projectionBehavior);
}
public class Raven.Client.Documents.Queries.QueryData : object {
    [CompilerGeneratedAttribute]
private String[] <Fields>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Projections>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FromAlias>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<DeclareToken> <DeclareTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<LoadToken> <LoadTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCustomFunction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMapReduce>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsProjectInto>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryStatistics <QueryStatistics>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ProjectionBehavior> <ProjectionBehavior>k__BackingField;
    public String[] Fields { get; public set; }
    public IEnumerable`1<string> Projections { get; public set; }
    public string FromAlias { get; public set; }
    public IEnumerable`1<DeclareToken> DeclareTokens { get; public set; }
    public List`1<LoadToken> LoadTokens { get; public set; }
    public bool IsCustomFunction { get; public set; }
    public bool IsMapReduce { get; public set; }
    internal bool IsProjectInto { get; internal set; }
    internal QueryStatistics QueryStatistics { get; internal set; }
    public Nullable`1<ProjectionBehavior> ProjectionBehavior { get; public set; }
    public QueryData(String[] fields, IEnumerable`1<string> projections, string fromAlias, IEnumerable`1<DeclareToken> declareTokens, List`1<LoadToken> loadTokens, bool isCustomFunction);
    [CompilerGeneratedAttribute]
public String[] get_Fields();
    [CompilerGeneratedAttribute]
public void set_Fields(String[] value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Projections();
    [CompilerGeneratedAttribute]
public void set_Projections(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_FromAlias();
    [CompilerGeneratedAttribute]
public void set_FromAlias(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<DeclareToken> get_DeclareTokens();
    [CompilerGeneratedAttribute]
public void set_DeclareTokens(IEnumerable`1<DeclareToken> value);
    [CompilerGeneratedAttribute]
public List`1<LoadToken> get_LoadTokens();
    [CompilerGeneratedAttribute]
public void set_LoadTokens(List`1<LoadToken> value);
    [CompilerGeneratedAttribute]
public bool get_IsCustomFunction();
    [CompilerGeneratedAttribute]
public void set_IsCustomFunction(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsMapReduce();
    [CompilerGeneratedAttribute]
public void set_IsMapReduce(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsProjectInto();
    [CompilerGeneratedAttribute]
internal void set_IsProjectInto(bool value);
    [CompilerGeneratedAttribute]
internal QueryStatistics get_QueryStatistics();
    [CompilerGeneratedAttribute]
internal void set_QueryStatistics(QueryStatistics value);
    [CompilerGeneratedAttribute]
public Nullable`1<ProjectionBehavior> get_ProjectionBehavior();
    [CompilerGeneratedAttribute]
public void set_ProjectionBehavior(Nullable`1<ProjectionBehavior> value);
    public static QueryData CustomFunction(string alias, string func);
    internal static void ThrowProjectionIsAlreadyDone();
}
internal static class Raven.Client.Documents.Queries.QueryFieldUtil : object {
    public static string EscapeIfNecessary(string name);
    public static string EscapeIfNecessary(string name, bool isPath);
    [CompilerGeneratedAttribute]
internal static bool <EscapeIfNecessary>g__ShouldEscape|1_0(string s, <>c__DisplayClass1_0& );
}
public class Raven.Client.Documents.Queries.QueryOperationOptions : object {
    private Nullable`1<int> _maxOpsPerSecond;
    [CompilerGeneratedAttribute]
private bool <AllowStale>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreMaxStepsForScript>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <StaleTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RetrieveDetails>k__BackingField;
    public bool AllowStale { get; public set; }
    public bool IgnoreMaxStepsForScript { get; public set; }
    public Nullable`1<TimeSpan> StaleTimeout { get; public set; }
    public Nullable`1<int> MaxOpsPerSecond { get; public set; }
    public bool RetrieveDetails { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AllowStale();
    [CompilerGeneratedAttribute]
public void set_AllowStale(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreMaxStepsForScript();
    [CompilerGeneratedAttribute]
public void set_IgnoreMaxStepsForScript(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_StaleTimeout();
    [CompilerGeneratedAttribute]
public void set_StaleTimeout(Nullable`1<TimeSpan> value);
    public Nullable`1<int> get_MaxOpsPerSecond();
    public void set_MaxOpsPerSecond(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_RetrieveDetails();
    [CompilerGeneratedAttribute]
public void set_RetrieveDetails(bool value);
}
public enum Raven.Client.Documents.Queries.QueryOperator : Enum {
    public int value__;
    public static QueryOperator And;
    public static QueryOperator Or;
}
public class Raven.Client.Documents.Queries.QueryResult : QueryResult`2<BlittableJsonReaderArray, BlittableJsonReaderObject> {
    public QueryResult CreateSnapshot();
}
public abstract class Raven.Client.Documents.Queries.QueryResult`2 : QueryResultBase`2<TResult, TIncludes> {
    [CompilerGeneratedAttribute]
private long <TotalResults>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <CappedMaxResults>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SkippedResults>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ScannedResults>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Dictionary`2<string, String[]>> <Highlightings>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, String[]> <Explanations>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DurationInMs>k__BackingField;
    [ForceJsonSerializationAttribute]
internal Nullable`1<long> IndexDefinitionRaftIndex;
    [ForceJsonSerializationAttribute]
internal Nullable`1<long> AutoIndexCreationRaftIndex;
    public long TotalResults { get; public set; }
    public Nullable`1<long> CappedMaxResults { get; public set; }
    public long SkippedResults { get; public set; }
    public Nullable`1<long> ScannedResults { get; public set; }
    public Dictionary`2<string, Dictionary`2<string, String[]>> Highlightings { get; public set; }
    public Dictionary`2<string, String[]> Explanations { get; public set; }
    public long DurationInMs { get; public set; }
    [CompilerGeneratedAttribute]
public long get_TotalResults();
    [CompilerGeneratedAttribute]
public void set_TotalResults(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_CappedMaxResults();
    [CompilerGeneratedAttribute]
public void set_CappedMaxResults(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public long get_SkippedResults();
    [CompilerGeneratedAttribute]
public void set_SkippedResults(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ScannedResults();
    [CompilerGeneratedAttribute]
public void set_ScannedResults(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Dictionary`2<string, String[]>> get_Highlightings();
    [CompilerGeneratedAttribute]
public void set_Highlightings(Dictionary`2<string, Dictionary`2<string, String[]>> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, String[]> get_Explanations();
    [CompilerGeneratedAttribute]
public void set_Explanations(Dictionary`2<string, String[]> value);
    [CompilerGeneratedAttribute]
public long get_DurationInMs();
    [CompilerGeneratedAttribute]
public void set_DurationInMs(long value);
}
public abstract class Raven.Client.Documents.Queries.QueryResultBase`2 : object {
    [CompilerGeneratedAttribute]
private TResult <Results>k__BackingField;
    [CompilerGeneratedAttribute]
private TInclude <Includes>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <CounterIncludes>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderArray <RevisionIncludes>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, String[]> <IncludedCounterNames>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <TimeSeriesIncludes>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <CompareExchangeValueIncludes>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <IncludedPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStale>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <IndexTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ResultEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastQueryTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryTimings <Timings>k__BackingField;
    public TResult Results { get; public set; }
    public TInclude Includes { get; public set; }
    public BlittableJsonReaderObject CounterIncludes { get; public set; }
    public BlittableJsonReaderArray RevisionIncludes { get; public set; }
    public Dictionary`2<string, String[]> IncludedCounterNames { get; public set; }
    public BlittableJsonReaderObject TimeSeriesIncludes { get; public set; }
    public BlittableJsonReaderObject CompareExchangeValueIncludes { get; public set; }
    public String[] IncludedPaths { get; public set; }
    public bool IsStale { get; public set; }
    public DateTime IndexTimestamp { get; public set; }
    public string IndexName { get; public set; }
    public long ResultEtag { get; public set; }
    public DateTime LastQueryTime { get; public set; }
    public string NodeTag { get; public set; }
    public QueryTimings Timings { get; public set; }
    [CompilerGeneratedAttribute]
public TResult get_Results();
    [CompilerGeneratedAttribute]
public void set_Results(TResult value);
    [CompilerGeneratedAttribute]
public TInclude get_Includes();
    [CompilerGeneratedAttribute]
public void set_Includes(TInclude value);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_CounterIncludes();
    [CompilerGeneratedAttribute]
public void set_CounterIncludes(BlittableJsonReaderObject value);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderArray get_RevisionIncludes();
    [CompilerGeneratedAttribute]
public void set_RevisionIncludes(BlittableJsonReaderArray value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, String[]> get_IncludedCounterNames();
    [CompilerGeneratedAttribute]
public void set_IncludedCounterNames(Dictionary`2<string, String[]> value);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_TimeSeriesIncludes();
    [CompilerGeneratedAttribute]
public void set_TimeSeriesIncludes(BlittableJsonReaderObject value);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_CompareExchangeValueIncludes();
    [CompilerGeneratedAttribute]
public void set_CompareExchangeValueIncludes(BlittableJsonReaderObject value);
    [CompilerGeneratedAttribute]
public String[] get_IncludedPaths();
    [CompilerGeneratedAttribute]
public void set_IncludedPaths(String[] value);
    [CompilerGeneratedAttribute]
public bool get_IsStale();
    [CompilerGeneratedAttribute]
public void set_IsStale(bool value);
    [CompilerGeneratedAttribute]
public DateTime get_IndexTimestamp();
    [CompilerGeneratedAttribute]
public void set_IndexTimestamp(DateTime value);
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    [CompilerGeneratedAttribute]
public long get_ResultEtag();
    [CompilerGeneratedAttribute]
public void set_ResultEtag(long value);
    [CompilerGeneratedAttribute]
public DateTime get_LastQueryTime();
    [CompilerGeneratedAttribute]
public void set_LastQueryTime(DateTime value);
    [CompilerGeneratedAttribute]
public string get_NodeTag();
    [CompilerGeneratedAttribute]
public void set_NodeTag(string value);
    [CompilerGeneratedAttribute]
public QueryTimings get_Timings();
    [CompilerGeneratedAttribute]
public void set_Timings(QueryTimings value);
}
public class Raven.Client.Documents.Queries.RavenQuery : object {
    public static T Load(string id);
    public static IEnumerable`1<T> Load(IEnumerable`1<string> ids);
    public static T Raw(string js);
    public static T Raw(T path, string js);
    public static DateTime LastModified(T instance);
    public static IMetadataDictionary Metadata(T instance);
    public static T CmpXchg(string key);
    public static Nullable`1<long> Counter(string name);
    public static Nullable`1<long> Counter(string docId, string name);
    public static Nullable`1<long> Counter(object documentInstance, string name);
    public static ITimeSeriesQueryable TimeSeries(string name);
    public static ITimeSeriesQueryable TimeSeries(object documentInstance, string name);
    public static ITimeSeriesQueryable TimeSeries(object documentInstance, string name, DateTime from, DateTime to);
    public static ITimeSeriesQueryable`1<T> TimeSeries(string name);
    public static ITimeSeriesQueryable`1<T> TimeSeries(object documentInstance, string name);
    public static ITimeSeriesQueryable`1<T> TimeSeries(object documentInstance, string name, DateTime from, DateTime to);
}
public enum Raven.Client.Documents.Queries.SearchOperator : Enum {
    public int value__;
    public static SearchOperator Or;
    public static SearchOperator And;
}
public class Raven.Client.Documents.Queries.Sorting.SorterDefinition : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    public string Name { get; public set; }
    public string Code { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(string value);
    public DynamicJsonValue ToJson();
    internal void Validate();
}
public class Raven.Client.Documents.Queries.Spatial.CircleCriteria : SpatialCriteria {
    private double _radius;
    private double _latitude;
    private double _longitude;
    private Nullable`1<SpatialUnits> _radiusUnits;
    public CircleCriteria(double radius, double latitude, double longitude, Nullable`1<SpatialUnits> radiusUnits, SpatialRelation relation, double distErrorPercent);
    protected virtual ShapeToken GetShapeToken(Func`2<object, string> addQueryParameter);
}
public abstract class Raven.Client.Documents.Queries.Spatial.DynamicSpatialField : object {
    [CompilerGeneratedAttribute]
private double <RoundFactor>k__BackingField;
    public double RoundFactor { get; private set; }
    public abstract virtual string ToField(Func`3<string, bool, string> ensureValidFieldName);
    [CompilerGeneratedAttribute]
public double get_RoundFactor();
    [CompilerGeneratedAttribute]
private void set_RoundFactor(double value);
    public DynamicSpatialField RoundTo(double factor);
}
public class Raven.Client.Documents.Queries.Spatial.DynamicSpatialFieldFactory`1 : object {
    private DocumentConventions _conventions;
    public static DynamicSpatialFieldFactory`1<TEntity> Instance;
    internal DynamicSpatialFieldFactory`1(DocumentConventions conventions);
    private static DynamicSpatialFieldFactory`1();
    public PointField Point(Expression`1<Func`2<TEntity, object>> latitudePath, Expression`1<Func`2<TEntity, object>> longitudePath);
    public WktField Wkt(Expression`1<Func`2<TEntity, object>> wktPath);
}
public class Raven.Client.Documents.Queries.Spatial.PointField : DynamicSpatialField {
    public string Latitude;
    public string Longitude;
    public PointField(string latitude, string longitude);
    public virtual string ToField(Func`3<string, bool, string> ensureValidFieldName);
}
public abstract class Raven.Client.Documents.Queries.Spatial.SpatialCriteria : object {
    private SpatialRelation _relation;
    private double _distanceErrorPct;
    protected SpatialCriteria(SpatialRelation relation, double distanceErrorPct);
    protected abstract virtual ShapeToken GetShapeToken(Func`2<object, string> addQueryParameter);
    public QueryToken ToQueryToken(string fieldName, Func`2<object, string> addQueryParameter);
}
public class Raven.Client.Documents.Queries.Spatial.SpatialCriteriaFactory : object {
    public static SpatialCriteriaFactory Instance;
    private static SpatialCriteriaFactory();
    public SpatialCriteria RelatesToShape(string shapeWkt, SpatialRelation relation, double distErrorPercent);
    public SpatialCriteria RelatesToShape(string shapeWkt, SpatialRelation relation, SpatialUnits units, double distErrorPercent);
    public SpatialCriteria Intersects(string shapeWkt, double distErrorPercent);
    public SpatialCriteria Intersects(string shapeWkt, SpatialUnits units, double distErrorPercent);
    public SpatialCriteria Contains(string shapeWkt, double distErrorPercent);
    public SpatialCriteria Contains(string shapeWkt, SpatialUnits units, double distErrorPercent);
    public SpatialCriteria Disjoint(string shapeWkt, double distErrorPercent);
    public SpatialCriteria Disjoint(string shapeWkt, SpatialUnits units, double distErrorPercent);
    public SpatialCriteria Within(string shapeWkt, double distErrorPercent);
    public SpatialCriteria Within(string shapeWkt, SpatialUnits units, double distErrorPercent);
    public SpatialCriteria WithinRadius(double radius, double latitude, double longitude, Nullable`1<SpatialUnits> radiusUnits, double distErrorPercent);
}
public class Raven.Client.Documents.Queries.Spatial.WktCriteria : SpatialCriteria {
    private string _shapeWkt;
    private Nullable`1<SpatialUnits> _radiusUnits;
    internal WktCriteria(string shapeWkt, SpatialRelation relation, Nullable`1<SpatialUnits> radiusUnits, double distanceErrorPct);
    protected virtual ShapeToken GetShapeToken(Func`2<object, string> addQueryParameter);
}
public class Raven.Client.Documents.Queries.Spatial.WktField : DynamicSpatialField {
    public string Wkt;
    public WktField(string wkt);
    public virtual string ToField(Func`3<string, bool, string> ensureValidFieldName);
}
internal class Raven.Client.Documents.Queries.Spatial.WktSanitizer : object {
    private static Regex RectangleRegex;
    private static Regex DimensionFlagRegex;
    private static Regex ReducerRegex;
    private static WktSanitizer();
    public string Sanitize(string shapeWkt);
}
internal class Raven.Client.Documents.Queries.Suggestions.AsyncSuggestionDocumentQuery`1 : SuggestionQueryBase {
    private AsyncDocumentQuery`1<T> _source;
    public AsyncSuggestionDocumentQuery`1(AsyncDocumentQuery`1<T> source);
    protected virtual IndexQuery GetIndexQuery(bool isAsync, bool updateAfterQueryExecuted);
    protected virtual void InvokeAfterQueryExecuted(QueryResult result);
    public sealed virtual IAsyncSuggestionDocumentQuery`1<T> AndSuggestUsing(SuggestionBase suggestion);
    public sealed virtual IAsyncSuggestionDocumentQuery`1<T> AndSuggestUsing(Action`1<ISuggestionBuilder`1<T>> builder);
}
public interface Raven.Client.Documents.Queries.Suggestions.IAsyncSuggestionDocumentQuery`1 {
    public abstract virtual IAsyncSuggestionDocumentQuery`1<T> AndSuggestUsing(SuggestionBase suggestion);
    public abstract virtual IAsyncSuggestionDocumentQuery`1<T> AndSuggestUsing(Action`1<ISuggestionBuilder`1<T>> builder);
    public abstract virtual Task`1<Dictionary`2<string, SuggestionResult>> ExecuteAsync(CancellationToken token);
    public abstract virtual Lazy`1<Task`1<Dictionary`2<string, SuggestionResult>>> ExecuteLazyAsync(Action`1<Dictionary`2<string, SuggestionResult>> onEval, CancellationToken token);
}
public interface Raven.Client.Documents.Queries.Suggestions.ISuggestionBuilder`1 {
    public abstract virtual ISuggestionOperations`1<T> ByField(string fieldName, string term);
    public abstract virtual ISuggestionOperations`1<T> ByField(string fieldName, String[] terms);
    public abstract virtual ISuggestionOperations`1<T> ByField(Expression`1<Func`2<T, object>> path, string term);
    public abstract virtual ISuggestionOperations`1<T> ByField(Expression`1<Func`2<T, object>> path, String[] terms);
}
public interface Raven.Client.Documents.Queries.Suggestions.ISuggestionDocumentQuery`1 {
    public abstract virtual ISuggestionDocumentQuery`1<T> AndSuggestUsing(SuggestionBase suggestion);
    public abstract virtual ISuggestionDocumentQuery`1<T> AndSuggestUsing(Action`1<ISuggestionBuilder`1<T>> builder);
    public abstract virtual Dictionary`2<string, SuggestionResult> Execute();
    public abstract virtual Lazy`1<Dictionary`2<string, SuggestionResult>> ExecuteLazy(Action`1<Dictionary`2<string, SuggestionResult>> onEval);
}
public interface Raven.Client.Documents.Queries.Suggestions.ISuggestionOperations`1 {
    public abstract virtual ISuggestionOperations`1<T> WithDisplayName(string displayName);
    public abstract virtual ISuggestionOperations`1<T> WithOptions(SuggestionOptions options);
}
public interface Raven.Client.Documents.Queries.Suggestions.ISuggestionQuery`1 {
    public abstract virtual ISuggestionQuery`1<T> AndSuggestUsing(SuggestionBase suggestion);
    public abstract virtual ISuggestionQuery`1<T> AndSuggestUsing(Action`1<ISuggestionBuilder`1<T>> builder);
    public abstract virtual Dictionary`2<string, SuggestionResult> Execute();
    public abstract virtual Task`1<Dictionary`2<string, SuggestionResult>> ExecuteAsync(CancellationToken token);
    public abstract virtual Lazy`1<Dictionary`2<string, SuggestionResult>> ExecuteLazy(Action`1<Dictionary`2<string, SuggestionResult>> onEval);
    public abstract virtual Lazy`1<Task`1<Dictionary`2<string, SuggestionResult>>> ExecuteLazyAsync(Action`1<Dictionary`2<string, SuggestionResult>> onEval, CancellationToken token);
}
public enum Raven.Client.Documents.Queries.Suggestions.StringDistanceTypes : Enum {
    public int value__;
    public static StringDistanceTypes None;
    public static StringDistanceTypes Default;
    public static StringDistanceTypes Levenshtein;
    public static StringDistanceTypes JaroWinkler;
    public static StringDistanceTypes NGram;
}
public abstract class Raven.Client.Documents.Queries.Suggestions.SuggestionBase : object {
    [CompilerGeneratedAttribute]
private string <Field>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayField>k__BackingField;
    [CompilerGeneratedAttribute]
private SuggestionOptions <Options>k__BackingField;
    public string Field { get; public set; }
    public string DisplayField { get; public set; }
    public SuggestionOptions Options { get; public set; }
    protected SuggestionBase(string field);
    [CompilerGeneratedAttribute]
public string get_Field();
    [CompilerGeneratedAttribute]
public void set_Field(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayField();
    [CompilerGeneratedAttribute]
public void set_DisplayField(string value);
    [CompilerGeneratedAttribute]
public SuggestionOptions get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(SuggestionOptions value);
}
internal class Raven.Client.Documents.Queries.Suggestions.SuggestionBuilder`1 : object {
    private DocumentConventions _conventions;
    private SuggestionWithTerm _term;
    private SuggestionWithTerms _terms;
    internal SuggestionBase Suggestion { get; }
    public SuggestionBuilder`1(DocumentConventions conventions);
    public sealed virtual ISuggestionOperations`1<T> WithDisplayName(string displayName);
    public sealed virtual ISuggestionOperations`1<T> ByField(string fieldName, string term);
    public sealed virtual ISuggestionOperations`1<T> ByField(string fieldName, String[] terms);
    public sealed virtual ISuggestionOperations`1<T> ByField(Expression`1<Func`2<T, object>> path, string term);
    public sealed virtual ISuggestionOperations`1<T> ByField(Expression`1<Func`2<T, object>> path, String[] terms);
    public sealed virtual ISuggestionOperations`1<T> WithOptions(SuggestionOptions options);
    internal SuggestionBase get_Suggestion();
}
internal class Raven.Client.Documents.Queries.Suggestions.SuggestionDocumentQuery`1 : SuggestionQueryBase {
    private DocumentQuery`1<T> _source;
    public SuggestionDocumentQuery`1(DocumentQuery`1<T> source);
    protected virtual IndexQuery GetIndexQuery(bool isAsync, bool updateAfterQueryExecuted);
    protected virtual void InvokeAfterQueryExecuted(QueryResult result);
    public sealed virtual ISuggestionDocumentQuery`1<T> AndSuggestUsing(SuggestionBase suggestion);
    public sealed virtual ISuggestionDocumentQuery`1<T> AndSuggestUsing(Action`1<ISuggestionBuilder`1<T>> builder);
}
public class Raven.Client.Documents.Queries.Suggestions.SuggestionOptions : object {
    internal static SuggestionOptions Default;
    public static float DefaultAccuracy;
    public static int DefaultPageSize;
    public static StringDistanceTypes DefaultDistance;
    public static SuggestionSortMode DefaultSortMode;
    [CompilerGeneratedAttribute]
private int <PageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<StringDistanceTypes> <Distance>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<float> <Accuracy>k__BackingField;
    [CompilerGeneratedAttribute]
private SuggestionSortMode <SortMode>k__BackingField;
    public int PageSize { get; public set; }
    public Nullable`1<StringDistanceTypes> Distance { get; public set; }
    public Nullable`1<float> Accuracy { get; public set; }
    public SuggestionSortMode SortMode { get; public set; }
    private static SuggestionOptions();
    [CompilerGeneratedAttribute]
public int get_PageSize();
    [CompilerGeneratedAttribute]
public void set_PageSize(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<StringDistanceTypes> get_Distance();
    [CompilerGeneratedAttribute]
public void set_Distance(Nullable`1<StringDistanceTypes> value);
    [CompilerGeneratedAttribute]
public Nullable`1<float> get_Accuracy();
    [CompilerGeneratedAttribute]
public void set_Accuracy(Nullable`1<float> value);
    [CompilerGeneratedAttribute]
public SuggestionSortMode get_SortMode();
    [CompilerGeneratedAttribute]
public void set_SortMode(SuggestionSortMode value);
}
internal class Raven.Client.Documents.Queries.Suggestions.SuggestionQuery`1 : SuggestionQueryBase {
    private IQueryable`1<T> _source;
    private Func`2<IQueryable`1<T>, Expression> _convertExpressionIfNecessary;
    private Func`3<MethodInfo, Type, MethodInfo> _convertMethodIfNecessary;
    private MethodInfo _suggestUsingMethod;
    public SuggestionQuery`1(IQueryable`1<T> source, Func`2<IQueryable`1<T>, Expression> convertExpressionIfNecessary, Func`3<MethodInfo, Type, MethodInfo> convertMethodIfNecessary, MethodInfo suggestUsingMethod);
    protected virtual IndexQuery GetIndexQuery(bool isAsync, bool updateAfterQueryExecuted);
    protected virtual void InvokeAfterQueryExecuted(QueryResult result);
    public sealed virtual ISuggestionQuery`1<T> AndSuggestUsing(SuggestionBase suggestion);
    public sealed virtual ISuggestionQuery`1<T> AndSuggestUsing(Action`1<ISuggestionBuilder`1<T>> builder);
}
internal abstract class Raven.Client.Documents.Queries.Suggestions.SuggestionQueryBase : object {
    private InMemoryDocumentSessionOperations _session;
    private IndexQuery _query;
    private Stopwatch _duration;
    protected SuggestionQueryBase(InMemoryDocumentSessionOperations session);
    public sealed virtual Dictionary`2<string, SuggestionResult> Execute();
    [AsyncStateMachineAttribute("Raven.Client.Documents.Queries.Suggestions.SuggestionQueryBase/<ExecuteAsync>d__5")]
public sealed virtual Task`1<Dictionary`2<string, SuggestionResult>> ExecuteAsync(CancellationToken token);
    private Dictionary`2<string, SuggestionResult> ProcessResults(QueryResult queryResult);
    public sealed virtual Lazy`1<Dictionary`2<string, SuggestionResult>> ExecuteLazy(Action`1<Dictionary`2<string, SuggestionResult>> onEval);
    public sealed virtual Lazy`1<Task`1<Dictionary`2<string, SuggestionResult>>> ExecuteLazyAsync(Action`1<Dictionary`2<string, SuggestionResult>> onEval, CancellationToken token);
    protected abstract virtual IndexQuery GetIndexQuery(bool isAsync, bool updateAfterQueryExecuted);
    protected abstract virtual void InvokeAfterQueryExecuted(QueryResult result);
    private QueryCommand GetCommand(bool isAsync);
    public virtual string ToString();
}
public class Raven.Client.Documents.Queries.Suggestions.SuggestionResult : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Suggestions>k__BackingField;
    public string Name { get; public set; }
    public List`1<string> Suggestions { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Suggestions();
    [CompilerGeneratedAttribute]
public void set_Suggestions(List`1<string> value);
}
public enum Raven.Client.Documents.Queries.Suggestions.SuggestionSortMode : Enum {
    public int value__;
    public static SuggestionSortMode None;
    public static SuggestionSortMode Popularity;
}
public class Raven.Client.Documents.Queries.Suggestions.SuggestionWithTerm : SuggestionBase {
    [CompilerGeneratedAttribute]
private string <Term>k__BackingField;
    public string Term { get; public set; }
    public SuggestionWithTerm(string field);
    [CompilerGeneratedAttribute]
public string get_Term();
    [CompilerGeneratedAttribute]
public void set_Term(string value);
}
public class Raven.Client.Documents.Queries.Suggestions.SuggestionWithTerms : SuggestionBase {
    [CompilerGeneratedAttribute]
private String[] <Terms>k__BackingField;
    public String[] Terms { get; public set; }
    public SuggestionWithTerms(string field);
    [CompilerGeneratedAttribute]
public String[] get_Terms();
    [CompilerGeneratedAttribute]
public void set_Terms(String[] value);
}
public class Raven.Client.Documents.Queries.TermsQueryResult : object {
    [CompilerGeneratedAttribute]
private List`1<string> <Terms>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ResultEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    public List`1<string> Terms { get; public set; }
    public long ResultEtag { get; public set; }
    public string IndexName { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_Terms();
    [CompilerGeneratedAttribute]
public void set_Terms(List`1<string> value);
    [CompilerGeneratedAttribute]
public long get_ResultEtag();
    [CompilerGeneratedAttribute]
public void set_ResultEtag(long value);
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
}
public enum Raven.Client.Documents.Queries.TimeSeries.AggregationType : Enum {
    public int value__;
    public static AggregationType First;
    public static AggregationType Last;
    public static AggregationType Min;
    public static AggregationType Max;
    public static AggregationType Sum;
    public static AggregationType Count;
    public static AggregationType Average;
    public static AggregationType Percentile;
    public static AggregationType Slope;
    public static AggregationType StandardDeviation;
}
public enum Raven.Client.Documents.Queries.TimeSeries.InterpolationType : Enum {
    public int value__;
    public static InterpolationType None;
    public static InterpolationType Linear;
    public static InterpolationType Nearest;
    public static InterpolationType Last;
    public static InterpolationType Next;
}
public interface Raven.Client.Documents.Queries.TimeSeries.ITimePeriodBuilder {
    public abstract virtual ITimeSeriesAggregationOperations Milliseconds(int duration);
    public abstract virtual ITimeSeriesAggregationOperations Seconds(int duration);
    public abstract virtual ITimeSeriesAggregationOperations Minutes(int duration);
    public abstract virtual ITimeSeriesAggregationOperations Hours(int duration);
    public abstract virtual ITimeSeriesAggregationOperations Days(int duration);
    public abstract virtual ITimeSeriesAggregationOperations Months(int duration);
    public abstract virtual ITimeSeriesAggregationOperations Quarters(int duration);
    public abstract virtual ITimeSeriesAggregationOperations Years(int duration);
}
public interface Raven.Client.Documents.Queries.TimeSeries.ITimeSeriesAggregationOperations {
    public abstract virtual void WithOptions(TimeSeriesAggregationOptions options);
    public abstract virtual ITimeSeriesAggregationOperations ByTag();
    public abstract virtual ITimeSeriesAggregationOperations ByTag(Expression`1<Func`2<TEntity, object>> selector);
}
public interface Raven.Client.Documents.Queries.TimeSeries.ITimeSeriesAggregationQueryable {
    public abstract virtual ITimeSeriesAggregationQueryable Select(Expression`1<Func`2<ITimeSeriesGrouping, object>> selector);
    public abstract virtual ITimeSeriesAggregationQueryable Offset(TimeSpan offset);
    public abstract virtual ITimeSeriesAggregationQueryable Scale(double value);
    public abstract virtual TimeSeriesAggregationResult ToList();
}
public interface Raven.Client.Documents.Queries.TimeSeries.ITimeSeriesAggregationQueryable`1 {
    public abstract virtual ITimeSeriesAggregationQueryable`1<T> Select(Expression`1<Func`2<ITimeSeriesGrouping, object>> selector);
    public abstract virtual ITimeSeriesAggregationQueryable`1<T> Offset(TimeSpan offset);
    public abstract virtual ITimeSeriesAggregationQueryable`1<T> Scale(double value);
    public abstract virtual TimeSeriesAggregationResult`1<T> ToList();
}
public interface Raven.Client.Documents.Queries.TimeSeries.ITimeSeriesGrouping {
    public abstract virtual Double[] Max();
    public abstract virtual Double[] Min();
    public abstract virtual Double[] Sum();
    public abstract virtual Double[] Average();
    public abstract virtual Double[] First();
    public abstract virtual Double[] Last();
    public abstract virtual Int64[] Count();
    public abstract virtual Double[] Percentile(double number);
    public abstract virtual Double[] Slope();
    public abstract virtual Double[] StandardDeviation();
}
public interface Raven.Client.Documents.Queries.TimeSeries.ITimeSeriesLoadQueryable`1 {
    public abstract virtual ITimeSeriesQueryable Where(Expression`1<Func`3<TimeSeriesEntry, TTag, bool>> predicate);
}
public interface Raven.Client.Documents.Queries.TimeSeries.ITimeSeriesLoadQueryable`2 {
    public abstract virtual ITimeSeriesQueryable`1<T> Where(Expression`1<Func`3<TimeSeriesEntry`1<T>, TTag, bool>> predicate);
}
public interface Raven.Client.Documents.Queries.TimeSeries.ITimeSeriesLoadTagBuilder`1 {
    public abstract virtual ITimeSeriesQueryable Where(Expression`1<Func`3<TimeSeriesEntry, TTag, bool>> predicate);
}
public interface Raven.Client.Documents.Queries.TimeSeries.ITimeSeriesQueryable {
    public abstract virtual ITimeSeriesQueryable Where(Expression`1<Func`2<TimeSeriesEntry, bool>> predicate);
    public abstract virtual ITimeSeriesQueryable Offset(TimeSpan offset);
    public abstract virtual ITimeSeriesQueryable Scale(double value);
    public abstract virtual ITimeSeriesQueryable FromLast(Action`1<ITimePeriodBuilder> timePeriod);
    public abstract virtual ITimeSeriesQueryable FromFirst(Action`1<ITimePeriodBuilder> timePeriod);
    public abstract virtual ITimeSeriesLoadQueryable`1<TEntity> LoadByTag();
    public abstract virtual ITimeSeriesAggregationQueryable GroupBy(string s);
    public abstract virtual ITimeSeriesAggregationQueryable GroupBy(Action`1<ITimePeriodBuilder> timePeriod);
    public abstract virtual ITimeSeriesAggregationQueryable Select(Expression`1<Func`2<ITimeSeriesGrouping, object>> selector);
    public abstract virtual TimeSeriesRawResult ToList();
}
public interface Raven.Client.Documents.Queries.TimeSeries.ITimeSeriesQueryable`1 {
    public abstract virtual ITimeSeriesQueryable`1<T> Where(Expression`1<Func`2<TimeSeriesEntry`1<T>, bool>> predicate);
    public abstract virtual ITimeSeriesQueryable`1<T> Offset(TimeSpan offset);
    public abstract virtual ITimeSeriesQueryable`1<T> Scale(double value);
    public abstract virtual ITimeSeriesQueryable`1<T> FromLast(Action`1<ITimePeriodBuilder> timePeriod);
    public abstract virtual ITimeSeriesQueryable`1<T> FromFirst(Action`1<ITimePeriodBuilder> timePeriod);
    public abstract virtual ITimeSeriesLoadQueryable`2<T, TEntity> LoadByTag();
    public abstract virtual ITimeSeriesAggregationQueryable`1<T> GroupBy(string s);
    public abstract virtual ITimeSeriesAggregationQueryable`1<T> GroupBy(Action`1<ITimePeriodBuilder> timePeriod);
    public abstract virtual ITimeSeriesAggregationQueryable`1<T> Select(Expression`1<Func`2<ITimeSeriesGrouping, object>> selector);
    public abstract virtual TimeSeriesRawResult`1<T> ToList();
}
public interface Raven.Client.Documents.Queries.TimeSeries.ITimeSeriesQueryBuilder {
    public abstract virtual T Raw(string queryText);
    public abstract virtual ITimeSeriesQueryBuilder From(string name);
    public abstract virtual ITimeSeriesQueryBuilder Between(DateTime start, DateTime end);
    public abstract virtual ITimeSeriesQueryBuilder FromLast(Action`1<ITimePeriodBuilder> timePeriod);
    public abstract virtual ITimeSeriesQueryBuilder FromFirst(Action`1<ITimePeriodBuilder> timePeriod);
    public abstract virtual ITimeSeriesLoadTagBuilder`1<TTag> LoadByTag();
}
public interface Raven.Client.Documents.Queries.TimeSeries.ITimeSeriesQueryStreamEntry {
}
internal interface Raven.Client.Documents.Queries.TimeSeries.ITimeSeriesQueryStreamResult {
    public abstract virtual void SetStream(TimeSeriesStreamEnumerator stream);
}
public class Raven.Client.Documents.Queries.TimeSeries.TimeSeriesAggregationOptions : object {
    [CompilerGeneratedAttribute]
private InterpolationType <Interpolation>k__BackingField;
    public InterpolationType Interpolation { get; public set; }
    [CompilerGeneratedAttribute]
public InterpolationType get_Interpolation();
    [CompilerGeneratedAttribute]
public void set_Interpolation(InterpolationType value);
}
public class Raven.Client.Documents.Queries.TimeSeries.TimeSeriesAggregationResult : TimeSeriesQueryStreamResultBase`1<TimeSeriesRangeAggregation> {
}
public class Raven.Client.Documents.Queries.TimeSeries.TimeSeriesAggregationResult`1 : TimeSeriesQueryStreamResultBase`1<TimeSeriesRangeAggregation`1<T>> {
}
internal class Raven.Client.Documents.Queries.TimeSeries.TimeSeriesLoadTagBuilder`2 : object {
    private TimeSeriesQueryBuilder`1<TEntity> _parent;
    public TimeSeriesLoadTagBuilder`2(TimeSeriesQueryBuilder`1<TEntity> builder);
    public sealed virtual ITimeSeriesQueryable Where(Expression`1<Func`3<TimeSeriesEntry, TTag, bool>> predicate);
}
internal class Raven.Client.Documents.Queries.TimeSeries.TimeSeriesQueryBuilder`1 : object {
    private string _query;
    private string _name;
    private Nullable`1<DateTime> _start;
    private Nullable`1<DateTime> _end;
    private MethodCallExpression _callExpression;
    private IAbstractDocumentQuery`1<TEntity> _documentQuery;
    private LinqPathProvider _linqPathProvider;
    public string QueryText { get; }
    public TimeSeriesQueryBuilder`1(IAbstractDocumentQuery`1<TEntity> abstractDocumentQuery, LinqPathProvider linqPathProvider);
    public string get_QueryText();
    public sealed virtual T Raw(string queryText);
    public sealed virtual ITimeSeriesQueryBuilder From(string name);
    public sealed virtual ITimeSeriesQueryBuilder Between(DateTime start, DateTime end);
    public sealed virtual ITimeSeriesQueryable Where(Expression`1<Func`2<TimeSeriesEntry, bool>> predicate);
    internal ITimeSeriesQueryable Where(Expression`1<Func`3<TimeSeriesEntry, TTag, bool>> predicate);
    private sealed virtual override ITimeSeriesLoadTagBuilder`1<TTag> Raven.Client.Documents.Queries.TimeSeries.ITimeSeriesQueryBuilder.LoadByTag();
    public sealed virtual ITimeSeriesAggregationQueryable GroupBy(string s);
    public sealed virtual ITimeSeriesAggregationQueryable GroupBy(Action`1<ITimePeriodBuilder> timePeriod);
    private sealed virtual override ITimeSeriesAggregationQueryable Raven.Client.Documents.Queries.TimeSeries.ITimeSeriesQueryable.Select(Expression`1<Func`2<ITimeSeriesGrouping, object>> selector);
    private sealed virtual override ITimeSeriesAggregationQueryable Raven.Client.Documents.Queries.TimeSeries.ITimeSeriesAggregationQueryable.Select(Expression`1<Func`2<ITimeSeriesGrouping, object>> selector);
    private sealed virtual override ITimeSeriesQueryable Raven.Client.Documents.Queries.TimeSeries.ITimeSeriesQueryable.Offset(TimeSpan offset);
    private sealed virtual override ITimeSeriesAggregationQueryable Raven.Client.Documents.Queries.TimeSeries.ITimeSeriesAggregationQueryable.Offset(TimeSpan offset);
    private sealed virtual override ITimeSeriesQueryable Raven.Client.Documents.Queries.TimeSeries.ITimeSeriesQueryable.Scale(double value);
    private sealed virtual override ITimeSeriesAggregationQueryable Raven.Client.Documents.Queries.TimeSeries.ITimeSeriesAggregationQueryable.Scale(double value);
    private sealed virtual override ITimeSeriesQueryBuilder Raven.Client.Documents.Queries.TimeSeries.ITimeSeriesQueryBuilder.FromFirst(Action`1<ITimePeriodBuilder> timePeriod);
    private sealed virtual override ITimeSeriesQueryBuilder Raven.Client.Documents.Queries.TimeSeries.ITimeSeriesQueryBuilder.FromLast(Action`1<ITimePeriodBuilder> timePeriod);
    public sealed virtual TimeSeriesRawResult ToList();
    private sealed virtual override TimeSeriesAggregationResult Raven.Client.Documents.Queries.TimeSeries.ITimeSeriesAggregationQueryable.ToList();
    private sealed virtual override ITimeSeriesLoadQueryable`1<TEntity1> Raven.Client.Documents.Queries.TimeSeries.ITimeSeriesQueryable.LoadByTag();
    private sealed virtual override ITimeSeriesQueryable Raven.Client.Documents.Queries.TimeSeries.ITimeSeriesQueryable.FromLast(Action`1<ITimePeriodBuilder> timePeriod);
    private sealed virtual override ITimeSeriesQueryable Raven.Client.Documents.Queries.TimeSeries.ITimeSeriesQueryable.FromFirst(Action`1<ITimePeriodBuilder> timePeriod);
    private void ModifyCallExpression(MethodInfo methodInfo, Expression arg);
    private static void ThrowMethodNotSupported(string method);
}
public class Raven.Client.Documents.Queries.TimeSeries.TimeSeriesQueryResult : object {
    [CompilerGeneratedAttribute]
private long <Count>k__BackingField;
    public long Count { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(long value);
}
public abstract class Raven.Client.Documents.Queries.TimeSeries.TimeSeriesQueryStreamResultBase`1 : TimeSeriesQueryResult {
    [JsonIgnoreAttribute]
private TResult[] _results;
    [JsonIgnoreAttribute]
private TimeSeriesStreamEnumerator`1<TResult> _timeSeriesStream;
    public TResult[] Results { get; public set; }
    [JsonIgnoreAttribute]
public IEnumerator`1<TResult> Stream { get; }
    [JsonIgnoreAttribute]
public IAsyncEnumerator`1<TResult> StreamAsync { get; }
    public TResult[] get_Results();
    public void set_Results(TResult[] value);
    private TResult[] MaterializeStream();
    public IEnumerator`1<TResult> get_Stream();
    public IAsyncEnumerator`1<TResult> get_StreamAsync();
    private sealed virtual override void Raven.Client.Documents.Queries.TimeSeries.ITimeSeriesQueryStreamResult.SetStream(TimeSeriesStreamEnumerator stream);
}
internal class Raven.Client.Documents.Queries.TimeSeries.TimeSeriesQueryVisitor`1 : object {
    private RavenQueryProviderProcessor`1<T> _providerProcessor;
    private IAbstractDocumentQuery`1<T> _documentQuery;
    private LinqPathProvider _linqPathProvider;
    private TimeSeriesWhereClauseVisitor`1<T> _whereVisitor;
    private StringBuilder _selectFields;
    private string _src;
    private string _between;
    private string _where;
    private string _groupBy;
    private string _last;
    private string _first;
    private string _loadTag;
    private string _loadTagAlias;
    private string _offset;
    private string _scale;
    [CompilerGeneratedAttribute]
private List`1<string> <Parameters>k__BackingField;
    public List`1<string> Parameters { get; internal set; }
    public TimeSeriesQueryVisitor`1(RavenQueryProviderProcessor`1<T> processor);
    internal TimeSeriesQueryVisitor`1(IAbstractDocumentQuery`1<T> documentQuery, LinqPathProvider linqPathProvider);
    [CompilerGeneratedAttribute]
public List`1<string> get_Parameters();
    [CompilerGeneratedAttribute]
internal void set_Parameters(List`1<string> value);
    private void VisitMethod(MethodCallExpression mce);
    private void Where(Expression expression);
    private void LoadByTag(string alias);
    private void GroupBy(Expression expression);
    private string GetGroupByArgsFromAction(Action`1<ITimePeriodBuilder> action, String& with, String& groupByTag);
    private static string GetTimePeriodFromAction(Action`1<ITimePeriodBuilder> action, String& with, String& groupByTag, String& alias);
    internal static string GroupByTagFromMethod(Expression argument, String& alias);
    private void WhereMethod(MethodCallExpression call);
    private void Select(Expression expression);
    private void AddSelectMethod(MethodCallExpression call);
    private void Offset(Expression expression);
    private void Scale(Expression expression);
    private void TimeSeriesCall(MethodCallExpression mce);
    private void Last(Expression expression);
    private static string GetTimePeriodFromExpression(Expression expression, string method);
    private void First(Expression expression);
    private string GetNameFromArgument(Expression argument);
    private void Between(MethodCallExpression mce);
    private void WhereBinary(BinaryExpression expression);
    private string ModifyExpression(Expression expression);
    private void WhereIn(MethodCallExpression mce);
    public string Visit(MethodCallExpression expression);
    private void VisitExpression(MethodCallExpression callExpression);
    private string BuildQuery();
    private void AddSelectField(string name, Nullable`1<double> value);
    private string GetDateValue(Expression exp);
    private static string GetTimePeriodFromMethodCall(MethodCallExpression callExpression, string method);
    private static string TryGetValueFromArgument(Expression argument, bool groupByArgument);
    private static void ThrowInvalidMethodArgument(Expression argument, string method);
    private static void ThrowFailedToEvaluateArgument(Expression argument, bool groupBy, Exception e);
}
public class Raven.Client.Documents.Queries.TimeSeries.TimeSeriesRangeAggregation : object {
    public Int64[] Count;
    public Double[] Max;
    public Double[] Min;
    public Double[] Last;
    public Double[] First;
    public Double[] Average;
    public Double[] Sum;
    public Double[] Percentile;
    public Double[] Slope;
    public Double[] StandardDeviation;
    public DateTime To;
    public DateTime From;
    [CompilerGeneratedAttribute]
private object <Key>k__BackingField;
    public object Key { get; private set; }
    [CompilerGeneratedAttribute]
public object get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(object value);
    [OnDeserializedAttribute]
internal void OnNewtonSoftJsonDeserialized(StreamingContext context);
    private sealed virtual override void Sparrow.Json.IPostJsonDeserialization.PostDeserialization();
    private void SetMinMaxDateTime();
}
public class Raven.Client.Documents.Queries.TimeSeries.TimeSeriesRangeAggregation`1 : TimeSeriesRangeAggregation {
    private T _max;
    private T _min;
    private T _last;
    private T _first;
    private T _average;
    private T _sum;
    private T _count;
    [JsonIgnoreAttribute]
public T Max { get; }
    [JsonIgnoreAttribute]
public T Min { get; }
    [JsonIgnoreAttribute]
public T Last { get; }
    [JsonIgnoreAttribute]
public T First { get; }
    [JsonIgnoreAttribute]
public T Average { get; }
    [JsonIgnoreAttribute]
public T Sum { get; }
    [JsonIgnoreAttribute]
public T Count { get; }
    public T get_Max();
    public T get_Min();
    public T get_Last();
    public T get_First();
    public T get_Average();
    public T get_Sum();
    public T get_Count();
}
public class Raven.Client.Documents.Queries.TimeSeries.TimeSeriesRawResult : TimeSeriesQueryStreamResultBase`1<TimeSeriesEntry> {
}
public class Raven.Client.Documents.Queries.TimeSeries.TimeSeriesRawResult`1 : TimeSeriesQueryStreamResultBase`1<TimeSeriesEntry`1<T>> {
}
internal class Raven.Client.Documents.Queries.TimeSeries.TimeSeriesStreamEnumerator`1 : object {
    private IAsyncEnumerator`1<BlittableJsonReaderObject> _outer;
    private CancellationToken _token;
    private static Func`2<BlittableJsonReaderObject, T> Converter;
    [CompilerGeneratedAttribute]
private T <Current>k__BackingField;
    public T Current { get; private set; }
    private object System.Collections.IEnumerator.Current { get; }
    internal TimeSeriesStreamEnumerator`1(TimeSeriesStreamEnumerator outer);
    internal TimeSeriesStreamEnumerator`1(IAsyncEnumerator`1<BlittableJsonReaderObject> outer, CancellationToken token);
    private static TimeSeriesStreamEnumerator`1();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    [AsyncStateMachineAttribute("Raven.Client.Documents.Queries.TimeSeries.TimeSeriesStreamEnumerator`1/<MoveNextAsync>d__7")]
public sealed virtual ValueTask`1<bool> MoveNextAsync();
    [CompilerGeneratedAttribute]
public sealed virtual T get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(T value);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    public sealed virtual ValueTask DisposeAsync();
}
internal class Raven.Client.Documents.Queries.TimeSeries.TimeSeriesWhereClauseVisitor`1 : ExpressionVisitor {
    private string _alias;
    private IAbstractDocumentQuery`1<T> _documentQuery;
    private bool _arrayIndex;
    internal List`1<string> Parameters;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2<string, string> _renameTagAlias;
    public TimeSeriesWhereClauseVisitor`1(string alias, IAbstractDocumentQuery`1<T> documentQuery);
    public void Rename(string from, string to);
    public Expression VisitWhere(Expression expression);
    public virtual Expression Visit(Expression node);
    protected virtual Expression VisitParameter(ParameterExpression node);
    protected virtual Expression VisitMember(MemberExpression node);
    private bool IsWhereAlias(Expression expression);
    private bool ShouldRename(ParameterExpression expression);
    protected virtual Expression VisitConstant(ConstantExpression node);
    private ParameterExpression AddAsQueryParameter(Expression node);
}
public class Raven.Client.Documents.Queries.Timings.QueryInspectionNode : object {
    [CompilerGeneratedAttribute]
private string <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<QueryInspectionNode> <Children>k__BackingField;
    public string Operation { get; public set; }
    public Dictionary`2<string, string> Parameters { get; public set; }
    public List`1<QueryInspectionNode> Children { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Operation();
    [CompilerGeneratedAttribute]
public void set_Operation(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public List`1<QueryInspectionNode> get_Children();
    [CompilerGeneratedAttribute]
public void set_Children(List`1<QueryInspectionNode> value);
    public QueryInspectionNode Clone();
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Queries.Timings.QueryTimings : object {
    [CompilerGeneratedAttribute]
private long <DurationInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, QueryTimings> <Timings>k__BackingField;
    [CompilerGeneratedAttribute]
private IDynamicJson <QueryPlan>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldBeIncluded>k__BackingField;
    public long DurationInMs { get; public set; }
    public IDictionary`2<string, QueryTimings> Timings { get; public set; }
    [JsonIgnoreAttribute]
public IDynamicJson QueryPlan { get; public set; }
    internal bool ShouldBeIncluded { get; internal set; }
    [CompilerGeneratedAttribute]
public long get_DurationInMs();
    [CompilerGeneratedAttribute]
public void set_DurationInMs(long value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, QueryTimings> get_Timings();
    [CompilerGeneratedAttribute]
public void set_Timings(IDictionary`2<string, QueryTimings> value);
    [CompilerGeneratedAttribute]
public IDynamicJson get_QueryPlan();
    [CompilerGeneratedAttribute]
public void set_QueryPlan(IDynamicJson value);
    [CompilerGeneratedAttribute]
internal bool get_ShouldBeIncluded();
    [CompilerGeneratedAttribute]
internal void set_ShouldBeIncluded(bool value);
    public sealed virtual void FillFromBlittableJson(BlittableJsonReaderObject json);
    internal QueryTimings Clone();
    internal void Update(QueryResult queryResult);
    public sealed virtual DynamicJsonValue ToJson();
    [CompilerGeneratedAttribute]
internal static DynamicJsonValue <ToJson>g__InnerToJson|19_0(IDictionary`2<string, QueryTimings> queryTimings);
}
public class Raven.Client.Documents.Replication.IncomingReplicationPerformanceStats : ReplicationPerformanceBase {
    [CompilerGeneratedAttribute]
private long <ReceivedLastEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatabaseChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private NetworkStats <Network>k__BackingField;
    public long ReceivedLastEtag { get; public set; }
    public string DatabaseChangeVector { get; public set; }
    public NetworkStats Network { get; public set; }
    public IncomingReplicationPerformanceStats(TimeSpan duration);
    [CompilerGeneratedAttribute]
public long get_ReceivedLastEtag();
    [CompilerGeneratedAttribute]
public void set_ReceivedLastEtag(long value);
    [CompilerGeneratedAttribute]
public string get_DatabaseChangeVector();
    [CompilerGeneratedAttribute]
public void set_DatabaseChangeVector(string value);
    [CompilerGeneratedAttribute]
public NetworkStats get_Network();
    [CompilerGeneratedAttribute]
public void set_Network(NetworkStats value);
}
public class Raven.Client.Documents.Replication.Messages.ReplicationInitialRequest : object {
    [CompilerGeneratedAttribute]
private string <PullReplicationDefinitionName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PullReplicationSinkTaskName>k__BackingField;
    [CompilerGeneratedAttribute]
private TcpConnectionInfo <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatabaseGroupId>k__BackingField;
    public string PullReplicationDefinitionName { get; public set; }
    public string PullReplicationSinkTaskName { get; public set; }
    public TcpConnectionInfo Info { get; public set; }
    public string Database { get; public set; }
    public string SourceUrl { get; public set; }
    public string DatabaseGroupId { get; public set; }
    [CompilerGeneratedAttribute]
public string get_PullReplicationDefinitionName();
    [CompilerGeneratedAttribute]
public void set_PullReplicationDefinitionName(string value);
    [CompilerGeneratedAttribute]
public string get_PullReplicationSinkTaskName();
    [CompilerGeneratedAttribute]
public void set_PullReplicationSinkTaskName(string value);
    [CompilerGeneratedAttribute]
public TcpConnectionInfo get_Info();
    [CompilerGeneratedAttribute]
public void set_Info(TcpConnectionInfo value);
    [CompilerGeneratedAttribute]
public string get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(string value);
    [CompilerGeneratedAttribute]
public string get_SourceUrl();
    [CompilerGeneratedAttribute]
public void set_SourceUrl(string value);
    [CompilerGeneratedAttribute]
public string get_DatabaseGroupId();
    [CompilerGeneratedAttribute]
public void set_DatabaseGroupId(string value);
}
public class Raven.Client.Documents.Replication.Messages.ReplicationLatestEtagRequest : object {
    [CompilerGeneratedAttribute]
private string <SourceDatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceDatabaseId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceDatabaseBase64Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceTag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceMachineName>k__BackingField;
    [CompilerGeneratedAttribute]
private ReplicationType <ReplicationsType>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MigrationIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShardedDatabaseId>k__BackingField;
    public string SourceDatabaseName { get; public set; }
    public string SourceDatabaseId { get; public set; }
    public string SourceDatabaseBase64Id { get; public set; }
    public string SourceUrl { get; public set; }
    public string SourceTag { get; public set; }
    public string SourceMachineName { get; public set; }
    public ReplicationType ReplicationsType { get; public set; }
    public long MigrationIndex { get; public set; }
    public string ShardedDatabaseId { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SourceDatabaseName();
    [CompilerGeneratedAttribute]
public void set_SourceDatabaseName(string value);
    [CompilerGeneratedAttribute]
public string get_SourceDatabaseId();
    [CompilerGeneratedAttribute]
public void set_SourceDatabaseId(string value);
    [CompilerGeneratedAttribute]
public string get_SourceDatabaseBase64Id();
    [CompilerGeneratedAttribute]
public void set_SourceDatabaseBase64Id(string value);
    [CompilerGeneratedAttribute]
public string get_SourceUrl();
    [CompilerGeneratedAttribute]
public void set_SourceUrl(string value);
    [CompilerGeneratedAttribute]
public string get_SourceTag();
    [CompilerGeneratedAttribute]
public void set_SourceTag(string value);
    [CompilerGeneratedAttribute]
public string get_SourceMachineName();
    [CompilerGeneratedAttribute]
public void set_SourceMachineName(string value);
    [CompilerGeneratedAttribute]
public ReplicationType get_ReplicationsType();
    [CompilerGeneratedAttribute]
public void set_ReplicationsType(ReplicationType value);
    [CompilerGeneratedAttribute]
public long get_MigrationIndex();
    [CompilerGeneratedAttribute]
public void set_MigrationIndex(long value);
    [CompilerGeneratedAttribute]
public string get_ShardedDatabaseId();
    [CompilerGeneratedAttribute]
public void set_ShardedDatabaseId(string value);
}
internal class Raven.Client.Documents.Replication.Messages.ReplicationMessageHeader : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastDocumentEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatabaseChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ItemsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AttachmentStreamsCount>k__BackingField;
    public string Type { get; public set; }
    public long LastDocumentEtag { get; public set; }
    public string DatabaseChangeVector { get; public set; }
    public int ItemsCount { get; public set; }
    public int AttachmentStreamsCount { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public long get_LastDocumentEtag();
    [CompilerGeneratedAttribute]
public void set_LastDocumentEtag(long value);
    [CompilerGeneratedAttribute]
public string get_DatabaseChangeVector();
    [CompilerGeneratedAttribute]
public void set_DatabaseChangeVector(string value);
    [CompilerGeneratedAttribute]
public int get_ItemsCount();
    [CompilerGeneratedAttribute]
public void set_ItemsCount(int value);
    [CompilerGeneratedAttribute]
public int get_AttachmentStreamsCount();
    [CompilerGeneratedAttribute]
public void set_AttachmentStreamsCount(int value);
}
public class Raven.Client.Documents.Replication.OutgoingReplicationPerformanceStats : ReplicationPerformanceBase {
    [CompilerGeneratedAttribute]
private long <SendLastEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastAcceptedChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private StorageStats <Storage>k__BackingField;
    [CompilerGeneratedAttribute]
private NetworkStats <Network>k__BackingField;
    public long SendLastEtag { get; public set; }
    public string LastAcceptedChangeVector { get; public set; }
    public StorageStats Storage { get; public set; }
    public NetworkStats Network { get; public set; }
    public OutgoingReplicationPerformanceStats(TimeSpan duration);
    [CompilerGeneratedAttribute]
public long get_SendLastEtag();
    [CompilerGeneratedAttribute]
public void set_SendLastEtag(long value);
    [CompilerGeneratedAttribute]
public string get_LastAcceptedChangeVector();
    [CompilerGeneratedAttribute]
public void set_LastAcceptedChangeVector(string value);
    [CompilerGeneratedAttribute]
public StorageStats get_Storage();
    [CompilerGeneratedAttribute]
public void set_Storage(StorageStats value);
    [CompilerGeneratedAttribute]
public NetworkStats get_Network();
    [CompilerGeneratedAttribute]
public void set_Network(NetworkStats value);
}
public class Raven.Client.Documents.Replication.ReplicationClientConfiguration : object {
    public DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Replication.ReplicationError : object {
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    public string Error { get; public set; }
    public DateTime Timestamp { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(string value);
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTime value);
    public virtual string ToString();
}
public abstract class Raven.Client.Documents.Replication.ReplicationNode : object {
    private string _url;
    protected bool HashCodeSealed;
    public string Database;
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    public string Url { get; public set; }
    public bool Disabled { get; public set; }
    public ReplicationType Type { get; }
    public string get_Url();
    public void set_Url(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Disabled();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Disabled(bool value);
    public ReplicationType get_Type();
    public abstract virtual ReplicationType GetReplicationType();
    public sealed virtual bool Equals(ReplicationNode other);
    public virtual bool IsEqualTo(ReplicationNode other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected static ulong CalculateStringHash(string s);
    public virtual DynamicJsonValue ToJson();
    public virtual string ToString();
    public virtual string FromString();
}
public class Raven.Client.Documents.Replication.ReplicationPerformance : object {
    [CompilerGeneratedAttribute]
private OutgoingStats[] <Outgoing>k__BackingField;
    [CompilerGeneratedAttribute]
private IncomingStats[] <Incoming>k__BackingField;
    public OutgoingStats[] Outgoing { get; public set; }
    public IncomingStats[] Incoming { get; public set; }
    [CompilerGeneratedAttribute]
public OutgoingStats[] get_Outgoing();
    [CompilerGeneratedAttribute]
public void set_Outgoing(OutgoingStats[] value);
    [CompilerGeneratedAttribute]
public IncomingStats[] get_Incoming();
    [CompilerGeneratedAttribute]
public void set_Incoming(IncomingStats[] value);
}
public abstract class Raven.Client.Documents.Replication.ReplicationPerformanceBase : object {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Started>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DurationInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Completed>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <BatchSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private ReplicationPerformanceOperation <Details>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ReplicationError> <Errors>k__BackingField;
    public int Id { get; public set; }
    public DateTime Started { get; public set; }
    public double DurationInMs { get; public set; }
    public Nullable`1<DateTime> Completed { get; public set; }
    public Nullable`1<long> BatchSizeInBytes { get; public set; }
    public ReplicationPerformanceOperation Details { get; public set; }
    public List`1<ReplicationError> Errors { get; public set; }
    protected ReplicationPerformanceBase(TimeSpan duration);
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    [CompilerGeneratedAttribute]
public DateTime get_Started();
    [CompilerGeneratedAttribute]
public void set_Started(DateTime value);
    [CompilerGeneratedAttribute]
public double get_DurationInMs();
    [CompilerGeneratedAttribute]
public void set_DurationInMs(double value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Completed();
    [CompilerGeneratedAttribute]
public void set_Completed(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_BatchSizeInBytes();
    [CompilerGeneratedAttribute]
public void set_BatchSizeInBytes(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public ReplicationPerformanceOperation get_Details();
    [CompilerGeneratedAttribute]
public void set_Details(ReplicationPerformanceOperation value);
    [CompilerGeneratedAttribute]
public List`1<ReplicationError> get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(List`1<ReplicationError> value);
}
public class Raven.Client.Documents.Replication.ReplicationPerformanceOperation : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DurationInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private ReplicationPerformanceOperation[] <Operations>k__BackingField;
    public string Name { get; public set; }
    public double DurationInMs { get; }
    public ReplicationPerformanceOperation[] Operations { get; public set; }
    public ReplicationPerformanceOperation(TimeSpan duration);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public double get_DurationInMs();
    [CompilerGeneratedAttribute]
public ReplicationPerformanceOperation[] get_Operations();
    [CompilerGeneratedAttribute]
public void set_Operations(ReplicationPerformanceOperation[] value);
}
public enum Raven.Client.Documents.Replication.StraightforwardConflictResolution : Enum {
    public int value__;
    public static StraightforwardConflictResolution None;
    public static StraightforwardConflictResolution ResolveToLatest;
}
[FlagsAttribute]
public enum Raven.Client.Documents.SearchOptions : Enum {
    public int value__;
    public static SearchOptions Or;
    public static SearchOptions And;
    public static SearchOptions Not;
    public static SearchOptions Guess;
}
public abstract class Raven.Client.Documents.Session.AbstractDocumentQuery`2 : object {
    private Dictionary`2<string, string> _aliasToGroupByFieldName;
    private static string DefaultParameterPrefix;
    private static List`1<string> _pregeneratedParametersWithDefaultPrefix;
    protected QueryOperator DefaultOperator;
    private LinqPathProvider _linqPathProvider;
    protected HashSet`1<Type> RootTypes;
    private static TypeCache`1<Func`2<object, string>> _implicitStringsCache;
    protected bool Negate;
    protected bool NegateFilter;
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectionName>k__BackingField;
    private int _currentClauseDepth;
    protected string QueryRaw;
    protected Stack`1<bool> FilterModeStack;
    protected Parameters QueryParameters;
    protected bool IsIntersect;
    protected bool IsGroupBy;
    protected InMemoryDocumentSessionOperations TheSession;
    protected Nullable`1<long> PageSize;
    protected LinkedList`1<QueryToken> SelectTokens;
    protected FromToken FromToken;
    protected IEnumerable`1<DeclareToken> DeclareTokens;
    protected List`1<LoadToken> LoadTokens;
    [CompilerGeneratedAttribute]
private FieldsToFetchToken <FieldsToFetchToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsProjectInto>k__BackingField;
    protected LinkedList`1<QueryToken> WhereTokens;
    protected LinkedList`1<QueryToken> GroupByTokens;
    protected LinkedList`1<QueryToken> OrderByTokens;
    protected LinkedList`1<QueryToken> FilterTokens;
    protected long Start;
    private DocumentConventions _conventions;
    protected Nullable`1<long> FilterLimit;
    protected Nullable`1<TimeSpan> Timeout;
    protected bool TheWaitForNonStaleResults;
    protected QueryStatistics QueryStats;
    protected bool DisableEntitiesTracking;
    protected bool DisableCaching;
    protected Nullable`1<ProjectionBehavior> ProjectionBehavior;
    private bool _isInMoreLikeThis;
    private string _includesAlias;
    [CompilerGeneratedAttribute]
private string <ParameterPrefix>k__BackingField;
    protected Action`1<IndexQuery> BeforeQueryExecutedCallback;
    protected Action`1<QueryResult> AfterQueryExecutedCallback;
    protected Action`1<BlittableJsonReaderObject> AfterStreamExecutedCallback;
    [CompilerGeneratedAttribute]
private QueryOperation <QueryOperation>k__BackingField;
    protected Explanations Explanations;
    protected ExplanationToken ExplanationToken;
    protected LinkedList`1<HighlightingToken> HighlightingTokens;
    protected QueryHighlightings QueryHighlightings;
    internal List`1<TimeSeriesIncludesToken> TimeSeriesIncludesTokens;
    protected List`1<CounterIncludesToken> CounterIncludesTokens;
    internal List`1<CompareExchangeValueIncludesToken> CompareExchangeValueIncludesTokens;
    internal List`1<RevisionIncludesToken> RevisionsIncludesTokens;
    protected HashSet`1<string> DocumentIncludes;
    protected QueryTimings QueryTimings;
    public string IndexName { get; }
    public string CollectionName { get; }
    internal bool IsFilterActive { get; }
    public FieldsToFetchToken FieldsToFetchToken { get; public set; }
    public bool IsProjectInto { get; }
    public bool IsDistinct { get; }
    public DocumentConventions Conventions { get; }
    public IDocumentSession Session { get; }
    public IAsyncDocumentSession AsyncSession { get; }
    public bool IsDynamicMapReduce { get; }
    private TimeSpan DefaultTimeout { get; }
    public string ParameterPrefix { get; public set; }
    public QueryOperation QueryOperation { get; protected set; }
    protected AbstractDocumentQuery`2(InMemoryDocumentSessionOperations session, string indexName, string collectionName, bool isGroupBy, IEnumerable`1<DeclareToken> declareTokens, List`1<LoadToken> loadTokens, string fromAlias, Nullable`1<bool> isProjectInto);
    private static AbstractDocumentQuery`2();
    [CompilerGeneratedAttribute]
public sealed virtual string get_IndexName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_CollectionName();
    internal bool get_IsFilterActive();
    [CompilerGeneratedAttribute]
public sealed virtual FieldsToFetchToken get_FieldsToFetchToken();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FieldsToFetchToken(FieldsToFetchToken value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsProjectInto();
    public sealed virtual bool get_IsDistinct();
    public sealed virtual DocumentConventions get_Conventions();
    public IDocumentSession get_Session();
    public IAsyncDocumentSession get_AsyncSession();
    public sealed virtual bool get_IsDynamicMapReduce();
    private TimeSpan get_DefaultTimeout();
    public void UsingDefaultOperator(QueryOperator operator);
    public sealed virtual void WaitForNonStaleResults(Nullable`1<TimeSpan> waitTimeout);
    internal LazyQueryOperation`1<T> GetLazyQueryOperation();
    public sealed virtual QueryOperation InitializeQueryOperation();
    public sealed virtual IndexQuery GetIndexQuery();
    public sealed virtual IEnumerable`1<string> GetProjectionFields();
    public sealed virtual void RandomOrdering();
    public sealed virtual void RandomOrdering(string seed);
    private void Projection(ProjectionBehavior projectionBehavior);
    internal void AddGroupByAlias(string fieldName, string projectedName);
    private void AssertNoRawQuery();
    public void RawQuery(string query);
    public void AddParameter(string name, object value);
    public sealed virtual void GroupBy(string fieldName, String[] fieldNames);
    public sealed virtual void GroupBy(ValueTuple`2<string, GroupByMethod> field, ValueTuple`2[] fields);
    public sealed virtual void GroupByKey(string fieldName, string projectedName);
    public sealed virtual void GroupBySum(string fieldName, string projectedName);
    public sealed virtual void GroupByCount(string projectedName);
    public sealed virtual void WhereTrue();
    public sealed virtual MoreLikeThisScope MoreLikeThis();
    [ObsoleteAttribute("
You cannot issue an in memory filter - such as Where(x=>x.Name == "Ayende") - on IDocumentQuery.
This is likely a bug, because this will execute the filter in memory, rather than in RavenDB.
Consider using session.Query<T>() instead of session.Advanced.DocumentQuery<T>. The session.Query<T>() method fully supports Linq queries, while session.Advanced.DocumentQuery<T>() is intended for lower level API access.
If you really want to do in memory filtering on the data returned from the query, you can use: session.Advanced.DocumentQuery<T>().ToList().Where(x=>x.Name == "Ayende")
", "True")]
public sealed virtual IEnumerable`1<T> Where(Func`2<T, bool> predicate);
    [ObsoleteAttribute("
You cannot issue an in memory filter - such as Count(x=>x.Name == "Ayende") - on IDocumentQuery.
This is likely a bug, because this will execute the filter in memory, rather than in RavenDB.
Consider using session.Query<T>() instead of session.Advanced.DocumentQuery<T>. The session.Query<T>() method fully supports Linq queries, while session.Advanced.DocumentQuery<T>() is intended for lower level API access.
If you really want to do in memory filtering on the data returned from the query, you can use: session.Advanced.DocumentQuery<T>().ToList().Count(x=>x.Name == "Ayende")
", "True")]
public sealed virtual int Count(Func`2<T, bool> predicate);
    [ObsoleteAttribute("
Use session.Query<T>() instead of session.Advanced.DocumentQuery<T>. The session.Query<T>() method fully supports Linq to issue group by grouping, while session.Advanced.DocumentQuery<T>() is intended for lower level API access.
", "True")]
public sealed virtual IEnumerable`1<IGrouping`2<TKey, T>> GroupBy(Func`2<T, TKey> keySelector);
    [ObsoleteAttribute("
Use session.Query<T>() instead of session.Advanced.DocumentQuery<T>. The session.Query<T>() method fully supports Linq to issue group by grouping, while session.Advanced.DocumentQuery<T>() is intended for lower level API access.
", "True")]
public sealed virtual IEnumerable`1<IGrouping`2<TKey, TElement>> GroupBy(Func`2<T, TKey> keySelector, Func`2<T, TElement> elementSelector);
    [ObsoleteAttribute("
Use session.Query<T>() instead of session.Advanced.DocumentQuery<T>. The session.Query<T>() method fully supports Linq to issue group by grouping, while session.Advanced.DocumentQuery<T>() is intended for lower level API access.
", "True")]
public sealed virtual IEnumerable`1<IGrouping`2<TKey, T>> GroupBy(Func`2<T, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ObsoleteAttribute("
Use session.Query<T>() instead of session.Advanced.DocumentQuery<T>. The session.Query<T>() method fully supports Linq to issue group by grouping, while session.Advanced.DocumentQuery<T>() is intended for lower level API access.
", "True")]
public sealed virtual IEnumerable`1<IGrouping`2<TKey, TElement>> GroupBy(Func`2<T, TKey> keySelector, Func`2<T, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    public sealed virtual void Take(long count);
    public sealed virtual void Skip(long count);
    public void WhereLucene(string fieldName, string whereClause, bool exact);
    public sealed virtual void OpenSubclause();
    public sealed virtual void CloseSubclause();
    public sealed virtual void WhereEquals(string fieldName, object value, bool exact);
    public sealed virtual void WhereEquals(string fieldName, MethodCall method, bool exact);
    public sealed virtual void WhereEquals(WhereParams whereParams);
    private bool IfValueIsMethod(WhereOperator op, WhereParams whereParams, LinkedList`1<QueryToken> tokens);
    public sealed virtual void WhereNotEquals(string fieldName, object value, bool exact);
    public sealed virtual void WhereNotEquals(string fieldName, MethodCall method, bool exact);
    public sealed virtual void WhereNotEquals(WhereParams whereParams);
    public sealed virtual void NegateNext();
    public sealed virtual void WhereIn(string fieldName, IEnumerable`1<object> values, bool exact);
    public sealed virtual void WhereStartsWith(string fieldName, object value);
    public sealed virtual void WhereStartsWith(string fieldName, object value, bool exact);
    public sealed virtual void WhereEndsWith(string fieldName, object value);
    public sealed virtual void WhereEndsWith(string fieldName, object value, bool exact);
    public sealed virtual void WhereBetween(string fieldName, object start, object end, bool exact);
    public sealed virtual void WhereGreaterThan(string fieldName, object value, bool exact);
    public sealed virtual void WhereGreaterThanOrEqual(string fieldName, object value, bool exact);
    public sealed virtual void WhereLessThan(string fieldName, object value, bool exact);
    public sealed virtual void WhereLessThanOrEqual(string fieldName, object value, bool exact);
    public sealed virtual void WhereRegex(string fieldName, string pattern);
    public sealed virtual void AndAlso();
    public void AndAlso(bool wrapPreviousQueryClauses);
    public sealed virtual void OrElse();
    internal IDisposable SetFilterMode(bool on);
    internal IDisposable SetAnyMode();
    public sealed virtual void Boost(decimal boost);
    public sealed virtual void Fuzzy(decimal fuzzy);
    public sealed virtual void Proximity(int proximity);
    public sealed virtual void OrderBy(string field, string sorterName);
    public sealed virtual void OrderBy(string field, OrderingType ordering);
    public sealed virtual void OrderByDescending(string field, string sorterName);
    public sealed virtual void OrderByDescending(string field, OrderingType ordering);
    public sealed virtual void OrderByScore();
    public sealed virtual void OrderByScoreDescending();
    public void Statistics(QueryStatistics& stats);
    public sealed virtual void InvokeAfterQueryExecuted(QueryResult result);
    public sealed virtual void InvokeAfterStreamExecuted(BlittableJsonReaderObject result);
    protected IndexQuery GenerateIndexQuery(string query);
    public sealed virtual void Search(string fieldName, string searchTerms, SearchOperator operator);
    private string ToString(bool compatibilityMode);
    public virtual string ToString();
    private void BuildPagination(StringBuilder queryText);
    private void BuildInclude(StringBuilder queryText);
    public sealed virtual void Intersect();
    public sealed virtual void WhereExists(string fieldName);
    public sealed virtual void ContainsAny(string fieldName, IEnumerable`1<object> values);
    public sealed virtual void ContainsAll(string fieldName, IEnumerable`1<object> values);
    public sealed virtual void AddRootType(Type type);
    public string GetMemberQueryPathForOrderBy(Expression expression);
    public string GetMemberQueryPath(Expression expression);
    public sealed virtual void Distinct();
    private void UpdateStatsHighlightingsAndExplanations(QueryResult queryResult);
    private void BuildSelect(StringBuilder writer);
    private void BuildFrom(StringBuilder writer);
    private void BuildDeclare(StringBuilder writer);
    private void BuildLoad(StringBuilder writer);
    private void BuildWhere(StringBuilder writer);
    private void BuildGroupBy(StringBuilder writer);
    private void BuildFilter(StringBuilder writer);
    private void BuildOrderBy(StringBuilder writer);
    private void AppendOperatorIfNeeded(LinkedList`1<QueryToken> tokens);
    [IteratorStateMachineAttribute("Raven.Client.Documents.Session.AbstractDocumentQuery`2/<TransformEnumerable>d__157")]
private IEnumerable`1<object> TransformEnumerable(string fieldName, IEnumerable`1<object> values);
    private void NegateIfNeeded(LinkedList`1<QueryToken> tokens, string fieldName);
    [IteratorStateMachineAttribute("Raven.Client.Documents.Session.AbstractDocumentQuery`2/<UnpackEnumerable>d__159")]
private static IEnumerable`1<object> UnpackEnumerable(IEnumerable items);
    private string EnsureValidFieldName(string fieldName, bool isNestedPath);
    private static Func`2<object, string> GetImplicitStringConversion(Type type);
    private object TransformValue(WhereParams whereParams, bool forRange);
    private string AddQueryParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ParameterPrefix();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ParameterPrefix(string value);
    private void AssertMethodIsCurrentlySupported(string methodName);
    private LinkedList`1<QueryToken> GetCurrentWhereTokens();
    private LinkedList`1<QueryToken> GetCurrentFilterTokens();
    private LinkedList`1<QueryToken> GetCurrentOrderByTokens();
    protected void UpdateFieldsToFetchToken(FieldsToFetchToken fieldsToFetch);
    public sealed virtual void AddFromAliasToWhereTokens(string fromAlias);
    public sealed virtual void AddFromAliasToOrderByTokens(string fromAlias);
    public sealed virtual void AddFromAliasToFilterTokens(string fromAlias);
    private void AddFromAliasToTokens(string fromAlias, LinkedList`1<QueryToken> tokens);
    public sealed virtual string AddAliasToIncludesTokens(string fromAlias);
    protected static void GetSourceAliasIfExists(QueryData queryData, String[] fields, String& sourceAlias);
    protected QueryData CreateTimeSeriesQueryData(Func`2<ITimeSeriesQueryBuilder, TTs> timeSeriesQuery);
    public sealed virtual string ProjectionParameter(object value);
    internal void AddFilterLimit(int filterLimit);
    [CompilerGeneratedAttribute]
public sealed virtual QueryOperation get_QueryOperation();
    [CompilerGeneratedAttribute]
protected void set_QueryOperation(QueryOperation value);
    public sealed virtual IDocumentQueryCustomization BeforeQueryExecuted(Action`1<IndexQuery> action);
    public sealed virtual IDocumentQueryCustomization AfterQueryExecuted(Action`1<QueryResult> action);
    public sealed virtual IDocumentQueryCustomization AfterStreamExecuted(Action`1<BlittableJsonReaderObject> action);
    public sealed virtual IDocumentQueryCustomization NoTracking();
    public sealed virtual IDocumentQueryCustomization NoCaching();
    public sealed virtual IDocumentQueryCustomization Timings(QueryTimings& timings);
    private sealed virtual override IDocumentQueryCustomization Raven.Client.Documents.Session.IDocumentQueryCustomization.RandomOrdering();
    private sealed virtual override IDocumentQueryCustomization Raven.Client.Documents.Session.IDocumentQueryCustomization.RandomOrdering(string seed);
    private sealed virtual override IDocumentQueryCustomization Raven.Client.Documents.Session.IDocumentQueryCustomization.WaitForNonStaleResults(Nullable`1<TimeSpan> waitTimeout);
    private sealed virtual override IDocumentQueryCustomization Raven.Client.Documents.Session.IDocumentQueryCustomization.Projection(ProjectionBehavior projectionBehavior);
    private sealed virtual override IDocumentQueryCustomization Raven.Client.Documents.Session.IDocumentQueryCustomization.ShardContext(Action`1<IQueryShardedContextBuilder> builder);
    public void IncludeExplanations(ExplanationOptions options, Explanations& explanations);
    public sealed virtual void AggregateBy(FacetBase facet);
    public sealed virtual void AggregateUsing(string facetSetupDocumentId);
    public sealed virtual void Highlight(string fieldName, int fragmentLength, int fragmentCount, HighlightingOptions options, Highlightings& highlightings);
    public sealed virtual void Include(string path);
    public sealed virtual void Include(Expression`1<Func`2<T, object>> path);
    public sealed virtual void Include(IncludeBuilder includes);
    private void IncludeCounters(string alias, Dictionary`2<string, ValueTuple`2<bool, HashSet`1<string>>> countersToIncludeByDocId);
    private void IncludeTimeSeries(string alias, Dictionary`2<string, HashSet`1<AbstractTimeSeriesRange>> timeSeriesToInclude);
    private void IncludeRevisions(DateTime dateTime);
    private void IncludeRevisions(HashSet`1<string> revisionsToIncludeByChangeVector);
    protected void ShardContext(Action`1<IQueryShardedContextBuilder> builder);
    protected void WithinRadiusOf(string fieldName, double radius, double latitude, double longitude, Nullable`1<SpatialUnits> radiusUnits, double distErrorPercent);
    protected void Spatial(string fieldName, string shapeWkt, SpatialRelation relation, Nullable`1<SpatialUnits> units, double distErrorPercent);
    public sealed virtual void Spatial(DynamicSpatialField dynamicField, SpatialCriteria criteria);
    public sealed virtual void Spatial(string fieldName, SpatialCriteria criteria);
    public sealed virtual void OrderByDistance(DynamicSpatialField field, double latitude, double longitude);
    public sealed virtual void OrderByDistance(string fieldName, double latitude, double longitude);
    public sealed virtual void OrderByDistance(string fieldName, double latitude, double longitude, double roundFactor);
    public sealed virtual void OrderByDistance(DynamicSpatialField field, string shapeWkt);
    public sealed virtual void OrderByDistance(string fieldName, string shapeWkt);
    public sealed virtual void OrderByDistance(string fieldName, string shapeWkt, double roundFactor);
    public sealed virtual void OrderByDistanceDescending(DynamicSpatialField field, double latitude, double longitude);
    public sealed virtual void OrderByDistanceDescending(string fieldName, double latitude, double longitude);
    public sealed virtual void OrderByDistanceDescending(string fieldName, double latitude, double longitude, double roundFactor);
    public sealed virtual void OrderByDistanceDescending(DynamicSpatialField field, string shapeWkt);
    public sealed virtual void OrderByDistanceDescending(string fieldName, string shapeWkt);
    public sealed virtual void OrderByDistanceDescending(string fieldName, string shapeWkt, double roundFactor);
    private void AssertIsDynamicQuery(DynamicSpatialField dynamicField, string methodName);
    public sealed virtual void SuggestUsing(SuggestionBase suggestion);
    private string GetOptionsParameterName(SuggestionOptions options);
    private void AssertCanSuggest(SuggestionBase suggestion);
    public void IncludeTimings(QueryTimings& timings);
    [CompilerGeneratedAttribute]
private void <MoreLikeThis>b__83_0();
    [CompilerGeneratedAttribute]
internal static void <BuildInclude>g__WriteIncludeTokens|138_0(IEnumerable`1<TToken> tokens, <>c__DisplayClass138_0& );
}
internal class Raven.Client.Documents.Session.AbstractDocumentQueryCache : object {
    public static TypeCache`1<TransformationMode> TransformTypeCache;
    public static TypeCache`1<Type> TransformNonNullableTypeCache;
    private static AbstractDocumentQueryCache();
}
public abstract class Raven.Client.Documents.Session.AdvancedSessionExtensionBase : object {
    [CompilerGeneratedAttribute]
private InMemoryDocumentSessionOperations <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestExecutor <RequestExecutor>k__BackingField;
    [CompilerGeneratedAttribute]
private SessionInfo <SessionInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonOperationContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private IDocumentStore <DocumentStore>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<ValueTuple`3<string, CommandType, string>, ICommandData> <DeferredCommandsDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentsById <DocumentsById>k__BackingField;
    protected InMemoryDocumentSessionOperations Session { get; }
    protected RequestExecutor RequestExecutor { get; }
    protected SessionInfo SessionInfo { get; }
    protected JsonOperationContext Context { get; }
    protected IDocumentStore DocumentStore { get; }
    protected Dictionary`2<ValueTuple`3<string, CommandType, string>, ICommandData> DeferredCommandsDictionary { get; }
    internal DocumentsById DocumentsById { get; }
    protected AdvancedSessionExtensionBase(InMemoryDocumentSessionOperations session);
    [CompilerGeneratedAttribute]
protected InMemoryDocumentSessionOperations get_Session();
    [CompilerGeneratedAttribute]
protected RequestExecutor get_RequestExecutor();
    [CompilerGeneratedAttribute]
protected SessionInfo get_SessionInfo();
    [CompilerGeneratedAttribute]
protected JsonOperationContext get_Context();
    [CompilerGeneratedAttribute]
protected IDocumentStore get_DocumentStore();
    [CompilerGeneratedAttribute]
protected Dictionary`2<ValueTuple`3<string, CommandType, string>, ICommandData> get_DeferredCommandsDictionary();
    [CompilerGeneratedAttribute]
internal DocumentsById get_DocumentsById();
    public void Defer(ICommandData command, ICommandData[] commands);
}
public class Raven.Client.Documents.Session.AfterConversionToDocumentEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Entity>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private InMemoryDocumentSessionOperations <Session>k__BackingField;
    public string Id { get; }
    public object Entity { get; }
    public BlittableJsonReaderObject Document { get; public set; }
    public InMemoryDocumentSessionOperations Session { get; }
    public AfterConversionToDocumentEventArgs(InMemoryDocumentSessionOperations session, string id, object entity, BlittableJsonReaderObject document);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public object get_Entity();
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_Document();
    [CompilerGeneratedAttribute]
public void set_Document(BlittableJsonReaderObject value);
    [CompilerGeneratedAttribute]
public InMemoryDocumentSessionOperations get_Session();
}
public class Raven.Client.Documents.Session.AfterConversionToEntityEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Entity>k__BackingField;
    [CompilerGeneratedAttribute]
private InMemoryDocumentSessionOperations <Session>k__BackingField;
    public string Id { get; }
    public BlittableJsonReaderObject Document { get; }
    public object Entity { get; }
    public InMemoryDocumentSessionOperations Session { get; }
    internal AfterConversionToEntityEventArgs(InMemoryDocumentSessionOperations session, string id, BlittableJsonReaderObject document, object entity);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_Document();
    [CompilerGeneratedAttribute]
public object get_Entity();
    [CompilerGeneratedAttribute]
public InMemoryDocumentSessionOperations get_Session();
}
public class Raven.Client.Documents.Session.AfterSaveChangesEventArgs : EventArgs {
    private IMetadataDictionary _documentMetadata;
    [CompilerGeneratedAttribute]
private InMemoryDocumentSessionOperations <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Entity>k__BackingField;
    public InMemoryDocumentSessionOperations Session { get; }
    public string DocumentId { get; }
    public object Entity { get; }
    public IMetadataDictionary DocumentMetadata { get; }
    public AfterSaveChangesEventArgs(InMemoryDocumentSessionOperations session, string documentId, object entity);
    [CompilerGeneratedAttribute]
public InMemoryDocumentSessionOperations get_Session();
    [CompilerGeneratedAttribute]
public string get_DocumentId();
    [CompilerGeneratedAttribute]
public object get_Entity();
    public IMetadataDictionary get_DocumentMetadata();
}
public class Raven.Client.Documents.Session.AsyncDocumentQuery`1 : AbstractDocumentQuery`2<T, AsyncDocumentQuery`1<T>> {
    private IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.Not { get; }
    private InMemoryDocumentSessionOperations Raven.Client.Documents.Linq.IDocumentQueryGenerator.Session { get; }
    public AsyncDocumentQuery`1(InMemoryDocumentSessionOperations session, string indexName, string collectionName, bool isGroupBy, IEnumerable`1<DeclareToken> declareTokens, List`1<LoadToken> loadTokens, string fromAlias, Nullable`1<bool> isProjectInfo);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.Include(string path);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.Include(Expression`1<Func`2<T, object>> path);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.get_Not();
    private sealed virtual override IAsyncRawDocumentQuery`1<T> Raven.Client.Documents.Session.IPagingDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncRawDocumentQuery<T>>.Skip(long count);
    private sealed virtual override IAsyncRawDocumentQuery`1<T> Raven.Client.Documents.Session.IPagingDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncRawDocumentQuery<T>>.Take(long count);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IPagingDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.Take(long count);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IPagingDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.Skip(long count);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereLucene(string fieldName, string whereClause);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereLucene(string fieldName, string whereClause, bool exact);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereEquals(string fieldName, object value, bool exact);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereEquals(string fieldName, MethodCall value, bool exact);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereEquals(Expression`1<Func`2<T, TValue>> propertySelector, TValue value, bool exact);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereEquals(Expression`1<Func`2<T, TValue>> propertySelector, MethodCall value, bool exact);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereEquals(WhereParams whereParams);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereNotEquals(string fieldName, object value, bool exact);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereNotEquals(string fieldName, MethodCall value, bool exact);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereNotEquals(Expression`1<Func`2<T, TValue>> propertySelector, TValue value, bool exact);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereNotEquals(Expression`1<Func`2<T, TValue>> propertySelector, MethodCall value, bool exact);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereNotEquals(WhereParams whereParams);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereIn(string fieldName, IEnumerable`1<object> values, bool exact);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereIn(Expression`1<Func`2<T, TValue>> propertySelector, IEnumerable`1<TValue> values, bool exact);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereStartsWith(string fieldName, object value);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereStartsWith(string fieldName, object value, bool exact);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereStartsWith(Expression`1<Func`2<T, TValue>> propertySelector, TValue value);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereStartsWith(Expression`1<Func`2<T, TValue>> propertySelector, TValue value, bool exact);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereEndsWith(string fieldName, object value);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereEndsWith(string fieldName, object value, bool exact);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereEndsWith(Expression`1<Func`2<T, TValue>> propertySelector, TValue value);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereEndsWith(Expression`1<Func`2<T, TValue>> propertySelector, TValue value, bool exact);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereBetween(string fieldName, object start, object end, bool exact);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereBetween(Expression`1<Func`2<T, TValue>> propertySelector, TValue start, TValue end, bool exact);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereGreaterThan(string fieldName, object value, bool exact);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereGreaterThan(Expression`1<Func`2<T, TValue>> propertySelector, TValue value, bool exact);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereGreaterThanOrEqual(string fieldName, object value, bool exact);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereGreaterThanOrEqual(Expression`1<Func`2<T, TValue>> propertySelector, TValue value, bool exact);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereLessThan(string fieldName, object value, bool exact);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereLessThan(Expression`1<Func`2<T, TValue>> propertySelector, TValue value, bool exact);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereLessThanOrEqual(string fieldName, object value, bool exact);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereLessThanOrEqual(Expression`1<Func`2<T, TValue>> propertySelector, TValue value, bool exact);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereExists(Expression`1<Func`2<T, TValue>> propertySelector);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereExists(string fieldName);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereRegex(Expression`1<Func`2<T, TValue>> propertySelector, string pattern);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WhereRegex(string fieldName, string pattern);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.AndAlso();
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.AndAlso(bool wrapPreviousQueryClauses);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrElse();
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.Boost(decimal boost);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.Fuzzy(decimal fuzzy);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.Proximity(int proximity);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.RandomOrdering();
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.RandomOrdering(string seed);
    private sealed virtual override IAsyncDocumentQuery`1<TResult> Raven.Client.Documents.Session.IAsyncDocumentQuery<T>.OfType();
    private sealed virtual override IAsyncGroupByDocumentQuery`1<T> Raven.Client.Documents.Session.IAsyncDocumentQuery<T>.GroupBy(string fieldName, String[] fieldNames);
    private sealed virtual override IAsyncGroupByDocumentQuery`1<T> Raven.Client.Documents.Session.IAsyncDocumentQuery<T>.GroupBy(ValueTuple`2<string, GroupByMethod> field, ValueTuple`2[] fields);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderBy(string field, string sorterName);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderBy(string field, OrderingType ordering);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderBy(Expression`1<Func`2<T, TValue>> propertySelector);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderBy(Expression`1<Func`2<T, TValue>> propertySelector, string sorterName);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderBy(Expression`1<Func`2<T, TValue>> propertySelector, OrderingType ordering);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderBy(Expression`1[] propertySelectors);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDescending(string field, string sorterName);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDescending(string field, OrderingType ordering);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDescending(Expression`1<Func`2<T, TValue>> propertySelector);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDescending(Expression`1<Func`2<T, TValue>> propertySelector, string sorterName);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDescending(Expression`1<Func`2<T, TValue>> propertySelector, OrderingType ordering);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDescending(Expression`1[] propertySelectors);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.BeforeQueryExecuted(Action`1<IndexQuery> beforeQueryExecuted);
    private sealed virtual override IAsyncRawDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IAsyncRawDocumentQuery<T>>.BeforeQueryExecuted(Action`1<IndexQuery> beforeQueryExecuted);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WaitForNonStaleResults(Nullable`1<TimeSpan> waitTimeout);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.AddParameter(string name, object value);
    private sealed virtual override IAsyncRawDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IAsyncRawDocumentQuery<T>>.AddParameter(string name, object value);
    private sealed virtual override IAsyncRawDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IAsyncRawDocumentQuery<T>>.WaitForNonStaleResults(Nullable`1<TimeSpan> waitTimeout);
    public sealed virtual IAsyncDocumentQuery`1<TProjection> SelectFields();
    public sealed virtual IAsyncDocumentQuery`1<TProjection> SelectFields(ProjectionBehavior projectionBehavior);
    public sealed virtual IAsyncDocumentQuery`1<TProjection> SelectFields(String[] fields);
    public sealed virtual IAsyncDocumentQuery`1<TProjection> SelectFields(ProjectionBehavior projectionBehavior, String[] fields);
    public sealed virtual IAsyncDocumentQuery`1<TProjection> SelectFields(QueryData queryData);
    private sealed virtual override IAsyncDocumentQuery`1<TTimeSeries> Raven.Client.Documents.Session.IAsyncDocumentQuery<T>.SelectTimeSeries(Func`2<ITimeSeriesQueryBuilder, TTimeSeries> timeSeriesQuery);
    private sealed virtual override Lazy`1<Task`1<int>> Raven.Client.Documents.Session.IAsyncDocumentQueryBase<T>.CountLazilyAsync(CancellationToken token);
    private sealed virtual override Lazy`1<Task`1<long>> Raven.Client.Documents.Session.IAsyncDocumentQueryBase<T>.LongCountLazilyAsync(CancellationToken token);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.AddOrder(string fieldName, bool descending, OrderingType ordering);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByScore();
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByScoreDescending();
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.AddOrder(Expression`1<Func`2<T, TValue>> propertySelector, bool descending, OrderingType ordering);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.AfterQueryExecuted(Action`1<QueryResult> action);
    private sealed virtual override IAsyncRawDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IAsyncRawDocumentQuery<T>>.AfterQueryExecuted(Action`1<QueryResult> action);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.AfterStreamExecuted(Action`1<BlittableJsonReaderObject> action);
    private sealed virtual override IAsyncRawDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IAsyncRawDocumentQuery<T>>.AfterStreamExecuted(Action`1<BlittableJsonReaderObject> action);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OpenSubclause();
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.Search(string fieldName, string searchTerms, SearchOperator operator);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.Search(Expression`1<Func`2<T, TValue>> propertySelector, string searchTerms, SearchOperator operator);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.CloseSubclause();
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.NegateNext();
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.Intersect();
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.ContainsAll(Expression`1<Func`2<T, IEnumerable`1<TValue>>> propertySelector, IEnumerable`1<TValue> values);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.ContainsAny(string fieldName, IEnumerable`1<object> values);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.ContainsAny(Expression`1<Func`2<T, TValue>> propertySelector, IEnumerable`1<TValue> values);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.ContainsAny(Expression`1<Func`2<T, IEnumerable`1<TValue>>> propertySelector, IEnumerable`1<TValue> values);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.ContainsAll(string fieldName, IEnumerable`1<object> values);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.ContainsAll(Expression`1<Func`2<T, TValue>> propertySelector, IEnumerable`1<TValue> values);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.Statistics(QueryStatistics& stats);
    private sealed virtual override IAsyncRawDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IAsyncRawDocumentQuery<T>>.Statistics(QueryStatistics& stats);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.UsingDefaultOperator(QueryOperator queryOperator);
    private sealed virtual override IAsyncRawDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IAsyncRawDocumentQuery<T>>.UsingDefaultOperator(QueryOperator queryOperator);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.NoTracking();
    private sealed virtual override IAsyncRawDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IAsyncRawDocumentQuery<T>>.NoTracking();
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.NoCaching();
    private sealed virtual override IAsyncRawDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IAsyncRawDocumentQuery<T>>.NoCaching();
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.Timings(QueryTimings& timings);
    private sealed virtual override IAsyncRawDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IAsyncRawDocumentQuery<T>>.Timings(QueryTimings& timings);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.Distinct();
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.IncludeExplanations(Explanations& explanations);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.IncludeExplanations(ExplanationOptions options, Explanations& explanations);
    private sealed virtual override IAsyncRawDocumentQuery`1<T> Raven.Client.Documents.Session.IAsyncRawDocumentQuery<T>.Projection(ProjectionBehavior projectionBehavior);
    private sealed virtual override Task`1<List`1<T>> Raven.Client.Documents.Session.IAsyncDocumentQueryBase<T>.ToListAsync(CancellationToken token);
    private sealed virtual override Task`1<T[]> Raven.Client.Documents.Session.IAsyncDocumentQueryBase<T>.ToArrayAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentQuery`1/<Raven-Client-Documents-Session-IAsyncDocumentQueryBase<T>-FirstAsync>d__118")]
private sealed virtual override Task`1<T> Raven.Client.Documents.Session.IAsyncDocumentQueryBase<T>.FirstAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentQuery`1/<Raven-Client-Documents-Session-IAsyncDocumentQueryBase<T>-FirstOrDefaultAsync>d__119")]
private sealed virtual override Task`1<T> Raven.Client.Documents.Session.IAsyncDocumentQueryBase<T>.FirstOrDefaultAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentQuery`1/<Raven-Client-Documents-Session-IAsyncDocumentQueryBase<T>-SingleAsync>d__120")]
private sealed virtual override Task`1<T> Raven.Client.Documents.Session.IAsyncDocumentQueryBase<T>.SingleAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentQuery`1/<Raven-Client-Documents-Session-IAsyncDocumentQueryBase<T>-SingleOrDefaultAsync>d__121")]
private sealed virtual override Task`1<T> Raven.Client.Documents.Session.IAsyncDocumentQueryBase<T>.SingleOrDefaultAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentQuery`1/<Raven-Client-Documents-Session-IAsyncDocumentQueryBase<T>-AnyAsync>d__122")]
private sealed virtual override Task`1<bool> Raven.Client.Documents.Session.IAsyncDocumentQueryBase<T>.AnyAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentQuery`1/<ExecuteQueryOperation>d__123")]
private Task`1<List`1<T>> ExecuteQueryOperation(Nullable`1<int> take, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentQuery`1/<ExecuteQueryOperationAsArray>d__124")]
private Task`1<T[]> ExecuteQueryOperationAsArray(Nullable`1<int> take, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentQuery`1/<ExecuteQueryOperationInternal>d__125")]
private Task ExecuteQueryOperationInternal(Nullable`1<int> take, CancellationToken token);
    private sealed virtual override Lazy`1<Task`1<IEnumerable`1<T>>> Raven.Client.Documents.Session.IAsyncDocumentQueryBase<T>.LazilyAsync(Action`1<IEnumerable`1<T>> onEval);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentQuery`1/<Raven-Client-Documents-Session-IAsyncDocumentQueryBase<T>-CountAsync>d__127")]
private sealed virtual override Task`1<int> Raven.Client.Documents.Session.IAsyncDocumentQueryBase<T>.CountAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentQuery`1/<Raven-Client-Documents-Session-IAsyncDocumentQueryBase<T>-LongCountAsync>d__128")]
private sealed virtual override Task`1<long> Raven.Client.Documents.Session.IAsyncDocumentQueryBase<T>.LongCountAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentQuery`1/<GetQueryResultAsync>d__129")]
public sealed virtual Task`1<QueryResult> GetQueryResultAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentQuery`1/<InitAsync>d__130")]
protected Task InitAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentQuery`1/<ExecuteActualQueryAsync>d__131")]
private Task ExecuteActualQueryAsync(CancellationToken token);
    internal AsyncDocumentQuery`1<TResult> CreateDocumentQueryInternal(QueryData queryData);
    public sealed virtual IRavenQueryable`1<T> ToQueryable();
    private sealed virtual override InMemoryDocumentSessionOperations Raven.Client.Documents.Linq.IDocumentQueryGenerator.get_Session();
    private sealed virtual override RavenQueryInspector`1<TS> Raven.Client.Documents.Linq.IDocumentQueryGenerator.CreateRavenQueryInspector();
    public sealed virtual IDocumentQuery`1<TResult> Query(string indexName, string collectionName, bool isMapReduce);
    public sealed virtual IAsyncDocumentQuery`1<TResult> AsyncQuery(string indexName, string collectionName, bool isMapReduce);
    public sealed virtual IAsyncAggregationDocumentQuery`1<T> AggregateBy(Action`1<IFacetBuilder`1<T>> builder);
    public sealed virtual IAsyncAggregationDocumentQuery`1<T> AggregateBy(FacetBase facet);
    public sealed virtual IAsyncAggregationDocumentQuery`1<T> AggregateBy(IEnumerable`1<FacetBase> facets);
    public sealed virtual IAsyncAggregationDocumentQuery`1<T> AggregateUsing(string facetSetupDocumentId);
    public sealed virtual Task`1<Dictionary`2<string, FacetResult>> ExecuteAggregationAsync(CancellationToken token);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IAsyncDocumentQuery<T>.Filter(Action`1<IFilterFactory`1<T>> builder, int limit);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.Highlight(string fieldName, int fragmentLength, int fragmentCount, Highlightings& highlightings);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.Highlight(string fieldName, int fragmentLength, int fragmentCount, HighlightingOptions options, Highlightings& highlightings);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.Highlight(Expression`1<Func`2<T, object>> path, int fragmentLength, int fragmentCount, Highlightings& highlightings);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.Highlight(Expression`1<Func`2<T, object>> path, int fragmentLength, int fragmentCount, HighlightingOptions options, Highlightings& highlightings);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.MoreLikeThis(MoreLikeThisBase moreLikeThis);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IAsyncDocumentQuery<T>.MoreLikeThis(Action`1<IMoreLikeThisBuilderForAsyncDocumentQuery`1<T>> builder);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IAsyncDocumentQuery<T>.ShardContext(Action`1<IQueryShardedContextBuilder> builder);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.Spatial(Expression`1<Func`2<T, object>> path, Func`2<SpatialCriteriaFactory, SpatialCriteria> clause);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.Spatial(string fieldName, Func`2<SpatialCriteriaFactory, SpatialCriteria> clause);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.Spatial(DynamicSpatialField field, Func`2<SpatialCriteriaFactory, SpatialCriteria> clause);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.Spatial(Func`2<DynamicSpatialFieldFactory`1<T>, DynamicSpatialField> field, Func`2<SpatialCriteriaFactory, SpatialCriteria> clause);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WithinRadiusOf(Expression`1<Func`2<T, TValue>> propertySelector, double radius, double latitude, double longitude, Nullable`1<SpatialUnits> radiusUnits, double distanceErrorPct);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.WithinRadiusOf(string fieldName, double radius, double latitude, double longitude, Nullable`1<SpatialUnits> radiusUnits, double distanceErrorPct);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.RelatesToShape(Expression`1<Func`2<T, TValue>> propertySelector, string shapeWkt, SpatialRelation relation, double distanceErrorPct);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.RelatesToShape(Expression`1<Func`2<T, TValue>> propertySelector, string shapeWkt, SpatialRelation relation, SpatialUnits units, double distanceErrorPct);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.RelatesToShape(string fieldName, string shapeWkt, SpatialRelation relation, double distanceErrorPct);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.RelatesToShape(string fieldName, string shapeWkt, SpatialRelation relation, SpatialUnits units, double distanceErrorPct);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDistance(DynamicSpatialField field, double latitude, double longitude);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDistance(Func`2<DynamicSpatialFieldFactory`1<T>, DynamicSpatialField> field, double latitude, double longitude);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDistance(DynamicSpatialField field, string shapeWkt);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDistance(Func`2<DynamicSpatialFieldFactory`1<T>, DynamicSpatialField> field, string shapeWkt);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDistance(Expression`1<Func`2<T, object>> propertySelector, double latitude, double longitude);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDistance(string fieldName, double latitude, double longitude);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDistance(Expression`1<Func`2<T, object>> propertySelector, string shapeWkt);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDistance(string fieldName, string shapeWkt);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDistanceDescending(DynamicSpatialField field, double latitude, double longitude);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDistanceDescending(Func`2<DynamicSpatialFieldFactory`1<T>, DynamicSpatialField> field, double latitude, double longitude);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDistanceDescending(DynamicSpatialField field, string shapeWkt);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDistanceDescending(Func`2<DynamicSpatialFieldFactory`1<T>, DynamicSpatialField> field, string shapeWkt);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDistanceDescending(Expression`1<Func`2<T, object>> propertySelector, double latitude, double longitude);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDistanceDescending(string fieldName, double latitude, double longitude);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDistanceDescending(Expression`1<Func`2<T, object>> propertySelector, string shapeWkt);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDistanceDescending(string fieldName, string shapeWkt);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDistance(Expression`1<Func`2<T, object>> propertySelector, double latitude, double longitude, double roundFactor);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDistance(string fieldName, double latitude, double longitude, double roundFactor);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDistance(Expression`1<Func`2<T, object>> propertySelector, string shapeWkt, double roundFactor);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDistance(string fieldName, string shapeWkt, double roundFactor);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDistanceDescending(Expression`1<Func`2<T, object>> propertySelector, double latitude, double longitude, double roundFactor);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDistanceDescending(string fieldName, double latitude, double longitude, double roundFactor);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDistanceDescending(Expression`1<Func`2<T, object>> propertySelector, string shapeWkt, double roundFactor);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IAsyncDocumentQuery<T>>.OrderByDistanceDescending(string fieldName, string shapeWkt, double roundFactor);
    private sealed virtual override IAsyncSuggestionDocumentQuery`1<T> Raven.Client.Documents.Session.IAsyncDocumentQuery<T>.SuggestUsing(SuggestionBase suggestion);
    private sealed virtual override IAsyncSuggestionDocumentQuery`1<T> Raven.Client.Documents.Session.IAsyncDocumentQuery<T>.SuggestUsing(Action`1<ISuggestionBuilder`1<T>> builder);
}
public class Raven.Client.Documents.Session.AsyncDocumentSession : InMemoryDocumentSessionOperations {
    private AsyncDocumentIdGeneration _asyncDocumentIdGeneration;
    private IAttachmentsSessionOperationsAsync _attachments;
    private IRevisionsSessionOperationsAsync _revisions;
    private IClusterTransactionOperationsAsync _clusterTransaction;
    public IAsyncAdvancedSessionOperations Advanced { get; }
    public IAsyncEagerSessionOperations Eagerly { get; }
    public IAsyncLazySessionOperations Lazily { get; }
    public IAttachmentsSessionOperationsAsync Attachments { get; }
    public IRevisionsSessionOperationsAsync Revisions { get; }
    public IClusterTransactionOperationsAsync ClusterTransaction { get; }
    protected bool HasClusterSession { get; }
    private InMemoryDocumentSessionOperations Raven.Client.Documents.Linq.IDocumentQueryGenerator.Session { get; }
    public AsyncDocumentSession(DocumentStore documentStore, Guid id, SessionOptions options);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentSession/<ConditionalLoadAsync>d__0`1")]
public sealed virtual Task`1<ValueTuple`2<T, string>> ConditionalLoadAsync(string id, string changeVector, CancellationToken token);
    public sealed virtual IAsyncSessionDocumentCounters CountersFor(string documentId);
    public sealed virtual IAsyncSessionDocumentCounters CountersFor(object entity);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentSession/<ExistsAsync>d__5")]
public sealed virtual Task`1<bool> ExistsAsync(string id, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentSession/<RefreshAsync>d__6`1")]
public sealed virtual Task RefreshAsync(T entity, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentSession/<RefreshAsync>d__7`1")]
public sealed virtual Task RefreshAsync(IEnumerable`1<T> entities, CancellationToken token);
    public sealed virtual IAsyncAdvancedSessionOperations get_Advanced();
    [ObsoleteAttribute("InMemoryDocumentSessionOperations.GenerateId is not supported anymore. Will be removed in next major version of the product.")]
protected virtual string GenerateId(object entity);
    protected virtual void RememberEntityForDocumentIdGeneration(object entity);
    private void EnsureAsyncDocumentIdGeneration();
    protected virtual Task`1<string> GenerateIdAsync(object entity);
    public sealed virtual IAsyncEagerSessionOperations get_Eagerly();
    public sealed virtual IAsyncLazySessionOperations get_Lazily();
    public sealed virtual IAttachmentsSessionOperationsAsync get_Attachments();
    public sealed virtual IRevisionsSessionOperationsAsync get_Revisions();
    public sealed virtual IClusterTransactionOperationsAsync get_ClusterTransaction();
    protected virtual bool get_HasClusterSession();
    protected virtual void ClearClusterSession();
    protected internal virtual ClusterTransactionOperationsBase GetClusterSession();
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentSession/<SaveChangesAsync>d__31")]
public sealed virtual Task SaveChangesAsync(CancellationToken token);
    public sealed virtual IAsyncLoaderWithInclude`1<object> Include(string path);
    public sealed virtual IAsyncLoaderWithInclude`1<T> Include(Expression`1<Func`2<T, string>> path);
    public sealed virtual IAsyncLoaderWithInclude`1<T> Include(Expression`1<Func`2<T, string>> path);
    public sealed virtual IAsyncLoaderWithInclude`1<T> Include(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    public sealed virtual IAsyncLoaderWithInclude`1<T> Include(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    internal Lazy`1<Task`1<T>> AddLazyOperation(ILazyOperation operation, Action`1<T> onEval, CancellationToken token);
    internal Lazy`1<Task`1<int>> AddLazyCountOperation(ILazyOperation operation, CancellationToken token);
    internal Lazy`1<Task`1<long>> AddLazyLongCountOperation(ILazyOperation operation, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentSession/<ExecuteAllPendingLazyOperationsAsync>d__40")]
public sealed virtual Task`1<ResponseTimeInformation> ExecuteAllPendingLazyOperationsAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentSession/<ExecuteLazyOperationsSingleStep>d__41")]
private Task`1<bool> ExecuteLazyOperationsSingleStep(ResponseTimeInformation responseTimeInformation, List`1<GetRequest> requests, Stopwatch sw, CancellationToken token);
    private sealed virtual override IAsyncLazyLoaderWithInclude`1<T> Raven.Client.Documents.Session.Operations.Lazy.IAsyncLazySessionOperations.Include(Expression`1<Func`2<T, string>> path);
    private sealed virtual override IAsyncLazyLoaderWithInclude`1<T> Raven.Client.Documents.Session.Operations.Lazy.IAsyncLazySessionOperations.Include(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    private sealed virtual override IAsyncLazyLoaderWithInclude`1<object> Raven.Client.Documents.Session.Operations.Lazy.IAsyncLazySessionOperations.Include(string path);
    private sealed virtual override Lazy`1<Task`1<Dictionary`2<string, T>>> Raven.Client.Documents.Session.Operations.Lazy.IAsyncLazySessionOperations.LoadAsync(IEnumerable`1<string> ids, CancellationToken token);
    private sealed virtual override Lazy`1<Task`1<T>> Raven.Client.Documents.Session.Operations.Lazy.IAsyncLazySessionOperations.LoadAsync(string id, CancellationToken token);
    public sealed virtual Lazy`1<Task`1<Dictionary`2<string, T>>> LoadAsync(IEnumerable`1<string> ids, Action`1<Dictionary`2<string, T>> onEval, CancellationToken token);
    public sealed virtual Lazy`1<Task`1<T>> LoadAsync(string id, Action`1<T> onEval, CancellationToken token);
    public sealed virtual Lazy`1<Task`1<Dictionary`2<string, T>>> LazyAsyncLoadInternal(String[] ids, String[] includes, Action`1<Dictionary`2<string, T>> onEval, CancellationToken token);
    private sealed virtual override Lazy`1<Task`1<Dictionary`2<string, T>>> Raven.Client.Documents.Session.Operations.Lazy.IAsyncLazySessionOperations.LoadStartingWithAsync(string idPrefix, string matches, int start, int pageSize, string exclude, string startAfter, CancellationToken token);
    private sealed virtual override Lazy`1<Task`1<ValueTuple`2<T, string>>> Raven.Client.Documents.Session.Operations.Lazy.IAsyncLazySessionOperations.ConditionalLoadAsync(string id, string changeVector, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentSession/<LoadAsync>d__52`1")]
public sealed virtual Task`1<T> LoadAsync(string id, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentSession/<LoadAsync>d__53`1")]
public sealed virtual Task`1<Dictionary`2<string, T>> LoadAsync(IEnumerable`1<string> ids, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentSession/<LoadAsync>d__54`1")]
public sealed virtual Task`1<T> LoadAsync(string id, Action`1<IIncludeBuilder`1<T>> includes, CancellationToken token);
    public sealed virtual Task`1<Dictionary`2<string, T>> LoadAsync(IEnumerable`1<string> ids, Action`1<IIncludeBuilder`1<T>> includes, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentSession/<LoadAsyncInternal>d__56`1")]
public sealed virtual Task`1<Dictionary`2<string, T>> LoadAsyncInternal(String[] ids, String[] includes, String[] counterIncludes, bool includeAllCounters, IEnumerable`1<AbstractTimeSeriesRange> timeSeriesIncludes, String[] compareExchangeValueIncludes, String[] revisionIncludesByChangeVector, Nullable`1<DateTime> revisionsToIncludeByDateTime, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentSession/<LoadStartingWithAsync>d__57`1")]
public sealed virtual Task`1<IEnumerable`1<T>> LoadStartingWithAsync(string idPrefix, string matches, int start, int pageSize, string exclude, string startAfter, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentSession/<LoadStartingWithIntoStreamAsync>d__58")]
public sealed virtual Task LoadStartingWithIntoStreamAsync(string idPrefix, Stream output, string matches, int start, int pageSize, string exclude, string startAfter, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentSession/<LoadIntoStreamAsync>d__59")]
public sealed virtual Task LoadIntoStreamAsync(IEnumerable`1<string> ids, Stream output, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentSession/<LoadStartingWithInternal>d__60")]
private Task LoadStartingWithInternal(string idPrefix, LoadStartingWithOperation operation, Stream stream, string matches, int start, int pageSize, string exclude, string startAfter, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentSession/<LoadAsyncInternal>d__61")]
private Task LoadAsyncInternal(String[] ids, Stream stream, LoadOperation operation, CancellationToken token);
    public sealed virtual IRavenQueryable`1<T> Query();
    public sealed virtual IRavenQueryable`1<T> Query(string indexName, string collectionName, bool isMapReduce);
    public sealed virtual IAsyncDocumentQuery`1<T> AsyncDocumentQuery();
    public sealed virtual IAsyncDocumentQuery`1<T> AsyncDocumentQuery(string indexName, string collectionName, bool isMapReduce);
    public sealed virtual RavenQueryInspector`1<S> CreateRavenQueryInspector();
    private sealed virtual override InMemoryDocumentSessionOperations Raven.Client.Documents.Linq.IDocumentQueryGenerator.get_Session();
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Linq.IDocumentQueryGenerator.Query(string indexName, string collectionName, bool isMapReduce);
    private sealed virtual override IAsyncDocumentQuery`1<T> Raven.Client.Documents.Linq.IDocumentQueryGenerator.AsyncQuery(string indexName, string collectionName, bool isMapReduce);
    public sealed virtual IAsyncRawDocumentQuery`1<T> AsyncRawQuery(string query);
    public sealed virtual Task`1<IAsyncEnumerator`1<StreamResult`1<T>>> StreamAsync(IAsyncRawDocumentQuery`1<T> query, CancellationToken token);
    public sealed virtual Task`1<IAsyncEnumerator`1<StreamResult`1<T>>> StreamAsync(IAsyncRawDocumentQuery`1<T> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
    public sealed virtual Task StreamIntoAsync(IAsyncRawDocumentQuery`1<T> query, Stream output, CancellationToken token);
    public sealed virtual Task`1<IAsyncEnumerator`1<StreamResult`1<T>>> StreamAsync(IAsyncDocumentQuery`1<T> query, CancellationToken token);
    public sealed virtual Task`1<IAsyncEnumerator`1<StreamResult`1<T>>> StreamAsync(IAsyncDocumentQuery`1<T> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
    public sealed virtual Task`1<IAsyncEnumerator`1<StreamResult`1<T>>> StreamAsync(IQueryable`1<T> query, CancellationToken token);
    public sealed virtual Task`1<IAsyncEnumerator`1<StreamResult`1<T>>> StreamAsync(IQueryable`1<T> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentSession/<StreamAsync>d__82`1")]
public sealed virtual Task`1<IAsyncEnumerator`1<StreamResult`1<T>>> StreamAsync(string startsWith, string matches, int start, int pageSize, string startAfter, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentSession/<StreamIntoAsync>d__83`1")]
public sealed virtual Task StreamIntoAsync(IAsyncDocumentQuery`1<T> query, Stream output, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentSession/<PerformQueryStreamOperation>d__84`1")]
private Task`1<IAsyncEnumerator`1<StreamResult`1<T>>> PerformQueryStreamOperation(IAsyncDocumentQuery`1<T> query, StreamQueryStatistics streamQueryStats, CancellationToken token);
    public sealed virtual IAsyncSessionDocumentTimeSeries TimeSeriesFor(string documentId, string name);
    public sealed virtual IAsyncSessionDocumentTimeSeries TimeSeriesFor(object entity, string name);
    public sealed virtual IAsyncSessionDocumentTypedTimeSeries`1<TValues> TimeSeriesFor(string documentId, string name);
    public sealed virtual IAsyncSessionDocumentTypedTimeSeries`1<TValues> TimeSeriesFor(object entity, string name);
    public sealed virtual IAsyncSessionDocumentRollupTypedTimeSeries`1<TValues> TimeSeriesRollupFor(object entity, string policy, string raw);
    public sealed virtual IAsyncSessionDocumentRollupTypedTimeSeries`1<TValues> TimeSeriesRollupFor(string documentId, string policy, string raw);
    public sealed virtual IAsyncSessionDocumentIncrementalTimeSeries IncrementalTimeSeriesFor(string documentId, string name);
    public sealed virtual IAsyncSessionDocumentIncrementalTimeSeries IncrementalTimeSeriesFor(object entity, string name);
    public sealed virtual IAsyncSessionDocumentTypedIncrementalTimeSeries`1<TValues> IncrementalTimeSeriesFor(string documentId, string name);
    public sealed virtual IAsyncSessionDocumentTypedIncrementalTimeSeries`1<TValues> IncrementalTimeSeriesFor(object entity, string name);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncDocumentSession/<TimeSeriesStreamInternalAsync>d__95`1")]
private Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<T>>> TimeSeriesStreamInternalAsync(IAsyncDocumentQuery`1<T> query, StreamQueryStatistics streamQueryStats, CancellationToken token);
    private Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<T>>> TimeSeriesStreamInternalAsync(IAsyncDocumentQuery`1<T> query, CancellationToken token);
    private Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<T>>> TimeSeriesStreamInternalAsync(IAsyncDocumentQuery`1<T> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
    private Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<T>>> TimeSeriesStreamInternalAsync(IQueryable`1<T> query, CancellationToken token);
    private Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<T>>> TimeSeriesStreamInternalAsync(IAsyncRawDocumentQuery`1<T> query, CancellationToken token);
    private Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<T>>> TimeSeriesStreamInternalAsync(IQueryable`1<T> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
    private Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<T>>> TimeSeriesStreamInternalAsync(IAsyncRawDocumentQuery`1<T> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
    private sealed virtual override Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult>>> Raven.Client.Documents.Session.IAsyncTimeSeriesSessionStreamOperations<Raven.Client.Documents.Queries.TimeSeries.TimeSeriesAggregationResult>.StreamAsync(IQueryable`1<TimeSeriesAggregationResult> query, CancellationToken token);
    private sealed virtual override Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult>>> Raven.Client.Documents.Session.IAsyncTimeSeriesSessionStreamOperations<Raven.Client.Documents.Queries.TimeSeries.TimeSeriesAggregationResult>.StreamAsync(IQueryable`1<TimeSeriesAggregationResult> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
    private sealed virtual override Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult>>> Raven.Client.Documents.Session.IAsyncTimeSeriesSessionStreamOperations<Raven.Client.Documents.Queries.TimeSeries.TimeSeriesAggregationResult>.StreamAsync(IAsyncDocumentQuery`1<TimeSeriesAggregationResult> query, CancellationToken token);
    private sealed virtual override Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult>>> Raven.Client.Documents.Session.IAsyncTimeSeriesSessionStreamOperations<Raven.Client.Documents.Queries.TimeSeries.TimeSeriesAggregationResult>.StreamAsync(IAsyncRawDocumentQuery`1<TimeSeriesAggregationResult> query, CancellationToken token);
    private sealed virtual override Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult>>> Raven.Client.Documents.Session.IAsyncTimeSeriesSessionStreamOperations<Raven.Client.Documents.Queries.TimeSeries.TimeSeriesAggregationResult>.StreamAsync(IAsyncRawDocumentQuery`1<TimeSeriesAggregationResult> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
    private sealed virtual override Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult>>> Raven.Client.Documents.Session.IAsyncTimeSeriesSessionStreamOperations<Raven.Client.Documents.Queries.TimeSeries.TimeSeriesAggregationResult>.StreamAsync(IAsyncDocumentQuery`1<TimeSeriesAggregationResult> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
    private sealed virtual override Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult>>> Raven.Client.Documents.Session.IAsyncTimeSeriesSessionStreamOperations<Raven.Client.Documents.Queries.TimeSeries.TimeSeriesRawResult>.StreamAsync(IQueryable`1<TimeSeriesRawResult> query, CancellationToken token);
    private sealed virtual override Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult>>> Raven.Client.Documents.Session.IAsyncTimeSeriesSessionStreamOperations<Raven.Client.Documents.Queries.TimeSeries.TimeSeriesRawResult>.StreamAsync(IQueryable`1<TimeSeriesRawResult> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
    private sealed virtual override Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult>>> Raven.Client.Documents.Session.IAsyncTimeSeriesSessionStreamOperations<Raven.Client.Documents.Queries.TimeSeries.TimeSeriesRawResult>.StreamAsync(IAsyncDocumentQuery`1<TimeSeriesRawResult> query, CancellationToken token);
    private sealed virtual override Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult>>> Raven.Client.Documents.Session.IAsyncTimeSeriesSessionStreamOperations<Raven.Client.Documents.Queries.TimeSeries.TimeSeriesRawResult>.StreamAsync(IAsyncRawDocumentQuery`1<TimeSeriesRawResult> query, CancellationToken token);
    private sealed virtual override Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult>>> Raven.Client.Documents.Session.IAsyncTimeSeriesSessionStreamOperations<Raven.Client.Documents.Queries.TimeSeries.TimeSeriesRawResult>.StreamAsync(IAsyncRawDocumentQuery`1<TimeSeriesRawResult> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
    private sealed virtual override Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult>>> Raven.Client.Documents.Session.IAsyncTimeSeriesSessionStreamOperations<Raven.Client.Documents.Queries.TimeSeries.TimeSeriesRawResult>.StreamAsync(IAsyncDocumentQuery`1<TimeSeriesRawResult> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
    private sealed virtual override Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult`1<T>>>> Raven.Client.Documents.Session.IAsyncTimeSeriesSessionStreamAggregationResultOperations.StreamAsync(IQueryable`1<TimeSeriesAggregationResult`1<T>> query, CancellationToken token);
    private sealed virtual override Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult`1<T>>>> Raven.Client.Documents.Session.IAsyncTimeSeriesSessionStreamAggregationResultOperations.StreamAsync(IQueryable`1<TimeSeriesAggregationResult`1<T>> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
    private sealed virtual override Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult`1<T>>>> Raven.Client.Documents.Session.IAsyncTimeSeriesSessionStreamAggregationResultOperations.StreamAsync(IAsyncDocumentQuery`1<TimeSeriesAggregationResult`1<T>> query, CancellationToken token);
    private sealed virtual override Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult`1<T>>>> Raven.Client.Documents.Session.IAsyncTimeSeriesSessionStreamAggregationResultOperations.StreamAsync(IAsyncRawDocumentQuery`1<TimeSeriesAggregationResult`1<T>> query, CancellationToken token);
    private sealed virtual override Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult`1<T>>>> Raven.Client.Documents.Session.IAsyncTimeSeriesSessionStreamAggregationResultOperations.StreamAsync(IAsyncRawDocumentQuery`1<TimeSeriesAggregationResult`1<T>> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
    private sealed virtual override Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult`1<T>>>> Raven.Client.Documents.Session.IAsyncTimeSeriesSessionStreamAggregationResultOperations.StreamAsync(IAsyncDocumentQuery`1<TimeSeriesAggregationResult`1<T>> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
    private sealed virtual override Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult`1<T>>>> Raven.Client.Documents.Session.IAsyncTimeSeriesSessionStreamRawResultOperations.StreamAsync(IQueryable`1<TimeSeriesRawResult`1<T>> query, CancellationToken token);
    private sealed virtual override Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult`1<T>>>> Raven.Client.Documents.Session.IAsyncTimeSeriesSessionStreamRawResultOperations.StreamAsync(IQueryable`1<TimeSeriesRawResult`1<T>> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
    private sealed virtual override Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult`1<T>>>> Raven.Client.Documents.Session.IAsyncTimeSeriesSessionStreamRawResultOperations.StreamAsync(IAsyncDocumentQuery`1<TimeSeriesRawResult`1<T>> query, CancellationToken token);
    private sealed virtual override Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult`1<T>>>> Raven.Client.Documents.Session.IAsyncTimeSeriesSessionStreamRawResultOperations.StreamAsync(IAsyncRawDocumentQuery`1<TimeSeriesRawResult`1<T>> query, CancellationToken token);
    private sealed virtual override Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult`1<T>>>> Raven.Client.Documents.Session.IAsyncTimeSeriesSessionStreamRawResultOperations.StreamAsync(IAsyncRawDocumentQuery`1<TimeSeriesRawResult`1<T>> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
    private sealed virtual override Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult`1<T>>>> Raven.Client.Documents.Session.IAsyncTimeSeriesSessionStreamRawResultOperations.StreamAsync(IAsyncDocumentQuery`1<TimeSeriesRawResult`1<T>> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
}
public class Raven.Client.Documents.Session.AsyncGroupByDocumentQuery`1 : object {
    private AsyncDocumentQuery`1<T> _query;
    public AsyncGroupByDocumentQuery`1(AsyncDocumentQuery`1<T> query);
    public sealed virtual IAsyncGroupByDocumentQuery`1<T> SelectKey(string fieldName, string projectedName);
    public sealed virtual IAsyncDocumentQuery`1<T> SelectSum(GroupByField field, GroupByField[] fields);
    public sealed virtual IAsyncDocumentQuery`1<T> SelectCount(string projectedName);
    public sealed virtual IAsyncGroupByDocumentQuery`1<T> Filter(Action`1<IFilterFactory`1<T>> builder, int limit);
}
public class Raven.Client.Documents.Session.AsyncSessionDocumentCounters : SessionCountersBase {
    public AsyncSessionDocumentCounters(InMemoryDocumentSessionOperations session, string documentId);
    public AsyncSessionDocumentCounters(InMemoryDocumentSessionOperations session, object entity);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncSessionDocumentCounters/<GetAsync>d__2")]
public sealed virtual Task`1<Nullable`1<long>> GetAsync(string counter, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncSessionDocumentCounters/<GetAsync>d__3")]
public sealed virtual Task`1<Dictionary`2<string, Nullable`1<long>>> GetAsync(IEnumerable`1<string> counters, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncSessionDocumentCounters/<GetAllAsync>d__4")]
public sealed virtual Task`1<Dictionary`2<string, Nullable`1<long>>> GetAllAsync(CancellationToken token);
}
public class Raven.Client.Documents.Session.AsyncSessionDocumentTimeSeries`1 : SessionTimeSeriesBase {
    public AsyncSessionDocumentTimeSeries`1(InMemoryDocumentSessionOperations session, string documentId, string name);
    public AsyncSessionDocumentTimeSeries`1(InMemoryDocumentSessionOperations session, object entity, string name);
    public sealed virtual Task`1<TimeSeriesEntry[]> GetAsync(Nullable`1<DateTime> from, Nullable`1<DateTime> to, int start, int pageSize, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncSessionDocumentTimeSeries`1/<GetAsync>d__3")]
public sealed virtual Task`1<TimeSeriesEntry[]> GetAsync(Nullable`1<DateTime> from, Nullable`1<DateTime> to, Action`1<ITimeSeriesIncludeBuilder> includes, int start, int pageSize, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncSessionDocumentTimeSeries`1/<GetTypedFromCache>d__4`1")]
internal Task`1<TimeSeriesEntry`1[]> GetTypedFromCache(Nullable`1<DateTime> from, Nullable`1<DateTime> to, Action`1<ITimeSeriesIncludeBuilder> includes, int start, int pageSize, CancellationToken token);
    internal bool NotInCache(Nullable`1<DateTime> from, Nullable`1<DateTime> to);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncSessionDocumentTimeSeries`1/<GetTimeSeriesAndIncludes>d__6`1")]
internal Task`1<TTValues[]> GetTimeSeriesAndIncludes(Nullable`1<DateTime> from, Nullable`1<DateTime> to, Action`1<ITimeSeriesIncludeBuilder> includes, int start, int pageSize, CancellationToken token);
    private void HandleIncludes(TimeSeriesRangeResult rangeResult);
    private static IEnumerable`1<TimeSeriesEntry> SkipAndTrimRangeIfNeeded(DateTime from, DateTime to, TimeSeriesRangeResult fromRange, TimeSeriesRangeResult toRange, List`1<TimeSeriesEntry> values, int skip, int trim);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncSessionDocumentTimeSeries`1/<ServeFromCache>d__9")]
private Task`1<IEnumerable`1<TimeSeriesEntry>> ServeFromCache(DateTime from, DateTime to, int start, int pageSize, Action`1<ITimeSeriesIncludeBuilder> includes, CancellationToken token);
    private void RegisterIncludes(TimeSeriesDetails details);
    private static TimeSeriesEntry[] MergeRangesWithResults(DateTime from, DateTime to, List`1<TimeSeriesRangeResult> ranges, int fromRangeIndex, int toRangeIndex, List`1<TimeSeriesRangeResult> resultFromServer, IEnumerable`1& resultToUser);
    [IteratorStateMachineAttribute("Raven.Client.Documents.Session.AsyncSessionDocumentTimeSeries`1/<ChopRelevantRange>d__12")]
private static IEnumerable`1<TimeSeriesEntry> ChopRelevantRange(TimeSeriesRangeResult range, DateTime from, DateTime to, int start, int pageSize);
    private Task`1<TimeSeriesEntry`1[]> GetAsyncInternal(Nullable`1<DateTime> from, Nullable`1<DateTime> to, int start, int pageSize, CancellationToken token);
    private sealed virtual override Task`1<TimeSeriesEntry`1[]> Raven.Client.Documents.Session.IAsyncSessionDocumentTypedTimeSeries<TValues>.GetAsync(Nullable`1<DateTime> from, Nullable`1<DateTime> to, int start, int pageSize, CancellationToken token);
    private sealed virtual override Task`1<TimeSeriesEntry`1[]> Raven.Client.Documents.Session.IAsyncSessionDocumentTypedIncrementalTimeSeries<TValues>.GetAsync(Nullable`1<DateTime> from, Nullable`1<DateTime> to, int start, int pageSize, CancellationToken token);
    private sealed virtual override void Raven.Client.Documents.Session.ISessionDocumentTypedAppendTimeSeriesBase<TValues>.Append(DateTime timestamp, TValues entry, string tag);
    public sealed virtual void Append(TimeSeriesEntry`1<TValues> entry);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncSessionDocumentTimeSeries`1/<Raven-Client-Documents-Session-IAsyncSessionDocumentRollupTypedTimeSeries<TValues>-GetAsync>d__18")]
private sealed virtual override Task`1<TimeSeriesRollupEntry`1[]> Raven.Client.Documents.Session.IAsyncSessionDocumentRollupTypedTimeSeries<TValues>.GetAsync(Nullable`1<DateTime> from, Nullable`1<DateTime> to, int start, int pageSize, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncSessionDocumentTimeSeries`1/<GetTimeSeriesStreamResult>d__19`1")]
internal Task`1<TimeSeriesStreamEnumerator`1<TTValues>> GetTimeSeriesStreamResult(Nullable`1<DateTime> from, Nullable`1<DateTime> to, Nullable`1<TimeSpan> offset, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncSessionDocumentTimeSeries`1/<GetAsyncStream>d__20`1")]
internal Task`1<IAsyncEnumerator`1<TTValues>> GetAsyncStream(Nullable`1<DateTime> from, Nullable`1<DateTime> to, Nullable`1<TimeSpan> offset, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.AsyncSessionDocumentTimeSeries`1/<GetStream>d__21`1")]
internal Task`1<IEnumerator`1<TTValues>> GetStream(Nullable`1<DateTime> from, Nullable`1<DateTime> to, Nullable`1<TimeSpan> offset);
    private sealed virtual override Task`1<IAsyncEnumerator`1<TimeSeriesEntry>> Raven.Client.Documents.Session.IAsyncTimeSeriesStreamingBase<Raven.Client.Documents.Session.TimeSeries.TimeSeriesEntry>.StreamAsync(Nullable`1<DateTime> from, Nullable`1<DateTime> to, Nullable`1<TimeSpan> offset, CancellationToken token);
    private sealed virtual override Task`1<IAsyncEnumerator`1<TimeSeriesRollupEntry`1<TValues>>> Raven.Client.Documents.Session.IAsyncTimeSeriesStreamingBase<Raven.Client.Documents.Session.TimeSeries.TimeSeriesRollupEntry<TValues>>.StreamAsync(Nullable`1<DateTime> from, Nullable`1<DateTime> to, Nullable`1<TimeSpan> offset, CancellationToken token);
    private sealed virtual override Task`1<IAsyncEnumerator`1<TimeSeriesEntry`1<TValues>>> Raven.Client.Documents.Session.IAsyncTimeSeriesStreamingBase<Raven.Client.Documents.Session.TimeSeries.TimeSeriesEntry<TValues>>.StreamAsync(Nullable`1<DateTime> from, Nullable`1<DateTime> to, Nullable`1<TimeSpan> offset, CancellationToken token);
}
[IsReadOnlyAttribute]
internal class Raven.Client.Documents.Session.AsyncTaskHolder : ValueType {
    private InMemoryDocumentSessionOperations _session;
    public AsyncTaskHolder(InMemoryDocumentSessionOperations session);
    public sealed virtual void Dispose();
}
public class Raven.Client.Documents.Session.BeforeConversionToDocumentEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Entity>k__BackingField;
    [CompilerGeneratedAttribute]
private InMemoryDocumentSessionOperations <Session>k__BackingField;
    public string Id { get; }
    public object Entity { get; }
    public InMemoryDocumentSessionOperations Session { get; }
    public BeforeConversionToDocumentEventArgs(InMemoryDocumentSessionOperations session, string id, object entity);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public object get_Entity();
    [CompilerGeneratedAttribute]
public InMemoryDocumentSessionOperations get_Session();
}
public class Raven.Client.Documents.Session.BeforeConversionToEntityEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private InMemoryDocumentSessionOperations <Session>k__BackingField;
    public string Id { get; }
    public Type Type { get; }
    public BlittableJsonReaderObject Document { get; public set; }
    public InMemoryDocumentSessionOperations Session { get; }
    internal BeforeConversionToEntityEventArgs(InMemoryDocumentSessionOperations session, string id, Type type, BlittableJsonReaderObject document);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_Document();
    [CompilerGeneratedAttribute]
public void set_Document(BlittableJsonReaderObject value);
    [CompilerGeneratedAttribute]
public InMemoryDocumentSessionOperations get_Session();
}
public class Raven.Client.Documents.Session.BeforeDeleteEventArgs : EventArgs {
    private IMetadataDictionary _documentMetadata;
    [CompilerGeneratedAttribute]
private InMemoryDocumentSessionOperations <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Entity>k__BackingField;
    public InMemoryDocumentSessionOperations Session { get; }
    public string DocumentId { get; }
    public object Entity { get; }
    public IMetadataDictionary DocumentMetadata { get; }
    public BeforeDeleteEventArgs(InMemoryDocumentSessionOperations session, string documentId, object entity);
    [CompilerGeneratedAttribute]
public InMemoryDocumentSessionOperations get_Session();
    [CompilerGeneratedAttribute]
public string get_DocumentId();
    [CompilerGeneratedAttribute]
public object get_Entity();
    public IMetadataDictionary get_DocumentMetadata();
}
public class Raven.Client.Documents.Session.BeforeQueryEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private InMemoryDocumentSessionOperations <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private IDocumentQueryCustomization <QueryCustomization>k__BackingField;
    public InMemoryDocumentSessionOperations Session { get; }
    public IDocumentQueryCustomization QueryCustomization { get; }
    public BeforeQueryEventArgs(InMemoryDocumentSessionOperations session, IDocumentQueryCustomization queryCustomization);
    [CompilerGeneratedAttribute]
public InMemoryDocumentSessionOperations get_Session();
    [CompilerGeneratedAttribute]
public IDocumentQueryCustomization get_QueryCustomization();
}
public class Raven.Client.Documents.Session.BeforeRequestEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpRequestMessage <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AttemptNumber>k__BackingField;
    public string Database { get; }
    public string Url { get; }
    public HttpRequestMessage Request { get; }
    public int AttemptNumber { get; }
    internal BeforeRequestEventArgs(string database, string url, HttpRequestMessage request, int attemptNumber);
    [CompilerGeneratedAttribute]
public string get_Database();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public HttpRequestMessage get_Request();
    [CompilerGeneratedAttribute]
public int get_AttemptNumber();
}
public class Raven.Client.Documents.Session.BeforeStoreEventArgs : EventArgs {
    private IMetadataDictionary _documentMetadata;
    [CompilerGeneratedAttribute]
private InMemoryDocumentSessionOperations <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Entity>k__BackingField;
    public InMemoryDocumentSessionOperations Session { get; }
    public string DocumentId { get; }
    public object Entity { get; }
    internal bool MetadataAccessed { get; }
    public IMetadataDictionary DocumentMetadata { get; }
    public BeforeStoreEventArgs(InMemoryDocumentSessionOperations session, string documentId, object entity);
    [CompilerGeneratedAttribute]
public InMemoryDocumentSessionOperations get_Session();
    [CompilerGeneratedAttribute]
public string get_DocumentId();
    [CompilerGeneratedAttribute]
public object get_Entity();
    internal bool get_MetadataAccessed();
    public IMetadataDictionary get_DocumentMetadata();
}
public class Raven.Client.Documents.Session.BulkInsertOnProgressEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private BulkInsertProgress <Progress>k__BackingField;
    public BulkInsertProgress Progress { get; }
    internal BulkInsertOnProgressEventArgs(BulkInsertProgress progress);
    [CompilerGeneratedAttribute]
public BulkInsertProgress get_Progress();
}
public class Raven.Client.Documents.Session.ClusterTransactionOperations : ClusterTransactionOperationsBase`1<DocumentSession> {
    private ILazyClusterTransactionOperations Raven.Client.Documents.Session.IClusterTransactionOperations.Lazily { get; }
    public ClusterTransactionOperations(DocumentSession session);
    private sealed virtual override ILazyClusterTransactionOperations Raven.Client.Documents.Session.IClusterTransactionOperations.get_Lazily();
    private sealed virtual override CompareExchangeValue`1<T> Raven.Client.Documents.Session.IClusterTransactionOperations.GetCompareExchangeValue(string key);
    private sealed virtual override Lazy`1<CompareExchangeValue`1<T>> Raven.Client.Documents.Session.ILazyClusterTransactionOperations.GetCompareExchangeValue(string key);
    private sealed virtual override Lazy`1<CompareExchangeValue`1<T>> Raven.Client.Documents.Session.ILazyClusterTransactionOperations.GetCompareExchangeValue(string key, Action`1<CompareExchangeValue`1<T>> onEval);
    private sealed virtual override Dictionary`2<string, CompareExchangeValue`1<T>> Raven.Client.Documents.Session.IClusterTransactionOperations.GetCompareExchangeValues(String[] keys);
    private sealed virtual override Lazy`1<Dictionary`2<string, CompareExchangeValue`1<T>>> Raven.Client.Documents.Session.ILazyClusterTransactionOperations.GetCompareExchangeValues(String[] keys);
    private sealed virtual override Dictionary`2<string, CompareExchangeValue`1<T>> Raven.Client.Documents.Session.IClusterTransactionOperations.GetCompareExchangeValues(string startsWith, int start, int pageSize);
    private sealed virtual override Lazy`1<Dictionary`2<string, CompareExchangeValue`1<T>>> Raven.Client.Documents.Session.ILazyClusterTransactionOperations.GetCompareExchangeValues(String[] keys, Action`1<Dictionary`2<string, CompareExchangeValue`1<T>>> onEval);
}
public class Raven.Client.Documents.Session.ClusterTransactionOperationsAsync : ClusterTransactionOperationsBase`1<AsyncDocumentSession> {
    private ILazyClusterTransactionOperationsAsync Raven.Client.Documents.Session.IClusterTransactionOperationsAsync.Lazily { get; }
    public ClusterTransactionOperationsAsync(AsyncDocumentSession session);
    private sealed virtual override ILazyClusterTransactionOperationsAsync Raven.Client.Documents.Session.IClusterTransactionOperationsAsync.get_Lazily();
    private sealed virtual override Lazy`1<Task`1<CompareExchangeValue`1<T>>> Raven.Client.Documents.Session.ILazyClusterTransactionOperationsAsync.GetCompareExchangeValueAsync(string key, CancellationToken token);
    private sealed virtual override Task`1<CompareExchangeValue`1<T>> Raven.Client.Documents.Session.IClusterTransactionOperationsAsync.GetCompareExchangeValueAsync(string key, CancellationToken token);
    private sealed virtual override Task`1<Dictionary`2<string, CompareExchangeValue`1<T>>> Raven.Client.Documents.Session.IClusterTransactionOperationsAsync.GetCompareExchangeValuesAsync(string startsWith, int start, int pageSize, CancellationToken token);
    private sealed virtual override Lazy`1<Task`1<CompareExchangeValue`1<T>>> Raven.Client.Documents.Session.ILazyClusterTransactionOperationsAsync.GetCompareExchangeValueAsync(string key, Action`1<CompareExchangeValue`1<T>> onEval, CancellationToken token);
    private sealed virtual override Lazy`1<Task`1<Dictionary`2<string, CompareExchangeValue`1<T>>>> Raven.Client.Documents.Session.ILazyClusterTransactionOperationsAsync.GetCompareExchangeValuesAsync(String[] keys, CancellationToken token);
    private sealed virtual override Task`1<Dictionary`2<string, CompareExchangeValue`1<T>>> Raven.Client.Documents.Session.IClusterTransactionOperationsAsync.GetCompareExchangeValuesAsync(String[] keys, CancellationToken token);
    private sealed virtual override Lazy`1<Task`1<Dictionary`2<string, CompareExchangeValue`1<T>>>> Raven.Client.Documents.Session.ILazyClusterTransactionOperationsAsync.GetCompareExchangeValuesAsync(String[] keys, Action`1<Dictionary`2<string, CompareExchangeValue`1<T>>> onEval, CancellationToken token);
}
public abstract class Raven.Client.Documents.Session.ClusterTransactionOperationsBase : object {
    internal InMemoryDocumentSessionOperations _session;
    private Dictionary`2<string, CompareExchangeSessionValue> _state;
    private Dictionary`2<string, CompareExchangeValue`1<BlittableJsonReaderObject>> _compareExchangeIncludes;
    private Dictionary`2<string, string> _missingDocumentsToAtomicGuardIndex;
    internal int NumberOfTrackedCompareExchangeValues { get; }
    protected ClusterTransactionOperationsBase(InMemoryDocumentSessionOperations session);
    internal bool TryGetMissingAtomicGuardFor(string docId, String& changeVector);
    internal int get_NumberOfTrackedCompareExchangeValues();
    internal bool IsTracked(string key);
    public sealed virtual CompareExchangeValue`1<T> CreateCompareExchangeValue(string key, T item);
    public sealed virtual void DeleteCompareExchangeValue(CompareExchangeValue`1<T> item);
    public sealed virtual void DeleteCompareExchangeValue(string key, long index);
    public void Clear();
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.ClusterTransactionOperationsBase/<GetCompareExchangeValueAsyncInternal>d__13`1")]
protected Task`1<CompareExchangeValue`1<T>> GetCompareExchangeValueAsyncInternal(string key, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.ClusterTransactionOperationsBase/<GetCompareExchangeValuesAsyncInternal>d__14`1")]
protected Task`1<Dictionary`2<string, CompareExchangeValue`1<T>>> GetCompareExchangeValuesAsyncInternal(String[] keys, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.ClusterTransactionOperationsBase/<GetCompareExchangeValuesAsyncInternal>d__15`1")]
protected Task`1<Dictionary`2<string, CompareExchangeValue`1<T>>> GetCompareExchangeValuesAsyncInternal(string startsWith, int start, int pageSize, CancellationToken token);
    internal CompareExchangeValue`1<T> GetCompareExchangeValueFromSessionInternal(string key, Boolean& notTracked);
    internal Dictionary`2<string, CompareExchangeValue`1<T>> GetCompareExchangeValuesFromSessionInternal(String[] keys, HashSet`1& notTrackedKeys);
    internal CompareExchangeSessionValue RegisterMissingCompareExchangeValue(string key);
    internal void RegisterCompareExchangeIncludes(BlittableJsonReaderObject values, bool includingMissingAtomicGuards);
    internal CompareExchangeSessionValue RegisterCompareExchangeValue(CompareExchangeValue`1<BlittableJsonReaderObject> value);
    internal void RegisterCompareExchangeInclude(CompareExchangeValue`1<BlittableJsonReaderObject> value);
    private void RegisterMissingCompareExchangeInclude(string key);
    private static void AssertNotAtomicGuard(CompareExchangeValue`1<BlittableJsonReaderObject> value);
    private static void AssertNotAtomicGuard(string key);
    private bool TryGetCompareExchangeValueFromSession(string key, CompareExchangeSessionValue& value);
    internal void PrepareCompareExchangeEntities(SaveChangesData result);
    internal void UpdateState(string key, long index);
}
public abstract class Raven.Client.Documents.Session.ClusterTransactionOperationsBase`1 : ClusterTransactionOperationsBase {
    [CompilerGeneratedAttribute]
private TSession <Session>k__BackingField;
    protected TSession Session { get; }
    protected ClusterTransactionOperationsBase`1(TSession session);
    [CompilerGeneratedAttribute]
protected TSession get_Session();
}
public class Raven.Client.Documents.Session.CmpXchg : MethodCall {
    public static CmpXchg Value(string key);
}
public enum Raven.Client.Documents.Session.ConcurrencyCheckMode : Enum {
    public int value__;
    public static ConcurrencyCheckMode Auto;
    public static ConcurrencyCheckMode Forced;
    public static ConcurrencyCheckMode Disabled;
}
internal class Raven.Client.Documents.Session.DeletedEntitiesHolder : object {
    private HashSet`1<object> _deletedEntities;
    private HashSet`1<object> _onBeforeDeletedEntities;
    private bool _prepareEntitiesDeletes;
    public int Count { get; }
    public int get_Count();
    public void Add(object entity);
    public void Remove(object entity);
    public void Evict(object entity);
    public bool Contains(object entity);
    public void Clear();
    [IteratorStateMachineAttribute("Raven.Client.Documents.Session.DeletedEntitiesHolder/<GetEnumerator>d__10")]
public IEnumerator`1<DeletedEntitiesEnumeratorResult> GetEnumerator();
    public IDisposable PrepareEntitiesDeletes();
    [CompilerGeneratedAttribute]
private void <PrepareEntitiesDeletes>b__11_0();
}
public class Raven.Client.Documents.Session.DocumentInfo : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrencyCheckMode <ConcurrencyCheckMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreChanges>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataDictionary <MetadataInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Entity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNewDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Collection>k__BackingField;
    public string Id { get; public set; }
    public string ChangeVector { get; public set; }
    public ConcurrencyCheckMode ConcurrencyCheckMode { get; public set; }
    public bool IgnoreChanges { get; public set; }
    public BlittableJsonReaderObject Metadata { get; public set; }
    public BlittableJsonReaderObject Document { get; public set; }
    public IMetadataDictionary MetadataInstance { get; public set; }
    public object Entity { get; public set; }
    public bool IsNewDocument { get; public set; }
    public string Collection { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_ChangeVector();
    [CompilerGeneratedAttribute]
public void set_ChangeVector(string value);
    [CompilerGeneratedAttribute]
public ConcurrencyCheckMode get_ConcurrencyCheckMode();
    [CompilerGeneratedAttribute]
public void set_ConcurrencyCheckMode(ConcurrencyCheckMode value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreChanges();
    [CompilerGeneratedAttribute]
public void set_IgnoreChanges(bool value);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(BlittableJsonReaderObject value);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_Document();
    [CompilerGeneratedAttribute]
public void set_Document(BlittableJsonReaderObject value);
    [CompilerGeneratedAttribute]
public IMetadataDictionary get_MetadataInstance();
    [CompilerGeneratedAttribute]
public void set_MetadataInstance(IMetadataDictionary value);
    [CompilerGeneratedAttribute]
public object get_Entity();
    [CompilerGeneratedAttribute]
public void set_Entity(object value);
    [CompilerGeneratedAttribute]
public bool get_IsNewDocument();
    [CompilerGeneratedAttribute]
public void set_IsNewDocument(bool value);
    [CompilerGeneratedAttribute]
public string get_Collection();
    [CompilerGeneratedAttribute]
public void set_Collection(string value);
    public DateTime GetLastModified();
    public static DocumentInfo GetNewDocumentInfo(BlittableJsonReaderObject document);
    public sealed virtual void Dispose();
}
public class Raven.Client.Documents.Session.DocumentQuery`1 : AbstractDocumentQuery`2<T, DocumentQuery`1<T>> {
    private IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.Not { get; }
    private InMemoryDocumentSessionOperations Raven.Client.Documents.Linq.IDocumentQueryGenerator.Session { get; }
    public DocumentQuery`1(InMemoryDocumentSessionOperations session, string indexName, string collectionName, bool isGroupBy, IEnumerable`1<DeclareToken> declareTokens, List`1<LoadToken> loadTokens, string fromAlias, Nullable`1<bool> isProjectInto);
    public sealed virtual IDocumentQuery`1<TProjection> SelectFields();
    public sealed virtual IDocumentQuery`1<TProjection> SelectFields(ProjectionBehavior projectionBehavior);
    private sealed virtual override IDocumentQuery`1<TTimeSeries> Raven.Client.Documents.Session.IDocumentQuery<T>.SelectTimeSeries(Func`2<ITimeSeriesQueryBuilder, TTimeSeries> timeSeriesQuery);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.Distinct();
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByScore();
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByScoreDescending();
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.IncludeExplanations(Explanations& explanations);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.IncludeExplanations(ExplanationOptions options, Explanations& explanations);
    private sealed virtual override IRawDocumentQuery`1<T> Raven.Client.Documents.Session.IRawDocumentQuery<T>.Projection(ProjectionBehavior projectionBehavior);
    public sealed virtual IDocumentQuery`1<TProjection> SelectFields(String[] fields);
    public sealed virtual IDocumentQuery`1<TProjection> SelectFields(ProjectionBehavior projectionBehavior, String[] fields);
    public sealed virtual IDocumentQuery`1<TProjection> SelectFields(QueryData queryData);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WaitForNonStaleResults(Nullable`1<TimeSpan> waitTimeout);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.AddParameter(string name, object value);
    private sealed virtual override IRawDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IRawDocumentQuery<T>>.AddParameter(string name, object value);
    private sealed virtual override IRawDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IRawDocumentQuery<T>>.WaitForNonStaleResults(Nullable`1<TimeSpan> waitTimeout);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.AddOrder(string fieldName, bool descending, OrderingType ordering);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.AddOrder(Expression`1<Func`2<T, TValue>> propertySelector, bool descending, OrderingType ordering);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.AfterQueryExecuted(Action`1<QueryResult> action);
    private sealed virtual override IRawDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IRawDocumentQuery<T>>.AfterQueryExecuted(Action`1<QueryResult> action);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.AfterStreamExecuted(Action`1<BlittableJsonReaderObject> action);
    private sealed virtual override IRawDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IRawDocumentQuery<T>>.AfterStreamExecuted(Action`1<BlittableJsonReaderObject> action);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OpenSubclause();
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.CloseSubclause();
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.NegateNext();
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.Search(string fieldName, string searchTerms, SearchOperator operator);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.Search(Expression`1<Func`2<T, TValue>> propertySelector, string searchTerms, SearchOperator operator);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.Intersect();
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.ContainsAll(Expression`1<Func`2<T, IEnumerable`1<TValue>>> propertySelector, IEnumerable`1<TValue> values);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.ContainsAny(string fieldName, IEnumerable`1<object> values);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.ContainsAny(Expression`1<Func`2<T, TValue>> propertySelector, IEnumerable`1<TValue> values);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.ContainsAny(Expression`1<Func`2<T, IEnumerable`1<TValue>>> propertySelector, IEnumerable`1<TValue> values);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.ContainsAll(string fieldName, IEnumerable`1<object> values);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.ContainsAll(Expression`1<Func`2<T, TValue>> propertySelector, IEnumerable`1<TValue> values);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.Statistics(QueryStatistics& stats);
    private sealed virtual override IRawDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IRawDocumentQuery<T>>.Statistics(QueryStatistics& stats);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.UsingDefaultOperator(QueryOperator queryOperator);
    private sealed virtual override IRawDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IRawDocumentQuery<T>>.UsingDefaultOperator(QueryOperator queryOperator);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.NoTracking();
    private sealed virtual override IRawDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IRawDocumentQuery<T>>.NoTracking();
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.NoCaching();
    private sealed virtual override IRawDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IRawDocumentQuery<T>>.NoCaching();
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.Timings(QueryTimings& timings);
    private sealed virtual override IRawDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IRawDocumentQuery<T>>.Timings(QueryTimings& timings);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.Include(string path);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.Include(Expression`1<Func`2<T, object>> path);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.get_Not();
    public sealed virtual QueryResult GetQueryResult();
    private sealed virtual override IRawDocumentQuery`1<T> Raven.Client.Documents.Session.IPagingDocumentQueryBase<T,Raven.Client.Documents.Session.IRawDocumentQuery<T>>.Skip(long count);
    private sealed virtual override IRawDocumentQuery`1<T> Raven.Client.Documents.Session.IPagingDocumentQueryBase<T,Raven.Client.Documents.Session.IRawDocumentQuery<T>>.Take(long count);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IPagingDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.Take(long count);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IPagingDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.Skip(long count);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereLucene(string fieldName, string whereClause);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereLucene(string fieldName, string whereClause, bool exact);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereEquals(string fieldName, object value, bool exact);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereEquals(string fieldName, MethodCall value, bool exact);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereEquals(Expression`1<Func`2<T, TValue>> propertySelector, TValue value, bool exact);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereEquals(Expression`1<Func`2<T, TValue>> propertySelector, MethodCall value, bool exact);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereEquals(WhereParams whereParams);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereNotEquals(string fieldName, object value, bool exact);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereNotEquals(string fieldName, MethodCall value, bool exact);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereNotEquals(Expression`1<Func`2<T, TValue>> propertySelector, TValue value, bool exact);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereNotEquals(Expression`1<Func`2<T, TValue>> propertySelector, MethodCall value, bool exact);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereNotEquals(WhereParams whereParams);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereIn(string fieldName, IEnumerable`1<object> values, bool exact);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereIn(Expression`1<Func`2<T, TValue>> propertySelector, IEnumerable`1<TValue> values, bool exact);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereStartsWith(string fieldName, object value);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereStartsWith(string fieldName, object value, bool exact);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereStartsWith(Expression`1<Func`2<T, TValue>> propertySelector, TValue value);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereStartsWith(Expression`1<Func`2<T, TValue>> propertySelector, TValue value, bool exact);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereEndsWith(string fieldName, object value);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereEndsWith(string fieldName, object value, bool exact);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereEndsWith(Expression`1<Func`2<T, TValue>> propertySelector, TValue value);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereEndsWith(Expression`1<Func`2<T, TValue>> propertySelector, TValue value, bool exact);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereBetween(string fieldName, object start, object end, bool exact);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereBetween(Expression`1<Func`2<T, TValue>> propertySelector, TValue start, TValue end, bool exact);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereGreaterThan(string fieldName, object value, bool exact);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereGreaterThan(Expression`1<Func`2<T, TValue>> propertySelector, TValue value, bool exact);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereGreaterThanOrEqual(string fieldName, object value, bool exact);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereGreaterThanOrEqual(Expression`1<Func`2<T, TValue>> propertySelector, TValue value, bool exact);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereLessThan(string fieldName, object value, bool exact);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereLessThan(Expression`1<Func`2<T, TValue>> propertySelector, TValue value, bool exact);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereLessThanOrEqual(string fieldName, object value, bool exact);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereLessThanOrEqual(Expression`1<Func`2<T, TValue>> propertySelector, TValue value, bool exact);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereExists(Expression`1<Func`2<T, TValue>> propertySelector);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereExists(string fieldName);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereRegex(Expression`1<Func`2<T, TValue>> propertySelector, string pattern);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WhereRegex(string fieldName, string pattern);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.AndAlso();
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.AndAlso(bool wrapPreviousQueryClauses);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrElse();
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.Boost(decimal boost);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.Fuzzy(decimal fuzzy);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.Proximity(int proximity);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.RandomOrdering();
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.RandomOrdering(string seed);
    private sealed virtual override IGroupByDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQuery<T>.GroupBy(string fieldName, String[] fieldNames);
    private sealed virtual override IGroupByDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQuery<T>.GroupBy(ValueTuple`2<string, GroupByMethod> field, ValueTuple`2[] fields);
    private sealed virtual override IDocumentQuery`1<TResult> Raven.Client.Documents.Session.IDocumentQuery<T>.OfType();
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderBy(string field, string sorterName);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderBy(string field, OrderingType ordering);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderBy(Expression`1<Func`2<T, TValue>> propertySelector);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderBy(Expression`1<Func`2<T, TValue>> propertySelector, string sorterName);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderBy(Expression`1<Func`2<T, TValue>> propertySelector, OrderingType ordering);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderBy(Expression`1[] propertySelectors);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDescending(string field, string sorterName);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDescending(string field, OrderingType ordering);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDescending(Expression`1<Func`2<T, TValue>> propertySelector);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDescending(Expression`1<Func`2<T, TValue>> propertySelector, string sorterName);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDescending(Expression`1<Func`2<T, TValue>> propertySelector, OrderingType ordering);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDescending(Expression`1[] propertySelectors);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.BeforeQueryExecuted(Action`1<IndexQuery> beforeQueryExecuted);
    private sealed virtual override IRawDocumentQuery`1<T> Raven.Client.Documents.Session.IQueryBase<T,Raven.Client.Documents.Session.IRawDocumentQuery<T>>.BeforeQueryExecuted(Action`1<IndexQuery> beforeQueryExecuted);
    private sealed virtual override T Raven.Client.Documents.Session.IDocumentQueryBase<T>.First();
    private sealed virtual override T Raven.Client.Documents.Session.IDocumentQueryBase<T>.FirstOrDefault();
    private sealed virtual override T Raven.Client.Documents.Session.IDocumentQueryBase<T>.Single();
    private sealed virtual override T Raven.Client.Documents.Session.IDocumentQueryBase<T>.SingleOrDefault();
    private sealed virtual override bool Raven.Client.Documents.Session.IDocumentQueryBase<T>.Any();
    private List`1<T> ExecuteQueryOperation(Nullable`1<long> take);
    private T[] ExecuteQueryOperationAsArray(Nullable`1<long> take);
    private void ExecuteQueryOperationInternal(Nullable`1<long> take);
    private sealed virtual override int Raven.Client.Documents.Session.IDocumentQueryBase<T>.Count();
    private sealed virtual override long Raven.Client.Documents.Session.IDocumentQueryBase<T>.LongCount();
    private sealed virtual override Lazy`1<int> Raven.Client.Documents.Session.IDocumentQueryBase<T>.CountLazily();
    private sealed virtual override Lazy`1<long> Raven.Client.Documents.Session.IDocumentQueryBase<T>.LongCountLazily();
    private sealed virtual override List`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T>.ToList();
    private sealed virtual override T[] Raven.Client.Documents.Session.IDocumentQueryBase<T>.ToArray();
    private sealed virtual override Lazy`1<IEnumerable`1<T>> Raven.Client.Documents.Session.IDocumentQueryBase<T>.Lazily(Action`1<IEnumerable`1<T>> onEval);
    protected void InitSync();
    private void ExecuteActualQuery();
    internal DocumentQuery`1<TResult> CreateDocumentQueryInternal(QueryData queryData);
    public sealed virtual IRavenQueryable`1<T> ToQueryable();
    private sealed virtual override InMemoryDocumentSessionOperations Raven.Client.Documents.Linq.IDocumentQueryGenerator.get_Session();
    private sealed virtual override RavenQueryInspector`1<TS> Raven.Client.Documents.Linq.IDocumentQueryGenerator.CreateRavenQueryInspector();
    public sealed virtual IDocumentQuery`1<TResult> Query(string indexName, string collectionName, bool isMapReduce);
    public sealed virtual IAsyncDocumentQuery`1<TResult> AsyncQuery(string indexName, string collectionName, bool isMapReduce);
    public sealed virtual IAggregationDocumentQuery`1<T> AggregateBy(Action`1<IFacetBuilder`1<T>> builder);
    public sealed virtual IAggregationDocumentQuery`1<T> AggregateBy(FacetBase facet);
    public sealed virtual IAggregationDocumentQuery`1<T> AggregateBy(IEnumerable`1<FacetBase> facets);
    public sealed virtual IAggregationDocumentQuery`1<T> AggregateUsing(string facetSetupDocumentId);
    public sealed virtual Dictionary`2<string, FacetResult> ExecuteAggregation();
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQuery<T>.Filter(Action`1<IFilterFactory`1<T>> builder, int limit);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.Highlight(string fieldName, int fragmentLength, int fragmentCount, Highlightings& highlightings);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.Highlight(string fieldName, int fragmentLength, int fragmentCount, HighlightingOptions options, Highlightings& highlightings);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.Highlight(Expression`1<Func`2<T, object>> path, int fragmentLength, int fragmentCount, Highlightings& highlightings);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.Highlight(Expression`1<Func`2<T, object>> path, int fragmentLength, int fragmentCount, HighlightingOptions options, Highlightings& highlightings);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.MoreLikeThis(MoreLikeThisBase moreLikeThis);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQuery<T>.MoreLikeThis(Action`1<IMoreLikeThisBuilderForDocumentQuery`1<T>> builder);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQuery<T>.ShardContext(Action`1<IQueryShardedContextBuilder> builder);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.Spatial(Expression`1<Func`2<T, object>> path, Func`2<SpatialCriteriaFactory, SpatialCriteria> clause);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.Spatial(string fieldName, Func`2<SpatialCriteriaFactory, SpatialCriteria> clause);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.Spatial(DynamicSpatialField field, Func`2<SpatialCriteriaFactory, SpatialCriteria> clause);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.Spatial(Func`2<DynamicSpatialFieldFactory`1<T>, DynamicSpatialField> field, Func`2<SpatialCriteriaFactory, SpatialCriteria> clause);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WithinRadiusOf(Expression`1<Func`2<T, TValue>> propertySelector, double radius, double latitude, double longitude, Nullable`1<SpatialUnits> radiusUnits, double distanceErrorPct);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.WithinRadiusOf(string fieldName, double radius, double latitude, double longitude, Nullable`1<SpatialUnits> radiusUnits, double distanceErrorPct);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.RelatesToShape(Expression`1<Func`2<T, TValue>> propertySelector, string shapeWkt, SpatialRelation relation, double distanceErrorPct);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.RelatesToShape(Expression`1<Func`2<T, TValue>> propertySelector, string shapeWkt, SpatialRelation relation, SpatialUnits units, double distanceErrorPct);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.RelatesToShape(string fieldName, string shapeWkt, SpatialRelation relation, double distanceErrorPct);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IFilterDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.RelatesToShape(string fieldName, string shapeWkt, SpatialRelation relation, SpatialUnits units, double distanceErrorPct);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDistance(DynamicSpatialField field, double latitude, double longitude);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDistance(Func`2<DynamicSpatialFieldFactory`1<T>, DynamicSpatialField> field, double latitude, double longitude);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDistance(DynamicSpatialField field, string shapeWkt);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDistance(Func`2<DynamicSpatialFieldFactory`1<T>, DynamicSpatialField> field, string shapeWkt);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDistance(Expression`1<Func`2<T, object>> propertySelector, double latitude, double longitude);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDistance(string fieldName, double latitude, double longitude);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDistance(Expression`1<Func`2<T, object>> propertySelector, string shapeWkt);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDistance(string fieldName, string shapeWkt);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDistanceDescending(DynamicSpatialField field, double latitude, double longitude);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDistanceDescending(Func`2<DynamicSpatialFieldFactory`1<T>, DynamicSpatialField> field, double latitude, double longitude);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDistanceDescending(DynamicSpatialField field, string shapeWkt);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDistanceDescending(Func`2<DynamicSpatialFieldFactory`1<T>, DynamicSpatialField> field, string shapeWkt);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDistanceDescending(Expression`1<Func`2<T, object>> propertySelector, double latitude, double longitude);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDistanceDescending(string fieldName, double latitude, double longitude);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDistanceDescending(Expression`1<Func`2<T, object>> propertySelector, string shapeWkt);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDistanceDescending(string fieldName, string shapeWkt);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDistance(Expression`1<Func`2<T, object>> propertySelector, double latitude, double longitude, double roundFactor);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDistance(string fieldName, double latitude, double longitude, double roundFactor);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDistance(Expression`1<Func`2<T, object>> propertySelector, string shapeWkt, double roundFactor);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDistance(string fieldName, string shapeWkt, double roundFactor);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDistanceDescending(Expression`1<Func`2<T, object>> propertySelector, double latitude, double longitude, double roundFactor);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDistanceDescending(string fieldName, double latitude, double longitude, double roundFactor);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDistanceDescending(Expression`1<Func`2<T, object>> propertySelector, string shapeWkt, double roundFactor);
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQueryBase<T,Raven.Client.Documents.Session.IDocumentQuery<T>>.OrderByDistanceDescending(string fieldName, string shapeWkt, double roundFactor);
    private sealed virtual override ISuggestionDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQuery<T>.SuggestUsing(SuggestionBase suggestion);
    private sealed virtual override ISuggestionDocumentQuery`1<T> Raven.Client.Documents.Session.IDocumentQuery<T>.SuggestUsing(Action`1<ISuggestionBuilder`1<T>> builder);
    [CompilerGeneratedAttribute]
private string <SelectFields>b__2_0(MemberInfo x);
    [CompilerGeneratedAttribute]
private string <SelectFields>b__2_1(MemberInfo p);
}
internal class Raven.Client.Documents.Session.DocumentQueryHelper : object {
    internal static void AddSpaceIfNeeded(QueryToken previousToken, QueryToken currentToken, StringBuilder writer);
}
[DefaultMemberAttribute("Item")]
internal class Raven.Client.Documents.Session.DocumentsByEntityHolder : object {
    private Dictionary`2<object, DocumentInfo> _documentsByEntity;
    private Dictionary`2<object, DocumentInfo> _onBeforeStoreDocumentsByEntity;
    private bool _prepareEntitiesPuts;
    public int Count { get; }
    unknown DocumentInfo Item {public set; }
    public int get_Count();
    public void Remove(object entity);
    public void Evict(object entity);
    public void Add(object entity, DocumentInfo documentInfo);
    public void set_Item(object obj, DocumentInfo value);
    private void CreateOnBeforeStoreDocumentsByEntityIfNeeded();
    public void Clear();
    public bool TryGetValue(object entity, DocumentInfo& documentInfo);
    [IteratorStateMachineAttribute("Raven.Client.Documents.Session.DocumentsByEntityHolder/<GetEnumerator>d__13")]
public IEnumerator`1<DocumentsByEntityEnumeratorResult> GetEnumerator();
    public IDisposable PrepareEntitiesPuts();
    [CompilerGeneratedAttribute]
private void <PrepareEntitiesPuts>b__14_0();
}
internal class Raven.Client.Documents.Session.DocumentsById : object {
    private Dictionary`2<string, DocumentInfo> _inner;
    public int Count { get; }
    public bool TryGetValue(string id, DocumentInfo& info);
    public void Add(DocumentInfo info);
    public bool Remove(string id);
    public void Clear();
    public int get_Count();
    public Dictionary`2<string, EntityInfo> GetTrackedEntities(InMemoryDocumentSessionOperations session);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, DocumentInfo>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Raven.Client.Documents.Session.DocumentsChanges : object {
    [CompilerGeneratedAttribute]
private object <FieldOldValue>k__BackingField;
    [CompilerGeneratedAttribute]
private object <FieldNewValue>k__BackingField;
    [CompilerGeneratedAttribute]
private ChangeType <Change>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FieldPath>k__BackingField;
    public object FieldOldValue { get; public set; }
    public object FieldNewValue { get; public set; }
    public ChangeType Change { get; public set; }
    public string FieldName { get; public set; }
    public string FieldPath { get; public set; }
    public string FieldFullName { get; }
    [CompilerGeneratedAttribute]
public object get_FieldOldValue();
    [CompilerGeneratedAttribute]
public void set_FieldOldValue(object value);
    [CompilerGeneratedAttribute]
public object get_FieldNewValue();
    [CompilerGeneratedAttribute]
public void set_FieldNewValue(object value);
    [CompilerGeneratedAttribute]
public ChangeType get_Change();
    [CompilerGeneratedAttribute]
public void set_Change(ChangeType value);
    [CompilerGeneratedAttribute]
public string get_FieldName();
    [CompilerGeneratedAttribute]
public void set_FieldName(string value);
    [CompilerGeneratedAttribute]
public string get_FieldPath();
    [CompilerGeneratedAttribute]
public void set_FieldPath(string value);
    public string get_FieldFullName();
    private bool Equals(DocumentsChanges other);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Raven.Client.Documents.Session.DocumentSession : InMemoryDocumentSessionOperations {
    private IAttachmentsSessionOperations _attachments;
    private IRevisionsSessionOperations _revisions;
    private IClusterTransactionOperations _clusterTransaction;
    public IAdvancedSessionOperations Advanced { get; }
    public IEagerSessionOperations Eagerly { get; }
    public ILazySessionOperations Lazily { get; }
    public IAttachmentsSessionOperations Attachments { get; }
    public IRevisionsSessionOperations Revisions { get; }
    public IClusterTransactionOperations ClusterTransaction { get; }
    protected bool HasClusterSession { get; }
    private InMemoryDocumentSessionOperations Raven.Client.Documents.Linq.IDocumentQueryGenerator.Session { get; }
    public DocumentSession(DocumentStore documentStore, Guid id, SessionOptions options);
    public sealed virtual ValueTuple`2<T, string> ConditionalLoad(string id, string changeVector);
    public sealed virtual ISessionDocumentCounters CountersFor(string documentId);
    public sealed virtual ISessionDocumentCounters CountersFor(object entity);
    public sealed virtual IAdvancedSessionOperations get_Advanced();
    public sealed virtual IEagerSessionOperations get_Eagerly();
    public sealed virtual ILazySessionOperations get_Lazily();
    public sealed virtual IAttachmentsSessionOperations get_Attachments();
    public sealed virtual IRevisionsSessionOperations get_Revisions();
    public sealed virtual IClusterTransactionOperations get_ClusterTransaction();
    protected virtual bool get_HasClusterSession();
    protected virtual void ClearClusterSession();
    protected internal virtual ClusterTransactionOperationsBase GetClusterSession();
    public sealed virtual void SaveChanges();
    public sealed virtual bool Exists(string id);
    public sealed virtual void Refresh(T entity);
    public sealed virtual void Refresh(IEnumerable`1<T> entities);
    [ObsoleteAttribute("InMemoryDocumentSessionOperations.GenerateId is not supported anymore. Will be removed in next major version of the product.")]
protected virtual string GenerateId(object entity);
    protected virtual Task`1<string> GenerateIdAsync(object entity);
    public sealed virtual ResponseTimeInformation ExecuteAllPendingLazyOperations();
    private bool ExecuteLazyOperationsSingleStep(ResponseTimeInformation responseTimeInformation, List`1<GetRequest> requests, Stopwatch sw);
    internal static void ThrowWhenResultsAreOverInt32(long value, string caller, string suggestedMethod);
    public sealed virtual ILoaderWithInclude`1<T> Include(Expression`1<Func`2<T, string>> path);
    public sealed virtual ILoaderWithInclude`1<T> Include(Expression`1<Func`2<T, string>> path);
    public sealed virtual ILoaderWithInclude`1<T> Include(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    public sealed virtual ILoaderWithInclude`1<T> Include(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    public sealed virtual ILoaderWithInclude`1<object> Include(string path);
    private sealed virtual override ILazyLoaderWithInclude`1<T> Raven.Client.Documents.Session.Operations.Lazy.ILazySessionOperations.Include(Expression`1<Func`2<T, string>> path);
    private sealed virtual override ILazyLoaderWithInclude`1<T> Raven.Client.Documents.Session.Operations.Lazy.ILazySessionOperations.Include(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    private sealed virtual override Lazy`1<Dictionary`2<string, T>> Raven.Client.Documents.Session.Operations.Lazy.ILazySessionOperations.Load(IEnumerable`1<string> ids);
    private sealed virtual override Lazy`1<Dictionary`2<string, T>> Raven.Client.Documents.Session.Operations.Lazy.ILazySessionOperations.Load(IEnumerable`1<string> ids, Action`1<Dictionary`2<string, T>> onEval);
    private sealed virtual override Lazy`1<T> Raven.Client.Documents.Session.Operations.Lazy.ILazySessionOperations.Load(string id);
    private sealed virtual override Lazy`1<T> Raven.Client.Documents.Session.Operations.Lazy.ILazySessionOperations.Load(string id, Action`1<T> onEval);
    internal Lazy`1<T> AddLazyOperation(ILazyOperation operation, Action`1<T> onEval);
    private sealed virtual override Lazy`1<Dictionary`2<string, TResult>> Raven.Client.Documents.Session.Operations.Lazy.ILazySessionOperations.LoadStartingWith(string idPrefix, string matches, int start, int pageSize, string exclude, string startAfter);
    private sealed virtual override Lazy`1<ValueTuple`2<T, string>> Raven.Client.Documents.Session.Operations.Lazy.ILazySessionOperations.ConditionalLoad(string id, string changeVector);
    private sealed virtual override ILazyLoaderWithInclude`1<object> Raven.Client.Documents.Session.Operations.Lazy.ILazySessionOperations.Include(string path);
    public sealed virtual Lazy`1<Dictionary`2<string, T>> LazyLoadInternal(String[] ids, String[] includes, Action`1<Dictionary`2<string, T>> onEval);
    internal Lazy`1<int> AddLazyCountOperation(ILazyOperation operation);
    internal Lazy`1<long> AddLazyLongCountOperation(ILazyOperation operation);
    public sealed virtual T Load(string id);
    public sealed virtual Dictionary`2<string, T> Load(IEnumerable`1<string> ids);
    public sealed virtual T Load(string id, Action`1<IIncludeBuilder`1<T>> includes);
    public sealed virtual Dictionary`2<string, T> Load(IEnumerable`1<string> ids, Action`1<IIncludeBuilder`1<T>> includes);
    public sealed virtual Dictionary`2<string, T> LoadInternal(String[] ids, String[] includes, String[] counterIncludes, bool includeAllCounters, IEnumerable`1<AbstractTimeSeriesRange> timeSeriesIncludes, String[] compareExchangeValueIncludes, String[] revisionIncludesByChangeVector, Nullable`1<DateTime> revisionIncludeByDateTimeBefore);
    public sealed virtual T[] LoadStartingWith(string idPrefix, string matches, int start, int pageSize, string exclude, string startAfter);
    public sealed virtual void LoadStartingWithIntoStream(string idPrefix, Stream output, string matches, int start, int pageSize, string exclude, string startAfter);
    public sealed virtual void LoadIntoStream(IEnumerable`1<string> ids, Stream output);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.DocumentSession/<LoadStartingWithInternalAsync>d__58")]
private Task LoadStartingWithInternalAsync(string idPrefix, LoadStartingWithOperation operation, Stream stream, string matches, int start, int pageSize, string exclude, string startAfter, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.DocumentSession/<LoadInternalAsync>d__59")]
private Task LoadInternalAsync(String[] ids, LoadOperation operation, Stream stream);
    public sealed virtual IDocumentQuery`1<T> DocumentQuery();
    public sealed virtual IDocumentQuery`1<T> DocumentQuery(string indexName, string collectionName, bool isMapReduce);
    public sealed virtual IRavenQueryable`1<T> Query(string indexName, string collectionName, bool isMapReduce);
    public sealed virtual IAsyncDocumentQuery`1<T> AsyncQuery(string indexName, string collectionName, bool isMapReduce);
    public sealed virtual RavenQueryInspector`1<S> CreateRavenQueryInspector();
    public sealed virtual IRavenQueryable`1<T> Query();
    private sealed virtual override IDocumentQuery`1<T> Raven.Client.Documents.Linq.IDocumentQueryGenerator.Query(string indexName, string collectionName, bool isMapReduce);
    private sealed virtual override InMemoryDocumentSessionOperations Raven.Client.Documents.Linq.IDocumentQueryGenerator.get_Session();
    public sealed virtual IRawDocumentQuery`1<T> RawQuery(string query);
    public sealed virtual IEnumerator`1<StreamResult`1<T>> Stream(IQueryable`1<T> query);
    public sealed virtual IEnumerator`1<StreamResult`1<T>> Stream(IQueryable`1<T> query, StreamQueryStatistics& streamQueryStats);
    public sealed virtual IEnumerator`1<StreamResult`1<T>> Stream(IDocumentQuery`1<T> query);
    public sealed virtual IEnumerator`1<StreamResult`1<T>> Stream(IRawDocumentQuery`1<T> query);
    public sealed virtual IEnumerator`1<StreamResult`1<T>> Stream(IRawDocumentQuery`1<T> query, StreamQueryStatistics& streamQueryStats);
    public sealed virtual IEnumerator`1<StreamResult`1<T>> Stream(IDocumentQuery`1<T> query, StreamQueryStatistics& streamQueryStats);
    [IteratorStateMachineAttribute("Raven.Client.Documents.Session.DocumentSession/<YieldResults>d__76`1")]
private IEnumerator`1<StreamResult`1<T>> YieldResults(IDocumentQuery`1<T> query, IEnumerator`1<BlittableJsonReaderObject> enumerator);
    public sealed virtual void StreamInto(IRawDocumentQuery`1<T> query, Stream output);
    public sealed virtual void StreamInto(IDocumentQuery`1<T> query, Stream output);
    [IteratorStateMachineAttribute("Raven.Client.Documents.Session.DocumentSession/<Stream>d__79`1")]
public sealed virtual IEnumerator`1<StreamResult`1<T>> Stream(string startsWith, string matches, int start, int pageSize, string startAfter);
    public sealed virtual ISessionDocumentTimeSeries TimeSeriesFor(string documentId, string name);
    public sealed virtual ISessionDocumentTimeSeries TimeSeriesFor(object entity, string name);
    public sealed virtual ISessionDocumentTypedTimeSeries`1<TValues> TimeSeriesFor(string documentId, string name);
    public sealed virtual ISessionDocumentTypedTimeSeries`1<TValues> TimeSeriesFor(object entity, string name);
    public sealed virtual ISessionDocumentRollupTypedTimeSeries`1<TValues> TimeSeriesRollupFor(object entity, string policy, string raw);
    public sealed virtual ISessionDocumentRollupTypedTimeSeries`1<TValues> TimeSeriesRollupFor(string documentId, string policy, string raw);
    public sealed virtual ISessionDocumentIncrementalTimeSeries IncrementalTimeSeriesFor(string documentId, string name);
    public sealed virtual ISessionDocumentIncrementalTimeSeries IncrementalTimeSeriesFor(object entity, string name);
    public sealed virtual ISessionDocumentTypedIncrementalTimeSeries`1<TValues> IncrementalTimeSeriesFor(string documentId, string name);
    public sealed virtual ISessionDocumentTypedIncrementalTimeSeries`1<TValues> IncrementalTimeSeriesFor(object entity, string name);
    private IEnumerator`1<TimeSeriesStreamResult`1<T>> StreamTimeSeriesInternal(IDocumentQuery`1<T> query);
    private IEnumerator`1<TimeSeriesStreamResult`1<T>> StreamTimeSeriesInternal(IDocumentQuery`1<T> query, StreamQueryStatistics& streamQueryStats);
    [IteratorStateMachineAttribute("Raven.Client.Documents.Session.DocumentSession/<YieldTimeSeriesResults>d__92`1")]
private IEnumerator`1<TimeSeriesStreamResult`1<T>> YieldTimeSeriesResults(IDocumentQuery`1<T> query, YieldStreamResults enumerator);
    private IEnumerator`1<TimeSeriesStreamResult`1<T>> StreamTimeSeriesInternal(IRawDocumentQuery`1<T> query);
    private IEnumerator`1<TimeSeriesStreamResult`1<T>> StreamTimeSeriesInternal(IQueryable`1<T> query);
    private IEnumerator`1<TimeSeriesStreamResult`1<T>> StreamTimeSeriesInternal(IQueryable`1<T> query, StreamQueryStatistics& streamQueryStats);
    private IEnumerator`1<TimeSeriesStreamResult`1<T>> StreamTimeSeriesInternal(IRawDocumentQuery`1<T> query, StreamQueryStatistics& streamQueryStats);
    private sealed virtual override IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult>> Raven.Client.Documents.Session.ITimeSeriesSessionStreamOperations<Raven.Client.Documents.Queries.TimeSeries.TimeSeriesAggregationResult>.Stream(IQueryable`1<TimeSeriesAggregationResult> query);
    private sealed virtual override IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult>> Raven.Client.Documents.Session.ITimeSeriesSessionStreamOperations<Raven.Client.Documents.Queries.TimeSeries.TimeSeriesAggregationResult>.Stream(IQueryable`1<TimeSeriesAggregationResult> query, StreamQueryStatistics& streamQueryStats);
    private sealed virtual override IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult>> Raven.Client.Documents.Session.ITimeSeriesSessionStreamOperations<Raven.Client.Documents.Queries.TimeSeries.TimeSeriesAggregationResult>.Stream(IDocumentQuery`1<TimeSeriesAggregationResult> query);
    private sealed virtual override IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult>> Raven.Client.Documents.Session.ITimeSeriesSessionStreamOperations<Raven.Client.Documents.Queries.TimeSeries.TimeSeriesAggregationResult>.Stream(IRawDocumentQuery`1<TimeSeriesAggregationResult> query);
    private sealed virtual override IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult>> Raven.Client.Documents.Session.ITimeSeriesSessionStreamOperations<Raven.Client.Documents.Queries.TimeSeries.TimeSeriesAggregationResult>.Stream(IRawDocumentQuery`1<TimeSeriesAggregationResult> query, StreamQueryStatistics& streamQueryStats);
    private sealed virtual override IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult>> Raven.Client.Documents.Session.ITimeSeriesSessionStreamOperations<Raven.Client.Documents.Queries.TimeSeries.TimeSeriesAggregationResult>.Stream(IDocumentQuery`1<TimeSeriesAggregationResult> query, StreamQueryStatistics& streamQueryStats);
    private sealed virtual override IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult>> Raven.Client.Documents.Session.ITimeSeriesSessionStreamOperations<Raven.Client.Documents.Queries.TimeSeries.TimeSeriesRawResult>.Stream(IQueryable`1<TimeSeriesRawResult> query);
    private sealed virtual override IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult>> Raven.Client.Documents.Session.ITimeSeriesSessionStreamOperations<Raven.Client.Documents.Queries.TimeSeries.TimeSeriesRawResult>.Stream(IQueryable`1<TimeSeriesRawResult> query, StreamQueryStatistics& streamQueryStats);
    private sealed virtual override IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult>> Raven.Client.Documents.Session.ITimeSeriesSessionStreamOperations<Raven.Client.Documents.Queries.TimeSeries.TimeSeriesRawResult>.Stream(IDocumentQuery`1<TimeSeriesRawResult> query);
    private sealed virtual override IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult>> Raven.Client.Documents.Session.ITimeSeriesSessionStreamOperations<Raven.Client.Documents.Queries.TimeSeries.TimeSeriesRawResult>.Stream(IRawDocumentQuery`1<TimeSeriesRawResult> query);
    private sealed virtual override IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult>> Raven.Client.Documents.Session.ITimeSeriesSessionStreamOperations<Raven.Client.Documents.Queries.TimeSeries.TimeSeriesRawResult>.Stream(IRawDocumentQuery`1<TimeSeriesRawResult> query, StreamQueryStatistics& streamQueryStats);
    private sealed virtual override IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult>> Raven.Client.Documents.Session.ITimeSeriesSessionStreamOperations<Raven.Client.Documents.Queries.TimeSeries.TimeSeriesRawResult>.Stream(IDocumentQuery`1<TimeSeriesRawResult> query, StreamQueryStatistics& streamQueryStats);
    private sealed virtual override IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult`1<T>>> Raven.Client.Documents.Session.ITimeSeriesSessionStreamAggregationResultOperations.Stream(IQueryable`1<TimeSeriesAggregationResult`1<T>> query);
    private sealed virtual override IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult`1<T>>> Raven.Client.Documents.Session.ITimeSeriesSessionStreamAggregationResultOperations.Stream(IQueryable`1<TimeSeriesAggregationResult`1<T>> query, StreamQueryStatistics& streamQueryStats);
    private sealed virtual override IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult`1<T>>> Raven.Client.Documents.Session.ITimeSeriesSessionStreamAggregationResultOperations.Stream(IDocumentQuery`1<TimeSeriesAggregationResult`1<T>> query);
    private sealed virtual override IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult`1<T>>> Raven.Client.Documents.Session.ITimeSeriesSessionStreamAggregationResultOperations.Stream(IRawDocumentQuery`1<TimeSeriesAggregationResult`1<T>> query);
    private sealed virtual override IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult`1<T>>> Raven.Client.Documents.Session.ITimeSeriesSessionStreamAggregationResultOperations.Stream(IRawDocumentQuery`1<TimeSeriesAggregationResult`1<T>> query, StreamQueryStatistics& streamQueryStats);
    private sealed virtual override IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult`1<T>>> Raven.Client.Documents.Session.ITimeSeriesSessionStreamAggregationResultOperations.Stream(IDocumentQuery`1<TimeSeriesAggregationResult`1<T>> query, StreamQueryStatistics& streamQueryStats);
    private sealed virtual override IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult`1<T>>> Raven.Client.Documents.Session.ITimeSeriesSessionStreamRawResultOperations.Stream(IQueryable`1<TimeSeriesRawResult`1<T>> query);
    private sealed virtual override IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult`1<T>>> Raven.Client.Documents.Session.ITimeSeriesSessionStreamRawResultOperations.Stream(IQueryable`1<TimeSeriesRawResult`1<T>> query, StreamQueryStatistics& streamQueryStats);
    private sealed virtual override IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult`1<T>>> Raven.Client.Documents.Session.ITimeSeriesSessionStreamRawResultOperations.Stream(IDocumentQuery`1<TimeSeriesRawResult`1<T>> query);
    private sealed virtual override IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult`1<T>>> Raven.Client.Documents.Session.ITimeSeriesSessionStreamRawResultOperations.Stream(IRawDocumentQuery`1<TimeSeriesRawResult`1<T>> query);
    private sealed virtual override IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult`1<T>>> Raven.Client.Documents.Session.ITimeSeriesSessionStreamRawResultOperations.Stream(IRawDocumentQuery`1<TimeSeriesRawResult`1<T>> query, StreamQueryStatistics& streamQueryStats);
    private sealed virtual override IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult`1<T>>> Raven.Client.Documents.Session.ITimeSeriesSessionStreamRawResultOperations.Stream(IDocumentQuery`1<TimeSeriesRawResult`1<T>> query, StreamQueryStatistics& streamQueryStats);
}
public class Raven.Client.Documents.Session.DocumentSessionAttachments : DocumentSessionAttachmentsBase {
    public DocumentSessionAttachments(InMemoryDocumentSessionOperations session);
    public sealed virtual bool Exists(string documentId, string name);
    public sealed virtual AttachmentResult Get(string documentId, string name);
    public sealed virtual AttachmentResult Get(object entity, string name);
    public sealed virtual IEnumerator`1<AttachmentEnumeratorResult> Get(IEnumerable`1<AttachmentRequest> attachments);
    public sealed virtual AttachmentResult GetRevision(string documentId, string name, string changeVector);
}
public class Raven.Client.Documents.Session.DocumentSessionAttachmentsAsync : DocumentSessionAttachmentsBase {
    public DocumentSessionAttachmentsAsync(InMemoryDocumentSessionOperations session);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.DocumentSessionAttachmentsAsync/<ExistsAsync>d__1")]
public sealed virtual Task`1<bool> ExistsAsync(string documentId, string name, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.DocumentSessionAttachmentsAsync/<GetAsync>d__2")]
public sealed virtual Task`1<AttachmentResult> GetAsync(string documentId, string name, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.DocumentSessionAttachmentsAsync/<GetAsync>d__3")]
public sealed virtual Task`1<AttachmentResult> GetAsync(object entity, string name, CancellationToken token);
    public sealed virtual Task`1<IEnumerator`1<AttachmentEnumeratorResult>> GetAsync(IEnumerable`1<AttachmentRequest> attachments, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.DocumentSessionAttachmentsAsync/<GetRevisionAsync>d__5")]
public sealed virtual Task`1<AttachmentResult> GetRevisionAsync(string documentId, string name, string changeVector, CancellationToken token);
}
public abstract class Raven.Client.Documents.Session.DocumentSessionAttachmentsBase : AdvancedSessionExtensionBase {
    protected DocumentSessionAttachmentsBase(InMemoryDocumentSessionOperations session);
    public sealed virtual AttachmentName[] GetNames(object entity);
    public sealed virtual void Store(string documentId, string name, Stream stream, string contentType);
    public sealed virtual void Store(object entity, string name, Stream stream, string contentType);
    protected void ThrowEntityNotInSessionOrMissingId(object entity);
    protected void ThrowEntityNotInSession(object entity);
    public sealed virtual void Delete(object entity, string name);
    public sealed virtual void Delete(string documentId, string name);
    public sealed virtual void Rename(string documentId, string name, string newName);
    public sealed virtual void Rename(object entity, string name, string newName);
    public sealed virtual void Move(object sourceEntity, string sourceName, object destinationEntity, string destinationName);
    public sealed virtual void Move(string sourceDocumentId, string sourceName, string destinationDocumentId, string destinationName);
    public sealed virtual void Copy(object sourceEntity, string sourceName, object destinationEntity, string destinationName);
    public sealed virtual void Copy(string sourceDocumentId, string sourceName, string destinationDocumentId, string destinationName);
    private static void ThrowDocumentAlreadyDeleted(string documentId, string name, string operation, string destinationDocumentId, string deletedDocumentId);
    private static void ThrowOtherDeferredCommandException(string documentId, string name, string operation, string previousOperation);
}
public class Raven.Client.Documents.Session.DocumentSessionRevisions : DocumentSessionRevisionsBase {
    public ILazyRevisionsOperations Lazily { get; }
    public DocumentSessionRevisions(InMemoryDocumentSessionOperations session);
    public sealed virtual ILazyRevisionsOperations get_Lazily();
    public sealed virtual List`1<T> GetFor(string id, int start, int pageSize);
    public sealed virtual List`1<IMetadataDictionary> GetMetadataFor(string id, int start, int pageSize);
    public sealed virtual T Get(string changeVector);
    public sealed virtual Dictionary`2<string, T> Get(IEnumerable`1<string> changeVectors);
    public sealed virtual T Get(string id, DateTime date);
    public sealed virtual long GetCountFor(string id);
    private sealed virtual override Lazy`1<T> Raven.Client.Documents.Session.ILazyRevisionsOperations.Get(string changeVector);
    private sealed virtual override Lazy`1<List`1<IMetadataDictionary>> Raven.Client.Documents.Session.ILazyRevisionsOperations.GetMetadataFor(string id, int start, int pageSize);
    private sealed virtual override Lazy`1<Dictionary`2<string, T>> Raven.Client.Documents.Session.ILazyRevisionsOperations.Get(IEnumerable`1<string> changeVectors);
    private sealed virtual override Lazy`1<T> Raven.Client.Documents.Session.ILazyRevisionsOperations.Get(string id, DateTime date);
    private sealed virtual override Lazy`1<List`1<T>> Raven.Client.Documents.Session.ILazyRevisionsOperations.GetFor(string id, int start, int pageSize);
}
public class Raven.Client.Documents.Session.DocumentSessionRevisionsAsync : DocumentSessionRevisionsBase {
    public ILazyRevisionsOperationsAsync Lazily { get; }
    public DocumentSessionRevisionsAsync(AsyncDocumentSession session);
    public sealed virtual ILazyRevisionsOperationsAsync get_Lazily();
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.DocumentSessionRevisionsAsync/<GetForAsync>d__3`1")]
public sealed virtual Task`1<List`1<T>> GetForAsync(string id, int start, int pageSize, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.DocumentSessionRevisionsAsync/<GetMetadataForAsync>d__4")]
public sealed virtual Task`1<List`1<IMetadataDictionary>> GetMetadataForAsync(string id, int start, int pageSize, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.DocumentSessionRevisionsAsync/<GetAsync>d__5`1")]
public sealed virtual Task`1<T> GetAsync(string changeVector, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.DocumentSessionRevisionsAsync/<GetAsync>d__6`1")]
public sealed virtual Task`1<Dictionary`2<string, T>> GetAsync(IEnumerable`1<string> changeVectors, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.DocumentSessionRevisionsAsync/<GetAsync>d__7`1")]
public sealed virtual Task`1<T> GetAsync(string id, DateTime date, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.DocumentSessionRevisionsAsync/<GetCountForAsync>d__8")]
public sealed virtual Task`1<long> GetCountForAsync(string id, CancellationToken token);
    private sealed virtual override Lazy`1<Task`1<List`1<T>>> Raven.Client.Documents.Session.ILazyRevisionsOperationsAsync.GetForAsync(string id, int start, int pageSize, CancellationToken token);
    private sealed virtual override Lazy`1<Task`1<T>> Raven.Client.Documents.Session.ILazyRevisionsOperationsAsync.GetAsync(string changeVector, CancellationToken token);
    private sealed virtual override Lazy`1<Task`1<T>> Raven.Client.Documents.Session.ILazyRevisionsOperationsAsync.GetAsync(string id, DateTime dateTime, CancellationToken token);
    private sealed virtual override Lazy`1<Task`1<Dictionary`2<string, T>>> Raven.Client.Documents.Session.ILazyRevisionsOperationsAsync.GetAsync(IEnumerable`1<string> changeVectors, CancellationToken token);
    private sealed virtual override Lazy`1<Task`1<List`1<IMetadataDictionary>>> Raven.Client.Documents.Session.ILazyRevisionsOperationsAsync.GetMetadataForAsync(string id, int start, int pageSize, CancellationToken token);
}
public abstract class Raven.Client.Documents.Session.DocumentSessionRevisionsBase : AdvancedSessionExtensionBase {
    protected DocumentSessionRevisionsBase(InMemoryDocumentSessionOperations session);
    public sealed virtual void ForceRevisionCreationFor(T entity, ForceRevisionStrategy strategy);
    public sealed virtual void ForceRevisionCreationFor(string id, ForceRevisionStrategy strategy);
    private void AddIdToList(string id, ForceRevisionStrategy requestedStrategy);
}
public class Raven.Client.Documents.Session.EntityInfo : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Entity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDeleted>k__BackingField;
    public string Id { get; public set; }
    public object Entity { get; public set; }
    public bool IsDeleted { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public object get_Entity();
    [CompilerGeneratedAttribute]
public void set_Entity(object value);
    [CompilerGeneratedAttribute]
public bool get_IsDeleted();
    [CompilerGeneratedAttribute]
public void set_IsDeleted(bool value);
}
public class Raven.Client.Documents.Session.FailedRequestEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpResponseMessage <Response>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpRequestMessage <Request>k__BackingField;
    public string Database { get; }
    public string Url { get; }
    public Exception Exception { get; }
    public HttpResponseMessage Response { get; }
    public HttpRequestMessage Request { get; }
    internal FailedRequestEventArgs(string database, string url, Exception exception);
    internal FailedRequestEventArgs(string database, string url, Exception exception, HttpResponseMessage response, HttpRequestMessage request);
    [CompilerGeneratedAttribute]
public string get_Database();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public HttpResponseMessage get_Response();
    [CompilerGeneratedAttribute]
public HttpRequestMessage get_Request();
}
public enum Raven.Client.Documents.Session.ForceRevisionStrategy : Enum {
    public int value__;
    public static ForceRevisionStrategy None;
    public static ForceRevisionStrategy Before;
}
public class Raven.Client.Documents.Session.GroupByDocumentQuery`1 : object {
    private DocumentQuery`1<T> _query;
    public GroupByDocumentQuery`1(DocumentQuery`1<T> query);
    public sealed virtual IGroupByDocumentQuery`1<T> SelectKey(string fieldName, string projectedName);
    public sealed virtual IDocumentQuery`1<T> SelectSum(GroupByField field, GroupByField[] fields);
    public sealed virtual IDocumentQuery`1<T> SelectCount(string projectedName);
    public sealed virtual IGroupByDocumentQuery`1<T> Filter(Action`1<IFilterFactory`1<T>> builder, int limit);
}
public class Raven.Client.Documents.Session.GroupByField : object {
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectedName>k__BackingField;
    public string FieldName { get; public set; }
    public string ProjectedName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FieldName();
    [CompilerGeneratedAttribute]
public void set_FieldName(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectedName();
    [CompilerGeneratedAttribute]
public void set_ProjectedName(string value);
}
public interface Raven.Client.Documents.Session.IAbstractDocumentQuery`1 {
    public string IndexName { get; }
    public string CollectionName { get; }
    public DocumentConventions Conventions { get; }
    public bool IsDynamicMapReduce { get; }
    public string ParameterPrefix { get; public set; }
    public abstract virtual string get_IndexName();
    public abstract virtual string get_CollectionName();
    public abstract virtual DocumentConventions get_Conventions();
    public abstract virtual bool get_IsDynamicMapReduce();
    public abstract virtual void WaitForNonStaleResults(Nullable`1<TimeSpan> waitTimeout);
    public abstract virtual IEnumerable`1<string> GetProjectionFields();
    public abstract virtual void RandomOrdering();
    public abstract virtual void RandomOrdering(string seed);
    public abstract virtual void Include(string path);
    public abstract virtual void Include(Expression`1<Func`2<T, object>> path);
    public abstract virtual void Include(IncludeBuilder includes);
    public abstract virtual void Take(long count);
    public abstract virtual void Skip(long count);
    public abstract virtual void WhereEquals(string fieldName, object value, bool exact);
    public abstract virtual void WhereEquals(string fieldName, MethodCall method, bool exact);
    public abstract virtual void WhereEquals(WhereParams whereParams);
    public abstract virtual void WhereNotEquals(string fieldName, object value, bool exact);
    public abstract virtual void WhereNotEquals(string fieldName, MethodCall method, bool exact);
    public abstract virtual void WhereNotEquals(WhereParams whereParams);
    public abstract virtual void OpenSubclause();
    public abstract virtual void CloseSubclause();
    public abstract virtual void NegateNext();
    public abstract virtual void WhereIn(string fieldName, IEnumerable`1<object> values, bool exact);
    public abstract virtual void WhereStartsWith(string fieldName, object value);
    public abstract virtual void WhereStartsWith(string fieldName, object value, bool exact);
    public abstract virtual void WhereEndsWith(string fieldName, object value);
    public abstract virtual void WhereEndsWith(string fieldName, object value, bool exact);
    public abstract virtual void WhereBetween(string fieldName, object start, object end, bool exact);
    public abstract virtual void WhereGreaterThan(string fieldName, object value, bool exact);
    public abstract virtual void WhereGreaterThanOrEqual(string fieldName, object value, bool exact);
    public abstract virtual void WhereLessThan(string fieldName, object value, bool exact);
    public abstract virtual void WhereLessThanOrEqual(string fieldName, object value, bool exact);
    public abstract virtual void WhereExists(string fieldName);
    public abstract virtual void WhereRegex(string fieldName, string pattern);
    public abstract virtual void AndAlso();
    public abstract virtual void OrElse();
    public abstract virtual void Boost(decimal boost);
    public abstract virtual void Fuzzy(decimal fuzzy);
    public abstract virtual void Proximity(int proximity);
    public abstract virtual void OrderBy(string field, string sorterName);
    public abstract virtual void OrderBy(string field, OrderingType ordering);
    public abstract virtual void OrderByDescending(string field, string sorterName);
    public abstract virtual void OrderByDescending(string field, OrderingType ordering);
    public abstract virtual void OrderByScore();
    public abstract virtual void OrderByScoreDescending();
    public abstract virtual void Highlight(string fieldName, int fragmentLength, int fragmentCount, HighlightingOptions options, Highlightings& highlightings);
    public abstract virtual void Search(string fieldName, string searchTerms, SearchOperator operator);
    public abstract virtual string ToString();
    public abstract virtual void Intersect();
    public abstract virtual void AddRootType(Type type);
    public abstract virtual void Distinct();
    public abstract virtual void ContainsAny(string fieldName, IEnumerable`1<object> values);
    public abstract virtual void ContainsAll(string fieldName, IEnumerable`1<object> values);
    public abstract virtual void GroupBy(string fieldName, String[] fieldNames);
    public abstract virtual void GroupBy(ValueTuple`2<string, GroupByMethod> field, ValueTuple`2[] fields);
    public abstract virtual void GroupByKey(string fieldName, string projectedName);
    public abstract virtual void GroupBySum(string fieldName, string projectedName);
    public abstract virtual void GroupByCount(string projectedName);
    public abstract virtual void WhereTrue();
    public abstract virtual void Spatial(DynamicSpatialField field, SpatialCriteria criteria);
    public abstract virtual void Spatial(string fieldName, SpatialCriteria criteria);
    public abstract virtual void OrderByDistance(DynamicSpatialField field, double latitude, double longitude);
    public abstract virtual void OrderByDistance(string fieldName, double latitude, double longitude);
    public abstract virtual void OrderByDistance(string fieldName, double latitude, double longitude, double roundFactor);
    public abstract virtual void OrderByDistance(DynamicSpatialField field, string shapeWkt);
    public abstract virtual void OrderByDistance(string fieldName, string shapeWkt);
    public abstract virtual void OrderByDistance(string fieldName, string shapeWkt, double roundFactor);
    public abstract virtual void OrderByDistanceDescending(DynamicSpatialField field, double latitude, double longitude);
    public abstract virtual void OrderByDistanceDescending(string fieldName, double latitude, double longitude);
    public abstract virtual void OrderByDistanceDescending(string fieldName, double latitude, double longitude, double roundFactor);
    public abstract virtual void OrderByDistanceDescending(DynamicSpatialField field, string shapeWkt);
    public abstract virtual void OrderByDistanceDescending(string fieldName, string shapeWkt);
    public abstract virtual void OrderByDistanceDescending(string fieldName, string shapeWkt, double roundFactor);
    public abstract virtual MoreLikeThisScope MoreLikeThis();
    public abstract virtual void AggregateBy(FacetBase facet);
    public abstract virtual void AggregateUsing(string facetSetupDocumentId);
    public abstract virtual void AddFromAliasToWhereTokens(string fromAlias);
    public abstract virtual void AddFromAliasToFilterTokens(string fromAlias);
    public abstract virtual void AddFromAliasToOrderByTokens(string fromAlias);
    public abstract virtual string AddAliasToIncludesTokens(string fromAlias);
    public abstract virtual string ProjectionParameter(object value);
    public abstract virtual void SuggestUsing(SuggestionBase suggestion);
    public abstract virtual string get_ParameterPrefix();
    public abstract virtual void set_ParameterPrefix(string value);
}
public interface Raven.Client.Documents.Session.IAbstractDocumentQueryImpl`1 {
    public FieldsToFetchToken FieldsToFetchToken { get; public set; }
    public bool IsProjectInto { get; }
    public abstract virtual FieldsToFetchToken get_FieldsToFetchToken();
    public abstract virtual void set_FieldsToFetchToken(FieldsToFetchToken value);
    public abstract virtual bool get_IsProjectInto();
    public abstract virtual QueryOperation InitializeQueryOperation();
}
public interface Raven.Client.Documents.Session.IAdvancedDocumentSessionOperations {
    public IDocumentStore DocumentStore { get; }
    public IDictionary`2<string, object> ExternalState { get; }
    public RequestExecutor RequestExecutor { get; }
    public JsonOperationContext Context { get; }
    public SessionInfo SessionInfo { get; }
    public bool HasChanges { get; }
    public int MaxNumberOfRequestsPerSession { get; public set; }
    public int NumberOfRequests { get; }
    public string StoreIdentifier { get; }
    public bool UseOptimisticConcurrency { get; public set; }
    public ISessionBlittableJsonConverter JsonConverter { get; }
    public abstract virtual IDocumentStore get_DocumentStore();
    public abstract virtual IDictionary`2<string, object> get_ExternalState();
    public abstract virtual Task`1<ServerNode> GetCurrentSessionNode();
    public abstract virtual RequestExecutor get_RequestExecutor();
    public abstract virtual JsonOperationContext get_Context();
    public abstract virtual SessionInfo get_SessionInfo();
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnBeforeStore(EventHandler`1<BeforeStoreEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnBeforeStore(EventHandler`1<BeforeStoreEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnAfterSaveChanges(EventHandler`1<AfterSaveChangesEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnAfterSaveChanges(EventHandler`1<AfterSaveChangesEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnBeforeDelete(EventHandler`1<BeforeDeleteEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnBeforeDelete(EventHandler`1<BeforeDeleteEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnBeforeQuery(EventHandler`1<BeforeQueryEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnBeforeQuery(EventHandler`1<BeforeQueryEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnBeforeConversionToDocument(EventHandler`1<BeforeConversionToDocumentEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnBeforeConversionToDocument(EventHandler`1<BeforeConversionToDocumentEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnAfterConversionToDocument(EventHandler`1<AfterConversionToDocumentEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnAfterConversionToDocument(EventHandler`1<AfterConversionToDocumentEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnBeforeConversionToEntity(EventHandler`1<BeforeConversionToEntityEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnBeforeConversionToEntity(EventHandler`1<BeforeConversionToEntityEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnAfterConversionToEntity(EventHandler`1<AfterConversionToEntityEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnAfterConversionToEntity(EventHandler`1<AfterConversionToEntityEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnSessionDisposing(EventHandler`1<SessionDisposingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnSessionDisposing(EventHandler`1<SessionDisposingEventArgs> value);
    public abstract virtual bool get_HasChanges();
    public abstract virtual int get_MaxNumberOfRequestsPerSession();
    public abstract virtual void set_MaxNumberOfRequestsPerSession(int value);
    public abstract virtual int get_NumberOfRequests();
    public abstract virtual string get_StoreIdentifier();
    public abstract virtual bool get_UseOptimisticConcurrency();
    public abstract virtual void set_UseOptimisticConcurrency(bool value);
    public abstract virtual void Clear();
    public abstract virtual void Defer(ICommandData command, ICommandData[] commands);
    public abstract virtual void Defer(ICommandData[] commands);
    public abstract virtual void Evict(T entity);
    public abstract virtual string GetDocumentId(object entity);
    public abstract virtual IMetadataDictionary GetMetadataFor(T instance);
    public abstract virtual string GetChangeVectorFor(T instance);
    public abstract virtual List`1<string> GetCountersFor(T instance);
    public abstract virtual List`1<string> GetTimeSeriesFor(T instance);
    public abstract virtual Nullable`1<DateTime> GetLastModifiedFor(T instance);
    public abstract virtual bool HasChanged(object entity);
    public abstract virtual bool IsLoaded(string id);
    public abstract virtual void IgnoreChangesFor(object entity);
    public abstract virtual IDictionary`2<string, DocumentsChanges[]> WhatChanged();
    public abstract virtual DocumentsChanges[] WhatChangedFor(object entity);
    public abstract virtual IDictionary`2<string, EntityInfo> GetTrackedEntities();
    public abstract virtual void WaitForReplicationAfterSaveChanges(Nullable`1<TimeSpan> timeout, bool throwOnTimeout, int replicas, bool majority);
    public abstract virtual void WaitForIndexesAfterSaveChanges(Nullable`1<TimeSpan> timeout, bool throwOnTimeout, String[] indexes);
    public abstract virtual void SetTransactionMode(TransactionMode mode);
    public abstract virtual ISessionBlittableJsonConverter get_JsonConverter();
}
public interface Raven.Client.Documents.Session.IAdvancedSessionOperations {
    public IEagerSessionOperations Eagerly { get; }
    public ILazySessionOperations Lazily { get; }
    public IAttachmentsSessionOperations Attachments { get; }
    public IRevisionsSessionOperations Revisions { get; }
    public IClusterTransactionOperations ClusterTransaction { get; }
    public abstract virtual ValueTuple`2<T, string> ConditionalLoad(string id, string changeVector);
    public abstract virtual IEagerSessionOperations get_Eagerly();
    public abstract virtual ILazySessionOperations get_Lazily();
    public abstract virtual IAttachmentsSessionOperations get_Attachments();
    public abstract virtual IRevisionsSessionOperations get_Revisions();
    public abstract virtual IClusterTransactionOperations get_ClusterTransaction();
    public abstract virtual void Refresh(T entity);
    public abstract virtual void Refresh(IEnumerable`1<T> entities);
    public abstract virtual IRawDocumentQuery`1<T> RawQuery(string query);
    public abstract virtual bool Exists(string id);
    public abstract virtual T[] LoadStartingWith(string idPrefix, string matches, int start, int pageSize, string exclude, string startAfter);
    public abstract virtual void LoadStartingWithIntoStream(string idPrefix, Stream output, string matches, int start, int pageSize, string exclude, string startAfter);
    public abstract virtual void LoadIntoStream(IEnumerable`1<string> ids, Stream output);
    public abstract virtual void Increment(T entity, Expression`1<Func`2<T, U>> path, U valToAdd);
    public abstract virtual void Increment(string id, Expression`1<Func`2<T, U>> path, U valToAdd);
    public abstract virtual void Patch(string id, Expression`1<Func`2<T, U>> path, U value);
    public abstract virtual void Patch(T entity, Expression`1<Func`2<T, U>> path, U value);
    public abstract virtual void Patch(T entity, Expression`1<Func`2<T, IEnumerable`1<U>>> path, Expression`1<Func`2<JavaScriptArray`1<U>, object>> arrayAdder);
    public abstract virtual void Patch(string id, Expression`1<Func`2<T, IEnumerable`1<U>>> path, Expression`1<Func`2<JavaScriptArray`1<U>, object>> arrayAdder);
    public abstract virtual void Patch(T entity, Expression`1<Func`2<T, IDictionary`2<TKey, TValue>>> path, Expression`1<Func`2<JavaScriptDictionary`2<TKey, TValue>, object>> dictionaryAdder);
    public abstract virtual void Patch(string id, Expression`1<Func`2<T, IDictionary`2<TKey, TValue>>> path, Expression`1<Func`2<JavaScriptDictionary`2<TKey, TValue>, object>> dictionaryAdder);
    public abstract virtual void AddOrPatch(string id, T entity, Expression`1<Func`2<T, TU>> path, TU value);
    public abstract virtual void AddOrPatch(string id, T entity, Expression`1<Func`2<T, List`1<TU>>> path, Expression`1<Func`2<JavaScriptArray`1<TU>, object>> arrayAdder);
    public abstract virtual void AddOrIncrement(string id, T entity, Expression`1<Func`2<T, TU>> path, TU valToAdd);
}
public interface Raven.Client.Documents.Session.IAsyncAdvancedDocumentsSessionOperations {
    public abstract virtual Task`1<IAsyncEnumerator`1<StreamResult`1<T>>> StreamAsync(IAsyncDocumentQuery`1<T> query, CancellationToken token);
    public abstract virtual Task`1<IAsyncEnumerator`1<StreamResult`1<T>>> StreamAsync(IAsyncDocumentQuery`1<T> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
    public abstract virtual Task`1<IAsyncEnumerator`1<StreamResult`1<T>>> StreamAsync(IAsyncRawDocumentQuery`1<T> query, CancellationToken token);
    public abstract virtual Task`1<IAsyncEnumerator`1<StreamResult`1<T>>> StreamAsync(IAsyncRawDocumentQuery`1<T> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
    public abstract virtual Task`1<IAsyncEnumerator`1<StreamResult`1<T>>> StreamAsync(IQueryable`1<T> query, CancellationToken token);
    public abstract virtual Task`1<IAsyncEnumerator`1<StreamResult`1<T>>> StreamAsync(IQueryable`1<T> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
    public abstract virtual Task`1<IAsyncEnumerator`1<StreamResult`1<T>>> StreamAsync(string startsWith, string matches, int start, int pageSize, string startAfter, CancellationToken token);
    public abstract virtual Task StreamIntoAsync(IAsyncDocumentQuery`1<T> query, Stream output, CancellationToken token);
    public abstract virtual Task StreamIntoAsync(IAsyncRawDocumentQuery`1<T> query, Stream output, CancellationToken token);
}
public interface Raven.Client.Documents.Session.IAsyncAdvancedSessionOperations {
    public IAsyncEagerSessionOperations Eagerly { get; }
    public IAsyncLazySessionOperations Lazily { get; }
    public IAttachmentsSessionOperationsAsync Attachments { get; }
    public IRevisionsSessionOperationsAsync Revisions { get; }
    public IClusterTransactionOperationsAsync ClusterTransaction { get; }
    public abstract virtual Task`1<ValueTuple`2<T, string>> ConditionalLoadAsync(string id, string changeVector, CancellationToken token);
    public abstract virtual IAsyncEagerSessionOperations get_Eagerly();
    public abstract virtual IAsyncLazySessionOperations get_Lazily();
    public abstract virtual IAttachmentsSessionOperationsAsync get_Attachments();
    public abstract virtual IRevisionsSessionOperationsAsync get_Revisions();
    public abstract virtual IClusterTransactionOperationsAsync get_ClusterTransaction();
    public abstract virtual Task RefreshAsync(T entity, CancellationToken token);
    public abstract virtual Task RefreshAsync(IEnumerable`1<T> entities, CancellationToken token);
    public abstract virtual IAsyncRawDocumentQuery`1<T> AsyncRawQuery(string query);
    public abstract virtual Task`1<bool> ExistsAsync(string id, CancellationToken token);
    public abstract virtual Task`1<IEnumerable`1<T>> LoadStartingWithAsync(string idPrefix, string matches, int start, int pageSize, string exclude, string startAfter, CancellationToken token);
    public abstract virtual Task LoadStartingWithIntoStreamAsync(string idPrefix, Stream output, string matches, int start, int pageSize, string exclude, string startAfter, CancellationToken token);
    public abstract virtual Task LoadIntoStreamAsync(IEnumerable`1<string> ids, Stream output, CancellationToken token);
    public abstract virtual void Increment(T entity, Expression`1<Func`2<T, U>> path, U valToAdd);
    public abstract virtual void Increment(string id, Expression`1<Func`2<T, U>> path, U valToAdd);
    public abstract virtual void Patch(string id, Expression`1<Func`2<T, U>> path, U value);
    public abstract virtual void Patch(T entity, Expression`1<Func`2<T, U>> path, U value);
    public abstract virtual void Patch(T entity, Expression`1<Func`2<T, IEnumerable`1<U>>> path, Expression`1<Func`2<JavaScriptArray`1<U>, object>> arrayAdder);
    public abstract virtual void Patch(string id, Expression`1<Func`2<T, IEnumerable`1<U>>> path, Expression`1<Func`2<JavaScriptArray`1<U>, object>> arrayAdder);
    public abstract virtual void Patch(T entity, Expression`1<Func`2<T, IDictionary`2<TKey, TValue>>> path, Expression`1<Func`2<JavaScriptDictionary`2<TKey, TValue>, object>> dictionaryAdder);
    public abstract virtual void Patch(string id, Expression`1<Func`2<T, IDictionary`2<TKey, TValue>>> path, Expression`1<Func`2<JavaScriptDictionary`2<TKey, TValue>, object>> dictionaryAdder);
    public abstract virtual void AddOrPatch(string id, T entity, Expression`1<Func`2<T, TU>> path, TU value);
    public abstract virtual void AddOrPatch(string id, T entity, Expression`1<Func`2<T, List`1<TU>>> path, Expression`1<Func`2<JavaScriptArray`1<TU>, object>> arrayAdder);
    public abstract virtual void AddOrIncrement(string id, T entity, Expression`1<Func`2<T, TU>> path, TU valToAdd);
}
public interface Raven.Client.Documents.Session.IAsyncDocumentQuery`1 {
    public string IndexName { get; }
    public bool IsDistinct { get; }
    public abstract virtual string get_IndexName();
    public abstract virtual bool get_IsDistinct();
    public abstract virtual Task`1<QueryResult> GetQueryResultAsync(CancellationToken token);
    public abstract virtual IAsyncDocumentQuery`1<TProjection> SelectFields(String[] fields);
    public abstract virtual IAsyncDocumentQuery`1<TProjection> SelectFields(ProjectionBehavior projectionBehavior, String[] fields);
    public abstract virtual IAsyncDocumentQuery`1<TProjection> SelectFields(QueryData queryData);
    public abstract virtual IAsyncDocumentQuery`1<TProjection> SelectFields();
    public abstract virtual IAsyncDocumentQuery`1<TProjection> SelectFields(ProjectionBehavior projectionBehavior);
    public abstract virtual IAsyncDocumentQuery`1<TTimeSeries> SelectTimeSeries(Func`2<ITimeSeriesQueryBuilder, TTimeSeries> timeSeriesQuery);
    public abstract virtual IAsyncDocumentQuery`1<TResult> OfType();
    public abstract virtual IAsyncGroupByDocumentQuery`1<T> GroupBy(string fieldName, String[] fieldNames);
    public abstract virtual IAsyncGroupByDocumentQuery`1<T> GroupBy(ValueTuple`2<string, GroupByMethod> field, ValueTuple`2[] fields);
    public abstract virtual IAsyncDocumentQuery`1<T> MoreLikeThis(Action`1<IMoreLikeThisBuilderForAsyncDocumentQuery`1<T>> builder);
    public abstract virtual IAsyncDocumentQuery`1<T> Filter(Action`1<IFilterFactory`1<T>> builder, int limit);
    public abstract virtual IAsyncAggregationDocumentQuery`1<T> AggregateBy(Action`1<IFacetBuilder`1<T>> builder);
    public abstract virtual IAsyncAggregationDocumentQuery`1<T> AggregateBy(FacetBase facet);
    public abstract virtual IAsyncAggregationDocumentQuery`1<T> AggregateBy(IEnumerable`1<FacetBase> facets);
    public abstract virtual IAsyncAggregationDocumentQuery`1<T> AggregateUsing(string facetSetupDocumentId);
    public abstract virtual IAsyncSuggestionDocumentQuery`1<T> SuggestUsing(SuggestionBase suggestion);
    public abstract virtual IAsyncSuggestionDocumentQuery`1<T> SuggestUsing(Action`1<ISuggestionBuilder`1<T>> builder);
    public abstract virtual IRavenQueryable`1<T> ToQueryable();
    public abstract virtual IAsyncDocumentQuery`1<T> ShardContext(Action`1<IQueryShardedContextBuilder> builder);
}
public interface Raven.Client.Documents.Session.IAsyncDocumentQueryBase`1 {
    public abstract virtual Lazy`1<Task`1<int>> CountLazilyAsync(CancellationToken token);
    public abstract virtual Lazy`1<Task`1<long>> LongCountLazilyAsync(CancellationToken token);
    public abstract virtual Task`1<List`1<T>> ToListAsync(CancellationToken token);
    public abstract virtual Task`1<T[]> ToArrayAsync(CancellationToken token);
    public abstract virtual Task`1<T> FirstAsync(CancellationToken token);
    public abstract virtual Task`1<T> FirstOrDefaultAsync(CancellationToken token);
    public abstract virtual Task`1<T> SingleAsync(CancellationToken token);
    public abstract virtual Task`1<T> SingleOrDefaultAsync(CancellationToken token);
    public abstract virtual Task`1<bool> AnyAsync(CancellationToken token);
    public abstract virtual Task`1<int> CountAsync(CancellationToken token);
    public abstract virtual Task`1<long> LongCountAsync(CancellationToken token);
    public abstract virtual Lazy`1<Task`1<IEnumerable`1<T>>> LazilyAsync(Action`1<IEnumerable`1<T>> onEval);
}
public interface Raven.Client.Documents.Session.IAsyncDocumentQueryBuilder {
    public abstract virtual IAsyncDocumentQuery`1<T> AsyncDocumentQuery();
    public abstract virtual IAsyncDocumentQuery`1<T> AsyncDocumentQuery(string indexName, string collectionName, bool isMapReduce);
}
public interface Raven.Client.Documents.Session.IAsyncDocumentSession {
    public IAsyncAdvancedSessionOperations Advanced { get; }
    public abstract virtual IAsyncSessionDocumentCounters CountersFor(string documentId);
    public abstract virtual IAsyncSessionDocumentCounters CountersFor(object entity);
    public abstract virtual IAsyncAdvancedSessionOperations get_Advanced();
    public abstract virtual void Delete(T entity);
    public abstract virtual void Delete(string id);
    public abstract virtual void Delete(string id, string expectedChangeVector);
    public abstract virtual Task SaveChangesAsync(CancellationToken token);
    public abstract virtual Task StoreAsync(object entity, CancellationToken token);
    public abstract virtual Task StoreAsync(object entity, string changeVector, string id, CancellationToken token);
    public abstract virtual Task StoreAsync(object entity, string id, CancellationToken token);
    public abstract virtual IAsyncLoaderWithInclude`1<object> Include(string path);
    public abstract virtual IAsyncLoaderWithInclude`1<T> Include(Expression`1<Func`2<T, string>> path);
    public abstract virtual IAsyncLoaderWithInclude`1<T> Include(Expression`1<Func`2<T, string>> path);
    public abstract virtual IAsyncLoaderWithInclude`1<T> Include(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    public abstract virtual IAsyncLoaderWithInclude`1<T> Include(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    public abstract virtual Task`1<T> LoadAsync(string id, CancellationToken token);
    public abstract virtual Task`1<Dictionary`2<string, T>> LoadAsync(IEnumerable`1<string> ids, CancellationToken token);
    public abstract virtual Task`1<T> LoadAsync(string id, Action`1<IIncludeBuilder`1<T>> includes, CancellationToken token);
    public abstract virtual Task`1<Dictionary`2<string, T>> LoadAsync(IEnumerable`1<string> ids, Action`1<IIncludeBuilder`1<T>> includes, CancellationToken token);
    public abstract virtual IRavenQueryable`1<T> Query(string indexName, string collectionName, bool isMapReduce);
    public abstract virtual IRavenQueryable`1<T> Query();
    public abstract virtual IAsyncSessionDocumentTimeSeries TimeSeriesFor(string documentId, string name);
    public abstract virtual IAsyncSessionDocumentTimeSeries TimeSeriesFor(object entity, string name);
    public abstract virtual IAsyncSessionDocumentTypedTimeSeries`1<TValues> TimeSeriesFor(string documentId, string name);
    public abstract virtual IAsyncSessionDocumentTypedTimeSeries`1<TValues> TimeSeriesFor(object entity, string name);
    public abstract virtual IAsyncSessionDocumentRollupTypedTimeSeries`1<TValues> TimeSeriesRollupFor(object entity, string policy, string raw);
    public abstract virtual IAsyncSessionDocumentRollupTypedTimeSeries`1<TValues> TimeSeriesRollupFor(string documentId, string policy, string raw);
    public abstract virtual IAsyncSessionDocumentIncrementalTimeSeries IncrementalTimeSeriesFor(string documentId, string name);
    public abstract virtual IAsyncSessionDocumentIncrementalTimeSeries IncrementalTimeSeriesFor(object entity, string name);
    public abstract virtual IAsyncSessionDocumentTypedIncrementalTimeSeries`1<TValues> IncrementalTimeSeriesFor(string documentId, string name);
    public abstract virtual IAsyncSessionDocumentTypedIncrementalTimeSeries`1<TValues> IncrementalTimeSeriesFor(object entity, string name);
}
internal interface Raven.Client.Documents.Session.IAsyncDocumentSessionImpl {
    public DocumentConventions Conventions { get; }
    public abstract virtual DocumentConventions get_Conventions();
    public abstract virtual Task`1<Dictionary`2<string, T>> LoadAsyncInternal(String[] ids, String[] includes, String[] counterIncludes, bool includeAllCounters, IEnumerable`1<AbstractTimeSeriesRange> timeSeriesIncludes, String[] compareExchangeValueIncludes, String[] revisionIncludes, Nullable`1<DateTime> revisionIncludeByDateTimeBefore, CancellationToken token);
    public abstract virtual Lazy`1<Task`1<Dictionary`2<string, T>>> LazyAsyncLoadInternal(String[] ids, String[] includes, Action`1<Dictionary`2<string, T>> onEval, CancellationToken token);
}
public interface Raven.Client.Documents.Session.IAsyncGroupByDocumentQuery`1 {
    public abstract virtual IAsyncGroupByDocumentQuery`1<T> SelectKey(string fieldName, string projectedName);
    public abstract virtual IAsyncDocumentQuery`1<T> SelectSum(GroupByField field, GroupByField[] fields);
    public abstract virtual IAsyncDocumentQuery`1<T> SelectCount(string projectedName);
    public abstract virtual IAsyncGroupByDocumentQuery`1<T> Filter(Action`1<IFilterFactory`1<T>> builder, int limit);
}
public interface Raven.Client.Documents.Session.IAsyncRawDocumentQuery`1 {
    public abstract virtual IAsyncRawDocumentQuery`1<T> Projection(ProjectionBehavior projectionBehavior);
    public abstract virtual Task`1<Dictionary`2<string, FacetResult>> ExecuteAggregationAsync(CancellationToken token);
}
public interface Raven.Client.Documents.Session.IAsyncSessionDocumentCounters {
    public abstract virtual Task`1<Dictionary`2<string, Nullable`1<long>>> GetAllAsync(CancellationToken token);
    public abstract virtual Task`1<Nullable`1<long>> GetAsync(string counter, CancellationToken token);
    public abstract virtual Task`1<Dictionary`2<string, Nullable`1<long>>> GetAsync(IEnumerable`1<string> counters, CancellationToken token);
}
public interface Raven.Client.Documents.Session.IAsyncSessionDocumentIncrementalTimeSeries {
    public abstract virtual Task`1<TimeSeriesEntry[]> GetAsync(Nullable`1<DateTime> from, Nullable`1<DateTime> to, int start, int pageSize, CancellationToken token);
    public abstract virtual Task`1<TimeSeriesEntry[]> GetAsync(Nullable`1<DateTime> from, Nullable`1<DateTime> to, Action`1<ITimeSeriesIncludeBuilder> includes, int start, int pageSize, CancellationToken token);
}
public interface Raven.Client.Documents.Session.IAsyncSessionDocumentRollupTypedTimeSeries`1 {
    public abstract virtual Task`1<TimeSeriesRollupEntry`1[]> GetAsync(Nullable`1<DateTime> from, Nullable`1<DateTime> to, int start, int pageSize, CancellationToken token);
}
public interface Raven.Client.Documents.Session.IAsyncSessionDocumentTimeSeries {
    public abstract virtual Task`1<TimeSeriesEntry[]> GetAsync(Nullable`1<DateTime> from, Nullable`1<DateTime> to, int start, int pageSize, CancellationToken token);
    public abstract virtual Task`1<TimeSeriesEntry[]> GetAsync(Nullable`1<DateTime> from, Nullable`1<DateTime> to, Action`1<ITimeSeriesIncludeBuilder> includes, int start, int pageSize, CancellationToken token);
}
public interface Raven.Client.Documents.Session.IAsyncSessionDocumentTypedIncrementalTimeSeries`1 {
    public abstract virtual Task`1<TimeSeriesEntry`1[]> GetAsync(Nullable`1<DateTime> from, Nullable`1<DateTime> to, int start, int pageSize, CancellationToken token);
}
public interface Raven.Client.Documents.Session.IAsyncSessionDocumentTypedTimeSeries`1 {
    public abstract virtual Task`1<TimeSeriesEntry`1[]> GetAsync(Nullable`1<DateTime> from, Nullable`1<DateTime> to, int start, int pageSize, CancellationToken token);
}
public interface Raven.Client.Documents.Session.IAsyncTimeSeriesSessionStreamAggregationResultOperations {
    public abstract virtual Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult`1<T>>>> StreamAsync(IQueryable`1<TimeSeriesAggregationResult`1<T>> query, CancellationToken token);
    public abstract virtual Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult`1<T>>>> StreamAsync(IQueryable`1<TimeSeriesAggregationResult`1<T>> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
    public abstract virtual Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult`1<T>>>> StreamAsync(IAsyncDocumentQuery`1<TimeSeriesAggregationResult`1<T>> query, CancellationToken token);
    public abstract virtual Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult`1<T>>>> StreamAsync(IAsyncRawDocumentQuery`1<TimeSeriesAggregationResult`1<T>> query, CancellationToken token);
    public abstract virtual Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult`1<T>>>> StreamAsync(IAsyncRawDocumentQuery`1<TimeSeriesAggregationResult`1<T>> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
    public abstract virtual Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult`1<T>>>> StreamAsync(IAsyncDocumentQuery`1<TimeSeriesAggregationResult`1<T>> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
}
public interface Raven.Client.Documents.Session.IAsyncTimeSeriesSessionStreamOperations`1 {
    public abstract virtual Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<T>>> StreamAsync(IQueryable`1<T> query, CancellationToken token);
    public abstract virtual Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<T>>> StreamAsync(IQueryable`1<T> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
    public abstract virtual Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<T>>> StreamAsync(IAsyncDocumentQuery`1<T> query, CancellationToken token);
    public abstract virtual Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<T>>> StreamAsync(IAsyncRawDocumentQuery`1<T> query, CancellationToken token);
    public abstract virtual Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<T>>> StreamAsync(IAsyncRawDocumentQuery`1<T> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
    public abstract virtual Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<T>>> StreamAsync(IAsyncDocumentQuery`1<T> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
}
public interface Raven.Client.Documents.Session.IAsyncTimeSeriesSessionStreamRawResultOperations {
    public abstract virtual Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult`1<T>>>> StreamAsync(IQueryable`1<TimeSeriesRawResult`1<T>> query, CancellationToken token);
    public abstract virtual Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult`1<T>>>> StreamAsync(IQueryable`1<TimeSeriesRawResult`1<T>> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
    public abstract virtual Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult`1<T>>>> StreamAsync(IAsyncDocumentQuery`1<TimeSeriesRawResult`1<T>> query, CancellationToken token);
    public abstract virtual Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult`1<T>>>> StreamAsync(IAsyncRawDocumentQuery`1<TimeSeriesRawResult`1<T>> query, CancellationToken token);
    public abstract virtual Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult`1<T>>>> StreamAsync(IAsyncRawDocumentQuery`1<TimeSeriesRawResult`1<T>> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
    public abstract virtual Task`1<IAsyncEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult`1<T>>>> StreamAsync(IAsyncDocumentQuery`1<TimeSeriesRawResult`1<T>> query, StreamQueryStatistics& streamQueryStats, CancellationToken token);
}
public interface Raven.Client.Documents.Session.IAsyncTimeSeriesStreamingBase`1 {
    public abstract virtual Task`1<IAsyncEnumerator`1<T>> StreamAsync(Nullable`1<DateTime> from, Nullable`1<DateTime> to, Nullable`1<TimeSpan> offset, CancellationToken token);
}
public interface Raven.Client.Documents.Session.IAttachmentsSessionOperations {
    public abstract virtual bool Exists(string documentId, string name);
    public abstract virtual AttachmentResult Get(string documentId, string name);
    public abstract virtual AttachmentResult Get(object entity, string name);
    public abstract virtual IEnumerator`1<AttachmentEnumeratorResult> Get(IEnumerable`1<AttachmentRequest> attachments);
    public abstract virtual AttachmentResult GetRevision(string documentId, string name, string changeVector);
}
public interface Raven.Client.Documents.Session.IAttachmentsSessionOperationsAsync {
    public abstract virtual Task`1<bool> ExistsAsync(string documentId, string name, CancellationToken token);
    public abstract virtual Task`1<AttachmentResult> GetAsync(string documentId, string name, CancellationToken token);
    public abstract virtual Task`1<AttachmentResult> GetAsync(object entity, string name, CancellationToken token);
    public abstract virtual Task`1<IEnumerator`1<AttachmentEnumeratorResult>> GetAsync(IEnumerable`1<AttachmentRequest> attachments, CancellationToken token);
    public abstract virtual Task`1<AttachmentResult> GetRevisionAsync(string documentId, string name, string changeVector, CancellationToken token);
}
public interface Raven.Client.Documents.Session.IAttachmentsSessionOperationsBase {
    public abstract virtual AttachmentName[] GetNames(object entity);
    public abstract virtual void Store(string documentId, string name, Stream stream, string contentType);
    public abstract virtual void Store(object entity, string name, Stream stream, string contentType);
    public abstract virtual void Delete(string documentId, string name);
    public abstract virtual void Delete(object entity, string name);
    public abstract virtual void Rename(object entity, string name, string newName);
    public abstract virtual void Rename(string documentId, string name, string newName);
    public abstract virtual void Copy(object sourceEntity, string sourceName, object destinationEntity, string destinationName);
    public abstract virtual void Copy(string sourceDocumentId, string sourceName, string destinationDocumentId, string destinationName);
    public abstract virtual void Move(object sourceEntity, string sourceName, object destinationEntity, string destinationName);
    public abstract virtual void Move(string sourceDocumentId, string sourceName, string destinationDocumentId, string destinationName);
}
public interface Raven.Client.Documents.Session.IClusterTransactionOperations {
    public ILazyClusterTransactionOperations Lazily { get; }
    public abstract virtual CompareExchangeValue`1<T> GetCompareExchangeValue(string key);
    public abstract virtual Dictionary`2<string, CompareExchangeValue`1<T>> GetCompareExchangeValues(String[] keys);
    public abstract virtual Dictionary`2<string, CompareExchangeValue`1<T>> GetCompareExchangeValues(string startsWith, int start, int pageSize);
    public abstract virtual ILazyClusterTransactionOperations get_Lazily();
}
public interface Raven.Client.Documents.Session.IClusterTransactionOperationsAsync {
    public ILazyClusterTransactionOperationsAsync Lazily { get; }
    public abstract virtual Task`1<CompareExchangeValue`1<T>> GetCompareExchangeValueAsync(string key, CancellationToken token);
    public abstract virtual Task`1<Dictionary`2<string, CompareExchangeValue`1<T>>> GetCompareExchangeValuesAsync(String[] keys, CancellationToken token);
    public abstract virtual Task`1<Dictionary`2<string, CompareExchangeValue`1<T>>> GetCompareExchangeValuesAsync(string startsWith, int start, int pageSize, CancellationToken token);
    public abstract virtual ILazyClusterTransactionOperationsAsync get_Lazily();
}
public interface Raven.Client.Documents.Session.IClusterTransactionOperationsBase {
    public abstract virtual void DeleteCompareExchangeValue(string key, long index);
    public abstract virtual void DeleteCompareExchangeValue(CompareExchangeValue`1<T> item);
    public abstract virtual CompareExchangeValue`1<T> CreateCompareExchangeValue(string key, T value);
}
public interface Raven.Client.Documents.Session.IDocumentQuery`1 {
    public string IndexName { get; }
    public bool IsDistinct { get; }
    public abstract virtual string get_IndexName();
    public abstract virtual bool get_IsDistinct();
    public abstract virtual IRavenQueryable`1<T> ToQueryable();
    public abstract virtual QueryResult GetQueryResult();
    public abstract virtual IDocumentQuery`1<TProjection> SelectFields(String[] fields);
    public abstract virtual IDocumentQuery`1<TProjection> SelectFields(ProjectionBehavior projectionBehavior, String[] fields);
    public abstract virtual IDocumentQuery`1<TProjection> SelectFields(QueryData queryData);
    public abstract virtual IDocumentQuery`1<TProjection> SelectFields();
    public abstract virtual IDocumentQuery`1<TProjection> SelectFields(ProjectionBehavior projectionBehavior);
    public abstract virtual IDocumentQuery`1<TTimeSeries> SelectTimeSeries(Func`2<ITimeSeriesQueryBuilder, TTimeSeries> timeSeriesQuery);
    public abstract virtual IDocumentQuery`1<TResult> OfType();
    public abstract virtual IGroupByDocumentQuery`1<T> GroupBy(string fieldName, String[] fieldNames);
    public abstract virtual IGroupByDocumentQuery`1<T> GroupBy(ValueTuple`2<string, GroupByMethod> field, ValueTuple`2[] fields);
    public abstract virtual IDocumentQuery`1<T> MoreLikeThis(Action`1<IMoreLikeThisBuilderForDocumentQuery`1<T>> builder);
    public abstract virtual IDocumentQuery`1<T> Filter(Action`1<IFilterFactory`1<T>> builder, int limit);
    public abstract virtual IAggregationDocumentQuery`1<T> AggregateBy(Action`1<IFacetBuilder`1<T>> builder);
    public abstract virtual IAggregationDocumentQuery`1<T> AggregateBy(FacetBase facet);
    public abstract virtual IAggregationDocumentQuery`1<T> AggregateBy(IEnumerable`1<FacetBase> facets);
    public abstract virtual IAggregationDocumentQuery`1<T> AggregateUsing(string facetSetupDocumentId);
    public abstract virtual ISuggestionDocumentQuery`1<T> SuggestUsing(SuggestionBase suggestion);
    public abstract virtual ISuggestionDocumentQuery`1<T> SuggestUsing(Action`1<ISuggestionBuilder`1<T>> builder);
    public abstract virtual IDocumentQuery`1<T> ShardContext(Action`1<IQueryShardedContextBuilder> builder);
}
public interface Raven.Client.Documents.Session.IDocumentQueryBase`1 {
    public abstract virtual Lazy`1<int> CountLazily();
    public abstract virtual Lazy`1<long> LongCountLazily();
    public abstract virtual List`1<T> ToList();
    public abstract virtual T[] ToArray();
    public abstract virtual T First();
    public abstract virtual T FirstOrDefault();
    public abstract virtual T Single();
    public abstract virtual T SingleOrDefault();
    public abstract virtual bool Any();
    public abstract virtual int Count();
    public abstract virtual long LongCount();
    public abstract virtual Lazy`1<IEnumerable`1<T>> Lazily(Action`1<IEnumerable`1<T>> onEval);
}
public interface Raven.Client.Documents.Session.IDocumentQueryBase`2 {
    public abstract virtual TSelf AddOrder(string fieldName, bool descending, OrderingType ordering);
    public abstract virtual TSelf AddOrder(Expression`1<Func`2<T, TValue>> propertySelector, bool descending, OrderingType ordering);
    public abstract virtual TSelf Boost(decimal boost);
    [ObsoleteAttribute("
You cannot issue an in memory filter - such as Count(x=>x.Name == "Ayende") - on IDocumentQuery. 
This is likely a bug, because this will execute the filter in memory, rather than in RavenDB.
Consider using session.Query<T>() instead of session.DocumentQuery<T>. The session.Query<T>() method fully supports Linq queries, while session.DocumentQuery<T>() is intended for lower level API access.
If you really want to do in memory filtering on the data returned from the query, you can use: session.DocumentQuery<T>().ToList().Count(x=>x.Name == "Ayende")
", "True")]
public abstract virtual int Count(Func`2<T, bool> predicate);
    public abstract virtual TSelf Distinct();
    public abstract virtual TSelf IncludeExplanations(Explanations& explanations);
    public abstract virtual TSelf IncludeExplanations(ExplanationOptions options, Explanations& explanations);
    public abstract virtual TSelf Fuzzy(decimal fuzzy);
    public abstract virtual TSelf Highlight(string fieldName, int fragmentLength, int fragmentCount, Highlightings& highlightings);
    public abstract virtual TSelf Highlight(string fieldName, int fragmentLength, int fragmentCount, HighlightingOptions options, Highlightings& highlightings);
    public abstract virtual TSelf Highlight(Expression`1<Func`2<T, object>> path, int fragmentLength, int fragmentCount, Highlightings& highlightings);
    public abstract virtual TSelf Highlight(Expression`1<Func`2<T, object>> path, int fragmentLength, int fragmentCount, HighlightingOptions options, Highlightings& highlightings);
    public abstract virtual TSelf Include(string path);
    public abstract virtual TSelf Include(Expression`1<Func`2<T, object>> path);
    public abstract virtual TSelf Intersect();
    public abstract virtual TSelf OrderBy(string field, string sorterName);
    public abstract virtual TSelf OrderBy(string field, OrderingType ordering);
    public abstract virtual TSelf OrderBy(Expression`1<Func`2<T, TValue>> propertySelector);
    public abstract virtual TSelf OrderBy(Expression`1<Func`2<T, TValue>> propertySelector, string sorterName);
    public abstract virtual TSelf OrderBy(Expression`1<Func`2<T, TValue>> propertySelector, OrderingType ordering);
    public abstract virtual TSelf OrderBy(Expression`1[] propertySelectors);
    public abstract virtual TSelf OrderByDescending(string field, string sorterName);
    public abstract virtual TSelf OrderByDescending(string field, OrderingType ordering);
    public abstract virtual TSelf OrderByDescending(Expression`1<Func`2<T, TValue>> propertySelector);
    public abstract virtual TSelf OrderByDescending(Expression`1<Func`2<T, TValue>> propertySelector, string sorterName);
    public abstract virtual TSelf OrderByDescending(Expression`1<Func`2<T, TValue>> propertySelector, OrderingType ordering);
    public abstract virtual TSelf OrderByDescending(Expression`1[] propertySelectors);
    public abstract virtual TSelf OrderByScore();
    public abstract virtual TSelf OrderByScoreDescending();
    public abstract virtual TSelf Proximity(int proximity);
    public abstract virtual TSelf RandomOrdering();
    public abstract virtual TSelf RandomOrdering(string seed);
    public abstract virtual TSelf OrderByDistance(DynamicSpatialField field, double latitude, double longitude);
    public abstract virtual TSelf OrderByDistance(Func`2<DynamicSpatialFieldFactory`1<T>, DynamicSpatialField> field, double latitude, double longitude);
    public abstract virtual TSelf OrderByDistance(DynamicSpatialField field, string shapeWkt);
    public abstract virtual TSelf OrderByDistance(Func`2<DynamicSpatialFieldFactory`1<T>, DynamicSpatialField> field, string shapeWkt);
    public abstract virtual TSelf OrderByDistance(Expression`1<Func`2<T, object>> propertySelector, double latitude, double longitude);
    public abstract virtual TSelf OrderByDistance(Expression`1<Func`2<T, object>> propertySelector, double latitude, double longitude, double roundFactor);
    public abstract virtual TSelf OrderByDistance(string fieldName, double latitude, double longitude);
    public abstract virtual TSelf OrderByDistance(string fieldName, double latitude, double longitude, double roundFactor);
    public abstract virtual TSelf OrderByDistance(Expression`1<Func`2<T, object>> propertySelector, string shapeWkt);
    public abstract virtual TSelf OrderByDistance(Expression`1<Func`2<T, object>> propertySelector, string shapeWkt, double roundFactor);
    public abstract virtual TSelf OrderByDistance(string fieldName, string shapeWkt);
    public abstract virtual TSelf OrderByDistance(string fieldName, string shapeWkt, double roundFactor);
    public abstract virtual TSelf OrderByDistanceDescending(DynamicSpatialField field, double latitude, double longitude);
    public abstract virtual TSelf OrderByDistanceDescending(Func`2<DynamicSpatialFieldFactory`1<T>, DynamicSpatialField> field, double latitude, double longitude);
    public abstract virtual TSelf OrderByDistanceDescending(DynamicSpatialField field, string shapeWkt);
    public abstract virtual TSelf OrderByDistanceDescending(Func`2<DynamicSpatialFieldFactory`1<T>, DynamicSpatialField> field, string shapeWkt);
    public abstract virtual TSelf OrderByDistanceDescending(Expression`1<Func`2<T, object>> propertySelector, double latitude, double longitude);
    public abstract virtual TSelf OrderByDistanceDescending(Expression`1<Func`2<T, object>> propertySelector, double latitude, double longitude, double roundFactor);
    public abstract virtual TSelf OrderByDistanceDescending(string fieldName, double latitude, double longitude);
    public abstract virtual TSelf OrderByDistanceDescending(string fieldName, double latitude, double longitude, double roundFactor);
    public abstract virtual TSelf OrderByDistanceDescending(Expression`1<Func`2<T, object>> propertySelector, string shapeWkt);
    public abstract virtual TSelf OrderByDistanceDescending(Expression`1<Func`2<T, object>> propertySelector, string shapeWkt, double roundFactor);
    public abstract virtual TSelf OrderByDistanceDescending(string fieldName, string shapeWkt);
    public abstract virtual TSelf OrderByDistanceDescending(string fieldName, string shapeWkt, double roundFactor);
}
public interface Raven.Client.Documents.Session.IDocumentQueryBuilder {
    public abstract virtual IDocumentQuery`1<T> DocumentQuery();
    public abstract virtual IDocumentQuery`1<T> DocumentQuery(string indexName, string collectionName, bool isMapReduce);
}
public interface Raven.Client.Documents.Session.IDocumentQueryCustomization {
    public QueryOperation QueryOperation { get; }
    public abstract virtual QueryOperation get_QueryOperation();
    public abstract virtual IDocumentQueryCustomization BeforeQueryExecuted(Action`1<IndexQuery> action);
    public abstract virtual IDocumentQueryCustomization AfterQueryExecuted(Action`1<QueryResult> action);
    public abstract virtual IDocumentQueryCustomization AfterStreamExecuted(Action`1<BlittableJsonReaderObject> action);
    public abstract virtual IDocumentQueryCustomization NoCaching();
    public abstract virtual IDocumentQueryCustomization NoTracking();
    public abstract virtual IDocumentQueryCustomization RandomOrdering();
    public abstract virtual IDocumentQueryCustomization RandomOrdering(string seed);
    public abstract virtual IDocumentQueryCustomization Timings(QueryTimings& timings);
    public abstract virtual IDocumentQueryCustomization WaitForNonStaleResults(Nullable`1<TimeSpan> waitTimeout);
    public abstract virtual IDocumentQueryCustomization Projection(ProjectionBehavior projectionBehavior);
    public abstract virtual IDocumentQueryCustomization ShardContext(Action`1<IQueryShardedContextBuilder> builder);
}
public interface Raven.Client.Documents.Session.IDocumentSession {
    public IAdvancedSessionOperations Advanced { get; }
    public abstract virtual ISessionDocumentCounters CountersFor(string documentId);
    public abstract virtual ISessionDocumentCounters CountersFor(object entity);
    public abstract virtual IAdvancedSessionOperations get_Advanced();
    public abstract virtual void Delete(T entity);
    public abstract virtual void Delete(string id);
    public abstract virtual void Delete(string id, string expectedChangeVector);
    public abstract virtual void SaveChanges();
    public abstract virtual void Store(object entity, string changeVector, string id);
    public abstract virtual void Store(object entity);
    public abstract virtual void Store(object entity, string id);
    public abstract virtual ILoaderWithInclude`1<object> Include(string path);
    public abstract virtual ILoaderWithInclude`1<T> Include(Expression`1<Func`2<T, string>> path);
    public abstract virtual ILoaderWithInclude`1<T> Include(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    public abstract virtual ILoaderWithInclude`1<T> Include(Expression`1<Func`2<T, string>> path);
    public abstract virtual ILoaderWithInclude`1<T> Include(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    public abstract virtual T Load(string id);
    public abstract virtual Dictionary`2<string, T> Load(IEnumerable`1<string> ids);
    public abstract virtual T Load(string id, Action`1<IIncludeBuilder`1<T>> includes);
    public abstract virtual Dictionary`2<string, T> Load(IEnumerable`1<string> ids, Action`1<IIncludeBuilder`1<T>> includes);
    public abstract virtual IRavenQueryable`1<T> Query(string indexName, string collectionName, bool isMapReduce);
    public abstract virtual IRavenQueryable`1<T> Query();
    public abstract virtual ISessionDocumentTimeSeries TimeSeriesFor(string documentId, string name);
    public abstract virtual ISessionDocumentTimeSeries TimeSeriesFor(object entity, string name);
    public abstract virtual ISessionDocumentTypedTimeSeries`1<TValues> TimeSeriesFor(object entity, string name);
    public abstract virtual ISessionDocumentTypedTimeSeries`1<TValues> TimeSeriesFor(string documentId, string name);
    public abstract virtual ISessionDocumentRollupTypedTimeSeries`1<TValues> TimeSeriesRollupFor(object entity, string policy, string raw);
    public abstract virtual ISessionDocumentRollupTypedTimeSeries`1<TValues> TimeSeriesRollupFor(string documentId, string policy, string raw);
    public abstract virtual ISessionDocumentIncrementalTimeSeries IncrementalTimeSeriesFor(string documentId, string name);
    public abstract virtual ISessionDocumentIncrementalTimeSeries IncrementalTimeSeriesFor(object entity, string name);
    public abstract virtual ISessionDocumentTypedIncrementalTimeSeries`1<TValues> IncrementalTimeSeriesFor(object entity, string name);
    public abstract virtual ISessionDocumentTypedIncrementalTimeSeries`1<TValues> IncrementalTimeSeriesFor(string documentId, string name);
}
internal interface Raven.Client.Documents.Session.IDocumentSessionImpl {
    public DocumentConventions Conventions { get; }
    public abstract virtual DocumentConventions get_Conventions();
    public abstract virtual Dictionary`2<string, T> LoadInternal(String[] ids, String[] includes, String[] counterIncludes, bool includeAllCounters, IEnumerable`1<AbstractTimeSeriesRange> timeSeriesIncludes, String[] compareExchangeValueIncludes, String[] revisionIncludes, Nullable`1<DateTime> revisionIncludeByDateTimeBefore);
    public abstract virtual Lazy`1<Dictionary`2<string, T>> LazyLoadInternal(String[] ids, String[] includes, Action`1<Dictionary`2<string, T>> onEval);
}
public interface Raven.Client.Documents.Session.IDocumentsSessionOperations {
    public abstract virtual IEnumerator`1<StreamResult`1<T>> Stream(IQueryable`1<T> query);
    public abstract virtual IEnumerator`1<StreamResult`1<T>> Stream(IQueryable`1<T> query, StreamQueryStatistics& streamQueryStats);
    public abstract virtual IEnumerator`1<StreamResult`1<T>> Stream(IDocumentQuery`1<T> query);
    public abstract virtual IEnumerator`1<StreamResult`1<T>> Stream(IRawDocumentQuery`1<T> query);
    public abstract virtual IEnumerator`1<StreamResult`1<T>> Stream(IRawDocumentQuery`1<T> query, StreamQueryStatistics& streamQueryStats);
    public abstract virtual IEnumerator`1<StreamResult`1<T>> Stream(IDocumentQuery`1<T> query, StreamQueryStatistics& streamQueryStats);
    public abstract virtual IEnumerator`1<StreamResult`1<T>> Stream(string startsWith, string matches, int start, int pageSize, string startAfter);
    public abstract virtual void StreamInto(IDocumentQuery`1<T> query, Stream output);
    public abstract virtual void StreamInto(IRawDocumentQuery`1<T> query, Stream output);
}
public interface Raven.Client.Documents.Session.IFilterDocumentQueryBase`2 {
    public TSelf Not { get; }
    public abstract virtual TSelf get_Not();
    public abstract virtual TSelf AndAlso();
    public abstract virtual TSelf AndAlso(bool wrapPreviousQueryClauses);
    public abstract virtual TSelf CloseSubclause();
    public abstract virtual TSelf ContainsAll(string fieldName, IEnumerable`1<object> values);
    public abstract virtual TSelf ContainsAll(Expression`1<Func`2<T, TValue>> propertySelector, IEnumerable`1<TValue> values);
    public abstract virtual TSelf ContainsAll(Expression`1<Func`2<T, IEnumerable`1<TValue>>> propertySelector, IEnumerable`1<TValue> values);
    public abstract virtual TSelf ContainsAny(string fieldName, IEnumerable`1<object> values);
    public abstract virtual TSelf ContainsAny(Expression`1<Func`2<T, TValue>> propertySelector, IEnumerable`1<TValue> values);
    public abstract virtual TSelf ContainsAny(Expression`1<Func`2<T, IEnumerable`1<TValue>>> propertySelector, IEnumerable`1<TValue> values);
    public abstract virtual TSelf NegateNext();
    public abstract virtual TSelf OpenSubclause();
    public abstract virtual TSelf OrElse();
    public abstract virtual TSelf Search(string fieldName, string searchTerms, SearchOperator operator);
    public abstract virtual TSelf Search(Expression`1<Func`2<T, TValue>> propertySelector, string searchTerms, SearchOperator operator);
    public abstract virtual IEnumerable`1<T> Where(Func`2<T, bool> predicate);
    public abstract virtual TSelf WhereLucene(string fieldName, string whereClause);
    public abstract virtual TSelf WhereLucene(string fieldName, string whereClause, bool exact);
    public abstract virtual TSelf WhereBetween(string fieldName, object start, object end, bool exact);
    public abstract virtual TSelf WhereBetween(Expression`1<Func`2<T, TValue>> propertySelector, TValue start, TValue end, bool exact);
    public abstract virtual TSelf WhereEndsWith(string fieldName, object value);
    public abstract virtual TSelf WhereEndsWith(string fieldName, object value, bool exact);
    public abstract virtual TSelf WhereEndsWith(Expression`1<Func`2<T, TValue>> propertySelector, TValue value);
    public abstract virtual TSelf WhereEndsWith(Expression`1<Func`2<T, TValue>> propertySelector, TValue value, bool exact);
    public abstract virtual TSelf WhereEquals(string fieldName, object value, bool exact);
    public abstract virtual TSelf WhereEquals(string fieldName, MethodCall value, bool exact);
    public abstract virtual TSelf WhereEquals(Expression`1<Func`2<T, TValue>> propertySelector, TValue value, bool exact);
    public abstract virtual TSelf WhereEquals(Expression`1<Func`2<T, TValue>> propertySelector, MethodCall value, bool exact);
    public abstract virtual TSelf WhereEquals(WhereParams whereParams);
    public abstract virtual TSelf WhereNotEquals(string fieldName, object value, bool exact);
    public abstract virtual TSelf WhereNotEquals(string fieldName, MethodCall value, bool exact);
    public abstract virtual TSelf WhereNotEquals(Expression`1<Func`2<T, TValue>> propertySelector, TValue value, bool exact);
    public abstract virtual TSelf WhereNotEquals(Expression`1<Func`2<T, TValue>> propertySelector, MethodCall value, bool exact);
    public abstract virtual TSelf WhereNotEquals(WhereParams whereParams);
    public abstract virtual TSelf WhereGreaterThan(string fieldName, object value, bool exact);
    public abstract virtual TSelf WhereGreaterThan(Expression`1<Func`2<T, TValue>> propertySelector, TValue value, bool exact);
    public abstract virtual TSelf WhereGreaterThanOrEqual(string fieldName, object value, bool exact);
    public abstract virtual TSelf WhereGreaterThanOrEqual(Expression`1<Func`2<T, TValue>> propertySelector, TValue value, bool exact);
    public abstract virtual TSelf WhereIn(string fieldName, IEnumerable`1<object> values, bool exact);
    public abstract virtual TSelf WhereIn(Expression`1<Func`2<T, TValue>> propertySelector, IEnumerable`1<TValue> values, bool exact);
    public abstract virtual TSelf WhereLessThan(string fieldName, object value, bool exact);
    public abstract virtual TSelf WhereLessThan(Expression`1<Func`2<T, TValue>> propertySelector, TValue value, bool exact);
    public abstract virtual TSelf WhereLessThanOrEqual(string fieldName, object value, bool exact);
    public abstract virtual TSelf WhereLessThanOrEqual(Expression`1<Func`2<T, TValue>> propertySelector, TValue value, bool exact);
    public abstract virtual TSelf WhereStartsWith(string fieldName, object value);
    public abstract virtual TSelf WhereStartsWith(string fieldName, object value, bool exact);
    public abstract virtual TSelf WhereStartsWith(Expression`1<Func`2<T, TValue>> propertySelector, TValue value);
    public abstract virtual TSelf WhereStartsWith(Expression`1<Func`2<T, TValue>> propertySelector, TValue value, bool exact);
    public abstract virtual TSelf WhereExists(Expression`1<Func`2<T, TValue>> propertySelector);
    public abstract virtual TSelf WhereExists(string fieldName);
    public abstract virtual TSelf WhereRegex(Expression`1<Func`2<T, TValue>> propertySelector, string pattern);
    public abstract virtual TSelf WhereRegex(string fieldName, string pattern);
    public abstract virtual TSelf WithinRadiusOf(Expression`1<Func`2<T, TValue>> propertySelector, double radius, double latitude, double longitude, Nullable`1<SpatialUnits> radiusUnits, double distanceErrorPct);
    public abstract virtual TSelf WithinRadiusOf(string fieldName, double radius, double latitude, double longitude, Nullable`1<SpatialUnits> radiusUnits, double distanceErrorPct);
    public abstract virtual TSelf RelatesToShape(Expression`1<Func`2<T, TValue>> propertySelector, string shapeWkt, SpatialRelation relation, double distanceErrorPct);
    public abstract virtual TSelf RelatesToShape(Expression`1<Func`2<T, TValue>> propertySelector, string shapeWkt, SpatialRelation relation, SpatialUnits units, double distanceErrorPct);
    public abstract virtual TSelf RelatesToShape(string fieldName, string shapeWkt, SpatialRelation relation, double distanceErrorPct);
    public abstract virtual TSelf RelatesToShape(string fieldName, string shapeWkt, SpatialRelation relation, SpatialUnits units, double distanceErrorPct);
    public abstract virtual TSelf Spatial(Expression`1<Func`2<T, object>> path, Func`2<SpatialCriteriaFactory, SpatialCriteria> clause);
    public abstract virtual TSelf Spatial(string fieldName, Func`2<SpatialCriteriaFactory, SpatialCriteria> clause);
    public abstract virtual TSelf Spatial(DynamicSpatialField field, Func`2<SpatialCriteriaFactory, SpatialCriteria> clause);
    public abstract virtual TSelf Spatial(Func`2<DynamicSpatialFieldFactory`1<T>, DynamicSpatialField> field, Func`2<SpatialCriteriaFactory, SpatialCriteria> clause);
    public abstract virtual TSelf MoreLikeThis(MoreLikeThisBase moreLikeThis);
}
public interface Raven.Client.Documents.Session.IGroupByDocumentQuery`1 {
    public abstract virtual IGroupByDocumentQuery`1<T> SelectKey(string fieldName, string projectedName);
    public abstract virtual IDocumentQuery`1<T> SelectSum(GroupByField field, GroupByField[] fields);
    public abstract virtual IDocumentQuery`1<T> SelectCount(string projectedName);
    public abstract virtual IGroupByDocumentQuery`1<T> Filter(Action`1<IFilterFactory`1<T>> builder, int limit);
}
public interface Raven.Client.Documents.Session.IGroupByDocumentQueryBase`2 {
    [ObsoleteAttribute("
Use session.Query<T>() instead of session.Advanced.DocumentQuery<T>. The session.Query<T>() method fully supports Linq grouping, while session.Advanced.DocumentQuery<T>() is intended for lower level API access.
", "True")]
public abstract virtual IEnumerable`1<IGrouping`2<TKey, T>> GroupBy(Func`2<T, TKey> keySelector);
    [ObsoleteAttribute("
Use session.Query<T>() instead of session.Advanced.DocumentQuery<T>. The session.Query<T>() method fully supports Linq grouping, while session.Advanced.DocumentQuery<T>() is intended for lower level API access.
", "True")]
public abstract virtual IEnumerable`1<IGrouping`2<TKey, TElement>> GroupBy(Func`2<T, TKey> keySelector, Func`2<T, TElement> elementSelector);
    [ObsoleteAttribute("
Use session.Query<T>() instead of session.Advanced.DocumentQuery<T>. The session.Query<T>() method fully supports Linq grouping, while session.Advanced.DocumentQuery<T>() is intended for lower level API access.
", "True")]
public abstract virtual IEnumerable`1<IGrouping`2<TKey, T>> GroupBy(Func`2<T, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ObsoleteAttribute("
Use session.Query<T>() instead of session.Advanced.DocumentQuery<T>. The session.Query<T>() method fully supports Linq grouping, while session.Advanced.DocumentQuery<T>() is intended for lower level API access.
", "True")]
public abstract virtual IEnumerable`1<IGrouping`2<TKey, TElement>> GroupBy(Func`2<T, TKey> keySelector, Func`2<T, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
}
public interface Raven.Client.Documents.Session.ILazyClusterTransactionOperations {
    public abstract virtual Lazy`1<CompareExchangeValue`1<T>> GetCompareExchangeValue(string key);
    public abstract virtual Lazy`1<CompareExchangeValue`1<T>> GetCompareExchangeValue(string key, Action`1<CompareExchangeValue`1<T>> onEval);
    public abstract virtual Lazy`1<Dictionary`2<string, CompareExchangeValue`1<T>>> GetCompareExchangeValues(String[] keys);
    public abstract virtual Lazy`1<Dictionary`2<string, CompareExchangeValue`1<T>>> GetCompareExchangeValues(String[] keys, Action`1<Dictionary`2<string, CompareExchangeValue`1<T>>> onEval);
}
public interface Raven.Client.Documents.Session.ILazyClusterTransactionOperationsAsync {
    public abstract virtual Lazy`1<Task`1<CompareExchangeValue`1<T>>> GetCompareExchangeValueAsync(string key, CancellationToken token);
    public abstract virtual Lazy`1<Task`1<CompareExchangeValue`1<T>>> GetCompareExchangeValueAsync(string key, Action`1<CompareExchangeValue`1<T>> onEval, CancellationToken token);
    public abstract virtual Lazy`1<Task`1<Dictionary`2<string, CompareExchangeValue`1<T>>>> GetCompareExchangeValuesAsync(String[] keys, CancellationToken token);
    public abstract virtual Lazy`1<Task`1<Dictionary`2<string, CompareExchangeValue`1<T>>>> GetCompareExchangeValuesAsync(String[] keys, Action`1<Dictionary`2<string, CompareExchangeValue`1<T>>> onEval, CancellationToken token);
}
public interface Raven.Client.Documents.Session.ILazyRevisionsOperations {
    public abstract virtual Lazy`1<List`1<T>> GetFor(string id, int start, int pageSize);
    public abstract virtual Lazy`1<List`1<IMetadataDictionary>> GetMetadataFor(string id, int start, int pageSize);
    public abstract virtual Lazy`1<T> Get(string changeVector);
    public abstract virtual Lazy`1<Dictionary`2<string, T>> Get(IEnumerable`1<string> changeVectors);
    public abstract virtual Lazy`1<T> Get(string id, DateTime date);
}
public interface Raven.Client.Documents.Session.ILazyRevisionsOperationsAsync {
    public abstract virtual Lazy`1<Task`1<List`1<T>>> GetForAsync(string id, int start, int pageSize, CancellationToken token);
    public abstract virtual Lazy`1<Task`1<T>> GetAsync(string changeVector, CancellationToken token);
    public abstract virtual Lazy`1<Task`1<List`1<IMetadataDictionary>>> GetMetadataForAsync(string id, int start, int pageSize, CancellationToken token);
    public abstract virtual Lazy`1<Task`1<Dictionary`2<string, T>>> GetAsync(IEnumerable`1<string> changeVectors, CancellationToken token);
    public abstract virtual Lazy`1<Task`1<T>> GetAsync(string id, DateTime date, CancellationToken token);
}
public interface Raven.Client.Documents.Session.IMetadataDictionary {
    public abstract virtual bool TryGetValue(string key, String& value);
    public abstract virtual string GetString(string key);
    public abstract virtual long GetLong(string key);
    public abstract virtual bool GetBoolean(string key);
    public abstract virtual double GetDouble(string key);
    public abstract virtual IMetadataDictionary GetObject(string key);
    public abstract virtual IMetadataDictionary[] GetObjects(string key);
}
internal class Raven.Client.Documents.Session.IncludesUtil : object {
    private static Regex IncludePrefixRegex;
    private static Regex IncludeSuffixRegex;
    private static IncludesUtil();
    private static IncludePath GetIncludePath(string include, Boolean& isPrefix);
    public static string GetPrefixedIncludePath(string basePath, DocumentConventions conventions);
    public static void Include(BlittableJsonReaderObject document, string include, Action`1<string> loadId);
    private static void ExecuteInternal(object token, string addition, Action`2<string, string> loadId);
    internal static bool RequiresQuotes(string include, String& escapedInclude);
}
internal static class Raven.Client.Documents.Session.IndexMetadataCache : object {
    private static ConcurrentDictionary`2<Type, IndexMetadataCacheItem> IndexMetadataCacheContainer;
    private static IndexMetadataCache();
    internal static IndexMetadataCacheItem GetIndexMetadataCacheItem();
}
public abstract class Raven.Client.Documents.Session.InMemoryDocumentSessionOperations : object {
    internal long _asyncTasksCounter;
    internal int _maxDocsCountOnCachedRenewSession;
    protected RequestExecutor _requestExecutor;
    private OperationExecutor _operationExecutor;
    private IDisposable _releaseOperationContext;
    private JsonOperationContext _context;
    protected List`1<ILazyOperation> PendingLazyOperations;
    protected Dictionary`2<ILazyOperation, Action`1<object>> OnEvaluateLazy;
    private static int _instancesCounter;
    private int _hash;
    protected bool GenerateDocumentIdsOnStore;
    protected internal SessionInfo _sessionInfo;
    private BatchOptions _saveChangesOptions;
    internal Nullable`1<bool> DisableAtomicDocumentWritesInClusterWideTransaction;
    public TransactionMode TransactionMode;
    private bool _isDisposed;
    private IJsonSerializer _jsonSerializer;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<BeforeStoreEventArgs> OnBeforeStore;
    [CompilerGeneratedAttribute]
private EventHandler`1<AfterSaveChangesEventArgs> OnAfterSaveChanges;
    [CompilerGeneratedAttribute]
private EventHandler`1<BeforeDeleteEventArgs> OnBeforeDelete;
    [CompilerGeneratedAttribute]
private EventHandler`1<BeforeQueryEventArgs> OnBeforeQuery;
    [CompilerGeneratedAttribute]
private EventHandler`1<BeforeConversionToDocumentEventArgs> OnBeforeConversionToDocument;
    [CompilerGeneratedAttribute]
private EventHandler`1<AfterConversionToDocumentEventArgs> OnAfterConversionToDocument;
    [CompilerGeneratedAttribute]
private EventHandler`1<BeforeConversionToEntityEventArgs> OnBeforeConversionToEntity;
    [CompilerGeneratedAttribute]
private EventHandler`1<AfterConversionToEntityEventArgs> OnAfterConversionToEntity;
    [CompilerGeneratedAttribute]
private EventHandler`1<SessionDisposingEventArgs> OnSessionDisposing;
    protected HashSet`1<string> _knownMissingIds;
    private Dictionary`2<string, object> _externalState;
    internal DocumentsById DocumentsById;
    internal Dictionary`2<string, DocumentInfo> IncludedDocumentsById;
    internal Dictionary`2<string, DocumentInfo> IncludeRevisionsByChangeVector;
    internal Dictionary`2<string, Dictionary`2<DateTime, DocumentInfo>> IncludeRevisionsIdByDateTimeBefore;
    internal DocumentsByEntityHolder DocumentsByEntity;
    internal DeletedEntitiesHolder DeletedEntities;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, ValueTuple`2<bool, Dictionary`2<string, Nullable`1<long>>>> _countersByDocId;
    private Dictionary`2<string, Dictionary`2<string, List`1<TimeSeriesRangeResult>>> _timeSeriesByDocId;
    protected DocumentStoreBase _documentStore;
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxNumberOfRequestsPerSession>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseOptimisticConcurrency>k__BackingField;
    protected List`1<ICommandData> DeferredCommands;
    protected internal Dictionary`2<ValueTuple`3<string, CommandType, string>, ICommandData> DeferredCommandsDictionary;
    public bool NoTracking;
    internal Dictionary`2<string, ForceRevisionStrategy> IdsForCreatingForcedRevisions;
    [CompilerGeneratedAttribute]
private GenerateEntityIdOnTheClient <GenerateEntityIdOnTheClient>k__BackingField;
    [CompilerGeneratedAttribute]
private ISessionBlittableJsonConverter <JsonConverter>k__BackingField;
    private TestingStuff _forTestingPurposes;
    private int _valsCount;
    private int _customCount;
    private Lazy`1<JavascriptCompilationOptions> _pathScriptCompilationOptions;
    private static CreateSerializerOptions SerializerOptions;
    public Guid Id { get; }
    public IDictionary`2<string, object> ExternalState { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected internal Dictionary`2<string, ValueTuple`2<bool, Dictionary`2<string, Nullable`1<long>>>> CountersByDocId { get; }
    protected internal Dictionary`2<string, Dictionary`2<string, List`1<TimeSeriesRangeResult>>> TimeSeriesByDocId { get; }
    public string DatabaseName { get; }
    public IDocumentStore DocumentStore { get; }
    public RequestExecutor RequestExecutor { get; }
    public SessionInfo SessionInfo { get; }
    internal OperationExecutor Operations { get; }
    public JsonOperationContext Context { get; }
    public int NumberOfRequests { get; private set; }
    public int NumberOfEntitiesInUnitOfWork { get; }
    public string StoreIdentifier { get; }
    public DocumentConventions Conventions { get; }
    public int MaxNumberOfRequestsPerSession { get; public set; }
    public bool UseOptimisticConcurrency { get; public set; }
    public int DeferredCommandsCount { get; }
    public GenerateEntityIdOnTheClient GenerateEntityIdOnTheClient { get; }
    public ISessionBlittableJsonConverter JsonConverter { get; }
    protected internal IJsonSerializer JsonSerializer { get; }
    protected bool HasClusterSession { get; }
    public bool HasChanges { get; }
    protected InMemoryDocumentSessionOperations(DocumentStoreBase documentStore, Guid id, SessionOptions options);
    private static InMemoryDocumentSessionOperations();
    [CompilerGeneratedAttribute]
public Guid get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnBeforeStore(EventHandler`1<BeforeStoreEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnBeforeStore(EventHandler`1<BeforeStoreEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnAfterSaveChanges(EventHandler`1<AfterSaveChangesEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnAfterSaveChanges(EventHandler`1<AfterSaveChangesEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnBeforeDelete(EventHandler`1<BeforeDeleteEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnBeforeDelete(EventHandler`1<BeforeDeleteEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnBeforeQuery(EventHandler`1<BeforeQueryEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnBeforeQuery(EventHandler`1<BeforeQueryEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnBeforeConversionToDocument(EventHandler`1<BeforeConversionToDocumentEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnBeforeConversionToDocument(EventHandler`1<BeforeConversionToDocumentEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnAfterConversionToDocument(EventHandler`1<AfterConversionToDocumentEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnAfterConversionToDocument(EventHandler`1<AfterConversionToDocumentEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnBeforeConversionToEntity(EventHandler`1<BeforeConversionToEntityEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnBeforeConversionToEntity(EventHandler`1<BeforeConversionToEntityEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnAfterConversionToEntity(EventHandler`1<AfterConversionToEntityEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnAfterConversionToEntity(EventHandler`1<AfterConversionToEntityEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnSessionDisposing(EventHandler`1<SessionDisposingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnSessionDisposing(EventHandler`1<SessionDisposingEventArgs> value);
    public sealed virtual IDictionary`2<string, object> get_ExternalState();
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.InMemoryDocumentSessionOperations/<GetCurrentSessionNode>d__51")]
public sealed virtual Task`1<ServerNode> GetCurrentSessionNode();
    protected internal Dictionary`2<string, ValueTuple`2<bool, Dictionary`2<string, Nullable`1<long>>>> get_CountersByDocId();
    protected internal Dictionary`2<string, Dictionary`2<string, List`1<TimeSeriesRangeResult>>> get_TimeSeriesByDocId();
    [CompilerGeneratedAttribute]
public string get_DatabaseName();
    public sealed virtual IDocumentStore get_DocumentStore();
    public sealed virtual RequestExecutor get_RequestExecutor();
    public sealed virtual SessionInfo get_SessionInfo();
    internal OperationExecutor get_Operations();
    public sealed virtual JsonOperationContext get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual int get_NumberOfRequests();
    [CompilerGeneratedAttribute]
private void set_NumberOfRequests(int value);
    public int get_NumberOfEntitiesInUnitOfWork();
    public sealed virtual string get_StoreIdentifier();
    public sealed virtual DocumentConventions get_Conventions();
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxNumberOfRequestsPerSession();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MaxNumberOfRequestsPerSession(int value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseOptimisticConcurrency();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UseOptimisticConcurrency(bool value);
    public int get_DeferredCommandsCount();
    [CompilerGeneratedAttribute]
public GenerateEntityIdOnTheClient get_GenerateEntityIdOnTheClient();
    [CompilerGeneratedAttribute]
public sealed virtual ISessionBlittableJsonConverter get_JsonConverter();
    protected internal IJsonSerializer get_JsonSerializer();
    public sealed virtual IMetadataDictionary GetMetadataFor(T instance);
    public sealed virtual void SetTransactionMode(TransactionMode mode);
    public sealed virtual List`1<string> GetCountersFor(T instance);
    public sealed virtual List`1<string> GetTimeSeriesFor(T instance);
    public sealed virtual string GetChangeVectorFor(T instance);
    public sealed virtual Nullable`1<DateTime> GetLastModifiedFor(T instance);
    private DocumentInfo GetDocumentInfo(T instance);
    public sealed virtual bool IsLoaded(string id);
    internal bool IsLoadedOrDeleted(string id);
    public bool IsDeleted(string id);
    public sealed virtual string GetDocumentId(object instance);
    public void IncrementRequestCount();
    public T TrackEntity(DocumentInfo documentFound);
    public T TrackEntity(string id, BlittableJsonReaderObject document, BlittableJsonReaderObject metadata, bool noTracking);
    private object TrackEntity(Type entityType, DocumentInfo documentFound);
    internal void RegisterExternalLoadedIntoTheSession(DocumentInfo info);
    private object TrackEntity(Type entityType, string id, BlittableJsonReaderObject document, BlittableJsonReaderObject metadata, bool noTracking);
    public static object GetDefaultValue(Type type);
    public sealed virtual void Delete(T entity);
    public sealed virtual void Delete(string id);
    public sealed virtual void Delete(string id, string expectedChangeVector);
    public sealed virtual void Store(object entity);
    public sealed virtual void Store(object entity, string id);
    public sealed virtual void Store(object entity, string changeVector, string id);
    private void StoreInternal(object entity, string changeVector, string id, ConcurrencyCheckMode forceConcurrencyCheck);
    public sealed virtual Task StoreAsync(object entity, CancellationToken token);
    public sealed virtual Task StoreAsync(object entity, string changeVector, string id, CancellationToken token);
    public sealed virtual Task StoreAsync(object entity, string id, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.InMemoryDocumentSessionOperations/<StoreAsyncInternal>d__139")]
private Task StoreAsyncInternal(object entity, string changeVector, string id, ConcurrencyCheckMode forceConcurrencyCheck, CancellationToken token);
    internal IDisposable AsyncTaskHolder();
    [ObsoleteAttribute("InMemoryDocumentSessionOperations.GenerateId is not supported anymore. Will be removed in next major version of the product.")]
protected abstract virtual string GenerateId(object entity);
    protected virtual void RememberEntityForDocumentIdGeneration(object entity);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.InMemoryDocumentSessionOperations/<GenerateDocumentIdForStorageAsync>d__143")]
protected internal Task`1<string> GenerateDocumentIdForStorageAsync(object entity);
    protected abstract virtual Task`1<string> GenerateIdAsync(object entity);
    protected virtual void StoreEntityInUnitOfWork(string id, object entity, string changeVector, DynamicJsonValue metadata, ConcurrencyCheckMode forceConcurrencyCheck);
    protected void AssertNoNonUniqueInstance(object entity, string id);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.InMemoryDocumentSessionOperations/<GetOrGenerateDocumentIdAsync>d__147")]
[ObsoleteAttribute("InMemoryDocumentSessionOperations.GetOrGenerateDocumentIdAsync is not supported anymore. Will be removed in next major version of the product.")]
protected Task`1<string> GetOrGenerateDocumentIdAsync(object entity);
    internal SaveChangesData PrepareForSaveChanges();
    internal void ValidateClusterTransaction(SaveChangesData result);
    private void PrepareCompareExchangeEntities(SaveChangesData result);
    protected abstract virtual bool get_HasClusterSession();
    protected abstract virtual void ClearClusterSession();
    protected internal abstract virtual ClusterTransactionOperationsBase GetClusterSession();
    internal static bool UpdateMetadataModifications(IMetadataDictionary metadataDictionary, BlittableJsonReaderObject metadata);
    private static object HandleDictionaryObject(IMetadataDictionary md);
    private void PrepareForCreatingRevisionsFromIds(SaveChangesData result);
    private void PrepareForEntitiesDeletion(SaveChangesData result, IDictionary`2<string, DocumentsChanges[]> changes);
    private void PrepareForEntitiesPuts(SaveChangesData result);
    private static void ThrowMissingDocumentMetadata(BlittableJsonReaderObject document);
    private static void ThrowInvalidDeletedDocumentWithDeferredCommand(ICommandData resultCommand);
    private static void ThrowInvalidModifiedDocumentWithDeferredCommand(ICommandData resultCommand);
    private static void ThrowNoDatabase();
    protected bool EntityChanged(BlittableJsonReaderObject newObj, DocumentInfo documentInfo, IDictionary`2<string, DocumentsChanges[]> changes);
    public sealed virtual IDictionary`2<string, DocumentsChanges[]> WhatChanged();
    public sealed virtual DocumentsChanges[] WhatChangedFor(object entity);
    public sealed virtual IDictionary`2<string, EntityInfo> GetTrackedEntities();
    public sealed virtual bool get_HasChanges();
    public sealed virtual bool HasChanged(object entity);
    public sealed virtual void WaitForReplicationAfterSaveChanges(Nullable`1<TimeSpan> timeout, bool throwOnTimeout, int replicas, bool majority);
    public sealed virtual void WaitForIndexesAfterSaveChanges(Nullable`1<TimeSpan> timeout, bool throwOnTimeout, String[] indexes);
    private void GetAllEntitiesChanges(IDictionary`2<string, DocumentsChanges[]> changes);
    public sealed virtual void IgnoreChangesFor(object entity);
    public sealed virtual void Evict(T entity);
    public sealed virtual void Clear();
    public sealed virtual void Defer(ICommandData command, ICommandData[] commands);
    public sealed virtual void Defer(ICommandData[] commands);
    private void DeferInternal(ICommandData command);
    public void AssertNotDisposed();
    private void Dispose(bool isDisposing);
    public virtual void Dispose();
    public void RegisterMissing(string id);
    public void RegisterMissing(IEnumerable`1<string> ids);
    internal void RegisterIncludes(BlittableJsonReaderObject includes, bool registerMissingIds);
    internal void RegisterRevisionIncludes(BlittableJsonReaderArray revisionIncludes);
    public void RegisterMissingIncludes(BlittableJsonReaderArray results, BlittableJsonReaderObject includes, ICollection`1<string> includePaths);
    internal void RegisterCounters(BlittableJsonReaderObject resultCounters, String[] ids, String[] countersToInclude, bool gotAll);
    internal void RegisterCounters(BlittableJsonReaderObject resultCounters, Dictionary`2<string, String[]> countersToInclude);
    private void RegisterCountersInternal(BlittableJsonReaderObject resultCounters, Dictionary`2<string, String[]> countersToInclude, bool fromQueryResult, bool gotAll);
    private void RegisterCountersForDocument(string id, bool gotAll, BlittableJsonReaderArray counters, Dictionary`2<string, String[]> countersToInclude);
    private void SetGotAllInCacheIfNeeded(Dictionary`2<string, String[]> countersToInclude);
    private void SetGotAllCountersForDocument(string id);
    private void RegisterMissingCounters(Dictionary`2<string, String[]> countersToInclude);
    private void RegisterMissingCounters(String[] ids, String[] countersToInclude);
    internal void RegisterTimeSeries(BlittableJsonReaderObject resultTimeSeries);
    private static void AddToCache(Dictionary`2<string, List`1<TimeSeriesRangeResult>> cache, TimeSeriesRangeResult newRange, string name);
    internal static void AddToCache(string timeseries, DateTime from, DateTime to, int fromRangeIndex, int toRangeIndex, List`1<TimeSeriesRangeResult> ranges, Dictionary`2<string, List`1<TimeSeriesRangeResult>> cache, TimeSeriesEntry[] values);
    private static TimeSeriesEntry[] MergeRanges(int fromRangeIndex, int toRangeIndex, List`1<TimeSeriesRangeResult> localRanges, TimeSeriesRangeResult newRange);
    private static void UpdateExistingRange(TimeSeriesRangeResult localRange, TimeSeriesRangeResult newRange);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    internal void HandleInternalMetadata(BlittableJsonReaderObject result);
    private void HandleInternalMetadata(BlittableJsonReaderArray values);
    private object DeserializeFromTransformer(Type entityType, string id, BlittableJsonReaderObject document, bool trackEntity);
    internal bool CheckIfAllChangeVectorsAreAlreadyIncluded(IEnumerable`1<string> changeVectors);
    internal bool CheckIfRevisionByDateTimeBeforeAlreadyIncluded(string id, DateTime dateTime);
    public bool CheckIfIdAlreadyIncluded(String[] ids, IEnumerable`1<string> includes);
    protected void BuildEntityDocInfoByIdHolder(IEnumerable`1<T> entities, Dictionary`2& idsEntitiesPairs);
    protected void RefreshEntities(GetDocumentsCommand command, Dictionary`2<string, ValueTuple`2<object, DocumentInfo>> idsEntitiesPairs);
    internal static void ThrowCouldNotRefreshDocument(string msg);
    protected void RefreshInternal(T entity, BlittableJsonReaderObject cmdResult, DocumentInfo documentInfo);
    protected static T GetOperationResult(object result);
    protected void UpdateSessionAfterSaveChanges(BatchCommandResult result);
    internal void OnBeforeConversionToDocumentInvoke(string id, object entity);
    internal void OnAfterConversionToDocumentInvoke(string id, object entity, BlittableJsonReaderObject& document);
    internal void OnBeforeConversionToEntityInvoke(string id, Type type, BlittableJsonReaderObject& document);
    internal void OnAfterConversionToEntityInvoke(string id, BlittableJsonReaderObject document, object entity);
    internal void OnAfterSaveChangesInvoke(AfterSaveChangesEventArgs args);
    internal void OnBeforeQueryInvoke(BeforeQueryEventArgs args);
    protected ValueTuple`2<string, string> ProcessQueryParameters(Type type, string indexName, string collectionName, DocumentConventions conventions);
    internal TestingStuff ForTestingPurposesOnly();
    internal void OnBeforeDeleteInvoke(BeforeDeleteEventArgs beforeDeleteEventArgs);
    internal StreamResult`1<T> CreateStreamResult(BlittableJsonReaderObject json, FieldsToFetchToken fieldsToFetch, bool isProjectInto);
    internal TimeSeriesStreamResult`1<T> CreateTimeSeriesStreamResult(YieldStreamResults enumerator);
    internal static void ValidateTimeSeriesName(string name);
    internal static void ValidateIncrementalTimeSeriesName(string name);
    internal void AssertNoIncludesInNonTrackingSession();
    public sealed virtual void Increment(T entity, Expression`1<Func`2<T, U>> path, U valToAdd);
    public sealed virtual void Increment(string id, Expression`1<Func`2<T, U>> path, U valToAdd);
    public sealed virtual void AddOrIncrement(string id, T entity, Expression`1<Func`2<T, TU>> path, TU valueToAdd);
    public sealed virtual void AddOrPatch(string id, T entity, Expression`1<Func`2<T, List`1<TU>>> path, Expression`1<Func`2<JavaScriptArray`1<TU>, object>> arrayAdder);
    public sealed virtual void AddOrPatch(string id, T entity, Expression`1<Func`2<T, TU>> path, TU value);
    public sealed virtual void Patch(T entity, Expression`1<Func`2<T, U>> path, U value);
    public sealed virtual void Patch(string id, Expression`1<Func`2<T, U>> path, U value);
    public sealed virtual void Patch(T entity, Expression`1<Func`2<T, IEnumerable`1<U>>> path, Expression`1<Func`2<JavaScriptArray`1<U>, object>> arrayAdder);
    public sealed virtual void Patch(string id, Expression`1<Func`2<T, IEnumerable`1<U>>> path, Expression`1<Func`2<JavaScriptArray`1<U>, object>> arrayAdder);
    public sealed virtual void Patch(string id, Expression`1<Func`2<T, IDictionary`2<TKey, TValue>>> path, Expression`1<Func`2<JavaScriptDictionary`2<TKey, TValue>, object>> dictionaryAdder);
    public sealed virtual void Patch(T entity, Expression`1<Func`2<T, IDictionary`2<TKey, TValue>>> path, Expression`1<Func`2<JavaScriptDictionary`2<TKey, TValue>, object>> dictionaryAdder);
    private static PatchRequest CreatePatchRequest(Expression`1<Func`2<JavaScriptArray`1<T>, object>> arrayAdder, string pathScript, string adderScript, CustomMethods extension);
    private bool TryMergePatches(string id, PatchRequest patchRequest);
    private object AddTypeNameToValueIfNeeded(Type propertyType, object value);
    private static ValueTuple`2<object, object> GetKeyAndValue(MethodCallExpression call);
    private static object GetKey(MethodCallExpression call);
    private static void ThrowUnsupportedExpression(Expression expression);
    [CompilerGeneratedAttribute]
private Task`1<string> <.ctor>b__110_0(object entity);
    [CompilerGeneratedAttribute]
private JavascriptCompilationOptions <.ctor>b__110_1();
    [CompilerGeneratedAttribute]
private void <DeferInternal>g__AddCommand|179_0(string id, CommandType commandType, string commandName, <>c__DisplayClass179_0& );
}
public interface Raven.Client.Documents.Session.IPagingDocumentQueryBase`2 {
    public abstract virtual TSelf Skip(long count);
    public abstract virtual TSelf Take(long count);
}
public interface Raven.Client.Documents.Session.IQueryBase`2 {
    public DocumentConventions Conventions { get; }
    public abstract virtual DocumentConventions get_Conventions();
    public abstract virtual TSelf AfterQueryExecuted(Action`1<QueryResult> action);
    public abstract virtual TSelf AfterStreamExecuted(Action`1<BlittableJsonReaderObject> action);
    public abstract virtual TSelf BeforeQueryExecuted(Action`1<IndexQuery> beforeQueryExecuted);
    public abstract virtual void InvokeAfterQueryExecuted(QueryResult result);
    public abstract virtual void InvokeAfterStreamExecuted(BlittableJsonReaderObject result);
    public abstract virtual TSelf NoCaching();
    public abstract virtual TSelf NoTracking();
    public abstract virtual TSelf Timings(QueryTimings& timings);
    public abstract virtual TSelf Statistics(QueryStatistics& stats);
    public abstract virtual TSelf UsingDefaultOperator(QueryOperator queryOperator);
    public abstract virtual TSelf WaitForNonStaleResults(Nullable`1<TimeSpan> waitTimeout);
    public abstract virtual IndexQuery GetIndexQuery();
    public abstract virtual TSelf AddParameter(string name, object value);
}
public interface Raven.Client.Documents.Session.IRavenQueryInspector {
    public string IndexName { get; }
    public InMemoryDocumentSessionOperations Session { get; }
    public abstract virtual string get_IndexName();
    public abstract virtual InMemoryDocumentSessionOperations get_Session();
    public abstract virtual IndexQuery GetIndexQuery(bool isAsync);
}
public interface Raven.Client.Documents.Session.IRawDocumentQuery`1 {
    public abstract virtual IRawDocumentQuery`1<T> Projection(ProjectionBehavior projectionBehavior);
    public abstract virtual Dictionary`2<string, FacetResult> ExecuteAggregation();
}
public interface Raven.Client.Documents.Session.IRevisionsSessionOperations {
    public ILazyRevisionsOperations Lazily { get; }
    public abstract virtual List`1<T> GetFor(string id, int start, int pageSize);
    public abstract virtual List`1<IMetadataDictionary> GetMetadataFor(string id, int start, int pageSize);
    public abstract virtual T Get(string changeVector);
    public abstract virtual Dictionary`2<string, T> Get(IEnumerable`1<string> changeVectors);
    public abstract virtual T Get(string id, DateTime date);
    public abstract virtual void ForceRevisionCreationFor(T entity, ForceRevisionStrategy strategy);
    public abstract virtual void ForceRevisionCreationFor(string id, ForceRevisionStrategy strategy);
    public abstract virtual long GetCountFor(string id);
    public abstract virtual ILazyRevisionsOperations get_Lazily();
}
public interface Raven.Client.Documents.Session.IRevisionsSessionOperationsAsync {
    public ILazyRevisionsOperationsAsync Lazily { get; }
    public abstract virtual ILazyRevisionsOperationsAsync get_Lazily();
    public abstract virtual Task`1<List`1<T>> GetForAsync(string id, int start, int pageSize, CancellationToken token);
    public abstract virtual Task`1<List`1<IMetadataDictionary>> GetMetadataForAsync(string id, int start, int pageSize, CancellationToken token);
    public abstract virtual Task`1<T> GetAsync(string changeVector, CancellationToken token);
    public abstract virtual Task`1<Dictionary`2<string, T>> GetAsync(IEnumerable`1<string> changeVectors, CancellationToken token);
    public abstract virtual Task`1<T> GetAsync(string id, DateTime date, CancellationToken token);
    public abstract virtual void ForceRevisionCreationFor(T entity, ForceRevisionStrategy strategy);
    public abstract virtual void ForceRevisionCreationFor(string id, ForceRevisionStrategy strategy);
    public abstract virtual Task`1<long> GetCountForAsync(string id, CancellationToken token);
}
public interface Raven.Client.Documents.Session.ISessionDocumentAppendTimeSeriesBase {
    public abstract virtual void Append(DateTime timestamp, IEnumerable`1<double> values, string tag);
    public abstract virtual void Append(DateTime timestamp, double value, string tag);
}
public interface Raven.Client.Documents.Session.ISessionDocumentCounters {
    public abstract virtual Dictionary`2<string, Nullable`1<long>> GetAll();
    public abstract virtual Nullable`1<long> Get(string counter);
    public abstract virtual Dictionary`2<string, Nullable`1<long>> Get(IEnumerable`1<string> counters);
}
public interface Raven.Client.Documents.Session.ISessionDocumentCountersBase {
    public abstract virtual void Increment(string counter, long delta);
    public abstract virtual void Delete(string counter);
}
public interface Raven.Client.Documents.Session.ISessionDocumentDeleteTimeSeriesBase {
    public abstract virtual void Delete(Nullable`1<DateTime> from, Nullable`1<DateTime> to);
    public abstract virtual void Delete(DateTime at);
}
public interface Raven.Client.Documents.Session.ISessionDocumentIncrementalTimeSeries {
    public abstract virtual TimeSeriesEntry[] Get(Nullable`1<DateTime> from, Nullable`1<DateTime> to, int start, int pageSize);
    public abstract virtual TimeSeriesEntry[] Get(Nullable`1<DateTime> from, Nullable`1<DateTime> to, Action`1<ITimeSeriesIncludeBuilder> includes, int start, int pageSize);
}
public interface Raven.Client.Documents.Session.ISessionDocumentIncrementTimeSeriesBase {
    public abstract virtual void Increment(DateTime timestamp, IEnumerable`1<double> values);
    public abstract virtual void Increment(IEnumerable`1<double> values);
    public abstract virtual void Increment(DateTime timestamp, double value);
    public abstract virtual void Increment(double value);
}
public interface Raven.Client.Documents.Session.ISessionDocumentRollupTypedAppendTimeSeriesBase`1 {
    public abstract virtual void Append(TimeSeriesRollupEntry`1<T> entry);
}
public interface Raven.Client.Documents.Session.ISessionDocumentRollupTypedTimeSeries`1 {
    public abstract virtual TimeSeriesRollupEntry`1[] Get(Nullable`1<DateTime> from, Nullable`1<DateTime> to, int start, int pageSize);
}
public interface Raven.Client.Documents.Session.ISessionDocumentTimeSeries {
    public abstract virtual TimeSeriesEntry[] Get(Nullable`1<DateTime> from, Nullable`1<DateTime> to, int start, int pageSize);
    public abstract virtual TimeSeriesEntry[] Get(Nullable`1<DateTime> from, Nullable`1<DateTime> to, Action`1<ITimeSeriesIncludeBuilder> includes, int start, int pageSize);
}
public interface Raven.Client.Documents.Session.ISessionDocumentTypedAppendTimeSeriesBase`1 {
    public abstract virtual void Append(DateTime timestamp, T entry, string tag);
    public abstract virtual void Append(TimeSeriesEntry`1<T> entry);
}
public interface Raven.Client.Documents.Session.ISessionDocumentTypedIncrementalTimeSeries`1 {
    public abstract virtual TimeSeriesEntry`1[] Get(Nullable`1<DateTime> from, Nullable`1<DateTime> to, int start, int pageSize);
}
public interface Raven.Client.Documents.Session.ISessionDocumentTypedIncrementTimeSeriesBase`1 {
    public abstract virtual void Increment(DateTime timestamp, T entry);
    public abstract virtual void Increment(T entry);
}
public interface Raven.Client.Documents.Session.ISessionDocumentTypedTimeSeries`1 {
    public abstract virtual TimeSeriesEntry`1[] Get(Nullable`1<DateTime> from, Nullable`1<DateTime> to, int start, int pageSize);
}
public interface Raven.Client.Documents.Session.ITimeSeriesSessionStreamAggregationResultOperations {
    public abstract virtual IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult`1<T>>> Stream(IQueryable`1<TimeSeriesAggregationResult`1<T>> query);
    public abstract virtual IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult`1<T>>> Stream(IQueryable`1<TimeSeriesAggregationResult`1<T>> query, StreamQueryStatistics& streamQueryStats);
    public abstract virtual IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult`1<T>>> Stream(IDocumentQuery`1<TimeSeriesAggregationResult`1<T>> query);
    public abstract virtual IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult`1<T>>> Stream(IRawDocumentQuery`1<TimeSeriesAggregationResult`1<T>> query);
    public abstract virtual IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult`1<T>>> Stream(IRawDocumentQuery`1<TimeSeriesAggregationResult`1<T>> query, StreamQueryStatistics& streamQueryStats);
    public abstract virtual IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesAggregationResult`1<T>>> Stream(IDocumentQuery`1<TimeSeriesAggregationResult`1<T>> query, StreamQueryStatistics& streamQueryStats);
}
public interface Raven.Client.Documents.Session.ITimeSeriesSessionStreamOperations`1 {
    public abstract virtual IEnumerator`1<TimeSeriesStreamResult`1<T>> Stream(IQueryable`1<T> query);
    public abstract virtual IEnumerator`1<TimeSeriesStreamResult`1<T>> Stream(IQueryable`1<T> query, StreamQueryStatistics& streamQueryStats);
    public abstract virtual IEnumerator`1<TimeSeriesStreamResult`1<T>> Stream(IDocumentQuery`1<T> query);
    public abstract virtual IEnumerator`1<TimeSeriesStreamResult`1<T>> Stream(IRawDocumentQuery`1<T> query);
    public abstract virtual IEnumerator`1<TimeSeriesStreamResult`1<T>> Stream(IRawDocumentQuery`1<T> query, StreamQueryStatistics& streamQueryStats);
    public abstract virtual IEnumerator`1<TimeSeriesStreamResult`1<T>> Stream(IDocumentQuery`1<T> query, StreamQueryStatistics& streamQueryStats);
}
public interface Raven.Client.Documents.Session.ITimeSeriesSessionStreamRawResultOperations {
    public abstract virtual IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult`1<T>>> Stream(IQueryable`1<TimeSeriesRawResult`1<T>> query);
    public abstract virtual IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult`1<T>>> Stream(IQueryable`1<TimeSeriesRawResult`1<T>> query, StreamQueryStatistics& streamQueryStats);
    public abstract virtual IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult`1<T>>> Stream(IDocumentQuery`1<TimeSeriesRawResult`1<T>> query);
    public abstract virtual IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult`1<T>>> Stream(IRawDocumentQuery`1<TimeSeriesRawResult`1<T>> query);
    public abstract virtual IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult`1<T>>> Stream(IRawDocumentQuery`1<TimeSeriesRawResult`1<T>> query, StreamQueryStatistics& streamQueryStats);
    public abstract virtual IEnumerator`1<TimeSeriesStreamResult`1<TimeSeriesRawResult`1<T>>> Stream(IDocumentQuery`1<TimeSeriesRawResult`1<T>> query, StreamQueryStatistics& streamQueryStats);
}
public interface Raven.Client.Documents.Session.ITimeSeriesStreamingBase`1 {
    public abstract virtual IEnumerator`1<T> Stream(Nullable`1<DateTime> from, Nullable`1<DateTime> to, Nullable`1<TimeSpan> offset);
}
public class Raven.Client.Documents.Session.JavaScriptArray`1 : object {
    [JavascriptMethodNameAttribute("push")]
public JavaScriptArray`1<U> Add(U u);
    [JavascriptMethodNameAttribute("push")]
public JavaScriptArray`1<U> Add(U[] u);
    [JavascriptMethodNameAttribute("splice")]
public JavaScriptArray`1<U> RemoveAt(int index);
    [JavascriptMethodNameAttribute("filter")]
public JavaScriptArray`1<U> RemoveAll(Func`2<U, bool> predicate);
}
public class Raven.Client.Documents.Session.JavaScriptDictionary`2 : object {
    public JavaScriptDictionary`2<TKey, TValue> Add(TKey key, TValue value);
    public JavaScriptDictionary`2<TKey, TValue> Add(KeyValuePair`2<TKey, TValue> kvp);
    public JavaScriptDictionary`2<TKey, TValue> Remove(TKey key);
}
internal class Raven.Client.Documents.Session.JavascriptMethodNameAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <PositionalArguments>k__BackingField;
    public string Name { get; }
    public Object[] PositionalArguments { get; public set; }
    public JavascriptMethodNameAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Object[] get_PositionalArguments();
    [CompilerGeneratedAttribute]
public void set_PositionalArguments(Object[] value);
}
internal class Raven.Client.Documents.Session.Loaders.AbstractTimeSeriesRangeComparer : object {
    public static AbstractTimeSeriesRangeComparer Instance;
    private static AbstractTimeSeriesRangeComparer();
    public sealed virtual bool Equals(AbstractTimeSeriesRange x, AbstractTimeSeriesRange y);
    public sealed virtual int GetHashCode(AbstractTimeSeriesRange obj);
}
internal class Raven.Client.Documents.Session.Loaders.AsyncLazyMultiLoaderWithInclude`1 : object {
    private IAsyncDocumentSessionImpl _session;
    private List`1<string> _includes;
    internal AsyncLazyMultiLoaderWithInclude`1(IAsyncDocumentSessionImpl session);
    public sealed virtual IAsyncLazyLoaderWithInclude`1<T> Include(string path);
    public sealed virtual IAsyncLazyLoaderWithInclude`1<T> Include(Expression`1<Func`2<T, string>> path);
    public sealed virtual IAsyncLazyLoaderWithInclude`1<T> Include(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    public sealed virtual Lazy`1<Task`1<Dictionary`2<string, T>>> LoadAsync(String[] ids);
    public sealed virtual Lazy`1<Task`1<Dictionary`2<string, T>>> LoadAsync(IEnumerable`1<string> ids);
    public sealed virtual Lazy`1<Task`1<T>> LoadAsync(string id);
    public sealed virtual Lazy`1<Task`1<Dictionary`2<string, TResult>>> LoadAsync(String[] ids);
    public sealed virtual Lazy`1<Task`1<Dictionary`2<string, TResult>>> LoadAsync(IEnumerable`1<string> ids);
    public sealed virtual Lazy`1<Task`1<TResult>> LoadAsync(string id);
}
public class Raven.Client.Documents.Session.Loaders.AsyncMultiLoaderWithInclude`1 : object {
    private IAsyncDocumentSessionImpl _session;
    private List`1<string> _includes;
    internal AsyncMultiLoaderWithInclude`1(IAsyncDocumentSessionImpl session);
    public sealed virtual AsyncMultiLoaderWithInclude`1<T> Include(string path);
    public sealed virtual AsyncMultiLoaderWithInclude`1<T> Include(Expression`1<Func`2<T, string>> path);
    public sealed virtual AsyncMultiLoaderWithInclude`1<T> Include(Expression`1<Func`2<T, string>> path);
    public sealed virtual AsyncMultiLoaderWithInclude`1<T> Include(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    public sealed virtual AsyncMultiLoaderWithInclude`1<T> Include(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    public sealed virtual Task`1<Dictionary`2<string, T>> LoadAsync(String[] ids);
    public sealed virtual Task`1<Dictionary`2<string, T>> LoadAsync(IEnumerable`1<string> ids, CancellationToken token);
    public sealed virtual Task`1<T> LoadAsync(string id, CancellationToken token);
    public sealed virtual Task`1<Dictionary`2<string, TResult>> LoadAsync(String[] ids);
    public sealed virtual Task`1<Dictionary`2<string, TResult>> LoadAsync(IEnumerable`1<string> ids, CancellationToken token);
    public sealed virtual Task`1<TResult> LoadAsync(string id, CancellationToken token);
}
public interface Raven.Client.Documents.Session.Loaders.IAbstractTimeSeriesIncludeBuilder`2 {
    public abstract virtual TBuilder IncludeTimeSeries(string name, TimeSeriesRangeType type, TimeValue time);
    public abstract virtual TBuilder IncludeTimeSeries(string name, TimeSeriesRangeType type, int count);
    public abstract virtual TBuilder IncludeTimeSeries(String[] names, TimeSeriesRangeType type, TimeValue time);
    public abstract virtual TBuilder IncludeTimeSeries(String[] names, TimeSeriesRangeType type, int count);
    public abstract virtual TBuilder IncludeAllTimeSeries(TimeSeriesRangeType type, TimeValue time);
    public abstract virtual TBuilder IncludeAllTimeSeries(TimeSeriesRangeType type, int count);
}
public interface Raven.Client.Documents.Session.Loaders.IAsyncLazyLoaderWithInclude`1 {
    public abstract virtual IAsyncLazyLoaderWithInclude`1<T> Include(string path);
    public abstract virtual IAsyncLazyLoaderWithInclude`1<T> Include(Expression`1<Func`2<T, string>> path);
    public abstract virtual IAsyncLazyLoaderWithInclude`1<T> Include(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    public abstract virtual Lazy`1<Task`1<Dictionary`2<string, T>>> LoadAsync(String[] ids);
    public abstract virtual Lazy`1<Task`1<Dictionary`2<string, T>>> LoadAsync(IEnumerable`1<string> ids);
    public abstract virtual Lazy`1<Task`1<T>> LoadAsync(string id);
    public abstract virtual Lazy`1<Task`1<Dictionary`2<string, TResult>>> LoadAsync(String[] ids);
    public abstract virtual Lazy`1<Task`1<Dictionary`2<string, TResult>>> LoadAsync(IEnumerable`1<string> ids);
    public abstract virtual Lazy`1<Task`1<TResult>> LoadAsync(string id);
}
public interface Raven.Client.Documents.Session.Loaders.IAsyncLoaderWithInclude`1 {
    public abstract virtual AsyncMultiLoaderWithInclude`1<T> Include(string path);
    public abstract virtual AsyncMultiLoaderWithInclude`1<T> Include(Expression`1<Func`2<T, string>> path);
    public abstract virtual AsyncMultiLoaderWithInclude`1<T> Include(Expression`1<Func`2<T, string>> path);
    public abstract virtual AsyncMultiLoaderWithInclude`1<T> Include(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    public abstract virtual AsyncMultiLoaderWithInclude`1<T> Include(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    public abstract virtual Task`1<Dictionary`2<string, T>> LoadAsync(String[] ids);
    public abstract virtual Task`1<Dictionary`2<string, T>> LoadAsync(IEnumerable`1<string> ids, CancellationToken token);
    public abstract virtual Task`1<T> LoadAsync(string id, CancellationToken token);
    public abstract virtual Task`1<Dictionary`2<string, TResult>> LoadAsync(String[] ids);
    public abstract virtual Task`1<Dictionary`2<string, TResult>> LoadAsync(IEnumerable`1<string> ids, CancellationToken token);
    public abstract virtual Task`1<TResult> LoadAsync(string id, CancellationToken token);
}
public interface Raven.Client.Documents.Session.Loaders.ICompareExchangeValueIncludeBuilder`2 {
    public abstract virtual TBuilder IncludeCompareExchangeValue(string path);
    public abstract virtual TBuilder IncludeCompareExchangeValue(Expression`1<Func`2<T, string>> path);
    public abstract virtual TBuilder IncludeCompareExchangeValue(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
}
public interface Raven.Client.Documents.Session.Loaders.ICounterIncludeBuilder`2 {
    public abstract virtual TBuilder IncludeCounter(string name);
    public abstract virtual TBuilder IncludeCounters(String[] names);
    public abstract virtual TBuilder IncludeAllCounters();
}
public interface Raven.Client.Documents.Session.Loaders.IDocumentIncludeBuilder`2 {
    public abstract virtual TBuilder IncludeDocuments(string path);
    public abstract virtual TBuilder IncludeDocuments(Expression`1<Func`2<T, string>> path);
    public abstract virtual TBuilder IncludeDocuments(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    public abstract virtual TBuilder IncludeDocuments(Expression`1<Func`2<T, string>> path);
    public abstract virtual TBuilder IncludeDocuments(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
}
public interface Raven.Client.Documents.Session.Loaders.IIncludeBuilder`1 {
}
public interface Raven.Client.Documents.Session.Loaders.IIncludeBuilder`2 {
}
public interface Raven.Client.Documents.Session.Loaders.ILazyLoaderWithInclude`1 {
    public abstract virtual ILazyLoaderWithInclude`1<T> Include(string path);
    public abstract virtual ILazyLoaderWithInclude`1<T> Include(Expression`1<Func`2<T, string>> path);
    public abstract virtual ILazyLoaderWithInclude`1<T> Include(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    public abstract virtual Lazy`1<Dictionary`2<string, T>> Load(String[] ids);
    public abstract virtual Lazy`1<Dictionary`2<string, T>> Load(IEnumerable`1<string> ids);
    public abstract virtual Lazy`1<T> Load(string id);
    public abstract virtual Lazy`1<Dictionary`2<string, TResult>> Load(String[] ids);
    public abstract virtual Lazy`1<Dictionary`2<string, TResult>> Load(IEnumerable`1<string> ids);
    public abstract virtual Lazy`1<TResult> Load(string id);
}
public interface Raven.Client.Documents.Session.Loaders.ILoaderWithInclude`1 {
    public abstract virtual ILoaderWithInclude`1<T> Include(string path);
    public abstract virtual ILoaderWithInclude`1<T> Include(Expression`1<Func`2<T, string>> path);
    public abstract virtual ILoaderWithInclude`1<T> Include(Expression`1<Func`2<T, string>> path);
    public abstract virtual ILoaderWithInclude`1<T> Include(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    public abstract virtual ILoaderWithInclude`1<T> Include(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    public abstract virtual Dictionary`2<string, T> Load(String[] ids);
    public abstract virtual Dictionary`2<string, T> Load(IEnumerable`1<string> ids);
    public abstract virtual T Load(string id);
    public abstract virtual Dictionary`2<string, TResult> Load(String[] ids);
    public abstract virtual Dictionary`2<string, TResult> Load(IEnumerable`1<string> ids);
    public abstract virtual TResult Load(string id);
}
public class Raven.Client.Documents.Session.Loaders.IncludeBuilder : object {
    internal HashSet`1<string> DocumentsToInclude;
    internal string Alias;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Dictionary`2<string, ValueTuple`2<bool, HashSet`1<string>>> CountersToIncludeBySourcePath;
    internal Dictionary`2<string, HashSet`1<AbstractTimeSeriesRange>> TimeSeriesToIncludeBySourceAlias;
    internal HashSet`1<string> CompareExchangeValuesToInclude;
    internal HashSet`1<string> RevisionsToIncludeByChangeVector;
    internal Nullable`1<DateTime> RevisionsToIncludeByDateTime;
    internal bool IncludeTimeSeriesTags;
    internal bool IncludeTimeSeriesDocument;
    internal IEnumerable`1<AbstractTimeSeriesRange> TimeSeriesToInclude { get; }
    internal HashSet`1<string> CountersToInclude { get; }
    internal bool AllCounters { get; }
    internal IEnumerable`1<AbstractTimeSeriesRange> get_TimeSeriesToInclude();
    internal HashSet`1<string> get_CountersToInclude();
    internal bool get_AllCounters();
}
internal class Raven.Client.Documents.Session.Loaders.IncludeBuilder`1 : IncludeBuilder {
    private DocumentConventions _conventions;
    internal IncludeBuilder`1(DocumentConventions conventions);
    private sealed virtual override IQueryIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IQueryIncludeBuilder<T>.IncludeCounter(Expression`1<Func`2<T, string>> path, string name);
    private sealed virtual override IQueryIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IQueryIncludeBuilder<T>.IncludeCounters(Expression`1<Func`2<T, string>> path, String[] names);
    private sealed virtual override IQueryIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IQueryIncludeBuilder<T>.IncludeAllCounters(Expression`1<Func`2<T, string>> path);
    private sealed virtual override IQueryIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.ICounterIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IQueryIncludeBuilder<T>>.IncludeCounter(string name);
    private sealed virtual override IQueryIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.ICounterIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IQueryIncludeBuilder<T>>.IncludeCounters(String[] names);
    private sealed virtual override IQueryIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.ICounterIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IQueryIncludeBuilder<T>>.IncludeAllCounters();
    private sealed virtual override ISubscriptionIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.ICounterIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.ISubscriptionIncludeBuilder<T>>.IncludeCounter(string name);
    private sealed virtual override ISubscriptionIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.ICounterIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.ISubscriptionIncludeBuilder<T>>.IncludeCounters(String[] names);
    private sealed virtual override ISubscriptionIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.ICounterIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.ISubscriptionIncludeBuilder<T>>.IncludeAllCounters();
    private sealed virtual override ISubscriptionIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IDocumentIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.ISubscriptionIncludeBuilder<T>>.IncludeDocuments(Expression`1<Func`2<T, string>> path);
    private sealed virtual override ISubscriptionIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IDocumentIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.ISubscriptionIncludeBuilder<T>>.IncludeDocuments(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    private sealed virtual override ISubscriptionIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IDocumentIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.ISubscriptionIncludeBuilder<T>>.IncludeDocuments(Expression`1<Func`2<T, string>> path);
    private sealed virtual override ISubscriptionIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IDocumentIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.ISubscriptionIncludeBuilder<T>>.IncludeDocuments(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    private sealed virtual override ISubscriptionIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IDocumentIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.ISubscriptionIncludeBuilder<T>>.IncludeDocuments(string path);
    private sealed virtual override IQueryIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IDocumentIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IQueryIncludeBuilder<T>>.IncludeDocuments(Expression`1<Func`2<T, string>> path);
    private sealed virtual override IQueryIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IDocumentIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IQueryIncludeBuilder<T>>.IncludeDocuments(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    private sealed virtual override IQueryIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IDocumentIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IQueryIncludeBuilder<T>>.IncludeDocuments(Expression`1<Func`2<T, string>> path);
    private sealed virtual override IQueryIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IDocumentIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IQueryIncludeBuilder<T>>.IncludeDocuments(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    private sealed virtual override IQueryIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IDocumentIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IQueryIncludeBuilder<T>>.IncludeDocuments(string path);
    private sealed virtual override IIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.ICounterIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IIncludeBuilder<T>>.IncludeCounter(string name);
    private sealed virtual override IIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.ICounterIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IIncludeBuilder<T>>.IncludeCounters(String[] names);
    private sealed virtual override IIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.ICounterIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IIncludeBuilder<T>>.IncludeAllCounters();
    private sealed virtual override IIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IDocumentIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IIncludeBuilder<T>>.IncludeDocuments(string path);
    private sealed virtual override IIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IDocumentIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IIncludeBuilder<T>>.IncludeDocuments(Expression`1<Func`2<T, string>> path);
    private sealed virtual override IIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IDocumentIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IIncludeBuilder<T>>.IncludeDocuments(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    private sealed virtual override IIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IDocumentIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IIncludeBuilder<T>>.IncludeDocuments(Expression`1<Func`2<T, string>> path);
    private sealed virtual override IIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IDocumentIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IIncludeBuilder<T>>.IncludeDocuments(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    private sealed virtual override IIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.ITimeSeriesIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IIncludeBuilder<T>>.IncludeTimeSeries(string name, Nullable`1<DateTime> from, Nullable`1<DateTime> to);
    private sealed virtual override IQueryIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.ITimeSeriesIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IQueryIncludeBuilder<T>>.IncludeTimeSeries(string name, Nullable`1<DateTime> from, Nullable`1<DateTime> to);
    private sealed virtual override IQueryIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IQueryIncludeBuilder<T>.IncludeTimeSeries(Expression`1<Func`2<T, string>> path, string name, DateTime from, DateTime to);
    private sealed virtual override IQueryIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.ICompareExchangeValueIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IQueryIncludeBuilder<T>>.IncludeCompareExchangeValue(string path);
    private sealed virtual override IQueryIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.ICompareExchangeValueIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IQueryIncludeBuilder<T>>.IncludeCompareExchangeValue(Expression`1<Func`2<T, string>> path);
    private sealed virtual override IQueryIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.ICompareExchangeValueIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IQueryIncludeBuilder<T>>.IncludeCompareExchangeValue(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    private sealed virtual override IIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.ICompareExchangeValueIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IIncludeBuilder<T>>.IncludeCompareExchangeValue(string path);
    private sealed virtual override IIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.ICompareExchangeValueIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IIncludeBuilder<T>>.IncludeCompareExchangeValue(Expression`1<Func`2<T, string>> path);
    private sealed virtual override IIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.ICompareExchangeValueIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IIncludeBuilder<T>>.IncludeCompareExchangeValue(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    private sealed virtual override ITimeSeriesIncludeBuilder Raven.Client.Documents.Session.Loaders.ITimeSeriesIncludeBuilder.IncludeTags();
    private sealed virtual override ITimeSeriesIncludeBuilder Raven.Client.Documents.Session.Loaders.ITimeSeriesIncludeBuilder.IncludeDocument();
    public ITimeSeriesIncludeBuilder IncludeTimeSeries(string name, Nullable`1<DateTime> from, Nullable`1<DateTime> to);
    private sealed virtual override IIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IAbstractTimeSeriesIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IIncludeBuilder<T>>.IncludeTimeSeries(string name, TimeSeriesRangeType type, TimeValue time);
    private sealed virtual override IIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IAbstractTimeSeriesIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IIncludeBuilder<T>>.IncludeTimeSeries(string name, TimeSeriesRangeType type, int count);
    private sealed virtual override IIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IAbstractTimeSeriesIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IIncludeBuilder<T>>.IncludeTimeSeries(String[] names, TimeSeriesRangeType type, TimeValue time);
    private sealed virtual override IIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IAbstractTimeSeriesIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IIncludeBuilder<T>>.IncludeTimeSeries(String[] names, TimeSeriesRangeType type, int count);
    private sealed virtual override IIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IAbstractTimeSeriesIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IIncludeBuilder<T>>.IncludeAllTimeSeries(TimeSeriesRangeType type, TimeValue time);
    private sealed virtual override IIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IAbstractTimeSeriesIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IIncludeBuilder<T>>.IncludeAllTimeSeries(TimeSeriesRangeType type, int count);
    private sealed virtual override IQueryIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IAbstractTimeSeriesIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IQueryIncludeBuilder<T>>.IncludeTimeSeries(string name, TimeSeriesRangeType type, TimeValue time);
    private sealed virtual override IQueryIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IAbstractTimeSeriesIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IQueryIncludeBuilder<T>>.IncludeTimeSeries(string name, TimeSeriesRangeType type, int count);
    private sealed virtual override IQueryIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IAbstractTimeSeriesIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IQueryIncludeBuilder<T>>.IncludeTimeSeries(String[] names, TimeSeriesRangeType type, TimeValue time);
    private sealed virtual override IQueryIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IAbstractTimeSeriesIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IQueryIncludeBuilder<T>>.IncludeTimeSeries(String[] names, TimeSeriesRangeType type, int count);
    private sealed virtual override IQueryIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IAbstractTimeSeriesIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IQueryIncludeBuilder<T>>.IncludeAllTimeSeries(TimeSeriesRangeType type, TimeValue time);
    private sealed virtual override IQueryIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IAbstractTimeSeriesIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IQueryIncludeBuilder<T>>.IncludeAllTimeSeries(TimeSeriesRangeType type, int count);
    private sealed virtual override ISubscriptionIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IAbstractTimeSeriesIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.ISubscriptionIncludeBuilder<T>>.IncludeTimeSeries(string name, TimeSeriesRangeType type, TimeValue time);
    private sealed virtual override ISubscriptionIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IAbstractTimeSeriesIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.ISubscriptionIncludeBuilder<T>>.IncludeTimeSeries(string name, TimeSeriesRangeType type, int count);
    private sealed virtual override ISubscriptionIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IAbstractTimeSeriesIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.ISubscriptionIncludeBuilder<T>>.IncludeTimeSeries(String[] names, TimeSeriesRangeType type, TimeValue time);
    private sealed virtual override ISubscriptionIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IAbstractTimeSeriesIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.ISubscriptionIncludeBuilder<T>>.IncludeTimeSeries(String[] names, TimeSeriesRangeType type, int count);
    private sealed virtual override ISubscriptionIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IAbstractTimeSeriesIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.ISubscriptionIncludeBuilder<T>>.IncludeAllTimeSeries(TimeSeriesRangeType type, TimeValue time);
    private sealed virtual override ISubscriptionIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IAbstractTimeSeriesIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.ISubscriptionIncludeBuilder<T>>.IncludeAllTimeSeries(TimeSeriesRangeType type, int count);
    private void IncludeDocuments(string path);
    private void IncludeCompareExchangeValue(string path);
    private void IncludeCounterWithAlias(Expression`1<Func`2<T, string>> path, string name);
    private void IncludeCountersWithAlias(Expression`1<Func`2<T, string>> path, String[] names);
    private void IncludeRevisionsBefore(DateTime dateTime);
    private void IncludeRevisionsByChangeVectors(string path);
    private void IncludeCounter(string path, string name);
    private void IncludeCounters(string path, String[] names);
    private void IncludeAllCountersWithAlias(Expression`1<Func`2<T, string>> path);
    private void IncludeAllCounters(string sourcePath);
    private void AssertNotAllAndAddNewEntryIfNeeded(string path);
    private void WithAlias(Expression`1<Func`2<T, string>> path);
    private void WithAlias(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    private void IncludeTimeSeriesFromTo(string alias, string name, Nullable`1<DateTime> from, Nullable`1<DateTime> to);
    private void IncludeTimeSeriesByRangeTypeAndTime(string alias, string name, TimeSeriesRangeType type, TimeValue time);
    private void IncludeTimeSeriesByRangeTypeAndCount(string alias, string name, TimeSeriesRangeType type, int count);
    private void IncludeArrayOfTimeSeriesByRangeTypeAndTime(String[] names, TimeSeriesRangeType type, TimeValue time);
    private void IncludeArrayOfTimeSeriesByRangeTypeAndCount(String[] names, TimeSeriesRangeType type, int count);
    private void AssertValid(string alias, string name);
    private sealed virtual override IQueryIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IRevisionIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IQueryIncludeBuilder<T>>.IncludeRevisions(Expression`1<Func`2<T, string>> changeVectorPath);
    private sealed virtual override IIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IRevisionIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IIncludeBuilder<T>>.IncludeRevisions(Expression`1<Func`2<T, string>> changeVectorPath);
    private sealed virtual override IIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IRevisionIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IIncludeBuilder<T>>.IncludeRevisions(Expression`1<Func`2<T, IEnumerable`1<string>>> changeVectorPaths);
    private sealed virtual override IQueryIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IRevisionIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IQueryIncludeBuilder<T>>.IncludeRevisions(DateTime before);
    private sealed virtual override IIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IRevisionIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IIncludeBuilder<T>>.IncludeRevisions(DateTime before);
    private sealed virtual override IQueryIncludeBuilder`1<T> Raven.Client.Documents.Session.Loaders.IRevisionIncludeBuilder<T,Raven.Client.Documents.Session.Loaders.IQueryIncludeBuilder<T>>.IncludeRevisions(Expression`1<Func`2<T, IEnumerable`1<string>>> changeVectorPaths);
    [CompilerGeneratedAttribute]
internal static void <IncludeTimeSeriesByRangeTypeAndTime>g__AssertValidType|73_0(TimeSeriesRangeType type, TimeValue time);
    [CompilerGeneratedAttribute]
internal static void <IncludeTimeSeriesByRangeTypeAndCount>g__AssertValidTypeAndCount|74_0(TimeSeriesRangeType type, int count);
}
public interface Raven.Client.Documents.Session.Loaders.IQueryIncludeBuilder`1 {
    public abstract virtual IQueryIncludeBuilder`1<T> IncludeCounter(Expression`1<Func`2<T, string>> path, string name);
    public abstract virtual IQueryIncludeBuilder`1<T> IncludeCounters(Expression`1<Func`2<T, string>> path, String[] names);
    public abstract virtual IQueryIncludeBuilder`1<T> IncludeAllCounters(Expression`1<Func`2<T, string>> path);
    public abstract virtual IQueryIncludeBuilder`1<T> IncludeTimeSeries(Expression`1<Func`2<T, string>> path, string name, DateTime from, DateTime to);
}
public interface Raven.Client.Documents.Session.Loaders.IRevisionIncludeBuilder`2 {
    public abstract virtual TBuilder IncludeRevisions(Expression`1<Func`2<T, string>> path);
    public abstract virtual TBuilder IncludeRevisions(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    public abstract virtual TBuilder IncludeRevisions(DateTime before);
}
public interface Raven.Client.Documents.Session.Loaders.ISubscriptionIncludeBuilder`1 {
}
public interface Raven.Client.Documents.Session.Loaders.ISubscriptionTimeSeriesIncludeBuilder`2 {
}
public interface Raven.Client.Documents.Session.Loaders.ITimeSeriesIncludeBuilder {
    public abstract virtual ITimeSeriesIncludeBuilder IncludeTags();
    public abstract virtual ITimeSeriesIncludeBuilder IncludeDocument();
}
public interface Raven.Client.Documents.Session.Loaders.ITimeSeriesIncludeBuilder`2 {
    public abstract virtual TBuilder IncludeTimeSeries(string name, Nullable`1<DateTime> from, Nullable`1<DateTime> to);
}
internal class Raven.Client.Documents.Session.Loaders.LazyMultiLoaderWithInclude`1 : object {
    private IDocumentSessionImpl _session;
    private List`1<string> _includes;
    internal LazyMultiLoaderWithInclude`1(IDocumentSessionImpl session);
    public sealed virtual ILazyLoaderWithInclude`1<T> Include(string path);
    public sealed virtual ILazyLoaderWithInclude`1<T> Include(Expression`1<Func`2<T, string>> path);
    public sealed virtual ILazyLoaderWithInclude`1<T> Include(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    public sealed virtual Lazy`1<Dictionary`2<string, T>> Load(String[] ids);
    public sealed virtual Lazy`1<Dictionary`2<string, T>> Load(IEnumerable`1<string> ids);
    public sealed virtual Lazy`1<T> Load(string id);
    public sealed virtual Lazy`1<Dictionary`2<string, TResult>> Load(String[] ids);
    public sealed virtual Lazy`1<Dictionary`2<string, TResult>> Load(IEnumerable`1<string> ids);
    public sealed virtual Lazy`1<TResult> Load(string id);
}
internal class Raven.Client.Documents.Session.Loaders.MultiLoaderWithInclude`1 : object {
    private IDocumentSessionImpl _session;
    private List`1<string> _includes;
    internal MultiLoaderWithInclude`1(IDocumentSessionImpl session);
    public sealed virtual ILoaderWithInclude`1<T> Include(string path);
    public sealed virtual ILoaderWithInclude`1<T> Include(Expression`1<Func`2<T, string>> path);
    public sealed virtual ILoaderWithInclude`1<T> Include(Expression`1<Func`2<T, string>> path);
    public sealed virtual ILoaderWithInclude`1<T> Include(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    public sealed virtual ILoaderWithInclude`1<T> Include(Expression`1<Func`2<T, IEnumerable`1<string>>> path);
    public sealed virtual Dictionary`2<string, T> Load(String[] ids);
    public sealed virtual Dictionary`2<string, T> Load(IEnumerable`1<string> ids);
    public sealed virtual T Load(string id);
    public sealed virtual Dictionary`2<string, TResult> Load(String[] ids);
    public sealed virtual Dictionary`2<string, TResult> Load(IEnumerable`1<string> ids);
    public sealed virtual TResult Load(string id);
}
public abstract class Raven.Client.Documents.Session.MethodCall : object {
    public Object[] Args;
    public string AccessPath;
}
internal class Raven.Client.Documents.Session.Operations.BatchOperation : object {
    private InMemoryDocumentSessionOperations _session;
    private List`1<object> _entities;
    private int _sessionCommandsCount;
    private int _allCommandsCount;
    private ActionsToRunOnSuccess _onSuccessfulRequest;
    private Dictionary`2<LazyStringValue, DocumentInfo> _modifications;
    public BatchOperation(InMemoryDocumentSessionOperations session);
    public SingleNodeBatchCommand CreateRequest();
    public void SetResult(BatchCommandResult result);
    private void FinalizeResult();
    private void ApplyMetadataModifications(LazyStringValue id, DocumentInfo documentInfo);
    private DocumentInfo GetOrAddModifications(LazyStringValue id, DocumentInfo documentInfo, bool applyModifications);
    private void HandleCompareExchangePut(BlittableJsonReaderObject batchResult);
    private void HandleCompareExchangeDelete(BlittableJsonReaderObject batchResult);
    private void HandleCompareExchangeInternal(CommandType commandType, BlittableJsonReaderObject batchResult);
    private void HandleAttachmentCopy(BlittableJsonReaderObject batchResult);
    private void HandleAttachmentMove(BlittableJsonReaderObject batchResult);
    private void HandleAttachmentDelete(BlittableJsonReaderObject batchResult);
    private void HandleAttachmentDeleteInternal(BlittableJsonReaderObject batchResult, CommandType type, string idFieldName, string attachmentNameFieldName, string documentChangeVectorFieldName);
    private void HandleAttachmentPut(BlittableJsonReaderObject batchResult);
    private void HandleAttachmentPutInternal(BlittableJsonReaderObject batchResult, CommandType type, string idFieldName, string attachmentNameFieldName, string documentChangeVectorFieldName);
    private void HandlePatch(BlittableJsonReaderObject batchResult);
    private void HandleJsonPatch(BlittableJsonReaderObject result);
    private void HandleDelete(BlittableJsonReaderObject batchResult);
    private void HandleDeleteInternal(BlittableJsonReaderObject batchResult, CommandType type);
    private void HandleForceRevisionCreation(BlittableJsonReaderObject batchResult);
    private void HandlePut(int index, BlittableJsonReaderObject batchResult, bool isDeferred);
    private void HandleMetadataModifications(DocumentInfo documentInfo, BlittableJsonReaderObject batchResult, LazyStringValue id, string changeVector);
    private void HandleCounters(BlittableJsonReaderObject batchResult);
    private static LazyStringValue GetLazyStringField(BlittableJsonReaderObject json, CommandType type, string fieldName, bool throwOnMissing);
    private static long GetLongField(BlittableJsonReaderObject json, CommandType type, string fieldName);
    private static bool GetBooleanField(BlittableJsonReaderObject json, CommandType type, string fieldName);
    private static void ThrowInvalidValue(string arg, string fieldName);
    private static void ThrowMissingField(CommandType type, string fieldName);
    private static void ThrowOnNullResults();
    [CompilerGeneratedAttribute]
internal static CommandType <SetResult>g__GetCommandType|8_0(BlittableJsonReaderObject batchResult);
}
internal class Raven.Client.Documents.Session.Operations.GetRevisionOperation : object {
    private InMemoryDocumentSessionOperations _session;
    private BlittableArrayResult _result;
    private GetRevisionsCommand _command;
    internal GetRevisionsCommand Command { get; }
    public GetRevisionOperation(InMemoryDocumentSessionOperations session, string id, Nullable`1<int> start, Nullable`1<int> pageSize, bool metadataOnly);
    public GetRevisionOperation(InMemoryDocumentSessionOperations session, string id, DateTime before);
    public GetRevisionOperation(InMemoryDocumentSessionOperations session, string changeVector);
    public GetRevisionOperation(InMemoryDocumentSessionOperations session, IEnumerable`1<string> changeVectors);
    public GetRevisionsCommand CreateRequest();
    public void SetResult(BlittableArrayResult result);
    internal GetRevisionsCommand get_Command();
    private T GetRevision(BlittableJsonReaderObject document);
    public List`1<T> GetRevisionsFor();
    public List`1<IMetadataDictionary> GetRevisionsMetadataFor();
    public T GetRevision();
    public Dictionary`2<string, T> GetRevisions();
}
internal class Raven.Client.Documents.Session.Operations.GetRevisionsCountOperation : object {
    private string _docId;
    public GetRevisionsCountOperation(string docId);
    public RavenCommand`1<long> CreateRequest();
}
public interface Raven.Client.Documents.Session.Operations.Lazy.IAsyncEagerSessionOperations {
    public abstract virtual Task`1<ResponseTimeInformation> ExecuteAllPendingLazyOperationsAsync(CancellationToken token);
}
public interface Raven.Client.Documents.Session.Operations.Lazy.IAsyncLazySessionOperations {
    public abstract virtual IAsyncLazyLoaderWithInclude`1<object> Include(string path);
    public abstract virtual IAsyncLazyLoaderWithInclude`1<TResult> Include(Expression`1<Func`2<TResult, string>> path);
    public abstract virtual IAsyncLazyLoaderWithInclude`1<TResult> Include(Expression`1<Func`2<TResult, IEnumerable`1<string>>> path);
    public abstract virtual Lazy`1<Task`1<Dictionary`2<string, TResult>>> LoadAsync(IEnumerable`1<string> ids, CancellationToken token);
    public abstract virtual Lazy`1<Task`1<Dictionary`2<string, TResult>>> LoadAsync(IEnumerable`1<string> ids, Action`1<Dictionary`2<string, TResult>> onEval, CancellationToken token);
    public abstract virtual Lazy`1<Task`1<TResult>> LoadAsync(string id, CancellationToken token);
    public abstract virtual Lazy`1<Task`1<TResult>> LoadAsync(string id, Action`1<TResult> onEval, CancellationToken token);
    public abstract virtual Lazy`1<Task`1<Dictionary`2<string, TResult>>> LoadStartingWithAsync(string idPrefix, string matches, int start, int pageSize, string exclude, string startAfter, CancellationToken token);
    public abstract virtual Lazy`1<Task`1<ValueTuple`2<T, string>>> ConditionalLoadAsync(string id, string changeVector, CancellationToken token);
}
public interface Raven.Client.Documents.Session.Operations.Lazy.IEagerSessionOperations {
    public abstract virtual ResponseTimeInformation ExecuteAllPendingLazyOperations();
}
public interface Raven.Client.Documents.Session.Operations.Lazy.ILazyOperation {
    public object Result { get; }
    public QueryResult QueryResult { get; }
    public bool RequiresRetry { get; }
    public abstract virtual GetRequest CreateRequest(JsonOperationContext ctx);
    public abstract virtual object get_Result();
    public abstract virtual QueryResult get_QueryResult();
    public abstract virtual bool get_RequiresRetry();
    public abstract virtual void HandleResponse(GetResponse response);
}
public interface Raven.Client.Documents.Session.Operations.Lazy.ILazySessionOperations {
    public abstract virtual ILazyLoaderWithInclude`1<object> Include(string path);
    public abstract virtual ILazyLoaderWithInclude`1<TResult> Include(Expression`1<Func`2<TResult, string>> path);
    public abstract virtual ILazyLoaderWithInclude`1<TResult> Include(Expression`1<Func`2<TResult, IEnumerable`1<string>>> path);
    public abstract virtual Lazy`1<Dictionary`2<string, TResult>> Load(IEnumerable`1<string> ids);
    public abstract virtual Lazy`1<Dictionary`2<string, TResult>> Load(IEnumerable`1<string> ids, Action`1<Dictionary`2<string, TResult>> onEval);
    public abstract virtual Lazy`1<TResult> Load(string id);
    public abstract virtual Lazy`1<TResult> Load(string id, Action`1<TResult> onEval);
    public abstract virtual Lazy`1<Dictionary`2<string, TResult>> LoadStartingWith(string idPrefix, string matches, int start, int pageSize, string exclude, string startAfter);
    public abstract virtual Lazy`1<ValueTuple`2<T, string>> ConditionalLoad(string id, string changeVector);
}
internal class Raven.Client.Documents.Session.Operations.Lazy.IndexQueryContent : object {
    private DocumentConventions _conventions;
    private IndexQuery _query;
    public IndexQueryContent(DocumentConventions conventions, IndexQuery query);
    public sealed virtual void WriteContent(AbstractBlittableJsonTextWriter writer, JsonOperationContext context);
}
internal class Raven.Client.Documents.Session.Operations.Lazy.LazyAggregationQueryOperation : object {
    private InMemoryDocumentSessionOperations _session;
    private IndexQuery _indexQuery;
    private Action`1<QueryResult> _invokeAfterQueryExecuted;
    private Func`2<QueryResult, Dictionary`2<string, FacetResult>> _processResults;
    [CompilerGeneratedAttribute]
private object <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryResult <QueryResult>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresRetry>k__BackingField;
    public object Result { get; private set; }
    public QueryResult QueryResult { get; private set; }
    public bool RequiresRetry { get; private set; }
    public LazyAggregationQueryOperation(InMemoryDocumentSessionOperations session, IndexQuery indexQuery, Action`1<QueryResult> invokeAfterQueryExecuted, Func`2<QueryResult, Dictionary`2<string, FacetResult>> processResults);
    public sealed virtual GetRequest CreateRequest(JsonOperationContext ctx);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Result();
    [CompilerGeneratedAttribute]
private void set_Result(object value);
    [CompilerGeneratedAttribute]
public sealed virtual QueryResult get_QueryResult();
    [CompilerGeneratedAttribute]
private void set_QueryResult(QueryResult value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequiresRetry();
    [CompilerGeneratedAttribute]
private void set_RequiresRetry(bool value);
    public sealed virtual void HandleResponse(GetResponse response);
    private void HandleResponse(QueryResult queryResult);
}
internal class Raven.Client.Documents.Session.Operations.Lazy.LazyConditionalLoadOperation`1 : object {
    private InMemoryDocumentSessionOperations _session;
    private string _id;
    private string _changeVector;
    [CompilerGeneratedAttribute]
private object <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresRetry>k__BackingField;
    public object Result { get; public set; }
    public QueryResult QueryResult { get; }
    public bool RequiresRetry { get; private set; }
    public LazyConditionalLoadOperation`1(string id, string changeVector, InMemoryDocumentSessionOperations session);
    public sealed virtual GetRequest CreateRequest(JsonOperationContext ctx);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(object value);
    public sealed virtual QueryResult get_QueryResult();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequiresRetry();
    [CompilerGeneratedAttribute]
private void set_RequiresRetry(bool value);
    public sealed virtual void HandleResponse(GetResponse response);
}
internal class Raven.Client.Documents.Session.Operations.Lazy.LazyGetCompareExchangeValueOperation`1 : object {
    private ClusterTransactionOperationsBase _clusterSession;
    private DocumentConventions _conventions;
    private string _key;
    [CompilerGeneratedAttribute]
private object <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresRetry>k__BackingField;
    public object Result { get; private set; }
    public QueryResult QueryResult { get; }
    public bool RequiresRetry { get; private set; }
    public LazyGetCompareExchangeValueOperation`1(ClusterTransactionOperationsBase clusterSession, DocumentConventions conventions, string key);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Result();
    [CompilerGeneratedAttribute]
private void set_Result(object value);
    public sealed virtual QueryResult get_QueryResult();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequiresRetry();
    [CompilerGeneratedAttribute]
private void set_RequiresRetry(bool value);
    public sealed virtual GetRequest CreateRequest(JsonOperationContext ctx);
    public sealed virtual void HandleResponse(GetResponse response);
}
internal class Raven.Client.Documents.Session.Operations.Lazy.LazyGetCompareExchangeValuesOperation`1 : object {
    private ClusterTransactionOperationsBase _clusterSession;
    private DocumentConventions _conventions;
    private string _startsWith;
    private int _start;
    private int _pageSize;
    private String[] _keys;
    [CompilerGeneratedAttribute]
private object <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresRetry>k__BackingField;
    public object Result { get; private set; }
    public QueryResult QueryResult { get; }
    public bool RequiresRetry { get; private set; }
    public LazyGetCompareExchangeValuesOperation`1(ClusterTransactionOperationsBase clusterSession, DocumentConventions conventions, String[] keys);
    public LazyGetCompareExchangeValuesOperation`1(ClusterTransactionOperationsBase clusterSession, DocumentConventions conventions, string startsWith, int start, int pageSize);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Result();
    [CompilerGeneratedAttribute]
private void set_Result(object value);
    public sealed virtual QueryResult get_QueryResult();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequiresRetry();
    [CompilerGeneratedAttribute]
private void set_RequiresRetry(bool value);
    public sealed virtual GetRequest CreateRequest(JsonOperationContext ctx);
    public sealed virtual void HandleResponse(GetResponse response);
}
internal class Raven.Client.Documents.Session.Operations.Lazy.LazyLoadOperation`1 : object {
    private InMemoryDocumentSessionOperations _session;
    private LoadOperation _loadOperation;
    private String[] _ids;
    private String[] _includes;
    private List`1<string> _alreadyInSession;
    [CompilerGeneratedAttribute]
private object <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryResult <QueryResult>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresRetry>k__BackingField;
    public object Result { get; public set; }
    public QueryResult QueryResult { get; public set; }
    public bool RequiresRetry { get; public set; }
    public LazyLoadOperation`1(InMemoryDocumentSessionOperations session, LoadOperation loadOperation);
    public sealed virtual GetRequest CreateRequest(JsonOperationContext ctx);
    public LazyLoadOperation`1<T> ById(string id);
    public LazyLoadOperation`1<T> ByIds(IEnumerable`1<string> ids);
    public LazyLoadOperation`1<T> WithIncludes(String[] includes);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(object value);
    [CompilerGeneratedAttribute]
public sealed virtual QueryResult get_QueryResult();
    [CompilerGeneratedAttribute]
public void set_QueryResult(QueryResult value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequiresRetry();
    [CompilerGeneratedAttribute]
public void set_RequiresRetry(bool value);
    public sealed virtual void HandleResponse(GetResponse response);
    private void HandleResponse(GetDocumentsResult loadResult);
}
internal class Raven.Client.Documents.Session.Operations.Lazy.LazyQueryOperation`1 : object {
    private InMemoryDocumentSessionOperations _session;
    private QueryOperation _queryOperation;
    private Action`1<QueryResult> _afterQueryExecuted;
    [CompilerGeneratedAttribute]
private object <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryResult <QueryResult>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresRetry>k__BackingField;
    public object Result { get; public set; }
    public QueryResult QueryResult { get; public set; }
    public bool RequiresRetry { get; public set; }
    public LazyQueryOperation`1(InMemoryDocumentSessionOperations session, QueryOperation queryOperation, Action`1<QueryResult> afterQueryExecuted);
    public sealed virtual GetRequest CreateRequest(JsonOperationContext ctx);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(object value);
    [CompilerGeneratedAttribute]
public sealed virtual QueryResult get_QueryResult();
    [CompilerGeneratedAttribute]
public void set_QueryResult(QueryResult value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequiresRetry();
    [CompilerGeneratedAttribute]
public void set_RequiresRetry(bool value);
    public sealed virtual void HandleResponse(GetResponse response);
    private void HandleResponse(QueryResult queryResult, TimeSpan duration);
}
internal class Raven.Client.Documents.Session.Operations.Lazy.LazyRevisionOperation`1 : object {
    private GetRevisionOperation _getRevisionOperation;
    private Mode<T> _mode;
    [CompilerGeneratedAttribute]
private object <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryResult <QueryResult>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresRetry>k__BackingField;
    public object Result { get; public set; }
    public QueryResult QueryResult { get; public set; }
    public bool RequiresRetry { get; public set; }
    public LazyRevisionOperation`1(GetRevisionOperation getRevisionOperation, Mode<T> mode);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(object value);
    [CompilerGeneratedAttribute]
public sealed virtual QueryResult get_QueryResult();
    [CompilerGeneratedAttribute]
public void set_QueryResult(QueryResult value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequiresRetry();
    [CompilerGeneratedAttribute]
public void set_RequiresRetry(bool value);
    public sealed virtual GetRequest CreateRequest(JsonOperationContext ctx);
    public sealed virtual void HandleResponse(GetResponse response);
}
internal class Raven.Client.Documents.Session.Operations.Lazy.LazyStartsWithOperation`1 : object {
    private string _idPrefix;
    private string _matches;
    private string _exclude;
    private int _start;
    private int _pageSize;
    private InMemoryDocumentSessionOperations _sessionOperations;
    private string _startAfter;
    [CompilerGeneratedAttribute]
private object <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryResult <QueryResult>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresRetry>k__BackingField;
    public object Result { get; public set; }
    public QueryResult QueryResult { get; public set; }
    public bool RequiresRetry { get; public set; }
    public LazyStartsWithOperation`1(string idPrefix, string matches, string exclude, int start, int pageSize, InMemoryDocumentSessionOperations sessionOperations, string startAfter);
    public sealed virtual GetRequest CreateRequest(JsonOperationContext ctx);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(object value);
    [CompilerGeneratedAttribute]
public sealed virtual QueryResult get_QueryResult();
    [CompilerGeneratedAttribute]
public void set_QueryResult(QueryResult value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequiresRetry();
    [CompilerGeneratedAttribute]
public void set_RequiresRetry(bool value);
    public sealed virtual void HandleResponse(GetResponse response);
}
internal class Raven.Client.Documents.Session.Operations.Lazy.LazySuggestionQueryOperation : object {
    private InMemoryDocumentSessionOperations _session;
    private IndexQuery _indexQuery;
    private Action`1<QueryResult> _invokeAfterQueryExecuted;
    private Func`2<QueryResult, Dictionary`2<string, SuggestionResult>> _processResults;
    [CompilerGeneratedAttribute]
private object <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryResult <QueryResult>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresRetry>k__BackingField;
    public object Result { get; private set; }
    public QueryResult QueryResult { get; private set; }
    public bool RequiresRetry { get; private set; }
    public LazySuggestionQueryOperation(InMemoryDocumentSessionOperations session, IndexQuery indexQuery, Action`1<QueryResult> invokeAfterQueryExecuted, Func`2<QueryResult, Dictionary`2<string, SuggestionResult>> processResults);
    public sealed virtual GetRequest CreateRequest(JsonOperationContext ctx);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Result();
    [CompilerGeneratedAttribute]
private void set_Result(object value);
    [CompilerGeneratedAttribute]
public sealed virtual QueryResult get_QueryResult();
    [CompilerGeneratedAttribute]
private void set_QueryResult(QueryResult value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequiresRetry();
    [CompilerGeneratedAttribute]
private void set_RequiresRetry(bool value);
    public sealed virtual void HandleResponse(GetResponse response);
    private void HandleResponse(QueryResult queryResult);
}
internal class Raven.Client.Documents.Session.Operations.LoadOperation : object {
    private InMemoryDocumentSessionOperations _session;
    private static Logger Logger;
    private String[] _ids;
    private String[] _includes;
    private String[] _countersToInclude;
    private String[] _revisionsToIncludeByChangeVector;
    private Nullable`1<DateTime> _revisionsToIncludeByDateTimeBefore;
    private String[] _compareExchangeValuesToInclude;
    private bool _includeAllCounters;
    private IEnumerable`1<AbstractTimeSeriesRange> _timeSeriesToInclude;
    private bool _resultsSet;
    private GetDocumentsResult _results;
    public LoadOperation(InMemoryDocumentSessionOperations session);
    private static LoadOperation();
    public GetDocumentsCommand CreateRequest();
    public LoadOperation ById(string id);
    public LoadOperation WithIncludes(String[] includes);
    public LoadOperation WithCompareExchange(String[] compareExchangeValues);
    public LoadOperation WithCounters(String[] counters);
    public LoadOperation WithRevisions(String[] revisionsByChangeVector);
    public LoadOperation WithRevisions(Nullable`1<DateTime> revisionByDateTimeBefore);
    public LoadOperation WithAllCounters();
    public LoadOperation WithTimeSeries(IEnumerable`1<AbstractTimeSeriesRange> timeseries);
    public LoadOperation ByIds(IEnumerable`1<string> ids);
    public T GetDocument();
    private T GetDocument(string id);
    public Dictionary`2<string, T> GetDocuments();
    public void SetResult(GetDocumentsResult result);
    [IteratorStateMachineAttribute("Raven.Client.Documents.Session.Operations.LoadOperation/<GetDocumentsFromResult>d__27")]
private static IEnumerable`1<DocumentInfo> GetDocumentsFromResult(GetDocumentsResult result);
}
internal class Raven.Client.Documents.Session.Operations.LoadStartingWithOperation : object {
    private static Logger Logger;
    private InMemoryDocumentSessionOperations _session;
    private string _startWith;
    private string _matches;
    private int _start;
    private int _pageSize;
    private string _exclude;
    private string _startAfter;
    private List`1<string> _returnedIds;
    private bool _resultsSet;
    private GetDocumentsResult _results;
    public LoadStartingWithOperation(InMemoryDocumentSessionOperations session);
    private static LoadStartingWithOperation();
    public GetDocumentsCommand CreateRequest();
    public void WithStartWith(string idPrefix, string matches, int start, int pageSize, string exclude, string startAfter);
    public void SetResult(GetDocumentsResult result);
    public T[] GetDocuments();
    private T GetDocument(string id);
    [IteratorStateMachineAttribute("Raven.Client.Documents.Session.Operations.LoadStartingWithOperation/<GetDocumentsFromResult>d__17")]
private static IEnumerable`1<DocumentInfo> GetDocumentsFromResult(GetDocumentsResult result);
}
internal class Raven.Client.Documents.Session.Operations.MultiGetOperation : object {
    private InMemoryDocumentSessionOperations _session;
    public MultiGetOperation(InMemoryDocumentSessionOperations session);
    public MultiGetCommand CreateRequest(List`1<GetRequest> requests);
    public void SetResult(BlittableArrayResult result);
}
public class Raven.Client.Documents.Session.Operations.QueryOperation : object {
    private InMemoryDocumentSessionOperations _session;
    private string _indexName;
    private IndexQuery _indexQuery;
    private bool _metadataOnly;
    private bool _indexEntriesOnly;
    private bool _isProjectInto;
    private QueryResult _currentQueryResults;
    private FieldsToFetchToken _fieldsToFetch;
    private Stopwatch _sp;
    private static Logger Logger;
    private static PropertyInfo[] _facetResultProperties;
    private static ConcurrentDictionary`2<Type, ValueTuple`2<Type, PropertyInfo>> _wrapperTypes;
    private static string DummyPropertyName;
    [CompilerGeneratedAttribute]
private bool <NoTracking>k__BackingField;
    public QueryResult CurrentQueryResults { get; }
    public bool NoTracking { get; public set; }
    public IndexQuery IndexQuery { get; }
    public QueryOperation(InMemoryDocumentSessionOperations session, string indexName, IndexQuery indexQuery, FieldsToFetchToken fieldsToFetch, bool disableEntitiesTracking, bool metadataOnly, bool indexEntriesOnly, bool isProjectInto);
    private static QueryOperation();
    public QueryResult get_CurrentQueryResults();
    public QueryCommand CreateRequest();
    public void SetResult(QueryResult queryResult);
    private void StartTiming();
    public void LogQuery();
    public IDisposable EnterQueryContext();
    internal T[] CompleteAsArray();
    public List`1<T> Complete();
    private void CompleteInternal(QueryResult queryResult, Action`2<int, T> addToResult);
    internal static T Deserialize(string id, BlittableJsonReaderObject document, BlittableJsonReaderObject metadata, FieldsToFetchToken fieldsToFetch, bool disableEntitiesTracking, InMemoryDocumentSessionOperations session, bool isProjectInto);
    private static ValueTuple`2<Type, PropertyInfo> AddWrapperTypeAndPropertyToCache();
    private static T DeserializeInnerArray(BlittableJsonReaderObject document, string fieldToFetch, InMemoryDocumentSessionOperations session, BlittableJsonReaderArray blittableArray);
    [CompilerGeneratedAttribute]
public bool get_NoTracking();
    [CompilerGeneratedAttribute]
public void set_NoTracking(bool value);
    public void EnsureIsAcceptableAndSaveResult(QueryResult result);
    internal void EnsureIsAcceptableAndSaveResult(QueryResult result, Nullable`1<TimeSpan> duration);
    private void SaveQueryResult(QueryResult result);
    public static void EnsureIsAcceptable(QueryResult result, bool waitForNonStaleResults, Stopwatch duration, InMemoryDocumentSessionOperations session);
    public static void EnsureIsAcceptable(QueryResult result, bool waitForNonStaleResults, Nullable`1<TimeSpan> duration, InMemoryDocumentSessionOperations session);
    public IndexQuery get_IndexQuery();
}
internal class Raven.Client.Documents.Session.Operations.SessionOperationExecutor : OperationExecutor {
    private InMemoryDocumentSessionOperations _session;
    public SessionOperationExecutor(InMemoryDocumentSessionOperations session);
    public virtual OperationExecutor ForDatabase(string databaseName);
    protected virtual IDisposable GetContext(JsonOperationContext& context);
}
internal class Raven.Client.Documents.Session.Operations.StreamOperation : object {
    private InMemoryDocumentSessionOperations _session;
    private StreamQueryStatistics _statistics;
    private bool _isQueryStream;
    public StreamOperation(InMemoryDocumentSessionOperations session);
    public StreamOperation(InMemoryDocumentSessionOperations session, StreamQueryStatistics statistics);
    public QueryStreamCommand CreateRequest(IndexQuery query);
    public void EnsureIsAcceptable(string indexName, StreamResult result);
    public StreamCommand CreateRequest(string startsWith, string matches, int start, int pageSize, string exclude, string startAfter);
    internal static StreamCommand CreateStreamCommand(string startsWith, string matches, int start, int pageSize, string exclude, string startAfter, string format);
    internal static StreamCommand CreateCollectionDocsStreamCommand(string collectionName, int start, int pageSize);
    internal YieldStreamResults SetResultForTimeSeries(StreamResult response);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.Operations.StreamOperation/<SetResultForTimeSeriesAsync>d__11")]
internal Task`1<YieldStreamResults> SetResultForTimeSeriesAsync(StreamResult response);
    public IEnumerator`1<BlittableJsonReaderObject> SetResult(StreamResult response);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.Operations.StreamOperation/<SetResultAsync>d__13")]
public Task`1<YieldStreamResults> SetResultAsync(StreamResult response, CancellationToken token);
}
internal class Raven.Client.Documents.Session.Operations.TimeSeriesStreamOperation : StreamOperation {
    private string _docId;
    private string _name;
    private Nullable`1<DateTime> _from;
    private Nullable`1<DateTime> _to;
    private Nullable`1<TimeSpan> _offset;
    public TimeSeriesStreamOperation(InMemoryDocumentSessionOperations session, string docId, string name, Nullable`1<DateTime> from, Nullable`1<DateTime> to, Nullable`1<TimeSpan> offset);
    public TimeSeriesStreamOperation(InMemoryDocumentSessionOperations session, StreamQueryStatistics statistics, string docId, string name, Nullable`1<DateTime> from, Nullable`1<DateTime> to, Nullable`1<TimeSpan> offset);
    public StreamCommand CreateRequest();
}
public enum Raven.Client.Documents.Session.OrderingType : Enum {
    public int value__;
    public static OrderingType String;
    public static OrderingType Long;
    public static OrderingType Double;
    public static OrderingType AlphaNumeric;
}
internal static class Raven.Client.Documents.Session.OrderingUtil : object {
    public static OrderingType GetOrderingFromRangeType(RangeType rangeType);
}
public interface Raven.Client.Documents.Session.Querying.Sharding.IQueryShardedContextBuilder {
    public abstract virtual IQueryShardedContextBuilder ByDocumentId(string id);
    public abstract virtual IQueryShardedContextBuilder ByDocumentIds(IEnumerable`1<string> ids);
    public abstract virtual IQueryShardedContextBuilder ByPrefix(string prefix);
    public abstract virtual IQueryShardedContextBuilder ByPrefixes(IEnumerable`1<string> prefixes);
}
internal class Raven.Client.Documents.Session.Querying.Sharding.QueryShardedContextBuilder : object {
    [CompilerGeneratedAttribute]
private HashSet`1<string> <DocumentIds>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <Prefixes>k__BackingField;
    public HashSet`1<string> DocumentIds { get; }
    public HashSet`1<string> Prefixes { get; }
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_DocumentIds();
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_Prefixes();
    public sealed virtual IQueryShardedContextBuilder ByDocumentId(string id);
    public sealed virtual IQueryShardedContextBuilder ByDocumentIds(IEnumerable`1<string> ids);
    public sealed virtual IQueryShardedContextBuilder ByPrefix(string prefix);
    public sealed virtual IQueryShardedContextBuilder ByPrefixes(IEnumerable`1<string> prefixes);
}
public class Raven.Client.Documents.Session.QueryStatistics : object {
    [CompilerGeneratedAttribute]
private bool <IsStale>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DurationInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalResults>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SkippedResults>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ScannedResults>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <IndexTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastQueryTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ResultEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequestedByUser>k__BackingField;
    public bool IsStale { get; public set; }
    public long DurationInMs { get; public set; }
    public long TotalResults { get; public set; }
    public long SkippedResults { get; public set; }
    public Nullable`1<long> ScannedResults { get; public set; }
    public DateTime Timestamp { get; public set; }
    public string IndexName { get; public set; }
    public DateTime IndexTimestamp { get; public set; }
    public DateTime LastQueryTime { get; public set; }
    public Nullable`1<long> ResultEtag { get; public set; }
    public string NodeTag { get; public set; }
    internal bool RequestedByUser { get; internal set; }
    [CompilerGeneratedAttribute]
public bool get_IsStale();
    [CompilerGeneratedAttribute]
public void set_IsStale(bool value);
    [CompilerGeneratedAttribute]
public long get_DurationInMs();
    [CompilerGeneratedAttribute]
public void set_DurationInMs(long value);
    [CompilerGeneratedAttribute]
public long get_TotalResults();
    [CompilerGeneratedAttribute]
public void set_TotalResults(long value);
    [CompilerGeneratedAttribute]
public long get_SkippedResults();
    [CompilerGeneratedAttribute]
public void set_SkippedResults(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ScannedResults();
    [CompilerGeneratedAttribute]
public void set_ScannedResults(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTime value);
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    [CompilerGeneratedAttribute]
public DateTime get_IndexTimestamp();
    [CompilerGeneratedAttribute]
public void set_IndexTimestamp(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_LastQueryTime();
    [CompilerGeneratedAttribute]
public void set_LastQueryTime(DateTime value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ResultEtag();
    [CompilerGeneratedAttribute]
public void set_ResultEtag(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public string get_NodeTag();
    [CompilerGeneratedAttribute]
public void set_NodeTag(string value);
    internal void UpdateQueryStats(QueryResult qr);
    [CompilerGeneratedAttribute]
internal bool get_RequestedByUser();
    [CompilerGeneratedAttribute]
internal void set_RequestedByUser(bool value);
}
public class Raven.Client.Documents.Session.ResponseTimeInformation : object {
    [CompilerGeneratedAttribute]
private TimeSpan <TotalServerDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TotalClientDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ResponseTimeItem> <DurationBreakdown>k__BackingField;
    public TimeSpan TotalServerDuration { get; public set; }
    public TimeSpan TotalClientDuration { get; public set; }
    public List`1<ResponseTimeItem> DurationBreakdown { get; public set; }
    [CompilerGeneratedAttribute]
public TimeSpan get_TotalServerDuration();
    [CompilerGeneratedAttribute]
public void set_TotalServerDuration(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_TotalClientDuration();
    [CompilerGeneratedAttribute]
public void set_TotalClientDuration(TimeSpan value);
    [CompilerGeneratedAttribute]
public List`1<ResponseTimeItem> get_DurationBreakdown();
    [CompilerGeneratedAttribute]
public void set_DurationBreakdown(List`1<ResponseTimeItem> value);
    internal void ComputeServerTotal();
}
public class Raven.Client.Documents.Session.ResponseTimeItem : object {
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    public string Url { get; public set; }
    public TimeSpan Duration { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(TimeSpan value);
}
public abstract class Raven.Client.Documents.Session.SessionCountersBase : object {
    protected string DocId;
    protected InMemoryDocumentSessionOperations Session;
    protected SessionCountersBase(InMemoryDocumentSessionOperations session, string documentId);
    protected SessionCountersBase(InMemoryDocumentSessionOperations session, object entity);
    public sealed virtual void Increment(string counter, long delta);
    public sealed virtual void Delete(string counter);
    protected void ThrowEntityNotInSession(object entity);
    private static void ThrowIncrementCounterAfterDeleteAttempt(string documentId, string counter);
    private static void ThrowDeleteCounterAfterIncrementAttempt(string documentId, string counter);
    private static void ThrowDocumentAlreadyDeletedInSession(string documentId, string counter);
}
public class Raven.Client.Documents.Session.SessionCreatedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private InMemoryDocumentSessionOperations <Session>k__BackingField;
    public InMemoryDocumentSessionOperations Session { get; }
    public SessionCreatedEventArgs(InMemoryDocumentSessionOperations session);
    [CompilerGeneratedAttribute]
public InMemoryDocumentSessionOperations get_Session();
}
public class Raven.Client.Documents.Session.SessionDisposingEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private InMemoryDocumentSessionOperations <Session>k__BackingField;
    public InMemoryDocumentSessionOperations Session { get; }
    internal SessionDisposingEventArgs(InMemoryDocumentSessionOperations session);
    [CompilerGeneratedAttribute]
public InMemoryDocumentSessionOperations get_Session();
}
public class Raven.Client.Documents.Session.SessionDocumentCounters : object {
    private AsyncSessionDocumentCounters _asyncSessionCounters;
    public SessionDocumentCounters(InMemoryDocumentSessionOperations session, string documentId);
    public SessionDocumentCounters(InMemoryDocumentSessionOperations session, object entity);
    public sealed virtual Dictionary`2<string, Nullable`1<long>> GetAll();
    public sealed virtual Nullable`1<long> Get(string counter);
    public sealed virtual Dictionary`2<string, Nullable`1<long>> Get(IEnumerable`1<string> counters);
    public sealed virtual void Increment(string counter, long delta);
    public sealed virtual void Delete(string counter);
    [CompilerGeneratedAttribute]
private Task`1<Dictionary`2<string, Nullable`1<long>>> <GetAll>b__3_0();
}
public class Raven.Client.Documents.Session.SessionDocumentTimeSeries`1 : object {
    private AsyncSessionDocumentTimeSeries`1<TimeSeriesEntry> _asyncSessionTimeSeries;
    public SessionDocumentTimeSeries`1(InMemoryDocumentSessionOperations session, string documentId, string name);
    public SessionDocumentTimeSeries`1(InMemoryDocumentSessionOperations session, object entity, string name);
    private sealed virtual override void Raven.Client.Documents.Session.ISessionDocumentAppendTimeSeriesBase.Append(DateTime timestamp, IEnumerable`1<double> values, string tag);
    private sealed virtual override void Raven.Client.Documents.Session.ISessionDocumentAppendTimeSeriesBase.Append(DateTime timestamp, double value, string tag);
    private sealed virtual override void Raven.Client.Documents.Session.ISessionDocumentTypedAppendTimeSeriesBase<TValues>.Append(DateTime timestamp, TValues entry, string tag);
    private sealed virtual override void Raven.Client.Documents.Session.ISessionDocumentTypedAppendTimeSeriesBase<TValues>.Append(TimeSeriesEntry`1<TValues> entry);
    public sealed virtual TimeSeriesEntry[] Get(Nullable`1<DateTime> from, Nullable`1<DateTime> to, int start, int pageSize);
    public sealed virtual TimeSeriesEntry[] Get(Nullable`1<DateTime> from, Nullable`1<DateTime> to, Action`1<ITimeSeriesIncludeBuilder> includes, int start, int pageSize);
    private TimeSeriesEntry`1[] GetInternal(Nullable`1<DateTime> from, Nullable`1<DateTime> to, int start, int pageSize);
    private sealed virtual override TimeSeriesEntry`1[] Raven.Client.Documents.Session.ISessionDocumentTypedTimeSeries<TValues>.Get(Nullable`1<DateTime> from, Nullable`1<DateTime> to, int start, int pageSize);
    private sealed virtual override TimeSeriesRollupEntry`1[] Raven.Client.Documents.Session.ISessionDocumentRollupTypedTimeSeries<TValues>.Get(Nullable`1<DateTime> from, Nullable`1<DateTime> to, int start, int pageSize);
    public sealed virtual void Append(TimeSeriesRollupEntry`1<TValues> entry);
    private sealed virtual override TimeSeriesEntry`1[] Raven.Client.Documents.Session.ISessionDocumentTypedIncrementalTimeSeries<TValues>.Get(Nullable`1<DateTime> from, Nullable`1<DateTime> to, int start, int pageSize);
    private sealed virtual override void Raven.Client.Documents.Session.ISessionDocumentDeleteTimeSeriesBase.Delete(Nullable`1<DateTime> from, Nullable`1<DateTime> to);
    private sealed virtual override void Raven.Client.Documents.Session.ISessionDocumentDeleteTimeSeriesBase.Delete(DateTime at);
    private sealed virtual override IEnumerator`1<TimeSeriesEntry> Raven.Client.Documents.Session.ITimeSeriesStreamingBase<Raven.Client.Documents.Session.TimeSeries.TimeSeriesEntry>.Stream(Nullable`1<DateTime> from, Nullable`1<DateTime> to, Nullable`1<TimeSpan> offset);
    private sealed virtual override IEnumerator`1<TimeSeriesRollupEntry`1<TValues>> Raven.Client.Documents.Session.ITimeSeriesStreamingBase<Raven.Client.Documents.Session.TimeSeries.TimeSeriesRollupEntry<TValues>>.Stream(Nullable`1<DateTime> from, Nullable`1<DateTime> to, Nullable`1<TimeSpan> offset);
    private sealed virtual override IEnumerator`1<TimeSeriesEntry`1<TValues>> Raven.Client.Documents.Session.ITimeSeriesStreamingBase<Raven.Client.Documents.Session.TimeSeries.TimeSeriesEntry<TValues>>.Stream(Nullable`1<DateTime> from, Nullable`1<DateTime> to, Nullable`1<TimeSpan> offset);
    private void Increment(DateTime timestamp, IEnumerable`1<double> values);
    private sealed virtual override void Raven.Client.Documents.Session.ISessionDocumentIncrementTimeSeriesBase.Increment(DateTime timestamp, IEnumerable`1<double> values);
    private sealed virtual override void Raven.Client.Documents.Session.ISessionDocumentIncrementTimeSeriesBase.Increment(IEnumerable`1<double> values);
    private sealed virtual override void Raven.Client.Documents.Session.ISessionDocumentIncrementTimeSeriesBase.Increment(DateTime timestamp, double value);
    private sealed virtual override void Raven.Client.Documents.Session.ISessionDocumentIncrementTimeSeriesBase.Increment(double value);
    private sealed virtual override void Raven.Client.Documents.Session.ISessionDocumentTypedIncrementTimeSeriesBase<TValues>.Increment(DateTime timestamp, TValues entry);
    private sealed virtual override void Raven.Client.Documents.Session.ISessionDocumentTypedIncrementTimeSeriesBase<TValues>.Increment(TValues entry);
}
public class Raven.Client.Documents.Session.SessionInfo : object {
    [ThreadStaticAttribute]
private static int _clientSessionIdCounter;
    private Nullable`1<int> _sessionId;
    private bool _sessionIdUsed;
    private int _loadBalancerContextSeed;
    private bool _canUseLoadBalanceBehavior;
    private InMemoryDocumentSessionOperations _session;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <LastClusterTransactionIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AsyncCommandRunning>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoCaching>k__BackingField;
    public int SessionId { get; }
    internal bool CanUseLoadBalanceBehavior { get; }
    public Nullable`1<long> LastClusterTransactionIndex { get; public set; }
    public bool AsyncCommandRunning { get; public set; }
    public bool NoCaching { get; public set; }
    internal SessionInfo(InMemoryDocumentSessionOperations session, SessionOptions options, DocumentStoreBase documentStore, bool asyncCommandRunning);
    public int get_SessionId();
    internal void IncrementRequestCount();
    internal bool get_CanUseLoadBalanceBehavior();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_LastClusterTransactionIndex();
    [CompilerGeneratedAttribute]
public void set_LastClusterTransactionIndex(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public bool get_AsyncCommandRunning();
    [CompilerGeneratedAttribute]
public void set_AsyncCommandRunning(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoCaching();
    [CompilerGeneratedAttribute]
public void set_NoCaching(bool value);
    public void SetContext(string sessionKey);
    private void SetContextInternal(string sessionKey);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Session.SessionInfo/<GetCurrentSessionNode>d__26")]
internal Task`1<ServerNode> GetCurrentSessionNode(RequestExecutor requestExecutor);
}
public class Raven.Client.Documents.Session.SessionOptions : object {
    [CompilerGeneratedAttribute]
private string <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoTracking>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoCaching>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestExecutor <RequestExecutor>k__BackingField;
    [CompilerGeneratedAttribute]
private TransactionMode <TransactionMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <DisableAtomicDocumentWritesInClusterWideTransaction>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ShardedBatchBehavior> <ShardedBatchBehavior>k__BackingField;
    public string Database { get; public set; }
    public bool NoTracking { get; public set; }
    public bool NoCaching { get; public set; }
    public RequestExecutor RequestExecutor { get; public set; }
    public TransactionMode TransactionMode { get; public set; }
    public Nullable`1<bool> DisableAtomicDocumentWritesInClusterWideTransaction { get; public set; }
    public Nullable`1<ShardedBatchBehavior> ShardedBatchBehavior { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(string value);
    [CompilerGeneratedAttribute]
public bool get_NoTracking();
    [CompilerGeneratedAttribute]
public void set_NoTracking(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoCaching();
    [CompilerGeneratedAttribute]
public void set_NoCaching(bool value);
    [CompilerGeneratedAttribute]
public RequestExecutor get_RequestExecutor();
    [CompilerGeneratedAttribute]
public void set_RequestExecutor(RequestExecutor value);
    [CompilerGeneratedAttribute]
public TransactionMode get_TransactionMode();
    [CompilerGeneratedAttribute]
public void set_TransactionMode(TransactionMode value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_DisableAtomicDocumentWritesInClusterWideTransaction();
    [CompilerGeneratedAttribute]
public void set_DisableAtomicDocumentWritesInClusterWideTransaction(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ShardedBatchBehavior> get_ShardedBatchBehavior();
    [CompilerGeneratedAttribute]
public void set_ShardedBatchBehavior(Nullable`1<ShardedBatchBehavior> value);
}
public abstract class Raven.Client.Documents.Session.SessionTimeSeriesBase : object {
    protected string DocId;
    protected string Name;
    protected InMemoryDocumentSessionOperations Session;
    protected SessionTimeSeriesBase(InMemoryDocumentSessionOperations session, string documentId, string name);
    protected SessionTimeSeriesBase(InMemoryDocumentSessionOperations session, object entity, string name);
    public sealed virtual void Append(DateTime timestamp, double value, string tag);
    public void Append(DateTime timestamp, TValues value, string tag);
    public sealed virtual void Append(DateTime timestamp, IEnumerable`1<double> values, string tag);
    public sealed virtual void Delete(DateTime at);
    public sealed virtual void Delete(Nullable`1<DateTime> from, Nullable`1<DateTime> to);
    private void RemoveFromCacheIfNeeded(Nullable`1<DateTime> from, Nullable`1<DateTime> to);
    public void Increment(DateTime timestamp, TValues value);
    public sealed virtual void Increment(DateTime timestamp, IEnumerable`1<double> values);
    public sealed virtual void Increment(IEnumerable`1<double> values);
    public sealed virtual void Increment(DateTime timestamp, double value);
    public sealed virtual void Increment(double value);
    private static void ThrowDocumentAlreadyDeletedInSession(string documentId, string timeseries);
    protected static void ThrowEntityNotInSession();
}
public enum Raven.Client.Documents.Session.ShardedBatchBehavior : Enum {
    public int value__;
    public static ShardedBatchBehavior Default;
    public static ShardedBatchBehavior TransactionalSingleBucketOnly;
    public static ShardedBatchBehavior NonTransactionalMultiBucket;
}
public class Raven.Client.Documents.Session.StreamQueryStatistics : object {
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStale>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <IndexTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalResults>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ResultEtag>k__BackingField;
    public string IndexName { get; public set; }
    public bool IsStale { get; public set; }
    public DateTime IndexTimestamp { get; public set; }
    public int TotalResults { get; public set; }
    public long ResultEtag { get; public set; }
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    [CompilerGeneratedAttribute]
public bool get_IsStale();
    [CompilerGeneratedAttribute]
public void set_IsStale(bool value);
    [CompilerGeneratedAttribute]
public DateTime get_IndexTimestamp();
    [CompilerGeneratedAttribute]
public void set_IndexTimestamp(DateTime value);
    [CompilerGeneratedAttribute]
public int get_TotalResults();
    [CompilerGeneratedAttribute]
public void set_TotalResults(int value);
    [CompilerGeneratedAttribute]
public long get_ResultEtag();
    [CompilerGeneratedAttribute]
public void set_ResultEtag(long value);
}
public class Raven.Client.Documents.Session.SucceedRequestEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpResponseMessage <Response>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpRequestMessage <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AttemptNumber>k__BackingField;
    public string Database { get; }
    public string Url { get; }
    public HttpResponseMessage Response { get; }
    public HttpRequestMessage Request { get; }
    public int AttemptNumber { get; }
    internal SucceedRequestEventArgs(string database, string url, HttpResponseMessage response, HttpRequestMessage request, int attemptNumber);
    [CompilerGeneratedAttribute]
public string get_Database();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public HttpResponseMessage get_Response();
    [CompilerGeneratedAttribute]
public HttpRequestMessage get_Request();
    [CompilerGeneratedAttribute]
public int get_AttemptNumber();
}
[ExtensionAttribute]
internal static class Raven.Client.Documents.Session.TimeSeries.RollupExtensions : object {
    [ExtensionAttribute]
public static TimeSeriesRollupEntry`1<T> AsRollupEntry(TimeSeriesEntry`1<T> entry);
}
public class Raven.Client.Documents.Session.TimeSeries.TimeSeriesEntry : object {
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Values>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRollup>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Double[]> <NodeValues>k__BackingField;
    public DateTime Timestamp { get; public set; }
    public Double[] Values { get; public set; }
    public string Tag { get; public set; }
    public bool IsRollup { get; public set; }
    public Dictionary`2<string, Double[]> NodeValues { get; public set; }
    [JsonDeserializationIgnoreAttribute]
public double Value { get; public set; }
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTime value);
    [CompilerGeneratedAttribute]
public Double[] get_Values();
    [CompilerGeneratedAttribute]
public void set_Values(Double[] value);
    [CompilerGeneratedAttribute]
public string get_Tag();
    [CompilerGeneratedAttribute]
public void set_Tag(string value);
    [CompilerGeneratedAttribute]
public bool get_IsRollup();
    [CompilerGeneratedAttribute]
public void set_IsRollup(bool value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Double[]> get_NodeValues();
    [CompilerGeneratedAttribute]
public void set_NodeValues(Dictionary`2<string, Double[]> value);
    public double get_Value();
    public void set_Value(double value);
    public virtual string ToString();
}
public class Raven.Client.Documents.Session.TimeSeries.TimeSeriesEntry`1 : TimeSeriesEntry {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; public set; }
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(T value);
    public void Deconstruct(DateTime& timestamp, T& value);
    public void Deconstruct(DateTime& timestamp, T& value, String& tag);
    [OnDeserializedAttribute]
internal void OnNewtonSoftJsonDeserialized(StreamingContext context);
    private sealed virtual override void Sparrow.Json.IPostJsonDeserialization.PostDeserialization();
}
public class Raven.Client.Documents.Session.TimeSeries.TimeSeriesRollupEntry`1 : TimeSeriesEntry {
    private int _dim;
    private TValues _first;
    private TValues _last;
    private TValues _max;
    private TValues _min;
    private TValues _sum;
    private TValues _count;
    private TValues _average;
    private bool _innerArrayInitialized;
    private Double[][] _innerValues;
    [JsonIgnoreAttribute]
public TValues First { get; public set; }
    [JsonIgnoreAttribute]
public TValues Last { get; public set; }
    [JsonIgnoreAttribute]
public TValues Min { get; public set; }
    [JsonIgnoreAttribute]
public TValues Max { get; public set; }
    [JsonIgnoreAttribute]
public TValues Sum { get; public set; }
    [JsonIgnoreAttribute]
public TValues Count { get; public set; }
    [JsonIgnoreAttribute]
public TValues Average { get; }
    public TimeSeriesRollupEntry`1(DateTime timestamp);
    public TValues get_First();
    public void set_First(TValues value);
    public TValues get_Last();
    public void set_Last(TValues value);
    public TValues get_Min();
    public void set_Min(TValues value);
    public TValues get_Max();
    public void set_Max(TValues value);
    public TValues get_Sum();
    public void set_Sum(TValues value);
    public TValues get_Count();
    public void set_Count(TValues value);
    public TValues get_Average();
    private static bool IsNormal(double d);
    private void Build2DArray();
    [OnDeserializedAttribute]
internal void OnNewtonSoftJsonDeserialized(StreamingContext context);
    private sealed virtual override void Sparrow.Json.IPostJsonDeserialization.PostDeserialization();
    internal void SetValuesFromMembers();
    private void SetInternal(TValues entry, int position);
    public static TimeSeriesEntry`1<TValues> op_Explicit(TimeSeriesRollupEntry`1<TValues> rollupEntry);
}
[AttributeUsageAttribute("384")]
public class Raven.Client.Documents.Session.TimeSeries.TimeSeriesValueAttribute : Attribute {
    public byte Index;
    public TimeSeriesValueAttribute(byte index);
}
internal static class Raven.Client.Documents.Session.TimeSeries.TimeSeriesValuesHelper : object {
    private static ConcurrentDictionary`2<Type, SortedDictionary`2<byte, MemberInfo>> _cache;
    private static TimeSeriesValuesHelper();
    internal static SortedDictionary`2<byte, MemberInfo> GetMembersMapping(Type type);
    internal static IEnumerable`1<double> GetValues(T obj, bool asRollup);
    internal static T SetMembers(Double[] values, bool asRollup);
}
internal class Raven.Client.Documents.Session.Tokens.CloseSubclauseToken : QueryToken {
    [CompilerGeneratedAttribute]
private string <BoostParameterName>k__BackingField;
    public string BoostParameterName { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_BoostParameterName();
    [CompilerGeneratedAttribute]
internal void set_BoostParameterName(string value);
    internal static CloseSubclauseToken Create();
    public virtual void WriteTo(StringBuilder writer);
}
internal class Raven.Client.Documents.Session.Tokens.CompareExchangeValueIncludesToken : QueryToken {
    private string _path;
    private CompareExchangeValueIncludesToken(string path);
    internal static CompareExchangeValueIncludesToken Create(string path);
    public virtual void WriteTo(StringBuilder writer);
}
public class Raven.Client.Documents.Session.Tokens.CounterIncludesToken : QueryToken {
    private string _sourcePath;
    private string _counterName;
    private bool _all;
    private CounterIncludesToken(string sourcePath, string counterName, bool all);
    public static CounterIncludesToken Create(string sourcePath, string counterName);
    public static CounterIncludesToken All(string sourcePath);
    public void AddAliasToPath(string alias);
    public virtual void WriteTo(StringBuilder writer);
}
public class Raven.Client.Documents.Session.Tokens.DeclareToken : QueryToken {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Body>k__BackingField;
    private bool _timeSeries;
    public string Name { get; }
    public string Parameters { get; }
    public string Body { get; }
    private DeclareToken(string name, string body, string parameters, bool timeSeries);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Parameters();
    [CompilerGeneratedAttribute]
public string get_Body();
    public static DeclareToken CreateFunction(string name, string body, string parameters);
    public static DeclareToken CreateTimeSeries(string name, string body, string parameters);
    public virtual void WriteTo(StringBuilder writer);
}
internal class Raven.Client.Documents.Session.Tokens.DistinctToken : QueryToken {
    public static DistinctToken Instance;
    private static DistinctToken();
    public virtual void WriteTo(StringBuilder writer);
}
public class Raven.Client.Documents.Session.Tokens.ExplanationToken : QueryToken {
    private string _optionsParameterName;
    private ExplanationToken(string optionsParameterName);
    public static ExplanationToken Create(string optionsParameterName);
    public virtual void WriteTo(StringBuilder writer);
}
internal class Raven.Client.Documents.Session.Tokens.FacetToken : QueryToken {
    private string _facetSetupDocumentId;
    private string _aggregateByFieldName;
    private string _alias;
    private List`1<string> _ranges;
    private string _optionsParameterName;
    private List`1<FacetAggregationToken> _aggregations;
    public string Name { get; }
    private FacetToken(string facetSetupDocumentId);
    private FacetToken(string aggregateByFieldName, string alias, List`1<string> ranges, string optionsParameterName);
    public string get_Name();
    public static FacetToken Create(string facetSetupDocumentId);
    public static FacetToken Create(Facet facet, Func`2<object, string> addQueryParameter);
    public static FacetToken Create(RangeFacet facet, Func`2<object, string> addQueryParameter);
    public static FacetToken Create(RangeFacet`1<T> facet, Func`2<object, string> addQueryParameter, DocumentConventions conventions);
    public static FacetToken Create(FacetBase facet, Func`2<object, string> addQueryParameter, DocumentConventions conventions);
    public virtual void WriteTo(StringBuilder writer);
    private static void ApplyAggregations(FacetBase facet, FacetToken token);
    private static string GetOptionsParameterName(FacetBase facet, Func`2<object, string> addQueryParameter);
}
public class Raven.Client.Documents.Session.Tokens.FieldsToFetchToken : QueryToken {
    public String[] FieldsToFetch;
    public String[] Projections;
    public bool IsCustomFunction;
    public string SourceAlias;
    private FieldsToFetchToken(String[] fieldsToFetch, String[] projections, bool isCustomFunction, string sourceAlias);
    public static FieldsToFetchToken Create(String[] fieldsToFetch, String[] projections, bool isCustomFunction, string sourceAlias);
    public virtual void WriteTo(StringBuilder writer);
}
public class Raven.Client.Documents.Session.Tokens.FromToken : QueryToken {
    [CompilerGeneratedAttribute]
private string <CollectionName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDynamic>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    public string CollectionName { get; }
    public string IndexName { get; }
    public bool IsDynamic { get; }
    public string Alias { get; }
    private FromToken(string indexName, string collectionName, string alias);
    [CompilerGeneratedAttribute]
public string get_CollectionName();
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public bool get_IsDynamic();
    [CompilerGeneratedAttribute]
public string get_Alias();
    public static FromToken Create(string indexName, string collectionName, string alias);
    public virtual void WriteTo(StringBuilder writer);
}
internal class Raven.Client.Documents.Session.Tokens.GroupByCountToken : QueryToken {
    private string _fieldName;
    private GroupByCountToken(string fieldName);
    public static GroupByCountToken Create(string fieldName);
    public virtual void WriteTo(StringBuilder writer);
}
internal class Raven.Client.Documents.Session.Tokens.GroupByKeyToken : QueryToken {
    private string _fieldName;
    private string _projectedName;
    private GroupByKeyToken(string fieldName, string projectedName);
    public static GroupByKeyToken Create(string fieldName, string projectedName);
    public virtual void WriteTo(StringBuilder writer);
}
internal class Raven.Client.Documents.Session.Tokens.GroupBySumToken : QueryToken {
    private string _projectedName;
    private string _fieldName;
    private GroupBySumToken(string fieldName, string projectedName);
    public static GroupBySumToken Create(string fieldName, string projectedName);
    public virtual void WriteTo(StringBuilder writer);
}
internal class Raven.Client.Documents.Session.Tokens.GroupByToken : QueryToken {
    private string _fieldName;
    private GroupByMethod _method;
    private GroupByToken(string fieldName, GroupByMethod method);
    public static GroupByToken Create(string fieldName, GroupByMethod method);
    public virtual void WriteTo(StringBuilder writer);
}
public class Raven.Client.Documents.Session.Tokens.HighlightingToken : QueryToken {
    private string _fieldName;
    private int _fragmentLength;
    private int _fragmentCount;
    private string _optionsParameterName;
    private HighlightingToken(string fieldName, int fragmentLength, int fragmentCount, string optionsParameterName);
    public static HighlightingToken Create(string fieldName, int fragmentLength, int fragmentCount, string optionsParameterName);
    public virtual void WriteTo(StringBuilder writer);
}
internal class Raven.Client.Documents.Session.Tokens.IntersectMarkerToken : QueryToken {
    public static IntersectMarkerToken Instance;
    private static IntersectMarkerToken();
    public virtual void WriteTo(StringBuilder writer);
}
public class Raven.Client.Documents.Session.Tokens.LoadToken : QueryToken {
    [CompilerGeneratedAttribute]
private string <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    public string Argument { get; }
    public string Alias { get; public set; }
    private LoadToken(string argument, string alias);
    [CompilerGeneratedAttribute]
public string get_Argument();
    [CompilerGeneratedAttribute]
public string get_Alias();
    [CompilerGeneratedAttribute]
public void set_Alias(string value);
    public static LoadToken Create(string argument, string alias);
    public virtual void WriteTo(StringBuilder writer);
}
public class Raven.Client.Documents.Session.Tokens.MoreLikeThisToken : WhereToken {
    public string DocumentParameterName;
    public string OptionsParameterName;
    public LinkedList`1<QueryToken> WhereTokens;
    public virtual void WriteTo(StringBuilder writer);
}
internal class Raven.Client.Documents.Session.Tokens.NegateToken : QueryToken {
    public static NegateToken Instance;
    private static NegateToken();
    public virtual void WriteTo(StringBuilder writer);
}
internal class Raven.Client.Documents.Session.Tokens.OpenSubclauseToken : QueryToken {
    [CompilerGeneratedAttribute]
private string <BoostParameterName>k__BackingField;
    public string BoostParameterName { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_BoostParameterName();
    [CompilerGeneratedAttribute]
internal void set_BoostParameterName(string value);
    internal static OpenSubclauseToken Create();
    public virtual void WriteTo(StringBuilder writer);
}
internal class Raven.Client.Documents.Session.Tokens.OrderByToken : QueryToken {
    private string _fieldName;
    private bool _descending;
    private string _sorterName;
    private OrderingType _ordering;
    private bool _isMethodField;
    public static OrderByToken Random;
    public static OrderByToken ScoreAscending;
    public static OrderByToken ScoreDescending;
    private OrderByToken(string fieldName, bool descending, string sorterName, bool isMethodField);
    private OrderByToken(string fieldName, bool descending, OrderingType ordering, bool isMethodField);
    private static OrderByToken();
    public static OrderByToken CreateDistanceAscending(string fieldName, string latitudeParameterName, string longitudeParameterName, string roundFactorParameterName);
    public static OrderByToken CreateDistanceAscending(string fieldName, string shapeWktParameterName, string roundFactorParameterName);
    public static OrderByToken CreateDistanceDescending(string fieldName, string latitudeParameterName, string longitudeParameterName, string roundFactorParameterName);
    public static OrderByToken CreateDistanceDescending(string fieldName, string shapeWktParameterName, string roundFactorParameterName);
    public static OrderByToken CreateRandom(string seed);
    public static OrderByToken CreateAscending(string fieldName, string sorterName);
    public static OrderByToken CreateAscending(string fieldName, OrderingType ordering);
    public static OrderByToken CreateDescending(string fieldName, string sorterName);
    public static OrderByToken CreateDescending(string fieldName, OrderingType ordering);
    public virtual void WriteTo(StringBuilder writer);
    public OrderByToken AddAlias(string alias);
}
internal class Raven.Client.Documents.Session.Tokens.QueryOperatorToken : QueryToken {
    private QueryOperator _queryOperator;
    public static QueryOperatorToken And;
    public static QueryOperatorToken Or;
    private QueryOperatorToken(QueryOperator queryOperator);
    private static QueryOperatorToken();
    public virtual void WriteTo(StringBuilder writer);
}
public abstract class Raven.Client.Documents.Session.Tokens.QueryToken : object {
    internal static HashSet`1<string> RqlKeywords;
    private static QueryToken();
    public abstract virtual void WriteTo(StringBuilder writer);
    internal static void WriteField(StringBuilder writer, string field);
    internal static bool IsKeyword(string field);
}
internal class Raven.Client.Documents.Session.Tokens.RevisionIncludesToken : QueryToken {
    private string _dateTime;
    private string _path;
    private RevisionIncludesToken(DateTime dateTime);
    private RevisionIncludesToken(string path);
    internal static RevisionIncludesToken Create(DateTime dateTime);
    internal static RevisionIncludesToken Create(string path);
    public virtual void WriteTo(StringBuilder writer);
}
public class Raven.Client.Documents.Session.Tokens.ShapeToken : QueryToken {
    private string _shape;
    private ShapeToken(string shape);
    public static ShapeToken Circle(string radiusParameterName, string latitudeParameterName, string longitudeParameterName, Nullable`1<SpatialUnits> radiusUnits);
    public static ShapeToken Wkt(string shapeWktParameterName, Nullable`1<SpatialUnits> units);
    public virtual void WriteTo(StringBuilder writer);
}
internal class Raven.Client.Documents.Session.Tokens.SuggestToken : QueryToken {
    public string FieldName;
    private string _alias;
    private string _termParameterName;
    private string _optionsParameterName;
    private SuggestToken(string fieldName, string alias, string termParameterName, string optionsParameterName);
    public static SuggestToken Create(string fieldName, string alias, string termParameterName, string optionsParameterName);
    public virtual void WriteTo(StringBuilder writer);
}
internal class Raven.Client.Documents.Session.Tokens.TimeSeriesIncludesToken : QueryToken {
    private string _sourcePath;
    private AbstractTimeSeriesRange _range;
    private TimeSeriesIncludesToken(string sourcePath, AbstractTimeSeriesRange range);
    public static TimeSeriesIncludesToken Create(string sourcePath, AbstractTimeSeriesRange range);
    public void AddAliasToPath(string alias);
    public virtual void WriteTo(StringBuilder writer);
    private static void WriteTo(StringBuilder writer, TimeSeriesTimeRange range);
    private static void WriteTo(StringBuilder writer, TimeSeriesCountRange range);
    private static void WriteTo(StringBuilder writer, TimeSeriesRange range);
}
internal class Raven.Client.Documents.Session.Tokens.TimingsToken : QueryToken {
    public static TimingsToken Instance;
    private static TimingsToken();
    public virtual void WriteTo(StringBuilder writer);
}
internal class Raven.Client.Documents.Session.Tokens.TrueToken : QueryToken {
    public static TrueToken Instance;
    private static TrueToken();
    public virtual void WriteTo(StringBuilder writer);
}
public enum Raven.Client.Documents.Session.Tokens.WhereOperator : Enum {
    public int value__;
    public static WhereOperator Equals;
    public static WhereOperator NotEquals;
    public static WhereOperator GreaterThan;
    public static WhereOperator GreaterThanOrEqual;
    public static WhereOperator LessThan;
    public static WhereOperator LessThanOrEqual;
    public static WhereOperator In;
    public static WhereOperator AllIn;
    public static WhereOperator Between;
    public static WhereOperator Search;
    public static WhereOperator Lucene;
    public static WhereOperator StartsWith;
    public static WhereOperator EndsWith;
    public static WhereOperator Exists;
    public static WhereOperator Spatial_Within;
    public static WhereOperator Spatial_Contains;
    public static WhereOperator Spatial_Disjoint;
    public static WhereOperator Spatial_Intersects;
    public static WhereOperator Regex;
}
public class Raven.Client.Documents.Session.Tokens.WhereToken : QueryToken {
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private WhereOperator <WhereOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public WhereOptions Options;
    public string FieldName { get; private set; }
    public WhereOperator WhereOperator { get; private set; }
    public string ParameterName { get; private set; }
    [CompilerGeneratedAttribute]
public string get_FieldName();
    [CompilerGeneratedAttribute]
private void set_FieldName(string value);
    [CompilerGeneratedAttribute]
public WhereOperator get_WhereOperator();
    [CompilerGeneratedAttribute]
private void set_WhereOperator(WhereOperator value);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
    [CompilerGeneratedAttribute]
private void set_ParameterName(string value);
    public static WhereToken Create(WhereOperator op, string fieldName, string parameterName, WhereOptions options);
    public WhereToken AddAlias(string alias);
    private bool WriteMethod(StringBuilder writer);
    public virtual void WriteTo(StringBuilder writer);
    private void WriteInnerWhere(StringBuilder writer);
    private void SpecialOperator(StringBuilder writer);
}
public class Raven.Client.Documents.Session.TopologyUpdatedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Topology <Topology>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public Topology Topology { get; }
    public string Reason { get; }
    internal TopologyUpdatedEventArgs(Topology topology, string reason);
    [CompilerGeneratedAttribute]
public Topology get_Topology();
    [CompilerGeneratedAttribute]
public string get_Reason();
}
public enum Raven.Client.Documents.Session.TransactionMode : Enum {
    public int value__;
    public static TransactionMode SingleNode;
    public static TransactionMode ClusterWide;
}
public class Raven.Client.Documents.Session.WhereParams : object {
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowWildcards>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNestedPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Exact>k__BackingField;
    public string FieldName { get; public set; }
    public object Value { get; public set; }
    public bool AllowWildcards { get; public set; }
    public bool IsNestedPath { get; public set; }
    public bool Exact { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FieldName();
    [CompilerGeneratedAttribute]
public void set_FieldName(string value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
    [CompilerGeneratedAttribute]
public bool get_AllowWildcards();
    [CompilerGeneratedAttribute]
public void set_AllowWildcards(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsNestedPath();
    [CompilerGeneratedAttribute]
public void set_IsNestedPath(bool value);
    [CompilerGeneratedAttribute]
public bool get_Exact();
    [CompilerGeneratedAttribute]
public void set_Exact(bool value);
}
[ExtensionAttribute]
internal static class Raven.Client.Documents.Smuggler.BackupUtils : object {
    private static string LegacyIncrementalBackupExtension;
    private static string LegacyFullBackupExtension;
    internal static bool IsBackupFile(string filePath);
    internal static bool IsFullBackupOrSnapshot(string filePath);
    internal static bool IsFullBackup(string extension);
    internal static bool IsSnapshot(string extension);
    internal static bool IsIncrementalBackupFile(string extension);
    [ExtensionAttribute]
internal static IOrderedEnumerable`1<string> OrderBackups(IEnumerable`1<string> data);
}
[FlagsAttribute]
public enum Raven.Client.Documents.Smuggler.DatabaseItemType : Enum {
    public int value__;
    public static DatabaseItemType None;
    public static DatabaseItemType Documents;
    public static DatabaseItemType RevisionDocuments;
    public static DatabaseItemType Indexes;
    public static DatabaseItemType Identities;
    public static DatabaseItemType Tombstones;
    public static DatabaseItemType LegacyAttachments;
    public static DatabaseItemType Conflicts;
    public static DatabaseItemType CompareExchange;
    public static DatabaseItemType LegacyDocumentDeletions;
    public static DatabaseItemType LegacyAttachmentDeletions;
    public static DatabaseItemType DatabaseRecord;
    public static DatabaseItemType Unknown;
    public static DatabaseItemType Attachments;
    public static DatabaseItemType CounterGroups;
    public static DatabaseItemType Subscriptions;
    public static DatabaseItemType CompareExchangeTombstones;
    public static DatabaseItemType TimeSeries;
    public static DatabaseItemType ReplicationHubCertificates;
    public static DatabaseItemType TimeSeriesDeletedRanges;
}
[FlagsAttribute]
public enum Raven.Client.Documents.Smuggler.DatabaseRecordItemType : Enum {
    public int value__;
    public static DatabaseRecordItemType None;
    public static DatabaseRecordItemType ConflictSolverConfig;
    public static DatabaseRecordItemType Settings;
    public static DatabaseRecordItemType Revisions;
    public static DatabaseRecordItemType Expiration;
    public static DatabaseRecordItemType PeriodicBackups;
    public static DatabaseRecordItemType ExternalReplications;
    public static DatabaseRecordItemType RavenConnectionStrings;
    public static DatabaseRecordItemType SqlConnectionStrings;
    public static DatabaseRecordItemType RavenEtls;
    public static DatabaseRecordItemType SqlEtls;
    public static DatabaseRecordItemType Client;
    public static DatabaseRecordItemType Sorters;
    public static DatabaseRecordItemType SinkPullReplications;
    public static DatabaseRecordItemType HubPullReplications;
    public static DatabaseRecordItemType TimeSeries;
    public static DatabaseRecordItemType DocumentsCompression;
    public static DatabaseRecordItemType Analyzers;
    public static DatabaseRecordItemType LockMode;
    public static DatabaseRecordItemType OlapConnectionStrings;
    public static DatabaseRecordItemType OlapEtls;
    public static DatabaseRecordItemType ElasticSearchConnectionStrings;
    public static DatabaseRecordItemType ElasticSearchEtls;
    public static DatabaseRecordItemType PostgreSQLIntegration;
    public static DatabaseRecordItemType QueueConnectionStrings;
    public static DatabaseRecordItemType QueueEtls;
    public static DatabaseRecordItemType IndexesHistory;
    public static DatabaseRecordItemType Refresh;
    public static DatabaseRecordItemType QueueSinks;
    public static DatabaseRecordItemType DataArchival;
}
public class Raven.Client.Documents.Smuggler.DatabaseSmuggler : object {
    private static Logger Logger;
    private Func`3<string, string, ISingleNodeDatabaseChanges> _getChanges;
    private Func`2<string, RequestExecutor> _getRequestExecutor;
    private string _databaseName;
    private RequestExecutor _requestExecutor;
    internal TestingStuff ForTestingPurposes;
    private RequestExecutor RequestExecutor { get; }
    public DatabaseSmuggler(IDocumentStore store, string databaseName);
    public DatabaseSmuggler(DocumentStore store, string databaseName);
    internal DatabaseSmuggler(Func`3<string, string, ISingleNodeDatabaseChanges> getChanges, Func`2<string, RequestExecutor> getRequestExecutor, string databaseName);
    private static DatabaseSmuggler();
    private RequestExecutor get_RequestExecutor();
    public DatabaseSmuggler ForDatabase(string databaseName);
    internal Task`1<Operation> ExportToStreamAsync(DatabaseSmugglerExportOptions options, Func`2<Stream, Task> handleStreamResponse, CancellationToken token);
    public Task`1<Operation> ExportAsync(DatabaseSmugglerExportOptions options, string toFile, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Smuggler.DatabaseSmuggler/<ExportAsync>d__13")]
private Task`1<Operation> ExportAsync(DatabaseSmugglerExportOptions options, Func`2<Stream, Task> handleStreamResponse, Task additionalTask, CancellationToken token);
    private Task`1<Operation> ExportAsync(DatabaseSmugglerExportOptions options, Func`2<Stream, Task> handleStreamResponse, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Smuggler.DatabaseSmuggler/<ExportAsync>d__15")]
public Task`1<Operation> ExportAsync(DatabaseSmugglerExportOptions options, DatabaseSmuggler toDatabase, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Smuggler.DatabaseSmuggler/<ImportIncrementalAsync>d__16")]
public Task ImportIncrementalAsync(DatabaseSmugglerImportOptions options, string fromDirectory, CancellationToken cancellationToken);
    internal static DatabaseItemType ConfigureOptionsForIncrementalImport(DatabaseSmugglerOptions options);
    public Task`1<Operation> ImportAsync(DatabaseSmugglerImportOptions options, string fromFile, CancellationToken cancellationToken);
    public Task`1<Operation> ImportAsync(DatabaseSmugglerImportOptions options, Stream stream, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Smuggler.DatabaseSmuggler/<ImportInternalAsync>d__20")]
private Task`1<Operation> ImportInternalAsync(DatabaseSmugglerImportOptions options, Stream stream, bool leaveOpen, CancellationToken token);
    internal TestingStuff ForTestingPurposesOnly();
}
public class Raven.Client.Documents.Smuggler.DatabaseSmugglerExportOptions : DatabaseSmugglerOptions {
    [CompilerGeneratedAttribute]
private Nullable`1<ExportCompressionAlgorithm> <CompressionAlgorithm>k__BackingField;
    public Nullable`1<ExportCompressionAlgorithm> CompressionAlgorithm { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<ExportCompressionAlgorithm> get_CompressionAlgorithm();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CompressionAlgorithm(Nullable`1<ExportCompressionAlgorithm> value);
}
public class Raven.Client.Documents.Smuggler.DatabaseSmugglerImportOptions : DatabaseSmugglerOptions {
    [CompilerGeneratedAttribute]
private bool <SkipRevisionCreation>k__BackingField;
    public bool SkipRevisionCreation { get; public set; }
    public DatabaseSmugglerImportOptions(DatabaseSmugglerOptions options);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipRevisionCreation();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SkipRevisionCreation(bool value);
}
public class Raven.Client.Documents.Smuggler.DatabaseSmugglerOptions : object {
    public static DatabaseItemType DefaultOperateOnTypes;
    public static DatabaseRecordItemType DefaultOperateOnDatabaseRecordTypes;
    internal static DatabaseItemType OperateOnFirstShardOnly;
    internal static DatabaseRecordItemType ShardingNotSupportedDatabaseSmugglerOptions;
    private static int DefaultMaxStepsForTransformScript;
    [CompilerGeneratedAttribute]
private DatabaseItemType <OperateOnTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private DatabaseRecordItemType <OperateOnDatabaseRecordTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeExpired>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeArtificial>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeArchived>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoveAnalyzers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TransformScript>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxStepsForTransformScript>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionKey>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Collections>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipCorruptedData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsShard>k__BackingField;
    public DatabaseItemType OperateOnTypes { get; public set; }
    public DatabaseRecordItemType OperateOnDatabaseRecordTypes { get; public set; }
    public bool IncludeExpired { get; public set; }
    public bool IncludeArtificial { get; public set; }
    public bool IncludeArchived { get; public set; }
    public bool RemoveAnalyzers { get; public set; }
    public string TransformScript { get; public set; }
    public int MaxStepsForTransformScript { get; public set; }
    public string EncryptionKey { get; public set; }
    public List`1<string> Collections { get; public set; }
    public bool SkipCorruptedData { get; public set; }
    [ForceJsonSerializationAttribute]
internal bool IsShard { get; internal set; }
    [CompilerGeneratedAttribute]
public sealed virtual DatabaseItemType get_OperateOnTypes();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OperateOnTypes(DatabaseItemType value);
    [CompilerGeneratedAttribute]
public sealed virtual DatabaseRecordItemType get_OperateOnDatabaseRecordTypes();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OperateOnDatabaseRecordTypes(DatabaseRecordItemType value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IncludeExpired();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IncludeExpired(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IncludeArtificial();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IncludeArtificial(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IncludeArchived();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IncludeArchived(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RemoveAnalyzers();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RemoveAnalyzers(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TransformScript();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TransformScript(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxStepsForTransformScript();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MaxStepsForTransformScript(int value);
    [CompilerGeneratedAttribute]
public string get_EncryptionKey();
    [CompilerGeneratedAttribute]
public void set_EncryptionKey(string value);
    [CompilerGeneratedAttribute]
public sealed virtual List`1<string> get_Collections();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Collections(List`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_SkipCorruptedData();
    [CompilerGeneratedAttribute]
public void set_SkipCorruptedData(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsShard();
    [CompilerGeneratedAttribute]
internal void set_IsShard(bool value);
}
public enum Raven.Client.Documents.Smuggler.ExportCompressionAlgorithm : Enum {
    public int value__;
    public static ExportCompressionAlgorithm Zstd;
    public static ExportCompressionAlgorithm Gzip;
}
internal interface Raven.Client.Documents.Smuggler.IDatabaseSmugglerExportOptions {
    public Nullable`1<ExportCompressionAlgorithm> CompressionAlgorithm { get; public set; }
    public abstract virtual Nullable`1<ExportCompressionAlgorithm> get_CompressionAlgorithm();
    public abstract virtual void set_CompressionAlgorithm(Nullable`1<ExportCompressionAlgorithm> value);
}
internal interface Raven.Client.Documents.Smuggler.IDatabaseSmugglerImportOptions {
    public bool SkipRevisionCreation { get; public set; }
    public abstract virtual bool get_SkipRevisionCreation();
    public abstract virtual void set_SkipRevisionCreation(bool value);
}
internal interface Raven.Client.Documents.Smuggler.IDatabaseSmugglerOptions {
    public DatabaseItemType OperateOnTypes { get; public set; }
    public DatabaseRecordItemType OperateOnDatabaseRecordTypes { get; public set; }
    public bool IncludeExpired { get; public set; }
    public bool IncludeArtificial { get; public set; }
    public bool IncludeArchived { get; public set; }
    public bool RemoveAnalyzers { get; public set; }
    public string TransformScript { get; public set; }
    public int MaxStepsForTransformScript { get; public set; }
    public List`1<string> Collections { get; public set; }
    public abstract virtual DatabaseItemType get_OperateOnTypes();
    public abstract virtual void set_OperateOnTypes(DatabaseItemType value);
    public abstract virtual DatabaseRecordItemType get_OperateOnDatabaseRecordTypes();
    public abstract virtual void set_OperateOnDatabaseRecordTypes(DatabaseRecordItemType value);
    public abstract virtual bool get_IncludeExpired();
    public abstract virtual void set_IncludeExpired(bool value);
    public abstract virtual bool get_IncludeArtificial();
    public abstract virtual void set_IncludeArtificial(bool value);
    public abstract virtual bool get_IncludeArchived();
    public abstract virtual void set_IncludeArchived(bool value);
    public abstract virtual bool get_RemoveAnalyzers();
    public abstract virtual void set_RemoveAnalyzers(bool value);
    public abstract virtual string get_TransformScript();
    public abstract virtual void set_TransformScript(string value);
    public abstract virtual int get_MaxStepsForTransformScript();
    public abstract virtual void set_MaxStepsForTransformScript(int value);
    public abstract virtual List`1<string> get_Collections();
    public abstract virtual void set_Collections(List`1<string> value);
}
public class Raven.Client.Documents.Smuggler.OfflineMigrationProgress : SmugglerProgress {
    public Counts DataExporter { get; }
    public OfflineMigrationProgress(OfflineMigrationResult result);
    public Counts get_DataExporter();
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Smuggler.OfflineMigrationResult : SmugglerResult {
    [CompilerGeneratedAttribute]
private Counts <DataExporter>k__BackingField;
    public Counts DataExporter { get; public set; }
    [CompilerGeneratedAttribute]
public Counts get_DataExporter();
    [CompilerGeneratedAttribute]
public void set_DataExporter(Counts value);
    public virtual DynamicJsonValue ToJson();
}
internal class Raven.Client.Documents.Smuggler.PeriodicBackupFileExtensionComparer : object {
    public static PeriodicBackupFileExtensionComparer Instance;
    private static PeriodicBackupFileExtensionComparer();
    public sealed virtual int Compare(string x, string y);
}
public class Raven.Client.Documents.Smuggler.ShardedSmugglerProgress : SmugglerProgress {
    [CompilerGeneratedAttribute]
private int <ShardNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    public int ShardNumber { get; public set; }
    public string NodeTag { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_ShardNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ShardNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_NodeTag();
    [CompilerGeneratedAttribute]
public sealed virtual void set_NodeTag(string value);
    public sealed virtual void Fill(IOperationProgress progress, int shardNumber, string nodeTag);
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Smuggler.ShardedSmugglerResult : object {
    [CompilerGeneratedAttribute]
private List`1<ShardNodeSmugglerResult> <Results>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public List`1<ShardNodeSmugglerResult> Results { get; public set; }
    public string Message { get; private set; }
    public bool ShouldPersist { get; }
    public bool CanMerge { get; }
    [CompilerGeneratedAttribute]
public sealed virtual List`1<ShardNodeSmugglerResult> get_Results();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Results(List`1<ShardNodeSmugglerResult> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(string value);
    public sealed virtual DynamicJsonValue ToJson();
    public sealed virtual bool get_ShouldPersist();
    public sealed virtual bool get_CanMerge();
    public sealed virtual void MergeWith(IOperationResult result);
    public sealed virtual void CombineWith(IOperationResult result, int shardNumber, string nodeTag);
}
public class Raven.Client.Documents.Smuggler.ShardNodeSmugglerResult : ShardNodeOperationResult`1<SmugglerResult> {
    public bool ShouldPersist { get; }
    public virtual bool get_ShouldPersist();
}
public abstract class Raven.Client.Documents.Smuggler.SmugglerProgressBase : object {
    [CompilerGeneratedAttribute]
private DatabaseRecordProgress <DatabaseRecord>k__BackingField;
    [CompilerGeneratedAttribute]
private CountsWithSkippedCountAndLastEtagAndAttachments <Documents>k__BackingField;
    [CompilerGeneratedAttribute]
private CountsWithSkippedCountAndLastEtagAndAttachments <RevisionDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private CountsWithLastEtag <Tombstones>k__BackingField;
    [CompilerGeneratedAttribute]
private CountsWithLastEtag <Conflicts>k__BackingField;
    [CompilerGeneratedAttribute]
private CountsWithLastEtag <Identities>k__BackingField;
    [CompilerGeneratedAttribute]
private Counts <Indexes>k__BackingField;
    [CompilerGeneratedAttribute]
private CountsWithLastEtag <CompareExchange>k__BackingField;
    [CompilerGeneratedAttribute]
private Counts <Subscriptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Counts <ReplicationHubCertificates>k__BackingField;
    [CompilerGeneratedAttribute]
private CountsWithSkippedCountAndLastEtag <Counters>k__BackingField;
    [CompilerGeneratedAttribute]
private CountsWithSkippedCountAndLastEtag <TimeSeries>k__BackingField;
    [CompilerGeneratedAttribute]
private Counts <CompareExchangeTombstones>k__BackingField;
    [CompilerGeneratedAttribute]
private CountsWithSkippedCountAndLastEtag <TimeSeriesDeletedRanges>k__BackingField;
    public DatabaseRecordProgress DatabaseRecord { get; public set; }
    public CountsWithSkippedCountAndLastEtagAndAttachments Documents { get; public set; }
    public CountsWithSkippedCountAndLastEtagAndAttachments RevisionDocuments { get; public set; }
    public CountsWithLastEtag Tombstones { get; public set; }
    public CountsWithLastEtag Conflicts { get; public set; }
    public CountsWithLastEtag Identities { get; public set; }
    public Counts Indexes { get; public set; }
    public CountsWithLastEtag CompareExchange { get; public set; }
    public Counts Subscriptions { get; public set; }
    public Counts ReplicationHubCertificates { get; public set; }
    public CountsWithSkippedCountAndLastEtag Counters { get; public set; }
    public CountsWithSkippedCountAndLastEtag TimeSeries { get; public set; }
    public Counts CompareExchangeTombstones { get; public set; }
    public CountsWithSkippedCountAndLastEtag TimeSeriesDeletedRanges { get; public set; }
    public bool CanMerge { get; }
    [CompilerGeneratedAttribute]
public DatabaseRecordProgress get_DatabaseRecord();
    [CompilerGeneratedAttribute]
public void set_DatabaseRecord(DatabaseRecordProgress value);
    [CompilerGeneratedAttribute]
public CountsWithSkippedCountAndLastEtagAndAttachments get_Documents();
    [CompilerGeneratedAttribute]
public void set_Documents(CountsWithSkippedCountAndLastEtagAndAttachments value);
    [CompilerGeneratedAttribute]
public CountsWithSkippedCountAndLastEtagAndAttachments get_RevisionDocuments();
    [CompilerGeneratedAttribute]
public void set_RevisionDocuments(CountsWithSkippedCountAndLastEtagAndAttachments value);
    [CompilerGeneratedAttribute]
public CountsWithLastEtag get_Tombstones();
    [CompilerGeneratedAttribute]
public void set_Tombstones(CountsWithLastEtag value);
    [CompilerGeneratedAttribute]
public CountsWithLastEtag get_Conflicts();
    [CompilerGeneratedAttribute]
public void set_Conflicts(CountsWithLastEtag value);
    [CompilerGeneratedAttribute]
public CountsWithLastEtag get_Identities();
    [CompilerGeneratedAttribute]
public void set_Identities(CountsWithLastEtag value);
    [CompilerGeneratedAttribute]
public Counts get_Indexes();
    [CompilerGeneratedAttribute]
public void set_Indexes(Counts value);
    [CompilerGeneratedAttribute]
public CountsWithLastEtag get_CompareExchange();
    [CompilerGeneratedAttribute]
public void set_CompareExchange(CountsWithLastEtag value);
    [CompilerGeneratedAttribute]
public Counts get_Subscriptions();
    [CompilerGeneratedAttribute]
public void set_Subscriptions(Counts value);
    [CompilerGeneratedAttribute]
public Counts get_ReplicationHubCertificates();
    [CompilerGeneratedAttribute]
public void set_ReplicationHubCertificates(Counts value);
    [CompilerGeneratedAttribute]
public CountsWithSkippedCountAndLastEtag get_Counters();
    [CompilerGeneratedAttribute]
public void set_Counters(CountsWithSkippedCountAndLastEtag value);
    [CompilerGeneratedAttribute]
public CountsWithSkippedCountAndLastEtag get_TimeSeries();
    [CompilerGeneratedAttribute]
public void set_TimeSeries(CountsWithSkippedCountAndLastEtag value);
    [CompilerGeneratedAttribute]
public Counts get_CompareExchangeTombstones();
    [CompilerGeneratedAttribute]
public void set_CompareExchangeTombstones(Counts value);
    [CompilerGeneratedAttribute]
public CountsWithSkippedCountAndLastEtag get_TimeSeriesDeletedRanges();
    [CompilerGeneratedAttribute]
public void set_TimeSeriesDeletedRanges(CountsWithSkippedCountAndLastEtag value);
    public virtual DynamicJsonValue ToJson();
    public sealed virtual IOperationProgress Clone();
    public sealed virtual bool get_CanMerge();
    public sealed virtual void MergeWith(IOperationProgress progress);
}
public class Raven.Client.Documents.Smuggler.SmugglerResult : SmugglerProgressBase {
    private object _locker;
    private List`1<string> _messages;
    protected SmugglerProgress _progress;
    private Stopwatch _sw;
    private DatabaseItemType _itemTypeInProgress;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LegacyLastDocumentEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LegacyLastAttachmentEtag>k__BackingField;
    public string Message { get; private set; }
    public TimeSpan Elapsed { get; }
    public IOperationProgress Progress { get; }
    private bool Raven.Client.Documents.Operations.IOperationResult.CanMerge { get; }
    public IReadOnlyList`1<string> Messages { get; public set; }
    public bool ShouldPersist { get; }
    public string LegacyLastDocumentEtag { get; public set; }
    public string LegacyLastAttachmentEtag { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(string value);
    public TimeSpan get_Elapsed();
    public IOperationProgress get_Progress();
    private sealed virtual override bool Raven.Client.Documents.Operations.IOperationResult.get_CanMerge();
    private sealed virtual override void Raven.Client.Documents.Operations.IOperationResult.MergeWith(IOperationResult result);
    public IReadOnlyList`1<string> get_Messages();
    public void set_Messages(IReadOnlyList`1<string> value);
    public void AddWarning(string message);
    public void AddInfo(string message);
    public void AddError(string message);
    public void StartProcessingForType(DatabaseItemType type);
    public void StopProcessingActualType(Counts counts);
    public void OnCorruptedData(object sender, InvalidOperationException e);
    internal void AddMessage(string message);
    private void AddMessage(string type, string message);
    public virtual DynamicJsonValue ToJson();
    public sealed virtual bool get_ShouldPersist();
    [CompilerGeneratedAttribute]
public string get_LegacyLastDocumentEtag();
    [CompilerGeneratedAttribute]
public void set_LegacyLastDocumentEtag(string value);
    [CompilerGeneratedAttribute]
public string get_LegacyLastAttachmentEtag();
    [CompilerGeneratedAttribute]
public void set_LegacyLastAttachmentEtag(string value);
    public long GetLastEtag();
    public long GetLastRaftIndex();
}
public abstract class Raven.Client.Documents.Subscriptions.AbstractSubscriptionWorker`2 : object {
    protected Logger _logger;
    internal string _dbName;
    protected CancellationTokenSource _processingCts;
    protected SubscriptionWorkerOptions _options;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ValueTuple`2<Func`2<TBatch, Task>, Action`1<TBatch>> _subscriber;
    internal TcpClient _tcpClient;
    protected bool _disposed;
    protected Task _subscriptionTask;
    protected Stream _stream;
    protected int _forcedTopologyUpdateAttempts;
    [CompilerGeneratedAttribute]
private AfterAcknowledgmentAction<TBatch, TType> AfterAcknowledgment;
    [CompilerGeneratedAttribute]
private Action OnEstablishedSubscriptionConnection;
    [CompilerGeneratedAttribute]
private Action`1<Exception> OnSubscriptionConnectionRetry;
    [CompilerGeneratedAttribute]
private Action`1<Exception> OnUnexpectedSubscriptionError;
    protected ServerNode _redirectNode;
    protected RequestExecutor _subscriptionLocalRequestExecutor;
    internal Nullable`1<int> SubscriptionTcpVersion;
    internal Nullable`1<DateTime> _lastConnectionFailure;
    private SupportedFeatures _supportedFeatures;
    private ConcurrentQueue`1<Exception> _recentExceptions;
    [CompilerGeneratedAttribute]
private Action`1<AbstractSubscriptionWorker`2<TBatch, TType>> OnDisposed;
    internal TestingStuff<TBatch, TType> _forTestingPurposes;
    public string WorkerId { get; }
    public string CurrentNodeTag { get; }
    public string SubscriptionName { get; }
    internal AbstractSubscriptionWorker`2(SubscriptionWorkerOptions options, string dbName);
    public string get_WorkerId();
    [CompilerGeneratedAttribute]
public void add_AfterAcknowledgment(AfterAcknowledgmentAction<TBatch, TType> value);
    [CompilerGeneratedAttribute]
public void remove_AfterAcknowledgment(AfterAcknowledgmentAction<TBatch, TType> value);
    [CompilerGeneratedAttribute]
internal void add_OnEstablishedSubscriptionConnection(Action value);
    [CompilerGeneratedAttribute]
internal void remove_OnEstablishedSubscriptionConnection(Action value);
    [CompilerGeneratedAttribute]
public void add_OnSubscriptionConnectionRetry(Action`1<Exception> value);
    [CompilerGeneratedAttribute]
public void remove_OnSubscriptionConnectionRetry(Action`1<Exception> value);
    [CompilerGeneratedAttribute]
public void add_OnUnexpectedSubscriptionError(Action`1<Exception> value);
    [CompilerGeneratedAttribute]
public void remove_OnUnexpectedSubscriptionError(Action`1<Exception> value);
    public sealed virtual void Dispose();
    public void Dispose(bool waitForSubscriptionTask);
    public sealed virtual ValueTask DisposeAsync();
    [AsyncStateMachineAttribute("Raven.Client.Documents.Subscriptions.AbstractSubscriptionWorker`2/<DisposeAsync>d__29")]
public virtual ValueTask DisposeAsync(bool waitForSubscriptionTask);
    public Task Run(Action`1<TBatch> processDocuments, CancellationToken ct);
    public Task Run(Func`2<TBatch, Task> processDocuments, CancellationToken ct);
    internal Task RunInternalAsync(CancellationToken ct);
    public string get_CurrentNodeTag();
    public string get_SubscriptionName();
    internal bool ShouldUseCompression();
    [AsyncStateMachineAttribute("Raven.Client.Documents.Subscriptions.AbstractSubscriptionWorker`2/<ConnectToServerAsync>d__41")]
internal Task`1<Stream> ConnectToServerAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Subscriptions.AbstractSubscriptionWorker`2/<NegotiateProtocolVersionForSubscriptionAsync>d__42")]
private Task`1<SupportedFeatures> NegotiateProtocolVersionForSubscriptionAsync(string chosenUrl, TcpConnectionInfo tcpInfo, Stream stream, JsonOperationContext context, List`1<string> _);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Subscriptions.AbstractSubscriptionWorker`2/<LegacyTryGetTcpInfoAsync>d__43")]
private Task`1<TcpConnectionInfo> LegacyTryGetTcpInfoAsync(RequestExecutor requestExecutor, JsonOperationContext context, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Subscriptions.AbstractSubscriptionWorker`2/<LegacyTryGetTcpInfoAsync>d__44")]
private Task`1<TcpConnectionInfo> LegacyTryGetTcpInfoAsync(RequestExecutor requestExecutor, JsonOperationContext context, ServerNode node, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Subscriptions.AbstractSubscriptionWorker`2/<ReadServerResponseAndGetVersionAsync>d__45")]
private ValueTask`1<NegotiationResponse> ReadServerResponseAndGetVersionAsync(JsonOperationContext context, AsyncBlittableJsonTextWriter writer, Stream stream, string destinationUrl);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Subscriptions.AbstractSubscriptionWorker`2/<SendDropMessageAsync>d__46")]
private ValueTask SendDropMessageAsync(JsonOperationContext context, AsyncBlittableJsonTextWriter writer, TcpConnectionHeaderResponse reply);
    private void AssertConnectionState(SubscriptionConnectionServerMessage connectionStatus);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Subscriptions.AbstractSubscriptionWorker`2/<ProcessSubscriptionAsync>d__48")]
private Task ProcessSubscriptionAsync();
    [AsyncStateMachineAttribute("Raven.Client.Documents.Subscriptions.AbstractSubscriptionWorker`2/<ProcessSubscriptionInternalAsync>d__49")]
private Task ProcessSubscriptionInternalAsync(JsonContextPool contextPool, Stream tcpStreamCopy, MemoryBuffer buffer, JsonOperationContext context);
    protected virtual TimeSpan GetTimeToWaitBeforeConnectionRetry();
    protected virtual void HandleSubscriberError(Exception ex);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Subscriptions.AbstractSubscriptionWorker`2/<PrepareBatchAsync>d__52")]
internal virtual Task`1<BatchFromServer> PrepareBatchAsync(JsonContextPool contextPool, Stream tcpStreamCopy, MemoryBuffer buffer, TBatch batch, Task notifiedSubscriber);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Subscriptions.AbstractSubscriptionWorker`2/<ReadSingleSubscriptionBatchFromServerAsync>d__53")]
internal Task`1<BatchFromServer> ReadSingleSubscriptionBatchFromServerAsync(JsonContextPool contextPool, Stream tcpStream, MemoryBuffer buffer, TBatch batch);
    private static void ThrowInvalidServerResponse(SubscriptionConnectionServerMessage receivedMessage);
    private static void ThrowSubscriptionError(SubscriptionConnectionServerMessage receivedMessage);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Subscriptions.AbstractSubscriptionWorker`2/<ReadNextObjectAsync>d__56")]
internal Task`1<SubscriptionConnectionServerMessage> ReadNextObjectAsync(JsonOperationContext context, Stream stream, MemoryBuffer buffer);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Subscriptions.AbstractSubscriptionWorker`2/<SendAckAsync>d__57")]
protected virtual Task SendAckAsync(TBatch batch, Stream stream, JsonOperationContext context, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Subscriptions.AbstractSubscriptionWorker`2/<SendAckInternalAsync>d__58")]
protected Task SendAckInternalAsync(TBatch batch, Stream stream, JsonOperationContext context, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Subscriptions.AbstractSubscriptionWorker`2/<RunSubscriptionAsync>d__59")]
internal Task RunSubscriptionAsync();
    [AsyncStateMachineAttribute("Raven.Client.Documents.Subscriptions.AbstractSubscriptionWorker`2/<TrySetRedirectNode>d__60")]
protected virtual Task TrySetRedirectNode(RequestExecutor reqEx, IReadOnlyList`1<ServerNode> curTopology);
    private void AssertLastConnectionFailure();
    protected virtual ValueTuple`2<bool, ServerNode> CheckIfShouldReconnectWorker(Exception ex, Action assertLastConnectionFailure, Action`1<Exception> onUnexpectedSubscriptionError, bool throwOnRedirectNodeNotFound);
    protected virtual ValueTuple`2<bool, ServerNode> HandleShouldNotTryToReconnect();
    protected virtual ValueTuple`2<bool, ServerNode> HandleAggregateException();
    protected virtual ValueTuple`2<bool, ServerNode> HandleSubscriptionChangeVectorUpdateConcurrencyException(SubscriptionChangeVectorUpdateConcurrencyException subscriptionChangeVectorUpdateConcurrencyException);
    protected virtual ValueTuple`2<bool, ServerNode> HandleSubscriptionClosedException(SubscriptionClosedException sce);
    protected void CloseTcpClient();
    protected abstract virtual RequestExecutor GetRequestExecutor();
    protected abstract virtual void SetLocalRequestExecutor(string url, X509Certificate2 cert);
    protected abstract virtual TBatch CreateEmptyBatch();
    protected abstract virtual Task TrySetRedirectNodeOnConnectToServerAsync();
    [CompilerGeneratedAttribute]
public void add_OnDisposed(Action`1<AbstractSubscriptionWorker`2<TBatch, TType>> value);
    [CompilerGeneratedAttribute]
public void remove_OnDisposed(Action`1<AbstractSubscriptionWorker`2<TBatch, TType>> value);
    internal TestingStuff<TBatch, TType> ForTestingPurposesOnly();
}
internal class Raven.Client.Documents.Subscriptions.BatchFromServer : object {
    public List`1<SubscriptionConnectionServerMessage> Messages;
    public IDisposable ReturnContext;
    public JsonOperationContext Context;
    public List`1<BlittableJsonReaderObject> Includes;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<ValueTuple`2<BlittableJsonReaderObject, Dictionary`2<string, String[]>>> CounterIncludes;
    public List`1<BlittableJsonReaderObject> TimeSeriesIncludes;
    internal static ValueTuple`3<BlittableJsonReaderObject, LazyStringValue, string> GetMetadataFromBlittable(BlittableJsonReaderObject curDoc);
    private static void ThrowRequired(string name);
}
public class Raven.Client.Documents.Subscriptions.CreateSubscriptionResult : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RaftCommandIndex>k__BackingField;
    public string Name { get; public set; }
    public long RaftCommandIndex { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public long get_RaftCommandIndex();
    [CompilerGeneratedAttribute]
public void set_RaftCommandIndex(long value);
}
public class Raven.Client.Documents.Subscriptions.DocumentSubscriptions : object {
    private DocumentStore _store;
    private ConcurrentSet`1<IAsyncDisposable> _subscriptions;
    internal static string IncludeRevisionsRQL;
    public DocumentSubscriptions(IDocumentStore store);
    private static DocumentSubscriptions();
    public string Create(SubscriptionCreationOptions`1<T> options, string database);
    public string Create(Expression`1<Func`2<T, bool>> predicate, SubscriptionCreationOptions options, string database);
    public Task`1<string> CreateAsync(SubscriptionCreationOptions`1<T> options, string database, CancellationToken token);
    public Task`1<string> CreateAsync(Expression`1<Func`2<T, bool>> predicate, SubscriptionCreationOptions options, string database, CancellationToken token);
    internal static SubscriptionCreationOptions CreateSubscriptionOptionsFromGeneric(DocumentConventions conventions, SubscriptionCreationOptions criteria, Expression`1<Func`2<T, bool>> predicate, Expression`1<Func`2<T, object>> project, Action`1<ISubscriptionIncludeBuilder`1<T>> includes);
    public string Create(SubscriptionCreationOptions options, string database);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Subscriptions.DocumentSubscriptions/<CreateAsync>d__10")]
public Task`1<string> CreateAsync(SubscriptionCreationOptions options, string database, CancellationToken token);
    public SubscriptionWorker`1<object> GetSubscriptionWorker(SubscriptionWorkerOptions options, string database);
    public SubscriptionWorker`1<object> GetSubscriptionWorker(string subscriptionName, string database);
    public SubscriptionWorker`1<T> GetSubscriptionWorker(SubscriptionWorkerOptions options, string database);
    public SubscriptionWorker`1<T> GetSubscriptionWorker(string subscriptionName, string database);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Subscriptions.DocumentSubscriptions/<GetSubscriptionsAsync>d__15")]
public Task`1<List`1<SubscriptionState>> GetSubscriptionsAsync(int start, int take, string database, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Subscriptions.DocumentSubscriptions/<DeleteAsync>d__16")]
public Task DeleteAsync(string name, string database, CancellationToken token);
    public void Delete(string name, string database);
    public SubscriptionState GetSubscriptionState(string subscriptionName, string database);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Subscriptions.DocumentSubscriptions/<GetSubscriptionStateAsync>d__19")]
public Task`1<SubscriptionState> GetSubscriptionStateAsync(string subscriptionName, string database, CancellationToken token);
    public sealed virtual void Dispose();
    public List`1<SubscriptionState> GetSubscriptions(int start, int take, string database);
    public void DropSubscriptionWorker(SubscriptionWorker`1<T> worker, string database);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Subscriptions.DocumentSubscriptions/<DropSubscriptionWorkerAsync>d__23`1")]
public Task DropSubscriptionWorkerAsync(SubscriptionWorker`1<T> worker, string database, CancellationToken token);
    public void DropConnection(string name, string database);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Subscriptions.DocumentSubscriptions/<DropConnectionAsync>d__25")]
public Task DropConnectionAsync(string name, string database, CancellationToken token);
    public void Enable(string name, string database);
    public Task EnableAsync(string name, string database, CancellationToken token);
    public void Disable(string name, string database);
    public Task DisableAsync(string name, string database, CancellationToken token);
    public string Update(SubscriptionUpdateOptions options, string database);
    [AsyncStateMachineAttribute("Raven.Client.Documents.Subscriptions.DocumentSubscriptions/<UpdateAsync>d__31")]
public Task`1<string> UpdateAsync(SubscriptionUpdateOptions options, string database, CancellationToken token);
    [CompilerGeneratedAttribute]
private void <GetSubscriptionWorker>b__13_0(AbstractSubscriptionWorker`2<SubscriptionBatch`1<T>, T> sender);
}
public class Raven.Client.Documents.Subscriptions.GetSubscriptionsResult : object {
    public SubscriptionState[] Results;
}
public class Raven.Client.Documents.Subscriptions.Revision`1 : object {
    public T Previous;
    public T Current;
}
public class Raven.Client.Documents.Subscriptions.SubscriptionBatch`1 : SubscriptionBatchBase`1<T> {
    private IDocumentStore _store;
    private GenerateEntityIdOnTheClient _generateEntityIdOnTheClient;
    private bool _sessionOpened;
    public SubscriptionBatch`1(RequestExecutor requestExecutor, IDocumentStore store, string dbName, Logger logger);
    internal virtual ValueTask InitializeAsync(BatchFromServer batch);
    public IDocumentSession OpenSession();
    public IDocumentSession OpenSession(SessionOptions options);
    private IDocumentSession OpenSessionInternal(SessionOptions options);
    public IAsyncDocumentSession OpenAsyncSession();
    public IAsyncDocumentSession OpenAsyncSession(SessionOptions options);
    private IAsyncDocumentSession OpenAsyncSessionInternal(SessionOptions options);
    private static void ThrowSessionCanBeOpenedOnlyOnce();
    private static void ValidateSessionOptions(SessionOptions options);
    private void LoadDataToSession(InMemoryDocumentSessionOperations s);
    protected virtual void EnsureDocumentId(T item, string id);
}
public abstract class Raven.Client.Documents.Subscriptions.SubscriptionBatchBase`1 : object {
    public string LastSentChangeVectorInBatch;
    protected RequestExecutor _requestExecutor;
    protected string _dbName;
    protected Logger _logger;
    [CompilerGeneratedAttribute]
private List`1<Item<T>> <Items>k__BackingField;
    protected List`1<BlittableJsonReaderObject> _includes;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected List`1<ValueTuple`2<BlittableJsonReaderObject, Dictionary`2<string, String[]>>> _counterIncludes;
    protected List`1<BlittableJsonReaderObject> _timeSeriesIncludes;
    public int NumberOfItemsInBatch { get; }
    internal int NumberOfIncludes { get; }
    public List`1<Item<T>> Items { get; }
    protected SubscriptionBatchBase`1(RequestExecutor requestExecutor, string dbName, Logger logger);
    public int get_NumberOfItemsInBatch();
    internal int get_NumberOfIncludes();
    [CompilerGeneratedAttribute]
public List`1<Item<T>> get_Items();
    protected abstract virtual void EnsureDocumentId(T item, string id);
    internal virtual ValueTask InitializeAsync(BatchFromServer batch);
}
internal class Raven.Client.Documents.Subscriptions.SubscriptionConnectionClientMessage : object {
    [CompilerGeneratedAttribute]
private MessageType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    public MessageType Type { get; public set; }
    public string ChangeVector { get; public set; }
    [CompilerGeneratedAttribute]
public MessageType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(MessageType value);
    [CompilerGeneratedAttribute]
public string get_ChangeVector();
    [CompilerGeneratedAttribute]
public void set_ChangeVector(string value);
}
internal class Raven.Client.Documents.Subscriptions.SubscriptionConnectionServerMessage : object {
    [CompilerGeneratedAttribute]
private MessageType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <Includes>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <CounterIncludes>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, String[]> <IncludedCounterNames>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <TimeSeriesIncludes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public MessageType Type { get; public set; }
    public ConnectionStatus Status { get; public set; }
    public BlittableJsonReaderObject Data { get; public set; }
    public BlittableJsonReaderObject Includes { get; public set; }
    public BlittableJsonReaderObject CounterIncludes { get; public set; }
    public Dictionary`2<string, String[]> IncludedCounterNames { get; public set; }
    public BlittableJsonReaderObject TimeSeriesIncludes { get; public set; }
    public string Exception { get; public set; }
    public string Message { get; public set; }
    [CompilerGeneratedAttribute]
public MessageType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(MessageType value);
    [CompilerGeneratedAttribute]
public ConnectionStatus get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(ConnectionStatus value);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(BlittableJsonReaderObject value);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_Includes();
    [CompilerGeneratedAttribute]
public void set_Includes(BlittableJsonReaderObject value);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_CounterIncludes();
    [CompilerGeneratedAttribute]
public void set_CounterIncludes(BlittableJsonReaderObject value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, String[]> get_IncludedCounterNames();
    [CompilerGeneratedAttribute]
public void set_IncludedCounterNames(Dictionary`2<string, String[]> value);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_TimeSeriesIncludes();
    [CompilerGeneratedAttribute]
public void set_TimeSeriesIncludes(BlittableJsonReaderObject value);
    [CompilerGeneratedAttribute]
public string get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(string value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
}
public class Raven.Client.Documents.Subscriptions.SubscriptionCreationOptions : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Query>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MentorNode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PinToMentorNode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ArchivedDataProcessingBehavior> <ArchivedDataProcessingBehavior>k__BackingField;
    public string Name { get; public set; }
    public string Query { get; public set; }
    public string ChangeVector { get; public set; }
    public string MentorNode { get; public set; }
    public bool Disabled { get; public set; }
    public bool PinToMentorNode { get; public set; }
    public Nullable`1<ArchivedDataProcessingBehavior> ArchivedDataProcessingBehavior { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Query();
    [CompilerGeneratedAttribute]
public void set_Query(string value);
    [CompilerGeneratedAttribute]
public string get_ChangeVector();
    [CompilerGeneratedAttribute]
public void set_ChangeVector(string value);
    [CompilerGeneratedAttribute]
public string get_MentorNode();
    [CompilerGeneratedAttribute]
public void set_MentorNode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_Disabled();
    [CompilerGeneratedAttribute]
public virtual void set_Disabled(bool value);
    [CompilerGeneratedAttribute]
public virtual bool get_PinToMentorNode();
    [CompilerGeneratedAttribute]
public virtual void set_PinToMentorNode(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<ArchivedDataProcessingBehavior> get_ArchivedDataProcessingBehavior();
    [CompilerGeneratedAttribute]
public void set_ArchivedDataProcessingBehavior(Nullable`1<ArchivedDataProcessingBehavior> value);
}
public class Raven.Client.Documents.Subscriptions.SubscriptionCreationOptions`1 : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<T, bool>> <Filter>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<T, object>> <Projection>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<ISubscriptionIncludeBuilder`1<T>> <Includes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MentorNode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PinToMentorNode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ArchivedDataProcessingBehavior> <ArchivedDataProcessingBehavior>k__BackingField;
    public string Name { get; public set; }
    public bool Disabled { get; public set; }
    public Expression`1<Func`2<T, bool>> Filter { get; public set; }
    public Expression`1<Func`2<T, object>> Projection { get; public set; }
    public Action`1<ISubscriptionIncludeBuilder`1<T>> Includes { get; public set; }
    public string ChangeVector { get; public set; }
    public string MentorNode { get; public set; }
    public bool PinToMentorNode { get; public set; }
    public Nullable`1<ArchivedDataProcessingBehavior> ArchivedDataProcessingBehavior { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    [CompilerGeneratedAttribute]
public Expression`1<Func`2<T, bool>> get_Filter();
    [CompilerGeneratedAttribute]
public void set_Filter(Expression`1<Func`2<T, bool>> value);
    [CompilerGeneratedAttribute]
public Expression`1<Func`2<T, object>> get_Projection();
    [CompilerGeneratedAttribute]
public void set_Projection(Expression`1<Func`2<T, object>> value);
    [CompilerGeneratedAttribute]
public Action`1<ISubscriptionIncludeBuilder`1<T>> get_Includes();
    [CompilerGeneratedAttribute]
public void set_Includes(Action`1<ISubscriptionIncludeBuilder`1<T>> value);
    [CompilerGeneratedAttribute]
public string get_ChangeVector();
    [CompilerGeneratedAttribute]
public void set_ChangeVector(string value);
    [CompilerGeneratedAttribute]
public string get_MentorNode();
    [CompilerGeneratedAttribute]
public void set_MentorNode(string value);
    [CompilerGeneratedAttribute]
public bool get_PinToMentorNode();
    [CompilerGeneratedAttribute]
public void set_PinToMentorNode(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<ArchivedDataProcessingBehavior> get_ArchivedDataProcessingBehavior();
    [CompilerGeneratedAttribute]
public void set_ArchivedDataProcessingBehavior(Nullable`1<ArchivedDataProcessingBehavior> value);
    public SubscriptionCreationOptions ToSubscriptionCreationOptions(DocumentConventions conventions);
}
public enum Raven.Client.Documents.Subscriptions.SubscriptionMode : Enum {
    public int value__;
    public static SubscriptionMode None;
    public static SubscriptionMode Single;
    public static SubscriptionMode Concurrent;
}
public enum Raven.Client.Documents.Subscriptions.SubscriptionOpeningStrategy : Enum {
    public int value__;
    public static SubscriptionOpeningStrategy OpenIfFree;
    public static SubscriptionOpeningStrategy TakeOver;
    public static SubscriptionOpeningStrategy WaitForFree;
    public static SubscriptionOpeningStrategy Concurrent;
}
public class Raven.Client.Documents.Subscriptions.SubscriptionShardingState : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <ChangeVectorForNextBatchStartingPointPerShard>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <NodeTagPerShard>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<int, string> <ProcessedChangeVectorPerBucket>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVectorForNextBatchStartingPointForOrchestrator>k__BackingField;
    public Dictionary`2<string, string> ChangeVectorForNextBatchStartingPointPerShard { get; public set; }
    public Dictionary`2<string, string> NodeTagPerShard { get; public set; }
    public Dictionary`2<int, string> ProcessedChangeVectorPerBucket { get; public set; }
    public string ChangeVectorForNextBatchStartingPointForOrchestrator { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_ChangeVectorForNextBatchStartingPointPerShard();
    [CompilerGeneratedAttribute]
public void set_ChangeVectorForNextBatchStartingPointPerShard(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_NodeTagPerShard();
    [CompilerGeneratedAttribute]
public void set_NodeTagPerShard(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<int, string> get_ProcessedChangeVectorPerBucket();
    [CompilerGeneratedAttribute]
public void set_ProcessedChangeVectorPerBucket(Dictionary`2<int, string> value);
    [CompilerGeneratedAttribute]
public string get_ChangeVectorForNextBatchStartingPointForOrchestrator();
    [CompilerGeneratedAttribute]
public void set_ChangeVectorForNextBatchStartingPointForOrchestrator(string value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Client.Documents.Subscriptions.SubscriptionState : object {
    [CompilerGeneratedAttribute]
private string <Query>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVectorForNextBatchStartingPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SubscriptionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SubscriptionName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MentorNode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PinToMentorNode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastBatchAckTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastClientConnectionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RaftCommandIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ArchivedDataProcessingBehavior> <ArchivedDataProcessingBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private SubscriptionShardingState <ShardingState>k__BackingField;
    public string Query { get; public set; }
    public string ChangeVectorForNextBatchStartingPoint { get; public set; }
    public long SubscriptionId { get; public set; }
    public string SubscriptionName { get; public set; }
    public string MentorNode { get; public set; }
    public bool PinToMentorNode { get; public set; }
    public Nullable`1<DateTime> LastBatchAckTime { get; public set; }
    public Nullable`1<DateTime> LastClientConnectionTime { get; public set; }
    public bool Disabled { get; public set; }
    public long RaftCommandIndex { get; public set; }
    public string NodeTag { get; public set; }
    public Nullable`1<ArchivedDataProcessingBehavior> ArchivedDataProcessingBehavior { get; public set; }
    public SubscriptionShardingState ShardingState { get; public set; }
    internal static string Prefix { get; }
    [CompilerGeneratedAttribute]
public string get_Query();
    [CompilerGeneratedAttribute]
public void set_Query(string value);
    [CompilerGeneratedAttribute]
public string get_ChangeVectorForNextBatchStartingPoint();
    [CompilerGeneratedAttribute]
public void set_ChangeVectorForNextBatchStartingPoint(string value);
    [CompilerGeneratedAttribute]
public long get_SubscriptionId();
    [CompilerGeneratedAttribute]
public void set_SubscriptionId(long value);
    [CompilerGeneratedAttribute]
public string get_SubscriptionName();
    [CompilerGeneratedAttribute]
public void set_SubscriptionName(string value);
    [CompilerGeneratedAttribute]
public string get_MentorNode();
    [CompilerGeneratedAttribute]
public void set_MentorNode(string value);
    [CompilerGeneratedAttribute]
public bool get_PinToMentorNode();
    [CompilerGeneratedAttribute]
public void set_PinToMentorNode(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastBatchAckTime();
    [CompilerGeneratedAttribute]
public void set_LastBatchAckTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastClientConnectionTime();
    [CompilerGeneratedAttribute]
public void set_LastClientConnectionTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    [CompilerGeneratedAttribute]
public long get_RaftCommandIndex();
    [CompilerGeneratedAttribute]
public void set_RaftCommandIndex(long value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_NodeTag();
    [CompilerGeneratedAttribute]
public void set_NodeTag(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<ArchivedDataProcessingBehavior> get_ArchivedDataProcessingBehavior();
    [CompilerGeneratedAttribute]
public void set_ArchivedDataProcessingBehavior(Nullable`1<ArchivedDataProcessingBehavior> value);
    [CompilerGeneratedAttribute]
public SubscriptionShardingState get_ShardingState();
    [CompilerGeneratedAttribute]
public void set_ShardingState(SubscriptionShardingState value);
    public sealed virtual ulong GetTaskKey();
    public sealed virtual string GetMentorNode();
    public sealed virtual string GetDefaultTaskName();
    public sealed virtual string GetTaskName();
    public sealed virtual bool IsResourceIntensive();
    public sealed virtual bool IsPinnedToMentorNode();
    public virtual DynamicJsonValue ToJson();
    public static string GenerateSubscriptionItemKeyName(string databaseName, string subscriptionName);
    public static string SubscriptionPrefix(string databaseName);
    internal static string get_Prefix();
}
internal class Raven.Client.Documents.Subscriptions.SubscriptionStateWithNodeDetails : SubscriptionState {
    [CompilerGeneratedAttribute]
private NodeId <ResponsibleNode>k__BackingField;
    public NodeId ResponsibleNode { get; public set; }
    [CompilerGeneratedAttribute]
public NodeId get_ResponsibleNode();
    [CompilerGeneratedAttribute]
public void set_ResponsibleNode(NodeId value);
    public virtual DynamicJsonValue ToJson();
}
internal class Raven.Client.Documents.Subscriptions.SubscriptionTryout : object {
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Query>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ArchivedDataProcessingBehavior> <ArchivedDataProcessingBehavior>k__BackingField;
    public string ChangeVector { get; public set; }
    public string Query { get; public set; }
    public Nullable`1<ArchivedDataProcessingBehavior> ArchivedDataProcessingBehavior { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ChangeVector();
    [CompilerGeneratedAttribute]
public void set_ChangeVector(string value);
    [CompilerGeneratedAttribute]
public string get_Query();
    [CompilerGeneratedAttribute]
public void set_Query(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<ArchivedDataProcessingBehavior> get_ArchivedDataProcessingBehavior();
    [CompilerGeneratedAttribute]
public void set_ArchivedDataProcessingBehavior(Nullable`1<ArchivedDataProcessingBehavior> value);
}
public class Raven.Client.Documents.Subscriptions.SubscriptionUpdateOptions : SubscriptionCreationOptions {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CreateNew>k__BackingField;
    private bool _pinToMentorNode;
    [CompilerGeneratedAttribute]
private bool <PinToMentorNodeWasSet>k__BackingField;
    private bool _disabled;
    [CompilerGeneratedAttribute]
private bool <DisabledWasSet>k__BackingField;
    public Nullable`1<long> Id { get; public set; }
    public bool CreateNew { get; public set; }
    public bool PinToMentorNode { get; public set; }
    internal bool PinToMentorNodeWasSet { get; internal set; }
    public bool Disabled { get; public set; }
    internal bool DisabledWasSet { get; internal set; }
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public bool get_CreateNew();
    [CompilerGeneratedAttribute]
public void set_CreateNew(bool value);
    public virtual bool get_PinToMentorNode();
    public virtual void set_PinToMentorNode(bool value);
    [CompilerGeneratedAttribute]
internal bool get_PinToMentorNodeWasSet();
    [CompilerGeneratedAttribute]
internal void set_PinToMentorNodeWasSet(bool value);
    public virtual bool get_Disabled();
    public virtual void set_Disabled(bool value);
    [CompilerGeneratedAttribute]
internal bool get_DisabledWasSet();
    [CompilerGeneratedAttribute]
internal void set_DisabledWasSet(bool value);
}
public class Raven.Client.Documents.Subscriptions.SubscriptionWorker`1 : AbstractSubscriptionWorker`2<SubscriptionBatch`1<T>, T> {
    private DocumentStore _store;
    internal SubscriptionWorker`1(SubscriptionWorkerOptions options, DocumentStore documentStore, string dbName);
    protected virtual RequestExecutor GetRequestExecutor();
    protected virtual void SetLocalRequestExecutor(string url, X509Certificate2 cert);
    protected virtual SubscriptionBatch`1<T> CreateEmptyBatch();
    protected virtual Task TrySetRedirectNodeOnConnectToServerAsync();
}
public class Raven.Client.Documents.Subscriptions.SubscriptionWorkerOptions : object {
    internal static int DefaultSendBufferSizeInBytes;
    internal static int DefaultReceiveBufferSizeInBytes;
    [CompilerGeneratedAttribute]
private string <SubscriptionName>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TimeToWaitBeforeConnectionRetry>k__BackingField;
    private TimeSpan _connectionStreamTimeout;
    [CompilerGeneratedAttribute]
private bool <IgnoreSubscriberErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private SubscriptionOpeningStrategy <Strategy>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDocsPerBatch>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MaxErroneousPeriod>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CloseWhenNoDocsLeft>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SendBufferSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReceiveBufferSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WorkerId>k__BackingField;
    public string SubscriptionName { get; private set; }
    public TimeSpan TimeToWaitBeforeConnectionRetry { get; public set; }
    public TimeSpan ConnectionStreamTimeout { get; public set; }
    public bool IgnoreSubscriberErrors { get; public set; }
    public SubscriptionOpeningStrategy Strategy { get; public set; }
    public int MaxDocsPerBatch { get; public set; }
    public TimeSpan MaxErroneousPeriod { get; public set; }
    public bool CloseWhenNoDocsLeft { get; public set; }
    public int SendBufferSizeInBytes { get; public set; }
    public int ReceiveBufferSizeInBytes { get; public set; }
    public string WorkerId { get; internal set; }
    public SubscriptionWorkerOptions(string subscriptionName);
    [CompilerGeneratedAttribute]
public string get_SubscriptionName();
    [CompilerGeneratedAttribute]
private void set_SubscriptionName(string value);
    [CompilerGeneratedAttribute]
public TimeSpan get_TimeToWaitBeforeConnectionRetry();
    [CompilerGeneratedAttribute]
public void set_TimeToWaitBeforeConnectionRetry(TimeSpan value);
    public TimeSpan get_ConnectionStreamTimeout();
    public void set_ConnectionStreamTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreSubscriberErrors();
    [CompilerGeneratedAttribute]
public void set_IgnoreSubscriberErrors(bool value);
    [CompilerGeneratedAttribute]
public SubscriptionOpeningStrategy get_Strategy();
    [CompilerGeneratedAttribute]
public void set_Strategy(SubscriptionOpeningStrategy value);
    [CompilerGeneratedAttribute]
public int get_MaxDocsPerBatch();
    [CompilerGeneratedAttribute]
public void set_MaxDocsPerBatch(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxErroneousPeriod();
    [CompilerGeneratedAttribute]
public void set_MaxErroneousPeriod(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_CloseWhenNoDocsLeft();
    [CompilerGeneratedAttribute]
public void set_CloseWhenNoDocsLeft(bool value);
    [CompilerGeneratedAttribute]
public int get_SendBufferSizeInBytes();
    [CompilerGeneratedAttribute]
public void set_SendBufferSizeInBytes(int value);
    [CompilerGeneratedAttribute]
public int get_ReceiveBufferSizeInBytes();
    [CompilerGeneratedAttribute]
public void set_ReceiveBufferSizeInBytes(int value);
    [CompilerGeneratedAttribute]
public string get_WorkerId();
    [CompilerGeneratedAttribute]
internal void set_WorkerId(string value);
    internal SubscriptionWorkerOptions Clone();
}
public class Raven.Client.Documents.Subscriptions.UpdateSubscriptionResult : CreateSubscriptionResult {
}
public class Raven.Client.Documents.TimeSeries.TimeSeriesOperations : object {
    private IDocumentStore _store;
    private string _database;
    private MaintenanceOperationExecutor _executor;
    public TimeSeriesOperations(IDocumentStore store);
    private TimeSeriesOperations(IDocumentStore store, string database);
    public Task RegisterAsync(string name);
    public Task RegisterAsync(string name, String[] valueNames);
    public Task RegisterAsync(string collection, string name, String[] valueNames);
    public Task SetPolicyAsync(string name, TimeValue aggregation, TimeValue retention);
    public Task SetPolicyAsync(string collection, string name, TimeValue aggregation, TimeValue retention);
    public Task SetRawPolicyAsync(TimeValue retention);
    public Task SetRawPolicyAsync(string collection, TimeValue retention);
    public Task RemovePolicyAsync(string collection, string name);
    public Task RemovePolicyAsync(string name);
    public void Register(string name);
    public void Register(string name, String[] valueNames);
    public void Register(string collection, string name, String[] valueNames);
    public void SetPolicy(string name, TimeValue aggregation, TimeValue retention);
    public void SetPolicy(string collection, string name, TimeValue aggregation, TimeValue retention);
    public void SetRawPolicy(TimeValue retention);
    public void SetRawPolicy(string collection, TimeValue retention);
    public void RemovePolicy(string collection, string name);
    public void RemovePolicy(string name);
    internal static string GetTimeSeriesName(DocumentConventions conventions);
    public TimeSeriesOperations ForDatabase(string database);
}
public class Raven.Client.Exceptions.AllTopologyNodesDownException : Exception {
    [CompilerGeneratedAttribute]
private Topology <FailedTopology>k__BackingField;
    public Topology FailedTopology { get; }
    public AllTopologyNodesDownException(string message);
    public AllTopologyNodesDownException(string message, Exception innerException);
    public AllTopologyNodesDownException(string message, Topology failedTopology, Exception innerException);
    [CompilerGeneratedAttribute]
public Topology get_FailedTopology();
}
public class Raven.Client.Exceptions.BadRequestException : RavenException {
    public BadRequestException(string message);
    public BadRequestException(string message, Exception inner);
}
public class Raven.Client.Exceptions.BadResponseException : RavenException {
    public BadResponseException(string message);
    public BadResponseException(string message, Exception inner);
}
public class Raven.Client.Exceptions.Changes.ChangeProcessingException : RavenException {
    public ChangeProcessingException(string message);
    public ChangeProcessingException(Exception e);
}
public class Raven.Client.Exceptions.ClientVersionMismatchException : RavenException {
    public ClientVersionMismatchException(string message);
    public ClientVersionMismatchException(string message, Exception innerException);
}
public class Raven.Client.Exceptions.Cluster.CommandExecutionException : RavenException {
    public CommandExecutionException(string message);
    public CommandExecutionException(string message, Exception inner);
}
public class Raven.Client.Exceptions.Cluster.NodeIsPassiveException : RavenException {
    public NodeIsPassiveException(string message);
    public NodeIsPassiveException(string message, Exception inner);
}
public class Raven.Client.Exceptions.Cluster.NoLeaderException : RavenException {
    public NoLeaderException(string message);
    public NoLeaderException(string message, Exception inner);
}
public class Raven.Client.Exceptions.ClusterTransactionConcurrencyException : ConcurrencyException {
    [CompilerGeneratedAttribute]
private ConcurrencyViolation[] <ConcurrencyViolations>k__BackingField;
    public ConcurrencyViolation[] ConcurrencyViolations { get; public set; }
    public ClusterTransactionConcurrencyException(string message);
    public ClusterTransactionConcurrencyException(string message, Exception inner);
    [CompilerGeneratedAttribute]
public ConcurrencyViolation[] get_ConcurrencyViolations();
    [CompilerGeneratedAttribute]
public void set_ConcurrencyViolations(ConcurrencyViolation[] value);
}
public class Raven.Client.Exceptions.Commercial.LicenseActivationException : RavenException {
    public LicenseActivationException(string message);
    public LicenseActivationException(string message, Exception e);
}
public class Raven.Client.Exceptions.Commercial.LicenseLimitException : RavenException {
    [CompilerGeneratedAttribute]
private LimitType <Type>k__BackingField;
    public LimitType Type { get; }
    public LicenseLimitException(string message);
    public LicenseLimitException(LimitType type, string message);
    public LicenseLimitException(string message, Exception e);
    [CompilerGeneratedAttribute]
public LimitType get_Type();
}
public enum Raven.Client.Exceptions.Commercial.LimitType : Enum {
    public int value__;
    [DescriptionAttribute("Invalid License")]
public static LimitType InvalidLicense;
    [DescriptionAttribute("Forbidden Host")]
public static LimitType ForbiddenHost;
    [DescriptionAttribute("Dynamic Nodes Distribution")]
public static LimitType DynamicNodeDistribution;
    [DescriptionAttribute("Cluster Size")]
public static LimitType ClusterSize;
    [DescriptionAttribute("Snapshot Backup")]
public static LimitType SnapshotBackup;
    [DescriptionAttribute("Cloud Backup")]
public static LimitType CloudBackup;
    [DescriptionAttribute("Encryption")]
public static LimitType Encryption;
    [DescriptionAttribute("Documents Compression")]
public static LimitType DocumentsCompression;
    [DescriptionAttribute("Rolling Indexes")]
public static LimitType RollingIndexes;
    [DescriptionAttribute("External Replication")]
public static LimitType ExternalReplication;
    [DescriptionAttribute("Raven ETL")]
public static LimitType RavenEtl;
    [DescriptionAttribute("SQL ETL")]
public static LimitType SqlEtl;
    [DescriptionAttribute("OLAP ETL")]
public static LimitType OlapEtl;
    [DescriptionAttribute("ElasticSearch ETL")]
public static LimitType ElasticSearchEtl;
    [DescriptionAttribute("Queue ETL")]
public static LimitType QueueEtl;
    [DescriptionAttribute("Cores Limit")]
public static LimitType Cores;
    [DescriptionAttribute("SNMP")]
public static LimitType Snmp;
    [DescriptionAttribute("PostgreSql Integration")]
public static LimitType PostgreSqlIntegration;
    [DescriptionAttribute("Power BI")]
public static LimitType PowerBI;
    [DescriptionAttribute("Delayed External Replication")]
public static LimitType DelayedExternalReplication;
    [DescriptionAttribute("Highly Available Tasks")]
public static LimitType HighlyAvailableTasks;
    [DescriptionAttribute("Pull Replication As Hub")]
public static LimitType PullReplicationAsHub;
    [DescriptionAttribute("Pull Replication As Sink")]
public static LimitType PullReplicationAsSink;
    [DescriptionAttribute("Time Series Rollups and Retention")]
public static LimitType TimeSeriesRollupsAndRetention;
    [DescriptionAttribute("Encrypted Backup")]
public static LimitType EncryptedBackup;
    [DescriptionAttribute("Additional Assemblies from NuGet")]
public static LimitType AdditionalAssembliesFromNuGet;
    [DescriptionAttribute("Monitoring Endpoints")]
public static LimitType MonitoringEndpoints;
    [DescriptionAttribute("Read-only Certificates")]
public static LimitType ReadOnlyCertificates;
    [DescriptionAttribute("Concurrent Subscriptions")]
public static LimitType ConcurrentSubscriptions;
    [DescriptionAttribute("TCP Data Compression")]
public static LimitType TcpDataCompression;
    [DescriptionAttribute("Server Wide Backups")]
public static LimitType ServerWideBackups;
    [DescriptionAttribute("Server Wide External Replications")]
public static LimitType ServerWideExternalReplications;
    [DescriptionAttribute("Server Wide Custom Sorters")]
public static LimitType ServerWideCustomSorters;
    [DescriptionAttribute("Server Wide Analyzers")]
public static LimitType ServerWideAnalyzers;
    [DescriptionAttribute("Index Cleanup")]
public static LimitType IndexCleanup;
    [DescriptionAttribute("Periodic Backup")]
public static LimitType PeriodicBackup;
    [DescriptionAttribute("Client Configuration")]
public static LimitType ClientConfiguration;
    [DescriptionAttribute("Studio Configuration")]
public static LimitType StudioConfiguration;
    [DescriptionAttribute("Queue Sink")]
public static LimitType QueueSink;
    [DescriptionAttribute("Data Archival")]
public static LimitType DataArchival;
    [DescriptionAttribute("Sharding")]
public static LimitType Sharding;
    [DescriptionAttribute("Subscriptions")]
public static LimitType Subscriptions;
    [DescriptionAttribute("Revisions Configuration")]
public static LimitType RevisionsConfiguration;
    [DescriptionAttribute("Expiration")]
public static LimitType Expiration;
    [DescriptionAttribute("Refresh")]
public static LimitType Refresh;
    [DescriptionAttribute("Indexes")]
public static LimitType Indexes;
    [DescriptionAttribute("Custom Sorters")]
public static LimitType CustomSorters;
    [DescriptionAttribute("Custom Analyzers")]
public static LimitType CustomAnalyzers;
}
public class Raven.Client.Exceptions.Commercial.PortInUseException : RavenException {
    public PortInUseException(string message);
    public PortInUseException(int port, string address, string message, Exception e);
    private static string BuildMessage(string message, int port, string address);
}
public class Raven.Client.Exceptions.CompareExchangeInvalidKeyException : RavenException {
    public CompareExchangeInvalidKeyException(string message);
    public CompareExchangeInvalidKeyException(string message, Exception inner);
}
public class Raven.Client.Exceptions.CompareExchangeKeyTooBigException : RavenException {
    public CompareExchangeKeyTooBigException(string message);
    public CompareExchangeKeyTooBigException(string message, Exception inner);
}
public abstract class Raven.Client.Exceptions.Compilation.CompilationException : RavenException {
    protected CompilationException(string message);
    protected CompilationException(string message, Exception inner);
}
public class Raven.Client.Exceptions.ConcurrencyException : ConflictException {
    [CompilerGeneratedAttribute]
private string <ExpectedChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActualChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    public string ExpectedChangeVector { get; public set; }
    public string ActualChangeVector { get; public set; }
    public string Id { get; public set; }
    public ConcurrencyException(string message);
    public ConcurrencyException(string message, Exception inner);
    [CompilerGeneratedAttribute]
public string get_ExpectedChangeVector();
    [CompilerGeneratedAttribute]
public void set_ExpectedChangeVector(string value);
    [CompilerGeneratedAttribute]
public string get_ActualChangeVector();
    [CompilerGeneratedAttribute]
public void set_ActualChangeVector(string value);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
}
public abstract class Raven.Client.Exceptions.ConflictException : RavenException {
    protected ConflictException(string message);
    protected ConflictException(string message, Exception inner);
}
public class Raven.Client.Exceptions.Corax.NotImplementedInCoraxException : RavenException {
    public NotImplementedInCoraxException(string message);
    public NotImplementedInCoraxException(string message, Exception e);
}
public class Raven.Client.Exceptions.Corax.NotSupportedInCoraxException : RavenException {
    public NotSupportedInCoraxException(string message);
    public NotSupportedInCoraxException(string message, Exception e);
}
public class Raven.Client.Exceptions.Database.DatabaseConcurrentLoadTimeoutException : RavenException {
    public DatabaseConcurrentLoadTimeoutException(string message);
    public DatabaseConcurrentLoadTimeoutException(string message, Exception innerException);
}
public class Raven.Client.Exceptions.Database.DatabaseDisabledException : RavenException {
    public DatabaseDisabledException(string message);
    public DatabaseDisabledException(string message, Exception inner);
}
public class Raven.Client.Exceptions.Database.DatabaseDoesNotExistException : RavenException {
    public DatabaseDoesNotExistException(string msg);
    public DatabaseDoesNotExistException(string message, Exception e);
    public static DatabaseDoesNotExistException CreateWithMessage(string databaseName, string message);
    public static void Throw(string databaseName);
    public static void ThrowWithMessage(string databaseName, string message);
    public static void ThrowWithMessageAndException(string databaseName, string message, Exception exception);
    private static string GetMessage(string databaseName, string message);
}
public class Raven.Client.Exceptions.Database.DatabaseIdleException : RavenException {
    public DatabaseIdleException(string message);
    public DatabaseIdleException(string message, Exception inner);
}
public class Raven.Client.Exceptions.Database.DatabaseLoadFailureException : RavenException {
    public DatabaseLoadFailureException(string message);
    public DatabaseLoadFailureException(string message, Exception e);
}
public class Raven.Client.Exceptions.Database.DatabaseLoadTimeoutException : RavenException {
    public DatabaseLoadTimeoutException(string message);
}
public class Raven.Client.Exceptions.Database.DatabaseNotRelevantException : RavenException {
    public DatabaseNotRelevantException(string message);
    public DatabaseNotRelevantException(string message, Exception innerException);
}
public class Raven.Client.Exceptions.Database.DatabaseRestoringException : RavenException {
    public DatabaseRestoringException(string message);
    public DatabaseRestoringException(string message, Exception inner);
}
public class Raven.Client.Exceptions.Database.DatabaseSchemaErrorException : RavenException {
    public DatabaseSchemaErrorException(string message);
    public DatabaseSchemaErrorException(string message, Exception e);
}
public class Raven.Client.Exceptions.Documents.Analyzers.AnalyzerDoesNotExistException : RavenException {
    public AnalyzerDoesNotExistException(string message);
    public AnalyzerDoesNotExistException(string message, Exception inner);
    public static AnalyzerDoesNotExistException ThrowFor(string analyzerName);
}
public class Raven.Client.Exceptions.Documents.Attachments.AttachmentDoesNotExistException : RavenException {
    public AttachmentDoesNotExistException(string message);
    public AttachmentDoesNotExistException(string message, Exception inner);
    public static AttachmentDoesNotExistException ThrowFor(string documentId, string attachmentName);
}
public class Raven.Client.Exceptions.Documents.BulkInsert.BulkInsertAbortedException : RavenException {
    public BulkInsertAbortedException(string message);
    public BulkInsertAbortedException(string message, Exception inner);
}
public abstract class Raven.Client.Exceptions.Documents.BulkInsert.BulkInsertClientException : RavenException {
    protected BulkInsertClientException(string message);
    protected BulkInsertClientException(string message, Exception inner);
}
public class Raven.Client.Exceptions.Documents.BulkInsert.BulkInsertInvalidOperationException : BulkInsertClientException {
    public BulkInsertInvalidOperationException(string message);
    public BulkInsertInvalidOperationException(string message, Exception inner);
}
public class Raven.Client.Exceptions.Documents.BulkInsert.BulkInsertProtocolViolationException : RavenException {
    public BulkInsertProtocolViolationException(string message);
    public BulkInsertProtocolViolationException(string message, Exception inner);
}
public class Raven.Client.Exceptions.Documents.Compilation.AnalyzerCompilationException : CompilationException {
    public AnalyzerCompilationException(string message);
    public AnalyzerCompilationException(string message, Exception inner);
    public virtual string ToString();
}
public class Raven.Client.Exceptions.Documents.Compilation.IndexCompilationException : CompilationException {
    public string IndexDefinitionProperty;
    public string ProblematicText;
    public IndexCompilationException(string message);
    public IndexCompilationException(string message, Exception inner);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private void <ToString>b__5_0(StringBuilder description);
}
public class Raven.Client.Exceptions.Documents.Compilation.SorterCompilationException : CompilationException {
    public SorterCompilationException(string message);
    public SorterCompilationException(string message, Exception inner);
    public virtual string ToString();
}
public class Raven.Client.Exceptions.Documents.Counters.CounterOverflowException : RavenException {
    public CounterOverflowException(string message);
    public CounterOverflowException(string message, Exception inner);
    internal static void ThrowFor(string docId, string counterName, long value, long delta, OverflowException inner);
    internal static void ThrowFor(string docId, string counterName, OverflowException inner);
}
public class Raven.Client.Exceptions.Documents.DocumentCollectionMismatchException : RavenException {
    public DocumentCollectionMismatchException(string message);
    public DocumentCollectionMismatchException(string message, Exception inner);
    public static DocumentCollectionMismatchException ThrowFor(string documentId, string oldCollection, string newCollection);
}
public class Raven.Client.Exceptions.Documents.DocumentConflictException : ConflictException {
    [CompilerGeneratedAttribute]
private string <DocId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LargestEtag>k__BackingField;
    public string DocId { get; }
    public long LargestEtag { get; }
    public DocumentConflictException(string message, string docId, long etag);
    public DocumentConflictException(GetConflictsResult conflicts);
    [CompilerGeneratedAttribute]
public string get_DocId();
    [CompilerGeneratedAttribute]
public long get_LargestEtag();
    public static DocumentConflictException From(string message);
    public static DocumentConflictException From(BlittableJsonReaderObject json);
}
public class Raven.Client.Exceptions.Documents.DocumentDoesNotExistException : RavenException {
    public DocumentDoesNotExistException(string id);
    public DocumentDoesNotExistException(string id, string message);
    public DocumentDoesNotExistException(string id, Exception inner);
}
public class Raven.Client.Exceptions.Documents.Indexes.IndexAlreadyExistException : RavenException {
    public IndexAlreadyExistException(string message);
    public IndexAlreadyExistException(string message, Exception inner);
}
internal class Raven.Client.Exceptions.Documents.Indexes.IndexCompactionInProgressException : RavenException {
    public IndexCompactionInProgressException(string message);
    public IndexCompactionInProgressException(string message, Exception inner);
}
public class Raven.Client.Exceptions.Documents.Indexes.IndexCreationException : RavenException {
    public IndexCreationException(string message);
    public IndexCreationException(string message, Exception innerException);
}
public class Raven.Client.Exceptions.Documents.Indexes.IndexDeletionException : RavenException {
    public IndexDeletionException(string message);
    public IndexDeletionException(string message, Exception innerException);
}
public class Raven.Client.Exceptions.Documents.Indexes.IndexDoesNotExistException : RavenException {
    public IndexDoesNotExistException(string message);
    public IndexDoesNotExistException(string message, Exception inner);
    public static IndexDoesNotExistException ThrowFor(string indexName);
    public static IndexDoesNotExistException ThrowForAuto(string indexName);
}
public class Raven.Client.Exceptions.Documents.Indexes.IndexInvalidException : RavenException {
    public IndexInvalidException(Exception e);
    public IndexInvalidException(string message);
    public IndexInvalidException(string message, Exception innerException);
}
public class Raven.Client.Exceptions.Documents.Indexes.PendingRollingIndexException : RavenException {
    public PendingRollingIndexException(string message);
}
public class Raven.Client.Exceptions.Documents.Patching.JavaScriptException : RavenException {
    public JavaScriptException(string message);
    public JavaScriptException(string message, Exception inner);
}
public class Raven.Client.Exceptions.Documents.Patching.JavaScriptParseException : JavaScriptException {
    public JavaScriptParseException(string message);
    public JavaScriptParseException(string message, Exception inner);
}
public class Raven.Client.Exceptions.Documents.Revisions.RevisionsDisabledException : RavenException {
    public RevisionsDisabledException(string message);
}
public class Raven.Client.Exceptions.Documents.Session.NonUniqueObjectException : RavenException {
    public NonUniqueObjectException(string message);
    public NonUniqueObjectException(string message, Exception inner);
}
public class Raven.Client.Exceptions.Documents.Sorters.SorterDoesNotExistException : RavenException {
    public SorterDoesNotExistException(string message);
    public SorterDoesNotExistException(string message, Exception inner);
    public static SorterDoesNotExistException ThrowFor(string sorterName);
}
public class Raven.Client.Exceptions.Documents.Subscriptions.DocumentUnderActiveMigrationException : SubscriptionException {
    public DocumentUnderActiveMigrationException(string message);
    public DocumentUnderActiveMigrationException(string message, Exception inner);
}
public class Raven.Client.Exceptions.Documents.Subscriptions.SubscriberErrorException : SubscriptionException {
    public SubscriberErrorException(string message);
    public SubscriberErrorException(string message, Exception inner);
}
public class Raven.Client.Exceptions.Documents.Subscriptions.SubscriptionChangeVectorUpdateConcurrencyException : SubscriptionException {
    public SubscriptionChangeVectorUpdateConcurrencyException(string message);
}
public class Raven.Client.Exceptions.Documents.Subscriptions.SubscriptionClosedException : SubscriptionException {
    [CompilerGeneratedAttribute]
private bool <CanReconnect>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoDocsLeft>k__BackingField;
    internal bool CanReconnect { get; internal set; }
    internal bool NoDocsLeft { get; internal set; }
    public SubscriptionClosedException(string message);
    public SubscriptionClosedException(string message, bool canReconnect);
    public SubscriptionClosedException(string message, bool canReconnect, bool noDocsLeft);
    public SubscriptionClosedException(string message, Exception inner);
    public SubscriptionClosedException(string message, bool canReconnect, Exception inner);
    public SubscriptionClosedException(string message, bool canReconnect, bool noDocsLeft, Exception inner);
    [CompilerGeneratedAttribute]
internal bool get_CanReconnect();
    [CompilerGeneratedAttribute]
internal void set_CanReconnect(bool value);
    [CompilerGeneratedAttribute]
internal bool get_NoDocsLeft();
    [CompilerGeneratedAttribute]
internal void set_NoDocsLeft(bool value);
}
public class Raven.Client.Exceptions.Documents.Subscriptions.SubscriptionConnectionDownException : SubscriptionException {
    public SubscriptionConnectionDownException(string message);
    public SubscriptionConnectionDownException(string message, Exception inner);
}
public class Raven.Client.Exceptions.Documents.Subscriptions.SubscriptionCreationException : SubscriptionException {
    public SubscriptionCreationException(string message);
    public SubscriptionCreationException(string message, Exception inner);
}
public class Raven.Client.Exceptions.Documents.Subscriptions.SubscriptionDoesNotBelongToNodeException : SubscriptionException {
    public string AppropriateNode;
    internal long Index;
    internal Nullable`1<long> RegisterConnectionDurationInTicks;
    public Dictionary`2<string, string> Reasons;
    public SubscriptionDoesNotBelongToNodeException(string message);
    public SubscriptionDoesNotBelongToNodeException(string message, Exception inner);
    public SubscriptionDoesNotBelongToNodeException(string message, Exception inner, string appropriateNode, Dictionary`2<string, string> reasons);
    internal SubscriptionDoesNotBelongToNodeException(string message, string appropriateNode, Dictionary`2<string, string> reasons, long index);
}
public class Raven.Client.Exceptions.Documents.Subscriptions.SubscriptionDoesNotExistException : SubscriptionException {
    public SubscriptionDoesNotExistException(string message);
    public SubscriptionDoesNotExistException(string message, Exception inner);
}
public abstract class Raven.Client.Exceptions.Documents.Subscriptions.SubscriptionException : RavenException {
    protected SubscriptionException(string message);
    protected SubscriptionException(string message, Exception inner);
}
public class Raven.Client.Exceptions.Documents.Subscriptions.SubscriptionInUseException : SubscriptionException {
    public SubscriptionInUseException(string message);
    public SubscriptionInUseException(string message, Exception inner);
}
public class Raven.Client.Exceptions.Documents.Subscriptions.SubscriptionInvalidStateException : SubscriptionException {
    public SubscriptionInvalidStateException(string message);
    public SubscriptionInvalidStateException(string message, Exception inner);
}
public class Raven.Client.Exceptions.Documents.Subscriptions.SubscriptionMessageTypeException : SubscriptionException {
    public SubscriptionMessageTypeException(string message);
    public SubscriptionMessageTypeException(string message, Exception inner);
}
public class Raven.Client.Exceptions.Documents.Subscriptions.SubscriptionNameException : SubscriptionException {
    public SubscriptionNameException(string message);
    public SubscriptionNameException(string message, Exception inner);
}
internal static class Raven.Client.Exceptions.ExceptionDispatcher : object {
    public static Exception Get(ExceptionSchema schema, HttpStatusCode code, Exception inner);
    public static Exception Get(BlittableJsonReaderObject json, HttpStatusCode code, Exception inner);
    [AsyncStateMachineAttribute("Raven.Client.Exceptions.ExceptionDispatcher/<Throw>d__3")]
public static Task Throw(JsonOperationContext context, HttpResponseMessage response, CommandUnsuccessfulResponseBehavior unsuccessfulResponseBehavior);
    private static void FillException(Exception exception, BlittableJsonReaderObject json);
    private static void ThrowConflict(ExceptionSchema schema, BlittableJsonReaderObject json);
    public static Type GetType(string typeAsString);
    private static ExceptionSchema GetExceptionSchema(HttpStatusCode code, BlittableJsonReaderObject json);
    [AsyncStateMachineAttribute("Raven.Client.Exceptions.ExceptionDispatcher/<GetJson>d__8")]
private static Task`1<BlittableJsonReaderObject> GetJson(JsonOperationContext context, HttpResponseMessage response, Stream stream);
}
public class Raven.Client.Exceptions.InvalidNetworkTopologyException : Exception {
    public InvalidNetworkTopologyException(string message);
    public InvalidNetworkTopologyException(string message, Exception inner);
}
public class Raven.Client.Exceptions.InvalidQueryException : RavenException {
    public InvalidQueryException(string message);
    public InvalidQueryException(string message, Exception inner);
    public InvalidQueryException(string message, string queryText, BlittableJsonReaderObject parameters, Exception e);
    public InvalidQueryException(string message, string queryText, BlittableJsonReaderObject parameters);
    private static string BuildMessage(string message, string queryText, BlittableJsonReaderObject parameters);
}
public class Raven.Client.Exceptions.LegacyReplicationViolationException : Exception {
    public LegacyReplicationViolationException(string message);
    public LegacyReplicationViolationException(string message, Exception inner);
}
public class Raven.Client.Exceptions.RavenException : Exception {
    [CompilerGeneratedAttribute]
private bool <ReachedLeader>k__BackingField;
    public bool ReachedLeader { get; public set; }
    public RavenException(string message);
    public RavenException(string message, Exception inner);
    [CompilerGeneratedAttribute]
public bool get_ReachedLeader();
    [CompilerGeneratedAttribute]
public void set_ReachedLeader(bool value);
    public static RavenException Generic(string error, BlittableJsonReaderObject json);
}
public class Raven.Client.Exceptions.RavenTimeoutException : RavenException {
    public bool FailImmediately;
    public RavenTimeoutException(string message);
    public RavenTimeoutException(string message, Exception inner);
}
public class Raven.Client.Exceptions.ReplicationHubNotFoundException : RavenException {
    public ReplicationHubNotFoundException(string message);
    public ReplicationHubNotFoundException(string message, Exception inner);
}
public class Raven.Client.Exceptions.RequestedNodeUnavailableException : Exception {
    public RequestedNodeUnavailableException(string message);
    public RequestedNodeUnavailableException(string message, Exception innerException);
}
public class Raven.Client.Exceptions.Routing.RouteNotFoundException : RavenException {
    public RouteNotFoundException(string message);
    public RouteNotFoundException(string message, Exception inner);
}
public class Raven.Client.Exceptions.Security.AuthenticationException : SecurityException {
    public AuthenticationException(string message);
    public AuthenticationException(string message, Exception inner);
}
public class Raven.Client.Exceptions.Security.AuthorizationException : SecurityException {
    public AuthorizationException(string message);
    public AuthorizationException(string message, Exception inner);
}
public class Raven.Client.Exceptions.Security.CertificateNameMismatchException : AuthenticationException {
    public CertificateNameMismatchException(string message);
    public CertificateNameMismatchException(string message, Exception inner);
}
public class Raven.Client.Exceptions.Security.InsufficientTransportLayerProtectionException : SecurityException {
    public InsufficientTransportLayerProtectionException(string message);
    public InsufficientTransportLayerProtectionException(string message, Exception inner);
}
public abstract class Raven.Client.Exceptions.Security.SecurityException : RavenException {
    protected SecurityException(string message);
    protected SecurityException(string message, Exception inner);
}
public class Raven.Client.Exceptions.Server.ServerLoadFailureException : RavenException {
    public ServerLoadFailureException(string message);
    public ServerLoadFailureException(string message, Exception e);
}
public class Raven.Client.Exceptions.Sharding.ExecutionForShardException : RavenException {
    public ExecutionForShardException(int shardNumber, Exception inner);
    private static string GetMessage(int shardNumber);
}
public class Raven.Client.Exceptions.Sharding.NotSupportedInShardingException : RavenException {
    public NotSupportedInShardingException(string message);
    public NotSupportedInShardingException(string message, Exception e);
}
public class Raven.Client.Exceptions.Sharding.ShardedBatchBehaviorViolationException : RavenException {
    public ShardedBatchBehaviorViolationException(string message);
    public ShardedBatchBehaviorViolationException(string message, Exception e);
}
public class Raven.Client.Exceptions.Sharding.ShardedPatchBehaviorViolationException : RavenException {
    public ShardedPatchBehaviorViolationException(string message);
    public ShardedPatchBehaviorViolationException(string message, Exception e);
}
public class Raven.Client.Exceptions.Sharding.ShardMismatchException : RavenException {
    public ShardMismatchException(string message);
    public ShardMismatchException(string message, Exception inner);
}
internal class Raven.Client.Exceptions.UnsuccessfulFileAccessException : Exception {
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private FileAccess <AccessType>k__BackingField;
    public string FilePath { get; }
    public FileAccess AccessType { get; }
    public UnsuccessfulFileAccessException(Exception e, string filePath, FileAccess accessType);
    internal static string GetMessage(string filePath, FileAccess accessType, Exception underlyingException);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public FileAccess get_AccessType();
}
public class Raven.Client.Exceptions.UnsuccessfulRequestException : Exception {
    public UnsuccessfulRequestException(string msg);
    public UnsuccessfulRequestException(string msg, Exception exception);
}
[ExtensionAttribute]
internal static class Raven.Client.Extensions.BlittableJsonExtensions : object {
    [ExtensionAttribute]
public static BlittableJsonReaderObject GetMetadata(BlittableJsonReaderObject document);
    [ExtensionAttribute]
public static bool TryGetMetadata(BlittableJsonReaderObject document, BlittableJsonReaderObject& metadata);
    [ExtensionAttribute]
public static bool TryGetProjection(BlittableJsonReaderObject metadata, Boolean& projection);
    [ExtensionAttribute]
public static string GetId(BlittableJsonReaderObject metadata);
    [ExtensionAttribute]
internal static LazyStringValue GetIdAsLazyString(BlittableJsonReaderObject metadata);
    [ExtensionAttribute]
public static bool TryGetId(BlittableJsonReaderObject metadata, String& id);
    [ExtensionAttribute]
public static bool TryGetConflict(BlittableJsonReaderObject metadata, Boolean& conflict);
    [ExtensionAttribute]
public static string GetChangeVector(BlittableJsonReaderObject metadata);
    [ExtensionAttribute]
public static DateTime GetLastModified(BlittableJsonReaderObject metadata);
    [ExtensionAttribute]
public static bool TryGetLastModified(BlittableJsonReaderObject metadata, DateTime& lastModified);
    [ExtensionAttribute]
public static bool TryGetChangeVector(BlittableJsonReaderObject metadata, String& changeVector);
    [ExtensionAttribute]
internal static BlittableJsonReaderObject AddToMetadata(BlittableJsonReaderObject item, JsonOperationContext context, string key, T value);
    private static void InvalidMissingChangeVector();
    private static void InvalidMissingLastModified();
}
[ExtensionAttribute]
internal static class Raven.Client.Extensions.BlittableJsonTextWriterExtensions : object {
    [ExtensionAttribute]
public static void WriteIndexQuery(AbstractBlittableJsonTextWriter writer, DocumentConventions conventions, JsonOperationContext context, IndexQuery`1<T> query);
    [ExtensionAttribute]
public static void WriteSubscriptionUpdateOptions(AbstractBlittableJsonTextWriter writer, SubscriptionUpdateOptions options);
}
[ExtensionAttribute]
internal static class Raven.Client.Extensions.CharExtensions : object {
    [ExtensionAttribute]
public static string ToInvariantString(object obj);
}
[ExtensionAttribute]
internal static class Raven.Client.Extensions.DictionaryExtensions : object {
    [ExtensionAttribute]
public static TVal GetOrDefault(IDictionary`2<TKey, TVal> self, TKey key);
    public static bool ContentEquals(IDictionary`2<TKey, TValue> x, IDictionary`2<TKey, TValue> y);
    [ExtensionAttribute]
public static int GetDictionaryHashCode(IDictionary`2<TKey, TValue> self);
}
[ExtensionAttribute]
internal static class Raven.Client.Extensions.DocumentStoreExtensions : object {
    [ExtensionAttribute]
internal static string GetDatabase(IDocumentStore store, string database);
}
[ExtensionAttribute]
internal static class Raven.Client.Extensions.EnumerableExtension : object {
    [ExtensionAttribute]
public static bool ApplyIfNotNull(IEnumerable`1<T> self, Action`1<T> action);
    public static bool ContentEquals(IEnumerable`1<TValue> x, IEnumerable`1<TValue> y);
    [ExtensionAttribute]
public static IEnumerable`1<T> EmptyIfNull(IEnumerable`1<T> self);
    [ExtensionAttribute]
public static int GetEnumerableHashCode(IEnumerable`1<TKey> self);
    public static bool ElementsEqual(List`1<TValue> list1, List`1<TValue> list2);
    [IteratorStateMachineAttribute("Raven.Client.Extensions.EnumerableExtension/<ForceEnumerateInThreadSafeManner>d__5`2")]
[ExtensionAttribute]
public static IEnumerable`1<KeyValuePair`2<T, S>> ForceEnumerateInThreadSafeManner(ConcurrentDictionary`2<T, S> collection);
}
[ExtensionAttribute]
internal static class Raven.Client.Extensions.ExceptionExtensions : object {
    [ExtensionAttribute]
public static Exception ExtractSingleInnerException(AggregateException e);
    [ExtensionAttribute]
public static Exception ExtractSingleInnerException(Exception e);
    [ExtensionAttribute]
public static string ExceptionToString(Exception ex, Action`1<StringBuilder> customFieldsFormatterAction);
    [ExtensionAttribute]
public static string AllInnerMessages(Exception ex);
}
[ExtensionAttribute]
internal static class Raven.Client.Extensions.ExpressionExtensions : object {
    [ExtensionAttribute]
public static MemberInfo ToProperty(LambdaExpression expr);
    [ExtensionAttribute]
public static string ToPropertyPath(LambdaExpression expr, DocumentConventions conventions, char propertySeparator, string collectionSeparator);
    [ExtensionAttribute]
public static string ToPropertyPath(Expression expression, DocumentConventions conventions, char propertySeparator, string collectionSeparator);
}
[ExtensionAttribute]
internal static class Raven.Client.Extensions.HttpExtensions : object {
    [ExtensionAttribute]
public static string GetRequiredEtagHeader(HttpResponseMessage response);
    [ExtensionAttribute]
public static string GetEtagHeader(HttpResponseMessage response);
    [ExtensionAttribute]
public static string GetEtagHeader(Dictionary`2<string, string> headers);
    [ExtensionAttribute]
public static Nullable`1<bool> GetBoolHeader(HttpResponseMessage response, string header);
    private static string EtagHeaderToChangeVector(string responseHeader);
}
[ExtensionAttribute]
internal static class Raven.Client.Extensions.JsonSerializationExtensions : object {
    [ExtensionAttribute]
public static DynamicJsonValue ToJsonWithPrimitiveKey(IDictionary`2<TKey, TValue> dic);
    [ExtensionAttribute]
public static DynamicJsonValue ToJson(Dictionary`2<string, TValue> dic);
    [ExtensionAttribute]
public static DynamicJsonValue ToJson(Dictionary`2<StringSegment, TValue> dic);
}
[ExtensionAttribute]
internal static class Raven.Client.Extensions.ListExtensions : object {
    [ExtensionAttribute]
public static bool IsNullOrEmpty(List`1<T> list);
}
[ExtensionAttribute]
internal static class Raven.Client.Extensions.MemberInfoExtensions : object {
    [ExtensionAttribute]
public static bool CanWrite(MemberInfo memberInfo);
    [ExtensionAttribute]
public static bool CanRead(MemberInfo memberInfo);
    [ExtensionAttribute]
public static ParameterInfo[] GetIndexParameters(MemberInfo memberInfo);
    [ExtensionAttribute]
public static Type Type(MemberInfo memberInfo);
    [ExtensionAttribute]
public static void SetValue(MemberInfo memberInfo, T& entity, object value);
    private static void SetStructValue(string name, Type type, T& entity, object value);
    [ExtensionAttribute]
public static object GetValue(MemberInfo memberInfo, object entity);
    [ExtensionAttribute]
public static bool IsProperty(MemberInfo memberInfo);
    [ExtensionAttribute]
public static bool IsField(MemberInfo memberInfo);
}
internal class Raven.Client.Extensions.PropertyNameConventionJSMetadataProvider : JavascriptMetadataProvider {
    private DocumentConventions _conventions;
    public PropertyNameConventionJSMetadataProvider(DocumentConventions conventions);
    public virtual IJavascriptMemberMetadata GetMemberMetadata(MemberInfo memberInfo);
}
[ExtensionAttribute]
internal static class Raven.Client.Extensions.ReflectionExtensions : object {
    [ExtensionAttribute]
public static Type GetMemberType(MemberInfo member);
    [ExtensionAttribute]
internal static Type GetElementType(Type seqType);
    [ExtensionAttribute]
public static bool IsNullableType(Type type);
    [ExtensionAttribute]
public static Type GetNonNullableType(Type type);
    private static Type FindIEnumerable(Type seqType);
}
internal static class Raven.Client.Extensions.Streams.BufferSharedPools : object {
    private static int Megabyte;
    private static int Kilobyte;
    public static int HugeByteBufferSize;
    public static int BigByteBufferSize;
    public static int ByteBufferSize;
    public static int SmallByteBufferSize;
    public static int MicroByteBufferSize;
    public static ObjectPool`1<Byte[]> HugeByteArray;
    public static ObjectPool`1<Byte[]> BigByteArray;
    public static ObjectPool`1<Byte[]> ByteArray;
    public static ObjectPool`1<Byte[]> SmallByteArray;
    public static ObjectPool`1<Byte[]> MicroByteArray;
    private static BufferSharedPools();
}
[ExtensionAttribute]
internal static class Raven.Client.Extensions.Streams.StreamExtensions : object {
    [ExtensionAttribute]
public static void Write(Stream stream, int value);
    [ExtensionAttribute]
public static void Write(Stream stream, string value);
    [ExtensionAttribute]
public static void Write(Stream stream, string value, Encoding encoding);
    [ExtensionAttribute]
public static Byte[] ReadData(Stream stream);
    [ExtensionAttribute]
public static Byte[] ReadEntireBlock(Stream stream, int count);
    [ExtensionAttribute]
public static void ReadEntireBlock(Stream stream, Byte[] buffer, int start, int count);
}
[ExtensionAttribute]
internal static class Raven.Client.Extensions.StringExtensions : object {
    private static Char[] LiteralSymbolsToEscape;
    private static String[] LiteralEscapedSymbols;
    private static StringExtensions();
    [ExtensionAttribute]
public static string ToWebSocketPath(string path);
    [ExtensionAttribute]
public static string ToInvariantString(int value);
    [ExtensionAttribute]
public static string ToInvariantString(float value);
    [ExtensionAttribute]
public static string ToInvariantString(double value);
    [ExtensionAttribute]
public static string ToInvariantString(decimal value);
    [ExtensionAttribute]
public static string ToInvariantString(long value);
    public static bool IsIdentifier(string token);
    public static bool IsIdentifier(string token, int start, int length);
    public static void EscapeString(StringBuilder builder, string value);
    private static void EscapeStringInternal(StringBuilder builder, string value);
    public static void EscapeChar(StringBuilder builder, char c);
}
[ExtensionAttribute]
public static class Raven.Client.Extensions.TaskExtensions : object {
    [ExtensionAttribute]
public static Task IgnoreUnobservedExceptions(Task task);
    [ExtensionAttribute]
public static Task AssertNotFailed(Task task);
    [ExtensionAttribute]
public static Task WithCancellation(Task task, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<T> WithCancellation(Task`1<T> task, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Extensions.TaskExtensions/<WaitWithTimeout>d__4")]
[ExtensionAttribute]
public static Task`1<bool> WaitWithTimeout(Task task, Nullable`1<TimeSpan> timeout);
    [AsyncStateMachineAttribute("Raven.Client.Extensions.TaskExtensions/<WaitAndThrowOnTimeout>d__5")]
[ExtensionAttribute]
internal static Task WaitAndThrowOnTimeout(Task task, TimeSpan timeout);
    [ExtensionAttribute]
public static Task`1<T> WithResult(Task task, T result);
    [ExtensionAttribute]
public static Task`1<T> WithResult(Task task, Func`1<T> result);
    [ExtensionAttribute]
public static Task`1<T> WithResult(Task task, Task`1<T> result);
    [ExtensionAttribute]
public static Task`1<T> ContinueWithTask(Task task, Func`1<Task`1<T>> result);
    [ExtensionAttribute]
public static Task ContinueWithTask(Task task, Func`1<Task> result);
}
internal static class Raven.Client.Extensions.WhoIsLocking : object {
    private static int RmRebootReasonNone;
    private static int CCH_RM_MAX_APP_NAME;
    private static int CCH_RM_MAX_SVC_NAME;
    public static string ThisFile(string path);
    public static IList`1<Process> GetProcessesUsingFile(string filePath);
    private static int RmStartSession(UInt32& pSessionHandle, int dwSessionFlags, string strSessionKey);
    private static int RmEndSession(UInt32 pSessionHandle);
    private static int RmRegisterResources(UInt32 pSessionHandle, UInt32 nFiles, String[] rgsFilenames, UInt32 nApplications, RM_UNIQUE_PROCESS[] rgApplications, UInt32 nServices, String[] rgsServiceNames);
    private static int RmGetList(UInt32 dwSessionHandle, UInt32& pnProcInfoNeeded, UInt32& pnProcInfo, RM_PROCESS_INFO[] rgAffectedApps, UInt32& lpdwRebootReasons);
}
public enum Raven.Client.Http.AggressiveCacheMode : Enum {
    public int value__;
    public static AggressiveCacheMode TrackChanges;
    public static AggressiveCacheMode DoNotTrackChanges;
}
public class Raven.Client.Http.AggressiveCacheOptions : object {
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private AggressiveCacheMode <Mode>k__BackingField;
    public TimeSpan Duration { get; public set; }
    public AggressiveCacheMode Mode { get; public set; }
    public AggressiveCacheOptions(TimeSpan duration, AggressiveCacheMode mode);
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public AggressiveCacheMode get_Mode();
    [CompilerGeneratedAttribute]
public void set_Mode(AggressiveCacheMode value);
}
public class Raven.Client.Http.AttachmentStreamContent : HttpContent {
    private Stream _stream;
    private CancellationToken _cancellationToken;
    private static int BufferSize;
    public AttachmentStreamContent(Stream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Raven.Client.Http.AttachmentStreamContent/<SerializeToStreamAsync>d__4")]
protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected virtual bool TryComputeLength(Int64& length);
    protected virtual Task`1<Stream> CreateContentReadStreamAsync();
}
internal abstract class Raven.Client.Http.Behaviors.AbstractCommandResponseBehavior : object {
    public abstract virtual ValueTask HandleNotModifiedAsync(JsonOperationContext context, RavenCommand`1<TResult> command, HttpResponseMessage response, BlittableJsonReaderObject cachedValue);
    public abstract virtual ValueTask`1<bool> TryHandleNotFoundAsync(JsonOperationContext context, RavenCommand`1<TResult> command, HttpResponseMessage response);
    public abstract virtual ValueTask`1<bool> TryHandleConflictAsync(JsonOperationContext context, RavenCommand`1<TResult> command, HttpResponseMessage response);
    public abstract virtual ValueTask`1<bool> TryHandleUnsuccessfulResponseAsync(JsonOperationContext context, RavenCommand`1<TResult> command, HttpResponseMessage response, CommandUnsuccessfulResponseBehavior unsuccessfulResponseBehavior);
}
internal class Raven.Client.Http.Behaviors.DefaultCommandResponseBehavior : AbstractCommandResponseBehavior {
    public static DefaultCommandResponseBehavior Instance;
    private static DefaultCommandResponseBehavior();
    public virtual ValueTask HandleNotModifiedAsync(JsonOperationContext context, RavenCommand`1<TResult> command, HttpResponseMessage response, BlittableJsonReaderObject cachedValue);
    public virtual ValueTask`1<bool> TryHandleNotFoundAsync(JsonOperationContext context, RavenCommand`1<TResult> command, HttpResponseMessage response);
    [AsyncStateMachineAttribute("Raven.Client.Http.Behaviors.DefaultCommandResponseBehavior/<TryHandleConflictAsync>d__4`1")]
public virtual ValueTask`1<bool> TryHandleConflictAsync(JsonOperationContext context, RavenCommand`1<TResult> command, HttpResponseMessage response);
    [AsyncStateMachineAttribute("Raven.Client.Http.Behaviors.DefaultCommandResponseBehavior/<TryHandleUnsuccessfulResponseAsync>d__5`1")]
public virtual ValueTask`1<bool> TryHandleUnsuccessfulResponseAsync(JsonOperationContext context, RavenCommand`1<TResult> command, HttpResponseMessage response, CommandUnsuccessfulResponseBehavior unsuccessfulResponseBehavior);
}
internal class Raven.Client.Http.ClusterRequestExecutor : RequestExecutor {
    private SemaphoreSlim _clusterTopologySemaphore;
    private ClusterRequestExecutor(X509Certificate2 certificate, DocumentConventions conventions, String[] initialUrls);
    [ObsoleteAttribute("Not supported", "True")]
public static ClusterRequestExecutor Create(String[] urls, string databaseName, X509Certificate2 certificate, DocumentConventions conventions, bool userPrivateUrls, bool includePromotables);
    [ObsoleteAttribute("Not supported", "True")]
public static ClusterRequestExecutor CreateForSingleNodeWithConfigurationUpdates(string url, string databaseName, X509Certificate2 certificate, DocumentConventions conventions);
    [ObsoleteAttribute("Not supported", "True")]
public static ClusterRequestExecutor CreateForSingleNodeWithoutConfigurationUpdates(string url, string databaseName, X509Certificate2 certificate, DocumentConventions conventions);
    public static ClusterRequestExecutor CreateForSingleNode(string url, X509Certificate2 certificate, DocumentConventions conventions);
    internal static ClusterRequestExecutor CreateForShortTermUse(string url, X509Certificate2 certificate, DocumentConventions conventions);
    public static ClusterRequestExecutor Create(String[] initialUrls, X509Certificate2 certificate, DocumentConventions conventions);
    protected virtual Task PerformHealthCheck(ServerNode serverNode, int nodeIndex, JsonOperationContext context);
    [AsyncStateMachineAttribute("Raven.Client.Http.ClusterRequestExecutor/<UpdateTopologyAsync>d__9")]
public virtual Task`1<bool> UpdateTopologyAsync(UpdateTopologyParameters parameters);
    protected virtual Task UpdateClientConfigurationAsync(ServerNode serverNode);
    protected virtual void ThrowExceptions(List`1<ValueTuple`2<string, Exception>> list);
    [AsyncStateMachineAttribute("Raven.Client.Http.ClusterRequestExecutor/<TryLoadFromCacheAsync>d__12")]
protected virtual Task`1<bool> TryLoadFromCacheAsync(JsonOperationContext context);
}
public class Raven.Client.Http.ClusterTopology : object {
    [CompilerGeneratedAttribute]
private string <LastNodeId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TopologyId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Members>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Promotables>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Watchers>k__BackingField;
    public Dictionary`2<string, string> AllNodes { get; }
    public string LastNodeId { get; private set; }
    public string TopologyId { get; private set; }
    public long Etag { get; private set; }
    public Dictionary`2<string, string> Members { get; private set; }
    public Dictionary`2<string, string> Promotables { get; private set; }
    public Dictionary`2<string, string> Watchers { get; private set; }
    [JsonIgnoreAttribute]
internal int Count { get; }
    public ClusterTopology(string topologyId, Dictionary`2<string, string> members, Dictionary`2<string, string> promotables, Dictionary`2<string, string> watchers, string lastNodeId, long index);
    internal void ReplaceCurrentNodeUrlWithClientRequestedUrl(string currentNodeTag, string clientRequestedUrl);
    internal Role GetServerRoleForTag(string nodeTag);
    public bool Contains(string node);
    public ValueTuple`2<bool, string> TryGetNodeTagByUrl(string nodeUrl);
    public DynamicJsonValue ToSortedJson();
    public DynamicJsonValue ToJson();
    public string GetUrlFromTag(string tag);
    public static ValueTuple`2<Dictionary`2<TKey, TValue>, Dictionary`2<TKey, TValue>> DictionaryDiff(Dictionary`2<TKey, TValue> oldDic, Dictionary`2<TKey, TValue> newDic);
    public Dictionary`2<string, string> get_AllNodes();
    [CompilerGeneratedAttribute]
public string get_LastNodeId();
    [CompilerGeneratedAttribute]
private void set_LastNodeId(string value);
    [CompilerGeneratedAttribute]
public string get_TopologyId();
    [CompilerGeneratedAttribute]
private void set_TopologyId(string value);
    [CompilerGeneratedAttribute]
public long get_Etag();
    [CompilerGeneratedAttribute]
private void set_Etag(long value);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Members();
    [CompilerGeneratedAttribute]
private void set_Members(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Promotables();
    [CompilerGeneratedAttribute]
private void set_Promotables(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Watchers();
    [CompilerGeneratedAttribute]
private void set_Watchers(Dictionary`2<string, string> value);
    internal int get_Count();
}
internal static class Raven.Client.Http.ClusterTopologyLocalCache : object {
    private static Logger _logger;
    private static ClusterTopologyLocalCache();
    private static void Clear(string path);
    private static string GetPath(string topologyHash, DocumentConventions conventions);
    [AsyncStateMachineAttribute("Raven.Client.Http.ClusterTopologyLocalCache/<TryLoadAsync>d__3")]
public static Task`1<ClusterTopologyResponse> TryLoadAsync(string topologyHash, DocumentConventions conventions, JsonOperationContext context);
    [AsyncStateMachineAttribute("Raven.Client.Http.ClusterTopologyLocalCache/<TrySavingAsync>d__4")]
public static Task TrySavingAsync(string topologyHash, ClusterTopologyResponse clusterTopology, DocumentConventions conventions, JsonOperationContext context, CancellationToken token);
}
public class Raven.Client.Http.ClusterTopologyResponse : object {
    public string Leader;
    public string NodeTag;
    public Role ServerRole;
    public ClusterTopology Topology;
    public long Etag;
    public Dictionary`2<string, NodeStatus> Status;
}
internal static class Raven.Client.Http.DatabaseTopologyLocalCache : object {
    private static Logger _logger;
    private static DatabaseTopologyLocalCache();
    private static void Clear(string path);
    private static string GetPath(string databaseName, string topologyHash, DocumentConventions conventions);
    public static Task`1<Topology> TryLoadAsync(string databaseName, string topologyHash, DocumentConventions conventions, JsonOperationContext context);
    [AsyncStateMachineAttribute("Raven.Client.Http.DatabaseTopologyLocalCache/<TryLoadAsync>d__4")]
private static Task`1<Topology> TryLoadAsync(string path, JsonOperationContext context);
    [AsyncStateMachineAttribute("Raven.Client.Http.DatabaseTopologyLocalCache/<TrySavingAsync>d__5")]
public static Task TrySavingAsync(string databaseName, string topologyHash, Topology topology, DocumentConventions conventions, JsonOperationContext context, CancellationToken token);
    private static void WriteNode(AsyncBlittableJsonTextWriter writer, ServerNode node, JsonOperationContext context);
}
public class Raven.Client.Http.HttpCache : object {
    internal static string NotFoundResponse;
    private static Logger Logger;
    private long _maxSize;
    private ConcurrentDictionary`2<string, HttpCacheItem> _items;
    private long _totalSize;
    private UnmanagedBuffersPool _unmanagedBuffersPool;
    private MultipleUseFlag _isFreeSpaceRunning;
    public int Generation;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _disposing;
    private TestingStuff _forTestingPurposes;
    public int NumberOfItems { get; }
    public HttpCache(long maxSize);
    private static HttpCache();
    public int get_NumberOfItems();
    public void Set(string url, string changeVector, BlittableJsonReaderObject result);
    public void SetNotFound(string url, bool aggressivelyCached);
    internal void FreeSpace();
    public ReleaseCacheItem Get(JsonOperationContext context, string url, String& changeVector, BlittableJsonReaderObject& obj);
    public void Clear();
    public sealed virtual void Dispose();
    public sealed virtual void LowMemory(LowMemorySeverity lowMemorySeverity);
    public sealed virtual void LowMemoryOver();
    internal TestingStuff ForTestingPurposesOnly();
}
public enum Raven.Client.Http.HttpCompressionAlgorithm : Enum {
    public int value__;
    public static HttpCompressionAlgorithm Gzip;
}
[ExtensionAttribute]
internal static class Raven.Client.Http.HttpCompressionAlgorithmExtensions : object {
    [ExtensionAttribute]
internal static string GetContentEncoding(HttpCompressionAlgorithm compressionAlgorithm);
    [AsyncStateMachineAttribute("Raven.Client.Http.HttpCompressionAlgorithmExtensions/<ReadAsStringWithZstdSupportAsync>d__1")]
[ExtensionAttribute]
internal static Task`1<string> ReadAsStringWithZstdSupportAsync(HttpContent httpContent, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Raven.Client.Http.HttpCompressionAlgorithmExtensions/<ReadAsStreamWithZstdSupportAsync>d__2")]
[ExtensionAttribute]
internal static Task`1<Stream> ReadAsStreamWithZstdSupportAsync(HttpContent httpContent);
}
public interface Raven.Client.Http.IBroadcast {
    public abstract virtual IBroadcast PrepareToBroadcast(JsonOperationContext context, DocumentConventions conventions);
}
public interface Raven.Client.Http.IRaftCommand {
    public string RaftUniqueRequestId { get; }
    public abstract virtual string get_RaftUniqueRequestId();
}
public enum Raven.Client.Http.LoadBalanceBehavior : Enum {
    public int value__;
    public static LoadBalanceBehavior None;
    public static LoadBalanceBehavior UseSessionContext;
}
public class Raven.Client.Http.NodeSelector : object {
    private Timer _updateFastestNodeTimer;
    internal NodeSelectorState _state;
    private object _timerCreationLocker;
    public Topology Topology { get; }
    internal Int32[] NodeSelectorFailures { get; }
    public bool InSpeedTestPhase { get; }
    public NodeSelector(Topology topology);
    public Topology get_Topology();
    public void OnFailedRequest(int nodeIndex);
    public bool OnUpdateTopology(Topology topology, bool forceUpdate);
    internal ValueTuple`2<int, ServerNode> GetRequestedNode(string nodeTag);
    internal bool NodeIsAvailable(int index);
    public ValueTuple`2<int, ServerNode> GetPreferredNode();
    private static ValueTuple`2<int, ServerNode> GetPreferredNodeInternal(NodeSelectorState state);
    internal Int32[] get_NodeSelectorFailures();
    private static ValueTuple`2<int, ServerNode> UnlikelyEveryoneFaultedChoice(NodeSelectorState state);
    public ValueTuple`2<int, ServerNode> GetNodeBySessionId(int sessionId);
    public ValueTuple`2<int, ServerNode> GetFastestNode();
    public void RestoreNodeIndex(ServerNode node);
    private void SwitchToSpeedTestPhase(object _);
    public bool get_InSpeedTestPhase();
    public void RecordFastest(int index, ServerNode node);
    private static int FindMaxIndex(NodeSelectorState state);
    private void SelectFastest(NodeSelectorState state, int index);
    public void ScheduleSpeedTest();
    public sealed virtual void Dispose();
}
public class Raven.Client.Http.NodeStatus : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Connected>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorDetails>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastSent>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastReply>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastSentMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastMatchingIndex>k__BackingField;
    public string Name { get; public set; }
    public bool Connected { get; public set; }
    public string ErrorDetails { get; public set; }
    public DateTime LastSent { get; public set; }
    public DateTime LastReply { get; public set; }
    public string LastSentMessage { get; public set; }
    public long LastMatchingIndex { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_Connected();
    [CompilerGeneratedAttribute]
public void set_Connected(bool value);
    [CompilerGeneratedAttribute]
public string get_ErrorDetails();
    [CompilerGeneratedAttribute]
public void set_ErrorDetails(string value);
    [CompilerGeneratedAttribute]
public DateTime get_LastSent();
    [CompilerGeneratedAttribute]
public void set_LastSent(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_LastReply();
    [CompilerGeneratedAttribute]
public void set_LastReply(DateTime value);
    [CompilerGeneratedAttribute]
public string get_LastSentMessage();
    [CompilerGeneratedAttribute]
public void set_LastSentMessage(string value);
    [CompilerGeneratedAttribute]
public long get_LastMatchingIndex();
    [CompilerGeneratedAttribute]
public void set_LastMatchingIndex(long value);
    public sealed virtual DynamicJsonValue ToJson();
    public virtual string ToString();
}
public abstract class Raven.Client.Http.RavenCommand : RavenCommand`1<object> {
    [CompilerGeneratedAttribute]
private bool <IsReadRequest>k__BackingField;
    public bool IsReadRequest { get; }
    protected RavenCommand(RavenCommand copy);
    [CompilerGeneratedAttribute]
public virtual bool get_IsReadRequest();
}
public abstract class Raven.Client.Http.RavenCommand`1 : object {
    public CancellationToken CancellationToken;
    public Dictionary`2<ServerNode, Exception> FailedNodes;
    public TResult Result;
    public HttpStatusCode StatusCode;
    [CompilerGeneratedAttribute]
private RavenCommandResponseType <ResponseType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <Timeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanCache>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanCacheAggressively>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanReadFromCache>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SelectedNodeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <SelectedShardNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfAttempts>k__BackingField;
    internal long FailoverTopologyEtag;
    internal string Etag;
    internal Action`1<HttpRequestMessage> ModifyRequest;
    internal Func`2<string, string> ModifyUrl;
    internal AbstractCommandResponseBehavior ResponseBehavior;
    public bool IsReadRequest { get; }
    public RavenCommandResponseType ResponseType { get; protected internal set; }
    public Nullable`1<TimeSpan> Timeout { get; protected internal set; }
    public bool CanCache { get; protected internal set; }
    public bool CanCacheAggressively { get; protected internal set; }
    internal bool CanReadFromCache { get; internal set; }
    public string SelectedNodeTag { get; protected internal set; }
    internal Nullable`1<int> SelectedShardNumber { get; internal set; }
    public int NumberOfAttempts { get; internal set; }
    protected RavenCommand`1(RavenCommand`1<TResult> copy);
    public abstract virtual bool get_IsReadRequest();
    [CompilerGeneratedAttribute]
public virtual RavenCommandResponseType get_ResponseType();
    [CompilerGeneratedAttribute]
protected internal virtual void set_ResponseType(RavenCommandResponseType value);
    [CompilerGeneratedAttribute]
public virtual Nullable`1<TimeSpan> get_Timeout();
    [CompilerGeneratedAttribute]
protected internal virtual void set_Timeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public virtual bool get_CanCache();
    [CompilerGeneratedAttribute]
protected internal virtual void set_CanCache(bool value);
    [CompilerGeneratedAttribute]
public virtual bool get_CanCacheAggressively();
    [CompilerGeneratedAttribute]
protected internal virtual void set_CanCacheAggressively(bool value);
    [CompilerGeneratedAttribute]
internal virtual bool get_CanReadFromCache();
    [CompilerGeneratedAttribute]
internal virtual void set_CanReadFromCache(bool value);
    [CompilerGeneratedAttribute]
public virtual string get_SelectedNodeTag();
    [CompilerGeneratedAttribute]
protected internal virtual void set_SelectedNodeTag(string value);
    [CompilerGeneratedAttribute]
internal virtual Nullable`1<int> get_SelectedShardNumber();
    [CompilerGeneratedAttribute]
internal virtual void set_SelectedShardNumber(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public int get_NumberOfAttempts();
    [CompilerGeneratedAttribute]
internal void set_NumberOfAttempts(int value);
    public abstract virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    [AsyncStateMachineAttribute("Raven.Client.Http.RavenCommand`1/<SendAsync>d__47")]
public virtual Task`1<HttpResponseMessage> SendAsync(HttpClient client, HttpRequestMessage request, CancellationToken token);
    public virtual void SetResponseRaw(HttpResponseMessage response, Stream stream, JsonOperationContext context);
    protected string UrlEncode(string value);
    public static void EnsureIsNotNullOrEmpty(string value, string name);
    public bool IsFailedWithNode(ServerNode node);
    [AsyncStateMachineAttribute("Raven.Client.Http.RavenCommand`1/<ProcessResponse>d__52")]
public virtual Task`1<ResponseDisposeHandling> ProcessResponse(JsonOperationContext context, HttpCache cache, HttpResponseMessage response, string url);
    protected void CacheResponse(HttpCache cache, string url, HttpResponseMessage response, BlittableJsonReaderObject responseJson);
    protected static void ThrowInvalidResponse();
    protected static void ThrowInvalidJsonResponse(PeepingTomStream peepingTomStream);
    protected void AddChangeVectorIfNotNull(string changeVector, HttpRequestMessage request);
    public virtual void OnResponseFailure(HttpResponseMessage response);
    internal void SetTimeout(TimeSpan timeout);
}
public enum Raven.Client.Http.RavenCommandResponseType : Enum {
    public int value__;
    public static RavenCommandResponseType Empty;
    public static RavenCommandResponseType Object;
    public static RavenCommandResponseType Raw;
}
public enum Raven.Client.Http.ReadBalanceBehavior : Enum {
    public int value__;
    public static ReadBalanceBehavior None;
    public static ReadBalanceBehavior RoundRobin;
    public static ReadBalanceBehavior FastestNode;
}
public class Raven.Client.Http.RequestExecutor : object {
    private static int DefaultConnectionLimit;
    private static Guid GlobalApplicationIdentifier;
    private static TimeSpan MinHttpClientLifetime;
    private static int InitialTopologyEtag;
    internal TimeSpan GlobalHttpClientTimeout;
    private static ConcurrentDictionary`2<HttpClientCacheKey, Lazy`1<HttpClientCacheItem>> GlobalHttpClientCache;
    private static GetStatisticsOperation BackwardCompatibilityFailureCheckOperation;
    private static DatabaseHealthCheckOperation FailureCheckOperation;
    private static ConcurrentSet`1<string> _useOldFailureCheckOperation;
    private SemaphoreSlim _updateDatabaseTopologySemaphore;
    private SemaphoreSlim _updateClientConfigurationSemaphore;
    private ConcurrentDictionary`2<ServerNode, Lazy`1<NodeStatus>> _failedNodesTimers;
    private AsyncLocal`1<RequestContext> _requestContexts;
    private ReturnContext _doNotClearContext;
    private ReturnContext _clearContext;
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    private string _databaseName;
    private static Logger Logger;
    public JsonContextPool ContextPool;
    public AsyncLocal`1<AggressiveCacheOptions> AggressiveCaching;
    public HttpCache Cache;
    private ServerNode _topologyTakenFromNode;
    [CompilerGeneratedAttribute]
private string <LastServerVersion>k__BackingField;
    private HttpClient _httpClient;
    private WeakReferencingTimer _updateTopologyTimer;
    protected internal NodeSelector _nodeSelector;
    private Nullable`1<TimeSpan> _defaultTimeout;
    public long NumberOfServerRequests;
    protected string TopologyHash;
    [CompilerGeneratedAttribute]
private long <TopologyEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ClientConfigurationEtag>k__BackingField;
    public DocumentConventions Conventions;
    protected bool _disableTopologyUpdates;
    protected bool _disableClientConfigurationUpdates;
    protected string _topologyHeaderName;
    private bool _usePrivateUrls;
    private bool _includePromotables;
    private CommandUnsuccessfulResponseBehavior _commandUnsuccessfulResponseBehavior;
    private TimeSpan _secondBroadcastAttemptTimeout;
    private TimeSpan _firstBroadcastAttemptTimeout;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ValueTuple`2<long, ClientConfiguration>> ClientConfigurationChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<FailedRequestEventArgs> _onFailedRequest;
    [CompilerGeneratedAttribute]
private EventHandler`1<BeforeRequestEventArgs> OnBeforeRequest;
    [CompilerGeneratedAttribute]
private EventHandler`1<SucceedRequestEventArgs> OnSucceedRequest;
    [CompilerGeneratedAttribute]
private EventHandler`1<TopologyUpdatedEventArgs> _onTopologyUpdated;
    private static Exception ServerCertificateCustomValidationCallbackRegistrationException;
    internal static Task`1<HttpRequestMessage> NeverEndingRequest;
    private string _localClientVersion;
    public static string ClientVersion;
    protected Task _firstTopologyUpdate;
    protected String[] _lastKnownUrls;
    private DisposeOnce`1<ExceptionRetry> _disposeOnceRunner;
    private static ConcurrentSet`1<string> UpdatedConnectionLimitUrls;
    private static RemoteCertificateValidationCallback[] _serverCertificateCustomValidationCallback;
    private static object _locker;
    internal TestingStuff ForTestingPurposes;
    public X509Certificate2 Certificate { get; }
    public Topology Topology { get; }
    internal string LastServerVersion { get; private set; }
    public HttpClient HttpClient { get; }
    public IReadOnlyList`1<ServerNode> TopologyNodes { get; }
    public string Url { get; }
    public long TopologyEtag { get; protected set; }
    public long ClientConfigurationEtag { get; internal set; }
    public Nullable`1<TimeSpan> DefaultTimeout { get; public set; }
    public TimeSpan SecondBroadcastAttemptTimeout { get; public set; }
    public TimeSpan FirstBroadcastAttemptTimeout { get; public set; }
    public bool InSpeedTestPhase { get; }
    internal bool Disposed { get; }
    public static bool HasServerCertificateCustomValidationCallback { get; }
    private static RequestExecutor();
    protected RequestExecutor(string databaseName, X509Certificate2 certificate, DocumentConventions conventions, String[] initialUrls);
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    public Topology get_Topology();
    [CompilerGeneratedAttribute]
internal string get_LastServerVersion();
    [CompilerGeneratedAttribute]
private void set_LastServerVersion(string value);
    public HttpClient get_HttpClient();
    public IReadOnlyList`1<ServerNode> get_TopologyNodes();
    public string get_Url();
    [CompilerGeneratedAttribute]
public long get_TopologyEtag();
    [CompilerGeneratedAttribute]
protected void set_TopologyEtag(long value);
    [CompilerGeneratedAttribute]
public long get_ClientConfigurationEtag();
    [CompilerGeneratedAttribute]
internal void set_ClientConfigurationEtag(long value);
    public Nullable`1<TimeSpan> get_DefaultTimeout();
    public void set_DefaultTimeout(Nullable`1<TimeSpan> value);
    public TimeSpan get_SecondBroadcastAttemptTimeout();
    public void set_SecondBroadcastAttemptTimeout(TimeSpan value);
    public TimeSpan get_FirstBroadcastAttemptTimeout();
    public void set_FirstBroadcastAttemptTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public void add_ClientConfigurationChanged(EventHandler`1<ValueTuple`2<long, ClientConfiguration>> value);
    [CompilerGeneratedAttribute]
public void remove_ClientConfigurationChanged(EventHandler`1<ValueTuple`2<long, ClientConfiguration>> value);
    [CompilerGeneratedAttribute]
private void add__onFailedRequest(EventHandler`1<FailedRequestEventArgs> value);
    [CompilerGeneratedAttribute]
private void remove__onFailedRequest(EventHandler`1<FailedRequestEventArgs> value);
    public void add_OnFailedRequest(EventHandler`1<FailedRequestEventArgs> value);
    public void remove_OnFailedRequest(EventHandler`1<FailedRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OnBeforeRequest(EventHandler`1<BeforeRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnBeforeRequest(EventHandler`1<BeforeRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OnSucceedRequest(EventHandler`1<SucceedRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnSucceedRequest(EventHandler`1<SucceedRequestEventArgs> value);
    private void OnFailedRequestInvoke(string url, Exception e, HttpResponseMessage response, HttpRequestMessage request);
    [CompilerGeneratedAttribute]
private void add__onTopologyUpdated(EventHandler`1<TopologyUpdatedEventArgs> value);
    [CompilerGeneratedAttribute]
private void remove__onTopologyUpdated(EventHandler`1<TopologyUpdatedEventArgs> value);
    public void add_OnTopologyUpdated(EventHandler`1<TopologyUpdatedEventArgs> value);
    public void remove_OnTopologyUpdated(EventHandler`1<TopologyUpdatedEventArgs> value);
    internal void OnTopologyUpdatedInvoke(Topology newTopology, string reason);
    private HttpClient GetHttpClient();
    internal bool TryRemoveHttpClient(bool force);
    private HttpClientCacheKey GetHttpClientCacheKey();
    internal static void ClearHttpClientsPool();
    private static bool ShouldRemoveHttpClient(SocketException exception);
    protected virtual override void Finalize();
    public static RequestExecutor Create(String[] initialUrls, string databaseName, X509Certificate2 certificate, DocumentConventions conventions, bool usePrivateUrls, bool includePromotables);
    internal static RequestExecutor CreateForServer(String[] initialUrls, string databaseName, X509Certificate2 certificate, DocumentConventions conventions, bool usePrivateUrls, bool includePromotables);
    internal static RequestExecutor CreateForProxy(String[] initialUrls, string databaseName, X509Certificate2 certificate, DocumentConventions conventions, bool usePrivateUrls);
    internal static RequestExecutor CreateForShard(String[] initialUrls, string databaseName, X509Certificate2 certificate, DocumentConventions conventions);
    public static RequestExecutor CreateForSingleNodeWithConfigurationUpdates(string url, string databaseName, X509Certificate2 certificate, DocumentConventions conventions);
    public static RequestExecutor CreateForSingleNodeWithoutConfigurationUpdates(string url, string databaseName, X509Certificate2 certificate, DocumentConventions conventions);
    internal static RequestExecutor CreateForShortTermUse(String[] initialUrls, string databaseName, X509Certificate2 certificate, DocumentConventions conventions);
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<UpdateClientConfigurationAsync>d__107")]
protected virtual Task UpdateClientConfigurationAsync(ServerNode serverNode);
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<UpdateTopologyAsync>d__108")]
public virtual Task`1<bool> UpdateTopologyAsync(UpdateTopologyParameters parameters);
    protected void UpdateNodeSelector(Topology topology, bool forceUpdate);
    protected void DisposeAllFailedNodesTimers();
    public void Execute(RavenCommand`1<TResult> command, JsonOperationContext context, SessionInfo sessionInfo);
    public Task ExecuteAsync(RavenCommand`1<TResult> command, JsonOperationContext context, SessionInfo sessionInfo, CancellationToken token);
    public ValueTuple`2<Nullable`1<int>, ServerNode> ChooseNodeForRequest(RavenCommand`1<TResult> cmd, SessionInfo sessionInfo);
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<UnlikelyExecuteAsync>d__114`1")]
private Task UnlikelyExecuteAsync(RavenCommand`1<TResult> command, JsonOperationContext context, Task topologyUpdate, SessionInfo sessionInfo, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<WaitForTopologyUpdate>d__115")]
private Task WaitForTopologyUpdate(Task topologyUpdate);
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<UpdateTopologyCallback>d__116")]
internal static void UpdateTopologyCallback(object state);
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<SingleTopologyUpdateAsync>d__117")]
protected Task SingleTopologyUpdateAsync(String[] initialUrls, Nullable`1<Guid> applicationIdentifier);
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<FirstTopologyUpdate>d__118")]
protected Task FirstTopologyUpdate(String[] initialUrls, Nullable`1<Guid> applicationIdentifier);
    private void SetupNodeSelectorOnFailure(String[] initialUrls);
    protected virtual void ThrowExceptions(List`1<ValueTuple`2<string, Exception>> list);
    internal static String[] ValidateUrls(String[] initialUrls, X509Certificate2 certificate);
    private void InitializeUpdateTopologyTimer();
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<TryLoadFromCacheAsync>d__123")]
protected virtual Task`1<bool> TryLoadFromCacheAsync(JsonOperationContext context);
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<ExecuteAsync>d__124`1")]
public Task ExecuteAsync(ServerNode chosenNode, Nullable`1<int> nodeIndex, JsonOperationContext context, RavenCommand`1<TResult> command, bool shouldRetry, SessionInfo sessionInfo, CancellationToken token);
    private Task RefreshIfNeeded(ServerNode chosenNode, HttpResponseMessage response);
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<SendRequestToServer>d__126`1")]
private Task`1<HttpResponseMessage> SendRequestToServer(ServerNode chosenNode, Nullable`1<int> nodeIndex, JsonOperationContext context, RavenCommand`1<TResult> command, bool shouldRetry, SessionInfo sessionInfo, HttpRequestMessage request, string url, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<SendAsync>d__127`1")]
private Task`1<HttpResponseMessage> SendAsync(ServerNode chosenNode, RavenCommand`1<TResult> command, SessionInfo sessionInfo, HttpRequestMessage request, CancellationToken token);
    private void SetRequestHeaders(SessionInfo sessionInfo, string cachedChangeVector, HttpRequestMessage request);
    private bool TryGetFromCache(JsonOperationContext context, RavenCommand`1<TResult> command, ReleaseCacheItem cachedItem, BlittableJsonReaderObject cachedValue);
    private IDisposable GetContext(RequestContext& context);
    private static bool TryGetServerVersion(HttpResponseMessage response, String& version);
    private void ThrowFailedToContactAllNodes(RavenCommand`1<TResult> command, HttpRequestMessage request);
    private static void ThrowInvalidConcurrentSessionUsage(string command, SessionInfo sessionInfo);
    public bool get_InSpeedTestPhase();
    private bool ShouldExecuteOnAll(ServerNode chosenNode, RavenCommand`1<TResult> command);
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<ExecuteOnAllToFigureOutTheFastest>d__138`1")]
private Task ExecuteOnAllToFigureOutTheFastest(ServerNode chosenNode, RavenCommand`1<TResult> command, Task`1<HttpResponseMessage> preferredTask, CancellationToken token);
    private void ThrowTimeoutTooLarge(Nullable`1<TimeSpan> timeout);
    private ReleaseCacheItem GetFromCache(JsonOperationContext context, RavenCommand`1<TResult> command, bool useCache, string url, String& cachedChangeVector, BlittableJsonReaderObject& cachedValue);
    internal IDisposable UsingClientVersion(string clientVersion);
    internal HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, RavenCommand`1<TResult> command, String& url);
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<HandleUnsuccessfulResponse>d__145`1")]
private ValueTask`1<bool> HandleUnsuccessfulResponse(ServerNode chosenNode, Nullable`1<int> nodeIndex, JsonOperationContext context, RavenCommand`1<TResult> command, HttpRequestMessage request, HttpResponseMessage response, string url, SessionInfo sessionInfo, bool shouldRetry, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<TryGetResponseOfError>d__146")]
private static Task`1<string> TryGetResponseOfError(HttpResponseMessage response);
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<ReadAsStreamUncompressedAsync>d__147")]
public static Task`1<Stream> ReadAsStreamUncompressedAsync(HttpResponseMessage response);
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<HandleServerDown>d__148`1")]
private Task`1<bool> HandleServerDown(string url, ServerNode chosenNode, Nullable`1<int> nodeIndex, JsonOperationContext context, RavenCommand`1<TResult> command, HttpRequestMessage request, HttpResponseMessage response, Exception e, SessionInfo sessionInfo, bool shouldRetry, RequestContext requestContext, CancellationToken token);
    private bool ShouldBroadcast(RavenCommand`1<TResult> command);
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<Broadcast>d__151`1")]
internal Task`1<TResult> Broadcast(RavenCommand`1<TResult> command, SessionInfo sessionInfo, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<WaitForBroadcastResult>d__152`1")]
private Task`1<TResult> WaitForBroadcastResult(RavenCommand`1<TResult> command, Dictionary`2<Task, BroadcastState`1<TResult>> tasks, CancellationTokenSource broadcastCts);
    private void SendToAllNodes(Dictionary`2<Task, BroadcastState`1<TResult>> tasks, SessionInfo sessionInfo, IBroadcast command, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<HandleServerNotResponsive>d__154")]
public Task`1<ServerNode> HandleServerNotResponsive(string url, ServerNode chosenNode, int nodeIndex, Exception e);
    private void SpawnHealthChecks(ServerNode chosenNode);
    internal Task CheckNodeStatusNow(string tag);
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<CheckNodeStatusCallback>d__157")]
private Task CheckNodeStatusCallback(NodeStatus nodeStatus);
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<PerformHealthCheck>d__158")]
protected virtual Task PerformHealthCheck(ServerNode serverNode, int nodeIndex);
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<PerformHealthCheck>d__159")]
protected virtual Task PerformHealthCheck(ServerNode serverNode, int nodeIndex, JsonOperationContext context);
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<ReadExceptionFromServer>d__160")]
private static Task`1<Exception> ReadExceptionFromServer(JsonOperationContext context, HttpRequestMessage request, HttpResponseMessage response, Exception e);
    internal bool get_Disposed();
    public static bool get_HasServerCertificateCustomValidationCallback();
    public virtual void Dispose();
    public static HttpClientHandler CreateHttpMessageHandler(X509Certificate2 certificate, bool setSslProtocols, bool useHttpDecompression, bool hasExplicitlySetDecompressionUsage, Nullable`1<TimeSpan> pooledConnectionLifetime, Nullable`1<TimeSpan> pooledConnectionIdleTimeout);
    public HttpClient CreateClient();
    private static void ValidateClientKeyUsages(X509Certificate2 certificate);
    private static void UpdateConnectionLimit(IEnumerable`1<string> urls);
    public static void add_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value);
    public static void remove_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value);
    private static void ThrowRemoteCertificateValidationCallbackRegistrationException();
    internal static bool OnServerCertificateCustomValidationCallback(object sender, X509Certificate cert, X509Chain chain, SslPolicyErrors errors);
    private static void ThrowCertificateNameMismatchException(object sender, X509Certificate cert);
    public static string ConvertSenderObjectToHostname(object sender);
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<GetRequestedNode>d__184")]
public Task`1<ValueTuple`2<int, ServerNode>> GetRequestedNode(string nodeTag);
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<GetRequestedNode>d__185")]
internal Task`1<ValueTuple`2<int, ServerNode>> GetRequestedNode(string nodeTag, bool throwIfContainsFailures);
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<GetPreferredNode>d__186")]
public Task`1<ValueTuple`2<int, ServerNode>> GetPreferredNode();
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<GetNodeBySessionId>d__187")]
public Task`1<ValueTuple`2<int, ServerNode>> GetNodeBySessionId(int sessionId);
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<GetFastestNode>d__188")]
public Task`1<ValueTuple`2<int, ServerNode>> GetFastestNode();
    [AsyncStateMachineAttribute("Raven.Client.Http.RequestExecutor/<EnsureNodeSelector>d__189")]
internal Task EnsureNodeSelector();
    private static void ThrowIfClientException(Exception e);
    internal TestingStuff ForTestingPurposesOnly();
    [CompilerGeneratedAttribute]
private HttpClientCacheItem <GetHttpClient>b__91_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__98_0();
    [CompilerGeneratedAttribute]
private ServerNode <SetupNodeSelectorOnFailure>b__119_0(string url);
    [CompilerGeneratedAttribute]
private void <UsingClientVersion>b__142_0();
    [CompilerGeneratedAttribute]
internal static string <CreateRequest>g__AppendToQuery|144_0(string query, string key, string value);
    [CompilerGeneratedAttribute]
private Task <PerformHealthCheck>g__ExecuteOldHealthCheck|159_0(<>c__DisplayClass159_0& );
}
public enum Raven.Client.Http.ResponseDisposeHandling : Enum {
    public int value__;
    public static ResponseDisposeHandling Manually;
    public static ResponseDisposeHandling Automatic;
}
public class Raven.Client.Http.ServerNode : object {
    private static int EmptyStringHash;
    public string Url;
    public string Database;
    public string ClusterTag;
    public Role ServerRole;
    private int _lastServerVersionCheck;
    [CompilerGeneratedAttribute]
private string <LastServerVersion>k__BackingField;
    private Nullable`1<bool> _supportsAtomicClusterWrites;
    public string LastServerVersion { get; private set; }
    public string ServerVersion { get; private set; }
    internal bool SupportsAtomicClusterWrites { get; }
    private static ServerNode();
    private bool Equals(ServerNode other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public string get_LastServerVersion();
    [CompilerGeneratedAttribute]
private void set_LastServerVersion(string value);
    public string get_ServerVersion();
    private void set_ServerVersion(string value);
    internal bool get_SupportsAtomicClusterWrites();
    public bool ShouldUpdateServerVersion();
    public void UpdateServerVersion(string serverVersion);
    public void DiscardServerVersion();
    internal static Topology CreateFrom(ClusterTopology topology, long etag);
    public virtual string ToString();
}
public class Raven.Client.Http.Topology : object {
    public long Etag;
    public List`1<ServerNode> Nodes;
    public List`1<ServerNode> Promotables;
    public virtual string ToString();
}
internal static class Raven.Client.Http.TopologyHash : object {
    public static string GetTopologyHash(String[] initialUrls);
}
public class Raven.Client.Json.BatchCommandResult : object {
    [CompilerGeneratedAttribute]
private BlittableJsonReaderArray <Results>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <TransactionIndex>k__BackingField;
    public BlittableJsonReaderArray Results { get; public set; }
    public Nullable`1<long> TransactionIndex { get; public set; }
    [CompilerGeneratedAttribute]
public BlittableJsonReaderArray get_Results();
    [CompilerGeneratedAttribute]
public void set_Results(BlittableJsonReaderArray value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_TransactionIndex();
    [CompilerGeneratedAttribute]
public void set_TransactionIndex(Nullable`1<long> value);
}
public class Raven.Client.Json.BlittableArrayResult : object {
    [CompilerGeneratedAttribute]
private BlittableJsonReaderArray <Results>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalResults>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContinuationToken>k__BackingField;
    public BlittableJsonReaderArray Results { get; public set; }
    public long TotalResults { get; public set; }
    public string ContinuationToken { get; public set; }
    [CompilerGeneratedAttribute]
public BlittableJsonReaderArray get_Results();
    [CompilerGeneratedAttribute]
public void set_Results(BlittableJsonReaderArray value);
    [CompilerGeneratedAttribute]
public long get_TotalResults();
    [CompilerGeneratedAttribute]
public void set_TotalResults(long value);
    [CompilerGeneratedAttribute]
public string get_ContinuationToken();
    [CompilerGeneratedAttribute]
public void set_ContinuationToken(string value);
}
[ExtensionAttribute]
internal static class Raven.Client.Json.BlittableExtensions : object {
    [IteratorStateMachineAttribute("Raven.Client.Json.BlittableExtensions/<SelectTokenWithRavenSyntaxReturningFlatStructure>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<Tuple`2<object, object>> SelectTokenWithRavenSyntaxReturningFlatStructure(BlittableJsonReaderBase self, string path, bool createSnapshots);
}
internal class Raven.Client.Json.BlittableJsonContent : HttpContent {
    private static TaskCompletionSource`1<object> Sentinel;
    private TaskCompletionSource`1<object> _tcs;
    private Func`2<Stream, Task> _asyncTaskWriter;
    private DocumentConventions _conventions;
    public BlittableJsonContent(Func`2<Stream, Task> writer, DocumentConventions conventions);
    private static BlittableJsonContent();
    public Task EnsureCompletedAsync();
    [AsyncStateMachineAttribute("Raven.Client.Json.BlittableJsonContent/<SerializeToStreamAsync>d__6")]
protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected virtual bool TryComputeLength(Int64& length);
}
internal static class Raven.Client.Json.BlittableOperation : object {
    private static Lazy`1<JsonOperationContext> Context;
    private static LazyStringValue LastModified;
    private static LazyStringValue Collection;
    private static LazyStringValue ChangeVector;
    private static LazyStringValue Id;
    private static BlittableOperation();
    public static bool EntityChanged(BlittableJsonReaderObject newObj, DocumentInfo documentInfo, IDictionary`2<string, DocumentsChanges[]> changes);
    private static bool CompareBlittable(string fieldPath, string id, BlittableJsonReaderObject originalBlittable, BlittableJsonReaderObject newBlittable, IDictionary`2<string, DocumentsChanges[]> changes, List`1<DocumentsChanges> docChanges);
    private static bool CompareStringsWithEscapePositions(JsonOperationContext context, PropertyDetails oldProp, PropertyDetails newProp);
    private static string FieldPathCombine(string path1, string path2);
    private static bool CompareValues(PropertyDetails oldProp, PropertyDetails newProp);
    private static bool CompareBlittableArray(string fieldPath, string id, BlittableJsonReaderArray oldArray, BlittableJsonReaderArray newArray, IDictionary`2<string, DocumentsChanges[]> changes, List`1<DocumentsChanges> docChanges, LazyStringValue propName);
    private static string AddIndexFieldPath(string fieldPath, int position);
    private static void NewChange(string fieldPath, string name, object newValue, object oldValue, List`1<DocumentsChanges> docChanges, ChangeType change);
}
internal class Raven.Client.Json.BlittablePath : object {
    private string _expression;
    [CompilerGeneratedAttribute]
private List`1<object> <Parts>k__BackingField;
    private int _currentIndex;
    private static Char[] _escapeChars;
    public List`1<object> Parts { get; }
    public BlittablePath(string expression);
    private static BlittablePath();
    [CompilerGeneratedAttribute]
public List`1<object> get_Parts();
    public static string EscapeString(string str);
    private static bool IsEscapeChar(char c);
    private void ParseMain();
    private string GetEscapedMember(string expression, int start, int length, List`1<int> escapePositions);
    private void ParseIndexer(char indexerOpenChar);
    internal object Evaluate(BlittableJsonReaderBase root);
}
[ExtensionAttribute]
internal static class Raven.Client.Json.ExpressionHelper : object {
    public static Action`2<TClass, TField> CreateFieldSetter(string fieldName);
    public static Action`1<TClass> SafelyClearList(string fieldName);
    [ExtensionAttribute]
private static Expression CastFromObject(Expression expr, Type targetType);
}
[DefaultMemberAttribute("Item")]
public class Raven.Client.Json.MetadataAsDictionary : object {
    private MetadataAsDictionary _parent;
    private string _parentKey;
    private IDictionary`2<string, object> _metadata;
    private BlittableJsonReaderObject _source;
    private bool _hasChanges;
    public object Item { get; public set; }
    public bool Changed { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<object> Values { get; }
    internal MetadataAsDictionary(BlittableJsonReaderObject metadata, MetadataAsDictionary parent, string parentKey);
    public MetadataAsDictionary(BlittableJsonReaderObject metadata);
    public MetadataAsDictionary(Dictionary`2<string, object> metadata);
    private void Initialize(BlittableJsonReaderObject metadata);
    private object ConvertValue(string key, object value);
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    internal static MetadataAsDictionary MaterializeFromBlittable(BlittableJsonReaderObject metadata);
    public bool get_Changed();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<object> get_Values();
    public sealed virtual void Add(KeyValuePair`2<string, object> item);
    public sealed virtual void Add(string key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, object> item);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    public sealed virtual bool Remove(KeyValuePair`2<string, object> item);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, Object& value);
    public sealed virtual bool TryGetValue(string key, String& value);
    public sealed virtual string GetString(string key);
    public sealed virtual long GetLong(string key);
    public sealed virtual bool GetBoolean(string key);
    public sealed virtual double GetDouble(string key);
    public sealed virtual IMetadataDictionary GetObject(string key);
    public sealed virtual IMetadataDictionary[] GetObjects(string key);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void MarkChanged();
}
public class Raven.Client.Json.Serialization.CreateDeserializerOptions : CreateSerializerOptions {
}
public class Raven.Client.Json.Serialization.CreateSerializerOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TypeNameHandling> <TypeNameHandling>k__BackingField;
    public Nullable`1<TypeNameHandling> TypeNameHandling { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TypeNameHandling> get_TypeNameHandling();
    [CompilerGeneratedAttribute]
public void set_TypeNameHandling(Nullable`1<TypeNameHandling> value);
}
public interface Raven.Client.Json.Serialization.IBlittableJsonConverter {
    public abstract virtual BlittableJsonReaderObject ToBlittable(object entity, JsonOperationContext context);
    public abstract virtual BlittableJsonReaderObject ToBlittable(object entity, JsonOperationContext context, IJsonSerializer jsonSerializer);
    public abstract virtual BlittableJsonReaderObject ToBlittable(object entity, IMetadataDictionary metadata, JsonOperationContext context);
    public abstract virtual BlittableJsonReaderObject ToBlittable(object entity, IMetadataDictionary metadata, JsonOperationContext context, IJsonSerializer jsonSerializer);
    public abstract virtual object FromBlittable(Type type, BlittableJsonReaderObject json, string id);
    public abstract virtual T FromBlittable(BlittableJsonReaderObject json, string id);
}
public interface Raven.Client.Json.Serialization.IBlittableJsonConverterBase {
    public abstract virtual void PopulateEntity(object entity, BlittableJsonReaderObject json);
    public abstract virtual void PopulateEntity(object entity, BlittableJsonReaderObject json, IJsonSerializer jsonSerializer);
}
public interface Raven.Client.Json.Serialization.IJsonReader {
}
public interface Raven.Client.Json.Serialization.IJsonSerializer {
    public abstract virtual void Serialize(IJsonWriter writer, object value);
    public abstract virtual void Serialize(IJsonWriter writer, object value, Type objectType);
    public abstract virtual object Deserialize(IJsonReader reader, Type type);
    public abstract virtual T Deserialize(IJsonReader reader);
}
public interface Raven.Client.Json.Serialization.IJsonWriter {
    public abstract virtual void Close();
    public abstract virtual BlittableJsonReaderObject CreateReader();
    public abstract virtual void FinalizeDocument();
    public abstract virtual void Flush();
    public abstract virtual void WriteComment(string text);
    public abstract virtual void WriteEnd();
    public abstract virtual void WriteEndArray();
    public abstract virtual void WriteEndConstructor();
    public abstract virtual void WriteEndObject();
    public abstract virtual void WriteNull();
    public abstract virtual void WriteMetadata(IMetadataDictionary metadata);
    public abstract virtual void WritePropertyName(string name);
    public abstract virtual void WritePropertyName(string name, bool escape);
    public abstract virtual void WriteRaw(string json);
    public abstract virtual void WriteRawValue(string json);
    public abstract virtual void WriteStartArray();
    public abstract virtual void WriteStartConstructor(string name);
    public abstract virtual void WriteStartObject();
    public abstract virtual void WriteUndefined();
    public abstract virtual void WriteValue(bool value);
    public abstract virtual void WriteValue(Nullable`1<bool> value);
    public abstract virtual void WriteValue(byte value);
    public abstract virtual void WriteValue(Nullable`1<byte> value);
    public abstract virtual void WriteValue(Byte[] value);
    public abstract virtual void WriteValue(char value);
    public abstract virtual void WriteValue(Nullable`1<char> value);
    public abstract virtual void WriteValue(DateTime dt);
    public abstract virtual void WriteValue(Nullable`1<DateTime> value);
    public abstract virtual void WriteValue(DateTimeOffset dto);
    public abstract virtual void WriteValue(Nullable`1<DateTimeOffset> value);
    public abstract virtual void WriteValue(decimal value);
    public abstract virtual void WriteValue(Nullable`1<decimal> value);
    public abstract virtual void WriteValue(double value);
    public abstract virtual void WriteValue(Nullable`1<double> value);
    public abstract virtual void WriteValue(float value);
    public abstract virtual void WriteValue(Nullable`1<float> value);
    public abstract virtual void WriteValue(Guid value);
    public abstract virtual void WriteValue(Nullable`1<Guid> value);
    public abstract virtual void WriteValue(int value);
    public abstract virtual void WriteValue(Nullable`1<int> value);
    public abstract virtual void WriteValue(long value);
    public abstract virtual void WriteValue(Nullable`1<long> value);
    public abstract virtual void WriteValue(object value);
    public abstract virtual void WriteValue(sbyte value);
    public abstract virtual void WriteValue(Nullable`1<sbyte> value);
    public abstract virtual void WriteValue(short value);
    public abstract virtual void WriteValue(Nullable`1<short> value);
    public abstract virtual void WriteValue(string value);
    public abstract virtual void WriteValue(TimeSpan ts);
    public abstract virtual void WriteValue(Nullable`1<TimeSpan> value);
    public abstract virtual void WriteValue(UInt32 value);
    public abstract virtual void WriteValue(Nullable`1<UInt32> value);
    public abstract virtual void WriteValue(ulong value);
    public abstract virtual void WriteValue(Nullable`1<ulong> value);
    public abstract virtual void WriteValue(Uri value);
    public abstract virtual void WriteValue(ushort value);
    public abstract virtual void WriteValue(Nullable`1<ushort> value);
    public abstract virtual void WriteWhitespace(string ws);
}
public interface Raven.Client.Json.Serialization.ISerializationConventions {
    public DocumentConventions Conventions { get; }
    public IBlittableJsonConverter DefaultConverter { get; }
    public abstract virtual DocumentConventions get_Conventions();
    public abstract virtual void Initialize(DocumentConventions conventions);
    public abstract virtual IJsonSerializer CreateSerializer(CreateSerializerOptions options);
    public abstract virtual IJsonSerializer CreateDeserializer(CreateDeserializerOptions options);
    public abstract virtual IBlittableJsonConverter get_DefaultConverter();
    public abstract virtual ISessionBlittableJsonConverter CreateConverter(InMemoryDocumentSessionOperations session);
    public abstract virtual IJsonWriter CreateWriter(JsonOperationContext context);
    public abstract virtual object DeserializeEntityFromBlittable(Type type, BlittableJsonReaderObject json);
    public abstract virtual T DeserializeEntityFromBlittable(BlittableJsonReaderObject json);
}
public interface Raven.Client.Json.Serialization.ISessionBlittableJsonConverter {
    public abstract virtual BlittableJsonReaderObject ToBlittable(object entity, DocumentInfo documentInfo);
    public abstract virtual object FromBlittable(Type type, BlittableJsonReaderObject& json, string id, bool trackEntity);
    public abstract virtual T FromBlittable(BlittableJsonReaderObject& json, string id, bool trackEntity);
    public abstract virtual void PopulateEntity(object entity, string id, BlittableJsonReaderObject json);
    public abstract virtual void PopulateEntity(object entity, string id, BlittableJsonReaderObject json, IJsonSerializer jsonSerializer);
    public abstract virtual void RemoveFromMissing(T entity);
    public abstract virtual void Clear();
}
internal class Raven.Client.Json.Serialization.JsonDeserializationClient : JsonDeserializationBase {
    public static Func`2<BlittableJsonReaderObject, CommandResult> IsDatabaseLoadedCommandResult;
    public static Func`2<BlittableJsonReaderObject, Conflict> DocumentConflict;
    public static Func`2<BlittableJsonReaderObject, GetConflictsResult> GetConflictsResult;
    public static Func`2<BlittableJsonReaderObject, GetDocumentsResult> GetDocumentsResult;
    public static Func`2<BlittableJsonReaderObject, ConditionalGetResult> ConditionalGetResult;
    public static Func`2<BlittableJsonReaderObject, PutResult> PutResult;
    public static Func`2<BlittableJsonReaderObject, AttachmentDetails> AttachmentDetails;
    public static Func`2<BlittableJsonReaderObject, AttachmentName> AttachmentName;
    public static Func`2<BlittableJsonReaderObject, QueryResult> QueryResult;
    public static Func`2<BlittableJsonReaderObject, ChangesSupportedFeatures> ChangesSupportedFeatures;
    public static Func`2<BlittableJsonReaderObject, Topology> Topology;
    public static Func`2<BlittableJsonReaderObject, ClusterTopologyResponse> ClusterTopology;
    public static Func`2<BlittableJsonReaderObject, NodeInfo> NodeInfo;
    public static Func`2<BlittableJsonReaderObject, TcpConnectionHeaderMessage> TcpConnectionHeaderMessage;
    public static Func`2<BlittableJsonReaderObject, TcpConnectionHeaderResponse> TcpConnectionHeaderResponse;
    public static Func`2<BlittableJsonReaderObject, DatabasePutResult> DatabasePutResult;
    public static Func`2<BlittableJsonReaderObject, ModifyDatabaseTopologyResult> ModifyDatabaseTopologyResult;
    public static Func`2<BlittableJsonReaderObject, GetLogsConfigurationResult> GetLogsConfigurationResult;
    public static Func`2<BlittableJsonReaderObject, ModifyOngoingTaskResult> ModifyOngoingTaskResult;
    public static Func`2<BlittableJsonReaderObject, OngoingTaskSubscription> GetOngoingTaskSubscriptionResult;
    public static Func`2<BlittableJsonReaderObject, OngoingTaskPullReplicationAsSink> OngoingTaskPullReplicationAsSinkResult;
    public static Func`2<BlittableJsonReaderObject, OngoingTaskPullReplicationAsHub> OngoingTaskPullReplicationAsHubResult;
    public static Func`2<BlittableJsonReaderObject, PullReplicationDefinitionAndCurrentConnections> PullReplicationDefinitionAndCurrentConnectionsResult;
    public static Func`2<BlittableJsonReaderObject, OngoingTaskReplication> GetOngoingTaskReplicationResult;
    public static Func`2<BlittableJsonReaderObject, OngoingTaskRavenEtl> GetOngoingTaskRavenEtlResult;
    public static Func`2<BlittableJsonReaderObject, OngoingTaskOlapEtl> GetOngoingTaskOlapEtlResult;
    public static Func`2<BlittableJsonReaderObject, OngoingTaskElasticSearchEtl> GetOngoingTaskElasticSearchEtlResult;
    public static Func`2<BlittableJsonReaderObject, OngoingTaskQueueEtl> GetOngoingTaskQueueEtlResult;
    public static Func`2<BlittableJsonReaderObject, OngoingTaskBackup> GetOngoingTaskBackupResult;
    public static Func`2<BlittableJsonReaderObject, OngoingTaskSqlEtl> GetOngoingTaskSqlEtlResult;
    public static Func`2<BlittableJsonReaderObject, ModifySolverResult> ModifySolverResult;
    public static Func`2<BlittableJsonReaderObject, ModifyOrchestratorTopologyResult> ModifyOrchestratorTopologyResult;
    public static Func`2<BlittableJsonReaderObject, AddDatabaseShardResult> AddDatabaseShardResult;
    public static Func`2<BlittableJsonReaderObject, DisableDatabaseToggleResult> DisableResourceToggleResult;
    public static Func`2<BlittableJsonReaderObject, BlittableArrayResult> BlittableArrayResult;
    public static Func`2<BlittableJsonReaderObject, BatchCommandResult> BatchCommandResult;
    public static Func`2<BlittableJsonReaderObject, DatabaseStatistics> GetStatisticsResult;
    public static Func`2<BlittableJsonReaderObject, EssentialDatabaseStatistics> GetEssentialDatabaseStatistics;
    public static Func`2<BlittableJsonReaderObject, DetailedDatabaseStatistics> GetDetailedStatisticsResult;
    public static Func`2<BlittableJsonReaderObject, TimeSeriesStatistics> GetTimeSeriesStatisticsResult;
    public static Func`2<BlittableJsonReaderObject, OperationIdResult> OperationIdResult;
    public static Func`2<BlittableJsonReaderObject, ReplayTxOperationResult> GetReplayTrxOperationResult;
    public static Func`2<BlittableJsonReaderObject, HiLoResult> HiLoResult;
    public static Func`2<BlittableJsonReaderObject, TcpConnectionInfo> TcpConnectionInfo;
    public static Func`2<BlittableJsonReaderObject, SubscriptionConnectionServerMessage> SubscriptionNextObjectResult;
    public static Func`2<BlittableJsonReaderObject, CreateSubscriptionResult> CreateSubscriptionResult;
    public static Func`2<BlittableJsonReaderObject, UpdateSubscriptionResult> UpdateSubscriptionResult;
    public static Func`2<BlittableJsonReaderObject, GetSubscriptionsResult> GetSubscriptionsResult;
    public static Func`2<BlittableJsonReaderObject, TermsQueryResult> TermsQueryResult;
    public static Func`2<BlittableJsonReaderObject, IndexingStatus> IndexingStatus;
    public static Func`2<BlittableJsonReaderObject, GetIndexesResponse> GetIndexesResponse;
    public static Func`2<BlittableJsonReaderObject, GetIndexNamesResponse> GetIndexNamesResponse;
    public static Func`2<BlittableJsonReaderObject, GetIndexStatisticsResponse> GetIndexStatisticsResponse;
    public static Func`2<BlittableJsonReaderObject, PutIndexesResponse> PutIndexesResponse;
    public static Func`2<BlittableJsonReaderObject, IndexErrors> IndexErrors;
    public static Func`2<BlittableJsonReaderObject, PatchResult> PatchResult;
    public static Func`2<BlittableJsonReaderObject, JsonPatchResult> JsonPatchResult;
    public static Func`2<BlittableJsonReaderObject, GetCertificatesResponse> GetCertificatesResponse;
    public static Func`2<BlittableJsonReaderObject, GetCertificatesMetadataResponse> GetCertificatesMetadataResponse;
    public static Func`2<BlittableJsonReaderObject, BuildNumber> BuildNumber;
    public static Func`2<BlittableJsonReaderObject, SubscriptionState> SubscriptionState;
    public static Func`2<BlittableJsonReaderObject, CountersDetail> CountersDetail;
    public static Func`2<BlittableJsonReaderObject, TimeSeriesEntry> TimeSeriesValue;
    public static Func`2<BlittableJsonReaderObject, TimeSeriesDetails> TimeSeriesDetails;
    internal static Func`2<BlittableJsonReaderObject, Response> TimeSeriesRangesResponse;
    internal static Func`2<BlittableJsonReaderObject, RequestBody> TimeSeriesRangesRequestBody;
    internal static Func`2<BlittableJsonReaderObject, ExceptionSchema> ExceptionSchema;
    internal static Func`2<BlittableJsonReaderObject, DeleteDatabaseResult> DeleteDatabaseResult;
    internal static Func`2<BlittableJsonReaderObject, ConfigureExpirationOperationResult> ConfigureExpirationOperationResult;
    internal static Func`2<BlittableJsonReaderObject, ConfigureDataArchivalOperationResult> ConfigureDataArchivalOperationResult;
    internal static Func`2<BlittableJsonReaderObject, DocumentCompressionConfigurationResult> DocumentCompressionConfigurationOperationResult;
    internal static Func`2<BlittableJsonReaderObject, ConfigureRevisionsForConflictsResult> ConfigRevisionsOnConflictOperationResult;
    internal static Func`2<BlittableJsonReaderObject, ConfigureRefreshOperationResult> ConfigureRefreshOperationResult;
    internal static Func`2<BlittableJsonReaderObject, UpdatePeriodicBackupOperationResult> ConfigurePeriodicBackupOperationResult;
    internal static Func`2<BlittableJsonReaderObject, StartBackupOperationResult> BackupDatabaseNowResult;
    internal static Func`2<BlittableJsonReaderObject, GetPeriodicBackupStatusOperationResult> GetPeriodicBackupStatusOperationResult;
    internal static Func`2<BlittableJsonReaderObject, GetShardedPeriodicBackupStatusOperationResult> GetShardedPeriodicBackupStatusOperationResult;
    internal static Func`2<BlittableJsonReaderObject, PeriodicBackupStatus> PeriodicBackupStatus;
    internal static Func`2<BlittableJsonReaderObject, ConfigureRevisionsOperationResult> ConfigureRevisionsOperationResult;
    internal static Func`2<BlittableJsonReaderObject, ConfigureTimeSeriesOperationResult> ConfigureTimeSeriesOperationResult;
    internal static Func`2<BlittableJsonReaderObject, ExternalReplication> ExternalReplication;
    internal static Func`2<BlittableJsonReaderObject, PullReplicationAsSink> PullReplicationAsSink;
    internal static Func`2<BlittableJsonReaderObject, ReplicationHubAccess> ReplicationHubAccess;
    internal static Func`2<BlittableJsonReaderObject, PullReplicationDefinition> PullReplicationDefinition;
    internal static Func`2<BlittableJsonReaderObject, AddEtlOperationResult> AddEtlOperationResult;
    internal static Func`2<BlittableJsonReaderObject, AddQueueSinkOperationResult> AddQueueSinkOperationResult;
    internal static Func`2<BlittableJsonReaderObject, ReplicationHubAccessResult> ReplicationHubAccessResult;
    internal static Func`2<BlittableJsonReaderObject, UpdateEtlOperationResult> UpdateEtlOperationResult;
    internal static Func`2<BlittableJsonReaderObject, UpdateQueueSinkOperationResult> UpdateQueueSinkOperationResult;
    internal static Func`2<BlittableJsonReaderObject, EtlProcessState> EtlProcessState;
    internal static Func`2<BlittableJsonReaderObject, QueueSinkProcessState> QueueSinkProcessState;
    internal static Func`2<BlittableJsonReaderObject, PutConnectionStringResult> PutConnectionStringResult;
    internal static Func`2<BlittableJsonReaderObject, RemoveConnectionStringResult> RemoveConnectionStringResult;
    internal static Func`2<BlittableJsonReaderObject, GetConnectionStringsResult> GetConnectionStringsResult;
    internal static Func`2<BlittableJsonReaderObject, SmugglerResult> SmugglerResult;
    internal static Func`2<BlittableJsonReaderObject, ClientConfiguration> ClientConfiguration;
    internal static Func`2<BlittableJsonReaderObject, StudioConfiguration> StudioConfiguration;
    internal static Func`2<BlittableJsonReaderObject, ServerWideStudioConfiguration> ServerWideStudioConfiguration;
    internal static Func`2<BlittableJsonReaderObject, PutServerWideBackupConfigurationResponse> PutServerWideBackupConfigurationResponse;
    internal static Func`2<BlittableJsonReaderObject, ServerWideExternalReplicationResponse> PutServerWideConfigurationResponse;
    internal static Func`2<BlittableJsonReaderObject, GetServerWideBackupConfigurationsResponse> GetServerWideBackupConfigurationsResponse;
    internal static Func`2<BlittableJsonReaderObject, GetServerWideExternalReplicationsResponse> GetServerWideExternalReplicationsResponse;
    internal static Func`2<BlittableJsonReaderObject, Result> ClientConfigurationResult;
    internal static Func`2<BlittableJsonReaderObject, S3Settings> S3Settings;
    internal static Func`2<BlittableJsonReaderObject, GlacierSettings> GlacierSettings;
    internal static Func`2<BlittableJsonReaderObject, AzureSettings> AzureSettings;
    internal static Func`2<BlittableJsonReaderObject, GoogleCloudSettings> GoogleCloudSettings;
    internal static Func`2<BlittableJsonReaderObject, FtpSettings> FtpSettings;
    internal static Func`2<BlittableJsonReaderObject, ClaimDomainResult> ClaimDomainResult;
    internal static Func`2<BlittableJsonReaderObject, ForceRenewResult> ForceRenewResult;
    internal static Func`2<BlittableJsonReaderObject, CounterBatch> CounterBatch;
    internal static Func`2<BlittableJsonReaderObject, IndexDefinition> IndexDefinition;
    internal static Func`2<BlittableJsonReaderObject, TimeSeriesIndexDefinition> TimeSeriesIndexDefinition;
    internal static ConcurrentDictionary`2<Type, Func`2<BlittableJsonReaderObject, TimeSeriesRangeResult>> CacheForTimeSeriesRangeResult;
    internal static Func`2<BlittableJsonReaderObject, DocumentRevisionsCount> DocumentRevisionsCount;
    internal static Func`2<BlittableJsonReaderObject, DatabaseSettings> DatabaseSettings;
    public static Func`2<BlittableJsonReaderObject, Parameters> GetTrafficWatchConfigurationResult;
    internal static Func`2<BlittableJsonReaderObject, ConfigurePostgreSqlOperationResult> ConfigurePostgreSqlOperationResult;
    public static Func`2<BlittableJsonReaderObject, PeriodicBackupConfiguration> PeriodicBackupConfiguration;
    public static Func`2<BlittableJsonReaderObject, ElasticSearchEtlConfiguration> ElasticSearchEtlConfiguration;
    public static Func`2<BlittableJsonReaderObject, OlapEtlConfiguration> OlapEtlConfiguration;
    public static Func`2<BlittableJsonReaderObject, QueueEtlConfiguration> QueueEtlConfiguration;
    public static Func`2<BlittableJsonReaderObject, RavenEtlConfiguration> RavenEtlConfiguration;
    public static Func`2<BlittableJsonReaderObject, SqlEtlConfiguration> SqlEtlConfiguration;
    public static Func`2<BlittableJsonReaderObject, ElasticSearchConnectionString> ElasticSearchConnectionString;
    public static Func`2<BlittableJsonReaderObject, SqlConnectionString> SqlConnectionString;
    public static Func`2<BlittableJsonReaderObject, RavenConnectionString> RavenConnectionString;
    public static Func`2<BlittableJsonReaderObject, QueueConnectionString> QueueConnectionString;
    public static Func`2<BlittableJsonReaderObject, OlapConnectionString> OlapConnectionString;
    public static Func`2<BlittableJsonReaderObject, OngoingTaskQueueSink> GetOngoingTaskQueueSinkResult;
    public static Func`2<BlittableJsonReaderObject, Result> DeleteRevisionsResult;
    private static JsonDeserializationClient();
}
public class Raven.Client.Json.Serialization.NewtonsoftJson.DefaultRavenContractResolver : DefaultContractResolver {
    [ThreadStaticAttribute]
private static ExtensionDataSetter _currentExtensionSetter;
    [ThreadStaticAttribute]
private static ExtensionDataGetter _currentExtensionGetter;
    public static Nullable`1<BindingFlags> MembersSearchFlag;
    private NewtonsoftJsonSerializationConventions _conventions;
    [ThreadStaticAttribute]
internal static bool RemovedIdentityProperty;
    [ThreadStaticAttribute]
internal static object RootEntity;
    public DefaultRavenContractResolver(ISerializationConventions conventions);
    private static DefaultRavenContractResolver();
    public static ClearExtensionData RegisterExtensionDataSetter(ExtensionDataSetter setter);
    public static ClearExtensionData RegisterExtensionDataGetter(ExtensionDataGetter getter);
    protected virtual JsonObjectContract CreateObjectContract(Type objectType);
    private static bool ShouldSerialize(object value);
    protected virtual JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization);
    protected virtual List`1<MemberInfo> GetSerializableMembers(Type objectType);
    private bool MembersToFilterOut(MemberInfo info, bool isRecord);
    private static void ThrowByRefNotSupported();
    private static void ThrowPointersNotSupported();
}
public class Raven.Client.Json.Serialization.NewtonsoftJson.DefaultRavenSerializationBinder : DefaultSerializationBinder {
    public static DefaultRavenSerializationBinder Instance;
    private HashSet`1<Type> _forbiddenTypesCache;
    private HashSet`1<Type> _safeTypesCache;
    private HashSet`1<string> _forbiddenNamespaces;
    private bool _used;
    private static HashSet`1<string> ForbiddenTypes;
    private static DefaultRavenSerializationBinder();
    public virtual Type BindToType(string assemblyName, string typeName);
    public virtual void BindToName(Type serializedType, String& assemblyName, String& typeName);
    public void RegisterForbiddenNamespace(string namespace);
    public void RegisterForbiddenType(Type type);
    public void RegisterSafeType(Type type);
    private void AssertType(Type type);
    private void AssertNotUsed();
    private static void UpdateCache(HashSet`1& cache, Type type);
    private static void ThrowForbiddenType(Type type);
    private static void ThrowForbiddenNamespace(Type type);
}
internal class Raven.Client.Json.Serialization.NewtonsoftJson.Internal.BlittableJsonConverter : BlittableJsonConverterBase {
    public BlittableJsonConverter(ISerializationConventions conventions);
    public sealed virtual T FromBlittable(BlittableJsonReaderObject json, string id);
    public sealed virtual object FromBlittable(Type type, BlittableJsonReaderObject json, string id);
    public sealed virtual BlittableJsonReaderObject ToBlittable(object entity, JsonOperationContext context);
    public sealed virtual BlittableJsonReaderObject ToBlittable(object entity, JsonOperationContext context, IJsonSerializer jsonSerializer);
    public sealed virtual BlittableJsonReaderObject ToBlittable(object entity, IMetadataDictionary metadata, JsonOperationContext context);
    public sealed virtual BlittableJsonReaderObject ToBlittable(object entity, IMetadataDictionary metadata, JsonOperationContext context, IJsonSerializer jsonSerializer);
}
internal abstract class Raven.Client.Json.Serialization.NewtonsoftJson.Internal.BlittableJsonConverterBase : object {
    protected ISerializationConventions Conventions;
    protected BlittableJsonConverterBase(ISerializationConventions conventions);
    public sealed virtual void PopulateEntity(object entity, BlittableJsonReaderObject json);
    public sealed virtual void PopulateEntity(object entity, BlittableJsonReaderObject json, IJsonSerializer jsonSerializer);
    protected static BlittableJsonReaderObject ToBlittableInternal(object entity, DocumentConventions conventions, JsonOperationContext context, IJsonSerializer serializer, IJsonWriter writer, bool removeIdentityProperty);
    private static bool TryRemoveIdentityProperty(BlittableJsonReaderObject document, Type entityType, DocumentConventions conventions, bool isDynamicObject);
    private static bool TrySimplifyJson(BlittableJsonReaderObject document, Type rootType);
    private static bool TrySimplifyJson(BlittableJsonReaderArray array, Type rootType);
    private static bool ShouldSimplifyJsonBasedOnType(string typeValue);
    internal static Type GetPropertyType(string propertyName, Type rootType);
    [CompilerGeneratedAttribute]
internal static Type <TrySimplifyJson>g__GetItemType|7_0(<>c__DisplayClass7_0& );
}
internal class Raven.Client.Json.Serialization.NewtonsoftJson.Internal.BlittableJsonReader : JsonReader {
    private Stack`1<CurrentItem> _items;
    private Action`2<JsonReader, State> _setState;
    private Action`2<JsonReader, JsonToken> _setToken;
    private Action`2<JsonReader, bool> _setHasExceededMaxDepth;
    private Action`1<JsonReader> _clearStack;
    public JsonOperationContext Context;
    private bool _readAsLazyNumber;
    public BlittableJsonReader(JsonOperationContext context);
    public void Initialize(BlittableJsonReaderObject root);
    public virtual bool Read();
    private static BlittableJsonToken GetTokenFromType(object val);
    private bool SetToken(BlittableJsonToken token, object value);
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual string ReadAsString();
    public virtual Byte[] ReadAsBytes();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<double> ReadAsDouble();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    public void SkipBlittableInside();
    public void SkipBlittableArrayInside();
    private sealed virtual override void System.IDisposable.Dispose();
}
internal class Raven.Client.Json.Serialization.NewtonsoftJson.Internal.BlittableJsonWriter : JsonWriter {
    private LazyStringValue _metadataKey;
    private LazyStringValue _metadataCollection;
    private LazyStringValue _metadataId;
    private ManualBlittableJsonDocumentBuilder`1<UnmanagedWriteBuffer> _manualBlittableJsonDocumentBuilder;
    private bool _first;
    private DocumentInfo _documentInfo;
    public BlittableJsonWriter(JsonOperationContext context, DocumentInfo documentInfo, Nullable`1<UsageMode> mode, BlittableWriter`1<UnmanagedWriteBuffer> writer, LazyStringValue idField, LazyStringValue keyField, LazyStringValue collectionField);
    public virtual void WriteStartObject();
    private void WriteMetadata();
    public sealed virtual void WriteMetadata(IMetadataDictionary metadata);
    private void WritePropertyValue(PropertyDetails prop);
    private void WriteObject(BlittableJsonReaderObject obj);
    private void WritePropertyValue(string propName, object value);
    private void WriteDictionary(IDictionary iDictionary);
    private void WriteDictionary(IDictionary`2<string, T> dic);
    public virtual void WriteEndObject();
    public sealed virtual void FinalizeDocument();
    public virtual void WriteStartArray();
    public virtual void WriteEndArray();
    public virtual void WritePropertyName(string name);
    public virtual void WritePropertyName(string name, bool escape);
    public virtual void WriteNull();
    public virtual void WriteValue(string value);
    public void WriteValue(LazyCompressedStringValue value);
    public void WriteValue(LazyStringValue value);
    public void WriteValue(LazyNumberValue value);
    public virtual void WriteValue(short value);
    public virtual void WriteValue(int value);
    public virtual void WriteValue(long value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(byte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime dt);
    public virtual void WriteValue(DateTimeOffset dto);
    public virtual void WriteValue(Nullable`1<int> value);
    public virtual void WriteValue(Nullable`1<long> value);
    public virtual void WriteValue(Nullable`1<float> value);
    public virtual void WriteValue(Nullable`1<double> value);
    public virtual void WriteValue(Nullable`1<bool> value);
    public virtual void WriteValue(Nullable`1<short> value);
    public virtual void WriteValue(Nullable`1<byte> value);
    public virtual void WriteValue(Nullable`1<decimal> value);
    public virtual void WriteValue(Nullable`1<DateTime> value);
    public virtual void WriteValue(Nullable`1<DateTimeOffset> value);
    protected virtual void Dispose(bool disposing);
    public sealed virtual BlittableJsonReaderObject CreateReader();
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(Nullable`1<Guid> value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(Nullable`1<char> value);
    public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(Nullable`1<sbyte> value);
    public virtual void WriteValue(ushort value);
    public virtual void WriteValue(Nullable`1<ushort> value);
    public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(Nullable`1<UInt32> value);
    public virtual void WriteValue(ulong value);
    public virtual void WriteValue(Nullable`1<ulong> value);
    public virtual void WriteValue(TimeSpan ts);
    public virtual void WriteValue(Nullable`1<TimeSpan> value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(Uri value);
    public virtual void WriteValue(object value);
    public virtual void WriteComment(string text);
    public virtual void WriteWhitespace(string ws);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual void Flush();
    public virtual void Close();
    public virtual void WriteStartConstructor(string name);
    public virtual void WriteEndConstructor();
    public virtual void WriteEnd();
    protected virtual void WriteEnd(JsonToken token);
    protected virtual void WriteIndent();
    protected virtual void WriteValueDelimiter();
    protected virtual void WriteIndentSpace();
    public virtual void WriteUndefined();
    public virtual void WriteRaw(string json);
    public virtual void WriteRawValue(string json);
    public virtual bool Equals(object obj);
}
internal class Raven.Client.Json.Serialization.NewtonsoftJson.Internal.Converters.CachingJsonConverter : JsonConverter {
    private JsonConverter[] _converters;
    private TypeCache`1<JsonConverter> _cache;
    [CompilerGeneratedAttribute]
private bool <CanRead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanWrite>k__BackingField;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public CachingJsonConverter(JsonConverter[] converters, bool canRead, bool canWrite);
    [CompilerGeneratedAttribute]
public virtual bool get_CanRead();
    [CompilerGeneratedAttribute]
public virtual bool get_CanWrite();
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    private JsonConverter UpdateCache(Type objectType);
    private void ThrowConverterIsNullException(Type objectType);
}
internal class Raven.Client.Json.Serialization.NewtonsoftJson.Internal.Converters.DateTools : object {
    private static string YEAR_FORMAT;
    private static string MONTH_FORMAT;
    private static string DAY_FORMAT;
    private static string HOUR_FORMAT;
    private static string MINUTE_FORMAT;
    private static string SECOND_FORMAT;
    private static string MILLISECOND_FORMAT;
    private static DateTools();
    public static string DateToString(DateTime date, Resolution resolution);
    public static string TimeToString(long time, Resolution resolution);
    public static long StringToTime(string dateString);
    public static DateTime StringToDate(string dateString);
    public static DateTime Round(DateTime date, Resolution resolution);
    public static long Round(long time, Resolution resolution);
}
internal class Raven.Client.Json.Serialization.NewtonsoftJson.Internal.Converters.JsonDateTimeISO8601Converter : JsonConverter {
    public static JsonDateTimeISO8601Converter Instance;
    private static JsonDateTimeISO8601Converter();
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
internal class Raven.Client.Json.Serialization.NewtonsoftJson.Internal.Converters.JsonDictionaryDateTimeKeysConverter : JsonConverter {
    private MethodInfo _genericWriteJsonMethodInfo;
    private MethodInfo _genericReadJsonMethodInfo;
    public static JsonDictionaryDateTimeKeysConverter Instance;
    private Dictionary`2<Type, bool> _canConvertCache;
    private static JsonDictionaryDateTimeKeysConverter();
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public void GenericWriteJson(JsonWriter writer, Dictionary`2<TKey, TValue> value, JsonSerializer serializer);
    public Dictionary`2<TKey, TValue> GenericReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
internal class Raven.Client.Json.Serialization.NewtonsoftJson.Internal.Converters.JsonEnumerableConverter : JsonConverter {
    private NewtonsoftJsonSerializationConventions _conventions;
    public bool CanRead { get; }
    public JsonEnumerableConverter(NewtonsoftJsonSerializationConventions conventions);
    public virtual bool get_CanRead();
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
internal class Raven.Client.Json.Serialization.NewtonsoftJson.Internal.Converters.JsonIMetadataDictionaryConverter : JsonConverter {
    public static JsonIMetadataDictionaryConverter Instance;
    private static JsonIMetadataDictionaryConverter();
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
internal class Raven.Client.Json.Serialization.NewtonsoftJson.Internal.Converters.JsonLinqEnumerableConverter : JsonConverter {
    public static JsonLinqEnumerableConverter Instance;
    private Dictionary`2<Type, bool> _canConvertCache;
    public bool CanRead { get; }
    private static JsonLinqEnumerableConverter();
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual bool get_CanRead();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
internal class Raven.Client.Json.Serialization.NewtonsoftJson.Internal.Converters.JsonLuceneDateTimeConverter : JsonConverter {
    private static Regex LuceneDateTimePattern;
    public static JsonLuceneDateTimeConverter Instance;
    public bool CanWrite { get; }
    private static JsonLuceneDateTimeConverter();
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
}
internal class Raven.Client.Json.Serialization.NewtonsoftJson.Internal.Converters.ParametersConverter : JsonConverter {
    public static ParametersConverter Instance;
    private static HashSet`1<Assembly> RavenAssemblies;
    private static TypeCache`1<ParameterType> ConverterCache;
    private static ParametersConverter();
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private static bool IsRavenAssembly(object item);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
internal class Raven.Client.Json.Serialization.NewtonsoftJson.Internal.Converters.SizeConverter : JsonConverter {
    public static SizeConverter Instance;
    private static SizeConverter();
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
internal class Raven.Client.Json.Serialization.NewtonsoftJson.Internal.Converters.StringDictionaryConverter : JsonConverter {
    private static StringDictionaryConverter CurrentCulture;
    private static StringDictionaryConverter CurrentCultureIgnoreCase;
    private static StringDictionaryConverter InvariantCulture;
    private static StringDictionaryConverter InvariantCultureIgnoreCase;
    private static StringDictionaryConverter Ordinal;
    private static StringDictionaryConverter OrdinalIgnoreCase;
    private Object[] _constructorParameters;
    public bool CanWrite { get; }
    private StringDictionaryConverter(StringComparison stringComparison);
    private static StringDictionaryConverter();
    public virtual bool get_CanWrite();
    public static StringDictionaryConverter For(StringComparison stringComparison);
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private static StringComparer GetStringComparer(StringComparison stringComparison);
}
internal class Raven.Client.Json.Serialization.NewtonsoftJson.Internal.NewtonsoftJsonBlittableEntitySerializer : object {
    private LightWeightThreadLocal`1<BlittableJsonReader> _reader;
    private LightWeightThreadLocal`1<IJsonSerializer> _deserializer;
    private GenerateEntityIdOnTheClient _generateEntityIdOnTheClient;
    public NewtonsoftJsonBlittableEntitySerializer(ISerializationConventions conventions);
    internal BlittableJsonReader GetReaderForCurrentThread();
    public object EntityFromJsonStream(Type type, BlittableJsonReaderObject json);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <EntityFromJsonStream>b__5_0(object o, string key, object value);
}
internal class Raven.Client.Json.Serialization.NewtonsoftJson.Internal.NewtonsoftJsonJsonSerializer : JsonSerializer {
    private sealed virtual override object Raven.Client.Json.Serialization.IJsonSerializer.Deserialize(IJsonReader reader, Type type);
    private sealed virtual override T Raven.Client.Json.Serialization.IJsonSerializer.Deserialize(IJsonReader reader);
    private sealed virtual override void Raven.Client.Json.Serialization.IJsonSerializer.Serialize(IJsonWriter writer, object value, Type objectType);
    private sealed virtual override void Raven.Client.Json.Serialization.IJsonSerializer.Serialize(IJsonWriter writer, object value);
}
[ExtensionAttribute]
internal static class Raven.Client.Json.Serialization.NewtonsoftJson.Internal.NewtonsoftJsonJsonSerializerExtensions : object {
    [ExtensionAttribute]
public static void ApplyOptions(NewtonsoftJsonJsonSerializer jsonSerializer, CreateSerializerOptions options);
}
internal class Raven.Client.Json.Serialization.NewtonsoftJson.Internal.SessionBlittableJsonConverter : BlittableJsonConverterBase {
    private InMemoryDocumentSessionOperations _session;
    private Dictionary`2<object, Dictionary`2<object, object>> _missingDictionary;
    public SessionBlittableJsonConverter(InMemoryDocumentSessionOperations session);
    public sealed virtual void Clear();
    public sealed virtual object FromBlittable(Type type, BlittableJsonReaderObject& json, string id, bool trackEntity);
    public sealed virtual T FromBlittable(BlittableJsonReaderObject& json, string id, bool trackEntity);
    public sealed virtual void PopulateEntity(object entity, string id, BlittableJsonReaderObject json);
    public sealed virtual void PopulateEntity(object entity, string id, BlittableJsonReaderObject json, IJsonSerializer jsonSerializer);
    public sealed virtual void RemoveFromMissing(T entity);
    public sealed virtual BlittableJsonReaderObject ToBlittable(object entity, DocumentInfo documentInfo);
    private IEnumerable`1<KeyValuePair`2<object, object>> FillMissingProperties(object o);
    private void RegisterMissingProperties(object o, string id, object value);
    [CompilerGeneratedAttribute]
internal static string <FromBlittable>g__TryReadBlittableAsString|4_0(BlittableJsonReaderObject jsonToRead);
}
public class Raven.Client.Json.Serialization.NewtonsoftJson.NewtonsoftJsonSerializationConventions : object {
    private BlittableJsonConverter _defaultConverter;
    private IContractResolver _jsonContractResolver;
    private Action`1<JsonSerializer> _customizeJsonSerializer;
    private Action`1<JsonSerializer> _customizeJsonDeserializer;
    private Func`3<Type, BlittableJsonReaderObject, object> _deserializeEntityFromBlittable;
    private JsonEnumerableConverter _jsonEnumerableConverter;
    private bool _ignoreByRefMembers;
    private bool _ignoreUnsafeMembers;
    private CachingJsonConverter _cachedConverterSerializer;
    private CachingJsonConverter _cachedConverterDeserializer;
    [CompilerGeneratedAttribute]
private DocumentConventions <Conventions>k__BackingField;
    public DocumentConventions Conventions { get; private set; }
    public Action`1<JsonSerializer> CustomizeJsonSerializer { get; public set; }
    public Action`1<JsonSerializer> CustomizeJsonDeserializer { get; public set; }
    public IContractResolver JsonContractResolver { get; public set; }
    public Func`3<Type, BlittableJsonReaderObject, object> DeserializeEntityFromBlittable { get; public set; }
    private IBlittableJsonConverter Raven.Client.Json.Serialization.ISerializationConventions.DefaultConverter { get; }
    public bool IgnoreByRefMembers { get; public set; }
    public bool IgnoreUnsafeMembers { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual DocumentConventions get_Conventions();
    [CompilerGeneratedAttribute]
private void set_Conventions(DocumentConventions value);
    public Action`1<JsonSerializer> get_CustomizeJsonSerializer();
    public void set_CustomizeJsonSerializer(Action`1<JsonSerializer> value);
    public Action`1<JsonSerializer> get_CustomizeJsonDeserializer();
    public void set_CustomizeJsonDeserializer(Action`1<JsonSerializer> value);
    public IContractResolver get_JsonContractResolver();
    public void set_JsonContractResolver(IContractResolver value);
    public Func`3<Type, BlittableJsonReaderObject, object> get_DeserializeEntityFromBlittable();
    public void set_DeserializeEntityFromBlittable(Func`3<Type, BlittableJsonReaderObject, object> value);
    private sealed virtual override void Raven.Client.Json.Serialization.ISerializationConventions.Initialize(DocumentConventions conventions);
    private sealed virtual override IBlittableJsonConverter Raven.Client.Json.Serialization.ISerializationConventions.get_DefaultConverter();
    public bool get_IgnoreByRefMembers();
    public void set_IgnoreByRefMembers(bool value);
    public bool get_IgnoreUnsafeMembers();
    public void set_IgnoreUnsafeMembers(bool value);
    private sealed virtual override ISessionBlittableJsonConverter Raven.Client.Json.Serialization.ISerializationConventions.CreateConverter(InMemoryDocumentSessionOperations session);
    private sealed virtual override IJsonSerializer Raven.Client.Json.Serialization.ISerializationConventions.CreateDeserializer(CreateDeserializerOptions options);
    private sealed virtual override IJsonSerializer Raven.Client.Json.Serialization.ISerializationConventions.CreateSerializer(CreateSerializerOptions options);
    private sealed virtual override IJsonWriter Raven.Client.Json.Serialization.ISerializationConventions.CreateWriter(JsonOperationContext context);
    private sealed virtual override object Raven.Client.Json.Serialization.ISerializationConventions.DeserializeEntityFromBlittable(Type type, BlittableJsonReaderObject json);
    private sealed virtual override T Raven.Client.Json.Serialization.ISerializationConventions.DeserializeEntityFromBlittable(BlittableJsonReaderObject json);
    private NewtonsoftJsonJsonSerializer CreateInitialSerializer();
    private void PostJsonSerializerInitiation(NewtonsoftJsonJsonSerializer jsonSerializer, bool canRead, CachingJsonConverter& cache);
    private CachingJsonConverter InitializeConverters(NewtonsoftJsonJsonSerializer jsonSerializer, bool canRead);
}
public enum Raven.Client.Json.Serialization.TypeNameHandling : Enum {
    public int value__;
    public static TypeNameHandling None;
    public static TypeNameHandling Objects;
    public static TypeNameHandling Auto;
}
internal static class Raven.Client.Json.TypeConverter : object {
    private static TypeCache`1<BlittableSupportedReturnType> _supportedTypeCache;
    private static TypeConverter();
    private static BlittableSupportedReturnType DoBlittableSupportedTypeInternal(Type type, object value);
    public static object ToBlittableSupportedType(object value, DocumentConventions conventions, JsonOperationContext context);
    private static string KeyAsString(object key);
}
public class Raven.Client.Parameters : Dictionary`2<string, object> {
    public Parameters(Parameters other);
}
[AttributeUsageAttribute("1")]
internal class Raven.Client.Properties.RavenVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <CommitHash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Build>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReleaseDateString>k__BackingField;
    private static Nullable`1<int> _buildVersion;
    private static Version _assemblyVersion;
    private static string _assemblyVersionAsString;
    public static RavenVersionAttribute Instance;
    public int MajorVersion;
    internal char MajorVersionAsChar;
    public int MinorVersion;
    public int PatchVersion;
    public string CommitHash { get; public set; }
    public string Build { get; public set; }
    public string Version { get; public set; }
    public string FullVersion { get; public set; }
    public string ReleaseDateString { get; public set; }
    public string AssemblyVersion { get; }
    internal DateTime ReleaseDate { get; }
    public int BuildVersion { get; }
    private static RavenVersionAttribute();
    [CompilerGeneratedAttribute]
public string get_CommitHash();
    [CompilerGeneratedAttribute]
public void set_CommitHash(string value);
    [CompilerGeneratedAttribute]
public string get_Build();
    [CompilerGeneratedAttribute]
public void set_Build(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public string get_FullVersion();
    [CompilerGeneratedAttribute]
public void set_FullVersion(string value);
    [CompilerGeneratedAttribute]
public string get_ReleaseDateString();
    [CompilerGeneratedAttribute]
public void set_ReleaseDateString(string value);
    public string get_AssemblyVersion();
    internal DateTime get_ReleaseDate();
    public int get_BuildVersion();
}
internal class Raven.Client.ServerWide.Commands.Cluster.AddClusterNodeCommand : RavenCommand {
    private string _url;
    private string _tag;
    private bool _watcher;
    [CompilerGeneratedAttribute]
private string <RaftUniqueRequestId>k__BackingField;
    public bool IsReadRequest { get; }
    public string RaftUniqueRequestId { get; }
    public AddClusterNodeCommand(string url, string tag, bool watcher);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RaftUniqueRequestId();
}
internal class Raven.Client.ServerWide.Commands.Cluster.DemoteClusterNodeCommand : RavenCommand {
    private string _node;
    [CompilerGeneratedAttribute]
private string <RaftUniqueRequestId>k__BackingField;
    public bool IsReadRequest { get; }
    public string RaftUniqueRequestId { get; }
    public DemoteClusterNodeCommand(string node);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RaftUniqueRequestId();
}
internal class Raven.Client.ServerWide.Commands.Cluster.PromoteClusterNodeCommand : RavenCommand {
    private string _node;
    [CompilerGeneratedAttribute]
private string <RaftUniqueRequestId>k__BackingField;
    public bool IsReadRequest { get; }
    public string RaftUniqueRequestId { get; }
    public PromoteClusterNodeCommand(string node);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RaftUniqueRequestId();
}
internal class Raven.Client.ServerWide.Commands.Cluster.RemoveClusterNodeCommand : RavenCommand {
    private string _node;
    [CompilerGeneratedAttribute]
private string <RaftUniqueRequestId>k__BackingField;
    public bool IsReadRequest { get; }
    public string RaftUniqueRequestId { get; }
    public RemoveClusterNodeCommand(string node);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RaftUniqueRequestId();
}
internal class Raven.Client.ServerWide.Commands.Cluster.RemoveClusterNodeOperation : object {
    private string _node;
    public RemoveClusterNodeOperation(string node);
    public sealed virtual RavenCommand GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
}
public class Raven.Client.ServerWide.Commands.GetClusterTopologyCommand : RavenCommand`1<ClusterTopologyResponse> {
    private string _debugTag;
    public bool IsReadRequest { get; }
    public GetClusterTopologyCommand(string debugTag);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
}
public class Raven.Client.ServerWide.Commands.GetDatabaseTopologyCommand : RavenCommand`1<Topology> {
    private Nullable`1<Guid> _applicationIdentifier;
    private bool _usePrivateUrls;
    private string _debugTag;
    private bool _includePromotables;
    public bool IsReadRequest { get; }
    internal GetDatabaseTopologyCommand(string debugTag, Nullable`1<Guid> applicationIdentifier, bool usePrivateUrls, bool includePromotables);
    public GetDatabaseTopologyCommand(string debugTag, Nullable`1<Guid> applicationIdentifier);
    public GetDatabaseTopologyCommand(string debugTag);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
}
public class Raven.Client.ServerWide.Commands.GetNodeInfoCommand : RavenCommand`1<NodeInfo> {
    public bool IsReadRequest { get; }
    public GetNodeInfoCommand(TimeSpan timeout);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
}
public class Raven.Client.ServerWide.Commands.GetRawStreamResultCommand : RavenCommand`1<Stream> {
    private string _commandUrl;
    private HttpMethod _method;
    private Stream _headerStream;
    private bool _ownsHeaderStream;
    public bool IsReadRequest { get; }
    public GetRawStreamResultCommand(string commandUrl, Stream headerStream, HttpMethod method, bool ownsHeaderStream);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponseRaw(HttpResponseMessage response, Stream stream, JsonOperationContext context);
    public sealed virtual void Dispose();
}
public class Raven.Client.ServerWide.Commands.GetTcpInfoCommand : RavenCommand`1<TcpConnectionInfo> {
    private string _tag;
    private string _dbName;
    private string _dbId;
    private long _etag;
    private bool _fromReplication;
    private string _senderUrl;
    [CompilerGeneratedAttribute]
private ServerNode <RequestedNode>k__BackingField;
    public ServerNode RequestedNode { get; private set; }
    public bool IsReadRequest { get; }
    public GetTcpInfoCommand(string tag);
    public GetTcpInfoCommand(string tag, string dbName);
    internal GetTcpInfoCommand(string senderUrl, string tag, string dbName);
    internal GetTcpInfoCommand(string tag, string dbName, string dbId, long etag);
    internal GetTcpInfoCommand(string senderUrl, string tag, string dbName, string dbId, long etag);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    [CompilerGeneratedAttribute]
public ServerNode get_RequestedNode();
    [CompilerGeneratedAttribute]
private void set_RequestedNode(ServerNode value);
    public virtual bool get_IsReadRequest();
}
public class Raven.Client.ServerWide.Commands.IsDatabaseLoadedCommand : RavenCommand`1<CommandResult> {
    public bool IsReadRequest { get; }
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
}
public class Raven.Client.ServerWide.Commands.NodeInfo : object {
    public string NodeTag;
    public string TopologyId;
    public string Certificate;
    public string ClusterStatus;
    public int NumberOfCores;
    public double InstalledMemoryInGb;
    public double UsableMemoryInGb;
    public BuildNumber BuildInfo;
    public OsInfo OsInfo;
    public Guid ServerId;
    public RachisState CurrentState;
    public Role ServerRole;
    public bool HasFixedPort;
    public int ServerSchemaVersion;
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Client.ServerWide.Commands.PutSecretKeyCommand : RavenCommand {
    private string _name;
    private string _base64Key;
    private bool _overwrite;
    public bool IsReadRequest { get; }
    public PutSecretKeyCommand(string name, string base64Key, bool overwrite);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
}
public class Raven.Client.ServerWide.Commands.TcpConnectionInfo : object {
    public int Port;
    public string Url;
    public string Certificate;
    public String[] Urls;
    public string NodeTag;
    public string ServerId;
    public DynamicJsonValue ToJson();
}
public class Raven.Client.ServerWide.Commands.WaitForRaftIndexCommand : RavenCommand {
    private long _index;
    public bool IsReadRequest { get; }
    public WaitForRaftIndexCommand(long index);
    public WaitForRaftIndexCommand(long index, string nodeTag);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
}
public class Raven.Client.ServerWide.CompactSettings : object {
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Documents>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Indexes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipOptimizeIndexes>k__BackingField;
    public string DatabaseName { get; public set; }
    public bool Documents { get; public set; }
    public String[] Indexes { get; public set; }
    public bool SkipOptimizeIndexes { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DatabaseName();
    [CompilerGeneratedAttribute]
public void set_DatabaseName(string value);
    [CompilerGeneratedAttribute]
public bool get_Documents();
    [CompilerGeneratedAttribute]
public void set_Documents(bool value);
    [CompilerGeneratedAttribute]
public String[] get_Indexes();
    [CompilerGeneratedAttribute]
public void set_Indexes(String[] value);
    [CompilerGeneratedAttribute]
public bool get_SkipOptimizeIndexes();
    [CompilerGeneratedAttribute]
public void set_SkipOptimizeIndexes(bool value);
    public DynamicJsonValue ToJson();
}
public class Raven.Client.ServerWide.ConflictSolver : object {
    public Dictionary`2<string, ScriptResolver> ResolveByCollection;
    public bool ResolveToLatest;
    public bool ConflictResolutionChanged(ConflictSolver other);
    public bool IsEmpty();
    public DynamicJsonValue ToJson();
}
public enum Raven.Client.ServerWide.DatabaseLockMode : Enum {
    public int value__;
    public static DatabaseLockMode Unlock;
    public static DatabaseLockMode PreventDeletesIgnore;
    public static DatabaseLockMode PreventDeletesError;
}
public enum Raven.Client.ServerWide.DatabasePromotionStatus : Enum {
    public int value__;
    public static DatabasePromotionStatus WaitingForFirstPromotion;
    public static DatabasePromotionStatus NotResponding;
    public static DatabasePromotionStatus IndexNotUpToDate;
    public static DatabasePromotionStatus ChangeVectorNotMerged;
    public static DatabasePromotionStatus WaitingForResponse;
    public static DatabasePromotionStatus Ok;
    public static DatabasePromotionStatus OutOfCpuCredits;
    public static DatabasePromotionStatus EarlyOutOfMemory;
    public static DatabasePromotionStatus HighDirtyMemory;
    public static DatabasePromotionStatus RaftIndexNotUpToDate;
}
public class Raven.Client.ServerWide.DatabaseRecord : object {
    public string DatabaseName;
    public bool Disabled;
    public bool Encrypted;
    public long EtagForBackup;
    public Dictionary`2<string, DeletionInProgressStatus> DeletionInProgress;
    public Dictionary`2<string, RollingIndex> RollingIndexes;
    public DatabaseStateStatus DatabaseState;
    public DatabaseLockMode LockMode;
    public DatabaseTopology Topology;
    public ShardingConfiguration Sharding;
    public ConflictSolver ConflictSolverConfig;
    public DocumentsCompressionConfiguration DocumentsCompression;
    public Dictionary`2<string, SorterDefinition> Sorters;
    public Dictionary`2<string, AnalyzerDefinition> Analyzers;
    public Dictionary`2<string, IndexDefinition> Indexes;
    public Dictionary`2<string, List`1<IndexHistoryEntry>> IndexesHistory;
    public Dictionary`2<string, AutoIndexDefinition> AutoIndexes;
    public Dictionary`2<string, string> Settings;
    public RevisionsConfiguration Revisions;
    public TimeSeriesConfiguration TimeSeries;
    public RevisionsCollectionConfiguration RevisionsForConflicts;
    public ExpirationConfiguration Expiration;
    public RefreshConfiguration Refresh;
    public DataArchivalConfiguration DataArchival;
    public IntegrationConfigurations Integrations;
    public List`1<PeriodicBackupConfiguration> PeriodicBackups;
    public List`1<ExternalReplication> ExternalReplications;
    public List`1<PullReplicationAsSink> SinkPullReplications;
    public List`1<PullReplicationDefinition> HubPullReplications;
    public Dictionary`2<string, RavenConnectionString> RavenConnectionStrings;
    public Dictionary`2<string, SqlConnectionString> SqlConnectionStrings;
    public Dictionary`2<string, OlapConnectionString> OlapConnectionStrings;
    public Dictionary`2<string, ElasticSearchConnectionString> ElasticSearchConnectionStrings;
    public Dictionary`2<string, QueueConnectionString> QueueConnectionStrings;
    public List`1<RavenEtlConfiguration> RavenEtls;
    public List`1<SqlEtlConfiguration> SqlEtls;
    public List`1<ElasticSearchEtlConfiguration> ElasticSearchEtls;
    public List`1<OlapEtlConfiguration> OlapEtls;
    public List`1<QueueEtlConfiguration> QueueEtls;
    public List`1<QueueSinkConfiguration> QueueSinks;
    public ClientConfiguration Client;
    public StudioConfiguration Studio;
    public long TruncatedClusterTransactionCommandsCount;
    public HashSet`1<string> UnusedDatabaseIds;
    [JsonIgnoreAttribute]
public bool IsSharded { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[JsonIgnoreAttribute]
internal IEnumerable`1<ValueTuple`2<string, DatabaseTopology>> Topologies { get; }
    public DatabaseRecord(string databaseName);
    public bool get_IsSharded();
    [IteratorStateMachineAttribute("Raven.Client.ServerWide.DatabaseRecord/<get_Topologies>d__49")]
internal IEnumerable`1<ValueTuple`2<string, DatabaseTopology>> get_Topologies();
    public void AddSorter(SorterDefinition definition);
    public void DeleteSorter(string sorterName);
    public void AddAnalyzer(AnalyzerDefinition definition);
    public void DeleteAnalyzer(string sorterName);
    public void AddIndex(IndexDefinition definition, string source, DateTime createdAt, long raftIndex, int revisionsToKeep, IndexDeploymentMode globalDeploymentMode);
    internal void AddIndexHistory(IndexDefinition definition, string source, int revisionsToKeep, DateTime createdAt, Dictionary`2<string, RollingIndexDeployment> rollingIndexDeployment, bool isFromCommand, bool isRolling);
    public void AddIndex(AutoIndexDefinition definition);
    internal void AddIndex(AutoIndexDefinition definition, DateTime createdAt, long raftIndex, IndexDeploymentMode globalDeploymentMode);
    internal static bool IsRolling(Nullable`1<IndexDeploymentMode> fromDefinition, IndexDeploymentMode fromSetting);
    private void InitializeRollingDeployment(string indexName, DateTime createdAt, long raftIndex);
    private string ChooseFirstNode();
    public void DeleteIndex(string name);
    public PeriodicBackupConfiguration DeletePeriodicBackupConfiguration(long backupTaskId);
    public void EnsureTaskNameIsNotUsed(string taskName);
    internal string EnsureUniqueTaskName(string defaultTaskName);
    public int GetIndexesCount();
    public bool ValidateTopologyNodes();
    internal string GetClusterTransactionId();
    internal static string GetKeyForDeletionInProgress(string node, Nullable`1<int> shardNumber);
    internal static string GetKeyForDeletionInProgress(string node, string shardName);
    internal bool IsShardBeingDeletedOnAnyNode(int shardNumber);
}
public class Raven.Client.ServerWide.DatabaseRecordWithEtag : DatabaseRecord {
    [CompilerGeneratedAttribute]
private long <Etag>k__BackingField;
    public long Etag { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Etag();
    [CompilerGeneratedAttribute]
public void set_Etag(long value);
}
public enum Raven.Client.ServerWide.DatabaseStateStatus : Enum {
    public int value__;
    public static DatabaseStateStatus Normal;
    public static DatabaseStateStatus RestoreInProgress;
}
public class Raven.Client.ServerWide.DatabaseTopology : object {
    public List`1<string> Members;
    public List`1<string> Promotables;
    public List`1<string> Rehabs;
    public Dictionary`2<string, string> PredefinedMentors;
    public Dictionary`2<string, string> DemotionReasons;
    public Dictionary`2<string, DatabasePromotionStatus> PromotablesStatus;
    public LeaderStamp Stamp;
    public bool DynamicNodesDistribution;
    public int ReplicationFactor;
    public List`1<string> PriorityOrder;
    public Nullable`1<DateTime> NodesModifiedAt;
    public string DatabaseTopologyIdBase64;
    public string ClusterTransactionIdBase64;
    [JsonIgnoreAttribute]
public int Count { get; }
    [JsonIgnoreAttribute]
public IEnumerable`1<string> AllNodes { get; }
    internal void ReorderMembers();
    internal bool TryUpdateByPriorityOrder();
    internal void ValidateTopology(string databaseName);
    private bool IsReorderNeeded();
    public bool RelevantFor(string nodeTag);
    public List`1<ReplicationNode> GetDestinations(string myTag, string databaseName, Dictionary`2<string, DeletionInProgressStatus> deletionInProgress, ClusterTopology clusterTopology, RachisState state);
    public static ValueTuple`3<List`1<string>, List`1<string>, List`1<string>> Reorder(DatabaseTopology topology, List`1<string> order);
    internal static ValueTuple`2<HashSet`1<string>, HashSet`1<string>> FindChanges(IEnumerable`1<ReplicationNode> oldDestinations, List`1<ReplicationNode> newDestinations);
    public int get_Count();
    [IteratorStateMachineAttribute("Raven.Client.ServerWide.DatabaseTopology/<get_AllNodes>d__24")]
public IEnumerable`1<string> get_AllNodes();
    public sealed virtual DynamicJsonValue ToJson();
    public virtual string ToString();
    public void RemoveFromTopology(string delDbFromNode);
    public string WhoseTaskIsIt(RachisState state, IDatabaseTask task, Func`1<string> getLastResponsibleNode, List`1<string> explanations);
    internal string WhoseTaskIsIt(IDatabaseTask task, List`1<string> explanations);
    private string FindNodeForIntensiveOperation(ulong key, List`1<string> topology, List`1<string> explanations);
    private string FindNode(ulong key, List`1<string> topology, List`1<string> explanations);
}
public enum Raven.Client.ServerWide.DeletionInProgressStatus : Enum {
    public int value__;
    public static DeletionInProgressStatus No;
    public static DeletionInProgressStatus SoftDelete;
    public static DeletionInProgressStatus HardDelete;
}
public class Raven.Client.ServerWide.DocumentsCompressionConfiguration : object {
    [CompilerGeneratedAttribute]
private String[] <Collections>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CompressAllCollections>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CompressRevisions>k__BackingField;
    public String[] Collections { get; public set; }
    public bool CompressAllCollections { get; public set; }
    public bool CompressRevisions { get; public set; }
    public DocumentsCompressionConfiguration(bool compressRevisions, String[] collections);
    public DocumentsCompressionConfiguration(bool compressRevisions, bool compressAllCollections, String[] collections);
    [CompilerGeneratedAttribute]
public String[] get_Collections();
    [CompilerGeneratedAttribute]
public void set_Collections(String[] value);
    [CompilerGeneratedAttribute]
public bool get_CompressAllCollections();
    [CompilerGeneratedAttribute]
public void set_CompressAllCollections(bool value);
    [CompilerGeneratedAttribute]
public bool get_CompressRevisions();
    [CompilerGeneratedAttribute]
public void set_CompressRevisions(bool value);
    private bool Equals(DocumentsCompressionConfiguration other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual DynamicJsonValue ToJson();
}
internal static class Raven.Client.ServerWide.Helpers : object {
    public static string ClusterStateMachineValuesPrefix(string databaseName);
}
public interface Raven.Client.ServerWide.IDatabaseTask {
    public abstract virtual ulong GetTaskKey();
    public abstract virtual string GetMentorNode();
    public abstract virtual string GetDefaultTaskName();
    public abstract virtual string GetTaskName();
    public abstract virtual bool IsResourceIntensive();
    public abstract virtual bool IsPinnedToMentorNode();
}
public interface Raven.Client.ServerWide.IDatabaseTaskStatus {
    public string NodeTag { get; }
    public abstract virtual string get_NodeTag();
}
public class Raven.Client.ServerWide.IndexHistoryEntry : object {
    [CompilerGeneratedAttribute]
private IndexDefinition <Definition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CreatedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, RollingIndexDeployment> <RollingDeployment>k__BackingField;
    public IndexDefinition Definition { get; public set; }
    public string Source { get; public set; }
    public DateTime CreatedAt { get; public set; }
    public Dictionary`2<string, RollingIndexDeployment> RollingDeployment { get; public set; }
    [CompilerGeneratedAttribute]
public IndexDefinition get_Definition();
    [CompilerGeneratedAttribute]
public void set_Definition(IndexDefinition value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public DateTime get_CreatedAt();
    [CompilerGeneratedAttribute]
public void set_CreatedAt(DateTime value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, RollingIndexDeployment> get_RollingDeployment();
    [CompilerGeneratedAttribute]
public void set_RollingDeployment(Dictionary`2<string, RollingIndexDeployment> value);
}
public class Raven.Client.ServerWide.LeaderStamp : object {
    public long Index;
    public long Term;
    public long LeadersTicks;
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Client.ServerWide.Operations.AddDatabaseNodeOperation : object {
    private string _databaseName;
    private string _node;
    public AddDatabaseNodeOperation(string databaseName, string node);
    public AddDatabaseNodeOperation(string databaseName, int shardNumber, string node);
    public sealed virtual RavenCommand`1<DatabasePutResult> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.Analyzers.DeleteServerWideAnalyzerOperation : object {
    private string _analyzerName;
    public DeleteServerWideAnalyzerOperation(string analyzerName);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.Analyzers.PutServerWideAnalyzersOperation : object {
    private AnalyzerDefinition[] _analyzersToAdd;
    public PutServerWideAnalyzersOperation(AnalyzerDefinition[] analyzersToAdd);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.BackupInfo : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastBackup>k__BackingField;
    [CompilerGeneratedAttribute]
private double <IntervalUntilNextBackupInSec>k__BackingField;
    [CompilerGeneratedAttribute]
private BackupTaskType <BackupTaskType>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Destinations>k__BackingField;
    public Nullable`1<DateTime> LastBackup { get; public set; }
    public double IntervalUntilNextBackupInSec { get; public set; }
    public BackupTaskType BackupTaskType { get; public set; }
    public List`1<string> Destinations { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastBackup();
    [CompilerGeneratedAttribute]
public void set_LastBackup(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public double get_IntervalUntilNextBackupInSec();
    [CompilerGeneratedAttribute]
public void set_IntervalUntilNextBackupInSec(double value);
    [CompilerGeneratedAttribute]
public BackupTaskType get_BackupTaskType();
    [CompilerGeneratedAttribute]
public void set_BackupTaskType(BackupTaskType value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Destinations();
    [CompilerGeneratedAttribute]
public void set_Destinations(List`1<string> value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Client.ServerWide.Operations.BuildNumber : object {
    [CompilerGeneratedAttribute]
private string <ProductVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BuildVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommitHash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyVersion>k__BackingField;
    public string ProductVersion { get; public set; }
    public int BuildVersion { get; public set; }
    public string CommitHash { get; public set; }
    public string FullVersion { get; public set; }
    public string AssemblyVersion { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ProductVersion();
    [CompilerGeneratedAttribute]
public void set_ProductVersion(string value);
    [CompilerGeneratedAttribute]
public int get_BuildVersion();
    [CompilerGeneratedAttribute]
public void set_BuildVersion(int value);
    [CompilerGeneratedAttribute]
public string get_CommitHash();
    [CompilerGeneratedAttribute]
public void set_CommitHash(string value);
    [CompilerGeneratedAttribute]
public string get_FullVersion();
    [CompilerGeneratedAttribute]
public void set_FullVersion(string value);
    [CompilerGeneratedAttribute]
public string get_AssemblyVersion();
    [CompilerGeneratedAttribute]
public void set_AssemblyVersion(string value);
    public virtual bool Equals(object obj);
    private bool Equals(BuildNumber other);
    public virtual int GetHashCode();
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Client.ServerWide.Operations.Certificates.CertificateDefinition : CertificateMetadata {
    public string Certificate;
    public string Password;
    public DynamicJsonValue ToJson(bool metadataOnly);
}
public class Raven.Client.ServerWide.Operations.Certificates.CertificateMetadata : object {
    public string Name;
    public SecurityClearance SecurityClearance;
    public string Thumbprint;
    public Nullable`1<DateTime> NotAfter;
    public Nullable`1<DateTime> NotBefore;
    public Dictionary`2<string, DatabaseAccess> Permissions;
    public List`1<string> CollectionSecondaryKeys;
    public string CollectionPrimaryKey;
    public string PublicKeyPinningHash;
    public DynamicJsonValue ToJson();
}
public class Raven.Client.ServerWide.Operations.Certificates.CertificateRawData : object {
    public Byte[] RawData;
}
public class Raven.Client.ServerWide.Operations.Certificates.ClientCertificateGenerationResult : object {
    public static ClientCertificateGenerationResult Instance;
    public string Message { get; }
    public bool ShouldPersist { get; }
    private bool Raven.Client.Documents.Operations.IOperationResult.CanMerge { get; }
    private static ClientCertificateGenerationResult();
    public sealed virtual string get_Message();
    public sealed virtual DynamicJsonValue ToJson();
    public sealed virtual bool get_ShouldPersist();
    private sealed virtual override bool Raven.Client.Documents.Operations.IOperationResult.get_CanMerge();
    private sealed virtual override void Raven.Client.Documents.Operations.IOperationResult.MergeWith(IOperationResult result);
}
public class Raven.Client.ServerWide.Operations.Certificates.CreateClientCertificateOperation : object {
    private string _name;
    private Dictionary`2<string, DatabaseAccess> _permissions;
    private SecurityClearance _clearance;
    private string _password;
    public CreateClientCertificateOperation(string name, Dictionary`2<string, DatabaseAccess> permissions, SecurityClearance clearance, string password);
    public sealed virtual RavenCommand`1<CertificateRawData> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public enum Raven.Client.ServerWide.Operations.Certificates.DatabaseAccess : Enum {
    public int value__;
    public static DatabaseAccess ReadWrite;
    public static DatabaseAccess Admin;
    public static DatabaseAccess Read;
}
public class Raven.Client.ServerWide.Operations.Certificates.DeleteCertificateOperation : object {
    private string _thumbprint;
    public DeleteCertificateOperation(string thumbprint);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.Certificates.EditClientCertificateOperation : object {
    private string _thumbprint;
    private Dictionary`2<string, DatabaseAccess> _permissions;
    private string _name;
    private SecurityClearance _clearance;
    public EditClientCertificateOperation(Parameters parameters);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.Certificates.GetCertificateMetadataOperation : object {
    private string _thumbprint;
    public GetCertificateMetadataOperation(string thumbprint);
    public sealed virtual RavenCommand`1<CertificateMetadata> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.Certificates.GetCertificateOperation : object {
    private string _thumbprint;
    public GetCertificateOperation(string thumbprint);
    public sealed virtual RavenCommand`1<CertificateDefinition> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.Certificates.GetCertificatesMetadataOperation : object {
    private string _name;
    public GetCertificatesMetadataOperation(string name);
    public sealed virtual RavenCommand`1<CertificateMetadata[]> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.Certificates.GetCertificatesOperation : object {
    private int _start;
    private int _pageSize;
    public GetCertificatesOperation(int start, int pageSize);
    public sealed virtual RavenCommand`1<CertificateDefinition[]> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.Certificates.PutClientCertificateOperation : object {
    private X509Certificate2 _certificate;
    private Dictionary`2<string, DatabaseAccess> _permissions;
    private string _name;
    private SecurityClearance _clearance;
    [CompilerGeneratedAttribute]
private string <TwoFactorAuthenticationKey>k__BackingField;
    public string TwoFactorAuthenticationKey { get; public set; }
    public PutClientCertificateOperation(string name, X509Certificate2 certificate, Dictionary`2<string, DatabaseAccess> permissions, SecurityClearance clearance);
    [CompilerGeneratedAttribute]
public string get_TwoFactorAuthenticationKey();
    [CompilerGeneratedAttribute]
public void set_TwoFactorAuthenticationKey(string value);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.Certificates.ReplaceClusterCertificateOperation : object {
    private Byte[] _certBytes;
    private bool _replaceImmediately;
    public ReplaceClusterCertificateOperation(Byte[] certBytes, bool replaceImmediately);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public enum Raven.Client.ServerWide.Operations.Certificates.SecurityClearance : Enum {
    public int value__;
    public static SecurityClearance UnauthenticatedClients;
    public static SecurityClearance ClusterAdmin;
    public static SecurityClearance ClusterNode;
    public static SecurityClearance Operator;
    public static SecurityClearance ValidUser;
}
[AttributeUsageAttribute("128")]
internal class Raven.Client.ServerWide.Operations.Certificates.SecurityClearanceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private SecurityClearance <SecurityClearanceLevel>k__BackingField;
    public SecurityClearance SecurityClearanceLevel { get; public set; }
    public SecurityClearanceAttribute(SecurityClearance level);
    [CompilerGeneratedAttribute]
public SecurityClearance get_SecurityClearanceLevel();
    [CompilerGeneratedAttribute]
public void set_SecurityClearanceLevel(SecurityClearance value);
}
public class Raven.Client.ServerWide.Operations.CompactDatabaseOperation : object {
    private string _nodeTag;
    private CompactSettings _compactSettings;
    public CompactDatabaseOperation(CompactSettings compactSettings);
    internal CompactDatabaseOperation(CompactSettings compactSettings, string nodeTag);
    public sealed virtual RavenCommand`1<OperationIdResult> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.CompactionProgress : CompactionProgressBase`1<CompactionProgress> {
    private CompactionResult _result;
    private Dictionary`2<string, CompactionProgress> _cachedIndexesResults;
    public string Message { get; public set; }
    public string TreeName { get; public set; }
    public long TreeProgress { get; public set; }
    public long TreeTotal { get; public set; }
    public long GlobalProgress { get; public set; }
    public long GlobalTotal { get; public set; }
    public Dictionary`2<string, CompactionProgress> IndexesResults { get; public set; }
    public bool Skipped { get; public set; }
    public bool Processed { get; public set; }
    private bool Raven.Client.Documents.Operations.IOperationProgress.CanMerge { get; }
    public CompactionProgress(CompactionResult result);
    public virtual string get_Message();
    public virtual void set_Message(string value);
    public virtual string get_TreeName();
    public virtual void set_TreeName(string value);
    public virtual long get_TreeProgress();
    public virtual void set_TreeProgress(long value);
    public virtual long get_TreeTotal();
    public virtual void set_TreeTotal(long value);
    public virtual long get_GlobalProgress();
    public virtual void set_GlobalProgress(long value);
    public virtual long get_GlobalTotal();
    public virtual void set_GlobalTotal(long value);
    public virtual Dictionary`2<string, CompactionProgress> get_IndexesResults();
    public virtual void set_IndexesResults(Dictionary`2<string, CompactionProgress> value);
    public virtual bool get_Skipped();
    public virtual void set_Skipped(bool value);
    public virtual bool get_Processed();
    public virtual void set_Processed(bool value);
    private sealed virtual override IOperationProgress Raven.Client.Documents.Operations.IOperationProgress.Clone();
    private sealed virtual override bool Raven.Client.Documents.Operations.IOperationProgress.get_CanMerge();
    private sealed virtual override void Raven.Client.Documents.Operations.IOperationProgress.MergeWith(IOperationProgress progress);
}
public class Raven.Client.ServerWide.Operations.CompactionProgressBase`1 : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, T> <IndexesResults>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TreeName>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TreeProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TreeTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private long <GlobalProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private long <GlobalTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Skipped>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Processed>k__BackingField;
    public Dictionary`2<string, T> IndexesResults { get; public set; }
    public string Message { get; public set; }
    public string TreeName { get; public set; }
    public long TreeProgress { get; public set; }
    public long TreeTotal { get; public set; }
    public long GlobalProgress { get; public set; }
    public long GlobalTotal { get; public set; }
    public bool Skipped { get; public set; }
    public bool Processed { get; public set; }
    [CompilerGeneratedAttribute]
public virtual Dictionary`2<string, T> get_IndexesResults();
    [CompilerGeneratedAttribute]
public virtual void set_IndexesResults(Dictionary`2<string, T> value);
    [CompilerGeneratedAttribute]
public virtual string get_Message();
    [CompilerGeneratedAttribute]
public virtual void set_Message(string value);
    [CompilerGeneratedAttribute]
public virtual string get_TreeName();
    [CompilerGeneratedAttribute]
public virtual void set_TreeName(string value);
    [CompilerGeneratedAttribute]
public virtual long get_TreeProgress();
    [CompilerGeneratedAttribute]
public virtual void set_TreeProgress(long value);
    [CompilerGeneratedAttribute]
public virtual long get_TreeTotal();
    [CompilerGeneratedAttribute]
public virtual void set_TreeTotal(long value);
    [CompilerGeneratedAttribute]
public virtual long get_GlobalProgress();
    [CompilerGeneratedAttribute]
public virtual void set_GlobalProgress(long value);
    [CompilerGeneratedAttribute]
public virtual long get_GlobalTotal();
    [CompilerGeneratedAttribute]
public virtual void set_GlobalTotal(long value);
    [CompilerGeneratedAttribute]
public virtual bool get_Skipped();
    [CompilerGeneratedAttribute]
public virtual void set_Skipped(bool value);
    [CompilerGeneratedAttribute]
public virtual bool get_Processed();
    [CompilerGeneratedAttribute]
public virtual void set_Processed(bool value);
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Client.ServerWide.Operations.CompactionResult : CompactionProgressBase`1<CompactionResult> {
    [CompilerGeneratedAttribute]
private long <SizeBeforeCompactionInMb>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SizeAfterCompactionInMb>k__BackingField;
    private ConcurrentQueue`1<string> _messages;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private CompactionProgress <Progress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public long SizeBeforeCompactionInMb { get; public set; }
    public long SizeAfterCompactionInMb { get; public set; }
    public string Message { get; public set; }
    public CompactionProgress Progress { get; }
    public string Name { get; }
    public IEnumerable`1<string> Messages { get; }
    public bool ShouldPersist { get; }
    private bool Raven.Client.Documents.Operations.IOperationResult.CanMerge { get; }
    public CompactionResult(string name);
    [CompilerGeneratedAttribute]
public long get_SizeBeforeCompactionInMb();
    [CompilerGeneratedAttribute]
public void set_SizeBeforeCompactionInMb(long value);
    [CompilerGeneratedAttribute]
public long get_SizeAfterCompactionInMb();
    [CompilerGeneratedAttribute]
public void set_SizeAfterCompactionInMb(long value);
    [CompilerGeneratedAttribute]
public virtual string get_Message();
    [CompilerGeneratedAttribute]
public virtual void set_Message(string value);
    [CompilerGeneratedAttribute]
public CompactionProgress get_Progress();
    [CompilerGeneratedAttribute]
public string get_Name();
    public IEnumerable`1<string> get_Messages();
    public void AddWarning(string message);
    public void AddInfo(string message);
    public void AddError(string message);
    internal void AddMessage(string message);
    private void AddMessage(string type, string message);
    public virtual DynamicJsonValue ToJson();
    public sealed virtual bool get_ShouldPersist();
    private sealed virtual override bool Raven.Client.Documents.Operations.IOperationResult.get_CanMerge();
    private sealed virtual override void Raven.Client.Documents.Operations.IOperationResult.MergeWith(IOperationResult result);
}
public class Raven.Client.ServerWide.Operations.Configuration.DatabaseSettings : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public void set_Settings(Dictionary`2<string, string> value);
}
public class Raven.Client.ServerWide.Operations.Configuration.GetDatabaseSettingsOperation : object {
    private string _databaseName;
    public GetDatabaseSettingsOperation(string databaseName);
    public sealed virtual RavenCommand`1<DatabaseSettings> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.Configuration.GetServerWideBackupConfigurationOperation : object {
    private string _name;
    public GetServerWideBackupConfigurationOperation(string name);
    public sealed virtual RavenCommand`1<ServerWideBackupConfiguration> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.Configuration.GetServerWideBackupConfigurationsOperation : object {
    public sealed virtual RavenCommand`1<ServerWideBackupConfiguration[]> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.Configuration.GetServerWideClientConfigurationOperation : object {
    public sealed virtual RavenCommand`1<ClientConfiguration> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.Configuration.PutDatabaseSettingsOperation : object {
    private string _databaseName;
    private Dictionary`2<string, string> _configurationSettings;
    public PutDatabaseSettingsOperation(string databaseName, Dictionary`2<string, string> configurationSettings);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.Configuration.PutServerWideBackupConfigurationOperation : object {
    private ServerWideBackupConfiguration _configuration;
    public PutServerWideBackupConfigurationOperation(ServerWideBackupConfiguration configuration);
    public sealed virtual RavenCommand`1<PutServerWideBackupConfigurationResponse> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.Configuration.PutServerWideBackupConfigurationResponse : ServerWideTaskResponse {
}
public class Raven.Client.ServerWide.Operations.Configuration.PutServerWideClientConfigurationOperation : object {
    private ClientConfiguration _configuration;
    public PutServerWideClientConfigurationOperation(ClientConfiguration configuration);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.Configuration.ServerWideBackupConfiguration : PeriodicBackupConfiguration {
    internal static string NamePrefix;
    [CompilerGeneratedAttribute]
private String[] <ExcludedDatabases>k__BackingField;
    public String[] ExcludedDatabases { get; public set; }
    private static ServerWideBackupConfiguration();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_ExcludedDatabases();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExcludedDatabases(String[] value);
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Client.ServerWide.Operations.Configuration.ServerWideStudioConfiguration : StudioConfiguration {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ReplicationFactor>k__BackingField;
    public Nullable`1<int> ReplicationFactor { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ReplicationFactor();
    [CompilerGeneratedAttribute]
public void set_ReplicationFactor(Nullable`1<int> value);
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Client.ServerWide.Operations.ConfigureRevisionsForConflictsOperation : object {
    private string _database;
    private RevisionsCollectionConfiguration _configuration;
    public ConfigureRevisionsForConflictsOperation(string database, RevisionsCollectionConfiguration configuration);
    public sealed virtual RavenCommand`1<ConfigureRevisionsForConflictsResult> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.ServerWide.Operations.ConfigureRevisionsForConflictsResult : object {
    public Nullable`1<long> RaftCommandIndex;
}
public class Raven.Client.ServerWide.Operations.CreateDatabaseOperation : object {
    private DatabaseRecord _databaseRecord;
    private int _replicationFactor;
    public CreateDatabaseOperation(DatabaseRecord databaseRecord);
    public CreateDatabaseOperation(Action`1<IDatabaseRecordBuilderInitializer> builder);
    public CreateDatabaseOperation(DatabaseRecord databaseRecord, int replicationFactor);
    public sealed virtual RavenCommand`1<DatabasePutResult> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.ServerWide.Operations.DatabaseGroupNodeStatus : object {
    public DatabasePromotionStatus LastStatus;
    public string LastError;
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Client.ServerWide.Operations.DatabaseInfo : DatabaseState {
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    public DatabaseLockMode LockMode;
    [CompilerGeneratedAttribute]
private bool <IsAdmin>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEncrypted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RejectClients>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasRevisionsConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasExpirationConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasRefreshConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasDataArchivalConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <IndexesCount>k__BackingField;
    [CompilerGeneratedAttribute]
private NodesTopology <NodesTopology>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReplicationFactor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DynamicNodesDistribution>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, DeletionInProgressStatus> <DeletionInProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private StudioEnvironment <Environment>k__BackingField;
    public bool Disabled { get; public set; }
    public bool IsAdmin { get; public set; }
    public bool IsEncrypted { get; public set; }
    public bool RejectClients { get; public set; }
    public bool HasRevisionsConfiguration { get; public set; }
    public bool HasExpirationConfiguration { get; public set; }
    public bool HasRefreshConfiguration { get; public set; }
    public bool HasDataArchivalConfiguration { get; public set; }
    public Nullable`1<int> IndexesCount { get; public set; }
    public NodesTopology NodesTopology { get; public set; }
    public int ReplicationFactor { get; public set; }
    public bool DynamicNodesDistribution { get; public set; }
    public Dictionary`2<string, DeletionInProgressStatus> DeletionInProgress { get; public set; }
    public StudioEnvironment Environment { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAdmin();
    [CompilerGeneratedAttribute]
public void set_IsAdmin(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsEncrypted();
    [CompilerGeneratedAttribute]
public void set_IsEncrypted(bool value);
    [CompilerGeneratedAttribute]
public bool get_RejectClients();
    [CompilerGeneratedAttribute]
public void set_RejectClients(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasRevisionsConfiguration();
    [CompilerGeneratedAttribute]
public void set_HasRevisionsConfiguration(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasExpirationConfiguration();
    [CompilerGeneratedAttribute]
public void set_HasExpirationConfiguration(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasRefreshConfiguration();
    [CompilerGeneratedAttribute]
public void set_HasRefreshConfiguration(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasDataArchivalConfiguration();
    [CompilerGeneratedAttribute]
public void set_HasDataArchivalConfiguration(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_IndexesCount();
    [CompilerGeneratedAttribute]
public void set_IndexesCount(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public NodesTopology get_NodesTopology();
    [CompilerGeneratedAttribute]
public void set_NodesTopology(NodesTopology value);
    [CompilerGeneratedAttribute]
public int get_ReplicationFactor();
    [CompilerGeneratedAttribute]
public void set_ReplicationFactor(int value);
    [CompilerGeneratedAttribute]
public bool get_DynamicNodesDistribution();
    [CompilerGeneratedAttribute]
public void set_DynamicNodesDistribution(bool value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, DeletionInProgressStatus> get_DeletionInProgress();
    [CompilerGeneratedAttribute]
public void set_DeletionInProgress(Dictionary`2<string, DeletionInProgressStatus> value);
    [CompilerGeneratedAttribute]
public StudioEnvironment get_Environment();
    [CompilerGeneratedAttribute]
public void set_Environment(StudioEnvironment value);
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Client.ServerWide.Operations.DatabasePutResult : object {
    [CompilerGeneratedAttribute]
private long <RaftCommandIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private DatabaseTopology <Topology>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <NodesAddedTo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShardsDefined>k__BackingField;
    public long RaftCommandIndex { get; public set; }
    public string Name { get; public set; }
    public DatabaseTopology Topology { get; public set; }
    public List`1<string> NodesAddedTo { get; public set; }
    public bool ShardsDefined { get; public set; }
    [CompilerGeneratedAttribute]
public long get_RaftCommandIndex();
    [CompilerGeneratedAttribute]
public void set_RaftCommandIndex(long value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public DatabaseTopology get_Topology();
    [CompilerGeneratedAttribute]
public void set_Topology(DatabaseTopology value);
    [CompilerGeneratedAttribute]
public List`1<string> get_NodesAddedTo();
    [CompilerGeneratedAttribute]
public void set_NodesAddedTo(List`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_ShardsDefined();
    [CompilerGeneratedAttribute]
public void set_ShardsDefined(bool value);
}
public class Raven.Client.ServerWide.Operations.DatabaseRecordBuilder : object {
    private DatabaseTopology _shardTopology;
    private DatabaseRecord _databaseRecord;
    public static IDatabaseRecordBuilderInitializer Create();
    private sealed virtual override IBackupConfigurationBuilder Raven.Client.ServerWide.Operations.IBackupConfigurationBuilder.AddPeriodicBackup(PeriodicBackupConfiguration configuration);
    private sealed virtual override IConnectionStringConfigurationBuilder Raven.Client.ServerWide.Operations.IConnectionStringConfigurationBuilder.AddRavenConnectionString(RavenConnectionString connectionString);
    private sealed virtual override IConnectionStringConfigurationBuilder Raven.Client.ServerWide.Operations.IConnectionStringConfigurationBuilder.AddSqlConnectionString(SqlConnectionString connectionString);
    private sealed virtual override IConnectionStringConfigurationBuilder Raven.Client.ServerWide.Operations.IConnectionStringConfigurationBuilder.AddOlapConnectionString(OlapConnectionString connectionString);
    private sealed virtual override IConnectionStringConfigurationBuilder Raven.Client.ServerWide.Operations.IConnectionStringConfigurationBuilder.AddElasticSearchConnectionString(ElasticSearchConnectionString connectionString);
    private sealed virtual override IConnectionStringConfigurationBuilder Raven.Client.ServerWide.Operations.IConnectionStringConfigurationBuilder.AddQueueConnectionString(QueueConnectionString connectionString);
    private sealed virtual override IDatabaseRecordBuilder Raven.Client.ServerWide.Operations.IDatabaseRecordBuilderInitializer.Regular(string databaseName);
    private sealed virtual override IShardedDatabaseRecordBuilder Raven.Client.ServerWide.Operations.IDatabaseRecordBuilderInitializer.Sharded(string databaseName, Action`1<IShardedTopologyConfigurationBuilder> builder);
    private sealed virtual override IEtlConfigurationBuilder Raven.Client.ServerWide.Operations.IEtlConfigurationBuilder.AddRavenEtl(RavenEtlConfiguration configuration);
    private sealed virtual override IEtlConfigurationBuilder Raven.Client.ServerWide.Operations.IEtlConfigurationBuilder.AddSqlEtl(SqlEtlConfiguration configuration);
    private sealed virtual override IEtlConfigurationBuilder Raven.Client.ServerWide.Operations.IEtlConfigurationBuilder.AddElasticSearchEtl(ElasticSearchEtlConfiguration configuration);
    private sealed virtual override IEtlConfigurationBuilder Raven.Client.ServerWide.Operations.IEtlConfigurationBuilder.AddOlapEtl(OlapEtlConfiguration configuration);
    private sealed virtual override IEtlConfigurationBuilder Raven.Client.ServerWide.Operations.IEtlConfigurationBuilder.AddQueueEtl(QueueEtlConfiguration configuration);
    private sealed virtual override IIntegrationConfigurationBuilder Raven.Client.ServerWide.Operations.IIntegrationConfigurationBuilder.ConfigurePostgreSql(PostgreSqlConfiguration configuration);
    private sealed virtual override IOrchestratorTopologyConfigurationBuilder Raven.Client.ServerWide.Operations.ITopologyConfigurationBuilderBase<Raven.Client.ServerWide.Operations.IOrchestratorTopologyConfigurationBuilder>.AddNode(string nodeTag);
    private sealed virtual override ITopologyConfigurationBuilder Raven.Client.ServerWide.Operations.ITopologyConfigurationBuilderBase<Raven.Client.ServerWide.Operations.IShardTopologyConfigurationBuilder>.EnableDynamicNodesDistribution();
    private sealed virtual override ITopologyConfigurationBuilder Raven.Client.ServerWide.Operations.ITopologyConfigurationBuilderBase<Raven.Client.ServerWide.Operations.IOrchestratorTopologyConfigurationBuilder>.EnableDynamicNodesDistribution();
    private sealed virtual override ITopologyConfigurationBuilder Raven.Client.ServerWide.Operations.ITopologyConfigurationBuilderBase<Raven.Client.ServerWide.Operations.ITopologyConfigurationBuilder>.EnableDynamicNodesDistribution();
    private sealed virtual override IReplicationConfigurationBuilder Raven.Client.ServerWide.Operations.IReplicationConfigurationBuilder.AddExternalReplication(ExternalReplication configuration);
    private sealed virtual override IReplicationConfigurationBuilder Raven.Client.ServerWide.Operations.IReplicationConfigurationBuilder.AddPullReplicationSink(PullReplicationAsSink configuration);
    private sealed virtual override IReplicationConfigurationBuilder Raven.Client.ServerWide.Operations.IReplicationConfigurationBuilder.AddPullReplicationHub(PullReplicationDefinition configuration);
    private sealed virtual override IDatabaseRecordBuilderBase Raven.Client.ServerWide.Operations.IDatabaseRecordBuilderBase.Encrypted();
    private sealed virtual override IDatabaseRecordBuilderBase Raven.Client.ServerWide.Operations.IDatabaseRecordBuilderBase.WithLockMode(DatabaseLockMode lockMode);
    private sealed virtual override IDatabaseRecordBuilderBase Raven.Client.ServerWide.Operations.IDatabaseRecordBuilderBase.ConfigureDocumentsCompression(DocumentsCompressionConfiguration configuration);
    private sealed virtual override IDatabaseRecordBuilderBase Raven.Client.ServerWide.Operations.IDatabaseRecordBuilderBase.WithSorters(SorterDefinition[] sorterDefinitions);
    private sealed virtual override IDatabaseRecordBuilderBase Raven.Client.ServerWide.Operations.IDatabaseRecordBuilderBase.WithAnalyzers(AnalyzerDefinition[] analyzerDefinitions);
    private sealed virtual override IDatabaseRecordBuilderBase Raven.Client.ServerWide.Operations.IDatabaseRecordBuilderBase.WithIndexes(IndexDefinition[] indexDefinitions);
    private sealed virtual override IDatabaseRecordBuilderBase Raven.Client.ServerWide.Operations.IDatabaseRecordBuilderBase.WithSettings(Dictionary`2<string, string> settings);
    private sealed virtual override IDatabaseRecordBuilderBase Raven.Client.ServerWide.Operations.IDatabaseRecordBuilderBase.WithSettings(Action`1<Dictionary`2<string, string>> builder);
    private sealed virtual override IDatabaseRecordBuilderBase Raven.Client.ServerWide.Operations.IDatabaseRecordBuilderBase.ConfigureRevisions(RevisionsConfiguration configuration);
    private sealed virtual override IDatabaseRecordBuilderBase Raven.Client.ServerWide.Operations.IDatabaseRecordBuilderBase.WithEtls(Action`1<IEtlConfigurationBuilder> builder);
    private sealed virtual override IDatabaseRecordBuilderBase Raven.Client.ServerWide.Operations.IDatabaseRecordBuilderBase.WithBackups(Action`1<IBackupConfigurationBuilder> builder);
    private sealed virtual override IDatabaseRecordBuilderBase Raven.Client.ServerWide.Operations.IDatabaseRecordBuilderBase.WithReplication(Action`1<IReplicationConfigurationBuilder> builder);
    private sealed virtual override IDatabaseRecordBuilderBase Raven.Client.ServerWide.Operations.IDatabaseRecordBuilderBase.WithConnectionStrings(Action`1<IConnectionStringConfigurationBuilder> builder);
    private sealed virtual override IDatabaseRecordBuilderBase Raven.Client.ServerWide.Operations.IDatabaseRecordBuilderBase.ConfigureClient(ClientConfiguration configuration);
    private sealed virtual override IDatabaseRecordBuilderBase Raven.Client.ServerWide.Operations.IDatabaseRecordBuilderBase.ConfigureStudio(StudioConfiguration configuration);
    private sealed virtual override IDatabaseRecordBuilderBase Raven.Client.ServerWide.Operations.IDatabaseRecordBuilderBase.ConfigureRefresh(RefreshConfiguration configuration);
    private sealed virtual override IDatabaseRecordBuilderBase Raven.Client.ServerWide.Operations.IDatabaseRecordBuilderBase.ConfigureExpiration(ExpirationConfiguration configuration);
    private sealed virtual override IDatabaseRecordBuilderBase Raven.Client.ServerWide.Operations.IDatabaseRecordBuilderBase.ConfigureTimeSeries(TimeSeriesConfiguration configuration);
    private sealed virtual override IDatabaseRecordBuilderBase Raven.Client.ServerWide.Operations.IDatabaseRecordBuilderBase.WithIntegrations(Action`1<IIntegrationConfigurationBuilder> builder);
    private sealed virtual override DatabaseRecord Raven.Client.ServerWide.Operations.IDatabaseRecordBuilderInitializer.ToDatabaseRecord();
    private sealed virtual override DatabaseRecord Raven.Client.ServerWide.Operations.IDatabaseRecordBuilderBase.ToDatabaseRecord();
    private sealed virtual override IDatabaseRecordBuilderBase Raven.Client.ServerWide.Operations.IDatabaseRecordBuilderBase.Disabled();
    private sealed virtual override IShardedTopologyConfigurationBuilder Raven.Client.ServerWide.Operations.IShardedTopologyConfigurationBuilder.Orchestrator(OrchestratorTopology topology);
    private sealed virtual override IShardedTopologyConfigurationBuilder Raven.Client.ServerWide.Operations.IShardedTopologyConfigurationBuilder.Orchestrator(Action`1<IOrchestratorTopologyConfigurationBuilder> builder);
    private sealed virtual override IShardedTopologyConfigurationBuilder Raven.Client.ServerWide.Operations.IShardedTopologyConfigurationBuilder.AddShard(int shardNumber, DatabaseTopology topology);
    private sealed virtual override IShardedTopologyConfigurationBuilder Raven.Client.ServerWide.Operations.IShardedTopologyConfigurationBuilder.AddShard(int shardNumber, Action`1<IShardTopologyConfigurationBuilder> builder);
    private sealed virtual override IShardTopologyConfigurationBuilder Raven.Client.ServerWide.Operations.ITopologyConfigurationBuilderBase<Raven.Client.ServerWide.Operations.IShardTopologyConfigurationBuilder>.AddNode(string nodeTag);
    private sealed virtual override ITopologyConfigurationBuilder Raven.Client.ServerWide.Operations.ITopologyConfigurationBuilderBase<Raven.Client.ServerWide.Operations.ITopologyConfigurationBuilder>.AddNode(string nodeTag);
    private sealed virtual override IDatabaseRecordBuilderBase Raven.Client.ServerWide.Operations.IDatabaseRecordBuilder.WithTopology(DatabaseTopology topology);
    private sealed virtual override IDatabaseRecordBuilderBase Raven.Client.ServerWide.Operations.IDatabaseRecordBuilder.WithTopology(Action`1<ITopologyConfigurationBuilder> builder);
    private sealed virtual override IDatabaseRecordBuilderBase Raven.Client.ServerWide.Operations.IDatabaseRecordBuilder.WithReplicationFactor(int replicationFactor);
    private void WithName(string databaseName);
}
public class Raven.Client.ServerWide.Operations.DatabasesInfo : object {
    [CompilerGeneratedAttribute]
private List`1<DatabaseInfo> <Databases>k__BackingField;
    public List`1<DatabaseInfo> Databases { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<DatabaseInfo> get_Databases();
    [CompilerGeneratedAttribute]
public void set_Databases(List`1<DatabaseInfo> value);
}
public class Raven.Client.ServerWide.Operations.DatabaseState : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <TotalSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <TempBuffersSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <UpTime>k__BackingField;
    [CompilerGeneratedAttribute]
private BackupInfo <BackupInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <DocumentsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <Alerts>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <PerformanceHints>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LoadError>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <IndexingErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexRunningStatus <IndexingStatus>k__BackingField;
    public string Name { get; public set; }
    public Size TotalSize { get; public set; }
    public Size TempBuffersSize { get; public set; }
    public Nullable`1<TimeSpan> UpTime { get; public set; }
    public BackupInfo BackupInfo { get; public set; }
    public Nullable`1<long> DocumentsCount { get; public set; }
    public Nullable`1<long> Alerts { get; public set; }
    public Nullable`1<long> PerformanceHints { get; public set; }
    public string LoadError { get; public set; }
    public Nullable`1<long> IndexingErrors { get; public set; }
    public IndexRunningStatus IndexingStatus { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Size get_TotalSize();
    [CompilerGeneratedAttribute]
public void set_TotalSize(Size value);
    [CompilerGeneratedAttribute]
public Size get_TempBuffersSize();
    [CompilerGeneratedAttribute]
public void set_TempBuffersSize(Size value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_UpTime();
    [CompilerGeneratedAttribute]
public void set_UpTime(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public BackupInfo get_BackupInfo();
    [CompilerGeneratedAttribute]
public void set_BackupInfo(BackupInfo value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_DocumentsCount();
    [CompilerGeneratedAttribute]
public void set_DocumentsCount(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_Alerts();
    [CompilerGeneratedAttribute]
public void set_Alerts(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_PerformanceHints();
    [CompilerGeneratedAttribute]
public void set_PerformanceHints(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public string get_LoadError();
    [CompilerGeneratedAttribute]
public void set_LoadError(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_IndexingErrors();
    [CompilerGeneratedAttribute]
public void set_IndexingErrors(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public IndexRunningStatus get_IndexingStatus();
    [CompilerGeneratedAttribute]
public void set_IndexingStatus(IndexRunningStatus value);
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Client.ServerWide.Operations.DeleteDatabaseResult : object {
    [CompilerGeneratedAttribute]
private long <RaftCommandIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <PendingDeletes>k__BackingField;
    public long RaftCommandIndex { get; public set; }
    public String[] PendingDeletes { get; public set; }
    [CompilerGeneratedAttribute]
public long get_RaftCommandIndex();
    [CompilerGeneratedAttribute]
public void set_RaftCommandIndex(long value);
    [CompilerGeneratedAttribute]
public String[] get_PendingDeletes();
    [CompilerGeneratedAttribute]
public void set_PendingDeletes(String[] value);
}
public class Raven.Client.ServerWide.Operations.DeleteDatabasesOperation : object {
    private Parameters _parameters;
    public DeleteDatabasesOperation(string databaseName, int shardNumber, bool hardDelete, string fromNode, Nullable`1<TimeSpan> timeToWaitForConfirmation);
    public DeleteDatabasesOperation(string databaseName, bool hardDelete, string fromNode, Nullable`1<TimeSpan> timeToWaitForConfirmation);
    public DeleteDatabasesOperation(Parameters parameters);
    public sealed virtual RavenCommand`1<DeleteDatabaseResult> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.DisableDatabaseToggleResult : object {
    public bool Disabled;
    public string Name;
    public bool Success;
    public string Reason;
}
public class Raven.Client.ServerWide.Operations.DiskSpaceResult : object {
    [CompilerGeneratedAttribute]
private string <DriveName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VolumeLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalFreeSpaceInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalSizeInBytes>k__BackingField;
    public string DriveName { get; public set; }
    public string VolumeLabel { get; public set; }
    public long TotalFreeSpaceInBytes { get; public set; }
    public long TotalSizeInBytes { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DriveName();
    [CompilerGeneratedAttribute]
public void set_DriveName(string value);
    [CompilerGeneratedAttribute]
public string get_VolumeLabel();
    [CompilerGeneratedAttribute]
public void set_VolumeLabel(string value);
    [CompilerGeneratedAttribute]
public long get_TotalFreeSpaceInBytes();
    [CompilerGeneratedAttribute]
public void set_TotalFreeSpaceInBytes(long value);
    [CompilerGeneratedAttribute]
public long get_TotalSizeInBytes();
    [CompilerGeneratedAttribute]
public void set_TotalSizeInBytes(long value);
    public DynamicJsonValue ToJson();
}
public class Raven.Client.ServerWide.Operations.DocumentsCompression.DocumentCompressionConfigurationResult : object {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <RaftCommandIndex>k__BackingField;
    public Nullable`1<long> RaftCommandIndex { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_RaftCommandIndex();
    [CompilerGeneratedAttribute]
public void set_RaftCommandIndex(Nullable`1<long> value);
}
public class Raven.Client.ServerWide.Operations.DocumentsCompression.UpdateDocumentsCompressionConfigurationOperation : object {
    private DocumentsCompressionConfiguration _documentsCompressionConfiguration;
    public UpdateDocumentsCompressionConfigurationOperation(DocumentsCompressionConfiguration configuration);
    public sealed virtual RavenCommand`1<DocumentCompressionConfigurationResult> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.GetBuildNumberOperation : object {
    public sealed virtual RavenCommand`1<BuildNumber> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.ServerWide.Operations.GetDatabaseNamesOperation : object {
    private int _start;
    private int _pageSize;
    public GetDatabaseNamesOperation(int start, int pageSize);
    public sealed virtual RavenCommand`1<String[]> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.ServerWide.Operations.GetDatabaseRecordOperation : object {
    private string _database;
    public GetDatabaseRecordOperation(string database);
    public sealed virtual RavenCommand`1<DatabaseRecordWithEtag> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.ServerWide.Operations.GetServerWideOperationStateOperation : object {
    private long _id;
    public GetServerWideOperationStateOperation(long id);
    public sealed virtual RavenCommand`1<OperationState> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public interface Raven.Client.ServerWide.Operations.IBackupConfigurationBuilder {
    public abstract virtual IBackupConfigurationBuilder AddPeriodicBackup(PeriodicBackupConfiguration configuration);
}
public interface Raven.Client.ServerWide.Operations.IConnectionStringConfigurationBuilder {
    public abstract virtual IConnectionStringConfigurationBuilder AddRavenConnectionString(RavenConnectionString connectionString);
    public abstract virtual IConnectionStringConfigurationBuilder AddSqlConnectionString(SqlConnectionString connectionString);
    public abstract virtual IConnectionStringConfigurationBuilder AddOlapConnectionString(OlapConnectionString connectionString);
    public abstract virtual IConnectionStringConfigurationBuilder AddElasticSearchConnectionString(ElasticSearchConnectionString connectionString);
    public abstract virtual IConnectionStringConfigurationBuilder AddQueueConnectionString(QueueConnectionString connectionString);
}
public interface Raven.Client.ServerWide.Operations.IDatabaseRecordBuilder {
    public abstract virtual IDatabaseRecordBuilderBase WithTopology(DatabaseTopology topology);
    public abstract virtual IDatabaseRecordBuilderBase WithTopology(Action`1<ITopologyConfigurationBuilder> builder);
    public abstract virtual IDatabaseRecordBuilderBase WithReplicationFactor(int replicationFactor);
}
public interface Raven.Client.ServerWide.Operations.IDatabaseRecordBuilderBase {
    public abstract virtual DatabaseRecord ToDatabaseRecord();
    public abstract virtual IDatabaseRecordBuilderBase Disabled();
    public abstract virtual IDatabaseRecordBuilderBase Encrypted();
    public abstract virtual IDatabaseRecordBuilderBase WithLockMode(DatabaseLockMode lockMode);
    public abstract virtual IDatabaseRecordBuilderBase ConfigureDocumentsCompression(DocumentsCompressionConfiguration configuration);
    public abstract virtual IDatabaseRecordBuilderBase WithSorters(SorterDefinition[] sorterDefinitions);
    public abstract virtual IDatabaseRecordBuilderBase WithAnalyzers(AnalyzerDefinition[] analyzerDefinitions);
    public abstract virtual IDatabaseRecordBuilderBase WithIndexes(IndexDefinition[] indexDefinitions);
    public abstract virtual IDatabaseRecordBuilderBase WithSettings(Dictionary`2<string, string> settings);
    public abstract virtual IDatabaseRecordBuilderBase WithSettings(Action`1<Dictionary`2<string, string>> builder);
    public abstract virtual IDatabaseRecordBuilderBase ConfigureRevisions(RevisionsConfiguration configuration);
    public abstract virtual IDatabaseRecordBuilderBase WithEtls(Action`1<IEtlConfigurationBuilder> builder);
    public abstract virtual IDatabaseRecordBuilderBase WithBackups(Action`1<IBackupConfigurationBuilder> builder);
    public abstract virtual IDatabaseRecordBuilderBase WithReplication(Action`1<IReplicationConfigurationBuilder> builder);
    public abstract virtual IDatabaseRecordBuilderBase WithConnectionStrings(Action`1<IConnectionStringConfigurationBuilder> builder);
    public abstract virtual IDatabaseRecordBuilderBase ConfigureClient(ClientConfiguration configuration);
    public abstract virtual IDatabaseRecordBuilderBase ConfigureStudio(StudioConfiguration configuration);
    public abstract virtual IDatabaseRecordBuilderBase ConfigureRefresh(RefreshConfiguration configuration);
    public abstract virtual IDatabaseRecordBuilderBase ConfigureExpiration(ExpirationConfiguration configuration);
    public abstract virtual IDatabaseRecordBuilderBase ConfigureTimeSeries(TimeSeriesConfiguration configuration);
    public abstract virtual IDatabaseRecordBuilderBase WithIntegrations(Action`1<IIntegrationConfigurationBuilder> builder);
}
public interface Raven.Client.ServerWide.Operations.IDatabaseRecordBuilderInitializer {
    public abstract virtual IDatabaseRecordBuilder Regular(string databaseName);
    public abstract virtual IShardedDatabaseRecordBuilder Sharded(string databaseName, Action`1<IShardedTopologyConfigurationBuilder> builder);
    public abstract virtual DatabaseRecord ToDatabaseRecord();
}
public interface Raven.Client.ServerWide.Operations.IEtlConfigurationBuilder {
    public abstract virtual IEtlConfigurationBuilder AddRavenEtl(RavenEtlConfiguration configuration);
    public abstract virtual IEtlConfigurationBuilder AddSqlEtl(SqlEtlConfiguration configuration);
    public abstract virtual IEtlConfigurationBuilder AddElasticSearchEtl(ElasticSearchEtlConfiguration configuration);
    public abstract virtual IEtlConfigurationBuilder AddOlapEtl(OlapEtlConfiguration configuration);
    public abstract virtual IEtlConfigurationBuilder AddQueueEtl(QueueEtlConfiguration configuration);
}
public interface Raven.Client.ServerWide.Operations.IIntegrationConfigurationBuilder {
    public abstract virtual IIntegrationConfigurationBuilder ConfigurePostgreSql(PostgreSqlConfiguration configuration);
}
public class Raven.Client.ServerWide.Operations.IndexOptimizeResult : object {
    public string IndexName;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldPersist>k__BackingField;
    public string Message { get; public set; }
    public bool ShouldPersist { get; }
    private bool Raven.Client.Documents.Operations.IOperationResult.CanMerge { get; }
    public IndexOptimizeResult(string indexName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    public sealed virtual DynamicJsonValue ToJson();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ShouldPersist();
    private sealed virtual override bool Raven.Client.Documents.Operations.IOperationResult.get_CanMerge();
    private sealed virtual override void Raven.Client.Documents.Operations.IOperationResult.MergeWith(IOperationResult result);
}
public class Raven.Client.ServerWide.Operations.Integrations.IntegrationConfigurations : object {
    public PostgreSqlConfiguration PostgreSql;
}
public class Raven.Client.ServerWide.Operations.Integrations.PostgreSQL.PostgreSqlAuthenticationConfiguration : object {
    public List`1<PostgreSqlUser> Users;
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Client.ServerWide.Operations.Integrations.PostgreSQL.PostgreSqlConfiguration : object {
    public PostgreSqlAuthenticationConfiguration Authentication;
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Client.ServerWide.Operations.Integrations.PostgreSQL.PostgreSqlUser : object {
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    public string Username { get; public set; }
    public string Password { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public void set_Username(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    public sealed virtual DynamicJsonValue ToJson();
}
public interface Raven.Client.ServerWide.Operations.IOrchestratorTopologyConfigurationBuilder {
}
public class Raven.Client.ServerWide.Operations.IoStatsResult : object {
    [CompilerGeneratedAttribute]
private double <IoReadOperations>k__BackingField;
    [CompilerGeneratedAttribute]
private double <IoWriteOperations>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ReadThroughputInKb>k__BackingField;
    [CompilerGeneratedAttribute]
private long <WriteThroughputInKb>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <QueueLength>k__BackingField;
    public double IoReadOperations { get; public set; }
    public double IoWriteOperations { get; public set; }
    public long ReadThroughputInKb { get; public set; }
    public long WriteThroughputInKb { get; public set; }
    public Nullable`1<long> QueueLength { get; public set; }
    [CompilerGeneratedAttribute]
public double get_IoReadOperations();
    [CompilerGeneratedAttribute]
public void set_IoReadOperations(double value);
    [CompilerGeneratedAttribute]
public double get_IoWriteOperations();
    [CompilerGeneratedAttribute]
public void set_IoWriteOperations(double value);
    [CompilerGeneratedAttribute]
public long get_ReadThroughputInKb();
    [CompilerGeneratedAttribute]
public void set_ReadThroughputInKb(long value);
    [CompilerGeneratedAttribute]
public long get_WriteThroughputInKb();
    [CompilerGeneratedAttribute]
public void set_WriteThroughputInKb(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_QueueLength();
    [CompilerGeneratedAttribute]
public void set_QueueLength(Nullable`1<long> value);
    public DynamicJsonValue ToJson();
}
public interface Raven.Client.ServerWide.Operations.IReplicationConfigurationBuilder {
    public abstract virtual IReplicationConfigurationBuilder AddExternalReplication(ExternalReplication configuration);
    public abstract virtual IReplicationConfigurationBuilder AddPullReplicationSink(PullReplicationAsSink configuration);
    public abstract virtual IReplicationConfigurationBuilder AddPullReplicationHub(PullReplicationDefinition configuration);
}
public interface Raven.Client.ServerWide.Operations.IServerOperation {
    public abstract virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public interface Raven.Client.ServerWide.Operations.IServerOperation`1 {
    public abstract virtual RavenCommand`1<T> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public interface Raven.Client.ServerWide.Operations.IShardedDatabaseRecordBuilder {
}
public interface Raven.Client.ServerWide.Operations.IShardedTopologyConfigurationBuilder {
    public abstract virtual IShardedTopologyConfigurationBuilder Orchestrator(OrchestratorTopology topology);
    public abstract virtual IShardedTopologyConfigurationBuilder Orchestrator(Action`1<IOrchestratorTopologyConfigurationBuilder> builder);
    public abstract virtual IShardedTopologyConfigurationBuilder AddShard(int shardNumber, DatabaseTopology topology);
    public abstract virtual IShardedTopologyConfigurationBuilder AddShard(int shardNumber, Action`1<IShardTopologyConfigurationBuilder> builder);
}
public interface Raven.Client.ServerWide.Operations.IShardTopologyConfigurationBuilder {
}
public interface Raven.Client.ServerWide.Operations.ITopologyConfigurationBuilder {
}
public interface Raven.Client.ServerWide.Operations.ITopologyConfigurationBuilderBase`1 {
    public abstract virtual TSelf AddNode(string nodeTag);
    public abstract virtual ITopologyConfigurationBuilder EnableDynamicNodesDistribution();
}
public class Raven.Client.ServerWide.Operations.Logs.GetLogsConfigurationOperation : object {
    public sealed virtual RavenCommand`1<GetLogsConfigurationResult> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.Logs.GetLogsConfigurationResult : object {
    [CompilerGeneratedAttribute]
private LogMode <CurrentMode>k__BackingField;
    [CompilerGeneratedAttribute]
private LogMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseUtcTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RetentionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Size> <RetentionSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Compress>k__BackingField;
    public LogMode CurrentMode { get; public set; }
    public LogMode Mode { get; public set; }
    public string Path { get; public set; }
    public bool UseUtcTime { get; public set; }
    public TimeSpan RetentionTime { get; public set; }
    public Nullable`1<Size> RetentionSize { get; public set; }
    public bool Compress { get; public set; }
    [CompilerGeneratedAttribute]
public LogMode get_CurrentMode();
    [CompilerGeneratedAttribute]
public void set_CurrentMode(LogMode value);
    [CompilerGeneratedAttribute]
public LogMode get_Mode();
    [CompilerGeneratedAttribute]
public void set_Mode(LogMode value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public bool get_UseUtcTime();
    [CompilerGeneratedAttribute]
public void set_UseUtcTime(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RetentionTime();
    [CompilerGeneratedAttribute]
public void set_RetentionTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public Nullable`1<Size> get_RetentionSize();
    [CompilerGeneratedAttribute]
public void set_RetentionSize(Nullable`1<Size> value);
    [CompilerGeneratedAttribute]
public bool get_Compress();
    [CompilerGeneratedAttribute]
public void set_Compress(bool value);
}
public class Raven.Client.ServerWide.Operations.Logs.SetLogsConfigurationOperation : object {
    private Parameters _parameters;
    public SetLogsConfigurationOperation(Parameters parameters);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.Migration.OfflineMigrationConfiguration : object {
    private static string StorageExporterExecutable;
    private static string EsentDBDataFile;
    private static string EsentFSDataFile;
    private static string VoronDataFile;
    private static string VoronBackupFile;
    private static string EsentBackupFile;
    [CompilerGeneratedAttribute]
private string <DataDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DataExporterFullPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <BatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRavenFs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCompressed>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JournalsPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LogFileSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxVerPages>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <EncryptionKeyBitsSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <Timeout>k__BackingField;
    [CompilerGeneratedAttribute]
private DatabaseRecord <DatabaseRecord>k__BackingField;
    public string DataDirectory { get; public set; }
    public string OutputFilePath { get; public set; }
    public string DataExporterFullPath { get; public set; }
    public Nullable`1<int> BatchSize { get; public set; }
    public bool IsRavenFs { get; public set; }
    public bool IsCompressed { get; public set; }
    public string JournalsPath { get; public set; }
    public Nullable`1<int> LogFileSize { get; public set; }
    public Nullable`1<int> MaxVerPages { get; public set; }
    public string EncryptionKey { get; public set; }
    public string EncryptionAlgorithm { get; public set; }
    public Nullable`1<int> EncryptionKeyBitsSize { get; public set; }
    public Nullable`1<TimeSpan> Timeout { get; public set; }
    public DatabaseRecord DatabaseRecord { get; public set; }
    public OfflineMigrationConfiguration(string dataDirectory, string dataExporterFullPath, DatabaseRecord databaseRecord);
    [CompilerGeneratedAttribute]
public string get_DataDirectory();
    [CompilerGeneratedAttribute]
public void set_DataDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_OutputFilePath();
    [CompilerGeneratedAttribute]
public void set_OutputFilePath(string value);
    [CompilerGeneratedAttribute]
public string get_DataExporterFullPath();
    [CompilerGeneratedAttribute]
public void set_DataExporterFullPath(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_BatchSize();
    [CompilerGeneratedAttribute]
public void set_BatchSize(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_IsRavenFs();
    [CompilerGeneratedAttribute]
public void set_IsRavenFs(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsCompressed();
    [CompilerGeneratedAttribute]
public void set_IsCompressed(bool value);
    [CompilerGeneratedAttribute]
public string get_JournalsPath();
    [CompilerGeneratedAttribute]
public void set_JournalsPath(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LogFileSize();
    [CompilerGeneratedAttribute]
public void set_LogFileSize(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxVerPages();
    [CompilerGeneratedAttribute]
public void set_MaxVerPages(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_EncryptionKey();
    [CompilerGeneratedAttribute]
public void set_EncryptionKey(string value);
    [CompilerGeneratedAttribute]
public string get_EncryptionAlgorithm();
    [CompilerGeneratedAttribute]
public void set_EncryptionAlgorithm(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_EncryptionKeyBitsSize();
    [CompilerGeneratedAttribute]
public void set_EncryptionKeyBitsSize(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_Timeout();
    [CompilerGeneratedAttribute]
public void set_Timeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public DatabaseRecord get_DatabaseRecord();
    [CompilerGeneratedAttribute]
public void set_DatabaseRecord(DatabaseRecord value);
    internal void Validate();
    internal static string EffectiveDataExporterFullPath(string fullPath);
    internal static void ValidateDataDirectory(string dataDirectory);
    internal static void ValidateExporterPath(string dataExporterPath);
    internal ValueTuple`2<string, string> GenerateExporterCommandLine();
    [CompilerGeneratedAttribute]
internal static string <GenerateExporterCommandLine>g__EnsureStringsAreQuoted|68_0(string path);
}
public class Raven.Client.ServerWide.Operations.Migration.OfflineMigrationOperation : object {
    private OfflineMigrationConfiguration _configuration;
    public OfflineMigrationOperation(OfflineMigrationConfiguration configuration);
    public sealed virtual RavenCommand`1<OperationIdResult> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.ModifyConflictSolverOperation : object {
    private string _database;
    public Dictionary`2<string, ScriptResolver> CollectionByScript;
    public bool ResolveToLatest;
    public ModifyConflictSolverOperation(string database, Dictionary`2<string, ScriptResolver> collectionByScript, bool resolveToLatest);
    public sealed virtual RavenCommand`1<ModifySolverResult> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.ServerWide.Operations.ModifyDatabaseTopologyOperation : object {
    private string _databaseName;
    private DatabaseTopology _databaseTopology;
    public ModifyDatabaseTopologyOperation(string databaseName, DatabaseTopology databaseTopology);
    public ModifyDatabaseTopologyOperation(string databaseName, int shardNumber, DatabaseTopology databaseTopology);
    public sealed virtual RavenCommand`1<ModifyDatabaseTopologyResult> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.ServerWide.Operations.ModifyDatabaseTopologyResult : object {
    [CompilerGeneratedAttribute]
private long <RaftCommandIndex>k__BackingField;
    public long RaftCommandIndex { get; public set; }
    [CompilerGeneratedAttribute]
public long get_RaftCommandIndex();
    [CompilerGeneratedAttribute]
public void set_RaftCommandIndex(long value);
}
public class Raven.Client.ServerWide.Operations.ModifySolverResult : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <RaftCommandIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private ConflictSolver <Solver>k__BackingField;
    public string Key { get; public set; }
    public Nullable`1<long> RaftCommandIndex { get; public set; }
    public ConflictSolver Solver { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_RaftCommandIndex();
    [CompilerGeneratedAttribute]
public void set_RaftCommandIndex(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public ConflictSolver get_Solver();
    [CompilerGeneratedAttribute]
public void set_Solver(ConflictSolver value);
}
public class Raven.Client.ServerWide.Operations.MountPointUsage : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private DiskSpaceResult <DiskSpaceResult>k__BackingField;
    [CompilerGeneratedAttribute]
private IoStatsResult <IoStatsResult>k__BackingField;
    [CompilerGeneratedAttribute]
private long <UsedSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private long <UsedSpaceByTempBuffers>k__BackingField;
    public string Name { get; public set; }
    public string Type { get; public set; }
    public DiskSpaceResult DiskSpaceResult { get; public set; }
    public IoStatsResult IoStatsResult { get; public set; }
    public long UsedSpace { get; public set; }
    public long UsedSpaceByTempBuffers { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public DiskSpaceResult get_DiskSpaceResult();
    [CompilerGeneratedAttribute]
public void set_DiskSpaceResult(DiskSpaceResult value);
    [CompilerGeneratedAttribute]
public IoStatsResult get_IoStatsResult();
    [CompilerGeneratedAttribute]
public void set_IoStatsResult(IoStatsResult value);
    [CompilerGeneratedAttribute]
public long get_UsedSpace();
    [CompilerGeneratedAttribute]
public void set_UsedSpace(long value);
    [CompilerGeneratedAttribute]
public long get_UsedSpaceByTempBuffers();
    [CompilerGeneratedAttribute]
public void set_UsedSpaceByTempBuffers(long value);
    public DynamicJsonValue ToJson();
}
public class Raven.Client.ServerWide.Operations.NodeId : object {
    public string NodeTag;
    public string NodeUrl;
    public string ResponsibleNode;
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Client.ServerWide.Operations.NodesTopology : object {
    [CompilerGeneratedAttribute]
private List`1<NodeId> <Members>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<NodeId> <Promotables>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<NodeId> <Rehabs>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, DatabaseGroupNodeStatus> <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <PriorityOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DynamicNodesDistribution>k__BackingField;
    public List`1<NodeId> Members { get; public set; }
    public List`1<NodeId> Promotables { get; public set; }
    public List`1<NodeId> Rehabs { get; public set; }
    public Dictionary`2<string, DatabaseGroupNodeStatus> Status { get; public set; }
    public List`1<string> PriorityOrder { get; public set; }
    public bool DynamicNodesDistribution { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<NodeId> get_Members();
    [CompilerGeneratedAttribute]
public void set_Members(List`1<NodeId> value);
    [CompilerGeneratedAttribute]
public List`1<NodeId> get_Promotables();
    [CompilerGeneratedAttribute]
public void set_Promotables(List`1<NodeId> value);
    [CompilerGeneratedAttribute]
public List`1<NodeId> get_Rehabs();
    [CompilerGeneratedAttribute]
public void set_Rehabs(List`1<NodeId> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, DatabaseGroupNodeStatus> get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(Dictionary`2<string, DatabaseGroupNodeStatus> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_PriorityOrder();
    [CompilerGeneratedAttribute]
public void set_PriorityOrder(List`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_DynamicNodesDistribution();
    [CompilerGeneratedAttribute]
public void set_DynamicNodesDistribution(bool value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Client.ServerWide.Operations.OngoingTasks.DeleteServerWideTaskOperation : object {
    private string _name;
    private OngoingTaskType _type;
    public DeleteServerWideTaskOperation(string name, OngoingTaskType type);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.OngoingTasks.GetServerWideExternalReplicationOperation : object {
    private string _name;
    public GetServerWideExternalReplicationOperation(string name);
    public sealed virtual RavenCommand`1<ServerWideExternalReplication> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.OngoingTasks.GetServerWideExternalReplicationsOperation : object {
    public sealed virtual RavenCommand`1<ServerWideExternalReplication[]> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public interface Raven.Client.ServerWide.Operations.OngoingTasks.IServerWideTask {
    public String[] ExcludedDatabases { get; public set; }
    public abstract virtual String[] get_ExcludedDatabases();
    public abstract virtual void set_ExcludedDatabases(String[] value);
}
public class Raven.Client.ServerWide.Operations.OngoingTasks.PutServerWideExternalReplicationOperation : object {
    private ServerWideExternalReplication _configuration;
    public PutServerWideExternalReplicationOperation(ServerWideExternalReplication configuration);
    public sealed virtual RavenCommand`1<ServerWideExternalReplicationResponse> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
[ExtensionAttribute]
internal static class Raven.Client.ServerWide.Operations.OngoingTasks.ServerWideExtensions : object {
    [ExtensionAttribute]
internal static bool IsExcluded(IServerWideTask task, string databaseName);
}
public class Raven.Client.ServerWide.Operations.OngoingTasks.ServerWideExternalReplication : object {
    internal static string NamePrefix;
    internal static string RavenConnectionStringPrefix;
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TaskId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MentorNode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PinToMentorNode>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <DelayReplicationFor>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <TopologyDiscoveryUrls>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ExcludedDatabases>k__BackingField;
    public bool Disabled { get; public set; }
    public long TaskId { get; public set; }
    public string Name { get; public set; }
    public string MentorNode { get; public set; }
    public bool PinToMentorNode { get; public set; }
    public TimeSpan DelayReplicationFor { get; public set; }
    public String[] TopologyDiscoveryUrls { get; public set; }
    public String[] ExcludedDatabases { get; public set; }
    private static ServerWideExternalReplication();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Disabled();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Disabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_TaskId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TaskId(long value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MentorNode();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MentorNode(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PinToMentorNode();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PinToMentorNode(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_DelayReplicationFor();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DelayReplicationFor(TimeSpan value);
    [CompilerGeneratedAttribute]
public String[] get_TopologyDiscoveryUrls();
    [CompilerGeneratedAttribute]
public void set_TopologyDiscoveryUrls(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_ExcludedDatabases();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExcludedDatabases(String[] value);
    public sealed virtual string GetDefaultTaskName();
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Client.ServerWide.Operations.OngoingTasks.ServerWideExternalReplicationResponse : ServerWideTaskResponse {
}
public class Raven.Client.ServerWide.Operations.OngoingTasks.ServerWideTaskResponse : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RaftCommandIndex>k__BackingField;
    public string Name { get; public set; }
    public long RaftCommandIndex { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public long get_RaftCommandIndex();
    [CompilerGeneratedAttribute]
public void set_RaftCommandIndex(long value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Client.ServerWide.Operations.OngoingTasks.ToggleServerWideTaskStateOperation : object {
    private string _name;
    private OngoingTaskType _type;
    private bool _disable;
    public ToggleServerWideTaskStateOperation(string name, OngoingTaskType type, bool disable);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.OsInfo : object {
    [CompilerGeneratedAttribute]
private OSType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Is64Bit>k__BackingField;
    public OSType Type { get; public set; }
    public string FullName { get; public set; }
    public string Version { get; public set; }
    public string BuildVersion { get; public set; }
    public bool Is64Bit { get; public set; }
    [CompilerGeneratedAttribute]
public OSType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(OSType value);
    [CompilerGeneratedAttribute]
public string get_FullName();
    [CompilerGeneratedAttribute]
public void set_FullName(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public string get_BuildVersion();
    [CompilerGeneratedAttribute]
public void set_BuildVersion(string value);
    [CompilerGeneratedAttribute]
public bool get_Is64Bit();
    [CompilerGeneratedAttribute]
public void set_Is64Bit(bool value);
    public virtual bool Equals(object obj);
    private bool Equals(OsInfo other);
    public virtual int GetHashCode();
    public sealed virtual DynamicJsonValue ToJson();
}
public enum Raven.Client.ServerWide.Operations.OSType : Enum {
    public int value__;
    public static OSType Windows;
    public static OSType Linux;
    public static OSType MacOS;
}
public class Raven.Client.ServerWide.Operations.PromoteDatabaseNodeOperation : object {
    private string _databaseName;
    private string _node;
    public PromoteDatabaseNodeOperation(string databaseName, string node);
    public PromoteDatabaseNodeOperation(string databaseName, int shardNumber, string node);
    public sealed virtual RavenCommand`1<DatabasePutResult> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.ServerWide.Operations.ReorderDatabaseMembersOperation : object {
    private string _database;
    private Parameters _parameters;
    public ReorderDatabaseMembersOperation(string database, List`1<string> order);
    public ReorderDatabaseMembersOperation(string database, List`1<string> order, bool fixedTopology);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.RestoreBackupOperation : object {
    private RestoreBackupConfigurationBase _restoreConfiguration;
    public string NodeTag;
    public RestoreBackupOperation(RestoreBackupConfigurationBase restoreConfiguration);
    public RestoreBackupOperation(RestoreBackupConfigurationBase restoreConfiguration, string nodeTag);
    public sealed virtual RavenCommand`1<OperationIdResult> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.ServerWide.Operations.RestoreProgress : SmugglerProgress {
    public Counts SnapshotRestore { get; }
    public FileCounts Files { get; }
    public RestoreProgress(RestoreResult result);
    public Counts get_SnapshotRestore();
    public FileCounts get_Files();
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Client.ServerWide.Operations.RestoreResult : SmugglerResult {
    [CompilerGeneratedAttribute]
private string <DataDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JournalStoragePath>k__BackingField;
    [CompilerGeneratedAttribute]
private Counts <SnapshotRestore>k__BackingField;
    [CompilerGeneratedAttribute]
private FileCounts <Files>k__BackingField;
    public string DataDirectory { get; public set; }
    public string JournalStoragePath { get; public set; }
    public Counts SnapshotRestore { get; public set; }
    public FileCounts Files { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DataDirectory();
    [CompilerGeneratedAttribute]
public void set_DataDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_JournalStoragePath();
    [CompilerGeneratedAttribute]
public void set_JournalStoragePath(string value);
    [CompilerGeneratedAttribute]
public Counts get_SnapshotRestore();
    [CompilerGeneratedAttribute]
public void set_SnapshotRestore(Counts value);
    [CompilerGeneratedAttribute]
public FileCounts get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(FileCounts value);
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Client.ServerWide.Operations.ServerOperationExecutor : object {
    private ConcurrentDictionary`2<string, ServerOperationExecutor> _cache;
    private string _nodeTag;
    private DocumentStoreBase _store;
    private ClusterRequestExecutor _requestExecutor;
    private ClusterRequestExecutor _initialRequestExecutor;
    public ServerOperationExecutor(DocumentStoreBase store);
    private ServerOperationExecutor(DocumentStoreBase store, ClusterRequestExecutor requestExecutor, ClusterRequestExecutor initialRequestExecutor, ConcurrentDictionary`2<string, ServerOperationExecutor> cache, string nodeTag);
    public sealed virtual void Dispose();
    public ServerOperationExecutor ForNode(string nodeTag);
    public void Send(IServerOperation operation);
    public TResult Send(IServerOperation`1<TResult> operation);
    [AsyncStateMachineAttribute("Raven.Client.ServerWide.Operations.ServerOperationExecutor/<SendAsync>d__11")]
public Task SendAsync(IServerOperation operation, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Client.ServerWide.Operations.ServerOperationExecutor/<SendAsync>d__12`1")]
public Task`1<TResult> SendAsync(IServerOperation`1<TResult> operation, CancellationToken token);
    public Operation Send(IServerOperation`1<OperationIdResult> operation);
    [AsyncStateMachineAttribute("Raven.Client.ServerWide.Operations.ServerOperationExecutor/<SendAsync>d__14")]
public Task`1<Operation> SendAsync(IServerOperation`1<OperationIdResult> operation, CancellationToken token);
    private Topology GetTopology(ClusterRequestExecutor requestExecutor);
    private static ClusterRequestExecutor CreateRequestExecutor(DocumentStoreBase store);
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_0(object sender, EventArgs args);
    [CompilerGeneratedAttribute]
private ServerOperationExecutor <ForNode>b__8_0(string tag);
}
public class Raven.Client.ServerWide.Operations.ServerWideOperation : Operation {
    public ServerWideOperation(RequestExecutor requestExecutor, DocumentConventions conventions, long id, string nodeTag);
    protected virtual RavenCommand`1<OperationState> GetOperationStateCommand(DocumentConventions conventions, long id, string nodeTag);
    protected virtual RavenCommand GetKillOperationCommand(long id, string nodeTag);
}
public class Raven.Client.ServerWide.Operations.SetDatabaseDynamicDistributionOperation : object {
    private bool _allowDynamicDistribution;
    private string _databaseName;
    public SetDatabaseDynamicDistributionOperation(string databaseName, bool allowDynamicDistribution);
    private sealed virtual override RavenCommand Raven.Client.ServerWide.Operations.IServerOperation.GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.SetDatabasesLockOperation : object {
    private Parameters _parameters;
    public SetDatabasesLockOperation(string databaseName, DatabaseLockMode mode);
    public SetDatabasesLockOperation(Parameters parameters);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.Sorters.DeleteServerWideSorterOperation : object {
    private string _sorterName;
    public DeleteServerWideSorterOperation(string sorterName);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.Sorters.PutServerWideSortersOperation : object {
    private SorterDefinition[] _sortersToAdd;
    public PutServerWideSortersOperation(SorterDefinition[] sortersToAdd);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.ToggleDatabasesStateOperation : object {
    private bool _disable;
    private Parameters _parameters;
    public ToggleDatabasesStateOperation(string databaseName, bool disable);
    public ToggleDatabasesStateOperation(String[] databaseNames, bool disable);
    public ToggleDatabasesStateOperation(Parameters parameters, bool disable);
    public sealed virtual RavenCommand`1<DisableDatabaseToggleResult> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.TrafficWatch.GetTrafficWatchConfigurationOperation : object {
    public sealed virtual RavenCommand`1<Parameters> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Operations.TrafficWatch.PutTrafficWatchConfigurationOperation : object {
    private Parameters _parameters;
    public PutTrafficWatchConfigurationOperation(Parameters parameters);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public enum Raven.Client.ServerWide.Operations.TrafficWatch.TrafficWatchMode : Enum {
    public int value__;
    public static TrafficWatchMode None;
    public static TrafficWatchMode Off;
    public static TrafficWatchMode ToLogFile;
}
public class Raven.Client.ServerWide.Operations.UpdateDatabaseOperation : object {
    private DatabaseRecord _databaseRecord;
    private long _etag;
    private int _replicationFactor;
    public UpdateDatabaseOperation(DatabaseRecord databaseRecord, long etag);
    public UpdateDatabaseOperation(DatabaseRecord databaseRecord, int replicationFactor, long etag);
    public sealed virtual RavenCommand`1<DatabasePutResult> GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.ServerWide.Operations.UpdateUnusedDatabasesOperation : object {
    private string _database;
    private Parameters _parameters;
    public UpdateUnusedDatabasesOperation(string database, HashSet`1<string> unusedDatabaseIds);
    public UpdateUnusedDatabasesOperation(string database, HashSet`1<string> unusedDatabaseIds, bool validate);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.OrchestratorTopology : DatabaseTopology {
    public void Update(DatabaseTopology topology);
}
public class Raven.Client.ServerWide.PromotableTask : object {
    private string _tag;
    private string _url;
    private string _name;
    private string _mentorNode;
    public PromotableTask(string tag, string url, string name, string mentorNode);
    private static ulong CalculateStringHash(string s);
    public sealed virtual ulong GetTaskKey();
    public sealed virtual string GetMentorNode();
    public sealed virtual string GetDefaultTaskName();
    public sealed virtual string GetTaskName();
    public sealed virtual bool IsResourceIntensive();
    public sealed virtual bool IsPinnedToMentorNode();
}
public enum Raven.Client.ServerWide.RachisState : Enum {
    public int value__;
    public static RachisState Passive;
    public static RachisState Candidate;
    public static RachisState Follower;
    public static RachisState LeaderElect;
    public static RachisState Leader;
}
public class Raven.Client.ServerWide.ScriptResolver : object {
    [CompilerGeneratedAttribute]
private string <Script>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastModifiedTime>k__BackingField;
    public string Script { get; public set; }
    public DateTime LastModifiedTime { get; }
    [CompilerGeneratedAttribute]
public string get_Script();
    [CompilerGeneratedAttribute]
public void set_Script(string value);
    [CompilerGeneratedAttribute]
public DateTime get_LastModifiedTime();
    public object ToJson();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Raven.Client.ServerWide.Sharding.AddDatabaseShardOperation : object {
    private string _databaseName;
    private Nullable`1<int> _shardNumber;
    private String[] _nodes;
    private Nullable`1<int> _replicationFactor;
    private Nullable`1<bool> _dynamicNodeDistribution;
    public AddDatabaseShardOperation(string databaseName, Nullable`1<int> shardNumber, Nullable`1<bool> dynamicNodeDistribution);
    public AddDatabaseShardOperation(string databaseName, String[] nodes, Nullable`1<int> shardNumber, Nullable`1<bool> dynamicNodeDistribution);
    public AddDatabaseShardOperation(string databaseName, Nullable`1<int> replicationFactor, Nullable`1<int> shardNumber, Nullable`1<bool> dynamicNodeDistribution);
    public sealed virtual RavenCommand`1<AddDatabaseShardResult> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Sharding.AddDatabaseShardResult : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ShardNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private DatabaseTopology <ShardTopology>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RaftCommandIndex>k__BackingField;
    public string Name { get; public set; }
    public int ShardNumber { get; public set; }
    public DatabaseTopology ShardTopology { get; public set; }
    public long RaftCommandIndex { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_ShardNumber();
    [CompilerGeneratedAttribute]
public void set_ShardNumber(int value);
    [CompilerGeneratedAttribute]
public DatabaseTopology get_ShardTopology();
    [CompilerGeneratedAttribute]
public void set_ShardTopology(DatabaseTopology value);
    [CompilerGeneratedAttribute]
public long get_RaftCommandIndex();
    [CompilerGeneratedAttribute]
public void set_RaftCommandIndex(long value);
}
public class Raven.Client.ServerWide.Sharding.AddNodeToOrchestratorTopologyOperation : object {
    private string _databaseName;
    private string _node;
    public AddNodeToOrchestratorTopologyOperation(string databaseName, string node);
    public sealed virtual RavenCommand`1<ModifyOrchestratorTopologyResult> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Sharding.AddPrefixedShardingSettingOperation : object {
    private PrefixedShardingSetting _setting;
    public AddPrefixedShardingSettingOperation(PrefixedShardingSetting setting);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public class Raven.Client.ServerWide.Sharding.DeletePrefixedShardingSettingOperation : object {
    private string _prefix;
    public DeletePrefixedShardingSettingOperation(string prefix);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
public enum Raven.Client.ServerWide.Sharding.MigrationStatus : Enum {
    public int value__;
    public static MigrationStatus Pending;
    public static MigrationStatus Moving;
    public static MigrationStatus Moved;
    public static MigrationStatus OwnershipTransferred;
}
public class Raven.Client.ServerWide.Sharding.ModifyOrchestratorTopologyResult : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private OrchestratorTopology <OrchestratorTopology>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RaftCommandIndex>k__BackingField;
    public string Name { get; public set; }
    public OrchestratorTopology OrchestratorTopology { get; public set; }
    public long RaftCommandIndex { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public OrchestratorTopology get_OrchestratorTopology();
    [CompilerGeneratedAttribute]
public void set_OrchestratorTopology(OrchestratorTopology value);
    [CompilerGeneratedAttribute]
public long get_RaftCommandIndex();
    [CompilerGeneratedAttribute]
public void set_RaftCommandIndex(long value);
}
public class Raven.Client.ServerWide.Sharding.OrchestratorConfiguration : object {
    public OrchestratorTopology Topology;
}
internal enum Raven.Client.ServerWide.Sharding.PrefixedCommandType : Enum {
    public int value__;
    public static PrefixedCommandType Add;
    public static PrefixedCommandType Delete;
    public static PrefixedCommandType Update;
}
internal abstract class Raven.Client.ServerWide.Sharding.PrefixedShardingCommand : RavenCommand {
    private DocumentConventions _conventions;
    private PrefixedShardingSetting _setting;
    [CompilerGeneratedAttribute]
private string <RaftUniqueRequestId>k__BackingField;
    protected PrefixedCommandType CommandType { get; }
    public bool IsReadRequest { get; }
    public string RaftUniqueRequestId { get; }
    protected PrefixedShardingCommand(DocumentConventions conventions, PrefixedShardingSetting setting);
    protected abstract virtual PrefixedCommandType get_CommandType();
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RaftUniqueRequestId();
}
public class Raven.Client.ServerWide.Sharding.PrefixedShardingSetting : object {
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    private Byte[] _prefixBytesLowerCase;
    [CompilerGeneratedAttribute]
private List`1<int> <Shards>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BucketRangeStart>k__BackingField;
    public string Prefix { get; public set; }
    internal Byte[] PrefixBytesLowerCase { get; }
    public List`1<int> Shards { get; public set; }
    [ForceJsonSerializationAttribute]
internal int BucketRangeStart { get; internal set; }
    public PrefixedShardingSetting(string prefix);
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public void set_Prefix(string value);
    internal Byte[] get_PrefixBytesLowerCase();
    [CompilerGeneratedAttribute]
public List`1<int> get_Shards();
    [CompilerGeneratedAttribute]
public void set_Shards(List`1<int> value);
    [CompilerGeneratedAttribute]
internal int get_BucketRangeStart();
    [CompilerGeneratedAttribute]
internal void set_BucketRangeStart(int value);
    public DynamicJsonValue ToJson();
}
public class Raven.Client.ServerWide.Sharding.RemoveNodeFromOrchestratorTopologyOperation : object {
    private string _databaseName;
    private string _node;
    public RemoveNodeFromOrchestratorTopologyOperation(string databaseName, string node);
    public sealed virtual RavenCommand`1<ModifyOrchestratorTopologyResult> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Client.ServerWide.Sharding.ShardBucketMigration : object {
    public MigrationStatus Status;
    public int Bucket;
    public int SourceShard;
    public int DestinationShard;
    public long MigrationIndex;
    public Nullable`1<long> ConfirmationIndex;
    public string LastSourceChangeVector;
    public List`1<string> ConfirmedDestinations;
    public List`1<string> ConfirmedSourceCleanup;
    public string MentorNode;
    private Nullable`1<ulong> _hashCode;
    public bool IsActive { get; }
    public virtual string ToString();
    public bool get_IsActive();
    public sealed virtual ulong GetTaskKey();
    public sealed virtual string GetMentorNode();
    public sealed virtual string GetDefaultTaskName();
    public sealed virtual string GetTaskName();
    public sealed virtual bool IsResourceIntensive();
    public sealed virtual bool IsPinnedToMentorNode();
}
public class Raven.Client.ServerWide.Sharding.ShardBucketRange : object {
    public int BucketRangeStart;
    public int ShardNumber;
    public DynamicJsonValue ToJson();
}
public class Raven.Client.ServerWide.Sharding.ShardingConfiguration : object {
    public OrchestratorConfiguration Orchestrator;
    public Dictionary`2<int, DatabaseTopology> Shards;
    public List`1<ShardBucketRange> BucketRanges;
    public List`1<PrefixedShardingSetting> Prefixed;
    public Dictionary`2<int, ShardBucketMigration> BucketMigrations;
    public long MigrationCutOffIndex;
    public string DatabaseId;
    internal bool DoesShardHaveBuckets(int shardNumber);
    internal static bool DoesShardHaveBuckets(List`1<ShardBucketRange> bucketRanges, int shardNumber);
    internal bool HasActiveMigrations();
    internal bool DoesShardHavePrefixes(int shardNumber);
    internal static bool DoesShardHavePrefixes(List`1<PrefixedShardingSetting> prefixes, int shardNumber);
}
public class Raven.Client.ServerWide.Sharding.UpdatePrefixedShardingSettingOperation : object {
    private PrefixedShardingSetting _setting;
    public UpdatePrefixedShardingSettingOperation(PrefixedShardingSetting setting);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext ctx);
}
internal abstract class Raven.Client.ServerWide.Tcp.AbstractTcpNegotiateParameters : object {
    [CompilerGeneratedAttribute]
private OperationTypes <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthorizationInfo <AuthorizeInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceNodeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationNodeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private LicensedFeatures <LicensedFeatures>k__BackingField;
    public OperationTypes Operation { get; public set; }
    public AuthorizationInfo AuthorizeInfo { get; public set; }
    public int Version { get; public set; }
    public string Database { get; public set; }
    public string SourceNodeTag { get; public set; }
    public string DestinationNodeTag { get; public set; }
    public string DestinationUrl { get; public set; }
    public string DestinationServerId { get; public set; }
    public CancellationToken CancellationToken { get; public set; }
    public LicensedFeatures LicensedFeatures { get; public set; }
    [CompilerGeneratedAttribute]
public OperationTypes get_Operation();
    [CompilerGeneratedAttribute]
public void set_Operation(OperationTypes value);
    [CompilerGeneratedAttribute]
public AuthorizationInfo get_AuthorizeInfo();
    [CompilerGeneratedAttribute]
public void set_AuthorizeInfo(AuthorizationInfo value);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    [CompilerGeneratedAttribute]
public string get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(string value);
    [CompilerGeneratedAttribute]
public string get_SourceNodeTag();
    [CompilerGeneratedAttribute]
public void set_SourceNodeTag(string value);
    [CompilerGeneratedAttribute]
public string get_DestinationNodeTag();
    [CompilerGeneratedAttribute]
public void set_DestinationNodeTag(string value);
    [CompilerGeneratedAttribute]
public string get_DestinationUrl();
    [CompilerGeneratedAttribute]
public void set_DestinationUrl(string value);
    [CompilerGeneratedAttribute]
public string get_DestinationServerId();
    [CompilerGeneratedAttribute]
public void set_DestinationServerId(string value);
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public void set_CancellationToken(CancellationToken value);
    [CompilerGeneratedAttribute]
public LicensedFeatures get_LicensedFeatures();
    [CompilerGeneratedAttribute]
public void set_LicensedFeatures(LicensedFeatures value);
}
internal class Raven.Client.ServerWide.Tcp.AsyncTcpNegotiateParameters : AbstractTcpNegotiateParameters {
    [CompilerGeneratedAttribute]
private Func`5<JsonOperationContext, AsyncBlittableJsonTextWriter, Stream, string, ValueTask`1<NegotiationResponse>> <ReadResponseAndGetVersionCallbackAsync>k__BackingField;
    public Func`5<JsonOperationContext, AsyncBlittableJsonTextWriter, Stream, string, ValueTask`1<NegotiationResponse>> ReadResponseAndGetVersionCallbackAsync { get; public set; }
    [CompilerGeneratedAttribute]
public Func`5<JsonOperationContext, AsyncBlittableJsonTextWriter, Stream, string, ValueTask`1<NegotiationResponse>> get_ReadResponseAndGetVersionCallbackAsync();
    [CompilerGeneratedAttribute]
public void set_ReadResponseAndGetVersionCallbackAsync(Func`5<JsonOperationContext, AsyncBlittableJsonTextWriter, Stream, string, ValueTask`1<NegotiationResponse>> value);
}
public class Raven.Client.ServerWide.Tcp.LicensedFeatures : object {
    public bool DataCompression;
    public DynamicJsonValue ToJson();
}
public class Raven.Client.ServerWide.Tcp.TcpConnectionHeaderMessage : object {
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceNodeTag>k__BackingField;
    public string ServerId;
    [CompilerGeneratedAttribute]
private OperationTypes <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OperationVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthorizationInfo <AuthorizeInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private LicensedFeatures <LicensedFeatures>k__BackingField;
    public DetailedReplicationHubAccess ReplicationHubAccess;
    public static int PingBaseLine;
    public static int NoneBaseLine;
    public static int DropBaseLine;
    public static int ClusterBaseLine;
    public static int ClusterWithMultiTree;
    public static int ClusterWithTcpCompression;
    public static int HeartbeatsBaseLine;
    public static int Heartbeats41200;
    public static int Heartbeats42000;
    public static int HeartbeatsWithTcpCompression;
    public static int ReplicationBaseLine;
    public static int ReplicationAttachmentMissing;
    public static int ReplicationAttachmentMissingVersion41;
    public static int ReplicationWithPullOption;
    public static int ReplicationWithTimeSeries;
    public static int ReplicationWithDeduplicatedAttachments;
    public static int ReplicationWithRevisionTombstones;
    public static int TcpConnectionsWithCompression;
    public static int SubscriptionBaseLine;
    public static int SubscriptionIncludes;
    public static int SubscriptionCounterIncludes;
    public static int SubscriptionTimeSeriesIncludes;
    public static int TestConnectionBaseLine;
    public static int ClusterTcpVersion;
    public static int HeartbeatsTcpVersion;
    public static int ReplicationTcpVersion;
    public static int SubscriptionTcpVersion;
    public static int TestConnectionTcpVersion;
    private static Dictionary`2<OperationTypes, List`1<int>> OperationsToSupportedProtocolVersions;
    private static Dictionary`2<OperationTypes, Dictionary`2<int, SupportedFeatures>> SupportedFeaturesByProtocol;
    public string DatabaseName { get; public set; }
    public string SourceNodeTag { get; public set; }
    public OperationTypes Operation { get; public set; }
    public int OperationVersion { get; public set; }
    public string Info { get; public set; }
    public AuthorizationInfo AuthorizeInfo { get; public set; }
    public LicensedFeatures LicensedFeatures { get; public set; }
    private static TcpConnectionHeaderMessage();
    [CompilerGeneratedAttribute]
public string get_DatabaseName();
    [CompilerGeneratedAttribute]
public void set_DatabaseName(string value);
    [CompilerGeneratedAttribute]
public string get_SourceNodeTag();
    [CompilerGeneratedAttribute]
public void set_SourceNodeTag(string value);
    [CompilerGeneratedAttribute]
public OperationTypes get_Operation();
    [CompilerGeneratedAttribute]
public void set_Operation(OperationTypes value);
    [CompilerGeneratedAttribute]
public int get_OperationVersion();
    [CompilerGeneratedAttribute]
public void set_OperationVersion(int value);
    [CompilerGeneratedAttribute]
public string get_Info();
    [CompilerGeneratedAttribute]
public void set_Info(string value);
    [CompilerGeneratedAttribute]
public AuthorizationInfo get_AuthorizeInfo();
    [CompilerGeneratedAttribute]
public void set_AuthorizeInfo(AuthorizationInfo value);
    [CompilerGeneratedAttribute]
public LicensedFeatures get_LicensedFeatures();
    [CompilerGeneratedAttribute]
public void set_LicensedFeatures(LicensedFeatures value);
    public static SupportedStatus OperationVersionSupported(OperationTypes operationType, int version, Int32& current);
    public static int GetOperationTcpVersion(OperationTypes operationType, int index);
    public static SupportedFeatures GetSupportedFeaturesFor(OperationTypes type, int protocolVersion);
}
public class Raven.Client.ServerWide.Tcp.TcpConnectionHeaderResponse : object {
    [CompilerGeneratedAttribute]
private TcpConnectionStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private LicensedFeatures <LicensedFeatures>k__BackingField;
    public TcpConnectionStatus Status { get; public set; }
    public string Message { get; public set; }
    public int Version { get; public set; }
    public LicensedFeatures LicensedFeatures { get; public set; }
    [CompilerGeneratedAttribute]
public TcpConnectionStatus get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(TcpConnectionStatus value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    [CompilerGeneratedAttribute]
public LicensedFeatures get_LicensedFeatures();
    [CompilerGeneratedAttribute]
public void set_LicensedFeatures(LicensedFeatures value);
}
public enum Raven.Client.ServerWide.Tcp.TcpConnectionStatus : Enum {
    public int value__;
    public static TcpConnectionStatus Ok;
    public static TcpConnectionStatus AuthorizationFailed;
    public static TcpConnectionStatus TcpVersionMismatch;
    public static TcpConnectionStatus InvalidNetworkTopology;
}
internal static class Raven.Client.ServerWide.Tcp.TcpNegotiation : object {
    public static int OutOfRangeStatus;
    public static int DropStatus;
    private static Logger Log;
    private static SyncTcpNegotiation _sync;
    internal static SyncTcpNegotiation Sync { get; }
    private static TcpNegotiation();
    internal static SyncTcpNegotiation get_Sync();
    [AsyncStateMachineAttribute("Raven.Client.ServerWide.Tcp.TcpNegotiation/<NegotiateProtocolVersionAsync>d__6")]
public static ValueTask`1<SupportedFeatures> NegotiateProtocolVersionAsync(JsonOperationContext context, Stream stream, AsyncTcpNegotiateParameters parameters);
    [AsyncStateMachineAttribute("Raven.Client.ServerWide.Tcp.TcpNegotiation/<SendTcpVersionInfoAsync>d__7")]
private static ValueTask SendTcpVersionInfoAsync(JsonOperationContext context, AsyncBlittableJsonTextWriter writer, AsyncTcpNegotiateParameters parameters, int currentVersion);
}
[ExtensionAttribute]
internal static class Raven.Client.ServerWide.ThreadSafeRandom : object {
    [ThreadStaticAttribute]
private static Random _random;
    [ExtensionAttribute]
public static void Shuffle(IList`1<T> list);
}
internal class Raven.Client.Util.AsyncDisposableAction : object {
    private Func`1<Task> _action;
    public AsyncDisposableAction(Func`1<Task> action);
    [AsyncStateMachineAttribute("Raven.Client.Util.AsyncDisposableAction/<DisposeAsync>d__2")]
public sealed virtual ValueTask DisposeAsync();
}
public static class Raven.Client.Util.AsyncHelpers : object {
    public static bool UseTaskAwaiterWhenNoSynchronizationContextIsAvailable;
    private static ObjectPool`2<ExclusiveSynchronizationContext, ExclusiveSynchronizationContextResetBehavior> _pool;
    private static AsyncHelpers();
    public static void RunSync(Func`1<Task> task);
    public static T RunSync(Func`1<Task`1<T>> task);
    internal static T RunSync(Func`1<ValueTask`1<T>> taskFactory);
    [DoesNotReturnAttribute]
private static void HandleException(AggregateException ex, Stopwatch sw);
}
internal static class Raven.Client.Util.CertificateLoaderUtil : object {
    private static Logger Log;
    private static bool FirstTime;
    public static X509KeyStorageFlags FlagsForExport { get; }
    public static X509KeyStorageFlags FlagsForPersist { get; }
    private static CertificateLoaderUtil();
    public static X509KeyStorageFlags get_FlagsForExport();
    public static X509KeyStorageFlags get_FlagsForPersist();
    public static void Import(X509Certificate2Collection collection, Byte[] rawData, string password, Nullable`1<X509KeyStorageFlags> flags);
    public static X509Certificate2 CreateCertificate(Byte[] rawData, string password, Nullable`1<X509KeyStorageFlags> flags);
    internal static X509Certificate2 CreateCertificate(string fileName, string password, Nullable`1<X509KeyStorageFlags> flags);
    private static X509Certificate2 CreateCertificate(Func`2<X509KeyStorageFlags, X509Certificate2> creator, Nullable`1<X509KeyStorageFlags> flag);
    private static X509KeyStorageFlags AddUserKeySet(Nullable`1<X509KeyStorageFlags> flag);
    private static X509KeyStorageFlags AddMachineKeySet(Nullable`1<X509KeyStorageFlags> flag);
    [ConditionalAttribute("DEBUG")]
private static void DebugAssertDoesntContainKeySet(Nullable`1<X509KeyStorageFlags> flags);
    private static void LogIfNeeded(string method, X509KeyStorageFlags flags, Exception exception);
    [CompilerGeneratedAttribute]
internal static string <LogIfNeeded>g__CreateMsg|13_0(<>c__DisplayClass13_0& );
}
internal static class Raven.Client.Util.ClientShardHelper : object {
    public static string ToShardName(string database, int shardNumber);
    public static string ToDatabaseName(string shardName);
    public static bool TryGetShardNumberAndDatabaseName(string databaseName, String& shardedDatabaseName, Int32& shardNumber);
    public static Nullable`1<int> GetShardNumberFromDatabaseName(string databaseName);
    public static bool IsShardName(string shardName);
}
internal static class Raven.Client.Util.ClusterWideTransactionHelper : object {
    public static bool IsAtomicGuardKey(string id, String& docId);
    public static bool IsAtomicGuardKey(string key);
    public static string GetAtomicGuardKey(string docId);
    public static string GetAtomicGuardKey(ReadOnlyMemory`1<char> docId);
    public static string ExtractDocumentIdFromAtomicGuard(string key);
}
internal class Raven.Client.Util.CSharpClassName : object {
    public static string ConvertToValidClassName(string input);
}
internal class Raven.Client.Util.CustomMemberInitAsJson : JavascriptConversionExtension {
    public static CustomMemberInitAsJson ForAllTypes;
    private static CustomMemberInitAsJson();
    public virtual void ConvertToJavascript(JavascriptConversionContext context);
}
internal class Raven.Client.Util.DisposableAction : object {
    private Action _action;
    public DisposableAction(Action action);
    public sealed virtual void Dispose();
}
internal static class Raven.Client.Util.HttpClientHandlerHelper : object {
    private static HttpClientHandlerHelper();
    public static void Configure(HttpClientHandler handler, Nullable`1<TimeSpan> pooledConnectionLifetime, Nullable`1<TimeSpan> pooledConnectionIdleTimeout);
}
internal static class Raven.Client.Util.HttpMethods : object {
    public static HttpMethod Connect;
    public static HttpMethod Reset;
    public static HttpMethod Patch;
    public static HttpMethod Eval;
    public static HttpMethod Get;
    public static HttpMethod Post;
    public static HttpMethod Put;
    public static HttpMethod Delete;
    public static HttpMethod Head;
    private static HttpMethods();
}
public interface Raven.Client.Util.IDisposalNotification {
    public bool WasDisposed { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_AfterDispose(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_AfterDispose(EventHandler value);
    public abstract virtual bool get_WasDisposed();
}
internal class Raven.Client.Util.JavascriptConversionExtensions : object {
    internal static string TransparentIdentifier;
    private static string DefaultAliasPrefix;
    public static ParameterExpression GetParameter(MemberExpression expression);
    private static ParameterExpression GetParameterAndCheckInternalMemberName(MemberExpression expression, Boolean& hasInternalKeyOrValue);
    public static Expression GetInnermostExpression(MemberExpression expression, String& path, Boolean& hasInternalKeyOrValue);
    private static void WriteArguments(JavascriptConversionContext context, IReadOnlyList`1<Expression> arguments, JavascriptWriter writer, int start);
    internal static bool IsWrappedConstantExpression(Expression expression);
}
internal class Raven.Client.Util.Metrics.AtomicLong : object {
    private long _value;
    public AtomicLong(long value);
    public long Get();
    public void Set(long value);
    public long AddAndGet(long amount);
    public long IncrementAndGet();
    public bool CompareAndSet(long expected, long updated);
    public long GetAndSet(long value);
    public long GetAndAdd(long value);
    public static AtomicLong op_Implicit(long value);
    public static long op_Implicit(AtomicLong value);
}
internal class Raven.Client.Util.Metrics.EWMA : object {
    private static double M1Second;
    public static double M1Alpha;
    private static double M5Alpha;
    private static double M15Alpha;
    private AtomicLong _uncounted;
    private double _alpha;
    private double _interval;
    private SingleUseFlag _initialized;
    private VolatileDouble _rate;
    public EWMA(double alpha, long interval, TimeUnit intervalUnit);
    private static EWMA();
    public static EWMA OneSecondEWMA();
    public static EWMA OneMinuteEWMA();
    public static EWMA FiveMinuteEWMA();
    public static EWMA FifteenMinuteEWMA();
    public void Update(long n);
    public void Tick();
    public double Rate(TimeUnit rateUnit);
}
internal enum Raven.Client.Util.Metrics.TimeUnit : Enum {
    public int value__;
    public static TimeUnit Nanoseconds;
    public static TimeUnit Microseconds;
    public static TimeUnit Milliseconds;
    public static TimeUnit Seconds;
    public static TimeUnit Minutes;
    public static TimeUnit Hours;
    public static TimeUnit Days;
}
[ExtensionAttribute]
internal static class Raven.Client.Util.Metrics.TimeUnitExtensions : object {
    private static Int64[][] _conversionMatrix;
    private static TimeUnitExtensions();
    private static Int64[][] BuildConversionMatrix();
    [ExtensionAttribute]
public static long Convert(TimeUnit source, long duration, TimeUnit target);
    [ExtensionAttribute]
public static long ToNanos(TimeUnit source, long interval);
    [ExtensionAttribute]
public static long ToMicros(TimeUnit source, long interval);
    [ExtensionAttribute]
public static long ToMillis(TimeUnit source, long interval);
    [ExtensionAttribute]
public static long ToSeconds(TimeUnit source, long interval);
    [ExtensionAttribute]
public static long ToMinutes(TimeUnit source, long interval);
    [ExtensionAttribute]
public static long ToHours(TimeUnit source, long interval);
    [ExtensionAttribute]
public static long ToDays(TimeUnit source, long interval);
}
internal class Raven.Client.Util.Metrics.VolatileDouble : ValueType {
    private double _value;
    private VolatileDouble(double value);
    public static VolatileDouble op_Addition(VolatileDouble left, VolatileDouble right);
    private static VolatileDouble Add(VolatileDouble left, VolatileDouble right);
    public static VolatileDouble op_Subtraction(VolatileDouble left, VolatileDouble right);
    public static VolatileDouble op_Multiply(VolatileDouble left, VolatileDouble right);
    public static VolatileDouble op_Division(VolatileDouble left, VolatileDouble right);
    public void Set(double value);
    public double Get();
    public static VolatileDouble op_Implicit(double value);
    public static double op_Implicit(VolatileDouble value);
    public virtual string ToString();
}
internal class Raven.Client.Util.NameValidation : object {
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    public bool IsValid { get; public set; }
    public string ErrorMessage { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsValid();
    [CompilerGeneratedAttribute]
public void set_IsValid(bool value);
    [CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [CompilerGeneratedAttribute]
public void set_ErrorMessage(string value);
}
internal class Raven.Client.Util.ObjectReferenceEqualityComparer`1 : EqualityComparer`1<T> {
    public static IEqualityComparer`1<T> Default;
    private static ObjectReferenceEqualityComparer`1();
    public virtual bool Equals(T x, T y);
    public virtual int GetHashCode(T obj);
}
internal static class Raven.Client.Util.RaftIdGenerator : object {
    public static string DontCareId { get; }
    public static string NewId();
    public static string get_DontCareId();
}
internal class Raven.Client.Util.RateLimiting.RateGate : object {
    private SemaphoreSlim _semaphore;
    private ConcurrentQueue`1<int> _exitTimes;
    private Timer _exitTimer;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private int <Occurrences>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TimeUnitMilliseconds>k__BackingField;
    public int Occurrences { get; }
    public int TimeUnitMilliseconds { get; }
    public RateGate(int occurrences, TimeSpan timeUnit);
    [CompilerGeneratedAttribute]
public int get_Occurrences();
    [CompilerGeneratedAttribute]
public int get_TimeUnitMilliseconds();
    private void ExitTimerCallback(object state);
    public bool WaitToProceed(int millisecondsTimeout);
    public bool WaitToProceed(TimeSpan timeout);
    public void WaitToProceed();
    private void CheckDisposed();
    public sealed virtual void Dispose();
    private void Dispose(bool isDisposing);
}
internal static class Raven.Client.Util.ReflectionUtil : object {
    private static Dictionary`2<Type, string> _fullNameCache;
    private static ReflectionUtil();
    public static string GetFullNameWithoutVersionInformation(Type entityType);
    public static IEnumerable`1<MemberInfo> GetPropertiesAndFieldsFor(BindingFlags bindingFlags);
    [IteratorStateMachineAttribute("Raven.Client.Util.ReflectionUtil/<GetPropertiesAndFieldsFor>d__4")]
public static IEnumerable`1<MemberInfo> GetPropertiesAndFieldsFor(Type type, BindingFlags bindingFlags);
    internal static MemberInfo GetPropertyOrFieldFor(Type type, BindingFlags bindingFlags, string name);
}
internal static class Raven.Client.Util.ResourceNameValidator : object {
    public static List`1<string> AllowedResourceNameCharacters;
    public static List`1<string> AllowedIndexNameCharacters;
    public static string ValidIndexNameCharacters;
    private static Regex ValidIndexNameCharactersRegex;
    private static Regex NameStartsOrEndsWithDotOrContainsConsecutiveDotsRegex;
    private static ResourceNameValidator();
    public static bool IsValidIndexName(string name);
    public static void AssertValidDatabaseName(string databaseName);
    public static bool IsValidResourceName(string name, string dataDirectory, String& errorMessage);
    public static bool IsValidFileName(string name, String& errorMessage);
    public static bool IsDotCharSurroundedByOtherChars(string name);
    private static bool IsValidName(string name, Regex regex);
}
internal class Raven.Client.Util.RunningOn : object {
    [ThreadStaticAttribute]
public static bool FinalizerThread;
    private static RunningOn();
    protected virtual override void Finalize();
}
public class Raven.Client.Util.Size : object {
    [CompilerGeneratedAttribute]
private long <SizeInBytes>k__BackingField;
    public long SizeInBytes { get; public set; }
    public string HumaneSize { get; }
    public Size(long sizeInBytes);
    [CompilerGeneratedAttribute]
public long get_SizeInBytes();
    [CompilerGeneratedAttribute]
public void set_SizeInBytes(long value);
    public string get_HumaneSize();
    public static string Humane(Nullable`1<long> size);
}
internal class Raven.Client.Util.StreamExposerContent : HttpContent {
    public Task`1<Stream> OutputStream;
    private TaskCompletionSource`1<Stream> _outputStreamTcs;
    protected TaskCompletionSource`1<object> _done;
    public bool IsDone { get; }
    public bool get_IsDone();
    public bool Complete();
    [AsyncStateMachineAttribute("Raven.Client.Util.StreamExposerContent/<SerializeToStreamAsync>d__7")]
protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected virtual bool TryComputeLength(Int64& length);
    public void ErrorOnRequestStart(Exception exception);
    public void ErrorOnProcessingRequest(Exception exception);
    protected virtual void Dispose(bool disposing);
}
internal class Raven.Client.Util.StreamWithTimeout : Stream {
    private static TimeSpan DefaultWriteTimeout;
    [CompilerGeneratedAttribute]
private static TimeSpan <DefaultReadTimeout>k__BackingField;
    internal Stream _stream;
    private int _writeTimeout;
    private int _readTimeout;
    private bool _canBaseStreamTimeoutOnWrite;
    private bool _canBaseStreamTimeoutOnRead;
    private CancellationTokenSource _writeCts;
    private CancellationTokenSource _readCts;
    private long _totalRead;
    private long _totalWritten;
    internal static TimeSpan DefaultReadTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public bool CanTimeout { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long TotalRead { get; }
    public long TotalWritten { get; }
    public long Position { get; public set; }
    public StreamWithTimeout(Stream stream);
    private static StreamWithTimeout();
    [CompilerGeneratedAttribute]
internal static TimeSpan get_DefaultReadTimeout();
    private void SetReadTimeoutIfNeeded(TimeSpan readTimeout);
    private void SetWriteTimeoutIfNeeded(TimeSpan writeTimeout);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual bool get_CanTimeout();
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Raven.Client.Util.StreamWithTimeout/<ReadAsyncWithTimeout>d__28")]
private Task`1<int> ReadAsyncWithTimeout(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    private Task WriteAsyncWithTimeout(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public long get_TotalRead();
    public long get_TotalWritten();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("Raven.Client.Util.StreamWithTimeout/<DisposeAsync>d__51")]
public virtual ValueTask DisposeAsync();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0();
}
public class Raven.Client.Util.SystemTime : object {
    private static SystemTime Instance;
    public Func`1<DateTime> UtcDateTime;
    public Action`1<int> WaitCalled;
    public static DateTime UtcNow { get; }
    private static SystemTime();
    public DateTime GetUtcNow();
    public static DateTime get_UtcNow();
}
internal static class Raven.Client.Util.TcpUtils : object {
    internal static SslProtocols SupportedSslProtocols;
    private static void SetTimeouts(TcpClient client, TimeSpan timeout);
    [AsyncStateMachineAttribute("Raven.Client.Util.TcpUtils/<ConnectSecuredTcpSocketAsReplication>d__2")]
internal static Task`1<ConnectSecuredTcpSocketResult> ConnectSecuredTcpSocketAsReplication(TcpConnectionInfo connection, X509Certificate2 certificate, NegotiationCallback negotiationCallback, TimeSpan timeout, Logger log);
    [AsyncStateMachineAttribute("Raven.Client.Util.TcpUtils/<ConnectAsync>d__3")]
public static Task`1<TcpClient> ConnectAsync(string url, Nullable`1<TimeSpan> timeout, bool useIPv6);
    [AsyncStateMachineAttribute("Raven.Client.Util.TcpUtils/<WrapStreamWithSslAsync>d__4")]
internal static Task`1<Stream> WrapStreamWithSslAsync(TcpClient tcpClient, TcpConnectionInfo info, X509Certificate2 storeCertificate, Nullable`1<TimeSpan> timeout);
    private static TcpClient NewTcpClient(Nullable`1<TimeSpan> timeout, bool useIPv6);
    [AsyncStateMachineAttribute("Raven.Client.Util.TcpUtils/<ConnectSecuredTcpSocket>d__8")]
internal static Task`1<ConnectSecuredTcpSocketResult> ConnectSecuredTcpSocket(TcpConnectionInfo info, X509Certificate2 cert, OperationTypes operationType, NegotiationCallback negotiationCallback, JsonOperationContext negContext, Nullable`1<TimeSpan> timeout, List`1<string> logs);
    [AsyncStateMachineAttribute("Raven.Client.Util.TcpUtils/<InvokeNegotiation>d__9")]
private static Task`1<SupportedFeatures> InvokeNegotiation(TcpConnectionInfo info, OperationTypes operationType, NegotiationCallback negotiationCallback, JsonOperationContext negContext, List`1<string> logs, string url, Stream stream);
}
internal class Raven.Client.Util.WeakReferencingTimer : object {
    private Timer _timer;
    public WeakReferencingTimer(WeakReferencingTimerCallback callback, object state, TimeSpan dueTime, TimeSpan period);
    private static void StaticCallback(object state);
    public void Change(TimeSpan dueTime, TimeSpan period);
    public sealed virtual void Dispose();
}
internal class Raven.Client.Util.WebSocketStream : Stream {
    private WebSocket _webSocket;
    private CancellationToken _cancellationToken;
    private ConcurrentSet`1<Task> _activeWriteTasks;
    private SingleUseFlag _isDisposed;
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public WebSocketStream(WebSocket webSocket, CancellationToken cancellationToken);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    [CompilerGeneratedAttribute]
public virtual long get_Position();
    [CompilerGeneratedAttribute]
public virtual void set_Position(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Raven.Client.Util.WebSocketStream/<WriteAsync>d__18")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void SetLength(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual int ReadByte();
    [AsyncStateMachineAttribute("Raven.Client.Util.WebSocketStream/<ReadAsync>d__24")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    private void ThrowOnDisposed();
    public virtual void Flush();
    [AsyncStateMachineAttribute("Raven.Client.Util.WebSocketStream/<FlushAsync>d__27")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private bool <Write>b__17_0(Task t);
    [CompilerGeneratedAttribute]
private Task <Dispose>b__28_0();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
