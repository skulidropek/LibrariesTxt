internal static class Consts : object {
    public static string Title;
    public static string Description;
    public static string Company;
    public static string Copyright;
    public static bool ComVisible;
    public static bool CLSCompliant;
    private static string FullFrameworkGuid;
    public static string Configuration;
    public static string Product;
}
public class GeoAPI.DataStructures.Interval : ValueType {
    public double Min;
    public double Max;
    private bool IsEmpty { get; }
    public double Width { get; }
    public double Centre { get; }
    private Interval(double value);
    private Interval(double min, double max);
    public Interval ExpandedByValue(double p);
    private bool get_IsEmpty();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Interval other);
    public virtual string ToString();
    public double get_Width();
    public double get_Centre();
    public Interval ExpandedByInterval(Interval interval);
    public bool Overlaps(Interval interval);
    public bool Overlaps(double min, double max);
    public bool Contains(Interval interval);
    public bool Contains(double min, double max);
    public bool Contains(double p);
    public bool Intersects(Interval other);
    public bool Intersects(double min, double max);
    public static Interval Create();
    public static Interval Create(double value);
    public static Interval Create(double val1, double val2);
    public static Interval Create(Interval interval);
    public static bool op_Equality(Interval lhs, Interval rhs);
    public static bool op_Inequality(Interval lhs, Interval rhs);
}
[DefaultMemberAttribute("Item")]
public class GeoAPI.Geometries.Coordinate : object {
    public static double NullOrdinate;
    public double X;
    public double Y;
    public double Z;
    public double Item { get; public set; }
    public Coordinate CoordinateValue { get; public set; }
    [ObsoleteAttribute]
private double GeoAPI.Geometries.ICoordinate.X { get; private set; }
    [ObsoleteAttribute]
private double GeoAPI.Geometries.ICoordinate.Y { get; private set; }
    [ObsoleteAttribute]
private double GeoAPI.Geometries.ICoordinate.Z { get; private set; }
    [ObsoleteAttribute]
private double GeoAPI.Geometries.ICoordinate.M { get; private set; }
    [ObsoleteAttribute]
private ICoordinate GeoAPI.Geometries.ICoordinate.CoordinateValue { get; private set; }
    [ObsoleteAttribute]
private double GeoAPI.Geometries.ICoordinate.Item { get; private set; }
    public Coordinate(double x, double y, double z);
    [ObsoleteAttribute]
public Coordinate(ICoordinate c);
    public Coordinate(Coordinate c);
    public Coordinate(double x, double y);
    public double get_Item(Ordinate ordinateIndex);
    public void set_Item(Ordinate ordinateIndex, double value);
    public Coordinate get_CoordinateValue();
    public void set_CoordinateValue(Coordinate value);
    public bool Equals2D(Coordinate other);
    public bool Equals2D(Coordinate c, double tolerance);
    private static bool EqualsWithTolerance(double x1, double x2, double tolerance);
    public virtual bool Equals(object other);
    public bool Equals(Coordinate other);
    public int CompareTo(object o);
    public sealed virtual int CompareTo(Coordinate other);
    public bool Equals3D(Coordinate other);
    public bool EqualInZ(Coordinate c, double tolerance);
    public virtual string ToString();
    public virtual Coordinate Copy();
    [ObsoleteAttribute("Use Copy")]
public sealed virtual object Clone();
    public double Distance(Coordinate c);
    public double Distance3D(Coordinate c);
    public virtual int GetHashCode();
    public static int GetHashCode(double value);
    private sealed virtual override double GeoAPI.Geometries.ICoordinate.get_X();
    private sealed virtual override void GeoAPI.Geometries.ICoordinate.set_X(double value);
    private sealed virtual override double GeoAPI.Geometries.ICoordinate.get_Y();
    private sealed virtual override void GeoAPI.Geometries.ICoordinate.set_Y(double value);
    private sealed virtual override double GeoAPI.Geometries.ICoordinate.get_Z();
    private sealed virtual override void GeoAPI.Geometries.ICoordinate.set_Z(double value);
    private sealed virtual override double GeoAPI.Geometries.ICoordinate.get_M();
    private sealed virtual override void GeoAPI.Geometries.ICoordinate.set_M(double value);
    private sealed virtual override ICoordinate GeoAPI.Geometries.ICoordinate.get_CoordinateValue();
    private sealed virtual override void GeoAPI.Geometries.ICoordinate.set_CoordinateValue(ICoordinate value);
    private sealed virtual override double GeoAPI.Geometries.ICoordinate.get_Item(Ordinate index);
    private sealed virtual override void GeoAPI.Geometries.ICoordinate.set_Item(Ordinate index, double value);
    [ObsoleteAttribute]
private sealed virtual override bool GeoAPI.Geometries.ICoordinate.Equals2D(ICoordinate other);
    [ObsoleteAttribute]
private sealed virtual override int System.IComparable<GeoAPI.Geometries.ICoordinate>.CompareTo(ICoordinate other);
    private sealed virtual override int System.IComparable.CompareTo(object o);
    [ObsoleteAttribute]
private sealed virtual override bool GeoAPI.Geometries.ICoordinate.Equals3D(ICoordinate other);
    [ObsoleteAttribute]
private sealed virtual override double GeoAPI.Geometries.ICoordinate.Distance(ICoordinate p);
}
public enum GeoAPI.Geometries.Dimension : Enum {
    public int value__;
    public static Dimension Point;
    public static Dimension Curve;
    public static Dimension Surface;
    public static Dimension False;
    public static Dimension True;
    public static Dimension Dontcare;
}
public class GeoAPI.Geometries.DimensionUtility : object {
    public static char SymFalse;
    public static char SymTrue;
    public static char SymDontcare;
    public static char SymP;
    public static char SymL;
    public static char SymA;
    public static char ToDimensionSymbol(Dimension dimensionValue);
    public static Dimension ToDimensionValue(char dimensionSymbol);
}
public class GeoAPI.Geometries.Envelope : object {
    private double _minx;
    private double _maxx;
    private double _miny;
    private double _maxy;
    public bool IsNull { get; }
    public double Width { get; }
    public double Height { get; }
    public double MinX { get; }
    public double MaxX { get; }
    public double MinY { get; }
    public double MaxY { get; }
    public double Area { get; }
    public double MinExtent { get; }
    public double MaxExtent { get; }
    public Coordinate Centre { get; }
    private ICoordinate GeoAPI.Geometries.IEnvelope.Centre { get; }
    public Envelope(double x1, double x2, double y1, double y2);
    public Envelope(Coordinate p1, Coordinate p2);
    public Envelope(Coordinate p);
    public Envelope(Envelope env);
    public static bool Intersects(Coordinate p1, Coordinate p2, Coordinate q);
    public static bool Intersects(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2);
    public void Init();
    public sealed virtual void Init(double x1, double x2, double y1, double y2);
    public void Init(Coordinate p1, Coordinate p2);
    public void Init(Coordinate p);
    public void Init(Envelope env);
    public sealed virtual void SetToNull();
    public sealed virtual bool get_IsNull();
    public sealed virtual double get_Width();
    public sealed virtual double get_Height();
    public sealed virtual double get_MinX();
    public sealed virtual double get_MaxX();
    public sealed virtual double get_MinY();
    public sealed virtual double get_MaxY();
    public sealed virtual double get_Area();
    public sealed virtual void ExpandBy(double distance);
    public sealed virtual void ExpandBy(double deltaX, double deltaY);
    public double get_MinExtent();
    public double get_MaxExtent();
    public void ExpandToInclude(Coordinate p);
    public sealed virtual void ExpandToInclude(double x, double y);
    public sealed virtual void ExpandToInclude(Envelope other);
    public sealed virtual Envelope ExpandedBy(Envelope other);
    public sealed virtual void Translate(double transX, double transY);
    public Coordinate get_Centre();
    public Envelope Intersection(Envelope env);
    public sealed virtual bool Intersects(Envelope other);
    [ObsoleteAttribute("Use Intersects instead")]
public bool Overlaps(Envelope other);
    [ObsoleteAttribute("Use Intersects instead")]
public bool Overlaps(Coordinate p);
    [ObsoleteAttribute("Use Intersects instead")]
public sealed virtual bool Overlaps(double x, double y);
    public bool Intersects(Coordinate p);
    public sealed virtual bool Intersects(double x, double y);
    public bool Intersects(Coordinate a, Coordinate b);
    public bool Contains(Envelope other);
    public bool Contains(Coordinate p);
    public sealed virtual bool Contains(double x, double y);
    public sealed virtual bool Covers(double x, double y);
    public bool Covers(Coordinate p);
    public bool Covers(Envelope other);
    public double Distance(Envelope env);
    public virtual bool Equals(object other);
    public bool Equals(Envelope other);
    public sealed virtual int CompareTo(object other);
    public sealed virtual int CompareTo(Envelope env);
    public virtual int GetHashCode();
    private static int GetHashCode(double value);
    public virtual string ToString();
    private sealed virtual override object System.ICloneable.Clone();
    public Envelope Copy();
    [ObsoleteAttribute("Use Copy()")]
public Envelope Clone();
    private sealed virtual override IEnvelope GeoAPI.Geometries.IEnvelope.Union(IPoint point);
    private sealed virtual override IEnvelope GeoAPI.Geometries.IEnvelope.Union(ICoordinate coord);
    private sealed virtual override IEnvelope GeoAPI.Geometries.IEnvelope.Union(IEnvelope box);
    private sealed virtual override void GeoAPI.Geometries.IEnvelope.SetCentre(ICoordinate centre);
    private sealed virtual override void GeoAPI.Geometries.IEnvelope.SetCentre(IPoint centre);
    private sealed virtual override void GeoAPI.Geometries.IEnvelope.SetCentre(double width, double height);
    private sealed virtual override void GeoAPI.Geometries.IEnvelope.SetCentre(IPoint centre, double width, double height);
    private sealed virtual override void GeoAPI.Geometries.IEnvelope.SetCentre(ICoordinate centre, double width, double height);
    private sealed virtual override void GeoAPI.Geometries.IEnvelope.Zoom(double perCent);
    private sealed virtual override void GeoAPI.Geometries.IEnvelope.Init();
    private sealed virtual override void GeoAPI.Geometries.IEnvelope.Init(ICoordinate p1, ICoordinate p2);
    private sealed virtual override void GeoAPI.Geometries.IEnvelope.Init(ICoordinate p);
    private sealed virtual override void GeoAPI.Geometries.IEnvelope.Init(IEnvelope env);
    private sealed virtual override void GeoAPI.Geometries.IEnvelope.ExpandToInclude(ICoordinate p);
    private sealed virtual override void GeoAPI.Geometries.IEnvelope.ExpandToInclude(IEnvelope other);
    private sealed virtual override ICoordinate GeoAPI.Geometries.IEnvelope.get_Centre();
    private sealed virtual override IEnvelope GeoAPI.Geometries.IEnvelope.Intersection(IEnvelope env);
    private sealed virtual override bool GeoAPI.Geometries.IEnvelope.Intersects(IEnvelope other);
    [ObsoleteAttribute("Use Intersects instead")]
private sealed virtual override bool GeoAPI.Geometries.IEnvelope.Overlaps(IEnvelope other);
    [ObsoleteAttribute("Use Intersects instead")]
private sealed virtual override bool GeoAPI.Geometries.IEnvelope.Overlaps(ICoordinate p);
    private sealed virtual override bool GeoAPI.Geometries.IEnvelope.Intersects(ICoordinate p);
    private sealed virtual override bool GeoAPI.Geometries.IEnvelope.Contains(IEnvelope other);
    private sealed virtual override bool GeoAPI.Geometries.IEnvelope.Contains(ICoordinate p);
    private sealed virtual override bool GeoAPI.Geometries.IEnvelope.Covers(ICoordinate p);
    private sealed virtual override bool GeoAPI.Geometries.IEnvelope.Covers(IEnvelope other);
    private sealed virtual override double GeoAPI.Geometries.IEnvelope.Distance(IEnvelope env);
    private sealed virtual override int System.IComparable<GeoAPI.Geometries.IEnvelope>.CompareTo(IEnvelope other);
    public static Envelope Parse(string envelope);
}
public interface GeoAPI.Geometries.IBoundable`2 {
    public T Bounds { get; }
    public TItem Item { get; }
    public abstract virtual T get_Bounds();
    public abstract virtual TItem get_Item();
}
[DefaultMemberAttribute("Item")]
[ObsoleteAttribute("Use Coordinate class instead")]
public interface GeoAPI.Geometries.ICoordinate {
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public double M { get; public set; }
    public ICoordinate CoordinateValue { get; public set; }
    public double Item { get; public set; }
    public abstract virtual double get_X();
    public abstract virtual void set_X(double value);
    public abstract virtual double get_Y();
    public abstract virtual void set_Y(double value);
    public abstract virtual double get_Z();
    public abstract virtual void set_Z(double value);
    public abstract virtual double get_M();
    public abstract virtual void set_M(double value);
    public abstract virtual ICoordinate get_CoordinateValue();
    public abstract virtual void set_CoordinateValue(ICoordinate value);
    public abstract virtual double get_Item(Ordinate index);
    public abstract virtual void set_Item(Ordinate index, double value);
    public abstract virtual double Distance(ICoordinate other);
    public abstract virtual bool Equals2D(ICoordinate other);
    public abstract virtual bool Equals3D(ICoordinate other);
}
public interface GeoAPI.Geometries.ICoordinateBuffer {
    public int Capacity { get; }
    public int Count { get; }
    public abstract virtual int get_Capacity();
    public abstract virtual int get_Count();
    public abstract virtual bool AddCoordinate(double x, double y, Nullable`1<double> z, Nullable`1<double> m, bool allowRepeated);
    public abstract virtual bool InsertCoordinate(int index, double x, double y, Nullable`1<double> z, Nullable`1<double> m, bool allowRepeated);
    public abstract virtual void SetM(int index, double m);
    public abstract virtual void SetZ(int index, double z);
    public abstract virtual ICoordinateSequence ToSequence(ICoordinateSequenceFactory factory);
}
public interface GeoAPI.Geometries.ICoordinateFilter {
    public abstract virtual void Filter(Coordinate coord);
}
public interface GeoAPI.Geometries.ICoordinateSequence {
    public int Dimension { get; }
    public Ordinates Ordinates { get; }
    public int Count { get; }
    public abstract virtual int get_Dimension();
    public abstract virtual Ordinates get_Ordinates();
    public abstract virtual int get_Count();
    public abstract virtual Coordinate GetCoordinate(int i);
    public abstract virtual Coordinate GetCoordinateCopy(int i);
    public abstract virtual void GetCoordinate(int index, Coordinate coord);
    public abstract virtual double GetX(int index);
    public abstract virtual double GetY(int index);
    public abstract virtual double GetOrdinate(int index, Ordinate ordinate);
    public abstract virtual void SetOrdinate(int index, Ordinate ordinate, double value);
    public abstract virtual Coordinate[] ToCoordinateArray();
    public abstract virtual Envelope ExpandEnvelope(Envelope env);
    public abstract virtual ICoordinateSequence Reversed();
    public abstract virtual ICoordinateSequence Copy();
}
public interface GeoAPI.Geometries.ICoordinateSequenceFactory {
    public Ordinates Ordinates { get; }
    public abstract virtual ICoordinateSequence Create(Coordinate[] coordinates);
    public abstract virtual ICoordinateSequence Create(ICoordinateSequence coordSeq);
    public abstract virtual ICoordinateSequence Create(int size, int dimension);
    public abstract virtual ICoordinateSequence Create(int size, Ordinates ordinates);
    public abstract virtual Ordinates get_Ordinates();
}
public interface GeoAPI.Geometries.ICoordinateSequenceFilter {
    public bool Done { get; }
    public bool GeometryChanged { get; }
    public abstract virtual void Filter(ICoordinateSequence seq, int i);
    public abstract virtual bool get_Done();
    public abstract virtual bool get_GeometryChanged();
}
public interface GeoAPI.Geometries.ICurve {
    public ICoordinateSequence CoordinateSequence { get; }
    public IPoint StartPoint { get; }
    public IPoint EndPoint { get; }
    public bool IsClosed { get; }
    public bool IsRing { get; }
    public abstract virtual ICoordinateSequence get_CoordinateSequence();
    public abstract virtual IPoint get_StartPoint();
    public abstract virtual IPoint get_EndPoint();
    public abstract virtual bool get_IsClosed();
    public abstract virtual bool get_IsRing();
}
[ObsoleteAttribute("Use Envelope class instead")]
public interface GeoAPI.Geometries.IEnvelope {
    public double Area { get; }
    public double Width { get; }
    public double Height { get; }
    public double MaxX { get; }
    public double MaxY { get; }
    public double MinX { get; }
    public double MinY { get; }
    public ICoordinate Centre { get; }
    public bool IsNull { get; }
    public abstract virtual double get_Area();
    public abstract virtual double get_Width();
    public abstract virtual double get_Height();
    public abstract virtual double get_MaxX();
    public abstract virtual double get_MaxY();
    public abstract virtual double get_MinX();
    public abstract virtual double get_MinY();
    public abstract virtual ICoordinate get_Centre();
    public abstract virtual bool Contains(double x, double y);
    public abstract virtual bool Contains(ICoordinate p);
    public abstract virtual bool Contains(IEnvelope other);
    public abstract virtual bool Covers(double x, double y);
    public abstract virtual bool Covers(ICoordinate p);
    public abstract virtual bool Covers(IEnvelope other);
    public abstract virtual double Distance(IEnvelope env);
    public abstract virtual void ExpandBy(double distance);
    public abstract virtual void ExpandBy(double deltaX, double deltaY);
    public abstract virtual void ExpandToInclude(ICoordinate p);
    public abstract virtual void ExpandToInclude(double x, double y);
    public abstract virtual void ExpandToInclude(IEnvelope other);
    public abstract virtual void Init();
    public abstract virtual void Init(ICoordinate p);
    public abstract virtual void Init(IEnvelope env);
    public abstract virtual void Init(ICoordinate p1, ICoordinate p2);
    public abstract virtual void Init(double x1, double x2, double y1, double y2);
    public abstract virtual IEnvelope Intersection(IEnvelope env);
    public abstract virtual void Translate(double transX, double transY);
    public abstract virtual bool Intersects(ICoordinate p);
    public abstract virtual bool Intersects(double x, double y);
    public abstract virtual bool Intersects(IEnvelope other);
    public abstract virtual bool get_IsNull();
    public abstract virtual void SetToNull();
    public abstract virtual void Zoom(double perCent);
    public abstract virtual bool Overlaps(IEnvelope other);
    public abstract virtual bool Overlaps(ICoordinate p);
    public abstract virtual bool Overlaps(double x, double y);
    public abstract virtual void SetCentre(double width, double height);
    public abstract virtual void SetCentre(IPoint centre, double width, double height);
    public abstract virtual void SetCentre(ICoordinate centre);
    public abstract virtual void SetCentre(IPoint centre);
    public abstract virtual void SetCentre(ICoordinate centre, double width, double height);
    public abstract virtual IEnvelope Union(IPoint point);
    public abstract virtual IEnvelope Union(ICoordinate coord);
    public abstract virtual IEnvelope Union(IEnvelope box);
}
public interface GeoAPI.Geometries.IExpandable`1 {
    public abstract virtual void ExpandToInclude(T other);
    public abstract virtual T ExpandedBy(T other);
}
public interface GeoAPI.Geometries.IGeometry {
    public IGeometryFactory Factory { get; }
    public IPrecisionModel PrecisionModel { get; }
    public int SRID { get; public set; }
    public string GeometryType { get; }
    public OgcGeometryType OgcGeometryType { get; }
    public double Area { get; }
    public double Length { get; }
    public int NumGeometries { get; }
    public int NumPoints { get; }
    public IGeometry Boundary { get; }
    public Dimension BoundaryDimension { get; }
    public IPoint Centroid { get; }
    public Coordinate Coordinate { get; }
    public Coordinate[] Coordinates { get; }
    public Dimension Dimension { get; public set; }
    public IGeometry Envelope { get; }
    public Envelope EnvelopeInternal { get; }
    public IPoint InteriorPoint { get; }
    public IPoint PointOnSurface { get; }
    public object UserData { get; public set; }
    public bool IsEmpty { get; }
    public bool IsRectangle { get; }
    public bool IsSimple { get; }
    public bool IsValid { get; }
    public abstract virtual IGeometryFactory get_Factory();
    public abstract virtual IPrecisionModel get_PrecisionModel();
    public abstract virtual int get_SRID();
    public abstract virtual void set_SRID(int value);
    public abstract virtual string get_GeometryType();
    public abstract virtual OgcGeometryType get_OgcGeometryType();
    public abstract virtual double get_Area();
    public abstract virtual double get_Length();
    public abstract virtual int get_NumGeometries();
    public abstract virtual int get_NumPoints();
    public abstract virtual IGeometry get_Boundary();
    public abstract virtual Dimension get_BoundaryDimension();
    public abstract virtual IPoint get_Centroid();
    public abstract virtual Coordinate get_Coordinate();
    public abstract virtual Coordinate[] get_Coordinates();
    public abstract virtual Double[] GetOrdinates(Ordinate ordinate);
    public abstract virtual Dimension get_Dimension();
    public abstract virtual void set_Dimension(Dimension value);
    public abstract virtual IGeometry get_Envelope();
    public abstract virtual Envelope get_EnvelopeInternal();
    public abstract virtual IPoint get_InteriorPoint();
    public abstract virtual IPoint get_PointOnSurface();
    public abstract virtual IGeometry GetGeometryN(int n);
    public abstract virtual void Normalize();
    public abstract virtual IGeometry Normalized();
    public abstract virtual IGeometry Copy();
    public abstract virtual Byte[] AsBinary();
    public abstract virtual string AsText();
    public abstract virtual object get_UserData();
    public abstract virtual void set_UserData(object value);
    public abstract virtual IGeometry ConvexHull();
    public abstract virtual IntersectionMatrix Relate(IGeometry g);
    public abstract virtual IGeometry Difference(IGeometry other);
    public abstract virtual IGeometry SymmetricDifference(IGeometry other);
    public abstract virtual IGeometry Buffer(double distance);
    public abstract virtual IGeometry Buffer(double distance, int quadrantSegments);
    [ObsoleteAttribute]
public abstract virtual IGeometry Buffer(double distance, BufferStyle endCapStyle);
    [ObsoleteAttribute]
public abstract virtual IGeometry Buffer(double distance, int quadrantSegments, BufferStyle endCapStyle);
    public abstract virtual IGeometry Buffer(double distance, int quadrantSegments, EndCapStyle endCapStyle);
    public abstract virtual IGeometry Buffer(double distance, IBufferParameters bufferParameters);
    public abstract virtual IGeometry Intersection(IGeometry other);
    public abstract virtual IGeometry Union(IGeometry other);
    public abstract virtual IGeometry Union();
    [ObsoleteAttribute("Favor either EqualsTopologically or EqualsExact instead.")]
public abstract virtual bool Equals(IGeometry other);
    public abstract virtual bool EqualsTopologically(IGeometry other);
    public abstract virtual bool EqualsExact(IGeometry other);
    public abstract virtual bool EqualsExact(IGeometry other, double tolerance);
    public abstract virtual bool EqualsNormalized(IGeometry g);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual bool get_IsRectangle();
    public abstract virtual bool get_IsSimple();
    public abstract virtual bool get_IsValid();
    public abstract virtual bool Within(IGeometry g);
    public abstract virtual bool Contains(IGeometry g);
    public abstract virtual bool IsWithinDistance(IGeometry geom, double distance);
    public abstract virtual bool CoveredBy(IGeometry g);
    public abstract virtual bool Covers(IGeometry g);
    public abstract virtual bool Crosses(IGeometry g);
    public abstract virtual bool Intersects(IGeometry g);
    public abstract virtual bool Overlaps(IGeometry g);
    public abstract virtual bool Relate(IGeometry g, string intersectionPattern);
    public abstract virtual bool Touches(IGeometry g);
    public abstract virtual bool Disjoint(IGeometry g);
    public abstract virtual IGeometry Reverse();
    public abstract virtual double Distance(IGeometry g);
    public abstract virtual void Apply(ICoordinateFilter filter);
    public abstract virtual void Apply(ICoordinateSequenceFilter filter);
    public abstract virtual void Apply(IGeometryFilter filter);
    public abstract virtual void Apply(IGeometryComponentFilter filter);
    public abstract virtual void GeometryChanged();
    public abstract virtual void GeometryChangedAction();
}
[DefaultMemberAttribute("Item")]
public interface GeoAPI.Geometries.IGeometryCollection {
    public int Count { get; }
    public IGeometry[] Geometries { get; }
    public IGeometry Item { get; }
    public bool IsHomogeneous { get; }
    public abstract virtual int get_Count();
    public abstract virtual IGeometry[] get_Geometries();
    public abstract virtual IGeometry get_Item(int i);
    public abstract virtual bool get_IsHomogeneous();
}
public interface GeoAPI.Geometries.IGeometryComponentFilter {
    public abstract virtual void Filter(IGeometry geom);
}
public interface GeoAPI.Geometries.IGeometryFactory {
    public ICoordinateSequenceFactory CoordinateSequenceFactory { get; }
    public int SRID { get; }
    public IPrecisionModel PrecisionModel { get; }
    public abstract virtual ICoordinateSequenceFactory get_CoordinateSequenceFactory();
    public abstract virtual int get_SRID();
    public abstract virtual IPrecisionModel get_PrecisionModel();
    public abstract virtual IGeometry BuildGeometry(ICollection`1<IGeometry> geomList);
    public abstract virtual IGeometry CreateGeometry(IGeometry g);
    public abstract virtual IPoint CreatePoint();
    public abstract virtual IPoint CreatePoint(Coordinate coordinate);
    public abstract virtual IPoint CreatePoint(ICoordinateSequence coordinates);
    public abstract virtual ILineString CreateLineString();
    public abstract virtual ILineString CreateLineString(Coordinate[] coordinates);
    public abstract virtual ILineString CreateLineString(ICoordinateSequence coordinates);
    public abstract virtual ILinearRing CreateLinearRing();
    public abstract virtual ILinearRing CreateLinearRing(Coordinate[] coordinates);
    public abstract virtual ILinearRing CreateLinearRing(ICoordinateSequence coordinates);
    public abstract virtual IPolygon CreatePolygon();
    public abstract virtual IPolygon CreatePolygon(ILinearRing shell, ILinearRing[] holes);
    public abstract virtual IPolygon CreatePolygon(ICoordinateSequence coordinates);
    public abstract virtual IPolygon CreatePolygon(Coordinate[] coordinates);
    public abstract virtual IPolygon CreatePolygon(ILinearRing shell);
    public abstract virtual IMultiPoint CreateMultiPoint();
    [ObsoleteAttribute("Use CreateMultiPointFromCoords")]
public abstract virtual IMultiPoint CreateMultiPoint(Coordinate[] coordinates);
    public abstract virtual IMultiPoint CreateMultiPointFromCoords(Coordinate[] coordinates);
    public abstract virtual IMultiPoint CreateMultiPoint(IPoint[] point);
    public abstract virtual IMultiPoint CreateMultiPoint(ICoordinateSequence coordinates);
    public abstract virtual IMultiLineString CreateMultiLineString();
    public abstract virtual IMultiLineString CreateMultiLineString(ILineString[] lineStrings);
    public abstract virtual IMultiPolygon CreateMultiPolygon();
    public abstract virtual IMultiPolygon CreateMultiPolygon(IPolygon[] polygons);
    public abstract virtual IGeometryCollection CreateGeometryCollection();
    public abstract virtual IGeometryCollection CreateGeometryCollection(IGeometry[] geometries);
    public abstract virtual IGeometry ToGeometry(Envelope envelopeInternal);
}
public interface GeoAPI.Geometries.IGeometryFilter {
    public abstract virtual void Filter(IGeometry geom);
}
public interface GeoAPI.Geometries.IIntersectable`1 {
    public abstract virtual bool Intersects(T other);
}
public interface GeoAPI.Geometries.ILineal {
}
public interface GeoAPI.Geometries.ILinearRing {
    public bool IsCCW { get; }
    public abstract virtual bool get_IsCCW();
}
public interface GeoAPI.Geometries.ILineString {
    public abstract virtual IPoint GetPointN(int n);
    public abstract virtual Coordinate GetCoordinateN(int n);
}
public interface GeoAPI.Geometries.IMultiCurve {
    public bool IsClosed { get; }
    public abstract virtual bool get_IsClosed();
}
public interface GeoAPI.Geometries.IMultiLineString {
    [ObsoleteAttribute("Use IGeometry.Reverse()")]
public abstract virtual IMultiLineString Reverse();
}
public interface GeoAPI.Geometries.IMultiPoint {
}
public interface GeoAPI.Geometries.IMultiPolygon {
}
public interface GeoAPI.Geometries.IMultiSurface {
}
[DefaultMemberAttribute("Item")]
public class GeoAPI.Geometries.IntersectionMatrix : object {
    private Dimension[0...,0...] _matrix;
    public Dimension Item { get; public set; }
    public IntersectionMatrix(string elements);
    public IntersectionMatrix(IntersectionMatrix other);
    public void Add(IntersectionMatrix im);
    public static bool IsTrue(Dimension actualDimensionValue);
    public static bool Matches(Dimension actualDimensionValue, char requiredDimensionSymbol);
    public static bool Matches(string actualDimensionSymbols, string requiredDimensionSymbols);
    public void Set(Location row, Location column, Dimension dimensionValue);
    public void Set(string dimensionSymbols);
    public void SetAtLeast(Location row, Location column, Dimension minimumDimensionValue);
    public void SetAtLeastIfValid(Location row, Location column, Dimension minimumDimensionValue);
    public void SetAtLeast(string minimumDimensionSymbols);
    public void SetAll(Dimension dimensionValue);
    public Dimension Get(Location row, Location column);
    public Dimension get_Item(Location row, Location column);
    public void set_Item(Location row, Location column, Dimension value);
    public bool IsDisjoint();
    public bool IsIntersects();
    public bool IsTouches(Dimension dimensionOfGeometryA, Dimension dimensionOfGeometryB);
    public bool IsCrosses(Dimension dimensionOfGeometryA, Dimension dimensionOfGeometryB);
    public bool IsWithin();
    public bool IsContains();
    public bool IsCovers();
    public bool IsCoveredBy();
    public bool IsEquals(Dimension dimensionOfGeometryA, Dimension dimensionOfGeometryB);
    public bool IsOverlaps(Dimension dimensionOfGeometryA, Dimension dimensionOfGeometryB);
    public bool Matches(string requiredDimensionSymbols);
    public IntersectionMatrix Transpose();
    public virtual string ToString();
}
public interface GeoAPI.Geometries.IPoint {
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public double M { get; public set; }
    public ICoordinateSequence CoordinateSequence { get; }
    public abstract virtual double get_X();
    public abstract virtual void set_X(double value);
    public abstract virtual double get_Y();
    public abstract virtual void set_Y(double value);
    public abstract virtual double get_Z();
    public abstract virtual void set_Z(double value);
    public abstract virtual double get_M();
    public abstract virtual void set_M(double value);
    public abstract virtual ICoordinateSequence get_CoordinateSequence();
}
public interface GeoAPI.Geometries.IPolygon {
    public ILineString ExteriorRing { get; }
    public ILinearRing Shell { get; }
    public int NumInteriorRings { get; }
    public ILineString[] InteriorRings { get; }
    public ILinearRing[] Holes { get; }
    public abstract virtual ILineString get_ExteriorRing();
    public abstract virtual ILinearRing get_Shell();
    public abstract virtual int get_NumInteriorRings();
    public abstract virtual ILineString[] get_InteriorRings();
    public abstract virtual ILineString GetInteriorRingN(int n);
    public abstract virtual ILinearRing[] get_Holes();
}
public interface GeoAPI.Geometries.IPolygonal {
}
public interface GeoAPI.Geometries.IPrecisionModel {
    public PrecisionModels PrecisionModelType { get; }
    public bool IsFloating { get; }
    public int MaximumSignificantDigits { get; }
    public double Scale { get; }
    public abstract virtual PrecisionModels get_PrecisionModelType();
    public abstract virtual bool get_IsFloating();
    public abstract virtual int get_MaximumSignificantDigits();
    public abstract virtual double get_Scale();
    public abstract virtual double MakePrecise(double val);
    public abstract virtual void MakePrecise(Coordinate coord);
}
public interface GeoAPI.Geometries.IPuntal {
}
public interface GeoAPI.Geometries.ISurface {
}
public enum GeoAPI.Geometries.Location : Enum {
    public int value__;
    public static Location Interior;
    public static Location Boundary;
    public static Location Exterior;
    public static Location Null;
}
public class GeoAPI.Geometries.LocationUtility : object {
    public static char ToLocationSymbol(Location locationValue);
}
public enum GeoAPI.Geometries.OgcGeometryType : Enum {
    public int value__;
    public static OgcGeometryType Point;
    public static OgcGeometryType LineString;
    public static OgcGeometryType Polygon;
    public static OgcGeometryType MultiPoint;
    public static OgcGeometryType MultiLineString;
    public static OgcGeometryType MultiPolygon;
    public static OgcGeometryType GeometryCollection;
    public static OgcGeometryType CircularString;
    public static OgcGeometryType CompoundCurve;
    public static OgcGeometryType CurvePolygon;
    public static OgcGeometryType MultiCurve;
    public static OgcGeometryType MultiSurface;
    public static OgcGeometryType Curve;
    public static OgcGeometryType Surface;
    public static OgcGeometryType PolyhedralSurface;
    public static OgcGeometryType TIN;
}
public enum GeoAPI.Geometries.Ordinate : Enum {
    public int value__;
    public static Ordinate X;
    public static Ordinate Y;
    public static Ordinate Z;
    public static Ordinate M;
    public static Ordinate Ordinate2;
    public static Ordinate Ordinate3;
    public static Ordinate Ordinate4;
    public static Ordinate Ordinate5;
    public static Ordinate Ordinate6;
    public static Ordinate Ordinate7;
    public static Ordinate Ordinate8;
    public static Ordinate Ordinate9;
    public static Ordinate Ordinate10;
    public static Ordinate Ordinate11;
    public static Ordinate Ordinate12;
    public static Ordinate Ordinate13;
    public static Ordinate Ordinate14;
    public static Ordinate Ordinate15;
    public static Ordinate Ordinate16;
    public static Ordinate Ordinate17;
    public static Ordinate Ordinate18;
    public static Ordinate Ordinate19;
    public static Ordinate Ordinate20;
    public static Ordinate Ordinate21;
    public static Ordinate Ordinate22;
    public static Ordinate Ordinate23;
    public static Ordinate Ordinate24;
    public static Ordinate Ordinate25;
    public static Ordinate Ordinate26;
    public static Ordinate Ordinate27;
    public static Ordinate Ordinate28;
    public static Ordinate Ordinate29;
    public static Ordinate Ordinate30;
    public static Ordinate Ordinate31;
    public static Ordinate Ordinate32;
}
[FlagsAttribute]
public enum GeoAPI.Geometries.Ordinates : Enum {
    public int value__;
    public static Ordinates None;
    public static Ordinates X;
    public static Ordinates Y;
    public static Ordinates XY;
    public static Ordinates Z;
    public static Ordinates XYZ;
    public static Ordinates M;
    public static Ordinates XYM;
    public static Ordinates XYZM;
    public static Ordinates Ordinate2;
    public static Ordinates Ordinate3;
    public static Ordinates Ordinate4;
    public static Ordinates Ordinate5;
    public static Ordinates Ordinate6;
    public static Ordinates Ordinate7;
    public static Ordinates Ordinate8;
    public static Ordinates Ordinate9;
    public static Ordinates Ordinate10;
    public static Ordinates Ordinate11;
    public static Ordinates Ordinate12;
    public static Ordinates Ordinate13;
    public static Ordinates Ordinate14;
    public static Ordinates Ordinate15;
    public static Ordinates Ordinate16;
    public static Ordinates Ordinate17;
    public static Ordinates Ordinate18;
    public static Ordinates Ordinate19;
    public static Ordinates Ordinate20;
    public static Ordinates Ordinate21;
    public static Ordinates Ordinate22;
    public static Ordinates Ordinate23;
    public static Ordinates Ordinate24;
    public static Ordinates Ordinate25;
    public static Ordinates Ordinate26;
    public static Ordinates Ordinate27;
    public static Ordinates Ordinate28;
    public static Ordinates Ordinate29;
    public static Ordinates Ordinate30;
    public static Ordinates Ordinate31;
    public static Ordinates Ordinate32;
}
public static class GeoAPI.Geometries.OrdinatesUtility : object {
    public static int OrdinatesToDimension(Ordinates ordinates);
    public static Ordinates DimensionToOrdinates(int dimension);
    public static Ordinate[] ToOrdinateArray(Ordinates ordinates, int maxEval);
    public static Ordinates ToOrdinatesFlag(Ordinate[] ordinates);
}
public enum GeoAPI.Geometries.PrecisionModels : Enum {
    public int value__;
    public static PrecisionModels Floating;
    public static PrecisionModels FloatingSingle;
    public static PrecisionModels Fixed;
}
public interface GeoAPI.Geometries.Prepared.IPreparedGeometry {
    public IGeometry Geometry { get; }
    public abstract virtual IGeometry get_Geometry();
    public abstract virtual bool Contains(IGeometry geom);
    public abstract virtual bool ContainsProperly(IGeometry geom);
    public abstract virtual bool CoveredBy(IGeometry geom);
    public abstract virtual bool Covers(IGeometry geom);
    public abstract virtual bool Crosses(IGeometry geom);
    public abstract virtual bool Disjoint(IGeometry geom);
    public abstract virtual bool Intersects(IGeometry geom);
    public abstract virtual bool Overlaps(IGeometry geom);
    public abstract virtual bool Touches(IGeometry geom);
    public abstract virtual bool Within(IGeometry geom);
}
public static class GeoAPI.GeometryServiceProvider : object {
    private static IGeometryServices modreq(System.Runtime.CompilerServices.IsVolatile) s_instance;
    private static object s_autoInitLock;
    private static object s_explicitInitLock;
    private static bool s_instanceSetDirectly;
    public static IGeometryServices Instance { get; public set; }
    private static GeometryServiceProvider();
    public static IGeometryServices get_Instance();
    public static void set_Instance(IGeometryServices value);
    public static bool SetInstanceIfNotAlreadySetDirectly(IGeometryServices instance);
    private static IGeometryServices InitializeInstance();
}
[ObsoleteAttribute("Not used", "True")]
public class GeoAPI.GetCoordinateSystemDelegate`1 : MulticastDelegate {
    public GetCoordinateSystemDelegate`1(object object, IntPtr method);
    public virtual TCoordinateSystem Invoke(string init);
    public virtual IAsyncResult BeginInvoke(string init, AsyncCallback callback, object object);
    public virtual TCoordinateSystem EndInvoke(IAsyncResult result);
}
public interface GeoAPI.IGeometryServices {
    public int DefaultSRID { get; }
    public ICoordinateSequenceFactory DefaultCoordinateSequenceFactory { get; }
    public IPrecisionModel DefaultPrecisionModel { get; }
    public abstract virtual int get_DefaultSRID();
    public abstract virtual ICoordinateSequenceFactory get_DefaultCoordinateSequenceFactory();
    public abstract virtual IPrecisionModel get_DefaultPrecisionModel();
    public abstract virtual IPrecisionModel CreatePrecisionModel(PrecisionModels modelType);
    public abstract virtual IPrecisionModel CreatePrecisionModel(IPrecisionModel modelType);
    public abstract virtual IPrecisionModel CreatePrecisionModel(double scale);
    public abstract virtual IGeometryFactory CreateGeometryFactory();
    public abstract virtual IGeometryFactory CreateGeometryFactory(int srid);
    public abstract virtual IGeometryFactory CreateGeometryFactory(ICoordinateSequenceFactory coordinateSequenceFactory);
    public abstract virtual IGeometryFactory CreateGeometryFactory(IPrecisionModel precisionModel);
    public abstract virtual IGeometryFactory CreateGeometryFactory(IPrecisionModel precisionModel, int srid);
    public abstract virtual IGeometryFactory CreateGeometryFactory(IPrecisionModel precisionModel, int srid, ICoordinateSequenceFactory coordinateSequenceFactory);
    public abstract virtual void ReadConfiguration();
    public abstract virtual void WriteConfiguration();
}
public enum GeoAPI.IO.ByteOrder : Enum {
    public byte value__;
    public static ByteOrder BigEndian;
    public static ByteOrder LittleEndian;
}
[CLSCompliantAttribute("False")]
public class GeoAPI.IO.GeometryType : ValueType {
    private UInt32 _geometrytype;
    private static UInt32 EwkbZFlag;
    private static UInt32 EwkbMFlag;
    private static UInt32 EwkbSridFlag;
    private static UInt32 EwkbFlags;
    public OgcGeometryType BaseGeometryType { get; public set; }
    public int WkbGeometryType { get; }
    public int EwkbWkbGeometryType { get; }
    public bool HasZ { get; }
    public bool HasM { get; }
    public bool HasSrid { get; }
    public bool HasWkbZ { get; public set; }
    public bool HasWkbM { get; public set; }
    public bool HasEwkbZ { get; public set; }
    public bool HasEwkbM { get; public set; }
    public bool HasEwkbSrid { get; public set; }
    public GeometryType(UInt32 geometryType);
    public GeometryType(IGeometry geometry, Ordinates ordinates);
    public GeometryType(OgcGeometryType ogcGeometryType);
    public GeometryType(OgcGeometryType ogcGeometryType, bool hasSrid);
    public GeometryType(OgcGeometryType ogcGeometryType, Ordinates ordinates, bool hasSrid);
    public OgcGeometryType get_BaseGeometryType();
    public void set_BaseGeometryType(OgcGeometryType value);
    public int get_WkbGeometryType();
    public int get_EwkbWkbGeometryType();
    public bool get_HasZ();
    public bool get_HasM();
    public bool get_HasSrid();
    public bool get_HasWkbZ();
    public void set_HasWkbZ(bool value);
    public bool get_HasWkbM();
    public void set_HasWkbM(bool value);
    public bool get_HasEwkbZ();
    public void set_HasEwkbZ(bool value);
    public bool get_HasEwkbM();
    public void set_HasEwkbM(bool value);
    public bool get_HasEwkbSrid();
    public void set_HasEwkbSrid(bool value);
}
public interface GeoAPI.IO.IBinaryGeometryReader {
}
public interface GeoAPI.IO.IBinaryGeometryWriter {
    public ByteOrder ByteOrder { get; public set; }
    public abstract virtual ByteOrder get_ByteOrder();
    public abstract virtual void set_ByteOrder(ByteOrder value);
}
public interface GeoAPI.IO.IGeometryIOSettings {
    public bool HandleSRID { get; public set; }
    public Ordinates AllowedOrdinates { get; }
    public Ordinates HandleOrdinates { get; public set; }
    public abstract virtual bool get_HandleSRID();
    public abstract virtual void set_HandleSRID(bool value);
    public abstract virtual Ordinates get_AllowedOrdinates();
    public abstract virtual Ordinates get_HandleOrdinates();
    public abstract virtual void set_HandleOrdinates(Ordinates value);
}
public interface GeoAPI.IO.IGeometryReader`1 {
    public bool RepairRings { get; public set; }
    public abstract virtual IGeometry Read(TSource source);
    public abstract virtual IGeometry Read(Stream stream);
    public abstract virtual bool get_RepairRings();
    public abstract virtual void set_RepairRings(bool value);
}
public interface GeoAPI.IO.IGeometryWriter`1 {
    public abstract virtual TSink Write(IGeometry geometry);
    public abstract virtual void Write(IGeometry geometry, Stream stream);
}
public interface GeoAPI.IO.ITextGeometryReader {
}
public interface GeoAPI.IO.ITextGeometryWriter {
}
public class GeoAPI.IO.ParseException : ApplicationException {
    public ParseException(string message);
    public ParseException(Exception e);
    public ParseException(string message, Exception innerException);
}
[ObsoleteAttribute("Use EndCapStyle instead.")]
public enum GeoAPI.Operation.Buffer.BufferStyle : Enum {
    public int value__;
    public static BufferStyle CapRound;
    public static BufferStyle CapButt;
    public static BufferStyle CapSquare;
}
public enum GeoAPI.Operation.Buffer.EndCapStyle : Enum {
    public int value__;
    public static EndCapStyle Round;
    public static EndCapStyle Flat;
    public static EndCapStyle Square;
}
public interface GeoAPI.Operation.Buffer.IBufferParameters {
    public int QuadrantSegments { get; public set; }
    public EndCapStyle EndCapStyle { get; public set; }
    public JoinStyle JoinStyle { get; public set; }
    public double MitreLimit { get; public set; }
    public bool IsSingleSided { get; public set; }
    public double SimplifyFactor { get; public set; }
    public abstract virtual int get_QuadrantSegments();
    public abstract virtual void set_QuadrantSegments(int value);
    public abstract virtual EndCapStyle get_EndCapStyle();
    public abstract virtual void set_EndCapStyle(EndCapStyle value);
    public abstract virtual JoinStyle get_JoinStyle();
    public abstract virtual void set_JoinStyle(JoinStyle value);
    public abstract virtual double get_MitreLimit();
    public abstract virtual void set_MitreLimit(double value);
    public abstract virtual bool get_IsSingleSided();
    public abstract virtual void set_IsSingleSided(bool value);
    public abstract virtual double get_SimplifyFactor();
    public abstract virtual void set_SimplifyFactor(double value);
}
public enum GeoAPI.Operation.Buffer.JoinStyle : Enum {
    public int value__;
    public static JoinStyle Round;
    public static JoinStyle Mitre;
    public static JoinStyle Bevel;
}
internal static class GeoAPI.ValueParser : object {
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Double& result);
}
