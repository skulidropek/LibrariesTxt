[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public class RabbitMQ.Client.AmqpTcpEndpoint : object {
    public static int DefaultAmqpSslPort;
    public static int UseDefaultPort;
    private int _port;
    private UInt32 _maxMessageSize;
    [CompilerGeneratedAttribute]
private string <HostName>k__BackingField;
    [CompilerGeneratedAttribute]
private AddressFamily <AddressFamily>k__BackingField;
    [CompilerGeneratedAttribute]
private SslOption <Ssl>k__BackingField;
    public string HostName { get; public set; }
    public int Port { get; public set; }
    public IProtocol Protocol { get; }
    public AddressFamily AddressFamily { get; public set; }
    public SslOption Ssl { get; public set; }
    public UInt32 MaxMessageSize { get; }
    public AmqpTcpEndpoint(string hostName, int portOrMinusOne, SslOption ssl, UInt32 maxMessageSize);
    public AmqpTcpEndpoint(string hostName, int portOrMinusOne, SslOption ssl);
    public AmqpTcpEndpoint(string hostName, int portOrMinusOne);
    public AmqpTcpEndpoint(Uri uri, SslOption ssl);
    public AmqpTcpEndpoint(Uri uri);
    public object Clone();
    public AmqpTcpEndpoint CloneWithHostname(string hostname);
    [CompilerGeneratedAttribute]
public string get_HostName();
    [CompilerGeneratedAttribute]
public void set_HostName(string value);
    public int get_Port();
    public void set_Port(int value);
    public IProtocol get_Protocol();
    [CompilerGeneratedAttribute]
public AddressFamily get_AddressFamily();
    [CompilerGeneratedAttribute]
public void set_AddressFamily(AddressFamily value);
    [CompilerGeneratedAttribute]
public SslOption get_Ssl();
    [CompilerGeneratedAttribute]
public void set_Ssl(SslOption value);
    public UInt32 get_MaxMessageSize();
    public static AmqpTcpEndpoint Parse(string address);
    public static AmqpTcpEndpoint[] ParseMultiple(string addresses);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class RabbitMQ.Client.AmqpTimestamp : ValueType {
    [CompilerGeneratedAttribute]
private long <UnixTime>k__BackingField;
    public long UnixTime { get; private set; }
    public AmqpTimestamp(long unixTime);
    [CompilerGeneratedAttribute]
public long get_UnixTime();
    [CompilerGeneratedAttribute]
private void set_UnixTime(long value);
    public virtual string ToString();
}
internal abstract class RabbitMQ.Client.Apigen.Attributes.AmqpApigenAttribute : Attribute {
    public string m_namespaceName;
    public AmqpApigenAttribute(string namespaceName);
}
[AttributeUsageAttribute("32767")]
internal class RabbitMQ.Client.Apigen.Attributes.AmqpAsynchronousHandlerAttribute : AmqpApigenAttribute {
    public AmqpAsynchronousHandlerAttribute(string namespaceName);
}
internal class RabbitMQ.Client.Apigen.Attributes.AmqpContentBodyMappingAttribute : Attribute {
}
internal class RabbitMQ.Client.Apigen.Attributes.AmqpContentHeaderFactoryAttribute : Attribute {
    public string m_contentClass;
    public AmqpContentHeaderFactoryAttribute(string contentClass);
}
internal class RabbitMQ.Client.Apigen.Attributes.AmqpContentHeaderMappingAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
internal class RabbitMQ.Client.Apigen.Attributes.AmqpFieldMappingAttribute : AmqpApigenAttribute {
    public string m_fieldName;
    public AmqpFieldMappingAttribute(string namespaceName, string fieldName);
}
internal class RabbitMQ.Client.Apigen.Attributes.AmqpForceOneWayAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
internal class RabbitMQ.Client.Apigen.Attributes.AmqpMethodDoNotImplementAttribute : AmqpApigenAttribute {
    public AmqpMethodDoNotImplementAttribute(string namespaceName);
}
[AttributeUsageAttribute("32767")]
internal class RabbitMQ.Client.Apigen.Attributes.AmqpMethodMappingAttribute : AmqpApigenAttribute {
    public string m_className;
    public string m_methodName;
    public AmqpMethodMappingAttribute(string namespaceName, string className, string methodName);
}
[AttributeUsageAttribute("32767")]
internal class RabbitMQ.Client.Apigen.Attributes.AmqpNowaitArgumentAttribute : AmqpApigenAttribute {
    public string m_replacementExpression;
    public AmqpNowaitArgumentAttribute(string namespaceName);
    public AmqpNowaitArgumentAttribute(string namespaceName, string replacementExpression);
}
[AttributeUsageAttribute("32767")]
internal class RabbitMQ.Client.Apigen.Attributes.AmqpUnsupportedAttribute : AmqpApigenAttribute {
    public AmqpUnsupportedAttribute(string namespaceName);
}
public class RabbitMQ.Client.AsyncDefaultBasicConsumer : object {
    private HashSet`1<string> _consumerTags;
    [CompilerGeneratedAttribute]
private bool <IsRunning>k__BackingField;
    [CompilerGeneratedAttribute]
private ShutdownEventArgs <ShutdownReason>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncEventHandler`1<ConsumerEventArgs> ConsumerCancelled;
    [CompilerGeneratedAttribute]
private IModel <Model>k__BackingField;
    public String[] ConsumerTags { get; }
    public bool IsRunning { get; protected set; }
    public ShutdownEventArgs ShutdownReason { get; protected set; }
    public IModel Model { get; public set; }
    public AsyncDefaultBasicConsumer(IModel model);
    public String[] get_ConsumerTags();
    [CompilerGeneratedAttribute]
public bool get_IsRunning();
    [CompilerGeneratedAttribute]
protected void set_IsRunning(bool value);
    [CompilerGeneratedAttribute]
public ShutdownEventArgs get_ShutdownReason();
    [CompilerGeneratedAttribute]
protected void set_ShutdownReason(ShutdownEventArgs value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ConsumerCancelled(AsyncEventHandler`1<ConsumerEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ConsumerCancelled(AsyncEventHandler`1<ConsumerEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual IModel get_Model();
    [CompilerGeneratedAttribute]
public void set_Model(IModel value);
    public virtual Task HandleBasicCancel(string consumerTag);
    public virtual Task HandleBasicCancelOk(string consumerTag);
    public virtual Task HandleBasicConsumeOk(string consumerTag);
    public virtual Task HandleBasicDeliver(string consumerTag, ulong deliveryTag, bool redelivered, string exchange, string routingKey, IBasicProperties properties, ReadOnlyMemory`1<byte> body);
    public virtual Task HandleModelShutdown(object model, ShutdownEventArgs reason);
    [AsyncStateMachineAttribute("RabbitMQ.Client.AsyncDefaultBasicConsumer/<OnCancel>d__25")]
public virtual Task OnCancel(String[] consumerTags);
    private sealed virtual override void RabbitMQ.Client.IBasicConsumer.add_ConsumerCancelled(EventHandler`1<ConsumerEventArgs> value);
    private sealed virtual override void RabbitMQ.Client.IBasicConsumer.remove_ConsumerCancelled(EventHandler`1<ConsumerEventArgs> value);
    private sealed virtual override void RabbitMQ.Client.IBasicConsumer.HandleBasicCancelOk(string consumerTag);
    private sealed virtual override void RabbitMQ.Client.IBasicConsumer.HandleBasicConsumeOk(string consumerTag);
    private sealed virtual override void RabbitMQ.Client.IBasicConsumer.HandleBasicDeliver(string consumerTag, ulong deliveryTag, bool redelivered, string exchange, string routingKey, IBasicProperties properties, ReadOnlyMemory`1<byte> body);
    private sealed virtual override void RabbitMQ.Client.IBasicConsumer.HandleModelShutdown(object model, ShutdownEventArgs reason);
    private sealed virtual override void RabbitMQ.Client.IBasicConsumer.HandleBasicCancel(string consumerTag);
}
public class RabbitMQ.Client.BasicCredentialsProvider : object {
    private string _name;
    private string _userName;
    private string _password;
    public string Name { get; }
    public string UserName { get; }
    public string Password { get; }
    public Nullable`1<TimeSpan> ValidUntil { get; }
    public BasicCredentialsProvider(string userName, string password);
    public BasicCredentialsProvider(string name, string userName, string password);
    public sealed virtual string get_Name();
    public sealed virtual string get_UserName();
    public sealed virtual string get_Password();
    public sealed virtual Nullable`1<TimeSpan> get_ValidUntil();
    public sealed virtual void Refresh();
}
public class RabbitMQ.Client.BasicGetResult : object {
    [CompilerGeneratedAttribute]
private IBasicProperties <BasicProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<byte> <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <DeliveryTag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exchange>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MessageCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Redelivered>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RoutingKey>k__BackingField;
    public IBasicProperties BasicProperties { get; private set; }
    public ReadOnlyMemory`1<byte> Body { get; private set; }
    public ulong DeliveryTag { get; private set; }
    public string Exchange { get; private set; }
    public UInt32 MessageCount { get; private set; }
    public bool Redelivered { get; private set; }
    public string RoutingKey { get; private set; }
    public BasicGetResult(ulong deliveryTag, bool redelivered, string exchange, string routingKey, UInt32 messageCount, IBasicProperties basicProperties, ReadOnlyMemory`1<byte> body);
    [CompilerGeneratedAttribute]
public IBasicProperties get_BasicProperties();
    [CompilerGeneratedAttribute]
private void set_BasicProperties(IBasicProperties value);
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<byte> get_Body();
    [CompilerGeneratedAttribute]
private void set_Body(ReadOnlyMemory`1<byte> value);
    [CompilerGeneratedAttribute]
public ulong get_DeliveryTag();
    [CompilerGeneratedAttribute]
private void set_DeliveryTag(ulong value);
    [CompilerGeneratedAttribute]
public string get_Exchange();
    [CompilerGeneratedAttribute]
private void set_Exchange(string value);
    [CompilerGeneratedAttribute]
public UInt32 get_MessageCount();
    [CompilerGeneratedAttribute]
private void set_MessageCount(UInt32 value);
    [CompilerGeneratedAttribute]
public bool get_Redelivered();
    [CompilerGeneratedAttribute]
private void set_Redelivered(bool value);
    [CompilerGeneratedAttribute]
public string get_RoutingKey();
    [CompilerGeneratedAttribute]
private void set_RoutingKey(string value);
}
[ExtensionAttribute]
public static class RabbitMQ.Client.BasicPublishBatchExtensions : object {
    [ExtensionAttribute]
public static void Add(IBasicPublishBatch batch, string exchange, string routingKey, bool mandatory, IBasicProperties properties, ReadOnlyMemory`1<byte> body);
}
public class RabbitMQ.Client.BinaryTableValue : object {
    [CompilerGeneratedAttribute]
private Byte[] <Bytes>k__BackingField;
    public Byte[] Bytes { get; public set; }
    public BinaryTableValue(Byte[] bytes);
    [CompilerGeneratedAttribute]
public Byte[] get_Bytes();
    [CompilerGeneratedAttribute]
public void set_Bytes(Byte[] value);
}
public class RabbitMQ.Client.ConnectionFactory : ConnectionFactoryBase {
    private static ICredentialsRefresher s_defaultCredentialsRefresher;
    private ICredentialsProvider _credentialsProvider;
    public static ushort DefaultChannelMax;
    public static TimeSpan DefaultConnectionTimeout;
    public static UInt32 DefaultFrameMax;
    public static UInt32 DefaultMaxMessageSize;
    public static TimeSpan DefaultHeartbeat;
    public static string DefaultPass;
    public static string DefaultUser;
    public static string DefaultVHost;
    [CompilerGeneratedAttribute]
private static SslProtocols <DefaultAmqpUriSslProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private SslProtocols <AmqpUriSslProtocols>k__BackingField;
    public static IList`1<IAuthMechanismFactory> DefaultAuthMechanisms;
    [CompilerGeneratedAttribute]
private IList`1<IAuthMechanismFactory> <AuthMechanisms>k__BackingField;
    [CompilerGeneratedAttribute]
private static AddressFamily <DefaultAddressFamily>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutomaticRecoveryEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DispatchConsumersAsync>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ConsumerDispatchConcurrency>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HostName>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <NetworkRecoveryInterval>k__BackingField;
    private TimeSpan _handshakeContinuationTimeout;
    private TimeSpan _continuationTimeout;
    private Uri _uri;
    private ArrayPool`1<byte> _memoryPool;
    [CompilerGeneratedAttribute]
private Func`2<IEnumerable`1<AmqpTcpEndpoint>, IEndpointResolver> <EndpointResolverFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RequestedConnectionTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <SocketReadTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <SocketWriteTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private SslOption <Ssl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TopologyRecoveryEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private TopologyRecoveryFilter <TopologyRecoveryFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private TopologyRecoveryExceptionHandler <TopologyRecoveryExceptionHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <ClientProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private ICredentialsRefresher <CredentialsRefresher>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <RequestedChannelMax>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <RequestedFrameMax>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RequestedHeartbeat>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseBackgroundThreadsForIO>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VirtualHost>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MaxMessageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientProvidedName>k__BackingField;
    public static SslProtocols DefaultAmqpUriSslProtocols { get; public set; }
    public SslProtocols AmqpUriSslProtocols { get; public set; }
    public IList`1<IAuthMechanismFactory> AuthMechanisms { get; public set; }
    public static AddressFamily DefaultAddressFamily { get; public set; }
    public bool AutomaticRecoveryEnabled { get; public set; }
    public bool DispatchConsumersAsync { get; public set; }
    public int ConsumerDispatchConcurrency { get; public set; }
    public string HostName { get; public set; }
    public TimeSpan NetworkRecoveryInterval { get; public set; }
    public ArrayPool`1<byte> MemoryPool { get; public set; }
    public TimeSpan HandshakeContinuationTimeout { get; public set; }
    public TimeSpan ContinuationTimeout { get; public set; }
    public Func`2<IEnumerable`1<AmqpTcpEndpoint>, IEndpointResolver> EndpointResolverFactory { get; public set; }
    public int Port { get; public set; }
    public TimeSpan RequestedConnectionTimeout { get; public set; }
    public TimeSpan SocketReadTimeout { get; public set; }
    public TimeSpan SocketWriteTimeout { get; public set; }
    public SslOption Ssl { get; public set; }
    public bool TopologyRecoveryEnabled { get; public set; }
    public TopologyRecoveryFilter TopologyRecoveryFilter { get; public set; }
    public TopologyRecoveryExceptionHandler TopologyRecoveryExceptionHandler { get; public set; }
    public AmqpTcpEndpoint Endpoint { get; public set; }
    public IDictionary`2<string, object> ClientProperties { get; public set; }
    public string UserName { get; public set; }
    public string Password { get; public set; }
    public ICredentialsProvider CredentialsProvider { get; public set; }
    public ICredentialsRefresher CredentialsRefresher { get; public set; }
    public ushort RequestedChannelMax { get; public set; }
    public UInt32 RequestedFrameMax { get; public set; }
    public TimeSpan RequestedHeartbeat { get; public set; }
    [ObsoleteAttribute("Currently a no-op. UseBackgroundThreadsForIO will be removed in version 7")]
public bool UseBackgroundThreadsForIO { get; public set; }
    public string VirtualHost { get; public set; }
    public UInt32 MaxMessageSize { get; public set; }
    public Uri Uri { get; public set; }
    public string ClientProvidedName { get; public set; }
    private static ConnectionFactory();
    [CompilerGeneratedAttribute]
public static SslProtocols get_DefaultAmqpUriSslProtocols();
    [CompilerGeneratedAttribute]
public static void set_DefaultAmqpUriSslProtocols(SslProtocols value);
    [CompilerGeneratedAttribute]
public SslProtocols get_AmqpUriSslProtocols();
    [CompilerGeneratedAttribute]
public void set_AmqpUriSslProtocols(SslProtocols value);
    [CompilerGeneratedAttribute]
public IList`1<IAuthMechanismFactory> get_AuthMechanisms();
    [CompilerGeneratedAttribute]
public void set_AuthMechanisms(IList`1<IAuthMechanismFactory> value);
    [CompilerGeneratedAttribute]
public static AddressFamily get_DefaultAddressFamily();
    [CompilerGeneratedAttribute]
public static void set_DefaultAddressFamily(AddressFamily value);
    [CompilerGeneratedAttribute]
public bool get_AutomaticRecoveryEnabled();
    [CompilerGeneratedAttribute]
public void set_AutomaticRecoveryEnabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DispatchConsumersAsync();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DispatchConsumersAsync(bool value);
    [CompilerGeneratedAttribute]
public int get_ConsumerDispatchConcurrency();
    [CompilerGeneratedAttribute]
public void set_ConsumerDispatchConcurrency(int value);
    [CompilerGeneratedAttribute]
public string get_HostName();
    [CompilerGeneratedAttribute]
public void set_HostName(string value);
    [CompilerGeneratedAttribute]
public TimeSpan get_NetworkRecoveryInterval();
    [CompilerGeneratedAttribute]
public void set_NetworkRecoveryInterval(TimeSpan value);
    public ArrayPool`1<byte> get_MemoryPool();
    public void set_MemoryPool(ArrayPool`1<byte> value);
    public sealed virtual TimeSpan get_HandshakeContinuationTimeout();
    public sealed virtual void set_HandshakeContinuationTimeout(TimeSpan value);
    public sealed virtual TimeSpan get_ContinuationTimeout();
    public sealed virtual void set_ContinuationTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public Func`2<IEnumerable`1<AmqpTcpEndpoint>, IEndpointResolver> get_EndpointResolverFactory();
    [CompilerGeneratedAttribute]
public void set_EndpointResolverFactory(Func`2<IEnumerable`1<AmqpTcpEndpoint>, IEndpointResolver> value);
    [CompilerGeneratedAttribute]
public int get_Port();
    [CompilerGeneratedAttribute]
public void set_Port(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RequestedConnectionTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestedConnectionTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_SocketReadTimeout();
    [CompilerGeneratedAttribute]
public void set_SocketReadTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_SocketWriteTimeout();
    [CompilerGeneratedAttribute]
public void set_SocketWriteTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public SslOption get_Ssl();
    [CompilerGeneratedAttribute]
public void set_Ssl(SslOption value);
    [CompilerGeneratedAttribute]
public bool get_TopologyRecoveryEnabled();
    [CompilerGeneratedAttribute]
public void set_TopologyRecoveryEnabled(bool value);
    [CompilerGeneratedAttribute]
public TopologyRecoveryFilter get_TopologyRecoveryFilter();
    [CompilerGeneratedAttribute]
public void set_TopologyRecoveryFilter(TopologyRecoveryFilter value);
    [CompilerGeneratedAttribute]
public TopologyRecoveryExceptionHandler get_TopologyRecoveryExceptionHandler();
    [CompilerGeneratedAttribute]
public void set_TopologyRecoveryExceptionHandler(TopologyRecoveryExceptionHandler value);
    public AmqpTcpEndpoint get_Endpoint();
    public void set_Endpoint(AmqpTcpEndpoint value);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, object> get_ClientProperties();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ClientProperties(IDictionary`2<string, object> value);
    public sealed virtual string get_UserName();
    public sealed virtual void set_UserName(string value);
    public sealed virtual string get_Password();
    public sealed virtual void set_Password(string value);
    public sealed virtual ICredentialsProvider get_CredentialsProvider();
    public sealed virtual void set_CredentialsProvider(ICredentialsProvider value);
    [CompilerGeneratedAttribute]
public sealed virtual ICredentialsRefresher get_CredentialsRefresher();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CredentialsRefresher(ICredentialsRefresher value);
    [CompilerGeneratedAttribute]
public sealed virtual ushort get_RequestedChannelMax();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RequestedChannelMax(ushort value);
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_RequestedFrameMax();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RequestedFrameMax(UInt32 value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_RequestedHeartbeat();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RequestedHeartbeat(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseBackgroundThreadsForIO();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UseBackgroundThreadsForIO(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_VirtualHost();
    [CompilerGeneratedAttribute]
public sealed virtual void set_VirtualHost(string value);
    [CompilerGeneratedAttribute]
public UInt32 get_MaxMessageSize();
    [CompilerGeneratedAttribute]
public void set_MaxMessageSize(UInt32 value);
    public sealed virtual Uri get_Uri();
    public sealed virtual void set_Uri(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ClientProvidedName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ClientProvidedName(string value);
    public sealed virtual IAuthMechanismFactory AuthMechanismFactory(IList`1<string> mechanismNames);
    public sealed virtual IConnection CreateConnection();
    public sealed virtual IConnection CreateConnection(string clientProvidedName);
    public sealed virtual IConnection CreateConnection(IList`1<string> hostnames);
    public sealed virtual IConnection CreateConnection(IList`1<string> hostnames, string clientProvidedName);
    public sealed virtual IConnection CreateConnection(IList`1<AmqpTcpEndpoint> endpoints);
    public sealed virtual IConnection CreateConnection(IList`1<AmqpTcpEndpoint> endpoints, string clientProvidedName);
    public IConnection CreateConnection(IEndpointResolver endpointResolver, string clientProvidedName);
    internal IFrameHandler CreateFrameHandler(AmqpTcpEndpoint endpoint);
    private IFrameHandler ConfigureFrameHandler(IFrameHandler fh);
    private void SetUri(Uri uri);
    private static string UriDecode(string uri);
    private List`1<AmqpTcpEndpoint> LocalEndpoints();
    [CompilerGeneratedAttribute]
private AmqpTcpEndpoint <CreateConnection>b__152_0(string h);
}
public class RabbitMQ.Client.ConnectionFactoryBase : object {
    public Func`2<AddressFamily, ITcpClient> SocketFactory;
    public static ITcpClient DefaultSocketFactory(AddressFamily addressFamily);
}
public static class RabbitMQ.Client.Constants : object {
    public static int FrameMethod;
    public static int FrameHeader;
    public static int FrameBody;
    public static int FrameHeartbeat;
    public static int FrameMinSize;
    public static int FrameEnd;
    public static int ReplySuccess;
    public static int ContentTooLarge;
    public static int NoRoute;
    public static int NoConsumers;
    public static int ConnectionForced;
    public static int InvalidPath;
    public static int AccessRefused;
    public static int NotFound;
    public static int ResourceLocked;
    public static int PreconditionFailed;
    public static int FrameError;
    public static int SyntaxError;
    public static int CommandInvalid;
    public static int ChannelError;
    public static int UnexpectedFrame;
    public static int ResourceError;
    public static int NotAllowed;
    public static int NotImplemented;
    public static int InternalError;
}
public class RabbitMQ.Client.DefaultBasicConsumer : object {
    private HashSet`1<string> _consumerTags;
    [CompilerGeneratedAttribute]
private bool <IsRunning>k__BackingField;
    [CompilerGeneratedAttribute]
private ShutdownEventArgs <ShutdownReason>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<ConsumerEventArgs> ConsumerCancelled;
    [CompilerGeneratedAttribute]
private IModel <Model>k__BackingField;
    public String[] ConsumerTags { get; }
    public bool IsRunning { get; protected set; }
    public ShutdownEventArgs ShutdownReason { get; protected set; }
    public IModel Model { get; public set; }
    public DefaultBasicConsumer(IModel model);
    public String[] get_ConsumerTags();
    [CompilerGeneratedAttribute]
public bool get_IsRunning();
    [CompilerGeneratedAttribute]
protected void set_IsRunning(bool value);
    [CompilerGeneratedAttribute]
public ShutdownEventArgs get_ShutdownReason();
    [CompilerGeneratedAttribute]
protected void set_ShutdownReason(ShutdownEventArgs value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ConsumerCancelled(EventHandler`1<ConsumerEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ConsumerCancelled(EventHandler`1<ConsumerEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual IModel get_Model();
    [CompilerGeneratedAttribute]
public void set_Model(IModel value);
    public virtual void HandleBasicCancel(string consumerTag);
    public virtual void HandleBasicCancelOk(string consumerTag);
    public virtual void HandleBasicConsumeOk(string consumerTag);
    public virtual void HandleBasicDeliver(string consumerTag, ulong deliveryTag, bool redelivered, string exchange, string routingKey, IBasicProperties properties, ReadOnlyMemory`1<byte> body);
    public virtual void HandleModelShutdown(object model, ShutdownEventArgs reason);
    public virtual void OnCancel(String[] consumerTags);
}
public class RabbitMQ.Client.DefaultEndpointResolver : object {
    private List`1<AmqpTcpEndpoint> _endpoints;
    private Random _rnd;
    public DefaultEndpointResolver(IEnumerable`1<AmqpTcpEndpoint> tcpEndpoints);
    public sealed virtual IEnumerable`1<AmqpTcpEndpoint> All();
    [CompilerGeneratedAttribute]
private int <All>b__3_0(AmqpTcpEndpoint item);
}
[ExtensionAttribute]
public static class RabbitMQ.Client.EndpointResolverExtensions : object {
    [ExtensionAttribute]
public static T SelectOne(IEndpointResolver resolver, Func`2<AmqpTcpEndpoint, T> selector);
}
public class RabbitMQ.Client.Events.AsyncEventHandler`1 : MulticastDelegate {
    public AsyncEventHandler`1(object object, IntPtr method);
    public virtual Task Invoke(object sender, TEvent event);
    public virtual IAsyncResult BeginInvoke(object sender, TEvent event, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
internal static class RabbitMQ.Client.Events.AsyncEventHandlerExtensions : object {
    [AsyncStateMachineAttribute("RabbitMQ.Client.Events.AsyncEventHandlerExtensions/<InvokeAsync>d__0`1")]
[ExtensionAttribute]
public static Task InvokeAsync(AsyncEventHandler`1<TEvent> eventHandler, object sender, TEvent event);
}
public class RabbitMQ.Client.Events.AsyncEventingBasicConsumer : AsyncDefaultBasicConsumer {
    [CompilerGeneratedAttribute]
private AsyncEventHandler`1<BasicDeliverEventArgs> Received;
    [CompilerGeneratedAttribute]
private AsyncEventHandler`1<ConsumerEventArgs> Registered;
    [CompilerGeneratedAttribute]
private AsyncEventHandler`1<ShutdownEventArgs> Shutdown;
    [CompilerGeneratedAttribute]
private AsyncEventHandler`1<ConsumerEventArgs> Unregistered;
    public AsyncEventingBasicConsumer(IModel model);
    [CompilerGeneratedAttribute]
public void add_Received(AsyncEventHandler`1<BasicDeliverEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Received(AsyncEventHandler`1<BasicDeliverEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Registered(AsyncEventHandler`1<ConsumerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Registered(AsyncEventHandler`1<ConsumerEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Shutdown(AsyncEventHandler`1<ShutdownEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Shutdown(AsyncEventHandler`1<ShutdownEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Unregistered(AsyncEventHandler`1<ConsumerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Unregistered(AsyncEventHandler`1<ConsumerEventArgs> value);
    [AsyncStateMachineAttribute("RabbitMQ.Client.Events.AsyncEventingBasicConsumer/<HandleBasicCancelOk>d__13")]
public virtual Task HandleBasicCancelOk(string consumerTag);
    [AsyncStateMachineAttribute("RabbitMQ.Client.Events.AsyncEventingBasicConsumer/<HandleBasicConsumeOk>d__14")]
public virtual Task HandleBasicConsumeOk(string consumerTag);
    public virtual Task HandleBasicDeliver(string consumerTag, ulong deliveryTag, bool redelivered, string exchange, string routingKey, IBasicProperties properties, ReadOnlyMemory`1<byte> body);
    [AsyncStateMachineAttribute("RabbitMQ.Client.Events.AsyncEventingBasicConsumer/<HandleModelShutdown>d__16")]
public virtual Task HandleModelShutdown(object model, ShutdownEventArgs reason);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(string consumerTag);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(string consumerTag);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__2(object model, ShutdownEventArgs reason);
}
public abstract class RabbitMQ.Client.Events.BaseExceptionEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Detail>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public IDictionary`2<string, object> Detail { get; private set; }
    public Exception Exception { get; private set; }
    public BaseExceptionEventArgs(Exception exception);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Detail();
    [CompilerGeneratedAttribute]
private void set_Detail(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(Exception value);
    public IDictionary`2<string, object> UpdateDetails(IDictionary`2<string, object> other);
}
public class RabbitMQ.Client.Events.BasicAckEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ulong <DeliveryTag>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Multiple>k__BackingField;
    public ulong DeliveryTag { get; public set; }
    public bool Multiple { get; public set; }
    [CompilerGeneratedAttribute]
public ulong get_DeliveryTag();
    [CompilerGeneratedAttribute]
public void set_DeliveryTag(ulong value);
    [CompilerGeneratedAttribute]
public bool get_Multiple();
    [CompilerGeneratedAttribute]
public void set_Multiple(bool value);
}
public class RabbitMQ.Client.Events.BasicDeliverEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IBasicProperties <BasicProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<byte> <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConsumerTag>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <DeliveryTag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exchange>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Redelivered>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RoutingKey>k__BackingField;
    public IBasicProperties BasicProperties { get; public set; }
    public ReadOnlyMemory`1<byte> Body { get; public set; }
    public string ConsumerTag { get; public set; }
    public ulong DeliveryTag { get; public set; }
    public string Exchange { get; public set; }
    public bool Redelivered { get; public set; }
    public string RoutingKey { get; public set; }
    public BasicDeliverEventArgs(string consumerTag, ulong deliveryTag, bool redelivered, string exchange, string routingKey, IBasicProperties properties, ReadOnlyMemory`1<byte> body);
    [CompilerGeneratedAttribute]
public IBasicProperties get_BasicProperties();
    [CompilerGeneratedAttribute]
public void set_BasicProperties(IBasicProperties value);
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<byte> get_Body();
    [CompilerGeneratedAttribute]
public void set_Body(ReadOnlyMemory`1<byte> value);
    [CompilerGeneratedAttribute]
public string get_ConsumerTag();
    [CompilerGeneratedAttribute]
public void set_ConsumerTag(string value);
    [CompilerGeneratedAttribute]
public ulong get_DeliveryTag();
    [CompilerGeneratedAttribute]
public void set_DeliveryTag(ulong value);
    [CompilerGeneratedAttribute]
public string get_Exchange();
    [CompilerGeneratedAttribute]
public void set_Exchange(string value);
    [CompilerGeneratedAttribute]
public bool get_Redelivered();
    [CompilerGeneratedAttribute]
public void set_Redelivered(bool value);
    [CompilerGeneratedAttribute]
public string get_RoutingKey();
    [CompilerGeneratedAttribute]
public void set_RoutingKey(string value);
}
public class RabbitMQ.Client.Events.BasicNackEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ulong <DeliveryTag>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Multiple>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Requeue>k__BackingField;
    public ulong DeliveryTag { get; public set; }
    public bool Multiple { get; public set; }
    public bool Requeue { get; public set; }
    [CompilerGeneratedAttribute]
public ulong get_DeliveryTag();
    [CompilerGeneratedAttribute]
public void set_DeliveryTag(ulong value);
    [CompilerGeneratedAttribute]
public bool get_Multiple();
    [CompilerGeneratedAttribute]
public void set_Multiple(bool value);
    [CompilerGeneratedAttribute]
public bool get_Requeue();
    [CompilerGeneratedAttribute]
public void set_Requeue(bool value);
}
public class RabbitMQ.Client.Events.BasicReturnEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IBasicProperties <BasicProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<byte> <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exchange>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <ReplyCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReplyText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RoutingKey>k__BackingField;
    public IBasicProperties BasicProperties { get; public set; }
    public ReadOnlyMemory`1<byte> Body { get; public set; }
    public string Exchange { get; public set; }
    public ushort ReplyCode { get; public set; }
    public string ReplyText { get; public set; }
    public string RoutingKey { get; public set; }
    [CompilerGeneratedAttribute]
public IBasicProperties get_BasicProperties();
    [CompilerGeneratedAttribute]
public void set_BasicProperties(IBasicProperties value);
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<byte> get_Body();
    [CompilerGeneratedAttribute]
public void set_Body(ReadOnlyMemory`1<byte> value);
    [CompilerGeneratedAttribute]
public string get_Exchange();
    [CompilerGeneratedAttribute]
public void set_Exchange(string value);
    [CompilerGeneratedAttribute]
public ushort get_ReplyCode();
    [CompilerGeneratedAttribute]
public void set_ReplyCode(ushort value);
    [CompilerGeneratedAttribute]
public string get_ReplyText();
    [CompilerGeneratedAttribute]
public void set_ReplyText(string value);
    [CompilerGeneratedAttribute]
public string get_RoutingKey();
    [CompilerGeneratedAttribute]
public void set_RoutingKey(string value);
}
public class RabbitMQ.Client.Events.CallbackExceptionEventArgs : BaseExceptionEventArgs {
    public CallbackExceptionEventArgs(Exception e);
    public static CallbackExceptionEventArgs Build(Exception e, string context);
    public static CallbackExceptionEventArgs Build(Exception e, IDictionary`2<string, object> details);
}
public class RabbitMQ.Client.Events.ConnectionBlockedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public string Reason { get; private set; }
    public ConnectionBlockedEventArgs(string reason);
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
private void set_Reason(string value);
}
public class RabbitMQ.Client.Events.ConnectionRecoveryErrorEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public Exception Exception { get; private set; }
    public ConnectionRecoveryErrorEventArgs(Exception ex);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(Exception value);
}
public class RabbitMQ.Client.Events.ConsumerEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private String[] <ConsumerTags>k__BackingField;
    public String[] ConsumerTags { get; private set; }
    public ConsumerEventArgs(String[] consumerTags);
    [CompilerGeneratedAttribute]
public String[] get_ConsumerTags();
    [CompilerGeneratedAttribute]
private void set_ConsumerTags(String[] value);
}
public class RabbitMQ.Client.Events.ConsumerTagChangedAfterRecoveryEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <TagBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TagAfter>k__BackingField;
    public string TagBefore { get; private set; }
    public string TagAfter { get; private set; }
    public ConsumerTagChangedAfterRecoveryEventArgs(string tagBefore, string tagAfter);
    [CompilerGeneratedAttribute]
public string get_TagBefore();
    [CompilerGeneratedAttribute]
private void set_TagBefore(string value);
    [CompilerGeneratedAttribute]
public string get_TagAfter();
    [CompilerGeneratedAttribute]
private void set_TagAfter(string value);
}
public class RabbitMQ.Client.Events.EventingBasicConsumer : DefaultBasicConsumer {
    [CompilerGeneratedAttribute]
private EventHandler`1<BasicDeliverEventArgs> Received;
    [CompilerGeneratedAttribute]
private EventHandler`1<ConsumerEventArgs> Registered;
    [CompilerGeneratedAttribute]
private EventHandler`1<ShutdownEventArgs> Shutdown;
    [CompilerGeneratedAttribute]
private EventHandler`1<ConsumerEventArgs> Unregistered;
    public EventingBasicConsumer(IModel model);
    [CompilerGeneratedAttribute]
public void add_Received(EventHandler`1<BasicDeliverEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Received(EventHandler`1<BasicDeliverEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Registered(EventHandler`1<ConsumerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Registered(EventHandler`1<ConsumerEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Shutdown(EventHandler`1<ShutdownEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Shutdown(EventHandler`1<ShutdownEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Unregistered(EventHandler`1<ConsumerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Unregistered(EventHandler`1<ConsumerEventArgs> value);
    public virtual void HandleBasicCancelOk(string consumerTag);
    public virtual void HandleBasicConsumeOk(string consumerTag);
    public virtual void HandleBasicDeliver(string consumerTag, ulong deliveryTag, bool redelivered, string exchange, string routingKey, IBasicProperties properties, ReadOnlyMemory`1<byte> body);
    public virtual void HandleModelShutdown(object model, ShutdownEventArgs reason);
}
public class RabbitMQ.Client.Events.FlowControlEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private bool <Active>k__BackingField;
    public bool Active { get; private set; }
    public FlowControlEventArgs(bool active);
    [CompilerGeneratedAttribute]
public bool get_Active();
    [CompilerGeneratedAttribute]
private void set_Active(bool value);
}
public class RabbitMQ.Client.Events.QueueNameChangedAfterRecoveryEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <NameBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NameAfter>k__BackingField;
    public string NameBefore { get; private set; }
    public string NameAfter { get; private set; }
    public QueueNameChangedAfterRecoveryEventArgs(string nameBefore, string nameAfter);
    [CompilerGeneratedAttribute]
public string get_NameBefore();
    [CompilerGeneratedAttribute]
private void set_NameBefore(string value);
    [CompilerGeneratedAttribute]
public string get_NameAfter();
    [CompilerGeneratedAttribute]
private void set_NameAfter(string value);
}
public class RabbitMQ.Client.Events.RecoveringConsumerEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <ConsumerArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConsumerTag>k__BackingField;
    public IDictionary`2<string, object> ConsumerArguments { get; }
    public string ConsumerTag { get; }
    public RecoveringConsumerEventArgs(IDictionary`2<string, object> consumerArguments, string consumerTag);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_ConsumerArguments();
    [CompilerGeneratedAttribute]
public string get_ConsumerTag();
}
public class RabbitMQ.Client.Events.RecoveryExceptionEventArgs : BaseExceptionEventArgs {
    public RecoveryExceptionEventArgs(Exception e);
}
public class RabbitMQ.Client.Exceptions.AlreadyClosedException : OperationInterruptedException {
    public AlreadyClosedException(ShutdownEventArgs reason);
}
public class RabbitMQ.Client.Exceptions.AuthenticationFailureException : PossibleAuthenticationFailureException {
    public AuthenticationFailureException(string msg);
}
public class RabbitMQ.Client.Exceptions.BrokerUnreachableException : IOException {
    public BrokerUnreachableException(Exception Inner);
}
public class RabbitMQ.Client.Exceptions.ChannelAllocationException : ProtocolViolationException {
    [CompilerGeneratedAttribute]
private int <Channel>k__BackingField;
    public int Channel { get; private set; }
    public ChannelAllocationException(int channel);
    [CompilerGeneratedAttribute]
public int get_Channel();
    [CompilerGeneratedAttribute]
private void set_Channel(int value);
}
public class RabbitMQ.Client.Exceptions.ChannelErrorException : HardProtocolException {
    [CompilerGeneratedAttribute]
private int <Channel>k__BackingField;
    public int Channel { get; private set; }
    public ushort ReplyCode { get; }
    public ChannelErrorException(int channel);
    [CompilerGeneratedAttribute]
public int get_Channel();
    [CompilerGeneratedAttribute]
private void set_Channel(int value);
    public virtual ushort get_ReplyCode();
}
public class RabbitMQ.Client.Exceptions.ConnectFailureException : ProtocolViolationException {
    public ConnectFailureException(string msg, Exception inner);
}
public abstract class RabbitMQ.Client.Exceptions.HardProtocolException : ProtocolException {
    protected bool _canShutdownCleanly;
    public bool CanShutdownCleanly { get; }
    protected HardProtocolException(string message);
    protected HardProtocolException(string message, bool canShutdownCleanly);
    public bool get_CanShutdownCleanly();
}
public class RabbitMQ.Client.Exceptions.MalformedFrameException : HardProtocolException {
    public ushort ReplyCode { get; }
    public MalformedFrameException(string message);
    public MalformedFrameException(string message, bool canShutdownCleanly);
    public virtual ushort get_ReplyCode();
}
public class RabbitMQ.Client.Exceptions.OperationInterruptedException : RabbitMQClientException {
    [CompilerGeneratedAttribute]
private ShutdownEventArgs <ShutdownReason>k__BackingField;
    public ShutdownEventArgs ShutdownReason { get; protected set; }
    public OperationInterruptedException(ShutdownEventArgs reason);
    public OperationInterruptedException(ShutdownEventArgs reason, string prefix);
    protected OperationInterruptedException(string message);
    protected OperationInterruptedException(string message, Exception inner);
    [CompilerGeneratedAttribute]
public ShutdownEventArgs get_ShutdownReason();
    [CompilerGeneratedAttribute]
protected void set_ShutdownReason(ShutdownEventArgs value);
}
public class RabbitMQ.Client.Exceptions.PacketNotRecognizedException : RabbitMQClientException {
    [CompilerGeneratedAttribute]
private int <ServerMajor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ServerMinor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TransportHigh>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TransportLow>k__BackingField;
    public int ServerMajor { get; private set; }
    public int ServerMinor { get; private set; }
    public int TransportHigh { get; private set; }
    public int TransportLow { get; private set; }
    public PacketNotRecognizedException(int transportHigh, int transportLow, int serverMajor, int serverMinor);
    [CompilerGeneratedAttribute]
public int get_ServerMajor();
    [CompilerGeneratedAttribute]
private void set_ServerMajor(int value);
    [CompilerGeneratedAttribute]
public int get_ServerMinor();
    [CompilerGeneratedAttribute]
private void set_ServerMinor(int value);
    [CompilerGeneratedAttribute]
public int get_TransportHigh();
    [CompilerGeneratedAttribute]
private void set_TransportHigh(int value);
    [CompilerGeneratedAttribute]
public int get_TransportLow();
    [CompilerGeneratedAttribute]
private void set_TransportLow(int value);
}
public class RabbitMQ.Client.Exceptions.PossibleAuthenticationFailureException : RabbitMQClientException {
    public PossibleAuthenticationFailureException(string msg, Exception inner);
    public PossibleAuthenticationFailureException(string msg);
}
public abstract class RabbitMQ.Client.Exceptions.ProtocolException : RabbitMQClientException {
    public ushort ReplyCode { get; }
    public ShutdownEventArgs ShutdownReason { get; }
    protected ProtocolException(string message);
    public abstract virtual ushort get_ReplyCode();
    public virtual ShutdownEventArgs get_ShutdownReason();
}
public class RabbitMQ.Client.Exceptions.ProtocolVersionMismatchException : ProtocolViolationException {
    [CompilerGeneratedAttribute]
private int <ClientMajor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ClientMinor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ServerMajor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ServerMinor>k__BackingField;
    public int ClientMajor { get; private set; }
    public int ClientMinor { get; private set; }
    public int ServerMajor { get; private set; }
    public int ServerMinor { get; private set; }
    public ProtocolVersionMismatchException(int clientMajor, int clientMinor, int serverMajor, int serverMinor);
    [CompilerGeneratedAttribute]
public int get_ClientMajor();
    [CompilerGeneratedAttribute]
private void set_ClientMajor(int value);
    [CompilerGeneratedAttribute]
public int get_ClientMinor();
    [CompilerGeneratedAttribute]
private void set_ClientMinor(int value);
    [CompilerGeneratedAttribute]
public int get_ServerMajor();
    [CompilerGeneratedAttribute]
private void set_ServerMajor(int value);
    [CompilerGeneratedAttribute]
public int get_ServerMinor();
    [CompilerGeneratedAttribute]
private void set_ServerMinor(int value);
    private static string positiveOrUnknown(int version);
}
public class RabbitMQ.Client.Exceptions.ProtocolViolationException : RabbitMQClientException {
    public ProtocolViolationException(string message);
    public ProtocolViolationException(string message, Exception inner);
}
public abstract class RabbitMQ.Client.Exceptions.RabbitMQClientException : Exception {
    protected RabbitMQClientException(string message);
    protected RabbitMQClientException(string message, Exception innerException);
}
public abstract class RabbitMQ.Client.Exceptions.SoftProtocolException : ProtocolException {
    [CompilerGeneratedAttribute]
private int <Channel>k__BackingField;
    public int Channel { get; private set; }
    protected SoftProtocolException(int channelNumber, string message);
    [CompilerGeneratedAttribute]
public int get_Channel();
    [CompilerGeneratedAttribute]
private void set_Channel(int value);
}
public class RabbitMQ.Client.Exceptions.SyntaxErrorException : HardProtocolException {
    public ushort ReplyCode { get; }
    public SyntaxErrorException(string message);
    public virtual ushort get_ReplyCode();
}
public class RabbitMQ.Client.Exceptions.TopologyRecoveryException : RabbitMQClientException {
    public TopologyRecoveryException(string message, Exception cause);
}
public class RabbitMQ.Client.Exceptions.UnexpectedFrameException : HardProtocolException {
    public ushort ReplyCode { get; }
    internal UnexpectedFrameException(FrameType frameType);
    public virtual ushort get_ReplyCode();
}
public class RabbitMQ.Client.Exceptions.UnexpectedMethodException : ProtocolViolationException {
    [CompilerGeneratedAttribute]
private IMethod <Method>k__BackingField;
    public IMethod Method { get; private set; }
    public UnexpectedMethodException(IMethod method);
    [CompilerGeneratedAttribute]
public IMethod get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(IMethod value);
}
public class RabbitMQ.Client.Exceptions.UnknownClassOrMethodException : HardProtocolException {
    [CompilerGeneratedAttribute]
private ushort <ClassId>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MethodId>k__BackingField;
    public ushort ClassId { get; private set; }
    public ushort MethodId { get; private set; }
    public ushort ReplyCode { get; }
    public UnknownClassOrMethodException(ushort classId, ushort methodId);
    [CompilerGeneratedAttribute]
public ushort get_ClassId();
    [CompilerGeneratedAttribute]
private void set_ClassId(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_MethodId();
    [CompilerGeneratedAttribute]
private void set_MethodId(ushort value);
    public virtual ushort get_ReplyCode();
    public virtual string ToString();
}
public class RabbitMQ.Client.Exceptions.UnsupportedMethodException : NotSupportedException {
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    public string MethodName { get; private set; }
    public UnsupportedMethodException(string methodName);
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
private void set_MethodName(string value);
}
public class RabbitMQ.Client.Exceptions.UnsupportedMethodFieldException : NotSupportedException {
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    public string FieldName { get; private set; }
    public string MethodName { get; private set; }
    public UnsupportedMethodFieldException(string methodName, string fieldName);
    [CompilerGeneratedAttribute]
public string get_FieldName();
    [CompilerGeneratedAttribute]
private void set_FieldName(string value);
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
private void set_MethodName(string value);
}
public class RabbitMQ.Client.Exceptions.WireFormattingException : ProtocolViolationException {
    [CompilerGeneratedAttribute]
private object <Offender>k__BackingField;
    public object Offender { get; private set; }
    public WireFormattingException(string message);
    public WireFormattingException(string message, object offender);
    [CompilerGeneratedAttribute]
public object get_Offender();
    [CompilerGeneratedAttribute]
private void set_Offender(object value);
}
public static class RabbitMQ.Client.ExchangeType : object {
    public static string Direct;
    public static string Fanout;
    public static string Headers;
    public static string Topic;
    private static String[] s_all;
    private static ExchangeType();
    public static ICollection`1<string> All();
}
public class RabbitMQ.Client.ExternalMechanism : object {
    public sealed virtual Byte[] handleChallenge(Byte[] challenge, IConnectionFactory factory);
}
public class RabbitMQ.Client.ExternalMechanismFactory : object {
    public string Name { get; }
    public sealed virtual string get_Name();
    public sealed virtual IAuthMechanism GetInstance();
}
internal class RabbitMQ.Client.Framing.BasicProperties : BasicProperties {
    private string _contentType;
    private string _contentEncoding;
    private IDictionary`2<string, object> _headers;
    private byte _deliveryMode;
    private byte _priority;
    private string _correlationId;
    private string _replyTo;
    private string _expiration;
    private string _messageId;
    private AmqpTimestamp _timestamp;
    private string _type;
    private string _userId;
    private string _appId;
    private string _clusterId;
    private bool _contentType_present;
    private bool _contentEncoding_present;
    private bool _headers_present;
    private bool _deliveryMode_present;
    private bool _priority_present;
    private bool _correlationId_present;
    private bool _replyTo_present;
    private bool _expiration_present;
    private bool _messageId_present;
    private bool _timestamp_present;
    private bool _type_present;
    private bool _userId_present;
    private bool _appId_present;
    private bool _clusterId_present;
    public string ContentType { get; public set; }
    public string ContentEncoding { get; public set; }
    public IDictionary`2<string, object> Headers { get; public set; }
    public byte DeliveryMode { get; public set; }
    public byte Priority { get; public set; }
    public string CorrelationId { get; public set; }
    public string ReplyTo { get; public set; }
    public string Expiration { get; public set; }
    public string MessageId { get; public set; }
    public AmqpTimestamp Timestamp { get; public set; }
    public string Type { get; public set; }
    public string UserId { get; public set; }
    public string AppId { get; public set; }
    public string ClusterId { get; public set; }
    public ushort ProtocolClassId { get; }
    public string ProtocolClassName { get; }
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual string get_ContentEncoding();
    public virtual void set_ContentEncoding(string value);
    public virtual IDictionary`2<string, object> get_Headers();
    public virtual void set_Headers(IDictionary`2<string, object> value);
    public virtual byte get_DeliveryMode();
    public virtual void set_DeliveryMode(byte value);
    public virtual byte get_Priority();
    public virtual void set_Priority(byte value);
    public virtual string get_CorrelationId();
    public virtual void set_CorrelationId(string value);
    public virtual string get_ReplyTo();
    public virtual void set_ReplyTo(string value);
    public virtual string get_Expiration();
    public virtual void set_Expiration(string value);
    public virtual string get_MessageId();
    public virtual void set_MessageId(string value);
    public virtual AmqpTimestamp get_Timestamp();
    public virtual void set_Timestamp(AmqpTimestamp value);
    public virtual string get_Type();
    public virtual void set_Type(string value);
    public virtual string get_UserId();
    public virtual void set_UserId(string value);
    public virtual string get_AppId();
    public virtual void set_AppId(string value);
    public virtual string get_ClusterId();
    public virtual void set_ClusterId(string value);
    public virtual void ClearContentType();
    public virtual void ClearContentEncoding();
    public virtual void ClearHeaders();
    public virtual void ClearDeliveryMode();
    public virtual void ClearPriority();
    public virtual void ClearCorrelationId();
    public virtual void ClearReplyTo();
    public virtual void ClearExpiration();
    public virtual void ClearMessageId();
    public virtual void ClearTimestamp();
    public virtual void ClearType();
    public virtual void ClearUserId();
    public virtual void ClearAppId();
    public virtual void ClearClusterId();
    public virtual bool IsContentTypePresent();
    public virtual bool IsContentEncodingPresent();
    public virtual bool IsHeadersPresent();
    public virtual bool IsDeliveryModePresent();
    public virtual bool IsPriorityPresent();
    public virtual bool IsCorrelationIdPresent();
    public virtual bool IsReplyToPresent();
    public virtual bool IsExpirationPresent();
    public virtual bool IsMessageIdPresent();
    public virtual bool IsTimestampPresent();
    public virtual bool IsTypePresent();
    public virtual bool IsUserIdPresent();
    public virtual bool IsAppIdPresent();
    public virtual bool IsClusterIdPresent();
    public virtual ushort get_ProtocolClassId();
    public virtual string get_ProtocolClassName();
    internal virtual void ReadPropertiesFrom(ContentHeaderPropertyReader& reader);
    internal virtual void WritePropertiesTo(ContentHeaderPropertyWriter& writer);
    public virtual int GetRequiredPayloadBufferSize();
    public virtual void AppendPropertyDebugStringTo(StringBuilder sb);
}
internal interface RabbitMQ.Client.Framing.IBasicAck {
    public ulong DeliveryTag { get; }
    public bool Multiple { get; }
    public abstract virtual ulong get_DeliveryTag();
    public abstract virtual bool get_Multiple();
}
internal interface RabbitMQ.Client.Framing.IBasicCancel {
    public string ConsumerTag { get; }
    public bool Nowait { get; }
    public abstract virtual string get_ConsumerTag();
    public abstract virtual bool get_Nowait();
}
internal interface RabbitMQ.Client.Framing.IBasicCancelOk {
    public string ConsumerTag { get; }
    public abstract virtual string get_ConsumerTag();
}
internal interface RabbitMQ.Client.Framing.IBasicConsume {
    public ushort Reserved1 { get; }
    public string Queue { get; }
    public string ConsumerTag { get; }
    public bool NoLocal { get; }
    public bool NoAck { get; }
    public bool Exclusive { get; }
    public bool Nowait { get; }
    public IDictionary`2<string, object> Arguments { get; }
    public abstract virtual ushort get_Reserved1();
    public abstract virtual string get_Queue();
    public abstract virtual string get_ConsumerTag();
    public abstract virtual bool get_NoLocal();
    public abstract virtual bool get_NoAck();
    public abstract virtual bool get_Exclusive();
    public abstract virtual bool get_Nowait();
    public abstract virtual IDictionary`2<string, object> get_Arguments();
}
internal interface RabbitMQ.Client.Framing.IBasicConsumeOk {
    public string ConsumerTag { get; }
    public abstract virtual string get_ConsumerTag();
}
internal interface RabbitMQ.Client.Framing.IBasicDeliver {
    public string ConsumerTag { get; }
    public ulong DeliveryTag { get; }
    public bool Redelivered { get; }
    public string Exchange { get; }
    public string RoutingKey { get; }
    public abstract virtual string get_ConsumerTag();
    public abstract virtual ulong get_DeliveryTag();
    public abstract virtual bool get_Redelivered();
    public abstract virtual string get_Exchange();
    public abstract virtual string get_RoutingKey();
}
internal interface RabbitMQ.Client.Framing.IBasicGet {
    public ushort Reserved1 { get; }
    public string Queue { get; }
    public bool NoAck { get; }
    public abstract virtual ushort get_Reserved1();
    public abstract virtual string get_Queue();
    public abstract virtual bool get_NoAck();
}
internal interface RabbitMQ.Client.Framing.IBasicGetEmpty {
    public string Reserved1 { get; }
    public abstract virtual string get_Reserved1();
}
internal interface RabbitMQ.Client.Framing.IBasicGetOk {
    public ulong DeliveryTag { get; }
    public bool Redelivered { get; }
    public string Exchange { get; }
    public string RoutingKey { get; }
    public UInt32 MessageCount { get; }
    public abstract virtual ulong get_DeliveryTag();
    public abstract virtual bool get_Redelivered();
    public abstract virtual string get_Exchange();
    public abstract virtual string get_RoutingKey();
    public abstract virtual UInt32 get_MessageCount();
}
internal interface RabbitMQ.Client.Framing.IBasicNack {
    public ulong DeliveryTag { get; }
    public bool Multiple { get; }
    public bool Requeue { get; }
    public abstract virtual ulong get_DeliveryTag();
    public abstract virtual bool get_Multiple();
    public abstract virtual bool get_Requeue();
}
internal interface RabbitMQ.Client.Framing.IBasicPublish {
    public ushort Reserved1 { get; }
    public string Exchange { get; }
    public string RoutingKey { get; }
    public bool Mandatory { get; }
    public bool Immediate { get; }
    public abstract virtual ushort get_Reserved1();
    public abstract virtual string get_Exchange();
    public abstract virtual string get_RoutingKey();
    public abstract virtual bool get_Mandatory();
    public abstract virtual bool get_Immediate();
}
internal interface RabbitMQ.Client.Framing.IBasicQos {
    public UInt32 PrefetchSize { get; }
    public ushort PrefetchCount { get; }
    public bool Global { get; }
    public abstract virtual UInt32 get_PrefetchSize();
    public abstract virtual ushort get_PrefetchCount();
    public abstract virtual bool get_Global();
}
internal interface RabbitMQ.Client.Framing.IBasicQosOk {
}
internal interface RabbitMQ.Client.Framing.IBasicRecover {
    public bool Requeue { get; }
    public abstract virtual bool get_Requeue();
}
internal interface RabbitMQ.Client.Framing.IBasicRecoverAsync {
    public bool Requeue { get; }
    public abstract virtual bool get_Requeue();
}
internal interface RabbitMQ.Client.Framing.IBasicRecoverOk {
}
internal interface RabbitMQ.Client.Framing.IBasicReject {
    public ulong DeliveryTag { get; }
    public bool Requeue { get; }
    public abstract virtual ulong get_DeliveryTag();
    public abstract virtual bool get_Requeue();
}
internal interface RabbitMQ.Client.Framing.IBasicReturn {
    public ushort ReplyCode { get; }
    public string ReplyText { get; }
    public string Exchange { get; }
    public string RoutingKey { get; }
    public abstract virtual ushort get_ReplyCode();
    public abstract virtual string get_ReplyText();
    public abstract virtual string get_Exchange();
    public abstract virtual string get_RoutingKey();
}
internal interface RabbitMQ.Client.Framing.IChannelClose {
    public ushort ReplyCode { get; }
    public string ReplyText { get; }
    public ushort ClassId { get; }
    public ushort MethodId { get; }
    public abstract virtual ushort get_ReplyCode();
    public abstract virtual string get_ReplyText();
    public abstract virtual ushort get_ClassId();
    public abstract virtual ushort get_MethodId();
}
internal interface RabbitMQ.Client.Framing.IChannelCloseOk {
}
internal interface RabbitMQ.Client.Framing.IChannelFlow {
    public bool Active { get; }
    public abstract virtual bool get_Active();
}
internal interface RabbitMQ.Client.Framing.IChannelFlowOk {
    public bool Active { get; }
    public abstract virtual bool get_Active();
}
internal interface RabbitMQ.Client.Framing.IChannelOpen {
    public string Reserved1 { get; }
    public abstract virtual string get_Reserved1();
}
internal interface RabbitMQ.Client.Framing.IChannelOpenOk {
    public Byte[] Reserved1 { get; }
    public abstract virtual Byte[] get_Reserved1();
}
internal interface RabbitMQ.Client.Framing.IConfirmSelect {
    public bool Nowait { get; }
    public abstract virtual bool get_Nowait();
}
internal interface RabbitMQ.Client.Framing.IConfirmSelectOk {
}
internal interface RabbitMQ.Client.Framing.IConnectionBlocked {
    public string Reason { get; }
    public abstract virtual string get_Reason();
}
internal interface RabbitMQ.Client.Framing.IConnectionClose {
    public ushort ReplyCode { get; }
    public string ReplyText { get; }
    public ushort ClassId { get; }
    public ushort MethodId { get; }
    public abstract virtual ushort get_ReplyCode();
    public abstract virtual string get_ReplyText();
    public abstract virtual ushort get_ClassId();
    public abstract virtual ushort get_MethodId();
}
internal interface RabbitMQ.Client.Framing.IConnectionCloseOk {
}
internal interface RabbitMQ.Client.Framing.IConnectionOpen {
    public string VirtualHost { get; }
    public string Reserved1 { get; }
    public bool Reserved2 { get; }
    public abstract virtual string get_VirtualHost();
    public abstract virtual string get_Reserved1();
    public abstract virtual bool get_Reserved2();
}
internal interface RabbitMQ.Client.Framing.IConnectionOpenOk {
    public string Reserved1 { get; }
    public abstract virtual string get_Reserved1();
}
internal interface RabbitMQ.Client.Framing.IConnectionSecure {
    public Byte[] Challenge { get; }
    public abstract virtual Byte[] get_Challenge();
}
internal interface RabbitMQ.Client.Framing.IConnectionSecureOk {
    public Byte[] Response { get; }
    public abstract virtual Byte[] get_Response();
}
internal interface RabbitMQ.Client.Framing.IConnectionStart {
    public byte VersionMajor { get; }
    public byte VersionMinor { get; }
    public IDictionary`2<string, object> ServerProperties { get; }
    public Byte[] Mechanisms { get; }
    public Byte[] Locales { get; }
    public abstract virtual byte get_VersionMajor();
    public abstract virtual byte get_VersionMinor();
    public abstract virtual IDictionary`2<string, object> get_ServerProperties();
    public abstract virtual Byte[] get_Mechanisms();
    public abstract virtual Byte[] get_Locales();
}
internal interface RabbitMQ.Client.Framing.IConnectionStartOk {
    public IDictionary`2<string, object> ClientProperties { get; }
    public string Mechanism { get; }
    public Byte[] Response { get; }
    public string Locale { get; }
    public abstract virtual IDictionary`2<string, object> get_ClientProperties();
    public abstract virtual string get_Mechanism();
    public abstract virtual Byte[] get_Response();
    public abstract virtual string get_Locale();
}
internal interface RabbitMQ.Client.Framing.IConnectionTune {
    public ushort ChannelMax { get; }
    public UInt32 FrameMax { get; }
    public ushort Heartbeat { get; }
    public abstract virtual ushort get_ChannelMax();
    public abstract virtual UInt32 get_FrameMax();
    public abstract virtual ushort get_Heartbeat();
}
internal interface RabbitMQ.Client.Framing.IConnectionTuneOk {
    public ushort ChannelMax { get; }
    public UInt32 FrameMax { get; }
    public ushort Heartbeat { get; }
    public abstract virtual ushort get_ChannelMax();
    public abstract virtual UInt32 get_FrameMax();
    public abstract virtual ushort get_Heartbeat();
}
internal interface RabbitMQ.Client.Framing.IConnectionUnblocked {
}
internal interface RabbitMQ.Client.Framing.IConnectionUpdateSecret {
    public Byte[] NewSecret { get; }
    public string Reason { get; }
    public abstract virtual Byte[] get_NewSecret();
    public abstract virtual string get_Reason();
}
internal interface RabbitMQ.Client.Framing.IConnectionUpdateSecretOk {
}
internal interface RabbitMQ.Client.Framing.IExchangeBind {
    public ushort Reserved1 { get; }
    public string Destination { get; }
    public string Source { get; }
    public string RoutingKey { get; }
    public bool Nowait { get; }
    public IDictionary`2<string, object> Arguments { get; }
    public abstract virtual ushort get_Reserved1();
    public abstract virtual string get_Destination();
    public abstract virtual string get_Source();
    public abstract virtual string get_RoutingKey();
    public abstract virtual bool get_Nowait();
    public abstract virtual IDictionary`2<string, object> get_Arguments();
}
internal interface RabbitMQ.Client.Framing.IExchangeBindOk {
}
internal interface RabbitMQ.Client.Framing.IExchangeDeclare {
    public ushort Reserved1 { get; }
    public string Exchange { get; }
    public string Type { get; }
    public bool Passive { get; }
    public bool Durable { get; }
    public bool AutoDelete { get; }
    public bool Internal { get; }
    public bool Nowait { get; }
    public IDictionary`2<string, object> Arguments { get; }
    public abstract virtual ushort get_Reserved1();
    public abstract virtual string get_Exchange();
    public abstract virtual string get_Type();
    public abstract virtual bool get_Passive();
    public abstract virtual bool get_Durable();
    public abstract virtual bool get_AutoDelete();
    public abstract virtual bool get_Internal();
    public abstract virtual bool get_Nowait();
    public abstract virtual IDictionary`2<string, object> get_Arguments();
}
internal interface RabbitMQ.Client.Framing.IExchangeDeclareOk {
}
internal interface RabbitMQ.Client.Framing.IExchangeDelete {
    public ushort Reserved1 { get; }
    public string Exchange { get; }
    public bool IfUnused { get; }
    public bool Nowait { get; }
    public abstract virtual ushort get_Reserved1();
    public abstract virtual string get_Exchange();
    public abstract virtual bool get_IfUnused();
    public abstract virtual bool get_Nowait();
}
internal interface RabbitMQ.Client.Framing.IExchangeDeleteOk {
}
internal interface RabbitMQ.Client.Framing.IExchangeUnbind {
    public ushort Reserved1 { get; }
    public string Destination { get; }
    public string Source { get; }
    public string RoutingKey { get; }
    public bool Nowait { get; }
    public IDictionary`2<string, object> Arguments { get; }
    public abstract virtual ushort get_Reserved1();
    public abstract virtual string get_Destination();
    public abstract virtual string get_Source();
    public abstract virtual string get_RoutingKey();
    public abstract virtual bool get_Nowait();
    public abstract virtual IDictionary`2<string, object> get_Arguments();
}
internal interface RabbitMQ.Client.Framing.IExchangeUnbindOk {
}
internal class RabbitMQ.Client.Framing.Impl.AmqpVersion : object {
    [CompilerGeneratedAttribute]
private int <Major>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Minor>k__BackingField;
    public int Major { get; private set; }
    public int Minor { get; private set; }
    public AmqpVersion(int major, int minor);
    [CompilerGeneratedAttribute]
public int get_Major();
    [CompilerGeneratedAttribute]
private void set_Major(int value);
    [CompilerGeneratedAttribute]
public int get_Minor();
    [CompilerGeneratedAttribute]
private void set_Minor(int value);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class RabbitMQ.Client.Framing.Impl.AutorecoveringConnection : object {
    private bool _disposed;
    private object _eventLock;
    private Connection _delegate;
    private ConnectionFactory _factory;
    private IEndpointResolver _endpoints;
    private object _recordedEntitiesLock;
    private Dictionary`2<string, RecordedExchange> _recordedExchanges;
    private Dictionary`2<string, RecordedQueue> _recordedQueues;
    private Dictionary`2<RecordedBinding, byte> _recordedBindings;
    private Dictionary`2<string, RecordedConsumer> _recordedConsumers;
    private List`1<AutorecoveringModel> _models;
    private EventHandler`1<ConnectionBlockedEventArgs> _recordedBlockedEventHandlers;
    private EventHandler`1<ShutdownEventArgs> _recordedShutdownEventHandlers;
    private EventHandler`1<EventArgs> _recordedUnblockedEventHandlers;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> RecoverySucceeded;
    [CompilerGeneratedAttribute]
private EventHandler`1<ConnectionRecoveryErrorEventArgs> ConnectionRecoveryError;
    [CompilerGeneratedAttribute]
private EventHandler`1<RecoveringConsumerEventArgs> RecoveringConsumer;
    [CompilerGeneratedAttribute]
private EventHandler`1<ConsumerTagChangedAfterRecoveryEventArgs> ConsumerTagChangeAfterRecovery;
    [CompilerGeneratedAttribute]
private EventHandler`1<QueueNameChangedAfterRecoveryEventArgs> QueueNameChangeAfterRecovery;
    [CompilerGeneratedAttribute]
private string <ClientProvidedName>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, RecordedExchange> <RecordedExchanges>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, RecordedQueue> <RecordedQueues>k__BackingField;
    private Task _recoveryTask;
    private RecoveryConnectionState _recoveryLoopState;
    private Channel`1<RecoveryCommand> _recoveryLoopCommandQueue;
    public string ClientProvidedName { get; private set; }
    public ushort ChannelMax { get; }
    public ConsumerWorkService ConsumerWorkService { get; }
    public IDictionary`2<string, object> ClientProperties { get; }
    public ShutdownEventArgs CloseReason { get; }
    public AmqpTcpEndpoint Endpoint { get; }
    public UInt32 FrameMax { get; }
    public TimeSpan Heartbeat { get; }
    public bool IsOpen { get; }
    public AmqpTcpEndpoint[] KnownHosts { get; public set; }
    public int LocalPort { get; }
    public ProtocolBase Protocol { get; }
    public IDictionary`2<string, RecordedExchange> RecordedExchanges { get; }
    public IDictionary`2<string, RecordedQueue> RecordedQueues { get; }
    public int RemotePort { get; }
    public IDictionary`2<string, object> ServerProperties { get; }
    public IList`1<ShutdownReportEntry> ShutdownReport { get; }
    private IProtocol RabbitMQ.Client.IConnection.Protocol { get; }
    internal IFrameHandler FrameHandler { get; }
    internal int RecordedExchangesCount { get; }
    internal int RecordedQueuesCount { get; }
    public AutorecoveringConnection(ConnectionFactory factory, string clientProvidedName);
    [CompilerGeneratedAttribute]
public sealed virtual void add_RecoverySucceeded(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_RecoverySucceeded(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ConnectionRecoveryError(EventHandler`1<ConnectionRecoveryErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ConnectionRecoveryError(EventHandler`1<ConnectionRecoveryErrorEventArgs> value);
    public sealed virtual void add_CallbackException(EventHandler`1<CallbackExceptionEventArgs> value);
    public sealed virtual void remove_CallbackException(EventHandler`1<CallbackExceptionEventArgs> value);
    public sealed virtual void add_ConnectionBlocked(EventHandler`1<ConnectionBlockedEventArgs> value);
    public sealed virtual void remove_ConnectionBlocked(EventHandler`1<ConnectionBlockedEventArgs> value);
    public sealed virtual void add_ConnectionShutdown(EventHandler`1<ShutdownEventArgs> value);
    public sealed virtual void remove_ConnectionShutdown(EventHandler`1<ShutdownEventArgs> value);
    public sealed virtual void add_ConnectionUnblocked(EventHandler`1<EventArgs> value);
    public sealed virtual void remove_ConnectionUnblocked(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_RecoveringConsumer(EventHandler`1<RecoveringConsumerEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_RecoveringConsumer(EventHandler`1<RecoveringConsumerEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ConsumerTagChangeAfterRecovery(EventHandler`1<ConsumerTagChangedAfterRecoveryEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ConsumerTagChangeAfterRecovery(EventHandler`1<ConsumerTagChangedAfterRecoveryEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_QueueNameChangeAfterRecovery(EventHandler`1<QueueNameChangedAfterRecoveryEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_QueueNameChangeAfterRecovery(EventHandler`1<QueueNameChangedAfterRecoveryEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ClientProvidedName();
    [CompilerGeneratedAttribute]
private void set_ClientProvidedName(string value);
    public sealed virtual ushort get_ChannelMax();
    public ConsumerWorkService get_ConsumerWorkService();
    public sealed virtual IDictionary`2<string, object> get_ClientProperties();
    public sealed virtual ShutdownEventArgs get_CloseReason();
    public sealed virtual AmqpTcpEndpoint get_Endpoint();
    public sealed virtual UInt32 get_FrameMax();
    public sealed virtual TimeSpan get_Heartbeat();
    public sealed virtual bool get_IsOpen();
    public sealed virtual AmqpTcpEndpoint[] get_KnownHosts();
    public void set_KnownHosts(AmqpTcpEndpoint[] value);
    public sealed virtual int get_LocalPort();
    public ProtocolBase get_Protocol();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, RecordedExchange> get_RecordedExchanges();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, RecordedQueue> get_RecordedQueues();
    public sealed virtual int get_RemotePort();
    public sealed virtual IDictionary`2<string, object> get_ServerProperties();
    public sealed virtual IList`1<ShutdownReportEntry> get_ShutdownReport();
    private sealed virtual override IProtocol RabbitMQ.Client.IConnection.get_Protocol();
    private bool TryPerformAutomaticRecovery();
    public void Close(ShutdownEventArgs reason);
    public RecoveryAwareModel CreateNonRecoveringModel();
    public void DeleteRecordedBinding(RecordedBinding rb);
    public RecordedConsumer DeleteRecordedConsumer(string consumerTag);
    public void DeleteRecordedExchange(string name);
    public void DeleteRecordedQueue(string name);
    public bool HasMoreConsumersOnQueue(ICollection`1<RecordedConsumer> consumers, string queue);
    public bool HasMoreDestinationsBoundToExchange(ICollection`1<RecordedBinding> bindings, string exchange);
    public void MaybeDeleteRecordedAutoDeleteExchange(string exchange);
    public void MaybeDeleteRecordedAutoDeleteQueue(string queue);
    public void RecordBinding(RecordedBinding rb);
    public void RecordConsumer(string consumerTag, RecordedConsumer recordedConsumer);
    public void RecordExchange(string name, RecordedExchange x);
    public void RecordQueue(string name, RecordedQueue q);
    public virtual string ToString();
    public void UnregisterModel(AutorecoveringModel model);
    public void Init();
    public void Init(IEndpointResolver endpoints);
    internal IFrameHandler get_FrameHandler();
    private void Init(IFrameHandler fh);
    public sealed virtual void UpdateSecret(string newSecret, string reason);
    public sealed virtual void Abort();
    public sealed virtual void Abort(ushort reasonCode, string reasonText);
    public sealed virtual void Abort(TimeSpan timeout);
    public sealed virtual void Abort(ushort reasonCode, string reasonText, TimeSpan timeout);
    public sealed virtual void Close();
    public sealed virtual void Close(ushort reasonCode, string reasonText);
    public sealed virtual void Close(TimeSpan timeout);
    public sealed virtual void Close(ushort reasonCode, string reasonText, TimeSpan timeout);
    public sealed virtual IModel CreateModel();
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual void HandleConnectionBlocked(string reason);
    public sealed virtual void HandleConnectionUnblocked();
    internal int get_RecordedExchangesCount();
    internal int get_RecordedQueuesCount();
    private void Dispose(bool disposing);
    private void EnsureIsOpen();
    private void HandleTopologyRecoveryException(TopologyRecoveryException e);
    private void PropagateQueueNameChangeToBindings(string oldName, string newName);
    private void PropagateQueueNameChangeToConsumers(string oldName, string newName);
    private void RecoverBindings(RecoveryModelFactory recoveryModelFactory);
    private void RecoverConnectionBlockedHandlers();
    private bool TryRecoverConnectionDelegate();
    private void RecoverConnectionShutdownHandlers();
    private void RecoverConnectionUnblockedHandlers();
    internal void RecoverConsumers(AutorecoveringModel modelToRecover, IModel channelToUse);
    private void RecoverExchanges(RecoveryModelFactory recoveryModelFactory);
    private void RecoverModelsAndItsConsumers();
    private void RecoverQueues(RecoveryModelFactory recoveryModelFactory);
    private void RunRecoveryEventHandlers();
    private bool ShouldTriggerConnectionRecovery(ShutdownEventArgs args);
    [AsyncStateMachineAttribute("RabbitMQ.Client.Framing.Impl.AutorecoveringConnection/<MainRecoveryLoop>d__144")]
private Task MainRecoveryLoop();
    private void StopRecoveryLoop();
    private void RecoveryLoopRecoveringHandler(RecoveryCommand command);
    private void RecoveryLoopConnectedHandler(RecoveryCommand command);
    private void ScheduleRecoveryRetry();
    [CompilerGeneratedAttribute]
private void <Init>b__104_0(object _, ShutdownEventArgs args);
    [CompilerGeneratedAttribute]
private bool <RecoverBindings>b__127_0(RecordedBinding x);
    [CompilerGeneratedAttribute]
private bool <RecoverConsumers>b__132_0(KeyValuePair`2<string, RecordedConsumer> x);
    [CompilerGeneratedAttribute]
private bool <RecoverExchanges>b__133_0(RecordedExchange x);
    [CompilerGeneratedAttribute]
private bool <RecoverQueues>b__135_0(KeyValuePair`2<string, RecordedQueue> x);
    [CompilerGeneratedAttribute]
private bool <ScheduleRecoveryRetry>b__148_0(Task t);
}
internal class RabbitMQ.Client.Framing.Impl.BasicAck : MethodBase {
    public ulong _deliveryTag;
    public bool _multiple;
    private ulong RabbitMQ.Client.Framing.IBasicAck.DeliveryTag { get; }
    private bool RabbitMQ.Client.Framing.IBasicAck.Multiple { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public BasicAck(ulong DeliveryTag, bool Multiple);
    private sealed virtual override ulong RabbitMQ.Client.Framing.IBasicAck.get_DeliveryTag();
    private sealed virtual override bool RabbitMQ.Client.Framing.IBasicAck.get_Multiple();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.BasicCancel : MethodBase {
    public string _consumerTag;
    public bool _nowait;
    private string RabbitMQ.Client.Framing.IBasicCancel.ConsumerTag { get; }
    private bool RabbitMQ.Client.Framing.IBasicCancel.Nowait { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public BasicCancel(string ConsumerTag, bool Nowait);
    private sealed virtual override string RabbitMQ.Client.Framing.IBasicCancel.get_ConsumerTag();
    private sealed virtual override bool RabbitMQ.Client.Framing.IBasicCancel.get_Nowait();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.BasicCancelOk : MethodBase {
    public string _consumerTag;
    private string RabbitMQ.Client.Framing.IBasicCancelOk.ConsumerTag { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public BasicCancelOk(string ConsumerTag);
    private sealed virtual override string RabbitMQ.Client.Framing.IBasicCancelOk.get_ConsumerTag();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.BasicConsume : MethodBase {
    public ushort _reserved1;
    public string _queue;
    public string _consumerTag;
    public bool _noLocal;
    public bool _noAck;
    public bool _exclusive;
    public bool _nowait;
    public IDictionary`2<string, object> _arguments;
    private ushort RabbitMQ.Client.Framing.IBasicConsume.Reserved1 { get; }
    private string RabbitMQ.Client.Framing.IBasicConsume.Queue { get; }
    private string RabbitMQ.Client.Framing.IBasicConsume.ConsumerTag { get; }
    private bool RabbitMQ.Client.Framing.IBasicConsume.NoLocal { get; }
    private bool RabbitMQ.Client.Framing.IBasicConsume.NoAck { get; }
    private bool RabbitMQ.Client.Framing.IBasicConsume.Exclusive { get; }
    private bool RabbitMQ.Client.Framing.IBasicConsume.Nowait { get; }
    private IDictionary`2<string, object> RabbitMQ.Client.Framing.IBasicConsume.Arguments { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public BasicConsume(ushort Reserved1, string Queue, string ConsumerTag, bool NoLocal, bool NoAck, bool Exclusive, bool Nowait, IDictionary`2<string, object> Arguments);
    private sealed virtual override ushort RabbitMQ.Client.Framing.IBasicConsume.get_Reserved1();
    private sealed virtual override string RabbitMQ.Client.Framing.IBasicConsume.get_Queue();
    private sealed virtual override string RabbitMQ.Client.Framing.IBasicConsume.get_ConsumerTag();
    private sealed virtual override bool RabbitMQ.Client.Framing.IBasicConsume.get_NoLocal();
    private sealed virtual override bool RabbitMQ.Client.Framing.IBasicConsume.get_NoAck();
    private sealed virtual override bool RabbitMQ.Client.Framing.IBasicConsume.get_Exclusive();
    private sealed virtual override bool RabbitMQ.Client.Framing.IBasicConsume.get_Nowait();
    private sealed virtual override IDictionary`2<string, object> RabbitMQ.Client.Framing.IBasicConsume.get_Arguments();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.BasicConsumeOk : MethodBase {
    public string _consumerTag;
    private string RabbitMQ.Client.Framing.IBasicConsumeOk.ConsumerTag { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public BasicConsumeOk(string ConsumerTag);
    private sealed virtual override string RabbitMQ.Client.Framing.IBasicConsumeOk.get_ConsumerTag();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.BasicDeliver : MethodBase {
    public string _consumerTag;
    public ulong _deliveryTag;
    public bool _redelivered;
    public string _exchange;
    public string _routingKey;
    private string RabbitMQ.Client.Framing.IBasicDeliver.ConsumerTag { get; }
    private ulong RabbitMQ.Client.Framing.IBasicDeliver.DeliveryTag { get; }
    private bool RabbitMQ.Client.Framing.IBasicDeliver.Redelivered { get; }
    private string RabbitMQ.Client.Framing.IBasicDeliver.Exchange { get; }
    private string RabbitMQ.Client.Framing.IBasicDeliver.RoutingKey { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public BasicDeliver(string ConsumerTag, ulong DeliveryTag, bool Redelivered, string Exchange, string RoutingKey);
    private sealed virtual override string RabbitMQ.Client.Framing.IBasicDeliver.get_ConsumerTag();
    private sealed virtual override ulong RabbitMQ.Client.Framing.IBasicDeliver.get_DeliveryTag();
    private sealed virtual override bool RabbitMQ.Client.Framing.IBasicDeliver.get_Redelivered();
    private sealed virtual override string RabbitMQ.Client.Framing.IBasicDeliver.get_Exchange();
    private sealed virtual override string RabbitMQ.Client.Framing.IBasicDeliver.get_RoutingKey();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.BasicGet : MethodBase {
    public ushort _reserved1;
    public string _queue;
    public bool _noAck;
    private ushort RabbitMQ.Client.Framing.IBasicGet.Reserved1 { get; }
    private string RabbitMQ.Client.Framing.IBasicGet.Queue { get; }
    private bool RabbitMQ.Client.Framing.IBasicGet.NoAck { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public BasicGet(ushort Reserved1, string Queue, bool NoAck);
    private sealed virtual override ushort RabbitMQ.Client.Framing.IBasicGet.get_Reserved1();
    private sealed virtual override string RabbitMQ.Client.Framing.IBasicGet.get_Queue();
    private sealed virtual override bool RabbitMQ.Client.Framing.IBasicGet.get_NoAck();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.BasicGetEmpty : MethodBase {
    public string _reserved1;
    private string RabbitMQ.Client.Framing.IBasicGetEmpty.Reserved1 { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public BasicGetEmpty(string Reserved1);
    private sealed virtual override string RabbitMQ.Client.Framing.IBasicGetEmpty.get_Reserved1();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.BasicGetOk : MethodBase {
    public ulong _deliveryTag;
    public bool _redelivered;
    public string _exchange;
    public string _routingKey;
    public UInt32 _messageCount;
    private ulong RabbitMQ.Client.Framing.IBasicGetOk.DeliveryTag { get; }
    private bool RabbitMQ.Client.Framing.IBasicGetOk.Redelivered { get; }
    private string RabbitMQ.Client.Framing.IBasicGetOk.Exchange { get; }
    private string RabbitMQ.Client.Framing.IBasicGetOk.RoutingKey { get; }
    private UInt32 RabbitMQ.Client.Framing.IBasicGetOk.MessageCount { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public BasicGetOk(ulong DeliveryTag, bool Redelivered, string Exchange, string RoutingKey, UInt32 MessageCount);
    private sealed virtual override ulong RabbitMQ.Client.Framing.IBasicGetOk.get_DeliveryTag();
    private sealed virtual override bool RabbitMQ.Client.Framing.IBasicGetOk.get_Redelivered();
    private sealed virtual override string RabbitMQ.Client.Framing.IBasicGetOk.get_Exchange();
    private sealed virtual override string RabbitMQ.Client.Framing.IBasicGetOk.get_RoutingKey();
    private sealed virtual override UInt32 RabbitMQ.Client.Framing.IBasicGetOk.get_MessageCount();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal static class RabbitMQ.Client.Framing.Impl.BasicMethodConstants : object {
    internal static ushort Qos;
    internal static ushort QosOk;
    internal static ushort Consume;
    internal static ushort ConsumeOk;
    internal static ushort Cancel;
    internal static ushort CancelOk;
    internal static ushort Publish;
    internal static ushort Return;
    internal static ushort Deliver;
    internal static ushort Get;
    internal static ushort GetOk;
    internal static ushort GetEmpty;
    internal static ushort Ack;
    internal static ushort Reject;
    internal static ushort RecoverAsync;
    internal static ushort Recover;
    internal static ushort RecoverOk;
    internal static ushort Nack;
}
internal class RabbitMQ.Client.Framing.Impl.BasicNack : MethodBase {
    public ulong _deliveryTag;
    public bool _multiple;
    public bool _requeue;
    private ulong RabbitMQ.Client.Framing.IBasicNack.DeliveryTag { get; }
    private bool RabbitMQ.Client.Framing.IBasicNack.Multiple { get; }
    private bool RabbitMQ.Client.Framing.IBasicNack.Requeue { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public BasicNack(ulong DeliveryTag, bool Multiple, bool Requeue);
    private sealed virtual override ulong RabbitMQ.Client.Framing.IBasicNack.get_DeliveryTag();
    private sealed virtual override bool RabbitMQ.Client.Framing.IBasicNack.get_Multiple();
    private sealed virtual override bool RabbitMQ.Client.Framing.IBasicNack.get_Requeue();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.BasicPublish : MethodBase {
    public ushort _reserved1;
    public string _exchange;
    public string _routingKey;
    public bool _mandatory;
    public bool _immediate;
    private ushort RabbitMQ.Client.Framing.IBasicPublish.Reserved1 { get; }
    private string RabbitMQ.Client.Framing.IBasicPublish.Exchange { get; }
    private string RabbitMQ.Client.Framing.IBasicPublish.RoutingKey { get; }
    private bool RabbitMQ.Client.Framing.IBasicPublish.Mandatory { get; }
    private bool RabbitMQ.Client.Framing.IBasicPublish.Immediate { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public BasicPublish(ushort Reserved1, string Exchange, string RoutingKey, bool Mandatory, bool Immediate);
    private sealed virtual override ushort RabbitMQ.Client.Framing.IBasicPublish.get_Reserved1();
    private sealed virtual override string RabbitMQ.Client.Framing.IBasicPublish.get_Exchange();
    private sealed virtual override string RabbitMQ.Client.Framing.IBasicPublish.get_RoutingKey();
    private sealed virtual override bool RabbitMQ.Client.Framing.IBasicPublish.get_Mandatory();
    private sealed virtual override bool RabbitMQ.Client.Framing.IBasicPublish.get_Immediate();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.BasicQos : MethodBase {
    public UInt32 _prefetchSize;
    public ushort _prefetchCount;
    public bool _global;
    private UInt32 RabbitMQ.Client.Framing.IBasicQos.PrefetchSize { get; }
    private ushort RabbitMQ.Client.Framing.IBasicQos.PrefetchCount { get; }
    private bool RabbitMQ.Client.Framing.IBasicQos.Global { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public BasicQos(UInt32 PrefetchSize, ushort PrefetchCount, bool Global);
    private sealed virtual override UInt32 RabbitMQ.Client.Framing.IBasicQos.get_PrefetchSize();
    private sealed virtual override ushort RabbitMQ.Client.Framing.IBasicQos.get_PrefetchCount();
    private sealed virtual override bool RabbitMQ.Client.Framing.IBasicQos.get_Global();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.BasicQosOk : MethodBase {
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.BasicRecover : MethodBase {
    public bool _requeue;
    private bool RabbitMQ.Client.Framing.IBasicRecover.Requeue { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public BasicRecover(bool Requeue);
    private sealed virtual override bool RabbitMQ.Client.Framing.IBasicRecover.get_Requeue();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.BasicRecoverAsync : MethodBase {
    public bool _requeue;
    private bool RabbitMQ.Client.Framing.IBasicRecoverAsync.Requeue { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public BasicRecoverAsync(bool Requeue);
    private sealed virtual override bool RabbitMQ.Client.Framing.IBasicRecoverAsync.get_Requeue();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.BasicRecoverOk : MethodBase {
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.BasicReject : MethodBase {
    public ulong _deliveryTag;
    public bool _requeue;
    private ulong RabbitMQ.Client.Framing.IBasicReject.DeliveryTag { get; }
    private bool RabbitMQ.Client.Framing.IBasicReject.Requeue { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public BasicReject(ulong DeliveryTag, bool Requeue);
    private sealed virtual override ulong RabbitMQ.Client.Framing.IBasicReject.get_DeliveryTag();
    private sealed virtual override bool RabbitMQ.Client.Framing.IBasicReject.get_Requeue();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.BasicReturn : MethodBase {
    public ushort _replyCode;
    public string _replyText;
    public string _exchange;
    public string _routingKey;
    private ushort RabbitMQ.Client.Framing.IBasicReturn.ReplyCode { get; }
    private string RabbitMQ.Client.Framing.IBasicReturn.ReplyText { get; }
    private string RabbitMQ.Client.Framing.IBasicReturn.Exchange { get; }
    private string RabbitMQ.Client.Framing.IBasicReturn.RoutingKey { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public BasicReturn(ushort ReplyCode, string ReplyText, string Exchange, string RoutingKey);
    private sealed virtual override ushort RabbitMQ.Client.Framing.IBasicReturn.get_ReplyCode();
    private sealed virtual override string RabbitMQ.Client.Framing.IBasicReturn.get_ReplyText();
    private sealed virtual override string RabbitMQ.Client.Framing.IBasicReturn.get_Exchange();
    private sealed virtual override string RabbitMQ.Client.Framing.IBasicReturn.get_RoutingKey();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.ChannelClose : MethodBase {
    public ushort _replyCode;
    public string _replyText;
    public ushort _classId;
    public ushort _methodId;
    private ushort RabbitMQ.Client.Framing.IChannelClose.ReplyCode { get; }
    private string RabbitMQ.Client.Framing.IChannelClose.ReplyText { get; }
    private ushort RabbitMQ.Client.Framing.IChannelClose.ClassId { get; }
    private ushort RabbitMQ.Client.Framing.IChannelClose.MethodId { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public ChannelClose(ushort ReplyCode, string ReplyText, ushort ClassId, ushort MethodId);
    private sealed virtual override ushort RabbitMQ.Client.Framing.IChannelClose.get_ReplyCode();
    private sealed virtual override string RabbitMQ.Client.Framing.IChannelClose.get_ReplyText();
    private sealed virtual override ushort RabbitMQ.Client.Framing.IChannelClose.get_ClassId();
    private sealed virtual override ushort RabbitMQ.Client.Framing.IChannelClose.get_MethodId();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.ChannelCloseOk : MethodBase {
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.ChannelFlow : MethodBase {
    public bool _active;
    private bool RabbitMQ.Client.Framing.IChannelFlow.Active { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public ChannelFlow(bool Active);
    private sealed virtual override bool RabbitMQ.Client.Framing.IChannelFlow.get_Active();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.ChannelFlowOk : MethodBase {
    public bool _active;
    private bool RabbitMQ.Client.Framing.IChannelFlowOk.Active { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public ChannelFlowOk(bool Active);
    private sealed virtual override bool RabbitMQ.Client.Framing.IChannelFlowOk.get_Active();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal static class RabbitMQ.Client.Framing.Impl.ChannelMethodConstants : object {
    internal static ushort Open;
    internal static ushort OpenOk;
    internal static ushort Flow;
    internal static ushort FlowOk;
    internal static ushort Close;
    internal static ushort CloseOk;
}
internal class RabbitMQ.Client.Framing.Impl.ChannelOpen : MethodBase {
    public string _reserved1;
    private string RabbitMQ.Client.Framing.IChannelOpen.Reserved1 { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public ChannelOpen(string Reserved1);
    private sealed virtual override string RabbitMQ.Client.Framing.IChannelOpen.get_Reserved1();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.ChannelOpenOk : MethodBase {
    public Byte[] _reserved1;
    private Byte[] RabbitMQ.Client.Framing.IChannelOpenOk.Reserved1 { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public ChannelOpenOk(Byte[] Reserved1);
    private sealed virtual override Byte[] RabbitMQ.Client.Framing.IChannelOpenOk.get_Reserved1();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal static class RabbitMQ.Client.Framing.Impl.ClassConstants : object {
    internal static ushort Connection;
    internal static ushort Channel;
    internal static ushort Exchange;
    internal static ushort Queue;
    internal static ushort Basic;
    internal static ushort Tx;
    internal static ushort Confirm;
}
internal enum RabbitMQ.Client.Framing.Impl.ClassId : Enum {
    public int value__;
    public static ClassId Connection;
    public static ClassId Channel;
    public static ClassId Exchange;
    public static ClassId Queue;
    public static ClassId Basic;
    public static ClassId Tx;
    public static ClassId Confirm;
    public static ClassId Invalid;
}
internal static class RabbitMQ.Client.Framing.Impl.ConfirmMethodConstants : object {
    internal static ushort Select;
    internal static ushort SelectOk;
}
internal class RabbitMQ.Client.Framing.Impl.ConfirmSelect : MethodBase {
    public bool _nowait;
    private bool RabbitMQ.Client.Framing.IConfirmSelect.Nowait { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public ConfirmSelect(bool Nowait);
    private sealed virtual override bool RabbitMQ.Client.Framing.IConfirmSelect.get_Nowait();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.ConfirmSelectOk : MethodBase {
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.Connection : object {
    private bool _disposed;
    private object _eventLock;
    private ManualResetEventSlim _appContinuation;
    private ShutdownEventArgs modreq(System.Runtime.CompilerServices.IsVolatile) _closeReason;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _closed;
    private EventHandler`1<ShutdownEventArgs> _connectionShutdown;
    private IConnectionFactory _factory;
    private IFrameHandler _frameHandler;
    private Guid _id;
    private ModelBase _model0;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _running;
    private MainSession _session0;
    private SessionManager _sessionManager;
    private ArrayPool`1<byte> _memoryPool;
    private TimeSpan _heartbeat;
    private TimeSpan _heartbeatTimeSpan;
    private int _missedHeartbeats;
    private bool _heartbeatDetected;
    private Timer _heartbeatWriteTimer;
    private Timer _heartbeatReadTimer;
    private Task _mainLoopTask;
    private static string s_version;
    [CompilerGeneratedAttribute]
private ConsumerWorkService <ConsumerWorkService>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<CallbackExceptionEventArgs> CallbackException;
    [CompilerGeneratedAttribute]
private EventHandler`1<ConnectionBlockedEventArgs> ConnectionBlocked;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> ConnectionUnblocked;
    [CompilerGeneratedAttribute]
private string <ClientProvidedName>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <ClientProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <FrameMax>k__BackingField;
    [CompilerGeneratedAttribute]
private AmqpTcpEndpoint[] <KnownHosts>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <ServerProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ShutdownReportEntry> <ShutdownReport>k__BackingField;
    public ConsumerWorkService ConsumerWorkService { get; private set; }
    internal ArrayPool`1<byte> MemoryPool { get; }
    public Guid Id { get; }
    public string ClientProvidedName { get; private set; }
    public ushort ChannelMax { get; }
    public IDictionary`2<string, object> ClientProperties { get; public set; }
    public ShutdownEventArgs CloseReason { get; }
    public AmqpTcpEndpoint Endpoint { get; }
    public UInt32 FrameMax { get; public set; }
    public TimeSpan Heartbeat { get; public set; }
    public bool IsOpen { get; }
    public AmqpTcpEndpoint[] KnownHosts { get; public set; }
    public EndPoint LocalEndPoint { get; }
    public int LocalPort { get; }
    public ProtocolBase Protocol { get; }
    public EndPoint RemoteEndPoint { get; }
    public int RemotePort { get; }
    public IDictionary`2<string, object> ServerProperties { get; public set; }
    public IList`1<ShutdownReportEntry> ShutdownReport { get; }
    private IProtocol RabbitMQ.Client.IConnection.Protocol { get; }
    internal IFrameHandler FrameHandler { get; }
    public Connection(IConnectionFactory factory, bool insist, IFrameHandler frameHandler, string clientProvidedName);
    public Connection(IConnectionFactory factory, bool insist, IFrameHandler frameHandler, ArrayPool`1<byte> memoryPool, string clientProvidedName);
    private static Connection();
    [CompilerGeneratedAttribute]
public ConsumerWorkService get_ConsumerWorkService();
    [CompilerGeneratedAttribute]
private void set_ConsumerWorkService(ConsumerWorkService value);
    internal ArrayPool`1<byte> get_MemoryPool();
    public Guid get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual void add_CallbackException(EventHandler`1<CallbackExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CallbackException(EventHandler`1<CallbackExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ConnectionBlocked(EventHandler`1<ConnectionBlockedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ConnectionBlocked(EventHandler`1<ConnectionBlockedEventArgs> value);
    public sealed virtual void add_ConnectionShutdown(EventHandler`1<ShutdownEventArgs> value);
    public sealed virtual void remove_ConnectionShutdown(EventHandler`1<ShutdownEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ConnectionUnblocked(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ConnectionUnblocked(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ClientProvidedName();
    [CompilerGeneratedAttribute]
private void set_ClientProvidedName(string value);
    public sealed virtual ushort get_ChannelMax();
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, object> get_ClientProperties();
    [CompilerGeneratedAttribute]
public void set_ClientProperties(IDictionary`2<string, object> value);
    public sealed virtual ShutdownEventArgs get_CloseReason();
    public sealed virtual AmqpTcpEndpoint get_Endpoint();
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_FrameMax();
    [CompilerGeneratedAttribute]
public void set_FrameMax(UInt32 value);
    public sealed virtual TimeSpan get_Heartbeat();
    public void set_Heartbeat(TimeSpan value);
    public sealed virtual bool get_IsOpen();
    [CompilerGeneratedAttribute]
public sealed virtual AmqpTcpEndpoint[] get_KnownHosts();
    [CompilerGeneratedAttribute]
public void set_KnownHosts(AmqpTcpEndpoint[] value);
    public EndPoint get_LocalEndPoint();
    public sealed virtual int get_LocalPort();
    public ProtocolBase get_Protocol();
    public EndPoint get_RemoteEndPoint();
    public sealed virtual int get_RemotePort();
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, object> get_ServerProperties();
    [CompilerGeneratedAttribute]
public void set_ServerProperties(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ShutdownReportEntry> get_ShutdownReport();
    private sealed virtual override IProtocol RabbitMQ.Client.IConnection.get_Protocol();
    public static IDictionary`2<string, object> DefaultClientProperties();
    public void Abort(ushort reasonCode, string reasonText, ShutdownInitiator initiator, TimeSpan timeout);
    public void Close(ShutdownEventArgs reason);
    public void Close(ShutdownEventArgs reason, bool abort, TimeSpan timeout);
    public void ClosingLoop();
    public OutgoingCommand ConnectionCloseWrapper(ushort reasonCode, string reasonText);
    public ISession CreateSession();
    public ISession CreateSession(int channelNumber);
    public void EnsureIsOpen();
    public void FinishClose();
    public void HandleDomainUnload(object sender, EventArgs ea);
    public void HandleMainLoopException(ShutdownEventArgs reason);
    public bool HardProtocolExceptionHandler(HardProtocolException hpe);
    public void InternalClose(ShutdownEventArgs reason);
    public void LogCloseError(string error, Exception ex);
    public void MainLoop();
    public void MainLoopIteration();
    private void NotifyHeartbeatListener();
    public void NotifyReceivedCloseOk();
    public void OnCallbackException(CallbackExceptionEventArgs args);
    public void OnConnectionBlocked(ConnectionBlockedEventArgs args);
    public void OnConnectionUnblocked();
    public void OnShutdown();
    public void Open(bool insist);
    public void PrettyPrintShutdownReport();
    public void QuiesceChannel(SoftProtocolException pe);
    public bool SetCloseReason(ShutdownEventArgs reason);
    public void MaybeStartHeartbeatTimers();
    public void StartMainLoop();
    public void HeartbeatReadTimerCallback(object state);
    public void HeartbeatWriteTimerCallback(object state);
    private void MaybeStopHeartbeatTimers();
    public void TerminateMainloop();
    public virtual string ToString();
    public void Write(ReadOnlyMemory`1<byte> memory);
    public sealed virtual void UpdateSecret(string newSecret, string reason);
    public sealed virtual void Abort();
    public sealed virtual void Abort(ushort reasonCode, string reasonText);
    public sealed virtual void Abort(TimeSpan timeout);
    public sealed virtual void Abort(ushort reasonCode, string reasonText, TimeSpan timeout);
    public sealed virtual void Close();
    public sealed virtual void Close(ushort reasonCode, string reasonText);
    public sealed virtual void Close(TimeSpan timeout);
    public sealed virtual void Close(ushort reasonCode, string reasonText, TimeSpan timeout);
    public sealed virtual IModel CreateModel();
    public sealed virtual void HandleConnectionBlocked(string reason);
    public sealed virtual void HandleConnectionUnblocked();
    private sealed virtual override void System.IDisposable.Dispose();
    private void Dispose(bool disposing);
    internal OutgoingCommand ChannelCloseWrapper(ushort reasonCode, string reasonText);
    internal IFrameHandler get_FrameHandler();
    private void StartAndTune();
    private static UInt32 NegotiatedMaxValue(UInt32 clientValue, UInt32 serverValue);
    private void MaybeStartCredentialRefresher();
    private void NotifyCredentialRefreshed(bool succesfully);
}
internal class RabbitMQ.Client.Framing.Impl.ConnectionBlocked : MethodBase {
    public string _reason;
    private string RabbitMQ.Client.Framing.IConnectionBlocked.Reason { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public ConnectionBlocked(string Reason);
    private sealed virtual override string RabbitMQ.Client.Framing.IConnectionBlocked.get_Reason();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.ConnectionClose : MethodBase {
    public ushort _replyCode;
    public string _replyText;
    public ushort _classId;
    public ushort _methodId;
    private ushort RabbitMQ.Client.Framing.IConnectionClose.ReplyCode { get; }
    private string RabbitMQ.Client.Framing.IConnectionClose.ReplyText { get; }
    private ushort RabbitMQ.Client.Framing.IConnectionClose.ClassId { get; }
    private ushort RabbitMQ.Client.Framing.IConnectionClose.MethodId { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public ConnectionClose(ushort ReplyCode, string ReplyText, ushort ClassId, ushort MethodId);
    private sealed virtual override ushort RabbitMQ.Client.Framing.IConnectionClose.get_ReplyCode();
    private sealed virtual override string RabbitMQ.Client.Framing.IConnectionClose.get_ReplyText();
    private sealed virtual override ushort RabbitMQ.Client.Framing.IConnectionClose.get_ClassId();
    private sealed virtual override ushort RabbitMQ.Client.Framing.IConnectionClose.get_MethodId();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.ConnectionCloseOk : MethodBase {
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal static class RabbitMQ.Client.Framing.Impl.ConnectionMethodConstants : object {
    internal static ushort Start;
    internal static ushort StartOk;
    internal static ushort Secure;
    internal static ushort SecureOk;
    internal static ushort Tune;
    internal static ushort TuneOk;
    internal static ushort Open;
    internal static ushort OpenOk;
    internal static ushort Close;
    internal static ushort CloseOk;
    internal static ushort Blocked;
    internal static ushort Unblocked;
    internal static ushort UpdateSecret;
    internal static ushort UpdateSecretOk;
}
internal class RabbitMQ.Client.Framing.Impl.ConnectionOpen : MethodBase {
    public string _virtualHost;
    public string _reserved1;
    public bool _reserved2;
    private string RabbitMQ.Client.Framing.IConnectionOpen.VirtualHost { get; }
    private string RabbitMQ.Client.Framing.IConnectionOpen.Reserved1 { get; }
    private bool RabbitMQ.Client.Framing.IConnectionOpen.Reserved2 { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public ConnectionOpen(string VirtualHost, string Reserved1, bool Reserved2);
    private sealed virtual override string RabbitMQ.Client.Framing.IConnectionOpen.get_VirtualHost();
    private sealed virtual override string RabbitMQ.Client.Framing.IConnectionOpen.get_Reserved1();
    private sealed virtual override bool RabbitMQ.Client.Framing.IConnectionOpen.get_Reserved2();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.ConnectionOpenOk : MethodBase {
    public string _reserved1;
    private string RabbitMQ.Client.Framing.IConnectionOpenOk.Reserved1 { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public ConnectionOpenOk(string Reserved1);
    private sealed virtual override string RabbitMQ.Client.Framing.IConnectionOpenOk.get_Reserved1();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.ConnectionSecure : MethodBase {
    public Byte[] _challenge;
    private Byte[] RabbitMQ.Client.Framing.IConnectionSecure.Challenge { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public ConnectionSecure(Byte[] Challenge);
    private sealed virtual override Byte[] RabbitMQ.Client.Framing.IConnectionSecure.get_Challenge();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.ConnectionSecureOk : MethodBase {
    public Byte[] _response;
    private Byte[] RabbitMQ.Client.Framing.IConnectionSecureOk.Response { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public ConnectionSecureOk(Byte[] Response);
    private sealed virtual override Byte[] RabbitMQ.Client.Framing.IConnectionSecureOk.get_Response();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.ConnectionStart : MethodBase {
    public byte _versionMajor;
    public byte _versionMinor;
    public IDictionary`2<string, object> _serverProperties;
    public Byte[] _mechanisms;
    public Byte[] _locales;
    private byte RabbitMQ.Client.Framing.IConnectionStart.VersionMajor { get; }
    private byte RabbitMQ.Client.Framing.IConnectionStart.VersionMinor { get; }
    private IDictionary`2<string, object> RabbitMQ.Client.Framing.IConnectionStart.ServerProperties { get; }
    private Byte[] RabbitMQ.Client.Framing.IConnectionStart.Mechanisms { get; }
    private Byte[] RabbitMQ.Client.Framing.IConnectionStart.Locales { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public ConnectionStart(byte VersionMajor, byte VersionMinor, IDictionary`2<string, object> ServerProperties, Byte[] Mechanisms, Byte[] Locales);
    private sealed virtual override byte RabbitMQ.Client.Framing.IConnectionStart.get_VersionMajor();
    private sealed virtual override byte RabbitMQ.Client.Framing.IConnectionStart.get_VersionMinor();
    private sealed virtual override IDictionary`2<string, object> RabbitMQ.Client.Framing.IConnectionStart.get_ServerProperties();
    private sealed virtual override Byte[] RabbitMQ.Client.Framing.IConnectionStart.get_Mechanisms();
    private sealed virtual override Byte[] RabbitMQ.Client.Framing.IConnectionStart.get_Locales();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.ConnectionStartOk : MethodBase {
    public IDictionary`2<string, object> _clientProperties;
    public string _mechanism;
    public Byte[] _response;
    public string _locale;
    private IDictionary`2<string, object> RabbitMQ.Client.Framing.IConnectionStartOk.ClientProperties { get; }
    private string RabbitMQ.Client.Framing.IConnectionStartOk.Mechanism { get; }
    private Byte[] RabbitMQ.Client.Framing.IConnectionStartOk.Response { get; }
    private string RabbitMQ.Client.Framing.IConnectionStartOk.Locale { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public ConnectionStartOk(IDictionary`2<string, object> ClientProperties, string Mechanism, Byte[] Response, string Locale);
    private sealed virtual override IDictionary`2<string, object> RabbitMQ.Client.Framing.IConnectionStartOk.get_ClientProperties();
    private sealed virtual override string RabbitMQ.Client.Framing.IConnectionStartOk.get_Mechanism();
    private sealed virtual override Byte[] RabbitMQ.Client.Framing.IConnectionStartOk.get_Response();
    private sealed virtual override string RabbitMQ.Client.Framing.IConnectionStartOk.get_Locale();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.ConnectionTune : MethodBase {
    public ushort _channelMax;
    public UInt32 _frameMax;
    public ushort _heartbeat;
    private ushort RabbitMQ.Client.Framing.IConnectionTune.ChannelMax { get; }
    private UInt32 RabbitMQ.Client.Framing.IConnectionTune.FrameMax { get; }
    private ushort RabbitMQ.Client.Framing.IConnectionTune.Heartbeat { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public ConnectionTune(ushort ChannelMax, UInt32 FrameMax, ushort Heartbeat);
    private sealed virtual override ushort RabbitMQ.Client.Framing.IConnectionTune.get_ChannelMax();
    private sealed virtual override UInt32 RabbitMQ.Client.Framing.IConnectionTune.get_FrameMax();
    private sealed virtual override ushort RabbitMQ.Client.Framing.IConnectionTune.get_Heartbeat();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.ConnectionTuneOk : MethodBase {
    public ushort _channelMax;
    public UInt32 _frameMax;
    public ushort _heartbeat;
    private ushort RabbitMQ.Client.Framing.IConnectionTuneOk.ChannelMax { get; }
    private UInt32 RabbitMQ.Client.Framing.IConnectionTuneOk.FrameMax { get; }
    private ushort RabbitMQ.Client.Framing.IConnectionTuneOk.Heartbeat { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public ConnectionTuneOk(ushort ChannelMax, UInt32 FrameMax, ushort Heartbeat);
    private sealed virtual override ushort RabbitMQ.Client.Framing.IConnectionTuneOk.get_ChannelMax();
    private sealed virtual override UInt32 RabbitMQ.Client.Framing.IConnectionTuneOk.get_FrameMax();
    private sealed virtual override ushort RabbitMQ.Client.Framing.IConnectionTuneOk.get_Heartbeat();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.ConnectionUnblocked : MethodBase {
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.ConnectionUpdateSecret : MethodBase {
    public Byte[] _newSecret;
    public string _reason;
    private Byte[] RabbitMQ.Client.Framing.IConnectionUpdateSecret.NewSecret { get; }
    private string RabbitMQ.Client.Framing.IConnectionUpdateSecret.Reason { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public ConnectionUpdateSecret(Byte[] NewSecret, string Reason);
    private sealed virtual override Byte[] RabbitMQ.Client.Framing.IConnectionUpdateSecret.get_NewSecret();
    private sealed virtual override string RabbitMQ.Client.Framing.IConnectionUpdateSecret.get_Reason();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.ConnectionUpdateSecretOk : MethodBase {
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.ExchangeBind : MethodBase {
    public ushort _reserved1;
    public string _destination;
    public string _source;
    public string _routingKey;
    public bool _nowait;
    public IDictionary`2<string, object> _arguments;
    private ushort RabbitMQ.Client.Framing.IExchangeBind.Reserved1 { get; }
    private string RabbitMQ.Client.Framing.IExchangeBind.Destination { get; }
    private string RabbitMQ.Client.Framing.IExchangeBind.Source { get; }
    private string RabbitMQ.Client.Framing.IExchangeBind.RoutingKey { get; }
    private bool RabbitMQ.Client.Framing.IExchangeBind.Nowait { get; }
    private IDictionary`2<string, object> RabbitMQ.Client.Framing.IExchangeBind.Arguments { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public ExchangeBind(ushort Reserved1, string Destination, string Source, string RoutingKey, bool Nowait, IDictionary`2<string, object> Arguments);
    private sealed virtual override ushort RabbitMQ.Client.Framing.IExchangeBind.get_Reserved1();
    private sealed virtual override string RabbitMQ.Client.Framing.IExchangeBind.get_Destination();
    private sealed virtual override string RabbitMQ.Client.Framing.IExchangeBind.get_Source();
    private sealed virtual override string RabbitMQ.Client.Framing.IExchangeBind.get_RoutingKey();
    private sealed virtual override bool RabbitMQ.Client.Framing.IExchangeBind.get_Nowait();
    private sealed virtual override IDictionary`2<string, object> RabbitMQ.Client.Framing.IExchangeBind.get_Arguments();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.ExchangeBindOk : MethodBase {
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.ExchangeDeclare : MethodBase {
    public ushort _reserved1;
    public string _exchange;
    public string _type;
    public bool _passive;
    public bool _durable;
    public bool _autoDelete;
    public bool _internal;
    public bool _nowait;
    public IDictionary`2<string, object> _arguments;
    private ushort RabbitMQ.Client.Framing.IExchangeDeclare.Reserved1 { get; }
    private string RabbitMQ.Client.Framing.IExchangeDeclare.Exchange { get; }
    private string RabbitMQ.Client.Framing.IExchangeDeclare.Type { get; }
    private bool RabbitMQ.Client.Framing.IExchangeDeclare.Passive { get; }
    private bool RabbitMQ.Client.Framing.IExchangeDeclare.Durable { get; }
    private bool RabbitMQ.Client.Framing.IExchangeDeclare.AutoDelete { get; }
    private bool RabbitMQ.Client.Framing.IExchangeDeclare.Internal { get; }
    private bool RabbitMQ.Client.Framing.IExchangeDeclare.Nowait { get; }
    private IDictionary`2<string, object> RabbitMQ.Client.Framing.IExchangeDeclare.Arguments { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public ExchangeDeclare(ushort Reserved1, string Exchange, string Type, bool Passive, bool Durable, bool AutoDelete, bool Internal, bool Nowait, IDictionary`2<string, object> Arguments);
    private sealed virtual override ushort RabbitMQ.Client.Framing.IExchangeDeclare.get_Reserved1();
    private sealed virtual override string RabbitMQ.Client.Framing.IExchangeDeclare.get_Exchange();
    private sealed virtual override string RabbitMQ.Client.Framing.IExchangeDeclare.get_Type();
    private sealed virtual override bool RabbitMQ.Client.Framing.IExchangeDeclare.get_Passive();
    private sealed virtual override bool RabbitMQ.Client.Framing.IExchangeDeclare.get_Durable();
    private sealed virtual override bool RabbitMQ.Client.Framing.IExchangeDeclare.get_AutoDelete();
    private sealed virtual override bool RabbitMQ.Client.Framing.IExchangeDeclare.get_Internal();
    private sealed virtual override bool RabbitMQ.Client.Framing.IExchangeDeclare.get_Nowait();
    private sealed virtual override IDictionary`2<string, object> RabbitMQ.Client.Framing.IExchangeDeclare.get_Arguments();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.ExchangeDeclareOk : MethodBase {
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.ExchangeDelete : MethodBase {
    public ushort _reserved1;
    public string _exchange;
    public bool _ifUnused;
    public bool _nowait;
    private ushort RabbitMQ.Client.Framing.IExchangeDelete.Reserved1 { get; }
    private string RabbitMQ.Client.Framing.IExchangeDelete.Exchange { get; }
    private bool RabbitMQ.Client.Framing.IExchangeDelete.IfUnused { get; }
    private bool RabbitMQ.Client.Framing.IExchangeDelete.Nowait { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public ExchangeDelete(ushort Reserved1, string Exchange, bool IfUnused, bool Nowait);
    private sealed virtual override ushort RabbitMQ.Client.Framing.IExchangeDelete.get_Reserved1();
    private sealed virtual override string RabbitMQ.Client.Framing.IExchangeDelete.get_Exchange();
    private sealed virtual override bool RabbitMQ.Client.Framing.IExchangeDelete.get_IfUnused();
    private sealed virtual override bool RabbitMQ.Client.Framing.IExchangeDelete.get_Nowait();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.ExchangeDeleteOk : MethodBase {
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal static class RabbitMQ.Client.Framing.Impl.ExchangeMethodConstants : object {
    internal static ushort Declare;
    internal static ushort DeclareOk;
    internal static ushort Delete;
    internal static ushort DeleteOk;
    internal static ushort Bind;
    internal static ushort BindOk;
    internal static ushort Unbind;
    internal static ushort UnbindOk;
}
internal class RabbitMQ.Client.Framing.Impl.ExchangeUnbind : MethodBase {
    public ushort _reserved1;
    public string _destination;
    public string _source;
    public string _routingKey;
    public bool _nowait;
    public IDictionary`2<string, object> _arguments;
    private ushort RabbitMQ.Client.Framing.IExchangeUnbind.Reserved1 { get; }
    private string RabbitMQ.Client.Framing.IExchangeUnbind.Destination { get; }
    private string RabbitMQ.Client.Framing.IExchangeUnbind.Source { get; }
    private string RabbitMQ.Client.Framing.IExchangeUnbind.RoutingKey { get; }
    private bool RabbitMQ.Client.Framing.IExchangeUnbind.Nowait { get; }
    private IDictionary`2<string, object> RabbitMQ.Client.Framing.IExchangeUnbind.Arguments { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public ExchangeUnbind(ushort Reserved1, string Destination, string Source, string RoutingKey, bool Nowait, IDictionary`2<string, object> Arguments);
    private sealed virtual override ushort RabbitMQ.Client.Framing.IExchangeUnbind.get_Reserved1();
    private sealed virtual override string RabbitMQ.Client.Framing.IExchangeUnbind.get_Destination();
    private sealed virtual override string RabbitMQ.Client.Framing.IExchangeUnbind.get_Source();
    private sealed virtual override string RabbitMQ.Client.Framing.IExchangeUnbind.get_RoutingKey();
    private sealed virtual override bool RabbitMQ.Client.Framing.IExchangeUnbind.get_Nowait();
    private sealed virtual override IDictionary`2<string, object> RabbitMQ.Client.Framing.IExchangeUnbind.get_Arguments();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.ExchangeUnbindOk : MethodBase {
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
[ExtensionAttribute]
internal static class RabbitMQ.Client.Framing.Impl.IProtocolExtensions : object {
    [ExtensionAttribute]
public static IFrameHandler CreateFrameHandler(IProtocol protocol, AmqpTcpEndpoint endpoint, ArrayPool`1<byte> pool, Func`2<AddressFamily, ITcpClient> socketFactory, TimeSpan connectionTimeout, TimeSpan readTimeout, TimeSpan writeTimeout);
}
internal class RabbitMQ.Client.Framing.Impl.Model : ModelBase {
    public Model(ISession session);
    public Model(ISession session, ConsumerWorkService workService);
    public virtual void ConnectionTuneOk(ushort channelMax, UInt32 frameMax, ushort heartbeat);
    public virtual void _Private_BasicCancel(string consumerTag, bool nowait);
    public virtual void _Private_BasicConsume(string queue, string consumerTag, bool noLocal, bool autoAck, bool exclusive, bool nowait, IDictionary`2<string, object> arguments);
    public virtual void _Private_BasicGet(string queue, bool autoAck);
    public virtual void _Private_BasicPublish(string exchange, string routingKey, bool mandatory, IBasicProperties basicProperties, ReadOnlyMemory`1<byte> body);
    public virtual void _Private_BasicRecover(bool requeue);
    public virtual void _Private_ChannelClose(ushort replyCode, string replyText, ushort classId, ushort methodId);
    public virtual void _Private_ChannelCloseOk();
    public virtual void _Private_ChannelFlowOk(bool active);
    public virtual void _Private_ChannelOpen(string outOfBand);
    public virtual void _Private_ConfirmSelect(bool nowait);
    public virtual void _Private_ConnectionClose(ushort replyCode, string replyText, ushort classId, ushort methodId);
    public virtual void _Private_ConnectionCloseOk();
    public virtual void _Private_ConnectionOpen(string virtualHost, string capabilities, bool insist);
    public virtual void _Private_ConnectionSecureOk(Byte[] response);
    public virtual void _Private_ConnectionStartOk(IDictionary`2<string, object> clientProperties, string mechanism, Byte[] response, string locale);
    public virtual void _Private_UpdateSecret(Byte[] newSecret, string reason);
    public virtual void _Private_ExchangeBind(string destination, string source, string routingKey, bool nowait, IDictionary`2<string, object> arguments);
    public virtual void _Private_ExchangeDeclare(string exchange, string type, bool passive, bool durable, bool autoDelete, bool internal, bool nowait, IDictionary`2<string, object> arguments);
    public virtual void _Private_ExchangeDelete(string exchange, bool ifUnused, bool nowait);
    public virtual void _Private_ExchangeUnbind(string destination, string source, string routingKey, bool nowait, IDictionary`2<string, object> arguments);
    public virtual void _Private_QueueBind(string queue, string exchange, string routingKey, bool nowait, IDictionary`2<string, object> arguments);
    public virtual void _Private_QueueDeclare(string queue, bool passive, bool durable, bool exclusive, bool autoDelete, bool nowait, IDictionary`2<string, object> arguments);
    public virtual UInt32 _Private_QueueDelete(string queue, bool ifUnused, bool ifEmpty, bool nowait);
    public virtual UInt32 _Private_QueuePurge(string queue, bool nowait);
    public virtual void BasicAck(ulong deliveryTag, bool multiple);
    public virtual void BasicNack(ulong deliveryTag, bool multiple, bool requeue);
    public virtual void BasicQos(UInt32 prefetchSize, ushort prefetchCount, bool global);
    public virtual void BasicRecoverAsync(bool requeue);
    public virtual void BasicReject(ulong deliveryTag, bool requeue);
    public virtual IBasicProperties CreateBasicProperties();
    public virtual void QueueUnbind(string queue, string exchange, string routingKey, IDictionary`2<string, object> arguments);
    public virtual void TxCommit();
    public virtual void TxRollback();
    public virtual void TxSelect();
    public virtual bool DispatchAsynchronous(IncomingCommand& modreq(System.Runtime.InteropServices.InAttribute) cmd);
}
internal abstract class RabbitMQ.Client.Framing.Impl.ProtocolBase : object {
    private ArrayPool`1<byte> _memoryPool;
    public IDictionary`2<string, bool> Capabilities;
    public string ApiName { get; }
    public int DefaultPort { get; }
    public int MajorVersion { get; }
    public int MinorVersion { get; }
    public int Revision { get; }
    public AmqpVersion Version { get; }
    public ArrayPool`1<byte> MemoryPool { get; }
    public abstract virtual string get_ApiName();
    public abstract virtual int get_DefaultPort();
    public abstract virtual int get_MajorVersion();
    public abstract virtual int get_MinorVersion();
    public abstract virtual int get_Revision();
    public AmqpVersion get_Version();
    public ArrayPool`1<byte> get_MemoryPool();
    public bool CanSendWhileClosed(MethodBase method);
    public void CreateChannelClose(ushort reasonCode, string reasonText, OutgoingCommand& request, UInt16& replyClassId, UInt16& replyMethodId);
    public void CreateConnectionClose(ushort reasonCode, string reasonText, OutgoingCommand& request, UInt16& replyClassId, UInt16& replyMethodId);
    internal abstract virtual ContentHeaderBase DecodeContentHeaderFrom(ushort classId);
    internal abstract virtual MethodBase DecodeMethodFrom(ReadOnlySpan`1<byte> reader);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public IConnection CreateConnection(IConnectionFactory factory, bool insist, IFrameHandler frameHandler, ArrayPool`1<byte> memoryPool);
    public IConnection CreateConnection(IConnectionFactory factory, bool insist, IFrameHandler frameHandler, ArrayPool`1<byte> memoryPool, string clientProvidedName);
    public IConnection CreateConnection(ConnectionFactory factory, IFrameHandler frameHandler, bool automaticRecoveryEnabled);
    public IConnection CreateConnection(ConnectionFactory factory, IFrameHandler frameHandler, bool automaticRecoveryEnabled, string clientProvidedName);
    public IModel CreateModel(ISession session);
    public IModel CreateModel(ISession session, ConsumerWorkService workService);
}
internal class RabbitMQ.Client.Framing.Impl.QueueBind : MethodBase {
    public ushort _reserved1;
    public string _queue;
    public string _exchange;
    public string _routingKey;
    public bool _nowait;
    public IDictionary`2<string, object> _arguments;
    private ushort RabbitMQ.Client.Framing.IQueueBind.Reserved1 { get; }
    private string RabbitMQ.Client.Framing.IQueueBind.Queue { get; }
    private string RabbitMQ.Client.Framing.IQueueBind.Exchange { get; }
    private string RabbitMQ.Client.Framing.IQueueBind.RoutingKey { get; }
    private bool RabbitMQ.Client.Framing.IQueueBind.Nowait { get; }
    private IDictionary`2<string, object> RabbitMQ.Client.Framing.IQueueBind.Arguments { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public QueueBind(ushort Reserved1, string Queue, string Exchange, string RoutingKey, bool Nowait, IDictionary`2<string, object> Arguments);
    private sealed virtual override ushort RabbitMQ.Client.Framing.IQueueBind.get_Reserved1();
    private sealed virtual override string RabbitMQ.Client.Framing.IQueueBind.get_Queue();
    private sealed virtual override string RabbitMQ.Client.Framing.IQueueBind.get_Exchange();
    private sealed virtual override string RabbitMQ.Client.Framing.IQueueBind.get_RoutingKey();
    private sealed virtual override bool RabbitMQ.Client.Framing.IQueueBind.get_Nowait();
    private sealed virtual override IDictionary`2<string, object> RabbitMQ.Client.Framing.IQueueBind.get_Arguments();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.QueueBindOk : MethodBase {
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.QueueDeclare : MethodBase {
    public ushort _reserved1;
    public string _queue;
    public bool _passive;
    public bool _durable;
    public bool _exclusive;
    public bool _autoDelete;
    public bool _nowait;
    public IDictionary`2<string, object> _arguments;
    private ushort RabbitMQ.Client.Framing.IQueueDeclare.Reserved1 { get; }
    private string RabbitMQ.Client.Framing.IQueueDeclare.Queue { get; }
    private bool RabbitMQ.Client.Framing.IQueueDeclare.Passive { get; }
    private bool RabbitMQ.Client.Framing.IQueueDeclare.Durable { get; }
    private bool RabbitMQ.Client.Framing.IQueueDeclare.Exclusive { get; }
    private bool RabbitMQ.Client.Framing.IQueueDeclare.AutoDelete { get; }
    private bool RabbitMQ.Client.Framing.IQueueDeclare.Nowait { get; }
    private IDictionary`2<string, object> RabbitMQ.Client.Framing.IQueueDeclare.Arguments { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public QueueDeclare(ushort Reserved1, string Queue, bool Passive, bool Durable, bool Exclusive, bool AutoDelete, bool Nowait, IDictionary`2<string, object> Arguments);
    private sealed virtual override ushort RabbitMQ.Client.Framing.IQueueDeclare.get_Reserved1();
    private sealed virtual override string RabbitMQ.Client.Framing.IQueueDeclare.get_Queue();
    private sealed virtual override bool RabbitMQ.Client.Framing.IQueueDeclare.get_Passive();
    private sealed virtual override bool RabbitMQ.Client.Framing.IQueueDeclare.get_Durable();
    private sealed virtual override bool RabbitMQ.Client.Framing.IQueueDeclare.get_Exclusive();
    private sealed virtual override bool RabbitMQ.Client.Framing.IQueueDeclare.get_AutoDelete();
    private sealed virtual override bool RabbitMQ.Client.Framing.IQueueDeclare.get_Nowait();
    private sealed virtual override IDictionary`2<string, object> RabbitMQ.Client.Framing.IQueueDeclare.get_Arguments();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.QueueDeclareOk : MethodBase {
    public string _queue;
    public UInt32 _messageCount;
    public UInt32 _consumerCount;
    private string RabbitMQ.Client.Framing.IQueueDeclareOk.Queue { get; }
    private UInt32 RabbitMQ.Client.Framing.IQueueDeclareOk.MessageCount { get; }
    private UInt32 RabbitMQ.Client.Framing.IQueueDeclareOk.ConsumerCount { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public QueueDeclareOk(string Queue, UInt32 MessageCount, UInt32 ConsumerCount);
    private sealed virtual override string RabbitMQ.Client.Framing.IQueueDeclareOk.get_Queue();
    private sealed virtual override UInt32 RabbitMQ.Client.Framing.IQueueDeclareOk.get_MessageCount();
    private sealed virtual override UInt32 RabbitMQ.Client.Framing.IQueueDeclareOk.get_ConsumerCount();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.QueueDelete : MethodBase {
    public ushort _reserved1;
    public string _queue;
    public bool _ifUnused;
    public bool _ifEmpty;
    public bool _nowait;
    private ushort RabbitMQ.Client.Framing.IQueueDelete.Reserved1 { get; }
    private string RabbitMQ.Client.Framing.IQueueDelete.Queue { get; }
    private bool RabbitMQ.Client.Framing.IQueueDelete.IfUnused { get; }
    private bool RabbitMQ.Client.Framing.IQueueDelete.IfEmpty { get; }
    private bool RabbitMQ.Client.Framing.IQueueDelete.Nowait { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public QueueDelete(ushort Reserved1, string Queue, bool IfUnused, bool IfEmpty, bool Nowait);
    private sealed virtual override ushort RabbitMQ.Client.Framing.IQueueDelete.get_Reserved1();
    private sealed virtual override string RabbitMQ.Client.Framing.IQueueDelete.get_Queue();
    private sealed virtual override bool RabbitMQ.Client.Framing.IQueueDelete.get_IfUnused();
    private sealed virtual override bool RabbitMQ.Client.Framing.IQueueDelete.get_IfEmpty();
    private sealed virtual override bool RabbitMQ.Client.Framing.IQueueDelete.get_Nowait();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.QueueDeleteOk : MethodBase {
    public UInt32 _messageCount;
    private UInt32 RabbitMQ.Client.Framing.IQueueDeleteOk.MessageCount { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public QueueDeleteOk(UInt32 MessageCount);
    private sealed virtual override UInt32 RabbitMQ.Client.Framing.IQueueDeleteOk.get_MessageCount();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal static class RabbitMQ.Client.Framing.Impl.QueueMethodConstants : object {
    internal static ushort Declare;
    internal static ushort DeclareOk;
    internal static ushort Bind;
    internal static ushort BindOk;
    internal static ushort Unbind;
    internal static ushort UnbindOk;
    internal static ushort Purge;
    internal static ushort PurgeOk;
    internal static ushort Delete;
    internal static ushort DeleteOk;
}
internal class RabbitMQ.Client.Framing.Impl.QueuePurge : MethodBase {
    public ushort _reserved1;
    public string _queue;
    public bool _nowait;
    private ushort RabbitMQ.Client.Framing.IQueuePurge.Reserved1 { get; }
    private string RabbitMQ.Client.Framing.IQueuePurge.Queue { get; }
    private bool RabbitMQ.Client.Framing.IQueuePurge.Nowait { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public QueuePurge(ushort Reserved1, string Queue, bool Nowait);
    private sealed virtual override ushort RabbitMQ.Client.Framing.IQueuePurge.get_Reserved1();
    private sealed virtual override string RabbitMQ.Client.Framing.IQueuePurge.get_Queue();
    private sealed virtual override bool RabbitMQ.Client.Framing.IQueuePurge.get_Nowait();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.QueuePurgeOk : MethodBase {
    public UInt32 _messageCount;
    private UInt32 RabbitMQ.Client.Framing.IQueuePurgeOk.MessageCount { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public QueuePurgeOk(UInt32 MessageCount);
    private sealed virtual override UInt32 RabbitMQ.Client.Framing.IQueuePurgeOk.get_MessageCount();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.QueueUnbind : MethodBase {
    public ushort _reserved1;
    public string _queue;
    public string _exchange;
    public string _routingKey;
    public IDictionary`2<string, object> _arguments;
    private ushort RabbitMQ.Client.Framing.IQueueUnbind.Reserved1 { get; }
    private string RabbitMQ.Client.Framing.IQueueUnbind.Queue { get; }
    private string RabbitMQ.Client.Framing.IQueueUnbind.Exchange { get; }
    private string RabbitMQ.Client.Framing.IQueueUnbind.RoutingKey { get; }
    private IDictionary`2<string, object> RabbitMQ.Client.Framing.IQueueUnbind.Arguments { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public QueueUnbind(ushort Reserved1, string Queue, string Exchange, string RoutingKey, IDictionary`2<string, object> Arguments);
    private sealed virtual override ushort RabbitMQ.Client.Framing.IQueueUnbind.get_Reserved1();
    private sealed virtual override string RabbitMQ.Client.Framing.IQueueUnbind.get_Queue();
    private sealed virtual override string RabbitMQ.Client.Framing.IQueueUnbind.get_Exchange();
    private sealed virtual override string RabbitMQ.Client.Framing.IQueueUnbind.get_RoutingKey();
    private sealed virtual override IDictionary`2<string, object> RabbitMQ.Client.Framing.IQueueUnbind.get_Arguments();
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.QueueUnbindOk : MethodBase {
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.TxCommit : MethodBase {
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.TxCommitOk : MethodBase {
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal static class RabbitMQ.Client.Framing.Impl.TxMethodConstants : object {
    internal static ushort Select;
    internal static ushort SelectOk;
    internal static ushort Commit;
    internal static ushort CommitOk;
    internal static ushort Rollback;
    internal static ushort RollbackOk;
}
internal class RabbitMQ.Client.Framing.Impl.TxRollback : MethodBase {
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.TxRollbackOk : MethodBase {
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.TxSelect : MethodBase {
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal class RabbitMQ.Client.Framing.Impl.TxSelectOk : MethodBase {
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public bool HasContent { get; }
    public virtual ushort get_ProtocolClassId();
    public virtual ushort get_ProtocolMethodId();
    public virtual string get_ProtocolMethodName();
    public virtual bool get_HasContent();
    public virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public virtual int GetRequiredBufferSize();
    public virtual void AppendArgumentDebugStringTo(StringBuilder sb);
}
internal interface RabbitMQ.Client.Framing.IQueueBind {
    public ushort Reserved1 { get; }
    public string Queue { get; }
    public string Exchange { get; }
    public string RoutingKey { get; }
    public bool Nowait { get; }
    public IDictionary`2<string, object> Arguments { get; }
    public abstract virtual ushort get_Reserved1();
    public abstract virtual string get_Queue();
    public abstract virtual string get_Exchange();
    public abstract virtual string get_RoutingKey();
    public abstract virtual bool get_Nowait();
    public abstract virtual IDictionary`2<string, object> get_Arguments();
}
internal interface RabbitMQ.Client.Framing.IQueueBindOk {
}
internal interface RabbitMQ.Client.Framing.IQueueDeclare {
    public ushort Reserved1 { get; }
    public string Queue { get; }
    public bool Passive { get; }
    public bool Durable { get; }
    public bool Exclusive { get; }
    public bool AutoDelete { get; }
    public bool Nowait { get; }
    public IDictionary`2<string, object> Arguments { get; }
    public abstract virtual ushort get_Reserved1();
    public abstract virtual string get_Queue();
    public abstract virtual bool get_Passive();
    public abstract virtual bool get_Durable();
    public abstract virtual bool get_Exclusive();
    public abstract virtual bool get_AutoDelete();
    public abstract virtual bool get_Nowait();
    public abstract virtual IDictionary`2<string, object> get_Arguments();
}
internal interface RabbitMQ.Client.Framing.IQueueDeclareOk {
    public string Queue { get; }
    public UInt32 MessageCount { get; }
    public UInt32 ConsumerCount { get; }
    public abstract virtual string get_Queue();
    public abstract virtual UInt32 get_MessageCount();
    public abstract virtual UInt32 get_ConsumerCount();
}
internal interface RabbitMQ.Client.Framing.IQueueDelete {
    public ushort Reserved1 { get; }
    public string Queue { get; }
    public bool IfUnused { get; }
    public bool IfEmpty { get; }
    public bool Nowait { get; }
    public abstract virtual ushort get_Reserved1();
    public abstract virtual string get_Queue();
    public abstract virtual bool get_IfUnused();
    public abstract virtual bool get_IfEmpty();
    public abstract virtual bool get_Nowait();
}
internal interface RabbitMQ.Client.Framing.IQueueDeleteOk {
    public UInt32 MessageCount { get; }
    public abstract virtual UInt32 get_MessageCount();
}
internal interface RabbitMQ.Client.Framing.IQueuePurge {
    public ushort Reserved1 { get; }
    public string Queue { get; }
    public bool Nowait { get; }
    public abstract virtual ushort get_Reserved1();
    public abstract virtual string get_Queue();
    public abstract virtual bool get_Nowait();
}
internal interface RabbitMQ.Client.Framing.IQueuePurgeOk {
    public UInt32 MessageCount { get; }
    public abstract virtual UInt32 get_MessageCount();
}
internal interface RabbitMQ.Client.Framing.IQueueUnbind {
    public ushort Reserved1 { get; }
    public string Queue { get; }
    public string Exchange { get; }
    public string RoutingKey { get; }
    public IDictionary`2<string, object> Arguments { get; }
    public abstract virtual ushort get_Reserved1();
    public abstract virtual string get_Queue();
    public abstract virtual string get_Exchange();
    public abstract virtual string get_RoutingKey();
    public abstract virtual IDictionary`2<string, object> get_Arguments();
}
internal interface RabbitMQ.Client.Framing.IQueueUnbindOk {
}
internal interface RabbitMQ.Client.Framing.ITxCommit {
}
internal interface RabbitMQ.Client.Framing.ITxCommitOk {
}
internal interface RabbitMQ.Client.Framing.ITxRollback {
}
internal interface RabbitMQ.Client.Framing.ITxRollbackOk {
}
internal interface RabbitMQ.Client.Framing.ITxSelect {
}
internal interface RabbitMQ.Client.Framing.ITxSelectOk {
}
internal class RabbitMQ.Client.Framing.Protocol : ProtocolBase {
    public int MajorVersion { get; }
    public int MinorVersion { get; }
    public int Revision { get; }
    public string ApiName { get; }
    public int DefaultPort { get; }
    public virtual int get_MajorVersion();
    public virtual int get_MinorVersion();
    public virtual int get_Revision();
    public virtual string get_ApiName();
    public virtual int get_DefaultPort();
    internal virtual MethodBase DecodeMethodFrom(ReadOnlySpan`1<byte> span);
    internal MethodBase DecodeMethodFrom(ushort classId, ushort methodId);
    internal virtual ContentHeaderBase DecodeContentHeaderFrom(ushort classId);
}
public static class RabbitMQ.Client.Headers : object {
    public static string XMaxPriority;
    public static string XMaxLength;
    public static string XMaxLengthInBytes;
    public static string XDeadLetterExchange;
    public static string XDeadLetterRoutingKey;
    public static string XMessageTTL;
    public static string XExpires;
    public static string AlternateExchange;
    public static string XPriority;
    public static string XQueueMode;
    public static string XQueueType;
    public static string XQuorumInitialGroupSize;
    public static string XSingleActiveConsumer;
    public static string XOverflow;
}
public interface RabbitMQ.Client.IAsyncBasicConsumer {
    public IModel Model { get; }
    public abstract virtual IModel get_Model();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ConsumerCancelled(AsyncEventHandler`1<ConsumerEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ConsumerCancelled(AsyncEventHandler`1<ConsumerEventArgs> value);
    public abstract virtual Task HandleBasicCancel(string consumerTag);
    public abstract virtual Task HandleBasicCancelOk(string consumerTag);
    public abstract virtual Task HandleBasicConsumeOk(string consumerTag);
    public abstract virtual Task HandleBasicDeliver(string consumerTag, ulong deliveryTag, bool redelivered, string exchange, string routingKey, IBasicProperties properties, ReadOnlyMemory`1<byte> body);
    public abstract virtual Task HandleModelShutdown(object model, ShutdownEventArgs reason);
}
public interface RabbitMQ.Client.IAsyncConnectionFactory {
    public bool DispatchConsumersAsync { get; public set; }
    public abstract virtual bool get_DispatchConsumersAsync();
    public abstract virtual void set_DispatchConsumersAsync(bool value);
}
public interface RabbitMQ.Client.IAuthMechanism {
    public abstract virtual Byte[] handleChallenge(Byte[] challenge, IConnectionFactory factory);
}
public interface RabbitMQ.Client.IAuthMechanismFactory {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual IAuthMechanism GetInstance();
}
public interface RabbitMQ.Client.IAutorecoveringConnection {
    [CompilerGeneratedAttribute]
public abstract virtual void add_RecoverySucceeded(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_RecoverySucceeded(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ConnectionRecoveryError(EventHandler`1<ConnectionRecoveryErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ConnectionRecoveryError(EventHandler`1<ConnectionRecoveryErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ConsumerTagChangeAfterRecovery(EventHandler`1<ConsumerTagChangedAfterRecoveryEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ConsumerTagChangeAfterRecovery(EventHandler`1<ConsumerTagChangedAfterRecoveryEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_QueueNameChangeAfterRecovery(EventHandler`1<QueueNameChangedAfterRecoveryEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_QueueNameChangeAfterRecovery(EventHandler`1<QueueNameChangedAfterRecoveryEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_RecoveringConsumer(EventHandler`1<RecoveringConsumerEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_RecoveringConsumer(EventHandler`1<RecoveringConsumerEventArgs> value);
}
public interface RabbitMQ.Client.IBasicConsumer {
    public IModel Model { get; }
    public abstract virtual IModel get_Model();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ConsumerCancelled(EventHandler`1<ConsumerEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ConsumerCancelled(EventHandler`1<ConsumerEventArgs> value);
    public abstract virtual void HandleBasicCancel(string consumerTag);
    public abstract virtual void HandleBasicCancelOk(string consumerTag);
    public abstract virtual void HandleBasicConsumeOk(string consumerTag);
    public abstract virtual void HandleBasicDeliver(string consumerTag, ulong deliveryTag, bool redelivered, string exchange, string routingKey, IBasicProperties properties, ReadOnlyMemory`1<byte> body);
    public abstract virtual void HandleModelShutdown(object model, ShutdownEventArgs reason);
}
public interface RabbitMQ.Client.IBasicProperties {
    public string AppId { get; public set; }
    public string ClusterId { get; public set; }
    public string ContentEncoding { get; public set; }
    public string ContentType { get; public set; }
    public string CorrelationId { get; public set; }
    public byte DeliveryMode { get; public set; }
    public string Expiration { get; public set; }
    public IDictionary`2<string, object> Headers { get; public set; }
    public string MessageId { get; public set; }
    public bool Persistent { get; public set; }
    public byte Priority { get; public set; }
    public string ReplyTo { get; public set; }
    public PublicationAddress ReplyToAddress { get; public set; }
    public AmqpTimestamp Timestamp { get; public set; }
    public string Type { get; public set; }
    public string UserId { get; public set; }
    public abstract virtual string get_AppId();
    public abstract virtual void set_AppId(string value);
    public abstract virtual string get_ClusterId();
    public abstract virtual void set_ClusterId(string value);
    public abstract virtual string get_ContentEncoding();
    public abstract virtual void set_ContentEncoding(string value);
    public abstract virtual string get_ContentType();
    public abstract virtual void set_ContentType(string value);
    public abstract virtual string get_CorrelationId();
    public abstract virtual void set_CorrelationId(string value);
    public abstract virtual byte get_DeliveryMode();
    public abstract virtual void set_DeliveryMode(byte value);
    public abstract virtual string get_Expiration();
    public abstract virtual void set_Expiration(string value);
    public abstract virtual IDictionary`2<string, object> get_Headers();
    public abstract virtual void set_Headers(IDictionary`2<string, object> value);
    public abstract virtual string get_MessageId();
    public abstract virtual void set_MessageId(string value);
    public abstract virtual bool get_Persistent();
    public abstract virtual void set_Persistent(bool value);
    public abstract virtual byte get_Priority();
    public abstract virtual void set_Priority(byte value);
    public abstract virtual string get_ReplyTo();
    public abstract virtual void set_ReplyTo(string value);
    public abstract virtual PublicationAddress get_ReplyToAddress();
    public abstract virtual void set_ReplyToAddress(PublicationAddress value);
    public abstract virtual AmqpTimestamp get_Timestamp();
    public abstract virtual void set_Timestamp(AmqpTimestamp value);
    public abstract virtual string get_Type();
    public abstract virtual void set_Type(string value);
    public abstract virtual string get_UserId();
    public abstract virtual void set_UserId(string value);
    public abstract virtual void ClearAppId();
    public abstract virtual void ClearClusterId();
    public abstract virtual void ClearContentEncoding();
    public abstract virtual void ClearContentType();
    public abstract virtual void ClearCorrelationId();
    public abstract virtual void ClearDeliveryMode();
    public abstract virtual void ClearExpiration();
    public abstract virtual void ClearHeaders();
    public abstract virtual void ClearMessageId();
    public abstract virtual void ClearPriority();
    public abstract virtual void ClearReplyTo();
    public abstract virtual void ClearTimestamp();
    public abstract virtual void ClearType();
    public abstract virtual void ClearUserId();
    public abstract virtual bool IsAppIdPresent();
    public abstract virtual bool IsClusterIdPresent();
    public abstract virtual bool IsContentEncodingPresent();
    public abstract virtual bool IsContentTypePresent();
    public abstract virtual bool IsCorrelationIdPresent();
    public abstract virtual bool IsDeliveryModePresent();
    public abstract virtual bool IsExpirationPresent();
    public abstract virtual bool IsHeadersPresent();
    public abstract virtual bool IsMessageIdPresent();
    public abstract virtual bool IsPriorityPresent();
    public abstract virtual bool IsReplyToPresent();
    public abstract virtual bool IsTimestampPresent();
    public abstract virtual bool IsTypePresent();
    public abstract virtual bool IsUserIdPresent();
}
public interface RabbitMQ.Client.IBasicPublishBatch {
    [ObsoleteAttribute("Use Add(string exchange, string routingKey, bool mandatory, IBasicProperties properties, ReadOnlyMemory<byte> body) instead. Will be replaced in version 7.0", "False")]
public abstract virtual void Add(string exchange, string routingKey, bool mandatory, IBasicProperties properties, Byte[] body);
    public abstract virtual void Publish();
}
public interface RabbitMQ.Client.IConnection {
    public ushort ChannelMax { get; }
    public IDictionary`2<string, object> ClientProperties { get; }
    public ShutdownEventArgs CloseReason { get; }
    public AmqpTcpEndpoint Endpoint { get; }
    public UInt32 FrameMax { get; }
    public TimeSpan Heartbeat { get; }
    public bool IsOpen { get; }
    public AmqpTcpEndpoint[] KnownHosts { get; }
    public IProtocol Protocol { get; }
    public IDictionary`2<string, object> ServerProperties { get; }
    public IList`1<ShutdownReportEntry> ShutdownReport { get; }
    public string ClientProvidedName { get; }
    public abstract virtual ushort get_ChannelMax();
    public abstract virtual IDictionary`2<string, object> get_ClientProperties();
    public abstract virtual ShutdownEventArgs get_CloseReason();
    public abstract virtual AmqpTcpEndpoint get_Endpoint();
    public abstract virtual UInt32 get_FrameMax();
    public abstract virtual TimeSpan get_Heartbeat();
    public abstract virtual bool get_IsOpen();
    public abstract virtual AmqpTcpEndpoint[] get_KnownHosts();
    public abstract virtual IProtocol get_Protocol();
    public abstract virtual IDictionary`2<string, object> get_ServerProperties();
    public abstract virtual IList`1<ShutdownReportEntry> get_ShutdownReport();
    public abstract virtual string get_ClientProvidedName();
    [CompilerGeneratedAttribute]
public abstract virtual void add_CallbackException(EventHandler`1<CallbackExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CallbackException(EventHandler`1<CallbackExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ConnectionBlocked(EventHandler`1<ConnectionBlockedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ConnectionBlocked(EventHandler`1<ConnectionBlockedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ConnectionShutdown(EventHandler`1<ShutdownEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ConnectionShutdown(EventHandler`1<ShutdownEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ConnectionUnblocked(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ConnectionUnblocked(EventHandler`1<EventArgs> value);
    public abstract virtual void UpdateSecret(string newSecret, string reason);
    public abstract virtual void Abort();
    public abstract virtual void Abort(ushort reasonCode, string reasonText);
    public abstract virtual void Abort(TimeSpan timeout);
    public abstract virtual void Abort(ushort reasonCode, string reasonText, TimeSpan timeout);
    public abstract virtual void Close();
    public abstract virtual void Close(ushort reasonCode, string reasonText);
    public abstract virtual void Close(TimeSpan timeout);
    public abstract virtual void Close(ushort reasonCode, string reasonText, TimeSpan timeout);
    public abstract virtual IModel CreateModel();
    public abstract virtual void HandleConnectionBlocked(string reason);
    public abstract virtual void HandleConnectionUnblocked();
}
public interface RabbitMQ.Client.IConnectionFactory {
    public IDictionary`2<string, object> ClientProperties { get; public set; }
    public string UserName { get; public set; }
    public string Password { get; public set; }
    public ICredentialsProvider CredentialsProvider { get; public set; }
    public ICredentialsRefresher CredentialsRefresher { get; public set; }
    public ushort RequestedChannelMax { get; public set; }
    public UInt32 RequestedFrameMax { get; public set; }
    public TimeSpan RequestedHeartbeat { get; public set; }
    public bool UseBackgroundThreadsForIO { get; public set; }
    public string VirtualHost { get; public set; }
    public Uri Uri { get; public set; }
    public string ClientProvidedName { get; public set; }
    public TimeSpan HandshakeContinuationTimeout { get; public set; }
    public TimeSpan ContinuationTimeout { get; public set; }
    public abstract virtual IDictionary`2<string, object> get_ClientProperties();
    public abstract virtual void set_ClientProperties(IDictionary`2<string, object> value);
    public abstract virtual string get_UserName();
    public abstract virtual void set_UserName(string value);
    public abstract virtual string get_Password();
    public abstract virtual void set_Password(string value);
    public abstract virtual ICredentialsProvider get_CredentialsProvider();
    public abstract virtual void set_CredentialsProvider(ICredentialsProvider value);
    public abstract virtual ICredentialsRefresher get_CredentialsRefresher();
    public abstract virtual void set_CredentialsRefresher(ICredentialsRefresher value);
    public abstract virtual ushort get_RequestedChannelMax();
    public abstract virtual void set_RequestedChannelMax(ushort value);
    public abstract virtual UInt32 get_RequestedFrameMax();
    public abstract virtual void set_RequestedFrameMax(UInt32 value);
    public abstract virtual TimeSpan get_RequestedHeartbeat();
    public abstract virtual void set_RequestedHeartbeat(TimeSpan value);
    public abstract virtual bool get_UseBackgroundThreadsForIO();
    public abstract virtual void set_UseBackgroundThreadsForIO(bool value);
    public abstract virtual string get_VirtualHost();
    public abstract virtual void set_VirtualHost(string value);
    public abstract virtual Uri get_Uri();
    public abstract virtual void set_Uri(Uri value);
    public abstract virtual string get_ClientProvidedName();
    public abstract virtual void set_ClientProvidedName(string value);
    public abstract virtual IAuthMechanismFactory AuthMechanismFactory(IList`1<string> mechanismNames);
    public abstract virtual IConnection CreateConnection();
    public abstract virtual IConnection CreateConnection(string clientProvidedName);
    public abstract virtual IConnection CreateConnection(IList`1<string> hostnames);
    public abstract virtual IConnection CreateConnection(IList`1<string> hostnames, string clientProvidedName);
    public abstract virtual IConnection CreateConnection(IList`1<AmqpTcpEndpoint> endpoints);
    public abstract virtual IConnection CreateConnection(IList`1<AmqpTcpEndpoint> endpoints, string clientProvidedName);
    public abstract virtual TimeSpan get_HandshakeContinuationTimeout();
    public abstract virtual void set_HandshakeContinuationTimeout(TimeSpan value);
    public abstract virtual TimeSpan get_ContinuationTimeout();
    public abstract virtual void set_ContinuationTimeout(TimeSpan value);
}
public interface RabbitMQ.Client.IContentHeader {
    public ushort ProtocolClassId { get; }
    public string ProtocolClassName { get; }
    public abstract virtual ushort get_ProtocolClassId();
    public abstract virtual string get_ProtocolClassName();
}
public interface RabbitMQ.Client.ICredentialsProvider {
    public string Name { get; }
    public string UserName { get; }
    public string Password { get; }
    public Nullable`1<TimeSpan> ValidUntil { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_UserName();
    public abstract virtual string get_Password();
    public abstract virtual Nullable`1<TimeSpan> get_ValidUntil();
    public abstract virtual void Refresh();
}
public interface RabbitMQ.Client.ICredentialsRefresher {
    public abstract virtual ICredentialsProvider Register(ICredentialsProvider provider, NotifyCredentialRefreshed callback);
    public abstract virtual bool Unregister(ICredentialsProvider provider);
}
public interface RabbitMQ.Client.IEndpointResolver {
    public abstract virtual IEnumerable`1<AmqpTcpEndpoint> All();
}
public interface RabbitMQ.Client.IMethod {
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public abstract virtual ushort get_ProtocolClassId();
    public abstract virtual ushort get_ProtocolMethodId();
    public abstract virtual string get_ProtocolMethodName();
}
public interface RabbitMQ.Client.IModel {
    public int ChannelNumber { get; }
    public ShutdownEventArgs CloseReason { get; }
    public IBasicConsumer DefaultConsumer { get; public set; }
    public bool IsClosed { get; }
    public bool IsOpen { get; }
    public ulong NextPublishSeqNo { get; }
    public string CurrentQueue { get; }
    public TimeSpan ContinuationTimeout { get; public set; }
    public abstract virtual int get_ChannelNumber();
    public abstract virtual ShutdownEventArgs get_CloseReason();
    public abstract virtual IBasicConsumer get_DefaultConsumer();
    public abstract virtual void set_DefaultConsumer(IBasicConsumer value);
    public abstract virtual bool get_IsClosed();
    public abstract virtual bool get_IsOpen();
    public abstract virtual ulong get_NextPublishSeqNo();
    public abstract virtual string get_CurrentQueue();
    [CompilerGeneratedAttribute]
public abstract virtual void add_BasicAcks(EventHandler`1<BasicAckEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BasicAcks(EventHandler`1<BasicAckEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_BasicNacks(EventHandler`1<BasicNackEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BasicNacks(EventHandler`1<BasicNackEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_BasicRecoverOk(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BasicRecoverOk(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_BasicReturn(EventHandler`1<BasicReturnEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BasicReturn(EventHandler`1<BasicReturnEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CallbackException(EventHandler`1<CallbackExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CallbackException(EventHandler`1<CallbackExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_FlowControl(EventHandler`1<FlowControlEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_FlowControl(EventHandler`1<FlowControlEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ModelShutdown(EventHandler`1<ShutdownEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ModelShutdown(EventHandler`1<ShutdownEventArgs> value);
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual void Abort();
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual void Abort(ushort replyCode, string replyText);
    public abstract virtual void BasicAck(ulong deliveryTag, bool multiple);
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual void BasicCancel(string consumerTag);
    public abstract virtual void BasicCancelNoWait(string consumerTag);
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual string BasicConsume(string queue, bool autoAck, string consumerTag, bool noLocal, bool exclusive, IDictionary`2<string, object> arguments, IBasicConsumer consumer);
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual BasicGetResult BasicGet(string queue, bool autoAck);
    public abstract virtual void BasicNack(ulong deliveryTag, bool multiple, bool requeue);
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual void BasicPublish(string exchange, string routingKey, bool mandatory, IBasicProperties basicProperties, ReadOnlyMemory`1<byte> body);
    public abstract virtual void BasicQos(UInt32 prefetchSize, ushort prefetchCount, bool global);
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual void BasicRecover(bool requeue);
    public abstract virtual void BasicRecoverAsync(bool requeue);
    public abstract virtual void BasicReject(ulong deliveryTag, bool requeue);
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual void Close();
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual void Close(ushort replyCode, string replyText);
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual void ConfirmSelect();
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual IBasicPublishBatch CreateBasicPublishBatch();
    [AmqpContentHeaderFactoryAttribute("basic")]
public abstract virtual IBasicProperties CreateBasicProperties();
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual void ExchangeBind(string destination, string source, string routingKey, IDictionary`2<string, object> arguments);
    public abstract virtual void ExchangeBindNoWait(string destination, string source, string routingKey, IDictionary`2<string, object> arguments);
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual void ExchangeDeclare(string exchange, string type, bool durable, bool autoDelete, IDictionary`2<string, object> arguments);
    public abstract virtual void ExchangeDeclareNoWait(string exchange, string type, bool durable, bool autoDelete, IDictionary`2<string, object> arguments);
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual void ExchangeDeclarePassive(string exchange);
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual void ExchangeDelete(string exchange, bool ifUnused);
    public abstract virtual void ExchangeDeleteNoWait(string exchange, bool ifUnused);
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual void ExchangeUnbind(string destination, string source, string routingKey, IDictionary`2<string, object> arguments);
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual void ExchangeUnbindNoWait(string destination, string source, string routingKey, IDictionary`2<string, object> arguments);
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual void QueueBind(string queue, string exchange, string routingKey, IDictionary`2<string, object> arguments);
    public abstract virtual void QueueBindNoWait(string queue, string exchange, string routingKey, IDictionary`2<string, object> arguments);
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual QueueDeclareOk QueueDeclare(string queue, bool durable, bool exclusive, bool autoDelete, IDictionary`2<string, object> arguments);
    public abstract virtual void QueueDeclareNoWait(string queue, bool durable, bool exclusive, bool autoDelete, IDictionary`2<string, object> arguments);
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual QueueDeclareOk QueueDeclarePassive(string queue);
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual UInt32 MessageCount(string queue);
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual UInt32 ConsumerCount(string queue);
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual UInt32 QueueDelete(string queue, bool ifUnused, bool ifEmpty);
    public abstract virtual void QueueDeleteNoWait(string queue, bool ifUnused, bool ifEmpty);
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual UInt32 QueuePurge(string queue);
    public abstract virtual void QueueUnbind(string queue, string exchange, string routingKey, IDictionary`2<string, object> arguments);
    public abstract virtual void TxCommit();
    public abstract virtual void TxRollback();
    public abstract virtual void TxSelect();
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual bool WaitForConfirms();
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual bool WaitForConfirms(TimeSpan timeout);
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual bool WaitForConfirms(TimeSpan timeout, Boolean& timedOut);
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual void WaitForConfirmsOrDie();
    [AmqpMethodDoNotImplementAttribute("")]
public abstract virtual void WaitForConfirmsOrDie(TimeSpan timeout);
    public abstract virtual TimeSpan get_ContinuationTimeout();
    public abstract virtual void set_ContinuationTimeout(TimeSpan value);
}
[ExtensionAttribute]
public static class RabbitMQ.Client.IModelExensions : object {
    [ExtensionAttribute]
public static string BasicConsume(IModel model, IBasicConsumer consumer, string queue, bool autoAck, string consumerTag, bool noLocal, bool exclusive, IDictionary`2<string, object> arguments);
    [ExtensionAttribute]
public static string BasicConsume(IModel model, string queue, bool autoAck, IBasicConsumer consumer);
    [ExtensionAttribute]
public static string BasicConsume(IModel model, string queue, bool autoAck, string consumerTag, IBasicConsumer consumer);
    [ExtensionAttribute]
public static string BasicConsume(IModel model, string queue, bool autoAck, string consumerTag, IDictionary`2<string, object> arguments, IBasicConsumer consumer);
    [ExtensionAttribute]
public static void BasicPublish(IModel model, PublicationAddress addr, IBasicProperties basicProperties, ReadOnlyMemory`1<byte> body);
    [ExtensionAttribute]
public static void BasicPublish(IModel model, string exchange, string routingKey, IBasicProperties basicProperties, ReadOnlyMemory`1<byte> body);
    [ExtensionAttribute]
public static void BasicPublish(IModel model, string exchange, string routingKey, bool mandatory, IBasicProperties basicProperties, ReadOnlyMemory`1<byte> body);
    [ExtensionAttribute]
public static QueueDeclareOk QueueDeclare(IModel model, string queue, bool durable, bool exclusive, bool autoDelete, IDictionary`2<string, object> arguments);
    [ExtensionAttribute]
public static void ExchangeBind(IModel model, string destination, string source, string routingKey, IDictionary`2<string, object> arguments);
    [ExtensionAttribute]
public static void ExchangeBindNoWait(IModel model, string destination, string source, string routingKey, IDictionary`2<string, object> arguments);
    [ExtensionAttribute]
public static void ExchangeDeclare(IModel model, string exchange, string type, bool durable, bool autoDelete, IDictionary`2<string, object> arguments);
    [ExtensionAttribute]
public static void ExchangeDeclareNoWait(IModel model, string exchange, string type, bool durable, bool autoDelete, IDictionary`2<string, object> arguments);
    [ExtensionAttribute]
public static void ExchangeUnbind(IModel model, string destination, string source, string routingKey, IDictionary`2<string, object> arguments);
    [ExtensionAttribute]
public static void ExchangeDelete(IModel model, string exchange, bool ifUnused);
    [ExtensionAttribute]
public static void ExchangeDeleteNoWait(IModel model, string exchange, bool ifUnused);
    [ExtensionAttribute]
public static void QueueBind(IModel model, string queue, string exchange, string routingKey, IDictionary`2<string, object> arguments);
    [ExtensionAttribute]
public static UInt32 QueueDelete(IModel model, string queue, bool ifUnused, bool ifEmpty);
    [ExtensionAttribute]
public static void QueueDeleteNoWait(IModel model, string queue, bool ifUnused, bool ifEmpty);
    [ExtensionAttribute]
public static void QueueUnbind(IModel model, string queue, string exchange, string routingKey, IDictionary`2<string, object> arguments);
}
internal class RabbitMQ.Client.Impl.AsyncConsumerDispatcher : object {
    private ModelBase _model;
    private AsyncConsumerWorkService _workService;
    [CompilerGeneratedAttribute]
private bool <IsShutdown>k__BackingField;
    public bool IsShutdown { get; private set; }
    public AsyncConsumerDispatcher(ModelBase model, AsyncConsumerWorkService ws);
    public sealed virtual void Quiesce();
    public sealed virtual Task Shutdown(IModel model);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsShutdown();
    [CompilerGeneratedAttribute]
private void set_IsShutdown(bool value);
    public sealed virtual void HandleBasicConsumeOk(IBasicConsumer consumer, string consumerTag);
    public sealed virtual void HandleBasicDeliver(IBasicConsumer consumer, string consumerTag, ulong deliveryTag, bool redelivered, string exchange, string routingKey, IBasicProperties basicProperties, ReadOnlySpan`1<byte> body);
    public sealed virtual void HandleBasicCancelOk(IBasicConsumer consumer, string consumerTag);
    public sealed virtual void HandleBasicCancel(IBasicConsumer consumer, string consumerTag);
    public sealed virtual void HandleModelShutdown(IBasicConsumer consumer, ShutdownEventArgs reason);
    private void ScheduleUnlessShuttingDown(TWork work);
    private void Schedule(TWork work);
}
internal class RabbitMQ.Client.Impl.AsyncConsumerWorkService : ConsumerWorkService {
    private ConcurrentDictionary`2<IModel, WorkPool> _workPools;
    private Func`2<IModel, WorkPool> _startNewWorkPoolFunc;
    public AsyncConsumerWorkService(int concurrency);
    public void Schedule(IModel model, TWork work);
    private WorkPool StartNewWorkPool(IModel model);
    public Task Stop(IModel model);
    [CompilerGeneratedAttribute]
private WorkPool <.ctor>b__2_0(IModel model);
}
internal class RabbitMQ.Client.Impl.AutorecoveringModel : object {
    private bool _disposed;
    private object _eventLock;
    private AutorecoveringConnection _connection;
    private RecoveryAwareModel _delegate;
    private List`1<string> _recordedConsumerTags;
    private EventHandler`1<BasicAckEventArgs> _recordedBasicAckEventHandlers;
    private EventHandler`1<BasicNackEventArgs> _recordedBasicNackEventHandlers;
    private EventHandler`1<BasicReturnEventArgs> _recordedBasicReturnEventHandlers;
    private EventHandler`1<CallbackExceptionEventArgs> _recordedCallbackExceptionEventHandlers;
    private EventHandler`1<ShutdownEventArgs> _recordedShutdownEventHandlers;
    private ushort _prefetchCountConsumer;
    private ushort _prefetchCountGlobal;
    private bool _usesPublisherConfirms;
    private bool _usesTransactions;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> Recovery;
    public IConsumerDispatcher ConsumerDispatcher { get; }
    public TimeSpan ContinuationTimeout { get; public set; }
    public IEnumerable`1<string> ConsumerTags { get; }
    public int ChannelNumber { get; }
    public ShutdownEventArgs CloseReason { get; }
    public IBasicConsumer DefaultConsumer { get; public set; }
    public IModel Delegate { get; }
    public bool IsClosed { get; }
    public bool IsOpen { get; }
    public ulong NextPublishSeqNo { get; }
    public string CurrentQueue { get; }
    public AutorecoveringModel(AutorecoveringConnection conn, RecoveryAwareModel _delegate);
    public IConsumerDispatcher get_ConsumerDispatcher();
    public sealed virtual TimeSpan get_ContinuationTimeout();
    public sealed virtual void set_ContinuationTimeout(TimeSpan value);
    public IEnumerable`1<string> get_ConsumerTags();
    public sealed virtual void add_BasicAcks(EventHandler`1<BasicAckEventArgs> value);
    public sealed virtual void remove_BasicAcks(EventHandler`1<BasicAckEventArgs> value);
    public sealed virtual void add_BasicNacks(EventHandler`1<BasicNackEventArgs> value);
    public sealed virtual void remove_BasicNacks(EventHandler`1<BasicNackEventArgs> value);
    public sealed virtual void add_BasicRecoverOk(EventHandler`1<EventArgs> value);
    public sealed virtual void remove_BasicRecoverOk(EventHandler`1<EventArgs> value);
    public sealed virtual void add_BasicReturn(EventHandler`1<BasicReturnEventArgs> value);
    public sealed virtual void remove_BasicReturn(EventHandler`1<BasicReturnEventArgs> value);
    public sealed virtual void add_CallbackException(EventHandler`1<CallbackExceptionEventArgs> value);
    public sealed virtual void remove_CallbackException(EventHandler`1<CallbackExceptionEventArgs> value);
    public sealed virtual void add_FlowControl(EventHandler`1<FlowControlEventArgs> value);
    public sealed virtual void remove_FlowControl(EventHandler`1<FlowControlEventArgs> value);
    public sealed virtual void add_ModelShutdown(EventHandler`1<ShutdownEventArgs> value);
    public sealed virtual void remove_ModelShutdown(EventHandler`1<ShutdownEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Recovery(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Recovery(EventHandler`1<EventArgs> value);
    public sealed virtual int get_ChannelNumber();
    public sealed virtual ShutdownEventArgs get_CloseReason();
    public sealed virtual IBasicConsumer get_DefaultConsumer();
    public sealed virtual void set_DefaultConsumer(IBasicConsumer value);
    public IModel get_Delegate();
    public sealed virtual bool get_IsClosed();
    public sealed virtual bool get_IsOpen();
    public sealed virtual ulong get_NextPublishSeqNo();
    public sealed virtual string get_CurrentQueue();
    public void AutomaticallyRecover(AutorecoveringConnection conn, bool recoverConsumers);
    public void Close(ushort replyCode, string replyText, bool abort);
    public void Close(ShutdownEventArgs reason, bool abort);
    public virtual string ToString();
    private sealed virtual override void System.IDisposable.Dispose();
    private void Dispose(bool disposing);
    public sealed virtual void ConnectionTuneOk(ushort channelMax, UInt32 frameMax, ushort heartbeat);
    public sealed virtual void HandleBasicAck(ulong deliveryTag, bool multiple);
    public sealed virtual void HandleBasicCancel(string consumerTag, bool nowait);
    public sealed virtual void HandleBasicCancelOk(string consumerTag);
    public sealed virtual void HandleBasicConsumeOk(string consumerTag);
    public sealed virtual void HandleBasicDeliver(string consumerTag, ulong deliveryTag, bool redelivered, string exchange, string routingKey, IBasicProperties basicProperties, ReadOnlyMemory`1<byte> body);
    public sealed virtual void HandleBasicGetEmpty();
    public sealed virtual void HandleBasicGetOk(ulong deliveryTag, bool redelivered, string exchange, string routingKey, UInt32 messageCount, IBasicProperties basicProperties, ReadOnlyMemory`1<byte> body);
    public sealed virtual void HandleBasicNack(ulong deliveryTag, bool multiple, bool requeue);
    public sealed virtual void HandleBasicRecoverOk();
    public sealed virtual void HandleBasicReturn(ushort replyCode, string replyText, string exchange, string routingKey, IBasicProperties basicProperties, ReadOnlyMemory`1<byte> body);
    public sealed virtual void HandleChannelClose(ushort replyCode, string replyText, ushort classId, ushort methodId);
    public sealed virtual void HandleChannelCloseOk();
    public sealed virtual void HandleChannelFlow(bool active);
    public sealed virtual void HandleConnectionBlocked(string reason);
    public sealed virtual void HandleConnectionClose(ushort replyCode, string replyText, ushort classId, ushort methodId);
    public sealed virtual void HandleConnectionOpenOk(string knownHosts);
    public sealed virtual void HandleConnectionSecure(Byte[] challenge);
    public sealed virtual void HandleConnectionStart(byte versionMajor, byte versionMinor, IDictionary`2<string, object> serverProperties, Byte[] mechanisms, Byte[] locales);
    public sealed virtual void HandleConnectionTune(ushort channelMax, UInt32 frameMax, ushort heartbeat);
    public sealed virtual void HandleConnectionUnblocked();
    public sealed virtual void HandleQueueDeclareOk(string queue, UInt32 messageCount, UInt32 consumerCount);
    public sealed virtual void _Private_BasicCancel(string consumerTag, bool nowait);
    public sealed virtual void _Private_BasicConsume(string queue, string consumerTag, bool noLocal, bool autoAck, bool exclusive, bool nowait, IDictionary`2<string, object> arguments);
    public sealed virtual void _Private_BasicGet(string queue, bool autoAck);
    public sealed virtual void _Private_BasicPublish(string exchange, string routingKey, bool mandatory, IBasicProperties basicProperties, ReadOnlyMemory`1<byte> body);
    public sealed virtual void _Private_BasicRecover(bool requeue);
    public sealed virtual void _Private_ChannelClose(ushort replyCode, string replyText, ushort classId, ushort methodId);
    public sealed virtual void _Private_ChannelCloseOk();
    public sealed virtual void _Private_ChannelFlowOk(bool active);
    public sealed virtual void _Private_ChannelOpen(string outOfBand);
    public sealed virtual void _Private_ConfirmSelect(bool nowait);
    public sealed virtual void _Private_ConnectionClose(ushort replyCode, string replyText, ushort classId, ushort methodId);
    public sealed virtual void _Private_ConnectionCloseOk();
    public sealed virtual void _Private_ConnectionOpen(string virtualHost, string capabilities, bool insist);
    public sealed virtual void _Private_ConnectionSecureOk(Byte[] response);
    public sealed virtual void _Private_ConnectionStartOk(IDictionary`2<string, object> clientProperties, string mechanism, Byte[] response, string locale);
    public sealed virtual void _Private_UpdateSecret(Byte[] newSecret, string reason);
    public sealed virtual void _Private_ExchangeBind(string destination, string source, string routingKey, bool nowait, IDictionary`2<string, object> arguments);
    public sealed virtual void _Private_ExchangeDeclare(string exchange, string type, bool passive, bool durable, bool autoDelete, bool internal, bool nowait, IDictionary`2<string, object> arguments);
    public sealed virtual void _Private_ExchangeDelete(string exchange, bool ifUnused, bool nowait);
    public sealed virtual void _Private_ExchangeUnbind(string destination, string source, string routingKey, bool nowait, IDictionary`2<string, object> arguments);
    public sealed virtual void _Private_QueueBind(string queue, string exchange, string routingKey, bool nowait, IDictionary`2<string, object> arguments);
    public sealed virtual void _Private_QueueDeclare(string queue, bool passive, bool durable, bool exclusive, bool autoDelete, bool nowait, IDictionary`2<string, object> arguments);
    public sealed virtual UInt32 _Private_QueueDelete(string queue, bool ifUnused, bool ifEmpty, bool nowait);
    public sealed virtual UInt32 _Private_QueuePurge(string queue, bool nowait);
    public sealed virtual void Abort();
    public sealed virtual void Abort(ushort replyCode, string replyText);
    public sealed virtual void BasicAck(ulong deliveryTag, bool multiple);
    public sealed virtual void BasicCancel(string consumerTag);
    public sealed virtual void BasicCancelNoWait(string consumerTag);
    public sealed virtual string BasicConsume(string queue, bool autoAck, string consumerTag, bool noLocal, bool exclusive, IDictionary`2<string, object> arguments, IBasicConsumer consumer);
    public sealed virtual BasicGetResult BasicGet(string queue, bool autoAck);
    public sealed virtual void BasicNack(ulong deliveryTag, bool multiple, bool requeue);
    public sealed virtual void BasicPublish(string exchange, string routingKey, bool mandatory, IBasicProperties basicProperties, ReadOnlyMemory`1<byte> body);
    public sealed virtual void BasicQos(UInt32 prefetchSize, ushort prefetchCount, bool global);
    public sealed virtual void BasicRecover(bool requeue);
    public sealed virtual void BasicRecoverAsync(bool requeue);
    public sealed virtual void BasicReject(ulong deliveryTag, bool requeue);
    public sealed virtual void Close();
    public sealed virtual void Close(ushort replyCode, string replyText);
    public sealed virtual void ConfirmSelect();
    public sealed virtual IBasicProperties CreateBasicProperties();
    public sealed virtual void ExchangeBind(string destination, string source, string routingKey, IDictionary`2<string, object> arguments);
    public sealed virtual void ExchangeBindNoWait(string destination, string source, string routingKey, IDictionary`2<string, object> arguments);
    public sealed virtual void ExchangeDeclare(string exchange, string type, bool durable, bool autoDelete, IDictionary`2<string, object> arguments);
    public sealed virtual void ExchangeDeclareNoWait(string exchange, string type, bool durable, bool autoDelete, IDictionary`2<string, object> arguments);
    public sealed virtual void ExchangeDeclarePassive(string exchange);
    public sealed virtual void ExchangeDelete(string exchange, bool ifUnused);
    public sealed virtual void ExchangeDeleteNoWait(string exchange, bool ifUnused);
    public sealed virtual void ExchangeUnbind(string destination, string source, string routingKey, IDictionary`2<string, object> arguments);
    public sealed virtual void ExchangeUnbindNoWait(string destination, string source, string routingKey, IDictionary`2<string, object> arguments);
    public sealed virtual void QueueBind(string queue, string exchange, string routingKey, IDictionary`2<string, object> arguments);
    public sealed virtual void QueueBindNoWait(string queue, string exchange, string routingKey, IDictionary`2<string, object> arguments);
    public sealed virtual QueueDeclareOk QueueDeclare(string queue, bool durable, bool exclusive, bool autoDelete, IDictionary`2<string, object> arguments);
    public sealed virtual void QueueDeclareNoWait(string queue, bool durable, bool exclusive, bool autoDelete, IDictionary`2<string, object> arguments);
    public sealed virtual QueueDeclareOk QueueDeclarePassive(string queue);
    public sealed virtual UInt32 MessageCount(string queue);
    public sealed virtual UInt32 ConsumerCount(string queue);
    public sealed virtual UInt32 QueueDelete(string queue, bool ifUnused, bool ifEmpty);
    public sealed virtual void QueueDeleteNoWait(string queue, bool ifUnused, bool ifEmpty);
    public sealed virtual UInt32 QueuePurge(string queue);
    public sealed virtual void QueueUnbind(string queue, string exchange, string routingKey, IDictionary`2<string, object> arguments);
    public sealed virtual void TxCommit();
    public sealed virtual void TxRollback();
    public sealed virtual void TxSelect();
    public sealed virtual bool WaitForConfirms(TimeSpan timeout, Boolean& timedOut);
    public sealed virtual bool WaitForConfirms(TimeSpan timeout);
    public sealed virtual bool WaitForConfirms();
    public sealed virtual void WaitForConfirmsOrDie();
    public sealed virtual void WaitForConfirmsOrDie(TimeSpan timeout);
    private void RecoverBasicAckHandlers();
    private void RecoverBasicNackHandlers();
    private void RecoverBasicReturnHandlers();
    private void RecoverCallbackExceptionHandlers();
    private void RunRecoveryEventHandlers();
    public sealed virtual IBasicPublishBatch CreateBasicPublishBatch();
}
internal class RabbitMQ.Client.Impl.BasicCancel : Work {
    private string _consumerTag;
    public string Context { get; }
    public BasicCancel(IBasicConsumer consumer, string consumerTag);
    public virtual string get_Context();
    protected virtual Task Execute(IAsyncBasicConsumer consumer);
}
internal class RabbitMQ.Client.Impl.BasicCancelOk : Work {
    private string _consumerTag;
    public string Context { get; }
    public BasicCancelOk(IBasicConsumer consumer, string consumerTag);
    public virtual string get_Context();
    protected virtual Task Execute(IAsyncBasicConsumer consumer);
}
internal class RabbitMQ.Client.Impl.BasicConsumeOk : Work {
    private string _consumerTag;
    public string Context { get; }
    public BasicConsumeOk(IBasicConsumer consumer, string consumerTag);
    public virtual string get_Context();
    protected virtual Task Execute(IAsyncBasicConsumer consumer);
}
internal class RabbitMQ.Client.Impl.BasicDeliver : Work {
    private string _consumerTag;
    private ulong _deliveryTag;
    private bool _redelivered;
    private string _exchange;
    private string _routingKey;
    private IBasicProperties _basicProperties;
    private ReadOnlyMemory`1<byte> _body;
    private ArrayPool`1<byte> _bodyOwner;
    public string Context { get; }
    public BasicDeliver(IBasicConsumer consumer, string consumerTag, ulong deliveryTag, bool redelivered, string exchange, string routingKey, IBasicProperties basicProperties, ReadOnlyMemory`1<byte> body, ArrayPool`1<byte> pool);
    public virtual string get_Context();
    protected virtual Task Execute(IAsyncBasicConsumer consumer);
    public virtual void PostExecute();
}
internal abstract class RabbitMQ.Client.Impl.BasicProperties : ContentHeaderBase {
    public string AppId { get; public set; }
    public string ClusterId { get; public set; }
    public string ContentEncoding { get; public set; }
    public string ContentType { get; public set; }
    public string CorrelationId { get; public set; }
    public byte DeliveryMode { get; public set; }
    public string Expiration { get; public set; }
    public IDictionary`2<string, object> Headers { get; public set; }
    public string MessageId { get; public set; }
    public bool Persistent { get; public set; }
    public byte Priority { get; public set; }
    public string ReplyTo { get; public set; }
    public PublicationAddress ReplyToAddress { get; public set; }
    public AmqpTimestamp Timestamp { get; public set; }
    public string Type { get; public set; }
    public string UserId { get; public set; }
    public abstract virtual string get_AppId();
    public abstract virtual void set_AppId(string value);
    public abstract virtual string get_ClusterId();
    public abstract virtual void set_ClusterId(string value);
    public abstract virtual string get_ContentEncoding();
    public abstract virtual void set_ContentEncoding(string value);
    public abstract virtual string get_ContentType();
    public abstract virtual void set_ContentType(string value);
    public abstract virtual string get_CorrelationId();
    public abstract virtual void set_CorrelationId(string value);
    public abstract virtual byte get_DeliveryMode();
    public abstract virtual void set_DeliveryMode(byte value);
    public abstract virtual string get_Expiration();
    public abstract virtual void set_Expiration(string value);
    public abstract virtual IDictionary`2<string, object> get_Headers();
    public abstract virtual void set_Headers(IDictionary`2<string, object> value);
    public abstract virtual string get_MessageId();
    public abstract virtual void set_MessageId(string value);
    public sealed virtual bool get_Persistent();
    public sealed virtual void set_Persistent(bool value);
    public abstract virtual byte get_Priority();
    public abstract virtual void set_Priority(byte value);
    public abstract virtual string get_ReplyTo();
    public abstract virtual void set_ReplyTo(string value);
    public sealed virtual PublicationAddress get_ReplyToAddress();
    public sealed virtual void set_ReplyToAddress(PublicationAddress value);
    public abstract virtual AmqpTimestamp get_Timestamp();
    public abstract virtual void set_Timestamp(AmqpTimestamp value);
    public abstract virtual string get_Type();
    public abstract virtual void set_Type(string value);
    public abstract virtual string get_UserId();
    public abstract virtual void set_UserId(string value);
    public abstract virtual void ClearAppId();
    public abstract virtual void ClearClusterId();
    public abstract virtual void ClearContentEncoding();
    public abstract virtual void ClearContentType();
    public abstract virtual void ClearCorrelationId();
    public abstract virtual void ClearDeliveryMode();
    public abstract virtual void ClearExpiration();
    public abstract virtual void ClearHeaders();
    public abstract virtual void ClearMessageId();
    public abstract virtual void ClearPriority();
    public abstract virtual void ClearReplyTo();
    public abstract virtual void ClearTimestamp();
    public abstract virtual void ClearType();
    public abstract virtual void ClearUserId();
    public abstract virtual bool IsAppIdPresent();
    public abstract virtual bool IsClusterIdPresent();
    public abstract virtual bool IsContentEncodingPresent();
    public abstract virtual bool IsContentTypePresent();
    public abstract virtual bool IsCorrelationIdPresent();
    public abstract virtual bool IsDeliveryModePresent();
    public abstract virtual bool IsExpirationPresent();
    public abstract virtual bool IsHeadersPresent();
    public abstract virtual bool IsMessageIdPresent();
    public abstract virtual bool IsPriorityPresent();
    public abstract virtual bool IsReplyToPresent();
    public abstract virtual bool IsTimestampPresent();
    public abstract virtual bool IsTypePresent();
    public abstract virtual bool IsUserIdPresent();
    public abstract virtual int GetRequiredPayloadBufferSize();
    public virtual object Clone();
}
internal class RabbitMQ.Client.Impl.BasicPublishBatch : object {
    private List`1<OutgoingCommand> _commands;
    private ModelBase _model;
    internal BasicPublishBatch(ModelBase model);
    public sealed virtual void Add(string exchange, string routingKey, bool mandatory, IBasicProperties basicProperties, Byte[] body);
    public void Add(string exchange, string routingKey, bool mandatory, IBasicProperties basicProperties, ReadOnlyMemory`1<byte> body);
    public sealed virtual void Publish();
}
internal class RabbitMQ.Client.Impl.CommandAssembler : object {
    private static int MaxArrayOfBytesSize;
    private ProtocolBase _protocol;
    private MethodBase _method;
    private ContentHeaderBase _header;
    private Byte[] _bodyBytes;
    private Memory`1<byte> _body;
    private int _remainingBodyBytes;
    private int _offset;
    private AssemblyState _state;
    public CommandAssembler(ProtocolBase protocol);
    private void Reset();
    public IncomingCommand HandleFrame(InboundFrame& frame);
    private void ParseMethodFrame(InboundFrame& frame);
    private void ParseHeaderFrame(InboundFrame& frame);
    private void ParseBodyFrame(InboundFrame& frame);
    private void UpdateContentBodyState();
}
internal class RabbitMQ.Client.Impl.CommandReceivedAction : MulticastDelegate {
    public CommandReceivedAction(object object, IntPtr method);
    public virtual void Invoke(IncomingCommand& modreq(System.Runtime.InteropServices.InAttribute) cmd);
    public virtual IAsyncResult BeginInvoke(IncomingCommand& modreq(System.Runtime.InteropServices.InAttribute) cmd, AsyncCallback callback, object object);
    public virtual void EndInvoke(IncomingCommand& modreq(System.Runtime.InteropServices.InAttribute) cmd, IAsyncResult result);
}
internal class RabbitMQ.Client.Impl.ConcurrentConsumerDispatcher : object {
    private ModelBase _model;
    private ConsumerWorkService _workService;
    [CompilerGeneratedAttribute]
private bool <IsShutdown>k__BackingField;
    public bool IsShutdown { get; private set; }
    public ConcurrentConsumerDispatcher(ModelBase model, ConsumerWorkService ws);
    public sealed virtual void Quiesce();
    public sealed virtual Task Shutdown(IModel model);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsShutdown();
    [CompilerGeneratedAttribute]
private void set_IsShutdown(bool value);
    public sealed virtual void HandleBasicConsumeOk(IBasicConsumer consumer, string consumerTag);
    public sealed virtual void HandleBasicDeliver(IBasicConsumer consumer, string consumerTag, ulong deliveryTag, bool redelivered, string exchange, string routingKey, IBasicProperties basicProperties, ReadOnlySpan`1<byte> body);
    public sealed virtual void HandleBasicCancelOk(IBasicConsumer consumer, string consumerTag);
    public sealed virtual void HandleBasicCancel(IBasicConsumer consumer, string consumerTag);
    public sealed virtual void HandleModelShutdown(IBasicConsumer consumer, ShutdownEventArgs reason);
    private void UnlessShuttingDown(Action fn);
    private void Execute(Action fn);
}
internal class RabbitMQ.Client.Impl.ConnectionSecureOrTune : object {
    public Byte[] m_challenge;
    public ConnectionTuneDetails m_tuneDetails;
}
internal class RabbitMQ.Client.Impl.ConnectionStartDetails : object {
    public Byte[] m_locales;
    public Byte[] m_mechanisms;
    public IDictionary`2<string, object> m_serverProperties;
    public byte m_versionMajor;
    public byte m_versionMinor;
}
internal class RabbitMQ.Client.Impl.ConnectionTuneDetails : ValueType {
    public ushort m_channelMax;
    public UInt32 m_frameMax;
    public ushort m_heartbeatInSeconds;
}
internal class RabbitMQ.Client.Impl.ConsumerWorkService : object {
    private ConcurrentDictionary`2<IModel, WorkPool> _workPools;
    private Func`2<IModel, WorkPool> _startNewWorkPoolFunc;
    protected int _concurrency;
    public ConsumerWorkService(int concurrency);
    public void AddWork(IModel model, Action fn);
    private WorkPool StartNewWorkPool(IModel model);
    public void StopWork();
    public void StopWork(IModel model);
    internal Task StopWorkAsync(IModel model);
    [CompilerGeneratedAttribute]
private WorkPool <.ctor>b__3_0(IModel model);
}
internal abstract class RabbitMQ.Client.Impl.ContentHeaderBase : object {
    public ushort ProtocolClassId { get; }
    public string ProtocolClassName { get; }
    public abstract virtual ushort get_ProtocolClassId();
    public abstract virtual string get_ProtocolClassName();
    public virtual object Clone();
    public abstract virtual void AppendPropertyDebugStringTo(StringBuilder stringBuilder);
    internal void ReadFrom(ReadOnlySpan`1<byte> span);
    internal abstract virtual void ReadPropertiesFrom(ContentHeaderPropertyReader& reader);
    internal abstract virtual void WritePropertiesTo(ContentHeaderPropertyWriter& writer);
    public abstract virtual int GetRequiredPayloadBufferSize();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class RabbitMQ.Client.Impl.ContentHeaderPropertyReader : ValueType {
    private static int StartBitMask;
    private static int EndBitMask;
    private ReadOnlySpan`1<byte> _span;
    private int _offset;
    private int _bitMask;
    private int _bits;
    private ReadOnlySpan`1<byte> Span { get; }
    private bool ContinuationBitSet { get; }
    public ContentHeaderPropertyReader(ReadOnlySpan`1<byte> span);
    private ReadOnlySpan`1<byte> get_Span();
    private bool get_ContinuationBitSet();
    public void FinishPresence();
    public bool ReadBit();
    private void ReadBits();
    public UInt32 ReadLong();
    public ulong ReadLonglong();
    public Byte[] ReadLongstr();
    public byte ReadOctet();
    public bool ReadPresence();
    public ushort ReadShort();
    public string ReadShortstr();
    public Dictionary`2<string, object> ReadTable();
    public AmqpTimestamp ReadTimestamp();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class RabbitMQ.Client.Impl.ContentHeaderPropertyWriter : ValueType {
    private static ushort StartBitMask;
    private static ushort EndBitMask;
    private Span`1<byte> _span;
    private int _offset;
    private ushort _bitAccumulator;
    private ushort _bitMask;
    public int Offset { get; }
    private Span`1<byte> Span { get; }
    public ContentHeaderPropertyWriter(Span`1<byte> span);
    public int get_Offset();
    private Span`1<byte> get_Span();
    public void FinishPresence();
    public void WriteBit(bool bit);
    public void WriteLong(UInt32 val);
    public void WriteLonglong(ulong val);
    public void WriteLongstr(Byte[] val);
    public void WriteOctet(byte val);
    public void WritePresence(bool present);
    public void WriteShort(ushort val);
    public void WriteShortstr(string val);
    public void WriteTable(IDictionary`2<string, object> val);
    public void WriteTimestamp(AmqpTimestamp val);
    private void WriteBits();
}
internal enum RabbitMQ.Client.Impl.FrameType : Enum {
    public int value__;
    public static FrameType FrameMethod;
    public static FrameType FrameHeader;
    public static FrameType FrameBody;
    public static FrameType FrameHeartbeat;
}
internal static class RabbitMQ.Client.Impl.Framing : object {
    private static int BaseFrameSize;
    private static int StartPayload;
    private static int WriteBaseFrame(Span`1<byte> span, FrameType type, ushort channel, int payloadLength);
}
internal interface RabbitMQ.Client.Impl.IConsumerDispatcher {
    public bool IsShutdown { get; }
    public abstract virtual bool get_IsShutdown();
    public abstract virtual void HandleBasicConsumeOk(IBasicConsumer consumer, string consumerTag);
    public abstract virtual void HandleBasicDeliver(IBasicConsumer consumer, string consumerTag, ulong deliveryTag, bool redelivered, string exchange, string routingKey, IBasicProperties basicProperties, ReadOnlySpan`1<byte> body);
    public abstract virtual void HandleBasicCancelOk(IBasicConsumer consumer, string consumerTag);
    public abstract virtual void HandleBasicCancel(IBasicConsumer consumer, string consumerTag);
    public abstract virtual void HandleModelShutdown(IBasicConsumer consumer, ShutdownEventArgs reason);
    public abstract virtual void Quiesce();
    public abstract virtual Task Shutdown(IModel model);
}
internal interface RabbitMQ.Client.Impl.IFrameHandler {
    public AmqpTcpEndpoint Endpoint { get; }
    public EndPoint LocalEndPoint { get; }
    public int LocalPort { get; }
    public EndPoint RemoteEndPoint { get; }
    public int RemotePort { get; }
    unknown TimeSpan ReadTimeout {public set; }
    unknown TimeSpan WriteTimeout {public set; }
    public abstract virtual AmqpTcpEndpoint get_Endpoint();
    public abstract virtual EndPoint get_LocalEndPoint();
    public abstract virtual int get_LocalPort();
    public abstract virtual EndPoint get_RemoteEndPoint();
    public abstract virtual int get_RemotePort();
    public abstract virtual void set_ReadTimeout(TimeSpan value);
    public abstract virtual void set_WriteTimeout(TimeSpan value);
    public abstract virtual void Close();
    public abstract virtual InboundFrame ReadFrame();
    public abstract virtual void SendHeader();
    public abstract virtual void Write(ReadOnlyMemory`1<byte> memory);
}
internal interface RabbitMQ.Client.Impl.IFullModel {
    public abstract virtual void ConnectionTuneOk(ushort channelMax, UInt32 frameMax, ushort heartbeat);
    public abstract virtual void HandleBasicAck(ulong deliveryTag, bool multiple);
    public abstract virtual void HandleBasicCancel(string consumerTag, bool nowait);
    public abstract virtual void HandleBasicCancelOk(string consumerTag);
    public abstract virtual void HandleBasicConsumeOk(string consumerTag);
    public abstract virtual void HandleBasicDeliver(string consumerTag, ulong deliveryTag, bool redelivered, string exchange, string routingKey, IBasicProperties basicProperties, ReadOnlyMemory`1<byte> body);
    public abstract virtual void HandleBasicGetEmpty();
    public abstract virtual void HandleBasicGetOk(ulong deliveryTag, bool redelivered, string exchange, string routingKey, UInt32 messageCount, IBasicProperties basicProperties, ReadOnlyMemory`1<byte> body);
    public abstract virtual void HandleBasicNack(ulong deliveryTag, bool multiple, bool requeue);
    public abstract virtual void HandleBasicRecoverOk();
    public abstract virtual void HandleBasicReturn(ushort replyCode, string replyText, string exchange, string routingKey, IBasicProperties basicProperties, ReadOnlyMemory`1<byte> body);
    public abstract virtual void HandleChannelClose(ushort replyCode, string replyText, ushort classId, ushort methodId);
    public abstract virtual void HandleChannelCloseOk();
    public abstract virtual void HandleChannelFlow(bool active);
    [AmqpMethodMappingAttribute("", "connection", "blocked")]
public abstract virtual void HandleConnectionBlocked(string reason);
    public abstract virtual void HandleConnectionClose(ushort replyCode, string replyText, ushort classId, ushort methodId);
    public abstract virtual void HandleConnectionOpenOk(string knownHosts);
    public abstract virtual void HandleConnectionSecure(Byte[] challenge);
    public abstract virtual void HandleConnectionStart(byte versionMajor, byte versionMinor, IDictionary`2<string, object> serverProperties, Byte[] mechanisms, Byte[] locales);
    public abstract virtual void HandleConnectionTune(ushort channelMax, UInt32 frameMax, ushort heartbeat);
    public abstract virtual void HandleConnectionUnblocked();
    public abstract virtual void HandleQueueDeclareOk(string queue, UInt32 messageCount, UInt32 consumerCount);
    [AmqpForceOneWayAttribute]
[AmqpMethodMappingAttribute("", "basic", "cancel")]
public abstract virtual void _Private_BasicCancel(string consumerTag, bool nowait);
    [AmqpForceOneWayAttribute]
[AmqpMethodMappingAttribute("", "basic", "consume")]
public abstract virtual void _Private_BasicConsume(string queue, string consumerTag, bool noLocal, bool autoAck, bool exclusive, bool nowait, IDictionary`2<string, object> arguments);
    [AmqpForceOneWayAttribute]
[AmqpMethodMappingAttribute("", "basic", "get")]
public abstract virtual void _Private_BasicGet(string queue, bool autoAck);
    [AmqpMethodMappingAttribute("", "basic", "publish")]
public abstract virtual void _Private_BasicPublish(string exchange, string routingKey, bool mandatory, IBasicProperties basicProperties, ReadOnlyMemory`1<byte> body);
    [AmqpForceOneWayAttribute]
[AmqpMethodMappingAttribute("", "basic", "recover")]
public abstract virtual void _Private_BasicRecover(bool requeue);
    [AmqpForceOneWayAttribute]
[AmqpMethodMappingAttribute("", "channel", "close")]
public abstract virtual void _Private_ChannelClose(ushort replyCode, string replyText, ushort classId, ushort methodId);
    [AmqpMethodMappingAttribute("", "channel", "close-ok")]
public abstract virtual void _Private_ChannelCloseOk();
    [AmqpMethodMappingAttribute("", "channel", "flow-ok")]
public abstract virtual void _Private_ChannelFlowOk(bool active);
    [AmqpMethodMappingAttribute("", "channel", "open")]
public abstract virtual void _Private_ChannelOpen(string outOfBand);
    [AmqpMethodMappingAttribute("", "confirm", "select")]
public abstract virtual void _Private_ConfirmSelect(bool nowait);
    [AmqpMethodMappingAttribute("", "connection", "close")]
public abstract virtual void _Private_ConnectionClose(ushort replyCode, string replyText, ushort classId, ushort methodId);
    [AmqpMethodMappingAttribute("", "connection", "close-ok")]
public abstract virtual void _Private_ConnectionCloseOk();
    [AmqpForceOneWayAttribute]
[AmqpMethodMappingAttribute("", "connection", "open")]
public abstract virtual void _Private_ConnectionOpen(string virtualHost, string capabilities, bool insist);
    [AmqpForceOneWayAttribute]
[AmqpMethodMappingAttribute("", "connection", "secure-ok")]
public abstract virtual void _Private_ConnectionSecureOk(Byte[] response);
    [AmqpForceOneWayAttribute]
[AmqpMethodMappingAttribute("", "connection", "start-ok")]
public abstract virtual void _Private_ConnectionStartOk(IDictionary`2<string, object> clientProperties, string mechanism, Byte[] response, string locale);
    [AmqpMethodMappingAttribute("", "connection", "update-secret")]
public abstract virtual void _Private_UpdateSecret(Byte[] newSecret, string reason);
    [AmqpMethodMappingAttribute("", "exchange", "bind")]
public abstract virtual void _Private_ExchangeBind(string destination, string source, string routingKey, bool nowait, IDictionary`2<string, object> arguments);
    [AmqpMethodMappingAttribute("", "exchange", "declare")]
public abstract virtual void _Private_ExchangeDeclare(string exchange, string type, bool passive, bool durable, bool autoDelete, bool internal, bool nowait, IDictionary`2<string, object> arguments);
    [AmqpMethodMappingAttribute("", "exchange", "delete")]
public abstract virtual void _Private_ExchangeDelete(string exchange, bool ifUnused, bool nowait);
    [AmqpMethodMappingAttribute("", "exchange", "unbind")]
public abstract virtual void _Private_ExchangeUnbind(string destination, string source, string routingKey, bool nowait, IDictionary`2<string, object> arguments);
    [AmqpMethodMappingAttribute("", "queue", "bind")]
public abstract virtual void _Private_QueueBind(string queue, string exchange, string routingKey, bool nowait, IDictionary`2<string, object> arguments);
    [AmqpMethodMappingAttribute("", "queue", "declare")]
[AmqpForceOneWayAttribute]
public abstract virtual void _Private_QueueDeclare(string queue, bool passive, bool durable, bool exclusive, bool autoDelete, bool nowait, IDictionary`2<string, object> arguments);
    [AmqpMethodMappingAttribute("", "queue", "delete")]
public abstract virtual UInt32 _Private_QueueDelete(string queue, bool ifUnused, bool ifEmpty, bool nowait);
    [AmqpMethodMappingAttribute("", "queue", "purge")]
public abstract virtual UInt32 _Private_QueuePurge(string queue, bool nowait);
}
[IsReadOnlyAttribute]
internal class RabbitMQ.Client.Impl.InboundFrame : ValueType {
    public FrameType Type;
    public int Channel;
    public ReadOnlyMemory`1<byte> Payload;
    private Byte[] _rentedArray;
    private ArrayPool`1<byte> _rentedArrayOwner;
    private InboundFrame(FrameType type, int channel, ReadOnlyMemory`1<byte> payload, Byte[] rentedArray, ArrayPool`1<byte> rentedArrayOwner);
    private static void ProcessProtocolHeader(Stream reader);
    internal static InboundFrame ReadFrom(Stream reader, Byte[] frameHeaderBuffer, ArrayPool`1<byte> pool, UInt32 maxMessageSize);
    public sealed virtual void Dispose();
    public virtual string ToString();
}
[IsReadOnlyAttribute]
internal class RabbitMQ.Client.Impl.IncomingCommand : ValueType {
    public static IncomingCommand Empty;
    public MethodBase Method;
    public ContentHeaderBase Header;
    public ReadOnlyMemory`1<byte> Body;
    private Byte[] _rentedArray;
    private ArrayPool`1<byte> _rentedArrayOwner;
    public bool IsEmpty { get; }
    public IncomingCommand(MethodBase method, ContentHeaderBase header, ReadOnlyMemory`1<byte> body, Byte[] rentedArray, ArrayPool`1<byte> rentedArrayOwner);
    private static IncomingCommand();
    public bool get_IsEmpty();
    public sealed virtual void Dispose();
    public virtual string ToString();
}
internal interface RabbitMQ.Client.Impl.IRpcContinuation {
    public abstract virtual void HandleCommand(IncomingCommand& modreq(System.Runtime.InteropServices.InAttribute) cmd);
    public abstract virtual void HandleModelShutdown(ShutdownEventArgs reason);
}
internal interface RabbitMQ.Client.Impl.ISession {
    public ushort ChannelNumber { get; }
    public ShutdownEventArgs CloseReason { get; }
    public CommandReceivedAction CommandReceived { get; public set; }
    public Connection Connection { get; }
    public bool IsOpen { get; }
    public abstract virtual ushort get_ChannelNumber();
    public abstract virtual ShutdownEventArgs get_CloseReason();
    public abstract virtual CommandReceivedAction get_CommandReceived();
    public abstract virtual void set_CommandReceived(CommandReceivedAction value);
    public abstract virtual Connection get_Connection();
    public abstract virtual bool get_IsOpen();
    [CompilerGeneratedAttribute]
public abstract virtual void add_SessionShutdown(EventHandler`1<ShutdownEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SessionShutdown(EventHandler`1<ShutdownEventArgs> value);
    public abstract virtual void Close(ShutdownEventArgs reason);
    public abstract virtual void Close(ShutdownEventArgs reason, bool notify);
    public abstract virtual void HandleFrame(InboundFrame& modreq(System.Runtime.InteropServices.InAttribute) frame);
    public abstract virtual void Notify();
    public abstract virtual void Transmit(OutgoingCommand& modreq(System.Runtime.InteropServices.InAttribute) cmd);
    public abstract virtual void Transmit(IList`1<OutgoingCommand> cmds);
}
internal class RabbitMQ.Client.Impl.MainSession : Session {
    private object _closingLock;
    private ushort _closeClassId;
    private ushort _closeMethodId;
    private ushort _closeOkClassId;
    private ushort _closeOkMethodId;
    private bool _closeServerInitiated;
    private bool _closing;
    [CompilerGeneratedAttribute]
private Action <Handler>k__BackingField;
    public Action Handler { get; public set; }
    public MainSession(Connection connection);
    [CompilerGeneratedAttribute]
public Action get_Handler();
    [CompilerGeneratedAttribute]
public void set_Handler(Action value);
    public virtual void HandleFrame(InboundFrame& modreq(System.Runtime.InteropServices.InAttribute) frame);
    public void SetSessionClosing(bool closeServerInitiated);
    public virtual void Transmit(OutgoingCommand& modreq(System.Runtime.InteropServices.InAttribute) cmd);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class RabbitMQ.Client.Impl.MethodArgumentReader : ValueType {
    private ReadOnlySpan`1<byte> _span;
    private int _offset;
    private int _bitMask;
    private int _bits;
    private ReadOnlySpan`1<byte> Span { get; }
    public MethodArgumentReader(ReadOnlySpan`1<byte> span);
    private ReadOnlySpan`1<byte> get_Span();
    public bool ReadBit();
    public Byte[] ReadContent();
    public UInt32 ReadLong();
    public ulong ReadLonglong();
    public Byte[] ReadLongstr();
    public byte ReadOctet();
    public ushort ReadShort();
    public string ReadShortstr();
    public Dictionary`2<string, object> ReadTable();
    public AmqpTimestamp ReadTimestamp();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class RabbitMQ.Client.Impl.MethodArgumentWriter : ValueType {
    private Span`1<byte> _span;
    private int _offset;
    private int _bitAccumulator;
    private int _bitMask;
    public int Offset { get; }
    private Span`1<byte> Span { get; }
    public MethodArgumentWriter(Span`1<byte> span);
    public int get_Offset();
    private Span`1<byte> get_Span();
    public void WriteBit(bool val);
    public void EndBits();
    public void WriteContent(Byte[] val);
    public void WriteLong(UInt32 val);
    public void WriteLonglong(ulong val);
    public void WriteLongstr(Byte[] val);
    public void WriteOctet(byte val);
    public void WriteShort(ushort val);
    public void WriteShortstr(string val);
    public void WriteTable(IDictionary val);
    public void WriteTable(IDictionary`2<string, object> val);
    public void WriteTimestamp(AmqpTimestamp val);
}
internal abstract class RabbitMQ.Client.Impl.MethodBase : object {
    public bool HasContent { get; }
    public ushort ProtocolClassId { get; }
    public ushort ProtocolMethodId { get; }
    public string ProtocolMethodName { get; }
    public abstract virtual bool get_HasContent();
    public abstract virtual ushort get_ProtocolClassId();
    public abstract virtual ushort get_ProtocolMethodId();
    public abstract virtual string get_ProtocolMethodName();
    public abstract virtual void AppendArgumentDebugStringTo(StringBuilder stringBuilder);
    public abstract virtual void ReadArgumentsFrom(MethodArgumentReader& reader);
    public abstract virtual void WriteArgumentsTo(MethodArgumentWriter& writer);
    public abstract virtual int GetRequiredBufferSize();
}
internal abstract class RabbitMQ.Client.Impl.ModelBase : object {
    internal BlockingCell`1<ConnectionStartDetails> m_connectionStartCell;
    private Exception m_connectionStartException;
    internal IBasicProperties _emptyBasicProperties;
    private Dictionary`2<string, IBasicConsumer> _consumers;
    private TimeSpan _handshakeContinuationTimeout;
    private TimeSpan _continuationTimeout;
    private RpcContinuationQueue _continuationQueue;
    private ManualResetEventSlim _flowControlBlock;
    private object _shutdownLock;
    private object _rpcLock;
    private object _confirmLock;
    private LinkedList`1<ulong> _pendingDeliveryTags;
    private CountdownEvent _deliveryTagsCountdown;
    private EventHandler`1<ShutdownEventArgs> _modelShutdown;
    private bool _onlyAcksReceived;
    [CompilerGeneratedAttribute]
private IConsumerDispatcher <ConsumerDispatcher>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<BasicAckEventArgs> BasicAcks;
    [CompilerGeneratedAttribute]
private EventHandler`1<BasicNackEventArgs> BasicNacks;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> BasicRecoverOk;
    [CompilerGeneratedAttribute]
private EventHandler`1<BasicReturnEventArgs> BasicReturn;
    [CompilerGeneratedAttribute]
private EventHandler`1<CallbackExceptionEventArgs> CallbackException;
    [CompilerGeneratedAttribute]
private EventHandler`1<FlowControlEventArgs> FlowControl;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> Recovery;
    [CompilerGeneratedAttribute]
private ShutdownEventArgs <CloseReason>k__BackingField;
    [CompilerGeneratedAttribute]
private IBasicConsumer <DefaultConsumer>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <NextPublishSeqNo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentQueue>k__BackingField;
    [CompilerGeneratedAttribute]
private ISession <Session>k__BackingField;
    public IConsumerDispatcher ConsumerDispatcher { get; }
    public TimeSpan HandshakeContinuationTimeout { get; public set; }
    public TimeSpan ContinuationTimeout { get; public set; }
    public int ChannelNumber { get; }
    public ShutdownEventArgs CloseReason { get; private set; }
    public IBasicConsumer DefaultConsumer { get; public set; }
    public bool IsClosed { get; }
    public bool IsOpen { get; }
    public ulong NextPublishSeqNo { get; private set; }
    public string CurrentQueue { get; private set; }
    public ISession Session { get; private set; }
    public Exception ConnectionStartException { get; }
    public ModelBase(ISession session);
    public ModelBase(ISession session, ConsumerWorkService workService);
    [CompilerGeneratedAttribute]
public IConsumerDispatcher get_ConsumerDispatcher();
    protected void Initialise(ISession session);
    public TimeSpan get_HandshakeContinuationTimeout();
    public void set_HandshakeContinuationTimeout(TimeSpan value);
    public sealed virtual TimeSpan get_ContinuationTimeout();
    public sealed virtual void set_ContinuationTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BasicAcks(EventHandler`1<BasicAckEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BasicAcks(EventHandler`1<BasicAckEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BasicNacks(EventHandler`1<BasicNackEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BasicNacks(EventHandler`1<BasicNackEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BasicRecoverOk(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BasicRecoverOk(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BasicReturn(EventHandler`1<BasicReturnEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BasicReturn(EventHandler`1<BasicReturnEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CallbackException(EventHandler`1<CallbackExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CallbackException(EventHandler`1<CallbackExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_FlowControl(EventHandler`1<FlowControlEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_FlowControl(EventHandler`1<FlowControlEventArgs> value);
    public sealed virtual void add_ModelShutdown(EventHandler`1<ShutdownEventArgs> value);
    public sealed virtual void remove_ModelShutdown(EventHandler`1<ShutdownEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Recovery(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Recovery(EventHandler`1<EventArgs> value);
    public sealed virtual int get_ChannelNumber();
    [CompilerGeneratedAttribute]
public sealed virtual ShutdownEventArgs get_CloseReason();
    [CompilerGeneratedAttribute]
private void set_CloseReason(ShutdownEventArgs value);
    [CompilerGeneratedAttribute]
public sealed virtual IBasicConsumer get_DefaultConsumer();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DefaultConsumer(IBasicConsumer value);
    public sealed virtual bool get_IsClosed();
    public sealed virtual bool get_IsOpen();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_NextPublishSeqNo();
    [CompilerGeneratedAttribute]
private void set_NextPublishSeqNo(ulong value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_CurrentQueue();
    [CompilerGeneratedAttribute]
private void set_CurrentQueue(string value);
    [CompilerGeneratedAttribute]
public ISession get_Session();
    [CompilerGeneratedAttribute]
private void set_Session(ISession value);
    public Exception get_ConnectionStartException();
    public void MaybeSetConnectionStartException(Exception ex);
    public Task Close(ushort replyCode, string replyText, bool abort);
    [AsyncStateMachineAttribute("RabbitMQ.Client.Impl.ModelBase/<Close>d__81")]
public Task Close(ShutdownEventArgs reason, bool abort);
    public string ConnectionOpen(string virtualHost, string capabilities, bool insist);
    public ConnectionSecureOrTune ConnectionSecureOk(Byte[] response);
    public ConnectionSecureOrTune ConnectionStartOk(IDictionary`2<string, object> clientProperties, string mechanism, Byte[] response, string locale);
    public abstract virtual bool DispatchAsynchronous(IncomingCommand& modreq(System.Runtime.InteropServices.InAttribute) cmd);
    public void Enqueue(IRpcContinuation k);
    public void FinishClose();
    public void HandleCommand(IncomingCommand& cmd);
    public MethodBase ModelRpc(MethodBase method, ContentHeaderBase header, Byte[] body);
    public void ModelSend(MethodBase method, ContentHeaderBase header, ReadOnlyMemory`1<byte> body);
    public virtual void OnBasicRecoverOk(EventArgs args);
    public virtual void OnBasicReturn(BasicReturnEventArgs args);
    public virtual void OnCallbackException(CallbackExceptionEventArgs args);
    public virtual void OnFlowControl(FlowControlEventArgs args);
    public virtual void OnModelShutdown(ShutdownEventArgs reason);
    public void OnSessionShutdown(object sender, ShutdownEventArgs reason);
    protected void BroadcastShutdownToConsumers(Dictionary`2<string, IBasicConsumer> cs, ShutdownEventArgs reason);
    public bool SetCloseReason(ShutdownEventArgs reason);
    public virtual string ToString();
    public void TransmitAndEnqueue(OutgoingCommand& cmd, IRpcContinuation k);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    public abstract virtual void ConnectionTuneOk(ushort channelMax, UInt32 frameMax, ushort heartbeat);
    public sealed virtual void HandleBasicAck(ulong deliveryTag, bool multiple);
    public sealed virtual void HandleBasicNack(ulong deliveryTag, bool multiple, bool requeue);
    protected void HandleAckNack(ulong deliveryTag, bool multiple, bool isNack);
    public sealed virtual void HandleBasicCancel(string consumerTag, bool nowait);
    public sealed virtual void HandleBasicCancelOk(string consumerTag);
    public sealed virtual void HandleBasicConsumeOk(string consumerTag);
    public virtual void HandleBasicDeliver(string consumerTag, ulong deliveryTag, bool redelivered, string exchange, string routingKey, IBasicProperties basicProperties, ReadOnlyMemory`1<byte> body);
    public sealed virtual void HandleBasicGetEmpty();
    public virtual void HandleBasicGetOk(ulong deliveryTag, bool redelivered, string exchange, string routingKey, UInt32 messageCount, IBasicProperties basicProperties, ReadOnlyMemory`1<byte> body);
    public sealed virtual void HandleBasicRecoverOk();
    public sealed virtual void HandleBasicReturn(ushort replyCode, string replyText, string exchange, string routingKey, IBasicProperties basicProperties, ReadOnlyMemory`1<byte> body);
    public sealed virtual void HandleChannelClose(ushort replyCode, string replyText, ushort classId, ushort methodId);
    public sealed virtual void HandleChannelCloseOk();
    public sealed virtual void HandleChannelFlow(bool active);
    public sealed virtual void HandleConnectionBlocked(string reason);
    public sealed virtual void HandleConnectionClose(ushort replyCode, string replyText, ushort classId, ushort methodId);
    public sealed virtual void HandleConnectionOpenOk(string knownHosts);
    public sealed virtual void HandleConnectionSecure(Byte[] challenge);
    public sealed virtual void HandleConnectionStart(byte versionMajor, byte versionMinor, IDictionary`2<string, object> serverProperties, Byte[] mechanisms, Byte[] locales);
    public sealed virtual void HandleConnectionTune(ushort channelMax, UInt32 frameMax, ushort heartbeatInSeconds);
    public sealed virtual void HandleConnectionUnblocked();
    public sealed virtual void HandleQueueDeclareOk(string queue, UInt32 messageCount, UInt32 consumerCount);
    public abstract virtual void _Private_BasicCancel(string consumerTag, bool nowait);
    public abstract virtual void _Private_BasicConsume(string queue, string consumerTag, bool noLocal, bool autoAck, bool exclusive, bool nowait, IDictionary`2<string, object> arguments);
    public abstract virtual void _Private_BasicGet(string queue, bool autoAck);
    public abstract virtual void _Private_BasicPublish(string exchange, string routingKey, bool mandatory, IBasicProperties basicProperties, ReadOnlyMemory`1<byte> body);
    public abstract virtual void _Private_BasicRecover(bool requeue);
    public abstract virtual void _Private_ChannelClose(ushort replyCode, string replyText, ushort classId, ushort methodId);
    public abstract virtual void _Private_ChannelCloseOk();
    public abstract virtual void _Private_ChannelFlowOk(bool active);
    public abstract virtual void _Private_ChannelOpen(string outOfBand);
    public abstract virtual void _Private_ConfirmSelect(bool nowait);
    public abstract virtual void _Private_ConnectionClose(ushort replyCode, string replyText, ushort classId, ushort methodId);
    public abstract virtual void _Private_ConnectionCloseOk();
    public abstract virtual void _Private_ConnectionOpen(string virtualHost, string capabilities, bool insist);
    public abstract virtual void _Private_ConnectionSecureOk(Byte[] response);
    public abstract virtual void _Private_ConnectionStartOk(IDictionary`2<string, object> clientProperties, string mechanism, Byte[] response, string locale);
    public abstract virtual void _Private_UpdateSecret(Byte[] newSecret, string reason);
    public abstract virtual void _Private_ExchangeBind(string destination, string source, string routingKey, bool nowait, IDictionary`2<string, object> arguments);
    public abstract virtual void _Private_ExchangeDeclare(string exchange, string type, bool passive, bool durable, bool autoDelete, bool internal, bool nowait, IDictionary`2<string, object> arguments);
    public abstract virtual void _Private_ExchangeDelete(string exchange, bool ifUnused, bool nowait);
    public abstract virtual void _Private_ExchangeUnbind(string destination, string source, string routingKey, bool nowait, IDictionary`2<string, object> arguments);
    public abstract virtual void _Private_QueueBind(string queue, string exchange, string routingKey, bool nowait, IDictionary`2<string, object> arguments);
    public abstract virtual void _Private_QueueDeclare(string queue, bool passive, bool durable, bool exclusive, bool autoDelete, bool nowait, IDictionary`2<string, object> arguments);
    public abstract virtual UInt32 _Private_QueueDelete(string queue, bool ifUnused, bool ifEmpty, bool nowait);
    public abstract virtual UInt32 _Private_QueuePurge(string queue, bool nowait);
    public sealed virtual void Abort();
    public sealed virtual void Abort(ushort replyCode, string replyText);
    public abstract virtual void BasicAck(ulong deliveryTag, bool multiple);
    public sealed virtual void BasicCancel(string consumerTag);
    public sealed virtual void BasicCancelNoWait(string consumerTag);
    public sealed virtual string BasicConsume(string queue, bool autoAck, string consumerTag, bool noLocal, bool exclusive, IDictionary`2<string, object> arguments, IBasicConsumer consumer);
    public sealed virtual BasicGetResult BasicGet(string queue, bool autoAck);
    public abstract virtual void BasicNack(ulong deliveryTag, bool multiple, bool requeue);
    internal void AllocatePublishSeqNos(int count);
    public sealed virtual void BasicPublish(string exchange, string routingKey, bool mandatory, IBasicProperties basicProperties, ReadOnlyMemory`1<byte> body);
    public void UpdateSecret(string newSecret, string reason);
    public abstract virtual void BasicQos(UInt32 prefetchSize, ushort prefetchCount, bool global);
    public sealed virtual void BasicRecover(bool requeue);
    public abstract virtual void BasicRecoverAsync(bool requeue);
    public abstract virtual void BasicReject(ulong deliveryTag, bool requeue);
    public sealed virtual void Close();
    public sealed virtual void Close(ushort replyCode, string replyText);
    public sealed virtual void ConfirmSelect();
    public abstract virtual IBasicProperties CreateBasicProperties();
    public sealed virtual IBasicPublishBatch CreateBasicPublishBatch();
    public sealed virtual void ExchangeBind(string destination, string source, string routingKey, IDictionary`2<string, object> arguments);
    public sealed virtual void ExchangeBindNoWait(string destination, string source, string routingKey, IDictionary`2<string, object> arguments);
    public sealed virtual void ExchangeDeclare(string exchange, string type, bool durable, bool autoDelete, IDictionary`2<string, object> arguments);
    public sealed virtual void ExchangeDeclareNoWait(string exchange, string type, bool durable, bool autoDelete, IDictionary`2<string, object> arguments);
    public sealed virtual void ExchangeDeclarePassive(string exchange);
    public sealed virtual void ExchangeDelete(string exchange, bool ifUnused);
    public sealed virtual void ExchangeDeleteNoWait(string exchange, bool ifUnused);
    public sealed virtual void ExchangeUnbind(string destination, string source, string routingKey, IDictionary`2<string, object> arguments);
    public sealed virtual void ExchangeUnbindNoWait(string destination, string source, string routingKey, IDictionary`2<string, object> arguments);
    public sealed virtual void QueueBind(string queue, string exchange, string routingKey, IDictionary`2<string, object> arguments);
    public sealed virtual void QueueBindNoWait(string queue, string exchange, string routingKey, IDictionary`2<string, object> arguments);
    public sealed virtual QueueDeclareOk QueueDeclare(string queue, bool durable, bool exclusive, bool autoDelete, IDictionary`2<string, object> arguments);
    public sealed virtual void QueueDeclareNoWait(string queue, bool durable, bool exclusive, bool autoDelete, IDictionary`2<string, object> arguments);
    public sealed virtual QueueDeclareOk QueueDeclarePassive(string queue);
    public sealed virtual UInt32 MessageCount(string queue);
    public sealed virtual UInt32 ConsumerCount(string queue);
    public sealed virtual UInt32 QueueDelete(string queue, bool ifUnused, bool ifEmpty);
    public sealed virtual void QueueDeleteNoWait(string queue, bool ifUnused, bool ifEmpty);
    public sealed virtual UInt32 QueuePurge(string queue);
    public abstract virtual void QueueUnbind(string queue, string exchange, string routingKey, IDictionary`2<string, object> arguments);
    public abstract virtual void TxCommit();
    public abstract virtual void TxRollback();
    public abstract virtual void TxSelect();
    public sealed virtual bool WaitForConfirms(TimeSpan timeout, Boolean& timedOut);
    public sealed virtual bool WaitForConfirms();
    public sealed virtual bool WaitForConfirms(TimeSpan timeout);
    public sealed virtual void WaitForConfirmsOrDie();
    public sealed virtual void WaitForConfirmsOrDie(TimeSpan timeout);
    internal void SendCommands(IList`1<OutgoingCommand> commands);
    private QueueDeclareOk QueueDeclare(string queue, bool passive, bool durable, bool exclusive, bool autoDelete, IDictionary`2<string, object> arguments);
}
internal class RabbitMQ.Client.Impl.ModelShutdown : Work {
    private ShutdownEventArgs _reason;
    private IModel _model;
    public string Context { get; }
    public ModelShutdown(IBasicConsumer consumer, ShutdownEventArgs reason, IModel model);
    public virtual string get_Context();
    protected virtual Task Execute(IAsyncBasicConsumer consumer);
}
[IsReadOnlyAttribute]
internal class RabbitMQ.Client.Impl.OutgoingCommand : ValueType {
    private static int EmptyFrameSize;
    public MethodBase Method;
    private ContentHeaderBase Header;
    private ReadOnlyMemory`1<byte> Body;
    public OutgoingCommand(MethodBase method);
    public OutgoingCommand(MethodBase method, ContentHeaderBase header, ReadOnlyMemory`1<byte> body);
    internal void Transmit(ushort channelNumber, Connection connection);
    private int GetMaxSize(int maxPayloadBytes);
    private int GetBodyFrameCount(int maxPayloadBytes);
}
internal class RabbitMQ.Client.Impl.QuiescingSession : SessionBase {
    public ShutdownEventArgs m_reason;
    public QuiescingSession(Connection connection, ushort channelNumber, ShutdownEventArgs reason);
    public virtual void HandleFrame(InboundFrame& modreq(System.Runtime.InteropServices.InAttribute) frame);
    protected OutgoingCommand CreateChannelCloseOk();
}
internal abstract class RabbitMQ.Client.Impl.RecordedBinding : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RoutingKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    public IDictionary`2<string, object> Arguments { get; protected set; }
    public string Destination { get; public set; }
    public string RoutingKey { get; protected set; }
    public string Source { get; protected set; }
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, object> get_Arguments();
    [CompilerGeneratedAttribute]
protected void set_Arguments(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Destination();
    [CompilerGeneratedAttribute]
public void set_Destination(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RoutingKey();
    [CompilerGeneratedAttribute]
protected void set_RoutingKey(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Source();
    [CompilerGeneratedAttribute]
protected void set_Source(string value);
    public bool Equals(RecordedBinding other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual void Recover(IModel model);
    public virtual string ToString();
    public RecordedBinding WithArguments(IDictionary`2<string, object> value);
    public RecordedBinding WithDestination(string value);
    public RecordedBinding WithRoutingKey(string value);
    public RecordedBinding WithSource(string value);
}
internal class RabbitMQ.Client.Impl.RecordedConsumer : object {
    private AutorecoveringModel _model;
    [CompilerGeneratedAttribute]
private string <Queue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConsumerTag>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoAck>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Exclusive>k__BackingField;
    [CompilerGeneratedAttribute]
private IBasicConsumer <Consumer>k__BackingField;
    public AutorecoveringModel Model { get; }
    public string Queue { get; public set; }
    public string ConsumerTag { get; public set; }
    public IDictionary`2<string, object> Arguments { get; public set; }
    public bool AutoAck { get; public set; }
    public bool Exclusive { get; public set; }
    public IBasicConsumer Consumer { get; public set; }
    public RecordedConsumer(AutorecoveringModel model, string queue, string consumerTag);
    public AutorecoveringModel get_Model();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Queue();
    [CompilerGeneratedAttribute]
public void set_Queue(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ConsumerTag();
    [CompilerGeneratedAttribute]
public void set_ConsumerTag(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, object> get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AutoAck();
    [CompilerGeneratedAttribute]
public void set_AutoAck(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Exclusive();
    [CompilerGeneratedAttribute]
public void set_Exclusive(bool value);
    [CompilerGeneratedAttribute]
public IBasicConsumer get_Consumer();
    [CompilerGeneratedAttribute]
public void set_Consumer(IBasicConsumer value);
    public string Recover(IModel channelToUse);
    public RecordedConsumer WithArguments(IDictionary`2<string, object> value);
    public RecordedConsumer WithAutoAck(bool value);
    public RecordedConsumer WithConsumer(IBasicConsumer value);
    public RecordedConsumer WithExclusive(bool value);
}
internal class RabbitMQ.Client.Impl.RecordedExchange : RecordedNamedEntity {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Durable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoDelete>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    public IDictionary`2<string, object> Arguments { get; private set; }
    public bool Durable { get; private set; }
    public bool AutoDelete { get; private set; }
    public string Type { get; private set; }
    public RecordedExchange(string name);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, object> get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Durable();
    [CompilerGeneratedAttribute]
private void set_Durable(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AutoDelete();
    [CompilerGeneratedAttribute]
private void set_AutoDelete(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(string value);
    public void Recover(IModel model);
    public virtual string ToString();
    public RecordedExchange WithArguments(IDictionary`2<string, object> value);
    public RecordedExchange WithAutoDelete(bool value);
    public RecordedExchange WithDurable(bool value);
    public RecordedExchange WithType(string value);
}
internal class RabbitMQ.Client.Impl.RecordedExchangeBinding : RecordedBinding {
    public virtual void Recover(IModel model);
}
internal class RabbitMQ.Client.Impl.RecordedNamedEntity : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; protected set; }
    public RecordedNamedEntity(string name);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
protected void set_Name(string value);
}
internal class RabbitMQ.Client.Impl.RecordedQueue : RecordedNamedEntity {
    [CompilerGeneratedAttribute]
private bool <Durable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Exclusive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoDelete>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsServerNamed>k__BackingField;
    public bool Durable { get; private set; }
    public bool Exclusive { get; private set; }
    public bool AutoDelete { get; private set; }
    public IDictionary`2<string, object> Arguments { get; private set; }
    public bool IsServerNamed { get; private set; }
    protected string NameToUseForRecovery { get; }
    public RecordedQueue(string name);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Durable();
    [CompilerGeneratedAttribute]
private void set_Durable(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Exclusive();
    [CompilerGeneratedAttribute]
private void set_Exclusive(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AutoDelete();
    [CompilerGeneratedAttribute]
private void set_AutoDelete(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, object> get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsServerNamed();
    [CompilerGeneratedAttribute]
private void set_IsServerNamed(bool value);
    protected string get_NameToUseForRecovery();
    public RecordedQueue WithArguments(IDictionary`2<string, object> value);
    public RecordedQueue WithAutoDelete(bool value);
    public RecordedQueue WithDurable(bool value);
    public RecordedQueue WithExclusive(bool value);
    public void Recover(IModel model);
    public RecordedQueue WithServerNamed(bool value);
    public virtual string ToString();
}
internal class RabbitMQ.Client.Impl.RecordedQueueBinding : RecordedBinding {
    public virtual void Recover(IModel model);
}
internal class RabbitMQ.Client.Impl.RecoveryAwareModel : Model {
    [CompilerGeneratedAttribute]
private ulong <ActiveDeliveryTagOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <MaxSeenDeliveryTag>k__BackingField;
    public ulong ActiveDeliveryTagOffset { get; private set; }
    public ulong MaxSeenDeliveryTag { get; private set; }
    public RecoveryAwareModel(ISession session);
    [CompilerGeneratedAttribute]
public ulong get_ActiveDeliveryTagOffset();
    [CompilerGeneratedAttribute]
private void set_ActiveDeliveryTagOffset(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_MaxSeenDeliveryTag();
    [CompilerGeneratedAttribute]
private void set_MaxSeenDeliveryTag(ulong value);
    public void InheritOffsetFrom(RecoveryAwareModel other);
    public virtual void HandleBasicGetOk(ulong deliveryTag, bool redelivered, string exchange, string routingKey, UInt32 messageCount, IBasicProperties basicProperties, ReadOnlyMemory`1<byte> body);
    public virtual void HandleBasicDeliver(string consumerTag, ulong deliveryTag, bool redelivered, string exchange, string routingKey, IBasicProperties basicProperties, ReadOnlyMemory`1<byte> body);
    public virtual void BasicAck(ulong deliveryTag, bool multiple);
    public virtual void BasicNack(ulong deliveryTag, bool multiple, bool requeue);
    public virtual void BasicReject(ulong deliveryTag, bool requeue);
    protected ulong OffsetDeliveryTag(ulong deliveryTag);
}
internal class RabbitMQ.Client.Impl.RpcContinuationQueue : object {
    private static EmptyRpcContinuation s_tmp;
    private IRpcContinuation _outstandingRpc;
    private static RpcContinuationQueue();
    public void Enqueue(IRpcContinuation k);
    public void HandleModelShutdown(ShutdownEventArgs reason);
    public IRpcContinuation Next();
}
internal class RabbitMQ.Client.Impl.Session : SessionBase {
    private CommandAssembler _assembler;
    public Session(Connection connection, ushort channelNumber);
    public virtual void HandleFrame(InboundFrame& modreq(System.Runtime.InteropServices.InAttribute) frame);
}
internal abstract class RabbitMQ.Client.Impl.SessionBase : object {
    private object _shutdownLock;
    private EventHandler`1<ShutdownEventArgs> _sessionShutdown;
    [CompilerGeneratedAttribute]
private ushort <ChannelNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private ShutdownEventArgs <CloseReason>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandReceivedAction <CommandReceived>k__BackingField;
    [CompilerGeneratedAttribute]
private Connection <Connection>k__BackingField;
    public ushort ChannelNumber { get; }
    public ShutdownEventArgs CloseReason { get; public set; }
    public CommandReceivedAction CommandReceived { get; public set; }
    public Connection Connection { get; private set; }
    public bool IsOpen { get; }
    protected SessionBase(Connection connection, ushort channelNumber);
    public sealed virtual void add_SessionShutdown(EventHandler`1<ShutdownEventArgs> value);
    public sealed virtual void remove_SessionShutdown(EventHandler`1<ShutdownEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual ushort get_ChannelNumber();
    [CompilerGeneratedAttribute]
public sealed virtual ShutdownEventArgs get_CloseReason();
    [CompilerGeneratedAttribute]
public void set_CloseReason(ShutdownEventArgs value);
    [CompilerGeneratedAttribute]
public sealed virtual CommandReceivedAction get_CommandReceived();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CommandReceived(CommandReceivedAction value);
    [CompilerGeneratedAttribute]
public sealed virtual Connection get_Connection();
    [CompilerGeneratedAttribute]
private void set_Connection(Connection value);
    public sealed virtual bool get_IsOpen();
    public virtual void OnConnectionShutdown(object conn, ShutdownEventArgs reason);
    public virtual void OnSessionShutdown(ShutdownEventArgs reason);
    public virtual string ToString();
    public sealed virtual void Close(ShutdownEventArgs reason);
    public sealed virtual void Close(ShutdownEventArgs reason, bool notify);
    public abstract virtual void HandleFrame(InboundFrame& modreq(System.Runtime.InteropServices.InAttribute) frame);
    public sealed virtual void Notify();
    public virtual void Transmit(OutgoingCommand& modreq(System.Runtime.InteropServices.InAttribute) cmd);
    public virtual void Transmit(IList`1<OutgoingCommand> cmds);
}
internal class RabbitMQ.Client.Impl.SessionManager : object {
    public ushort ChannelMax;
    private IntAllocator _ints;
    private Connection _connection;
    private Dictionary`2<int, ISession> _sessionMap;
    private bool _autoClose;
    [ObsoleteAttribute("Please explicitly close connections instead.")]
public bool AutoClose { get; public set; }
    public int Count { get; }
    public SessionManager(Connection connection, ushort channelMax);
    public bool get_AutoClose();
    public void set_AutoClose(bool value);
    public int get_Count();
    public void AutoCloseConnection();
    public void CheckAutoClose();
    public ISession Create();
    public ISession Create(int channelNumber);
    public ISession CreateInternal(int channelNumber);
    public void HandleSessionShutdown(object sender, ShutdownEventArgs reason);
    public ISession Lookup(int number);
    public ISession Swap(int channelNumber, ISession replacement);
}
internal class RabbitMQ.Client.Impl.ShutdownContinuation : object {
    public BlockingCell`1<ShutdownEventArgs> m_cell;
    public virtual void OnConnectionShutdown(object sender, ShutdownEventArgs reason);
    public virtual void OnModelShutdown(IModel sender, ShutdownEventArgs reason);
    public virtual ShutdownEventArgs Wait();
    public ShutdownEventArgs Wait(TimeSpan timeout);
}
internal class RabbitMQ.Client.Impl.SimpleBlockingRpcContinuation : object {
    public BlockingCell`1<Either`2<IncomingCommand, ShutdownEventArgs>> m_cell;
    public virtual IncomingCommand GetReply();
    public virtual IncomingCommand GetReply(TimeSpan timeout);
    public virtual void HandleCommand(IncomingCommand& modreq(System.Runtime.InteropServices.InAttribute) cmd);
    public virtual void HandleModelShutdown(ShutdownEventArgs reason);
}
internal class RabbitMQ.Client.Impl.SocketFrameHandler : object {
    private AmqpTcpEndpoint _endpoint;
    private TimeSpan _writeableStateTimeout;
    private int _writeableStateTimeoutMicroSeconds;
    private ITcpClient _socket;
    private Stream _reader;
    private Stream _writer;
    private ChannelWriter`1<ReadOnlyMemory`1<byte>> _channelWriter;
    private ChannelReader`1<ReadOnlyMemory`1<byte>> _channelReader;
    private Task _writerTask;
    private object _semaphore;
    private Byte[] _frameHeaderBuffer;
    private bool _closed;
    private ArrayPool`1<byte> _pool;
    public AmqpTcpEndpoint Endpoint { get; }
    internal ArrayPool`1<byte> MemoryPool { get; internal set; }
    public EndPoint LocalEndPoint { get; }
    public int LocalPort { get; }
    public EndPoint RemoteEndPoint { get; }
    public int RemotePort { get; }
    unknown TimeSpan ReadTimeout {public set; }
    unknown TimeSpan WriteTimeout {public set; }
    public SocketFrameHandler(AmqpTcpEndpoint endpoint, Func`2<AddressFamily, ITcpClient> socketFactory, TimeSpan connectionTimeout, TimeSpan readTimeout, TimeSpan writeTimeout);
    public sealed virtual AmqpTcpEndpoint get_Endpoint();
    internal ArrayPool`1<byte> get_MemoryPool();
    internal void set_MemoryPool(ArrayPool`1<byte> value);
    public sealed virtual EndPoint get_LocalEndPoint();
    public sealed virtual int get_LocalPort();
    public sealed virtual EndPoint get_RemoteEndPoint();
    public sealed virtual int get_RemotePort();
    public sealed virtual void set_ReadTimeout(TimeSpan value);
    public sealed virtual void set_WriteTimeout(TimeSpan value);
    public sealed virtual void Close();
    public sealed virtual InboundFrame ReadFrame();
    public sealed virtual void SendHeader();
    public sealed virtual void Write(ReadOnlyMemory`1<byte> memory);
    [AsyncStateMachineAttribute("RabbitMQ.Client.Impl.SocketFrameHandler/<WriteLoop>d__35")]
private Task WriteLoop();
    private static bool ShouldTryIPv6(AmqpTcpEndpoint endpoint);
    private ITcpClient ConnectUsingIPv6(AmqpTcpEndpoint endpoint, Func`2<AddressFamily, ITcpClient> socketFactory, TimeSpan timeout);
    private ITcpClient ConnectUsingIPv4(AmqpTcpEndpoint endpoint, Func`2<AddressFamily, ITcpClient> socketFactory, TimeSpan timeout);
    private ITcpClient ConnectUsingAddressFamily(AmqpTcpEndpoint endpoint, Func`2<AddressFamily, ITcpClient> socketFactory, TimeSpan timeout, AddressFamily family);
    private void ConnectOrFail(ITcpClient socket, AmqpTcpEndpoint endpoint, TimeSpan timeout);
}
internal class RabbitMQ.Client.Impl.SslHelper : object {
    private SslOption _sslOption;
    private SslHelper(SslOption sslOption);
    public static Stream TcpUpgrade(Stream tcpStream, SslOption options);
    private X509Certificate CertificateSelectionCallback(object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers);
    private bool CertificateValidationCallback(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
}
internal abstract class RabbitMQ.Client.Impl.StreamProperties : ContentHeaderBase {
    public string ContentEncoding { get; public set; }
    public string ContentType { get; public set; }
    public IDictionary`2<string, object> Headers { get; public set; }
    public byte Priority { get; public set; }
    public AmqpTimestamp Timestamp { get; public set; }
    public abstract virtual string get_ContentEncoding();
    public abstract virtual void set_ContentEncoding(string value);
    public abstract virtual string get_ContentType();
    public abstract virtual void set_ContentType(string value);
    public abstract virtual IDictionary`2<string, object> get_Headers();
    public abstract virtual void set_Headers(IDictionary`2<string, object> value);
    public abstract virtual byte get_Priority();
    public abstract virtual void set_Priority(byte value);
    public abstract virtual AmqpTimestamp get_Timestamp();
    public abstract virtual void set_Timestamp(AmqpTimestamp value);
    public virtual object Clone();
    public abstract virtual void ClearContentEncoding();
    public abstract virtual void ClearContentType();
    public abstract virtual void ClearHeaders();
    public abstract virtual void ClearPriority();
    public abstract virtual void ClearTimestamp();
    public abstract virtual bool IsContentEncodingPresent();
    public abstract virtual bool IsContentTypePresent();
    public abstract virtual bool IsHeadersPresent();
    public abstract virtual bool IsPriorityPresent();
    public abstract virtual bool IsTimestampPresent();
}
[ExtensionAttribute]
internal static class RabbitMQ.Client.Impl.TaskExtensions : object {
    [AsyncStateMachineAttribute("RabbitMQ.Client.Impl.TaskExtensions/<TimeoutAfter>d__0")]
[ExtensionAttribute]
public static Task TimeoutAfter(Task task, TimeSpan timeout);
}
internal class RabbitMQ.Client.Impl.WireFormatting : object {
    public static decimal AmqpToDecimal(byte scale, UInt32 unsignedMantissa);
    public static void DecimalToAmqp(decimal value, Byte& scale, Int32& mantissa);
    public static IList ReadArray(ReadOnlySpan`1<byte> span, Int32& bytesRead);
    public static decimal ReadDecimal(ReadOnlySpan`1<byte> span);
    public static object ReadFieldValue(ReadOnlySpan`1<byte> span, Int32& bytesRead);
    public static Byte[] ReadLongstr(ReadOnlySpan`1<byte> span);
    public static string ReadShortstr(ReadOnlySpan`1<byte> span, Int32& bytesRead);
    public static Dictionary`2<string, object> ReadTable(ReadOnlySpan`1<byte> span, Int32& bytesRead);
    public static AmqpTimestamp ReadTimestamp(ReadOnlySpan`1<byte> span);
    public static int WriteArray(Span`1<byte> span, IList val);
    public static int GetArrayByteCount(IList val);
    public static int WriteDecimal(Span`1<byte> span, decimal value);
    public static int WriteFieldValue(Span`1<byte> span, object value);
    public static int GetFieldValueByteCount(object value);
    public static int WriteLong(Span`1<byte> span, UInt32 val);
    public static int WriteLonglong(Span`1<byte> span, ulong val);
    public static int WriteLongstr(Span`1<byte> span, ReadOnlySpan`1<byte> val);
    public static int WriteShort(Span`1<byte> span, ushort val);
    public static int WriteShortstr(Span`1<byte> span, string val);
    public static int WriteLongstr(Span`1<byte> span, string val);
    public static int WriteTable(Span`1<byte> span, IDictionary val);
    public static int WriteTable(Span`1<byte> span, IDictionary`2<string, object> val);
    public static int GetTableByteCount(IDictionary val);
    public static int GetTableByteCount(IDictionary`2<string, object> val);
    public static int WriteTimestamp(Span`1<byte> span, AmqpTimestamp val);
}
internal abstract class RabbitMQ.Client.Impl.Work : object {
    [CompilerGeneratedAttribute]
private IAsyncBasicConsumer <Consumer>k__BackingField;
    public IAsyncBasicConsumer Consumer { get; }
    public string Context { get; }
    protected Work(IBasicConsumer consumer);
    [CompilerGeneratedAttribute]
public IAsyncBasicConsumer get_Consumer();
    public abstract virtual string get_Context();
    public Task Execute();
    protected abstract virtual Task Execute(IAsyncBasicConsumer consumer);
    public virtual void PostExecute();
}
public interface RabbitMQ.Client.INetworkConnection {
    public int LocalPort { get; }
    public int RemotePort { get; }
    public abstract virtual int get_LocalPort();
    public abstract virtual int get_RemotePort();
}
public interface RabbitMQ.Client.IProtocol {
    public string ApiName { get; }
    public int DefaultPort { get; }
    public int MajorVersion { get; }
    public int MinorVersion { get; }
    public int Revision { get; }
    public abstract virtual string get_ApiName();
    public abstract virtual int get_DefaultPort();
    public abstract virtual int get_MajorVersion();
    public abstract virtual int get_MinorVersion();
    public abstract virtual int get_Revision();
}
public interface RabbitMQ.Client.IRecordedBinding {
    public string Source { get; }
    public string Destination { get; }
    public string RoutingKey { get; }
    public IDictionary`2<string, object> Arguments { get; }
    public abstract virtual string get_Source();
    public abstract virtual string get_Destination();
    public abstract virtual string get_RoutingKey();
    public abstract virtual IDictionary`2<string, object> get_Arguments();
}
public interface RabbitMQ.Client.IRecordedConsumer {
    public string ConsumerTag { get; }
    public string Queue { get; }
    public bool AutoAck { get; }
    public bool Exclusive { get; }
    public IDictionary`2<string, object> Arguments { get; }
    public abstract virtual string get_ConsumerTag();
    public abstract virtual string get_Queue();
    public abstract virtual bool get_AutoAck();
    public abstract virtual bool get_Exclusive();
    public abstract virtual IDictionary`2<string, object> get_Arguments();
}
public interface RabbitMQ.Client.IRecordedExchange {
    public string Name { get; }
    public string Type { get; }
    public bool Durable { get; }
    public bool AutoDelete { get; }
    public IDictionary`2<string, object> Arguments { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Type();
    public abstract virtual bool get_Durable();
    public abstract virtual bool get_AutoDelete();
    public abstract virtual IDictionary`2<string, object> get_Arguments();
}
public interface RabbitMQ.Client.IRecordedQueue {
    public string Name { get; }
    public bool Durable { get; }
    public bool Exclusive { get; }
    public bool AutoDelete { get; }
    public IDictionary`2<string, object> Arguments { get; }
    public bool IsServerNamed { get; }
    public abstract virtual string get_Name();
    public abstract virtual bool get_Durable();
    public abstract virtual bool get_Exclusive();
    public abstract virtual bool get_AutoDelete();
    public abstract virtual IDictionary`2<string, object> get_Arguments();
    public abstract virtual bool get_IsServerNamed();
}
public interface RabbitMQ.Client.IRecoverable {
    [CompilerGeneratedAttribute]
public abstract virtual void add_Recovery(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Recovery(EventHandler`1<EventArgs> value);
}
public interface RabbitMQ.Client.IStreamProperties {
    public string ContentEncoding { get; public set; }
    public string ContentType { get; public set; }
    public IDictionary`2<string, object> Headers { get; public set; }
    public byte Priority { get; public set; }
    public AmqpTimestamp Timestamp { get; public set; }
    public abstract virtual string get_ContentEncoding();
    public abstract virtual void set_ContentEncoding(string value);
    public abstract virtual string get_ContentType();
    public abstract virtual void set_ContentType(string value);
    public abstract virtual IDictionary`2<string, object> get_Headers();
    public abstract virtual void set_Headers(IDictionary`2<string, object> value);
    public abstract virtual byte get_Priority();
    public abstract virtual void set_Priority(byte value);
    public abstract virtual AmqpTimestamp get_Timestamp();
    public abstract virtual void set_Timestamp(AmqpTimestamp value);
    public abstract virtual void ClearContentEncoding();
    public abstract virtual void ClearContentType();
    public abstract virtual void ClearHeaders();
    public abstract virtual void ClearPriority();
    public abstract virtual void ClearTimestamp();
    public abstract virtual bool IsContentEncodingPresent();
    public abstract virtual bool IsContentTypePresent();
    public abstract virtual bool IsHeadersPresent();
    public abstract virtual bool IsPriorityPresent();
    public abstract virtual bool IsTimestampPresent();
}
public interface RabbitMQ.Client.ITcpClient {
    public bool Connected { get; }
    public TimeSpan ReceiveTimeout { get; public set; }
    public Socket Client { get; }
    public abstract virtual bool get_Connected();
    public abstract virtual TimeSpan get_ReceiveTimeout();
    public abstract virtual void set_ReceiveTimeout(TimeSpan value);
    public abstract virtual Socket get_Client();
    public abstract virtual Task ConnectAsync(string host, int port);
    public abstract virtual NetworkStream GetStream();
    public abstract virtual void Close();
}
internal static class RabbitMQ.Client.Logging.ESLog : object {
    public static void Info(string message);
    public static void Info(string message, Object[] args);
    public static void Warn(string message);
    public static void Warn(string message, Object[] args);
    public static void Error(string message, Exception ex);
    public static void Error(string message, Exception ex, Object[] args);
}
[EventSourceAttribute]
public class RabbitMQ.Client.Logging.RabbitMqClientEventSource : EventSource {
    public static RabbitMqClientEventSource Log;
    private static RabbitMqClientEventSource();
    [EventAttribute("1")]
public void Info(string message);
    [EventAttribute("2")]
public void Warn(string message);
    [EventAttribute("3")]
public void Error(string message, RabbitMqExceptionDetail ex);
    [NonEventAttribute]
public void Error(string message, Exception ex);
}
public class RabbitMQ.Client.Logging.RabbitMqConsoleEventListener : EventListener {
    protected virtual void OnEventWritten(EventWrittenEventArgs eventData);
    public virtual void Dispose();
}
[EventDataAttribute]
public class RabbitMQ.Client.Logging.RabbitMqExceptionDetail : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StackTrace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InnerException>k__BackingField;
    public string Type { get; private set; }
    public string Message { get; private set; }
    public string StackTrace { get; private set; }
    public string InnerException { get; private set; }
    public RabbitMqExceptionDetail(Exception ex);
    public RabbitMqExceptionDetail(IDictionary`2<string, object> ex);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_StackTrace();
    [CompilerGeneratedAttribute]
private void set_StackTrace(string value);
    [CompilerGeneratedAttribute]
public string get_InnerException();
    [CompilerGeneratedAttribute]
private void set_InnerException(string value);
    public virtual string ToString();
}
internal class RabbitMQ.Client.NoOpCredentialsRefresher : object {
    public sealed virtual ICredentialsProvider Register(ICredentialsProvider provider, NotifyCredentialRefreshed callback);
    public sealed virtual bool Unregister(ICredentialsProvider provider);
}
public class RabbitMQ.Client.NotifyCredentialRefreshed : MulticastDelegate {
    public NotifyCredentialRefreshed(object object, IntPtr method);
    public virtual void Invoke(bool succesfully);
    public virtual IAsyncResult BeginInvoke(bool succesfully, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class RabbitMQ.Client.PlainMechanism : object {
    public sealed virtual Byte[] handleChallenge(Byte[] challenge, IConnectionFactory factory);
}
public class RabbitMQ.Client.PlainMechanismFactory : object {
    public string Name { get; }
    public sealed virtual string get_Name();
    public sealed virtual IAuthMechanism GetInstance();
}
public static class RabbitMQ.Client.Protocols : object {
    public static IProtocol AMQP_0_9_1 { get; }
    public static IProtocol DefaultProtocol { get; }
    public static IProtocol get_AMQP_0_9_1();
    public static IProtocol get_DefaultProtocol();
}
public class RabbitMQ.Client.PublicationAddress : object {
    public static Regex PSEUDO_URI_PARSER;
    [CompilerGeneratedAttribute]
private string <ExchangeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExchangeType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RoutingKey>k__BackingField;
    public string ExchangeName { get; private set; }
    public string ExchangeType { get; private set; }
    public string RoutingKey { get; private set; }
    public PublicationAddress(string exchangeType, string exchangeName, string routingKey);
    private static PublicationAddress();
    [CompilerGeneratedAttribute]
public string get_ExchangeName();
    [CompilerGeneratedAttribute]
private void set_ExchangeName(string value);
    [CompilerGeneratedAttribute]
public string get_ExchangeType();
    [CompilerGeneratedAttribute]
private void set_ExchangeType(string value);
    [CompilerGeneratedAttribute]
public string get_RoutingKey();
    [CompilerGeneratedAttribute]
private void set_RoutingKey(string value);
    public static PublicationAddress Parse(string uriLikeString);
    public static bool TryParse(string uriLikeString, PublicationAddress& result);
    public virtual string ToString();
}
public class RabbitMQ.Client.QueueDeclareOk : object {
    [CompilerGeneratedAttribute]
private UInt32 <ConsumerCount>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MessageCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QueueName>k__BackingField;
    public UInt32 ConsumerCount { get; private set; }
    public UInt32 MessageCount { get; private set; }
    public string QueueName { get; private set; }
    public QueueDeclareOk(string queueName, UInt32 messageCount, UInt32 consumerCount);
    [CompilerGeneratedAttribute]
public UInt32 get_ConsumerCount();
    [CompilerGeneratedAttribute]
private void set_ConsumerCount(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_MessageCount();
    [CompilerGeneratedAttribute]
private void set_MessageCount(UInt32 value);
    [CompilerGeneratedAttribute]
public string get_QueueName();
    [CompilerGeneratedAttribute]
private void set_QueueName(string value);
    public static string op_Implicit(QueueDeclareOk declareOk);
}
public class RabbitMQ.Client.ShutdownEventArgs : EventArgs {
    private Exception _exception;
    [CompilerGeneratedAttribute]
private object <Cause>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <ClassId>k__BackingField;
    [CompilerGeneratedAttribute]
private ShutdownInitiator <Initiator>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MethodId>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <ReplyCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReplyText>k__BackingField;
    public Exception Exception { get; }
    public object Cause { get; private set; }
    public ushort ClassId { get; private set; }
    public ShutdownInitiator Initiator { get; private set; }
    public ushort MethodId { get; private set; }
    public ushort ReplyCode { get; private set; }
    public string ReplyText { get; private set; }
    public ShutdownEventArgs(ShutdownInitiator initiator, ushort replyCode, string replyText, object cause);
    public ShutdownEventArgs(ShutdownInitiator initiator, ushort replyCode, string replyText, ushort classId, ushort methodId, object cause);
    public ShutdownEventArgs(ShutdownInitiator initiator, ushort replyCode, string replyText, Exception exception);
    public Exception get_Exception();
    [CompilerGeneratedAttribute]
public object get_Cause();
    [CompilerGeneratedAttribute]
private void set_Cause(object value);
    [CompilerGeneratedAttribute]
public ushort get_ClassId();
    [CompilerGeneratedAttribute]
private void set_ClassId(ushort value);
    [CompilerGeneratedAttribute]
public ShutdownInitiator get_Initiator();
    [CompilerGeneratedAttribute]
private void set_Initiator(ShutdownInitiator value);
    [CompilerGeneratedAttribute]
public ushort get_MethodId();
    [CompilerGeneratedAttribute]
private void set_MethodId(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_ReplyCode();
    [CompilerGeneratedAttribute]
private void set_ReplyCode(ushort value);
    [CompilerGeneratedAttribute]
public string get_ReplyText();
    [CompilerGeneratedAttribute]
private void set_ReplyText(string value);
    public virtual string ToString();
}
public enum RabbitMQ.Client.ShutdownInitiator : Enum {
    public int value__;
    public static ShutdownInitiator Application;
    public static ShutdownInitiator Library;
    public static ShutdownInitiator Peer;
}
public class RabbitMQ.Client.ShutdownReportEntry : object {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public string Description { get; public set; }
    public Exception Exception { get; public set; }
    public ShutdownReportEntry(string description, Exception exception);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(Exception value);
    public virtual string ToString();
}
public class RabbitMQ.Client.SslOption : object {
    private X509CertificateCollection _certificateCollection;
    [CompilerGeneratedAttribute]
private SslPolicyErrors <AcceptablePolicyErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertPassphrase>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertPath>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalCertificateSelectionCallback <CertificateSelectionCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteCertificateValidationCallback <CertificateValidationCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckCertificateRevocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerName>k__BackingField;
    [CompilerGeneratedAttribute]
private SslProtocols <Version>k__BackingField;
    public SslPolicyErrors AcceptablePolicyErrors { get; public set; }
    public string CertPassphrase { get; public set; }
    public string CertPath { get; public set; }
    public LocalCertificateSelectionCallback CertificateSelectionCallback { get; public set; }
    public RemoteCertificateValidationCallback CertificateValidationCallback { get; public set; }
    public X509CertificateCollection Certs { get; public set; }
    public bool CheckCertificateRevocation { get; public set; }
    public bool Enabled { get; public set; }
    public string ServerName { get; public set; }
    public SslProtocols Version { get; public set; }
    public SslOption(string serverName, string certificatePath, bool enabled);
    [CompilerGeneratedAttribute]
public SslPolicyErrors get_AcceptablePolicyErrors();
    [CompilerGeneratedAttribute]
public void set_AcceptablePolicyErrors(SslPolicyErrors value);
    [CompilerGeneratedAttribute]
public string get_CertPassphrase();
    [CompilerGeneratedAttribute]
public void set_CertPassphrase(string value);
    [CompilerGeneratedAttribute]
public string get_CertPath();
    [CompilerGeneratedAttribute]
public void set_CertPath(string value);
    [CompilerGeneratedAttribute]
public LocalCertificateSelectionCallback get_CertificateSelectionCallback();
    [CompilerGeneratedAttribute]
public void set_CertificateSelectionCallback(LocalCertificateSelectionCallback value);
    [CompilerGeneratedAttribute]
public RemoteCertificateValidationCallback get_CertificateValidationCallback();
    [CompilerGeneratedAttribute]
public void set_CertificateValidationCallback(RemoteCertificateValidationCallback value);
    public X509CertificateCollection get_Certs();
    public void set_Certs(X509CertificateCollection value);
    [CompilerGeneratedAttribute]
public bool get_CheckCertificateRevocation();
    [CompilerGeneratedAttribute]
public void set_CheckCertificateRevocation(bool value);
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public string get_ServerName();
    [CompilerGeneratedAttribute]
public void set_ServerName(string value);
    [CompilerGeneratedAttribute]
public SslProtocols get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(SslProtocols value);
    internal SslProtocols UseFallbackTlsVersions();
}
public class RabbitMQ.Client.TcpClientAdapter : object {
    private Socket _sock;
    public Socket Client { get; }
    public bool Connected { get; }
    public TimeSpan ReceiveTimeout { get; public set; }
    public TcpClientAdapter(Socket socket);
    [AsyncStateMachineAttribute("RabbitMQ.Client.TcpClientAdapter/<ConnectAsync>d__2")]
public virtual Task ConnectAsync(string host, int port);
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual NetworkStream GetStream();
    public virtual Socket get_Client();
    public virtual bool get_Connected();
    public virtual TimeSpan get_ReceiveTimeout();
    public virtual void set_ReceiveTimeout(TimeSpan value);
    private void AssertSocket();
    public static IPAddress GetMatchingHost(IReadOnlyCollection`1<IPAddress> addresses, AddressFamily addressFamily);
}
public class RabbitMQ.Client.TimerBasedCredentialRefresher : object {
    private ConcurrentDictionary`2<ICredentialsProvider, Timer> _registrations;
    public sealed virtual ICredentialsProvider Register(ICredentialsProvider provider, NotifyCredentialRefreshed callback);
    public sealed virtual bool Unregister(ICredentialsProvider provider);
    private Timer scheduleTimer(ICredentialsProvider provider, NotifyCredentialRefreshed callback);
}
[EventSourceAttribute]
public class RabbitMQ.Client.TimerBasedCredentialRefresherEventSource : EventSource {
    [CompilerGeneratedAttribute]
private static TimerBasedCredentialRefresherEventSource <Log>k__BackingField;
    public static TimerBasedCredentialRefresherEventSource Log { get; }
    private static TimerBasedCredentialRefresherEventSource();
    [CompilerGeneratedAttribute]
public static TimerBasedCredentialRefresherEventSource get_Log();
    [EventAttribute("1")]
public void Registered(string name);
    [EventAttribute("2")]
public void Unregistered(string name);
    [EventAttribute("3")]
public void ScheduledTimer(string name, double interval);
    [EventAttribute("4")]
public void TriggeredTimer(string name);
    [EventAttribute("5")]
public void RefreshedCredentials(string name, bool succesfully);
    [EventAttribute("6")]
public void AlreadyRegistered(string name);
}
public class RabbitMQ.Client.TopologyRecoveryExceptionHandler : object {
    private static Func`3<IRecordedExchange, Exception, bool> s_defaultExchangeExceptionCondition;
    private static Func`3<IRecordedQueue, Exception, bool> s_defaultQueueExceptionCondition;
    private static Func`3<IRecordedBinding, Exception, bool> s_defaultBindingExceptionCondition;
    private static Func`3<IRecordedConsumer, Exception, bool> s_defaultConsumerExceptionCondition;
    private Func`3<IRecordedExchange, Exception, bool> _exchangeRecoveryExceptionCondition;
    private Func`3<IRecordedQueue, Exception, bool> _queueRecoveryExceptionCondition;
    private Func`3<IRecordedBinding, Exception, bool> _bindingRecoveryExceptionCondition;
    private Func`3<IRecordedConsumer, Exception, bool> _consumerRecoveryExceptionCondition;
    private Action`3<IRecordedExchange, Exception, IConnection> _exchangeRecoveryExceptionHandler;
    private Action`3<IRecordedQueue, Exception, IConnection> _queueRecoveryExceptionHandler;
    private Action`3<IRecordedBinding, Exception, IConnection> _bindingRecoveryExceptionHandler;
    private Action`3<IRecordedConsumer, Exception, IConnection> _consumerRecoveryExceptionHandler;
    public Func`3<IRecordedExchange, Exception, bool> ExchangeRecoveryExceptionCondition { get; public set; }
    public Func`3<IRecordedQueue, Exception, bool> QueueRecoveryExceptionCondition { get; public set; }
    public Func`3<IRecordedBinding, Exception, bool> BindingRecoveryExceptionCondition { get; public set; }
    public Func`3<IRecordedConsumer, Exception, bool> ConsumerRecoveryExceptionCondition { get; public set; }
    public Action`3<IRecordedExchange, Exception, IConnection> ExchangeRecoveryExceptionHandler { get; public set; }
    public Action`3<IRecordedQueue, Exception, IConnection> QueueRecoveryExceptionHandler { get; public set; }
    public Action`3<IRecordedBinding, Exception, IConnection> BindingRecoveryExceptionHandler { get; public set; }
    public Action`3<IRecordedConsumer, Exception, IConnection> ConsumerRecoveryExceptionHandler { get; public set; }
    private static TopologyRecoveryExceptionHandler();
    public Func`3<IRecordedExchange, Exception, bool> get_ExchangeRecoveryExceptionCondition();
    public void set_ExchangeRecoveryExceptionCondition(Func`3<IRecordedExchange, Exception, bool> value);
    public Func`3<IRecordedQueue, Exception, bool> get_QueueRecoveryExceptionCondition();
    public void set_QueueRecoveryExceptionCondition(Func`3<IRecordedQueue, Exception, bool> value);
    public Func`3<IRecordedBinding, Exception, bool> get_BindingRecoveryExceptionCondition();
    public void set_BindingRecoveryExceptionCondition(Func`3<IRecordedBinding, Exception, bool> value);
    public Func`3<IRecordedConsumer, Exception, bool> get_ConsumerRecoveryExceptionCondition();
    public void set_ConsumerRecoveryExceptionCondition(Func`3<IRecordedConsumer, Exception, bool> value);
    public Action`3<IRecordedExchange, Exception, IConnection> get_ExchangeRecoveryExceptionHandler();
    public void set_ExchangeRecoveryExceptionHandler(Action`3<IRecordedExchange, Exception, IConnection> value);
    public Action`3<IRecordedQueue, Exception, IConnection> get_QueueRecoveryExceptionHandler();
    public void set_QueueRecoveryExceptionHandler(Action`3<IRecordedQueue, Exception, IConnection> value);
    public Action`3<IRecordedBinding, Exception, IConnection> get_BindingRecoveryExceptionHandler();
    public void set_BindingRecoveryExceptionHandler(Action`3<IRecordedBinding, Exception, IConnection> value);
    public Action`3<IRecordedConsumer, Exception, IConnection> get_ConsumerRecoveryExceptionHandler();
    public void set_ConsumerRecoveryExceptionHandler(Action`3<IRecordedConsumer, Exception, IConnection> value);
}
public class RabbitMQ.Client.TopologyRecoveryFilter : object {
    private static Func`2<IRecordedExchange, bool> s_defaultExchangeFilter;
    private static Func`2<IRecordedQueue, bool> s_defaultQueueFilter;
    private static Func`2<IRecordedBinding, bool> s_defaultBindingFilter;
    private static Func`2<IRecordedConsumer, bool> s_defaultConsumerFilter;
    private Func`2<IRecordedExchange, bool> _exchangeFilter;
    private Func`2<IRecordedQueue, bool> _queueFilter;
    private Func`2<IRecordedBinding, bool> _bindingFilter;
    private Func`2<IRecordedConsumer, bool> _consumerFilter;
    public Func`2<IRecordedExchange, bool> ExchangeFilter { get; public set; }
    public Func`2<IRecordedQueue, bool> QueueFilter { get; public set; }
    public Func`2<IRecordedBinding, bool> BindingFilter { get; public set; }
    public Func`2<IRecordedConsumer, bool> ConsumerFilter { get; public set; }
    private static TopologyRecoveryFilter();
    public Func`2<IRecordedExchange, bool> get_ExchangeFilter();
    public void set_ExchangeFilter(Func`2<IRecordedExchange, bool> value);
    public Func`2<IRecordedQueue, bool> get_QueueFilter();
    public void set_QueueFilter(Func`2<IRecordedQueue, bool> value);
    public Func`2<IRecordedBinding, bool> get_BindingFilter();
    public void set_BindingFilter(Func`2<IRecordedBinding, bool> value);
    public Func`2<IRecordedConsumer, bool> get_ConsumerFilter();
    public void set_ConsumerFilter(Func`2<IRecordedConsumer, bool> value);
}
internal class RabbitMQ.Util.BlockingCell`1 : object {
    private ManualResetEventSlim _manualResetEventSlim;
    private T _value;
    public void ContinueWithValue(T value);
    public T WaitForValue(TimeSpan timeout);
    public T WaitForValue();
}
internal static class RabbitMQ.Util.DebugUtil : object {
    public static void Dump(Byte[] bytes);
    public static void Dump(Byte[] bytes, TextWriter writer);
    public static void DumpKeyValue(string key, object value, TextWriter writer, int indent);
    public static void DumpProperties(object value, TextWriter writer, int indent);
}
internal class RabbitMQ.Util.Either`2 : object {
    [CompilerGeneratedAttribute]
private EitherAlternative <Alternative>k__BackingField;
    [CompilerGeneratedAttribute]
private L <LeftValue>k__BackingField;
    [CompilerGeneratedAttribute]
private R <RightValue>k__BackingField;
    public EitherAlternative Alternative { get; private set; }
    public L LeftValue { get; private set; }
    public R RightValue { get; private set; }
    private Either`2(EitherAlternative alternative, L valueL, R valueR);
    [CompilerGeneratedAttribute]
public EitherAlternative get_Alternative();
    [CompilerGeneratedAttribute]
private void set_Alternative(EitherAlternative value);
    [CompilerGeneratedAttribute]
public L get_LeftValue();
    [CompilerGeneratedAttribute]
private void set_LeftValue(L value);
    [CompilerGeneratedAttribute]
public R get_RightValue();
    [CompilerGeneratedAttribute]
private void set_RightValue(R value);
    public static Either`2<L, R> Left(L value);
    public static Either`2<L, R> Right(R value);
}
internal enum RabbitMQ.Util.EitherAlternative : Enum {
    public int value__;
    public static EitherAlternative Left;
    public static EitherAlternative Right;
}
internal class RabbitMQ.Util.IntAllocator : object {
    private Int32[] _unsorted;
    private IntervalList _base;
    private int _unsortedCount;
    public IntAllocator(int start, int end);
    public int Allocate();
    public void Free(int id);
    public bool Reserve(int id);
    private void Flush();
}
internal static class RabbitMQ.Util.NetworkOrderDeserializer : object {
    internal static double ReadDouble(ReadOnlySpan`1<byte> span);
    internal static short ReadInt16(ReadOnlySpan`1<byte> span);
    internal static int ReadInt32(ReadOnlySpan`1<byte> span);
    internal static long ReadInt64(ReadOnlySpan`1<byte> span);
    internal static float ReadSingle(ReadOnlySpan`1<byte> span);
    internal static ushort ReadUInt16(ReadOnlySpan`1<byte> span);
    internal static UInt32 ReadUInt32(ReadOnlySpan`1<byte> span);
    internal static ulong ReadUInt64(ReadOnlySpan`1<byte> span);
}
internal static class RabbitMQ.Util.NetworkOrderSerializer : object {
    internal static void WriteDouble(Span`1<byte> span, double val);
    internal static void WriteInt16(Span`1<byte> span, short val);
    internal static void WriteInt32(Span`1<byte> span, int val);
    internal static void WriteInt64(Span`1<byte> span, long val);
    internal static void WriteSingle(Span`1<byte> span, float val);
    internal static void WriteUInt16(Span`1<byte> span, ushort val);
    internal static void WriteUInt32(Span`1<byte> span, UInt32 val);
    internal static void WriteUInt64(Span`1<byte> span, ulong val);
}
internal class RabbitMQ.Util.SetQueue`1 : object {
    private HashSet`1<T> _members;
    private LinkedList`1<T> _queue;
    public bool Enqueue(T item);
    public T Dequeue();
    public bool Contains(T item);
    public bool IsEmpty();
    public bool Remove(T item);
    public void Clear();
}
internal class RabbitMQ.Util.SharedQueue : SharedQueue`1<object> {
}
internal class RabbitMQ.Util.SharedQueue`1 : object {
    protected bool m_isOpen;
    protected Queue`1<T> m_queue;
    public void Close();
    public T Dequeue();
    public bool Dequeue(TimeSpan timeout, T& result);
    public T DequeueNoWait(T defaultValue);
    public void Enqueue(T o);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private void EnsureIsOpen();
}
internal class RabbitMQ.Util.SharedQueueEnumerator`1 : ValueType {
    private SharedQueue`1<T> _queue;
    private T _current;
    private object System.Collections.IEnumerator.Current { get; }
    private T System.Collections.Generic.IEnumerator<T>.Current { get; }
    public SharedQueueEnumerator`1(SharedQueue`1<T> queue);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override T System.Collections.Generic.IEnumerator<T>.get_Current();
    public sealed virtual void Dispose();
    private sealed virtual override bool System.Collections.IEnumerator.MoveNext();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
[DefaultMemberAttribute("Item")]
internal class RabbitMQ.Util.SynchronizedList`1 : object {
    private IList`1<T> _list;
    [CompilerGeneratedAttribute]
private object <SyncRoot>k__BackingField;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public object SyncRoot { get; private set; }
    internal SynchronizedList`1(IList`1<T> list);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    [CompilerGeneratedAttribute]
public object get_SyncRoot();
    [CompilerGeneratedAttribute]
private void set_SyncRoot(object value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
